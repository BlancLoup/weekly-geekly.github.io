<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Template Description Language Snakeskin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is Frank, a snake-cowboy who loves templates. 



 Hello! I want to talk about my development - the programming language of text templates "Snake...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Template Description Language Snakeskin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://camo.githubusercontent.com/387c4de9d31bc82182b92747a7e0c6e54e114500/687474703a2f2f6b6f62657a7a7a612e636f6d2f66696c65732f736e616b65736b696e2f6c6f676f2e7376673f31" alt="Snakeskin" width="190"><br><p>  <em>This is Frank, a snake-cowboy who loves templates.</em> </p><br><hr><br><p>  Hello!  I want to talk about my development - the programming language of text templates "Snakeskin".  The project is more than three years old, with all childhood illnesses, I suppose, he successfully recovered from his illness (and was cured), so I want to share the result. </p><br><p>  <a href="http://codepen.io/kobezzza/pen/zrJNXx">Demo</a> </p><br><p>  <a href="https://github.com/SnakeskinTpl/Snakeskin">Main repository</a> </p><br><p>  <a href="http://snakeskintpl.github.io/docs/index-ru.html">Documentation</a> </p><br><p>  <a href="https://github.com/SnakeskinTpl">Plug-ins for Gulp, Grunt, Webpack and others</a> </p><br><p>  <a href="https://gitter.im/SnakeskinTpl/Snakeskin">Gitter</a> - here you can ask any question </p><a name="habracut"></a><br><h2>  A bit of history </h2><br><p>  When I worked at Yandex (four years ago), one of the main topics for heated discussions at coffee points we had with colleagues were template makers: we discussed the advantages and disadvantages of existing solutions, some even developed their own. </p><br><p>  In the department, TemplateToolkit2 was the main one - a template engine popular in particular among Perl developers, and the client used the simplest MicroTemplate (by John Rezig).  Even at that time, XSLT-like engines were actively forcing, but for a number of reasons (discussion of which is beyond the scope of this article) they did not fit us.  From time to time we experimented with others: Handlebars, Dust, Closure Templates, plus our bikes, of course ... All this led to the presence of a whole zoo of template engines in the project. </p><br><p>  My favorite was Google Closure Templates: it was close to me as a programmer, because the template was positioned as a function that simply returns a string, plus very good features for those times;  but I was very upset by the need to edit the Java code in order to add some banal filter, and the translation speed was not so hot (it was really felt). </p><br><p>  And I wanted to make my own Closure Templates <del>  with blackjack and whores </del>  : it is natural that it was written in JS and, as a result, open to modifications without having to know Java.  Plus, I liked the template inheritance model, based on static blocks, which I spied in Django Templates (hence the name - reference to Python) - this was the basis of the existing inheritance system. </p><br><p>  The prototype I sketched for three days: it was a terrible hard-code on regulars in seven hundred lines of code.  I played a little with the result, shared it with my colleagues, got some feedback, but decided to move on.  Refactor this case, corrected bugs, added <del>  new ones </del>  opportunities.  After a week of development, I released version 2 - in fact, the same hardcode on regulars, but more stable and fichastey.  It could already be used. </p><br><p>  After working for a while with the result and releasing a dozen updates, I rubbed my hands and sat at the computer with the thought ‚ÄúIt's time to make things right‚Äù, and a month later I released the 3rd version: I threw out the hardcode, rewrote the code on ES6 ( at that time there were no normal translators, so I also wrote my own translator (again, with terrible hardcodes on regulars - yes, I love regulars)), added the construction of the tree during parsing and many new features. </p><br><p>  The version came out stable, powerful and, in fact, was a Closure Templates on steroids.  I was pleased with the result and began to use Snakeskin in my personal projects, occasionally releasing new updates and patches. </p><br><p>  A little later, I met HAML and Jade, I liked their approach to syntax, and it was decided to add something similar to Snakeskin (the result of this decision was the Jade-like syntax).  After several months of active development, I released the fourth version, which became a truly milestone in the history of the language and determined its further development.  The fifth and sixth were nothing more than a modification of the fourth version, but with the breaking changes that were necessary, and since I chose <a href="http://semver.org/">SemVer</a> as the versioning pattern for Snakeskin, I had to use the major version. </p><br><p>  I used SS6 for quite a long time and in various projects, my friends and colleagues also began to use it - as a result, after some time, a list of complaints had accumulated - not very long, but still: there were many features, they appeared in a rather chaotic manner , and ‚Äúconflicts‚Äù between directives became visible.  The reason for this was the absence of any initial specification of the language - the development was proceeding as the appearance of the "hoteles". </p><br><p>  I decided that it was impossible to continue living like this - you need to standardize everything and remove garbage.  The development dragged on for a year and a half (of which, however, the active was a maximum of six months - the lack of free time had an effect), but in the end, the most stable and well thought out release of Snakeskin turned out: version 7;  and i'm sincerely proud of him. </p><br><h2>  First look </h2><br><p>  The most suitable for Snakeskin seems to me the definition that it is just ‚Äúsugar‚Äù over JS, like CoffeeScript or TypeScript, but it has a rather narrow specialization: writing templates.  Of course, it is possible to write on the SS at least the entire application as a whole, but it will be, heh, not very convenient.  SS is intended for use with the primary language - mainly JS: </p><br><p>  <strong>select.ss</strong> </p><br><pre><code class="hljs pgsql">- namespace <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>) &lt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> =&gt; el &lt; <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ${el.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {el.label}</code> </pre> <br><p>  <strong>select.js</strong> </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'select.ss'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> { constructor(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>) { this.template = <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>.main(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>); } } const newSelect = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>([{<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, label: <span class="hljs-string"><span class="hljs-string">''</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, label: <span class="hljs-string"><span class="hljs-string">''</span></span>}])</code> </pre> <br><p>  Here, the main file on JS is connected as a module file on Snakeskin (for example, a <a href="https://github.com/SnakeskinTpl/snakeskin-loader">plug-in for WebPack</a> gives such a seamless integration).  From it we import the namespace <code>select</code> , and declare the class <code>Select</code> .  When creating the <code>Select</code> instance, we execute the <code>main</code> function (into which the <code>main</code> template was translated), and assign the result of its work to the <code>template</code> property - for <code>newSelect</code> it will be like this: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  As you can see, SS is translated to JS (if specifically, to ES5), which is then very easy to use in the main code. </p><br><p>  If we talk about why I started doing Snakeskin - the main motivation was the desire to have a template language with powerful code reuse capabilities that can be used on the server and on the client at the same time without having to change the template code.  Then, of course, new requirements for the language began to appear and ideas in the style of ‚Äúshould I add such a feature here‚Äù - all this, creatively and logically meaningful, and made Snakeskin the way you see it now. </p><br><p>  One of the ‚Äútime requirements‚Äù, for example, was the need for seamless integration with frameworks and libraries that have their own template language (like Angular or React ‚Äî well, I prefer <a href="http://vuejs.org/">Vue</a> ) ‚Äîand now Snakeskin is doing great. </p><br><p>  <strong>An example of using SS to create Angular templates:</strong> </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">- namespace myApp - template main() </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Name:</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">text</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-model</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">yourName</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">Enter</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">here</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">hr</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">h1</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Hello</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{yourName}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">!</span></span></span></span></code> </pre> <br><p>  <strong>The result of the <code>main</code></strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> Name: <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"yourName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Enter a name here"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> Hello {{yourName}}! <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Snakeskin significantly reduces the amount of code, allows you to reuse layout elements (through inheritance, composition, impurities, etc.), while Angular implements data-binding.  From a technical point of view, SS generates a template that then uses Angular. </p><br><h2>  Where to use </h2><br><ul><li>  <strong>Server templateization</strong> - everything is simple: we connect SS as a module, compile the file - and node.  js works with its templates as functions: </li></ul><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ss = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'snakeskin'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    //     - const tpls = ss.compileFile('./myTpls.ss'); http.createServer((req, res) =&gt; { res.writeHead(200, {'Content-Type': 'text/html'}); //   foo    res.write(tpls.foo('bar', 'bla')); res.end(); }).listen(8888);</span></span></code> </pre> <br><p>  Of course, in practice it will be a server-side framework like Express or Koa, but it doesn‚Äôt matter.  Also, templates can (and preferably) be pre-translated using a <a href="https://github.com/SnakeskinTpl/gulp-snakeskin">plugin for Gulp</a> or <a href="https://github.com/SnakeskinTpl/grunt-snakeskin">Grunt</a> and include the resulting files, well, or, as above, use a WebPack. </p><br><ul><li><p>  <strong>Static site generation</strong> : plugins have the option to call the compiled template at the time of translation and return the result of its work.  The plugin will <a href="http://snakeskintpl.github.io/docs/api.html">calculate the main template itself</a> , or you can specify it explicitly. </p><br></li><li>  <strong>Using templates translated into JS on the client</strong> : ‚Äúcompiled‚Äù modules can be connected via an external <code>&lt;script&gt;</code> , or as a module (using Webpack, Browserify, RequireJS, or any other module management system). </li></ul><br><h2>  Overview of the language </h2><br><p>  Here I will go over the basic concepts, and if you have questions, welcome to the <a href="http://snakeskintpl.github.io/docs/index-ru.html">documentation</a> or to <a href="https://gitter.im/SnakeskinTpl/Snakeskin">Gitter</a> . </p><br><h3>  Main </h3><br><h4>  Templates </h4><br><p>  As already mentioned several times, the Snakeskin template after the broadcast becomes a JavaScript function: </p><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main() Hello world!</code> </pre> <br><p>  after the broadcast will turn into something like: </p><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.myApp === <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myApp = <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.myApp = {}; } <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.myApp.main = <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>; }</code> </pre> <br><p>  Of course, this is a simplified code, but in general it looks like this. </p><br><h4>  Syntax </h4><br><p>  SS supports 2 different types of syntax: </p><br><ul><li>  <strong>Classic</strong> : directives are enclosed in braces;  block (which may contain another code on SS) must be explicitly closed: </li></ul><br><pre> <code class="hljs pgsql">{namespace myApp} {<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'world'</span></span>)} Hello {<span class="hljs-type"><span class="hljs-type">name</span></span>}! {/<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>}</code> </pre> <br><p>  This mode is useful for generating text with control spaces, for example <del>  Python code </del>  Markdown. </p><br><p>  <em>Note</em> : to generate text where curly brackets are often used, there is a <a href="http://snakeskintpl.github.io/docs/guide-ru.html">special mechanism</a> in SS. </p><br><ul><li>  <strong>Jade-like</strong> : is based on control spaces and is similar to Jade (hence the name).  The example above using it will look like this: </li></ul><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'world'</span></span>) Hello {<span class="hljs-type"><span class="hljs-type">name</span></span>}!</code> </pre> <br><p>  The main advantages of this syntax are brevity and clarity.  Ideal for generating XML-like structures. </p><br><p>  SS also supports mixed syntax: </p><br><pre> <code class="hljs pgsql">- namespace myApp {<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> hello(<span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'world'</span></span>)} Hello {<span class="hljs-type"><span class="hljs-type">name</span></span>}! {/<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>} - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-type"><span class="hljs-type">name</span></span>) += myApp.hello(<span class="hljs-type"><span class="hljs-type">name</span></span>)</code> </pre> <br><p>  <a href="http://snakeskintpl.github.io/docs/guide-ru.html">Learn more about syntax and its types</a> . </p><br><h3>  Code-reuse tools </h3><br><h4>  Inheritance </h4><br><p>  In SS, each template is a class, that is, it has methods and properties, and it can be inherited from another template.  A child template can override inherited parent methods and properties and add new ones. </p><br><p>  <strong>An example of template inheritance</strong> . </p><br><pre> <code class="hljs ruby">- namespace myApp /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  sayHello  base /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  SS      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     --    , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     - block base-&gt;sayHello(name = <span class="hljs-string"><span class="hljs-string">'world'</span></span>) Hello {name}! - template base() - doctype &lt; html &lt; head /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   head /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        - block head &lt; title /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">`title`</span></span>,    - title = <span class="hljs-string"><span class="hljs-string">' '</span></span> ? &lt; body - block body /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   sayHello += <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.sayHello() /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    - block child-&gt;sayHello() /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   sayHello  - <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Hello people! <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    - block child-&gt;go() Let's go! /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  child   base - template child() extends myApp.base /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   - title = <span class="hljs-string"><span class="hljs-string">' '</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    - block body - <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> += <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.go()</code> </pre> <br><p>  <strong>The result of the <code>child</code></strong> : </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> Hello world! Hello people! Let's go! <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  When inheriting a template, the input parameters, the decorators of the template, and various modifiers are also inherited - <a href="http://snakeskintpl.github.io/docs/guide-ru.html">here</a> you can read more. </p><br><h4>  Composition </h4><br><p>  Since all the templates in Snakeskin are functions, then, naturally, any template can call any other template: for this is the <a href="http://snakeskintpl.github.io/docs/api-ru.html"><code>call</code></a> directive. </p><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> hello(<span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'world'</span></span>) Hello {<span class="hljs-type"><span class="hljs-type">name</span></span>}! - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-type"><span class="hljs-type">name</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> myApp.hello(<span class="hljs-type"><span class="hljs-type">name</span></span>) ///    += myApp.hello(<span class="hljs-type"><span class="hljs-type">name</span></span>)</code> </pre> <br><h4>  Pattern as value </h4><br><p>  In Snakeskin, you can assign a template to a variable or property of an object, pass it as an argument to a function, and so on. </p><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> wrap(content) &lt; .<span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span> {content} - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main(<span class="hljs-type"><span class="hljs-type">name</span></span>) += myApp.wrap() &lt; .hello Hello world!</code> </pre> <br><p>  <strong><code>main</code> execution result</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrapper"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hello"</span></span></span><span class="hljs-tag">&gt;</span></span> Hello world! <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Modules </h4><br><p>  Each file written in Snakeskin is a module: global variables are encapsulated in it, and all templates are exported.  Modules can connect other modules using the <a href="http://snakeskintpl.github.io/docs/api-ru.html"><code>include</code></a> directive. </p><br><p>  Thus, you can easily divide the code into logical parts, create plug-in libraries (and even, perhaps, frameworks), and generally follow the rule of ‚Äúdivide and conquer‚Äù. </p><br><p>  <strong>math.ss</strong> </p><br><pre> <code class="hljs cpp">- <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> math - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> </span></span>{a + b}</code> </pre> <br><p>  <strong>app.ss</strong> </p><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'./math'</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main() <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> = += math.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  <strong>Result of calling myApp.main</strong> </p><br><pre> <code class="hljs">1 + 2 = 3</code> </pre> <br><h3>  Nice buns </h3><br><ul><li><p>  <strong>Rich set of built-in directives</strong> </p><br><p>  In Snakeskin, there are: directives semantically equivalent to operators in JS, such as <a href="http://snakeskintpl.github.io/docs/api-ru.html"><code>if</code></a> , <a href="http://snakeskintpl.github.io/docs/api-ru.html"><code>for</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>var</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>return</code></a> , etc;  directives specific to the template language and simplifying the markup of XML-like structures: <a href="http://snakeskintpl.github.io/docs/api.html"><code>tag</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>attr</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>doctype</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>comment</code></a> and others;  directives for asynchronous template generation: <a href="http://snakeskintpl.github.io/docs/api.html"><code>await</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>yield</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>parallel</code></a> , <a href="http://snakeskintpl.github.io/docs/api.html"><code>waterfall</code></a> ;  and <a href="http://snakeskintpl.github.io/docs/api.html">many others</a> . </p><br><p>  <em>Hostess for a note</em> : Snakeskin is still not JavaScript, so some directives in the nuances may not work the way similar operators work in JS;  for example, variables declared via <a href="http://snakeskintpl.github.io/docs/api.html"><code>var</code></a> a block scope (this is how the <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a> from ES2015 works).  In the <a href="http://snakeskintpl.github.io/docs/api.html"><code>with</code></a> directive, the architectural flaws of the operator of the same name from JS are eliminated altogether, which makes its use within the SS quite good practice, and simply simplifies and speeds up code writing. </p><br></li><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/guide-ru.html">Filter mechanism</a></strong> </p><br><p><img src="https://habrastorage.org/files/6d2/6e3/f26/6d26e3f26ac249f29a3ba91822a2a2cc.jpg" alt="Filters_Everywhere.jpg"></p><br><p>  Filters are present in one form or another in most template engines, but in SS they are part of the core language, so you can use them literally everywhere: when creating variables, in cycles, when declaring block and template arguments, in directives ... In general, in general everywhere. </p><br></li></ul><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main((str|trim), <span class="hljs-type"><span class="hljs-type">name</span></span> = (<span class="hljs-string"><span class="hljs-string">'World'</span></span>|lower)) - var a = {foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>} |<span class="hljs-type"><span class="hljs-type">json</span></span></code> </pre> <br><p>  In SS out of the box there are <a href="">many useful built-in filters</a> , and if they are not enough, then add your own - <a href="http://snakeskintpl.github.io/docs/guide-ru.html">elementary</a> . </p><br><ul><li><p>  <strong>Bidirectional modular integration with JS</strong> </p><br><p>  You can import SS templates into a JS program, and Snakeskin can import JavaScript modules (using the <a href="&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhj8nfCyax2wW865GAUarPSES8ig3Q#"><code>import</code></a> directive), supporting all the main types of modules: <em>umd</em> , <em>amd</em> , <em>commonjs</em> , <em>native</em> and <em>global</em> . </p><br></li></ul><br><pre> <code class="hljs pgsql">- namespace myApp - <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { readdirSync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ///    ./foo - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> main((str|trim), <span class="hljs-type"><span class="hljs-type">name</span></span> = (<span class="hljs-string"><span class="hljs-string">'World'</span></span>|lower)) - <span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> readdirSync(<span class="hljs-string"><span class="hljs-string">'./foo'</span></span>) =&gt; dirname {dirname}</code> </pre> <br><ul><li><p>  <a href="http://snakeskintpl.github.io/docs/guide-ru.html"><strong>Powerful template localization mechanism</strong></a> </p><br></li><li><p>  <strong>Availability of <a href="http://snakeskintpl.github.io/docs/guide-ru.html">special tools</a> for generating code of other template languages</strong> </p><br><p>  For example, SS plug-ins for building systems (Gulp and others) have a mode in which the Snakeskin template immediately returns React.Element. </p><br><p>  <strong>Template generation for React</strong> </p><br></li></ul><br><pre> <code class="hljs actionscript">- <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> myComponent - template render() &lt; .hello {{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name }}</code> </pre> <br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { myComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./myComponent.ss'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: myComponent.render });</code> </pre> <br><p>  For such seamless integration, when a template returns an element created with React, use a <a href="https://github.com/SnakeskinTpl/snakeskin-loader">Webpack plugin</a> with the <code>jsx</code> flag <code>jsx</code> . </p><br><ul><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/guide-ru.html">Full control over whitespace</a></strong> </p><br><p>  Still worth a look at the section " <a href="http://snakeskintpl.github.io/docs/api-ru.html">Working with whitespace characters</a> ." </p><br></li><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/api-ru.html">Support for sticky links</a> (links to parent class)</strong> </p><br><p>  The mechanism is similar to that used in CSS preprocessors.  Convenient if you adhere to the BEM approach.  The principle of operation is the following: if during the tag declaration you specify the name of a class that begins with the symbol ‚Äú&amp;‚Äù, then it will be replaced with the closest parent class that was declared without this symbol: </p><br></li></ul><br><pre> <code class="hljs actionscript">- <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> myApp - template main() &lt; .hello <span class="hljs-comment"><span class="hljs-comment">/// hello__wrap &lt; .&amp;__wrap /// hello__cont &lt; .&amp;__cont</span></span></code> </pre> <br><ul><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/api-ru.html">Smart interpolation</a></strong> </p><br><p>  Many Snakeskin directives support an interpolation mechanism, i.e., throwing dynamic template values ‚Äã‚Äãinto directives, for example: </p><br></li></ul><br><pre> <code class="hljs ruby">- namespace myApp - template main(area) &lt; ${area ? <span class="hljs-string"><span class="hljs-string">'textarea'</span></span> : <span class="hljs-string"><span class="hljs-string">'input'</span></span>}.b-${area ? <span class="hljs-string"><span class="hljs-string">'textarea'</span></span> : <span class="hljs-string"><span class="hljs-string">'input'</span></span>}   </code> </pre> <br><p>  Depending on the value of the <code>area</code> result will look either like this (if <code>area == true</code> ): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"b-textarea"</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  either way (with <code>area == false</code> ): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"b-input"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"  "</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><ul><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/api-ru.html">Pattern Decorators</a></strong> </p><br><p>  Thanks to the decorators' mechanism, it is easy to integrate additional modules in Snakeskin - for example, a typographer: </p><br></li></ul><br><pre> <code class="hljs pgsql">- namespace demo - <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Typograf <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typograf'</span></span> /// -    JS   SS - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> typograf(params) - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; target - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Typograf(params).<span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>(target.apply(this, arguments)) ///   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>     - @typograf({lang: <span class="hljs-string"><span class="hljs-string">'ru'</span></span>}) - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>()  -  !</code> </pre> <br><ul><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/api-ru.html">Asynchronous patterns</a></strong> </p><br><p>  SS allows you to create generator templates and async templates, plus contains a number of directives for the convenient use of the popular <a href="https://github.com/caolan/async"><em>async</em></a> library. </p><br></li></ul><br><pre> <code class="hljs matlab">- namespace myApp - async template main(db) - forEach await db.getData() =&gt; el {el} - template *foo(data) - <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; data.<span class="hljs-built_in"><span class="hljs-built_in">length</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ {data.value} - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> <span class="hljs-comment"><span class="hljs-comment">% 1e3 === 0 - yield</span></span></code> </pre> <br><p>  Also look in the section " <a href="http://snakeskintpl.github.io/docs/api-ru.html">Directives for asynchronous work</a> ." </p><br><ul><li><p>  <strong>Customizable rendering</strong> </p><br><p>  Out of the box, Snakeskin supports four rendering modes: string (by default), Buffer, DocumentFragment, and JSX;  You can also add your renderer ‚Äî for example, to generate a custom Virtual DOM. </p><br></li><li><p>  <strong>Informative error messages</strong> </p><br><p>  Snakeskin translator has a powerful code debugger that helps to find the most syntax and logical errors when translating templates. </p><br></li><li><p>  <strong>Support for all major build systems</strong> </p><br><p>  <a href="https://github.com/SnakeskinTpl/gulp-snakeskin">Gulp</a> , <a href="https://github.com/SnakeskinTpl/grunt-snakeskin">Grunt</a> , <a href="https://github.com/SnakeskinTpl/snakeskin-loader">WebPack</a> . </p><br></li><li><p>  <strong>Good codebase</strong> </p><br><p>  Snakeskin is completely written in ES2015, contains a large number of tests and passes the most rigorous verification of Google Closure Compiler in <code>ADVANCED</code> mode.  The code is well documented in accordance with Google's JSDoc standard. </p><br></li><li><p>  <strong><a href="http://snakeskintpl.github.io/docs/index-ru.html">Detailed and clear documentation</a></strong> </p><br><p>  Which, by the way, is <a href="https://github.com/SnakeskinTpl/docs/tree/gh-pages/tpls">written on Snakeskin</a> . </p><br></li></ul><br><h2>  Conclusion </h2><br><p>  I sincerely hope that Snakeskin interested you, you will try it and will enjoy using it. </p><br><p>  I express my sincere appreciation to <a href="https://habrahabr.ru/users/trikadin/" class="user_link">trikadin</a> for help with writing and editing the article.  By the way, this guy works as a <a href="https://edadeal.ru/">front-end</a> in <a href="https://edadeal.ru/">Foodadil</a> , and now they are implementing Snakeskin as their main web template language.  He says that he is happy and does not understand how he lived without SS before :) </p><br><p>  I also want to thank the team of the <a href="http://javascript.ru/forum/">javascript.ru forum</a> for ideas on language development and support. </p><br><p>  About the bugs found, write to the <a href="https://github.com/SnakeskinTpl/Snakeskin/issues">Issues</a> on the GitHub-e project, and ask the questions that arise either here in the comments or in <a href="https://gitter.im/SnakeskinTpl/Snakeskin">Gitter</a> 'e - I will always be happy to answer and explain. </p><br><p>  Good luck! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/301646/">https://habr.com/ru/post/301646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301632/index.html">How Microsoft implemented Yammer (Part I)</a></li>
<li><a href="../301636/index.html">Add dependencies to CDI. Part 1</a></li>
<li><a href="../301640/index.html">IPython notebook data processing for SEO tasks</a></li>
<li><a href="../301642/index.html">Positive Hack Days VI WAF Bypass Contest</a></li>
<li><a href="../301644/index.html">We are testing asynchronous code.</a></li>
<li><a href="../301648/index.html">Dependency Injection Container from PHPixie</a></li>
<li><a href="../301650/index.html">Every vacancy on ‚ÄúMy Circle‚Äù is qualified by specialists</a></li>
<li><a href="../301652/index.html">Cisco learning old school</a></li>
<li><a href="../301654/index.html">Fast video encoding for Linux with Nvidia NVENC with SDK 7.5 and ffmpeg 3.0.2 on Nvidia GTX 960/970/980</a></li>
<li><a href="../301656/index.html">7 signs that you are the future boss</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>