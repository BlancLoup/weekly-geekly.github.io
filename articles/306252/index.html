<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Efficient caching. From theory to practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a rule, articles about caching begin for health, and end with LRU cache. Let's try to reverse this trend? To begin with, what LRU is bad, and finis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Efficient caching. From theory to practice</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/6f9/fa1/7e76f9fa16c5fb09cf27fccd98e62ef5.jpg" alt="image"><br><br>  As a rule, articles about caching begin for health, and end with <a href="https://habrahabr.ru/post/136758/">LRU</a> cache.  Let's try to reverse this trend?  To begin with, what LRU is bad, and finish for health.  I hope. <br><br>  Regardless of whether you build a <a href="https://relap.io/">highload service for millions of visitors</a> or design a mobile application, write an operating system or DBMS - the key element affecting the final cost of the system and the responsiveness of the interface / service is a cache. <br><a name="habracut"></a><br>  Asking for interviews what caching algorithms you know - as a rule you hear in response, mmm ... LRU Cache ... But if you ask about sorting algorithms, the probability of hearing something besides "Bubble" is much higher.  A person is willing to spend several days searching for the optimal library of image resizing or a web framework, not realizing that by implementing an effective cache, he can in principle take any library with similar characteristics, since the cache minimizes access to it, smoothing the difference in speed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For <a href="https://relap.io/">Relap.io</a> , as for the highload service, caching is especially important.  For example, yesterday we showed recommendations on various sites 789301033 times.  Therefore, we have a densely smeared cache of everything: recommendations, pictures, advertising, and so on. <br><br><h4>  <b>Not all caches are equally useful.</b> </h4><br>  A good example of LRU Cache. <br><br>  At the competitions of algorithms it is usually not taken.  No one wants to have anything to do with a loser.  It is difficult to come up with a more inefficient algorithm.  The only algorithm that LRU Cache wins in efficiency is probably just a queue, for example, FIFO.  However, LRU is embedded everywhere as a default and, unfortunately, often the only algorithm, since it is simple to implement. <br><br>  Would you like to use a site, application or operating system that slows down, is inefficient and eats resources like not to itself, but is it written in an easy-to-implement language, for example, conditional basic?  If not, welcome under cat. <br><br>  I love the Pareto rule.  On a stat meaningful sample, it can be applied to absolutely everything. <br><br>  Let's try: <br><ul><li>  20% of effort brings 80% of the result, </li><li>  20% of goods bring 80% of profit </li><li>  80% of urls account for 80% of views, </li><li>  20% of the code implements 80% of the functionality. </li></ul><br><br>  This is a rather interesting pattern valid for large data arrays.  It would seem, where does Pareto? <br><br><blockquote>  &lt;Lyrical digression&gt; <br>  A few years ago we wrote an application for android for Surfingbird.  We switched to RX Java.  Asynchronized all that is possible.  Smoothed all the transitions with animation, nevertheless, one unsolved problem remained, these are constant reloads of pictures.  And your application is literally teeming with pictures, and they constantly rotate and change, and you do not have enough memory to place them. <br><br>  I admit, at first I thought that the whole thing was in an imagloader.  It is enough to choose effective and voila.  I reviewed everything.  Picasso, Facebook fresco, UIL I do not remember all the names.  But the problem remained.  Pictures were loaded somewhere a little faster, somewhere slightly smoother, but they were loaded.  Then I sat down and wrote <a href="https://habrahabr.ru/post/262189/">mine</a> .  Plain.  Clean.  Light.  And it did not help.  Stupid imagloader continued to constantly pull pictures unnerving the user and could not separate the wheat from the chaff.  Then I remembered the Pareto rule. <br>  &lt;/ Lyrical digression&gt; </blockquote><br><br>  If we assume that 20% of the pictures - are shown 80% of the time - everything falls into place.  The only thing left to understand is exactly which pictures should be stored. <br><br><h4>  <b>How does LRU cache work?</b> </h4><br><br>  Let's look at a spherical application in a vacuum.  Let it be an instant messenger, it's easiest to imagine. <br><br>  <b>screenshot_from_telegramm.jpg</b> <br><br>  If you look closely at the screenshot, you can see that user messages are accompanied by avatars, and in the body of messages - there are pictures.  Your task is to make the interface as smooth as possible.  Let's take another look at the screenshot above.  We see 2 duplicate autarkies in the dialogue, and then user 1 sent a large picture. <br><br><ul><li>  Avatar 1 - 100 by 100 pixels came, we recorded 100 * 100 * 4 bytes in the cache. </li><li>  An avatar came 2 - 100 by 100 pixels, we recorded 100 * 100 * 4 bytes in the cache. </li><li>  Avatar has come 1 - we raised it in the queue up. </li></ul><br><br>  So far so good. <br><br>  The picture came 1024 by 768 pixels, we recorded 1024 * 768 * 4 bytes in the cache - and BAM!  Our beautiful avatars completely knocked out of the cache.  Now there is a solemn roll of a picture that had to be shown once and there was no need to cache it. <br><br><h4>  <b>How to win?</b> </h4><br><br>  If you look at the AQuery library, for example, the developer suggests dividing the cache into several piles.  A separate heap for small avatars, a separate heap for large pictures.  Already bread is the way, but this solution is not universal, it requires programming and attention, but I want everything at once.  Since all the interesting has already been invented before us - it's time to look at what other caching algorithms exist. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BA%25D1%258D%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">Wiki Article</a> <br><br>  Forgive me for a little bit of a bit of dryness here, and I will describe very brief truths. <br><br>  <b>LRU</b> - unused for the longest flies from the cache. <br>  <b>MRU</b> - the last used crashes out of the cache (specific case, we save the old ones). <br>  <b>LFU</b> - least often used crashes out of the cache. <br><br>  This is the base.  You may be scared that the cost of computing grows with the complexity of the algorithms, but not critical.  Try to compare the time of the lukap by the keys in memory with the rendering time of the picture 1024 by 768. Namely, this will happen if the algorithm ‚Äúmissed‚Äù. <br><br>  <b>SNLRU</b> (segmented LRU) - we get some ‚Äúboxes‚Äù with LRU.  First, we put in the first box, when we repeat the request, we shift it to the second of the second - to the third. <br><br>  If you call the boxes - it will be clearer: <br><ul><li>  Cold - the first box </li><li>  Warm - the second, </li><li>  Hot is the third. </li></ul><br><br>  This is already a good algorithm, it is used in the depths of freebsd, if I'm not mistaken.  At least I came across him in this context. <br><br>  <b>Mid point LRU</b> - segmented LRU in which there are only two boxes. <br><br>  <b>MQ</b> - segmented LRU in which we memorize.  The position from which the element flew out is remembered - and upon repeated request - returns to where it was, if it did not take off from the queue of memorized positions.  In essence, the cache warms up faster in the event of cyclic rotation of elements (poops can become popular).  Looks like a pretty weird use. <br><br>  <b>ARC, GCLOCK</b> - and other more complex algorithms will have to be taken out of the brackets for a while.  Not that they are bad or uninteresting, the same ARC is used (or rather, probably used, judging by this painful article: <a href="http://www.varlena.com/GeneralBits/96.php">www.varlena.com/GeneralBits/96.php</a> ) in postgreSQL.  I can not refrain from a small quote: <br><br><blockquote>  Many systems are often not handled by LRU.  For example, it can be used again.  The cache is not yet helpful until it is re-populated with more commonly used pages. </blockquote><br><br>  <b>2Q</b> - or two turns, it is remarkable that, while maintaining the simplicity of implementation, it adapts well.  The cache is divided into three parts, as in a segmented LRU, but with a more complex strategy: <br><br><ul><li>  The first part of In is the FIFO incoming cache in which new items are placed. </li><li>  The second part of the Out is the outgoing FIFO cache, into which elements displaced from the In box are moved. </li><li>  The third part is the Hot LRU cache for items requested from Out. </li></ul><br><br>  Cache displacement strategy: <br><br><ul><li>  the elements requested from In do not move anywhere.  Items pushed out of In - move to Out. </li><li>  elements requested from Out - go to heaven, in the Main box.  Forced out of the same Out (not used) - immediately go to hell (null). </li></ul><br><br>  Link to canonical <a href="http://www.vldb.org/conf/1994/P439.PDF">description</a> . <br><br>  Firstly - it is beautiful.  For the Main box, for example, we are doing 20% ‚Äã‚Äã(remember Pareto?) It is here that our avatars will be accumulated.  But Out - you need to do more, 60 percent. Since this is a ‚Äúsump‚Äù. <br><br>  What is the beauty of In - new elements quietly descend along the FIFO pipe from In to Out, not bouncing and not moving anywhere as you query.  But if they asked again (for example, the user scrolled up) and, the picture managed to go from In to Out - here it is the winner picture.  The cache at the level of architecture corrects some typical correlations that are present in ordinary life.  And after the introduction, permanent reboots disappeared in conditions of limited memory size.  Pareto worked.  But we will return to Pareto more than once. <br><br>  First, let's move on to the nuances.  When you read about the three boxes, there is an involuntary temptation just so stupidly and to make three linked lists and drive elements through them.  But this is an inefficient way, and somehow not Jedi.  In fact, we only need to know which box the key is in, and the values ‚Äã‚Äãthemselves can roll in this ugly heap at this time.  Let's move on to programming. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation on java, bam!</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.squareup.picasso; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.HashMap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Iterator; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.LinkedHashSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-comment"><span class="hljs-comment">/** * 2Q: A Low Overhead High Performance Buffer Management Replacement Algorith * Based on description: http://www.vldb.org/conf/1994/P439.PDF * Created by recoilme on 22/08/15. * email: vadim-kulibaba@yandex.ru */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoQCache</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Primary container */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap&lt;K, V&gt; map; <span class="hljs-comment"><span class="hljs-comment">/** * Sets for 2Q algorithm */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LinkedHashSet&lt;K&gt; mapIn, mapOut, mapHot; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> quarter = .<span class="hljs-number"><span class="hljs-number">25f</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Size of this cache in units. Not necessarily the number of elements. */</span></span> <span class="hljs-comment"><span class="hljs-comment">//private int size; private int sizeIn; private int sizeOut; private int sizeHot; private int maxSizeIn; private int maxSizeOut; private int maxSizeHot; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * Two queues cache * * @param maxSize for caches that do not override {@link #sizeOf}, this is * this is the maximum sum of the sizes of the entries in this cache. */ public TwoQCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException("maxSize &lt;= 0"); } calcMaxSizes(maxSize); map = new HashMap&lt;K, V&gt;(0, 0.75f); mapIn = new LinkedHashSet&lt;K&gt;(); mapOut = new LinkedHashSet&lt;K&gt;(); mapHot = new LinkedHashSet&lt;K&gt;(); } /** * Sets sizes: * mapIn ~ 25% // 1st lvl - store for input keys, FIFO * mapOut ~ 50% // 2nd lvl - store for keys goes from input to output, FIFO * mapHot ~ 25% // hot lvl - store for keys goes from output to hot, LRU * * @param maxSize if mapIn/mapOut sizes == 0, works like LRU for mapHot */ private void calcMaxSizes(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException("maxSize &lt;= 0"); } synchronized (this) { //sizes maxSizeIn = (int) (maxSize * quarter); maxSizeOut = maxSizeIn * 2; maxSizeHot = maxSize - maxSizeOut - maxSizeIn; } } /** * Sets the size of the cache. * * @param maxSize The new maximum size. */ public void resize(int maxSize) { calcMaxSizes(maxSize); synchronized (this) { HashMap&lt;K, V&gt; copy = new HashMap&lt;K, V&gt;(map); evictAll(); Iterator&lt;K&gt; it = copy.keySet().iterator(); while (it.hasNext()) { K key = it.next(); put(key, copy.get(key)); } } } /** * Returns the value for {@code key} if it exists in the cache or can be * created by {@code #create}. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public V get(K key) { if (key == null) { throw new NullPointerException("key == null"); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; if (mapHot.contains(key)) { // add &amp; trim (LRU) mapHot.remove(key); mapHot.add(key); } else { if (mapOut.contains(key)) { mapHot.add(key); sizeHot += safeSizeOf(key, mapValue); trimMapHot(); sizeOut -= safeSizeOf(key, mapValue); mapOut.remove(key); } } return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; if (!map.containsKey(key)) { // There was no conflict, create return put(key, createdValue); } else { return map.get(key); } } } /** * Caches {@code value} for {@code key}. * * @return the previous value mapped by {@code key}. */ public V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException("key == null || value == null"); } if (map.containsKey(key)) { // if already have - replace it. // Cache size may be overheaded at this moment synchronized (this) { V oldValue = map.get(key); if (mapIn.contains(key)) { sizeIn -= safeSizeOf(key, oldValue); sizeIn += safeSizeOf(key, value); } if (mapOut.contains(key)) { sizeOut -= safeSizeOf(key, oldValue); sizeOut += safeSizeOf(key, value); } if (mapHot.contains(key)) { sizeHot -= safeSizeOf(key, oldValue); sizeHot += safeSizeOf(key, value); } } return map.put(key, value); } V result; synchronized (this) { putCount++; final int sizeOfValue = safeSizeOf(key, value); //if there are free page slots then put value into a free page slot boolean hasFreeSlot = add2slot(key, safeSizeOf(key, value)); if (hasFreeSlot) { // add 2 free slot &amp; exit map.put(key, value); result = value; } else { // no free slot, go to trim mapIn/mapOut if (trimMapIn(sizeOfValue)) { //put X into the reclaimed page slot map.put(key, value); result = value; } else { map.put(key, value); mapHot.add(key); sizeHot += safeSizeOf(key, value); trimMapHot(); result = value; } } } return result; } /** * Remove items by LRU from mapHot */ public void trimMapHot() { while (true) { K key; V value; synchronized (this) { if (sizeHot &lt; 0 || (mapHot.isEmpty() &amp;&amp; sizeHot != 0)) { throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); } if (sizeHot &lt;= maxSizeHot || mapHot.isEmpty()) { break; } // we add new item before, so next return first (LRU) item key = mapHot.iterator().next(); mapHot.remove(key); value = map.get(key); sizeHot -= safeSizeOf(key, value); map.remove(key); evictionCount++; } entryRemoved(true, key, value, null); } } /** * Remove items by FIFO from mapIn &amp; mapOut * * @param sizeOfValue size of * @return boolean is trim */ private boolean trimMapIn(final int sizeOfValue) { boolean result = false; if (maxSizeIn &lt; sizeOfValue) { return result; } else { while (mapIn.iterator().hasNext()) { K keyIn; V valueIn; if (!mapIn.iterator().hasNext()) { System.out.print("err"); } keyIn = mapIn.iterator().next(); valueIn = map.get(keyIn); if ((sizeIn + sizeOfValue) &lt;= maxSizeIn || mapIn.isEmpty()) { //put X into the reclaimed page slot if (keyIn == null) { System.out.print("err"); } mapIn.add(keyIn); sizeIn += sizeOfValue; result = true; break; } //page out the tail of mapIn, call it Y mapIn.remove(keyIn); final int removedItemSize = safeSizeOf(keyIn, valueIn); sizeIn -= removedItemSize; // add identifier of Y to the head of mapOut while (mapOut.iterator().hasNext()) { K keyOut; V valueOut; if ((sizeOut + removedItemSize) &lt;= maxSizeOut || mapOut.isEmpty()) { // put Y into the reclaimed page slot mapOut.add(keyIn); sizeOut += removedItemSize; break; } //remove identifier of Z from the tail of mapOut keyOut = mapOut.iterator().next(); mapOut.remove(keyOut); valueOut = map.get(keyOut); sizeOut -= safeSizeOf(keyOut, valueOut); } } } return result; } /** * Check for free slot in any container and add if exists * * @param key key * @param sizeOfValue size * @return true if key added */ private boolean add2slot(final K key, final int sizeOfValue) { boolean hasFreeSlot = false; if (!hasFreeSlot &amp;&amp; maxSizeIn &gt;= sizeIn + sizeOfValue) { mapIn.add(key); sizeIn += sizeOfValue; hasFreeSlot = true; } if (!hasFreeSlot &amp;&amp; maxSizeOut &gt;= sizeOut + sizeOfValue) { mapOut.add(key); sizeOut += sizeOfValue; hasFreeSlot = true; } if (!hasFreeSlot &amp;&amp; maxSizeHot &gt;= sizeHot + sizeOfValue) { mapHot.add(key); sizeHot += sizeOfValue; hasFreeSlot = true; } return hasFreeSlot; } /** * Removes the entry for {@code key} if it exists. * * @return the previous value mapped by {@code key}. */ public V remove(K key) { if (key == null) { throw new NullPointerException("key == null"); } V previous; synchronized (this) { previous = map.remove(key); if (previous != null) { if (mapIn.contains(key)) { sizeIn -= safeSizeOf(key, previous); mapIn.remove(key); } if (mapOut.contains(key)) { sizeOut -= safeSizeOf(key, previous); mapOut.remove(key); } if (mapHot.contains(key)) { sizeHot -= safeSizeOf(key, previous); mapHot.remove(key); } } } if (previous != null) { entryRemoved(false, key, previous, null); } return previous; } /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * {@link #remove}, or replaced by a call to {@link #put}. The default * implementation does nothing. * &lt;p&gt; * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a {@link #put} or {@link #remove}. * @param newValue the new value for {@code key}, if it exists. If non-null, * this removal was caused by a {@link #put}. Otherwise it was caused by * an eviction or a {@link #remove}. */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) { } /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * &lt;p&gt; * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * &lt;p&gt; * &lt;p&gt;If a value for {@code key} exists in the cache when this method * returns, the created value will be released with {@link #entryRemoved} * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls {@link #put} while another is creating a value for the same * key. */ protected V create(K key) { return null; } private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException("Negative size: " + key + "=" + value); } return result; } /** * Returns the size of the entry for {@code key} and {@code value} in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * &lt;p&gt; * &lt;p&gt;An entry's size must not change while it is in the cache. */ protected int sizeOf(K key, V value) { return 1; } /** * Clear the cache, calling {@link #entryRemoved} on each removed entry. */ public synchronized final void evictAll() { Iterator&lt;K&gt; it = map.keySet().iterator(); while (it.hasNext()) { K key = it.next(); it.remove(); remove(key); } mapIn.clear(); mapOut.clear(); mapHot.clear(); sizeIn = 0; sizeOut = 0; sizeHot = 0; } /** * For caches that do not override {@link #sizeOf}, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. */ public synchronized final int size() { return sizeIn + sizeOut + sizeHot; } /** * For caches that do not override {@link #sizeOf}, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() { return maxSizeIn + maxSizeOut + maxSizeHot; } /** * Returns the number of times {@link #get} returned a value that was * already present in the cache. */ public synchronized final int hitCount() { return hitCount; } /** * Returns the number of times {@link #get} returned null or required a new * value to be created. */ public synchronized final int missCount() { return missCount; } /** * Returns the number of times {@link #create(Object)} returned a value. */ public synchronized final int createCount() { return createCount; } /** * Returns the number of times {@link #put} was called. */ public synchronized final int putCount() { return putCount; } /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() { return evictionCount; } /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() { return new HashMap&lt;K, V&gt;(map); } @Override public synchronized final String toString() { int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format("Cache[size=%d,maxSize=%d,hits=%d,misses=%d,hitRate=%d%%," + "]", size(), maxSize(), hitCount, missCount, hitPercent) + "\n map:" + map.toString(); } public List&lt;Object&gt; getMapHotSnapshot() { List&lt;Object&gt; result = new ArrayList&lt;Object&gt;(); Iterator&lt;K&gt; it = mapHot.iterator(); while (it.hasNext()) { K key = it.next(); result.add(key); result.add(map.get(key)); } return result; } }</span></span></code> </pre> <br></div></div><br><br>  Pay attention to the containers: <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** Primary container */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap&lt;K,V&gt; map; <span class="hljs-comment"><span class="hljs-comment">/** Sets for 2Q algorithm */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LinkedHashSet&lt;K&gt; mapIn, mapOut, mapHot;</code> </pre><br><br>  The management of the "handful" is implemented on the super-fast and memory-efficient LinkedHashSet, it does not matter to us, it matters only in which "handful" which key is currently located.  This is the key to speed. <br><br>  More practice.  Suppose we want to tie it to an image loader - a pull request to a Picasso: <a href="https://github.com/square/picasso/pull/1134">github.com/square/picasso/pull/1134</a> <br>  But in general it is not necessary.  Normal - allow you to connect an arbitrary caching algorithm - just copy the <a href="">class</a> and redefine the cache (glide knew how, picasso, starting with some version) <br><br>  I do not remember the exact numbers on the hit rate in my case.  I only remember that LRU had a hit rate of more than 70% but less than 80. A 2Q had just over 80%.  But a miracle happened.  Because all we need is to cache 20% of the information, which will make up 80% of the traffic.  A miracle, by the way, was that in speed 2Q was faster than LRU. <br><br>  We have in <a href="http://relap.io/">Relap.io</a> , several implementations of caches, for example, mine - <a href="https://github.com/recoilme/2qcache">github.com/recoilme/2qcache</a> (in general, I‚Äôm not a programmer, this is my first program and I hope the only program in this language is its only plus - it‚Äôs simple). <br><br>  Therefore, I recommend to look at the implementation of 2Q on the Pearl from our lead developer: <br><br>  Implementation on the pearl, bam: <a href="https://github.com/grinya007/2q">github.com/grinya007/2q</a> <br><br>  So, it does not matter what you write: a website, a high-speed service, a mobile application or an operating system, having implemented a clever caching algorithm once, you can use it everywhere, saving the resources and nerves of the user. </div><p>Source: <a href="https://habr.com/ru/post/306252/">https://habr.com/ru/post/306252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306242/index.html">Machine Learning with TMVA (ROOT)</a></li>
<li><a href="../306244/index.html">Email advertising is a marvel of marketing from BazaarEmail</a></li>
<li><a href="../306246/index.html">Lobby VR. Libraries for viewing panoramas 360 *</a></li>
<li><a href="../306248/index.html">Greedy download in Yii2, for those who want to understand what it is</a></li>
<li><a href="../306250/index.html">Who was Ramanujan?</a></li>
<li><a href="../306254/index.html">Visit 4 data centers per day and do not regret the time spent</a></li>
<li><a href="../306256/index.html">Prospects for native advertising in Russia and the world</a></li>
<li><a href="../306258/index.html">Using custom functions in OSSIM parsers</a></li>
<li><a href="../306260/index.html">On the role of DevOps in IT - expert opinions</a></li>
<li><a href="../306266/index.html">RuHaxe 5 Online Conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>