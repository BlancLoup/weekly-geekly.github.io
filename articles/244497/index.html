<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Factory method without placement in dynamic memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The classical implementation of the factory method in C ++ has one major drawback - the dynamic polymorphism used in the implementation of this patter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Factory method without placement in dynamic memory</h1><div class="post__text post__text-html js-mediator-article"> The classical implementation of the factory method in C ++ has one major drawback - the dynamic polymorphism used in the implementation of this pattern implies the placement of objects in dynamic memory.  If at the same time the sizes of the objects created by the factory method are not large, but they are often created, this can negatively affect the performance.  This is due to the fact that, in the first place, the <code>new</code> operator is not very efficient in allocating memory of small size, and secondly, the frequent allocation of small memory blocks in itself requires a lot of resources. <br>  To solve this problem, it would be good to keep dynamic polymorphism (without it, the template cannot be implemented) and still allocate memory on the stack. <br>  If you're wondering how I did it, welcome to cat. <br><br><a name="habracut"></a><br><br>  One of the possible implementations of the classic factory method: <br><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;memory&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> std::unique_ptr&lt;Base&gt; create(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> x); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void f() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~Base()"</span></span> &lt;&lt; std::endl;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>: public Base { A() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A()"</span></span> &lt;&lt; std::endl;} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void f() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> override {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A::f\t"</span></span> &lt;&lt; ((size_t)this) &lt;&lt; std::endl;} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~A() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~A()"</span></span> &lt;&lt; std::endl;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span>: public Base { B() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B()"</span></span> &lt;&lt; std::endl;} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void f() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> override {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f\t"</span></span> &lt;&lt; ((size_t)this) &lt;&lt; std::endl;} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~B() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~B()"</span></span> &lt;&lt; std::endl;} }; std::unique_ptr&lt;Base&gt; Base::create(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::unique_ptr&lt;Base&gt;(new A()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::unique_ptr&lt;Base&gt;(new B()); } int main() { auto p = Base::create(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); p-&gt;f(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"p addr:\t"</span></span> &lt;&lt; ((size_t)&amp;p) &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// compile &amp; run: // g++ -std=c++11 1.cpp &amp;&amp; ./a.out</span></span></code> </pre><br>  output: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::f</span></span> 21336080 <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">addr</span></span>: 140733537175632 ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>() ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">Base</span></span>()</code> </pre><br>  I think there is no need to comment.  By address ranges, you can indirectly make sure that the created object is really located on the heap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now let's get rid of dynamic memory allocation. <br>  As I said above, we assume that the objects created are small and the variant proposed below improves performance due to a small memory overflow. <br><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;memory&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void f() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~Base()"</span></span> &lt;&lt; std::endl;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>: public Base {<span class="hljs-comment"><span class="hljs-comment">/* code here */</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span>: public Base {<span class="hljs-comment"><span class="hljs-comment">/* code here */</span></span>}; class BaseCreator { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span></span> { A a; B b; }; public: BaseCreator(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> x) : _x(x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x) (new(m) A()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (new(m) B()); } ~BaseCreator() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_x) { reinterpret_cast&lt;A*&gt;(m)-&gt;A::~A(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reinterpret_cast&lt;B*&gt;(m)-&gt;B::~B(); } } Base* operator-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reinterpret_cast&lt;Base *&gt;(m); } private: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> _x; unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> m[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(U)]; }; int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *argv[]) { BaseCreator p(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); p-&gt;f(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"p addr:\t"</span></span> &lt;&lt; ((size_t)&amp;p) &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  output: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::f</span></span> 140735807769160 <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">addr</span></span>: 140735807769160 ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>() ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">Base</span></span>()</code> </pre><br>  At the printed addresses, you can see that yes.  The object is located on the stack. <br>  The idea here is very simple: we take the union of objects that will create the factory method and with the help of it we will find out the size of the most capacious type.  Then we allocate on the stack the memory of the desired size <code>unsigned char m[sizeof(U)];</code>  and with the help of the special form <code>new</code> place the object <code>new(m) A()</code> . <br> <code>reinterpret_cast&lt;A*&gt;(m)-&gt;A::~A();</code>  correctly destroys the object placed in the allocated memory. <br><br>  In principle, this could have been stopped, but in the resulting solution I don‚Äôt like the fact that information about the created types in the BaseCreator class is present in three places.  And if we need, so that our factory method would create objects of another type, we will have to synchronously make changes to all these three places.  Moreover, in case of an error, the compiler will not say anything.  Yes, and in runtime, the error may not immediately emerge.  And if the types will not be 2-3, but 10-15, then it‚Äôs generally a disaster. <br><br>  Let's try to improve our BaseCreator class. <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> { union </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">U</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> a; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class"> b; }; public: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) { if(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) createObj&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;(); else createObj&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">&gt;(); } ~</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">() { deleter(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">); } //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> &amp;) = delete; //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> &amp;&amp;) = default; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span><span class="hljs-class">* operator-&gt;() { return reinterpret_cast&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span><span class="hljs-class"> *&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">); } private: typedef void (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deleter_t</span></span></span><span class="hljs-class">)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *); template&lt;typename </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; void createObj() { new(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">(); deleter = freeObj&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;; } template&lt;typename </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; static void freeObj(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) { reinterpret_cast&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">*&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">)-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">::~</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">(); } unsigned char m[sizeof(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">U</span></span></span><span class="hljs-class">)]; deleter_t *deleter; };</span></span></code> </pre><br><br>  Thus, there are not three, but two places that require editing when adding new types.  Already better, but still not perfect.  The main problem remained. <br>  To solve this problem you need to get rid of the union.  But at the same time maintain the visibility provided to them and the ability to determine the required size. <br><br>  But what if we had a ‚Äúsmart union‚Äù that would not only know its size, but also allow us to dynamically create in it the objects of the types listed in this union?  Well and at the same time, of course, would carry out type control. <br><br>  No problems!  This is C ++! <br><pre> <code class="hljs lua">template &lt;typename ...Types&gt; class TypeUnion { public: //     TypeUnion() {}; //   TypeUnion(const TypeUnion &amp;) = delete; //   TypeUnion(TypeUnion &amp;&amp;) = default; ~TypeUnion() { //     -  //  ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(deleter) deleter(mem); } //     <span class="hljs-string"><span class="hljs-string">""</span></span>   T //    T          //   args    template &lt;typename T, typename ...Args&gt; void assign(Args&amp;&amp;... args) { //         <span class="hljs-string"><span class="hljs-string">""</span></span> static_assert ( usize, <span class="hljs-string"><span class="hljs-string">"TypeUnion is empty"</span></span> ); static_assert ( same_as&lt;T&gt;(), <span class="hljs-string"><span class="hljs-string">"Type must be present in the types list "</span></span> ); //      -    //  ,    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(deleter) deleter(mem); //        //  ,     new(mem) T(std::forward&lt;Args&gt;(args)...); //       deleter = freeMem&lt;T&gt;; } //      <span class="hljs-string"><span class="hljs-string">""</span></span>  template&lt;typename T&gt; T* get() { static_assert ( usize, <span class="hljs-string"><span class="hljs-string">"TypeUnion is empty"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span> ( deleter ); // TypeUnion::assign was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> called <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reinterpret_cast&lt;T*&gt;(mem); } private: //         typedef void (deleter_t)(void *); //      TypeUnion    ? static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //      static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(size_t r0) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r0; } template &lt;typename ...R&gt; static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(size_t r0, R... r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( r0 &gt; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(r...) ? r0 : <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(r...) ); } // is_same    template &lt;typename T&gt; static constexpr bool same_as() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>( std::is_same&lt;T, Types&gt;::value... ); } //          template&lt;typename T&gt; static void freeMem(void *p) { reinterpret_cast&lt;T*&gt;(p)-&gt;T::~T(); } //          static constexpr size_t usize = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>( sizeof(Types)... ); //  ,     unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> mem[usize]; deleter_t *deleter = nullptr; };</code> </pre><br><br>  Now BaseCreator looks much nicer: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeUnion</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">&gt; obj; public: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) { if(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) obj.assign&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;(); else obj.assign&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">&gt;(); } //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> &amp;) = delete; //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseCreator</span></span></span><span class="hljs-class"> &amp;&amp;) = default; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span><span class="hljs-class">* operator-&gt;() { return obj.get&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span><span class="hljs-class">&gt;(); } };</span></span></code> </pre><br>  Now perfect.  The record <code>TypeUnion&lt;A, B&gt; obj</code> clearer than <code>union U {A a; B b;}</code>  <code>union U {A a; B b;}</code> .  And an error with type mismatch will be caught at compile time. <br><br><div class="spoiler">  <b class="spoiler_title">Full sample code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;cassert&gt; struct Base { virtual void f() const = <span class="hljs-number"><span class="hljs-number">0</span></span>; virtual ~Base() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~Base()\n"</span></span>;} }; struct A: public Base { A(){std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A()\n"</span></span>;} virtual void f() const override{std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A::f\n"</span></span>;} virtual ~A() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~A()\n"</span></span>;} }; struct B: public Base { B(){std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B()\n"</span></span>;} virtual void f() const override{std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f\n"</span></span>;} virtual ~B() {std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~B()\n"</span></span>;} size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; template &lt;typename ...Types&gt; class TypeUnion { public: //     TypeUnion() {}; //   TypeUnion(const TypeUnion &amp;) = delete; //   TypeUnion(TypeUnion &amp;&amp;) = default; ~TypeUnion() { //     -  //  ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(deleter) deleter(mem); } //     <span class="hljs-string"><span class="hljs-string">""</span></span>   T //    T          //   args    template &lt;typename T, typename ...Args&gt; void assign(Args&amp;&amp;... args) { //         <span class="hljs-string"><span class="hljs-string">""</span></span> static_assert ( usize, <span class="hljs-string"><span class="hljs-string">"TypeUnion is empty"</span></span> ); static_assert ( same_as&lt;T&gt;(), <span class="hljs-string"><span class="hljs-string">"Type must be present in the types list "</span></span> ); //      -    //  ,    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(deleter) deleter(mem); //        //  ,     new(mem) T(std::forward&lt;Args&gt;(args)...); //       deleter = freeMem&lt;T&gt;; } //      <span class="hljs-string"><span class="hljs-string">""</span></span>  template&lt;typename T&gt; T* get() { static_assert ( usize, <span class="hljs-string"><span class="hljs-string">"TypeUnion is empty"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span> ( deleter ); // TypeUnion::assign was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> called <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reinterpret_cast&lt;T*&gt;(mem); } private: //         typedef void (deleter_t)(void *); //      TypeUnion    ? static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //      static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(size_t r0) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r0; } template &lt;typename ...R&gt; static constexpr size_t <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(size_t r0, R... r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( r0 &gt; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(r...) ? r0 : <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(r...) ); } // is_same    template &lt;typename T&gt; static constexpr bool same_as() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>( std::is_same&lt;T, Types&gt;::value... ); } //          template&lt;typename T&gt; static void freeMem(void *p) { reinterpret_cast&lt;T*&gt;(p)-&gt;T::~T(); } //          static constexpr size_t usize = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>( sizeof(Types)... ); //  ,     unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> mem[usize]; deleter_t *deleter = nullptr; }; class BaseCreator { TypeUnion&lt;A, B&gt; obj; public: BaseCreator(bool x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x) obj.assign&lt;A&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> obj.assign&lt;B&gt;(); } //   BaseCreator(const BaseCreator &amp;) = delete; //   BaseCreator(BaseCreator &amp;&amp;) = default; Base* operator-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.get&lt;Base&gt;(); } }; int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> const *argv[]) { BaseCreator p(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); p-&gt;f(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"sizeof(BaseCreator):"</span></span> &lt;&lt; sizeof(BaseCreator) &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"sizeof(A):"</span></span> &lt;&lt; sizeof(A) &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"sizeof(B):"</span></span> &lt;&lt; sizeof(B) &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // // clang++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>cpp &amp;&amp; ./a.out</code> </pre><br></div></div><br><br>  Are there any rakes that I did not notice? <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/244497/">https://habr.com/ru/post/244497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244481/index.html">A few words about working at home</a></li>
<li><a href="../244485/index.html">Sniff the output Tor node and analyze the resulting content.</a></li>
<li><a href="../244487/index.html">Swift Multiple Functions</a></li>
<li><a href="../244491/index.html">Looking for the perfect file storage</a></li>
<li><a href="../244493/index.html">Creating the game on your eyes - part 8: Visual scripting of cut scenes in Unity (uScript)</a></li>
<li><a href="../244505/index.html">Vectorization of cycles: diagnosis and control</a></li>
<li><a href="../244507/index.html">Equalization of histograms for image enhancement</a></li>
<li><a href="../244509/index.html">The project 1C-Tools became the winner of the selection in U.M.NI.K.</a></li>
<li><a href="../244511/index.html">Samsung's DeepSort ranked first in the Sort Benchmark 2014 competition</a></li>
<li><a href="../244515/index.html">The company Global Web Index presented a statistical report on the Internet preferences of Europeans in 2014</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>