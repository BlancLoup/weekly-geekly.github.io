<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python extension modules on Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúAbsolute statements are the root of all evil. 
 The key is balance. There are no answers, only questions. ‚Äù 
 ???? 

 The author of the article: zolk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python extension modules on Rust</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/fa6/0c7/77c/fa60c777cc09487eba64f52a083c8333.png"></div><br><br>  <i>‚ÄúAbsolute statements are the root of all evil.</i> <i><br></i>  <i>The key is balance.</i>  <i>There are no answers, only questions. ‚Äù</i> <i><br></i>  <i>????</i> <br><br>  The author of the article: <a href="https://habrahabr.ru/users/zolkko/" class="user_link">zolkko</a> . <br><h5>  <b>Optimization</b> </h5><br>  When they talk about optimization in the context of software, they often mean optimization of the programmer‚Äôs performance and / or optimization of the software itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Based on the YAGNI principle, Python allows the programmer to focus on software implementation, eliminating the need to take care of low-level things: regions of memory in which objects are allocated, freeing up memory, calling conventions. <br><br>  Simon Jones pointed to the reverse problem in <a href="https://www.youtube.com/watch%3Fv%3DbrE_dyedGm0">one of his</a> Haskell <a href="https://www.youtube.com/watch%3Fv%3DbrE_dyedGm0">lectures</a> .  He had a slide with a gradient-colored arrow.  In the beginning was written ‚Äúno types‚Äù, in the middle - ‚ÄúHaskell‚Äù, at the end - ‚ÄúCoq‚Äù.  Pointing to Coq, he said: ‚ÄúThis stresses power over usability.  Right ?!  You need a PhD here! ‚Äù[1].  Despite the fact that it was a joke, the Python mantra is one of the programmers' favorite features of this language.  In my experience, this is what allows you to produce a finished product a little faster. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/files/352/4cb/01c/3524cb01cef7431aa1723863fe22bf8b.png"></div><br><br>  As for software optimization, different sources say this differently, but for myself I divide it into three levels: <br><ul><li>  at the level of architecture </li><li>  high-level algorithms and data structures </li><li>  low level </li></ul><br><br>  An interesting feature here is this: the higher the level at which the optimization is carried out, the more effective it is.  Usually so.  On the other hand, the more we optimize at a higher level, the earlier it needs to be done: of course, at the end of the project it is more difficult to redo the application architecture.  In addition, it is problematic to identify in advance where the bottleneck will be, and in general I want to avoid premature optimizations, because in case of a change in the requirements, it becomes more difficult to change the software. <br><br><h6>  <b>Run Level Optimization</b> </h6><br>  Probably the most logical and correct (in terms of complexity) strategy for low-level optimization of the Python code is the use of special tools such as PyPy, Pyston and others.  This is due to the fact that the frequently used Cpython code is already optimal, and an attempt to add any line will, rather, result in performance degradation.  In addition, it is impossible to use classical optimization methods due to the dynamic typing of Python. <br><br>  This problem was also noted by Kevin Modzelewski at Pyston Talk 2015 [2].  According to him, you can count on about 10% runtime.  By combining different techniques - JIT, tracing JIT, heuristic analysis, Pyston - you can achieve a 25% increase in productivity. <br>  And here is one benchmark chart taken from his report: <br><br><img src="https://habrastorage.org/files/602/c1f/155/602c1f1551e24ee58e9031cae50529d6.png"><br><br>  The graph shows that at some point PyPy becomes 38 times slower than normal Cpython.  The result suggests that, using such tools, it is necessary to measure performance.  And it should be done on real data, in conditions close to real conditions of software execution.  And it is desirable to carry out such an exercise every time the versions of interpreters are updated.  Here you can quote: ‚Äù[3]. <br><br><h6>  <b>Source Code Optimization</b> </h6><br>  A similar problem can also be revealed when optimizing at the language level through the use of idiomatic productive code.  To illustrate, I give an example of a small program (not quite idiomatic [4]), which defines a list of words and three functions that convert it into a list of words from capital letters: <br><br><pre><code class="python hljs">LST = list(map(<span class="hljs-string"><span class="hljs-string">''</span></span>.join, product(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>, repeat=<span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(str.upper, LST) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> LST: res.append(i.upper()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [i.upper() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> LST]</code> </pre> <br><br>  In it, three logically equivalent functions differ semantically and throughput.  At the same time, performance semantics say nothing.  In any case, for the inexperienced Python programmer - while 1: pass vs while: True: pass is magic that runs the risk of becoming a hoax when switching to Python 3. <br><br><h5>  <b>CPython Modules</b> </h5><br>  Another option for low-level Python optimization is expansion modules. By transferring part of the logic to an expansion module, in some cases you can achieve good performance with a predictable result. <br><br><h6>  <b>Tools</b> </h6><br>  Many of the available Python-tools offer a variety of functionality, ranging from generating code for CUDA and ending with transparent integration with numpy or C ++.  However, below I will consider their behavior only in the context of writing extension modules on a specially selected boundary example: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_mul_two</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> acc = <span class="hljs-number"><span class="hljs-number">0</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>: acc += a + b i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc</code> </pre><br><br>  As you can see, CPython takes it literally: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">12</span></span> SETUP_LOOP <span class="hljs-number"><span class="hljs-number">40</span></span> (to <span class="hljs-number"><span class="hljs-number">55</span></span>) <span class="hljs-number"><span class="hljs-number">15</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">3</span></span> (i) <span class="hljs-number"><span class="hljs-number">18</span></span> LOAD_CONST <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-number"><span class="hljs-number">21</span></span> COMPARE_OP <span class="hljs-number"><span class="hljs-number">0</span></span> (&lt;) <span class="hljs-number"><span class="hljs-number">24</span></span> POP_JUMP_IF_FALSE <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">2</span></span> (acc) <span class="hljs-number"><span class="hljs-number">30</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (a) <span class="hljs-number"><span class="hljs-number">33</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">1</span></span> (b) <span class="hljs-number"><span class="hljs-number">36</span></span> BINARY_ADD <span class="hljs-number"><span class="hljs-number">37</span></span> INPLACE_ADD <span class="hljs-number"><span class="hljs-number">38</span></span> STORE_FAST <span class="hljs-number"><span class="hljs-number">2</span></span> (acc) <span class="hljs-number"><span class="hljs-number">41</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">3</span></span> (i) <span class="hljs-number"><span class="hljs-number">44</span></span> LOAD_CONST <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">47</span></span> INPLACE_ADD <span class="hljs-number"><span class="hljs-number">48</span></span> STORE_FAST <span class="hljs-number"><span class="hljs-number">3</span></span> (i) <span class="hljs-number"><span class="hljs-number">51</span></span> JUMP_ABSOLUTE <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> POP_BLOCK</code> </pre><br><br>  You can correct the situation by writing the simplest extension module in C. <br>  To do this, determine the minimum initialization function of the module: <br><br><pre> <code class="python hljs">// example.c void initexample(void) { Py_InitModule(<span class="hljs-string"><span class="hljs-string">"example"</span></span>, NULL); }</code> </pre><br><br>  This function is called so, because in fact the execution of the import statement ... <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> example IMPORT_NAME <span class="hljs-number"><span class="hljs-number">0</span></span> (example) STORE_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (example)</code> </pre><br><br>  ... will lead to fulfillment ... <br><br><pre> <code class="python hljs">// ceval.c ... w = GETITEM(names, oparg); v = PyDict_GetItemString(f-&gt;f_builtins, <span class="hljs-string"><span class="hljs-string">"__import__"</span></span>); ... x = PyEval_CallObject(v, w); ...</code> </pre><br><br>  ... the builtin function builtin___import__ (bltinmodule.c), and further along the call chain: <br><br><pre> <code class="python hljs">dl_funcptr _PyImport_GetDynLoadFunc(const char *fqname, const char *shortname, const char *pathname, FILE *fp) { char funcname[<span class="hljs-number"><span class="hljs-number">258</span></span>]; PyOS_snprintf(funcname, sizeof(funcname), <span class="hljs-string"><span class="hljs-string">"init%.200s"</span></span>, shortname); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dl_loadmod(Py_GetProgramName(), pathname, funcname); }</code> </pre><br><br>  In any case, for some platforms and under certain conditions: CPython is built with support for dynamically loadable extension modules, the module has not yet been loaded, the file name of the module has a specific and platform-specific extension, etc. <br><br>  Next, the module method is determined ... <br><br><pre> <code class="python hljs">static PyObject * add_mul_two(PyObject * self, PyObject * args); static PyMethodDef ExampleMethods[] = { {<span class="hljs-string"><span class="hljs-string">"add_mul_two"</span></span>, add_mul_two, METH_VARARGS, <span class="hljs-string"><span class="hljs-string">""</span></span>}, {NULL, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>, NULL} }; void initexample(void) { Py_InitModule(<span class="hljs-string"><span class="hljs-string">"example"</span></span>, ExampleMethods); }</code> </pre><br><br>  ... and its implementation itself.  Since in this case the types of input variables are precisely known, the function can be defined as: <br><br><pre> <code class="python hljs">PyObject * add_mul_two(PyObject * self, PyObject * args) { int a, b, acc = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PyArg_ParseTuple(args, <span class="hljs-string"><span class="hljs-string">"ii"</span></span>, &amp;a, &amp;b)) { PyErr_SetNone(PyExc_ValueError); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NULL; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) acc += a + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Py_BuildValue(<span class="hljs-string"><span class="hljs-string">"i"</span></span>, acc); }</code> </pre><br><br>  The output will be a binary code, about the same that can be obtained using Numba ... <br><br><pre> <code class="python hljs">___main__.add_mul_two$<span class="hljs-number"><span class="hljs-number">1.</span></span>int32.int32: addl %r8d, %ecx imull $<span class="hljs-number"><span class="hljs-number">1000</span></span>, %ecx, %eax movl %eax, (%rdi) xorl %eax, %eax retq</code> </pre><br><br>  ... but having written only two lines and not going beyond the framework of one programming language. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@jit(int32(int32, int32), nopython=True)</span></span></code> </pre><br><br>  In addition to this code, numba generates ... <br><br><pre> <code class="python hljs">add_mul_two.inspect_asm().values()[<span class="hljs-number"><span class="hljs-number">0</span></span>].decode(<span class="hljs-string"><span class="hljs-string">'string_escape'</span></span>)</code> </pre><br><br>  ... type wrapper function: <br><pre> <code class="python hljs">_wrapper.__main__.add_mul_two$<span class="hljs-number"><span class="hljs-number">1.</span></span>int32.int32: ... movq %rdi, %r14 movabsq $_.const.add_mul_two, %r10 movabsq $_PyArg_UnpackTuple, %r11 ... movabsq $_PyNumber_Long, %r15 callq *%r15 movq %rax, %rbx xorl %r14d, %r14d testq %rbx, %rbx je LBB1_8 movabsq $_PyLong_AsLongLong, %rax ‚Ä¶</code> </pre><br><br>  Its task is to parse the input arguments according to the signatures described in the decorator and, if it worked, to run the compiled version.  This method seems very tempting, but if, for example, you take the body of the loop into a separate function, you will also need to frame it with the decorator or disable nopython. <br><br>  Cython is the next challenger.  It is a Python superset with support for calling C functions and defining C types.  Therefore, in the simplest case, the add_mul_two function on it will look similar to Cpython.  However, the extensive functionality is not given just like that, and, unlike the C-version, the resulting file will be almost 2000 lines of CPython API-type: <br><br><pre> <code class="python hljs">__pyx_t_2 = PyNumber_Add(__pyx_v_a, __pyx_v_b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_2)) { __pyx_filename = __pyx_f[<span class="hljs-number"><span class="hljs-number">0</span></span>]; __pyx_lineno = <span class="hljs-number"><span class="hljs-number">14</span></span>; __pyx_clineno = __LINE__; goto __pyx_L1_error; } __Pyx_GOTREF(__pyx_t_2); __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_acc, __pyx_t_2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_3)) { __pyx_filename = __pyx_f[<span class="hljs-number"><span class="hljs-number">0</span></span>]; __pyx_lineno = <span class="hljs-number"><span class="hljs-number">14</span></span>; __pyx_clineno = __LINE__; goto __pyx_L1_error; }</code> </pre><br><br>  To improve the situation in terms of specificity, but not in terms of code size, one could write, for example, the implementation of the function itself in C, and use Cython to define a wrapper ... <br><br><pre> <code class="python hljs">int cadd_mul_two(int a, int b) { int32_t acc = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) acc += a + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; } cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"example_func.h"</span></span>: int cadd_mul_two(int, int) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cadd_two(a, b) cythonize(<span class="hljs-string"><span class="hljs-string">"sample.pyx"</span></span>, sources=[ <span class="hljs-string"><span class="hljs-string">'example_func.c'</span></span> ])</code> </pre><br><br>  ... while getting almost perfect option, but in this case you need to write in C, Cython, Python. <br><br><pre> <code class="python hljs"> __pyx_t_1 = __Pyx_PyInt_As_int32_t(__pyx_v_a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely((__pyx_t_1 == (int32_t)<span class="hljs-number"><span class="hljs-number">-1</span></span>) &amp;&amp; PyErr_Occurred())) {__pyx_filename = __pyx_f[<span class="hljs-number"><span class="hljs-number">0</span></span>]; __pyx_ __pyx_t_2 = __Pyx_PyInt_As_int32_t(__pyx_v_b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely((__pyx_t_2 == (int32_t)<span class="hljs-number"><span class="hljs-number">-1</span></span>) &amp;&amp; PyErr_Occurred())) {__pyx_filename = __pyx_f[<span class="hljs-number"><span class="hljs-number">0</span></span>]; __pyx_ __pyx_t_3 = __Pyx_PyInt_From_int32_t(cadd_two(__pyx_t_1, __pyx_t_2)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[<span class="hljs-number"><span class="hljs-number">0</span></span>]; __pyx_lineno = <span class="hljs-number"><span class="hljs-number">8</span></span>; _</code> </pre><br><br><h5>  <b>Rusty</b> </h5><br>  To make a module on Rust, you only need to declare the extern-function c no_mangle ... <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#[no_mangle] pub extern fn initexample() { unsafe { Py_InitModule4_64(&amp;SAMPLE[0] as *const _, &amp;METHODS[0] as *const _, 0 as *const _, 0, PYTHON_API_VERSION); }; }</span></span></code> </pre><br><br>  ... and describe the types: <br><br><pre> <code class="python hljs">type PyCFunction = unsafe extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> fn (slf: *mut isize, args: *mut isize) -&gt; *mut isize; <span class="hljs-comment"><span class="hljs-comment">#[repr(C)] struct PyMethodDef { pub ml_name: *const i8, pub ml_meth: Option&lt;PyCFunction&gt;, pub ml_flags: i32, pub ml_doc: *const i8, } unsafe impl Sync for PyMethodDef { }</span></span></code> </pre><br><br>  As in C, you need to declare PyMethod: <br><br><pre> <code class="python hljs">lazy_static! { static ref METHODS: Vec = { vec![ PyMethodDef { ml_name: &amp;ADD_MUL_TWO[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *const _, ml_meth: Some(add_mul_two), }, ... ] }; }</code> </pre><br><br>  Due to the fact that there are many C API calls in CPython, you will have to write something like this: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#[link(name="python2.7")] extern { fn Py_InitModule4_64(name: *const i8, methods: *const PyMethodDef, doc: *const i8, s: isize, apiver: usize) -&gt; *mut isize; fn PyArg_ParseTuple(arg1: *mut isize, arg2: *const i8, ...) -&gt; isize; fn Py_BuildValue(arg1: *const i8, ...) -&gt; *mut isize; }</span></span></code> </pre><br><br>  But in the end we will get this beautiful function: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#[allow(unused_variables)] unsafe extern "C" fn add_mul_two(slf: *mut isize, args: *mut isize) -&gt; *mut isize { let mut a: i32 = 0; let mut b: i32 = 0; if PyArg_ParseTuple(args, &amp;II_ARGS[0] as *const _, &amp;a as *const i32, &amp;b as *const i32) == 0 { return 0 as *mut _; } let mut acc: i32 = 0; for i in 0..1000 { acc += a + b; } Py_BuildValue(&amp;I_ARGS[0] as *const _, acc) }</span></span></code> </pre><br><br>  Or, if desired ... <br><pre> <code class="python hljs">let acc: i32 = (<span class="hljs-number"><span class="hljs-number">0.</span></span>.).take(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .map(|_| a + b) .fold(<span class="hljs-number"><span class="hljs-number">0</span></span>, |acc, x| acc + x);</code> </pre><br><br>  ... this function will also be compiled into two machine instructions: <br><br><pre> <code class="python hljs">__ZN7add_mul_two20h391818698d43ab0ffcaE: ... callq <span class="hljs-number"><span class="hljs-number">0x7a002</span></span> <span class="hljs-comment"><span class="hljs-comment">## symbol stub for: _PyArg_ParseTuple testq %rax, %rax je 0x14e3 movl -0x8(%rbp), %eax addl -0x4(%rbp), %eax imull $0x3e8, %eax, %esi ## imm = 0x3E8 leaq _ref5540(%rip), %rdi ## literal pool for: "h" ...</span></span></code> </pre><br><br>  The disadvantages of this approach are as follows: <br><br><ul><li>  only CPython API 2.7 and if you also need Python 3, you will need to duplicate a lot of code </li><li>  If you try to reduce the size of the binary due to no_std, then the code will be larger </li><li>  including  A number of data structures in Rust are different from C. So for example Rust uses pascal strings and to interact with C you have to use something like std :: ffi :: CString </li></ul><br><br>  But, fortunately, there is a wonderful rust-cpython project that not only described all the necessary CpythonAPIs, but also provides high-level abstractions for them, and at the same time supports Python 2.x and 3.x.  The code is approximately like this: <br><br><pre> <code class="python hljs">[package] name = <span class="hljs-string"><span class="hljs-string">"example"</span></span> version = <span class="hljs-string"><span class="hljs-string">"0.1.0"</span></span> [lib] name = <span class="hljs-string"><span class="hljs-string">"example"</span></span> crate-type = [<span class="hljs-string"><span class="hljs-string">"dylib"</span></span>] [dependencies] interpolate_idents = <span class="hljs-string"><span class="hljs-string">"0.0.9"</span></span> [dependencies.cpython] version = <span class="hljs-string"><span class="hljs-string">"0.0.5"</span></span> default-features = false features = [<span class="hljs-string"><span class="hljs-string">"python27-sys"</span></span>]</code> </pre><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#![feature(slice_patterns)] #![feature(plugin)] #![plugin(interpolate_idents)] #[macro_use] extern crate cpython; use cpython::{PyObject, PyResult, Python, PyTuple, PyDict, ToPyObject, PythonObject}; fn add_two(py: Python, args: &amp;PyTuple, _: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;PyObject&gt; { match args.as_slice() { [ref a_obj, ref b_obj] =&gt; { let a = a_obj.extract::&lt;i32&gt;(py).unwrap(); let b = b_obj.extract::&lt;i32&gt;(py).unwrap(); let mut acc:i32 = 0; for _ in 0..1000 { acc += a + b; } Ok(acc.to_py_object(py).into_object()) }, _ =&gt; Ok(py.None()) } }</span></span></code> </pre><br><br><pre> <code class="python hljs">py_module_initializer!(example, |py, module| { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>!(module.add(py, <span class="hljs-string"><span class="hljs-string">"add_two"</span></span>, py_fn!(add_two))); Ok(()) });</code> </pre><br><br>  Here nightly Rust is used, as a matter of fact, only for sclice_pattens and PyTuple.as_slice. <br>  But, in my opinion, Rust in this situation offers a solution with powerful high-level abstractions, the ability to fine-tune algorithms and data structures, an effective and predictable result of optimizations.  That is, it looks like a worthy alternative to other tools. <br><br>  Code examples used in the article, you can see <br>  <a href="https://github.com/zolkko/pug-rust">here</a> <br><br><h5>  <b>Bibliography</b> </h5><br>  1: Simon Peyton Jones, Adventure with Types in Haskell - Simon Peyton Jones (Lecture 2), 2014, <a href="https://youtu.be/brE_dyedGm0%3Ft%3D536">youtu.be/brE_dyedGm0?t=536</a> <br>  2: Kevin Modzelewski, 2015/11/10 Pyston Meetup, 2015, <a href="http://www.youtube.com/watch%3Fv%3DNdB9XoBg5zI">www.youtube.com/watch?v=NdB9XoBg5zI</a> <br>  3: Martin Fowler, Yet Another Optimization <a href="http://martinfowler.com/ieeeSoftware/yetOptimization.pdf">Article</a> , 2002, <a href="http://martinfowler.com/ieeeSoftware/yetOptimization.pdf">martinfowler.com/ieeeSoftware/yetOptimization.pdf</a> <br>  4: Raymond Hettinger, Transforming Code into Beautiful, Idiomatic Python, 2013, <a href="https://www.youtube.com/watch%3Fv%3DOSGv2VnC0go">www.youtube.com/watch?v=OSGv2VnC0go</a> </div><p>Source: <a href="https://habr.com/ru/post/279561/">https://habr.com/ru/post/279561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279547/index.html">How cloud technologies affect data centers</a></li>
<li><a href="../279549/index.html">We invite you to a series of lectures "Creating online games: game design, monetization, operating and promotion"</a></li>
<li><a href="../279551/index.html">ABBYY: environmental friendliness ++. Four years later</a></li>
<li><a href="../279553/index.html">Is there life without google play? Alternatives and Application Updates</a></li>
<li><a href="../279555/index.html">Shared on shared-hosting: pain and suffering or a simple routine?</a></li>
<li><a href="../279563/index.html">MSLibrary. SIMPLE: remove unnecessary characters from a string using regular expressions for iOS and not only ...</a></li>
<li><a href="../279565/index.html">New features in Google Play Games</a></li>
<li><a href="../279567/index.html">Universal script to switch 2 Internet channels Mikrotik</a></li>
<li><a href="../279569/index.html">How to make an automatic snapshot of your site when it fell</a></li>
<li><a href="../279571/index.html">IBM introduced the new z13s hybrid cloud mainframe.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>