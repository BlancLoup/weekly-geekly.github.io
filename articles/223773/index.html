<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add gas: + 200% performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 

 Last time I told you how we wrote Raw JavaScript converter, and you told me that it works slowly. Today I want to talk about how we have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add gas: + 200% performance</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/f82/a71/80b/f82a7180b571af10dc987145cde28488.jpg">  <b>Hi, Habr.</b> <br><br>  <a href="http://habrahabr.ru/company/toptechphoto/blog/221907/">Last time</a> I told you how we wrote Raw JavaScript converter, and you told me that it works slowly.  Today I want to talk about how we have accelerated our <a href="http://raw.pics.io/">raw.pics.io</a> almost <b>3 times</b> .  I will not post a sheet of code describing each step, I will try to tell you in general terms about the approaches to optimization that we used.  I also decided not to write about accessing the DOM, reducing the number of HTTP requests, gluing and minifying files, compression options on the server, etc.  All this technical work. <a name="habracut"></a>  about which they wrote <a href="http://habrahabr.ru/post/178561/">well</a> and <a href="http://habrahabr.ru/hub/client_side_optimization/">much</a> . <br><br><h4>  How it all began </h4><br>  We began by defining critical sections of code that take up most of the execution time.  Almost always in the programs there are nasty chunks that slow down the most - that's what you should start with.  Typically, the developer is roughly where the main time goes in his code, and finding what slows down is not difficult.  You only need to want.  In addition to sacred knowledge, we used a profiler and measured the execution time using console.time ().  In addition, now in browsers for these purposes appeared a convenient object performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Technology Optimization </h4><br>  Technological optimization is probably the most global of all approaches to increasing productivity.  You can change the language, the compiler, or the stack of technologies used to achieve the desired results.  In our case, the most significant performance gain gave the transition to parallel computing. <br><br><h6>  SIMD (Single Instructions Multiple Data) </h6><br>  Using MMX and SSE can achieve significant acceleration due to the rapid execution of operations on vectors.  Such a thing is already in many languages, and recently Intel <a href="https://01.org/node/1495">introduced an</a> extension of the language that adds such features to JavaScript.  This news delighted us.  We searched and even found the implementation in the nightly build of Firefox.  But the joy was premature.  After a couple of tests, we realized that now it is impossible to use.  The SIMD implementation we tried is very slow at the moment.  We continue to follow the development, but this technology is still quite raw for use. <br><br><h6>  Webcl </h6><br>  Another potentially interesting technology that we really want to use is WebCL.  A couple of months ago, the Khronos Group <a href="https://www.khronos.org/registry/webcl/specs/1.0.0/">published the</a> first specification describing the use of GPU power for parallel computing in the browser.  It sounds great, but so far it is available only in the form of synthetic tests for specially assembled versions of browsers, or in the form of plug-ins.  I hope we can test it towards the end of the year.  While not applicable for use at all.  = ( <br><br><h6>  Webworks </h6><br>  As a result, the task of debiting perfectly fell on WebWorkers, which turned out to be very convenient and easy to work with.  We divide the whole image into pieces and process each in its own stream.  First, we wrote our wrapper to manage WebWorkers, and now we use the <a href="http://adambom.github.io/parallel.js/">Parallel.js</a> library.  I had to take care of cutting and then gluing these pieces together.  It must be remembered that it takes some time to initialize each worker and there are difficulties with passing some types of data to the worker and back.  But the main problem: webworkers are not very convenient to debug.  Now this feature is only in Chrome.  Another interesting question: how to determine the optimal number of workers?  We found a correlation with the number of cores in the system, but in browsers there is still no way to determine their number. <br><br>  In general, of all that found, the most working were WebWorkers, who now work with us at raw.pics.io. <br><br><h4>  Algorithm level optimization </h4><br>  One of the important approaches is the selection of the correct architecture and fast algorithms.  We process arrays of 20,000,000+ elements, which means that accelerating the processing of each of the elements reduces the overall execution time.  Naturally, speeding up or getting rid of unnecessary operations can help a lot.  That is why we analyzed and selected a lot of interpolation algorithms, rewrote them several times, replaced mathematical operations with bit shifts and removed unnecessary checks and conditions.  These milliseconds on a large number of iterations gave significant savings.  For example, we were able to increase the speed of the algorithm due to the fact that the insignificant parts of the photo were not processed (inactive parts of the camera sensor) and the extra checks that did not affect the result were removed. <br><br><h4>  Optimization of structures and data types </h4><br><h6>  Typed Arrays </h6><br>  Modern browsers provide the ability to use fast typed arrays ( <a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/">typed arrays</a> ), which give a good performance <a href="http://jsperf.com/native-vs-typed-js-array-speed/29">boost</a> compared to conventional arrays.  This is not always applicable, but for operations that manipulate binary data, this is a real breath of fresh air.  Now all our calculations are built on typed arrays - without them it would be impossible to achieve the speed that we have now. <br><br><h6>  Simple structures </h6><br>  The very first version of our decoder contained beautiful data structures, with a hierarchy of classes and a bunch of modules.  Although this was correct from the point of view of the PLO, it slowed down during initialization and access to objects.  After we looked at it from the side and thought over the structure once more, I simplified everything to several modules.  This denormalization reduced the number of modules and connections between them, which made understanding a bit more difficult, but this was done consciously (for performance purposes). <br><br><h4>  Language level optimization </h4><br>  Nicholas Zakas has a great JavaScript performance <a href="http://www.nczonline.net/blog/tag/performance/page/3/">series</a> .  I will not consider everything that we did, but describe the main thing.  The decelerating code is added (obtained by the product =)) from the cost of the operation and the number of such operations.  And if we cannot reduce the number of iterations, then it is worth reducing the cost of each operation.  At each step, we had a function call, or even two.  Calling a function is quite an expensive operation and it makes sense to avoid them inside large cycles, since it is always very expensive.  In JavaScript, there is no mechanism (as in C ++) that allows the compiler to say that this function needs to be inserted inline, so we denormalize the code and get rid of these calls.  It became less readable, but more quickly.  Thanks to this approach, we have significantly increased the performance of large cycles. <br><br>  Also it should be understood that in your cycles are invariants and does not change at each iteration.  These invariants must be moved out of the cycle.  A simple <a href="http://jsperf.com/picsio-loops-test">example</a> : <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   for(var i=0; i&lt;items.length; i++) { //  ... } //     var size = items.length; for(var i=0;i&lt;size; i++){ //  ... }</span></span></code> </pre> <br><br>  In general, there are a lot of similar optimizations and all of them are very similar, but the essence is the same - to reduce the cost of the operation. <br><br>  Another good example is the so-called LookUpTables (LUT), in which we cache some values ‚Äã‚Äãinstead of recalculating them at each step of the loop.  Some variables (pixel brightness in our case) can be repeated and there is no point in calculating them at each step.  But the use of LUT is not always justified.  Sometimes (when elements vary greatly from iteration to iteration), the total cost of building this table is greater than the cost of calculating these elements. <br><br><h4>  Platform Level Optimization </h4><br>  JavaScript implementations of engines vary from browser to browser and the same code works differently in Chrome and FF.  I will not touch on this, since we have not done this kind of optimization yet, but I am sure that you can write code that is more adapted to a specific browser.  If anyone has any thoughts on this, please comment. <br><br><h4>  Perception optimization </h4><br>  The most interesting thing you can do is show the user the result as soon as possible.  This is also a kind of optimization that can give you a few seconds while the user is sad and looks at the rotating progress bar.  We can show some intermediate result, small pieces of a map or a pre-loaded image of low quality - we need to give the user the opportunity to begin to assimilate the information in at least some form.  For example, Pinterest before uploading images, shows rectangles filled with the average color of a particular image.  Due to this, the effect is created that it works faster.  We can do the same thing by showing embedded JPEG, and replacing it with the result of raw data processing. <br><br><h4>  When to finish </h4><br>  Each new optimization step gives a progressively smaller performance gain.  And as soon as the applied efforts are large enough (for example, you need to rewrite a large enough part of the code), and the performance gain is already minimal (less than 5%), then, most likely, you should stop and look.  Perhaps already enough, or you are doing something wrong.  Although if your operations are really long, an additional 5% can save users precious seconds. <br><br><h4>  Afterword </h4><br><h6>  Useful tools </h6><br>  Often it is worth choosing between execution speed and memory costs.  And although now the memory is already quite cheap, there are still cases when it is not enough.  Tracking who spends how much memory helps profiler.  But sometimes he is not enough to understand what is happening.  Google Chrome provides excellent developer tools.  Chrome can be run with interesting flags, which is sometimes very useful.  For example <a href="https://gist.github.com/yetithefoot/e466827c7756f6a7a03e">,</a> you can access the <i>memory</i> object and the <i>gc ()</i> method, which are usually not available.  And <a href="https://gist.github.com/yetithefoot/8098332">so</a> - redirect all errors directly to the terminal and find a lot of interesting things.  Chrome: // about is a complete list of Chrome-built utilities that can be a great help for debugging and development. <br><br><h6>  How to test options </h6><br>  When you have found one inhibitory piece and there are several options for optimization, you need to understand which one will work faster.  Instead of writing a few options, it is useful to run small synthetic tests.  We use <a href="http://jsperf.com/">jsperf.com</a> .  Such benchmarks make it clear which of the chosen approaches will be the most optimal.  And if you search, you can find many ready-made tests and rewrite / add them for your case. <br><br>  In general, whether or not to optimize (and most importantly, how), it is necessary to decide in each specific case and this decision depends on many factors that are difficult to structure.  Combining the above methods, we managed to speed up the conversion of RAW files several times, which at first seemed almost impossible.  And this means that you will succeed. <br><br><img src="//habrastorage.org/files/471/ed1/1fb/471ed11fbe9e497a8bc88206663d75fd.jpg"></div><p>Source: <a href="https://habr.com/ru/post/223773/">https://habr.com/ru/post/223773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223759/index.html">Published code engine for rendering PDF in Chrome browser</a></li>
<li><a href="../223761/index.html">Impressions of Lenovo Miix 2 8: a week with a tablet on Windows 8.1</a></li>
<li><a href="../223767/index.html">Multilingual Badoo: "translation difficulties"</a></li>
<li><a href="../223769/index.html">Keyword volatile and time attack</a></li>
<li><a href="../223771/index.html">Dauria gets involved in a large microsatellite race</a></li>
<li><a href="../223777/index.html">Our checklist for forms on sites</a></li>
<li><a href="../223779/index.html">Guinea pig, or one of the domestic production of MK</a></li>
<li><a href="../223783/index.html">Flask Mega-Tutorial, Part 7: Unit Testing</a></li>
<li><a href="../223785/index.html">The history of amperca</a></li>
<li><a href="../223789/index.html">(Kiev) May 26-27 seminar: Basic HP ProLiant skills from TC MUK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>