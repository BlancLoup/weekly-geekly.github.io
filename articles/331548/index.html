<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Connect: Modern Frontend Tips</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We recently released a new and improved version of Connect , our toolkit for platforms and stores. The Stripe design team has worked a lot to create u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Connect: Modern Frontend Tips</h1><div class="post__text post__text-html js-mediator-article">  We recently released a new and improved version of <a href="https://stripe.com/connect">Connect</a> , our toolkit for platforms and stores.  The Stripe design team has worked a lot to create <a href="https://stripe.com/atlas">unique landing pages</a> that <a href="https://stripe.com/sigma">tell a story</a> for our main products.  We have prepared a Connect landing page for the release to reflect these intricate, advanced features, but at the same time without losing clarity and simplicity of presentation. <br><br>  In this article, we describe how several of the next-generation web technologies were used to launch Connect, and go over some of the small technical details of our front-end travel. <br><a name="habracut"></a><br><h3>  CSS grid layout </h3><br>  Earlier this year, three major browsers (Firefox, Chrome and Safari) almost simultaneously rolled out their implementations of the new <a href="https://www.w3.org/TR/css-grid-1/">CSS Grid Layout</a> module.  These specifications give developers a two-dimensional layout system that is easy to use and incredibly powerful.  <a href="https://stripe.com/connect">The</a> Connect <a href="https://stripe.com/connect">landing page</a> relies on CSS grids almost everywhere, which makes some seemingly tricky design solutions simple to implement.  As an example, let's hide the contents of the header and focus on the background: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/427/2e4/d69/4272e4d691d1b4fb39c9d7ab0fcd9965.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Historically, we created such background stripes (stripes) using absolute positioning to precisely place each strip on the page.  This method works, but fragile positioning often leads to small problems: for example, due to rounding errors, a gap of 1 px may form.  Style sheets also swell up quickly and are harder to maintain because media queries are complicated to account for differences in background on different screen sizes. <br><br>  CSS Grid eliminates almost all these problems.  We simply define a flexible grid and place the stripes in the appropriate cells.  Firefox has a handy <a href="https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector/How_to/Examine_grid_layouts">grid inspector</a> that visualizes the structure of your layout.  Let's see what it looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d81/ba1/382/d81ba13825675d07b67eda0cfaa07346.png"><br><br>  We selected three stripes and removed the tilt effect for clarity.  Here is what the corresponding CSS code will look like: <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.stripes</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(5, 200px) / <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(10, 1fr); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.stripes</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:nth-child(1)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.stripes</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:nth-child(2)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> / span <span class="hljs-number"><span class="hljs-number">3</span></span> / auto / -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.stripes</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:nth-child(3)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  Then we can simply transform the entire <code>.stripes</code> container to get a tilt effect: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ded/60c/5c8/ded60c5c85308a2e9cf7ed1da1b23547.png"><br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.stripes</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">skewY</span></span>(-12deg); <span class="hljs-attribute"><span class="hljs-attribute">transform-origin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  And voila!  The CSS Grid may scare at first sight, as it is accompanied by an unusual syntax and many new properties and values, but the mental model is actually very simple.  And if you are familiar with Flexbox, you already know the <a href="https://www.w3.org/TR/css-align-3/">Box Alignment</a> module, which means you can also use familiar properties that you like so much, such as <code>justify-content</code> and <code>align-items</code> . <br><br><h3>  CSS 3D </h3><br>  The title page shows several cubes as a visual metaphor of the building blocks that make up Connect.  These flying cubes rotate in 3D at random speeds (in a certain range) and are illuminated by a single light source that dynamically highlights the corresponding surfaces of the video: <a href="">cubes.mp4</a> <br><br> <a href=""><img src="https://habrastorage.org/web/bd3/a1c/cae/bd3a1ccae1a249de88c51eaf8b6492f3.png"></a> <br><br>  These cubes are simple DOM elements that are generated and animated by JavaScript.  Each of them is confirmed by one HTML <code>template</code> : <br><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- HTML --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cube-template"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cube"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"shadow"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sides"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"back"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"top"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"left"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"front"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"right"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bottom"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> // JavaScript const createCube = () =&gt; { const template = document.getElementById("cube-template"); const fragment = document.importNode(template.content, true); return fragment; };</code> </pre> <br>  Nothing complicated.  Now we can quite easily convert these clean and empty elements into three-dimensional form.  Thanks to 3D transformations, adding perspective and moving sides along z-axes is quite natural: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.cube</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.cube</span></span> * { <span class="hljs-attribute"><span class="hljs-attribute">position</span></span>: absolute; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100px</span></span> } <span class="hljs-selector-class"><span class="hljs-selector-class">.sides</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform-style</span></span>: preserve-<span class="hljs-number"><span class="hljs-number">3</span></span>d; <span class="hljs-attribute"><span class="hljs-attribute">perspective</span></span>: <span class="hljs-number"><span class="hljs-number">600px</span></span> } <span class="hljs-selector-class"><span class="hljs-selector-class">.front</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(0deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) } <span class="hljs-selector-class"><span class="hljs-selector-class">.back</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(-180deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) } <span class="hljs-selector-class"><span class="hljs-selector-class">.left</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(-90deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) } <span class="hljs-selector-class"><span class="hljs-selector-class">.right</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(90deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) } <span class="hljs-selector-class"><span class="hljs-selector-class">.top</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateX</span></span>(90deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) } <span class="hljs-selector-class"><span class="hljs-selector-class">.bottom</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateX</span></span>(-90deg) <span class="hljs-built_in"><span class="hljs-built_in">translateZ</span></span>(50px) }</code> </pre> <br>  Although CSS makes it trivial to model a cube, it does not provide advanced animation features, such as dynamic shading.  Instead, the cube animation relies on <code>requestAnimationFrame</code> to calculate and update each side at any point of rotation.  In each frame, you need to define three things: <br><br><ul><li>  <b>Visibility</b>  At any given time, no more than three sides are visible, so that unnecessary calculations and resource-intensive repainting on hidden sides can be avoided. </li><li>  <b>Transformation</b>  Each side of the cube must be transformed depending on its initial rotation, the current state of the animation, and the speed along each axis. </li><li>  <b>Shading</b>  Although CSS allows you to position elements in three-dimensional space, there are no traditional concepts from a 3D environment (for example, light sources).  To simulate a 3D environment, we can render a light source by progressively darkening the sides of the cube as it moves away from a certain point. </li></ul><br>  There are other considerations that need to be taken into account (for example, performance improvements using <code>requestIdleCallback</code> in JavaScript and <code>backface-visibility</code> in CSS), but these are the main bases for the logic of animation. <br><br>  We can calculate the visibility and transformation for each side by continuously monitoring their states and updating them using simple mathematical operations.  When using <a href="https://alistapart.com/article/making-your-javascript-pure">pure</a> ES2015 <a href="https://alistapart.com/article/making-your-javascript-pure">functions</a> and features, such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a> , everything becomes even easier.  Here are two short javascript code snippets for computing and defining the current transformation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getDistance = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, rotate</span></span></span><span class="hljs-function">) =&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object, axis</span></span></span><span class="hljs-function">) =&gt;</span></span> { object[axis] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(state[axis] + rotate[axis]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object; }, {}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getRotation = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, size, rotate</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axis = rotate.x ? <span class="hljs-string"><span class="hljs-string">"Z"</span></span> : <span class="hljs-string"><span class="hljs-string">"Y"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> direction = rotate.x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` rotateX(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.x + rotate.x}</span></span></span><span class="hljs-string">deg) rotate</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${axis}</span></span></span><span class="hljs-string">(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${direction * (state.y + rotate.y)}</span></span></span><span class="hljs-string">deg) translateZ(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${size </span></span><span class="hljs-regexp"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">/ 2}px) `; };</span></span></span></span></span></span></code> </pre> <br>  The most difficult piece of the puzzle is how to correctly calculate the shading for each side of the cube.  To simulate a virtual light source in the center of the scene, we can gradually increase the effect of lighting each side as it approaches the center point - on all axes.  Specifically, this means that we need to calculate the brightness and color for each side.  We will perform this calculation in each frame, interpolating the base color and the current shading factor. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Linear interpolation between a and b // Example: (100, 200, .5) = 150 const interpolate = (a, b, i) =&gt; a * (1 - i) + b * i; const getShading = (tint, rotate, distance) =&gt; { const darken = ["x", "y"].reduce((object, axis) =&gt; { const delta = distance[axis]; const ratio = delta / 180; object[axis] = delta &gt; 180 ? Math.abs(2 - ratio) : ratio; return object; }, {}); if (rotate.x) darken.y = 0; else { const {x} = distance; if (x &gt; 90 &amp;&amp; x &lt; 270) directions.forEach(axis =&gt; darken[axis] = 1 - darken[axis]); } const alpha = (darken.x + darken.y) / 2; const blend = (value, index) =&gt; Math.round(interpolate(value, tint.shading[index], alpha)); const [r, g, b] = tint.color.map(blend); return `rgb(${r}, ${g}, ${b})`; };</span></span></code> </pre> <br>  Whew!  Fortunately, the rest of the code is much simpler and consists mainly of template code, DOM-helpers and other elementary abstractions.  The last detail to be mentioned is the technique that makes the animation less intrusive, depending on the user's settings: <a href="">video</a> . <br><br> <a href=""><img src="https://habrastorage.org/web/0b8/db3/7ac/0b8db37acec747218635d76dc8d1cd71.jpg"></a> <br>  <font color="gray">Click to view video</font> <br><br>  On macOS, when <i>Reduce Motion</i> mode is enabled in the settings, the trigger on the new media request <code>prefers-reduced-motion</code> (while in Safari only) will work, and all decorative animations on the page will be turned off.  Cubes simultaneously use CSS animations for shading and JavaScript animation for rotation.  We can disable these animations by a combination of <code>@media</code> locks and the <code>MediaQueryList Interface</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/* CSS */</span></span> @media (prefers-reduced-motion) { #<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>-hero * { animation: <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> } } // JavaScript const reduceMotion = matchMedia("(prefers-reduced-motion)").matches; const tick = () =&gt; { cubes.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(updateSides); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reduceMotion) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; requestAnimationFrame(tick); };</code> </pre> <br><h3>  More CSS 3D! </h3><br>  Throughout the site, we use custom 3D computer devices as a showcase for Stripe customers and available applications.  In our endless quest to reduce file size and load time, we considered several options for how to achieve a three-dimensional view with a small file size and resolution independence.  Drawing devices directly into CSS met our requirements.  Here is a CSS laptop: <br><br><img src="https://habrastorage.org/web/d05/d1c/557/d05d1c557ccf4cea9cad51fa6f130a4d.jpg"><br><br>  Defining an object in CSS is definitely less convenient than exporting a bitmap, but it's worth it.  The laptop at the top takes less than one kilobyte and is easy to configure.  We can add hardware acceleration, animate any part, make it interactive without loss of image quality, and precisely position DOM elements (for example, other images) on the laptop display.  This flexibility does not mean that you need to give up clean code - the markup remains clean, concise and visual: <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">laptop</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadow</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">lid</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">camera</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">screen</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">chassis</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">keyboard</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">trackpad</span></span>"&gt;&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt;</code> </pre> <br>  Laptop styling includes a mixture of gradients, shadows and transformations.  In many ways, this is a simple translation of the workflow and concepts that you know and use in your graphical tools.  For example, here is the CSS code for the cover: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.laptop</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.lid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">position</span></span>: absolute; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">linear-gradient</span></span>(45deg, #E5EBF2, #F3F8FB); <span class="hljs-attribute"><span class="hljs-attribute">box-shadow</span></span>: inset <span class="hljs-number"><span class="hljs-number">1px</span></span> -<span class="hljs-number"><span class="hljs-number">4px</span></span> <span class="hljs-number"><span class="hljs-number">6px</span></span> <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(145, 161, 181, .3) }</code> </pre> <br>  Choosing the right tool for the job is not always obvious - the choice between CSS, SVG, Canvas, WebGL and images is not as clear as it should be.  It is easy to abandon CSS as an exclusive format for presenting documents, but it‚Äôs just as easy to go beyond and over-use its visual capabilities.  No matter which technology you choose, optimize it for the user!  So pay close attention to client-side performance, availability, and rollback options for older browsers. <br><br><h3>  Web Animations API </h3><br> <a href=""><img src="https://habrastorage.org/web/276/db5/773/276db5773f5d45b9824a9a9baef78a25.jpg" align="left"></a>  The <a href="https://stripe.com/connect">Onboarding &amp; Verification</a> section features a demo of <b>Express</b> , a new adaptation system for novice Connect users.  All the animation is entirely based on the program code and mainly relies on the new <a href="https://www.w3.org/TR/web-animations-1/">Web Animations API</a> . <br><br>  The Web Animations API provides <code>@keyframes</code> performance and simplicity in JavaScript, making it easy to create a smooth sequence of animation frames.  Unlike the low-level <code>requestAnimationFrame</code> interfaces, here you get all the niceties of CSS animations, such as native support for <code>cubic-bezier</code> emollient functions.  As an example, take a look at our code for sliding the keyboard: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toggleKeyboard = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, callback, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyframes = { <span class="hljs-attr"><span class="hljs-attr">transform</span></span>: [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`translateY(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${n}</span></span></span><span class="hljs-string">%)`</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">"forwards"</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">"cubic-bezier(.2, 1, .2, 1)"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: action == <span class="hljs-string"><span class="hljs-string">"hide"</span></span> ? <span class="hljs-string"><span class="hljs-string">"reverse"</span></span> : <span class="hljs-string"><span class="hljs-string">"normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> animation = element.animate(keyframes, options); animation.addEventListener(<span class="hljs-string"><span class="hljs-string">"finish"</span></span>, callback, {<span class="hljs-attr"><span class="hljs-attr">once</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); };</code> </pre> <br>  Nice and easy!  Web Animations APIs cover the absolute majority of typical UI animations that can be needed without third-party dependencies (as a result, all Express animation takes about 5 KB, including everything: scripts, images, etc.).  It must be said that this is not a complete replacement for <code>requestAnimationFrame</code> , it still provides more subtle control over the animation and allows effects that you would not otherwise get, such as Spring Curve and independent transformation functions.  If you are not sure which technology to choose for your animations, then you can probably arrange the options in the following priority order: <br><br><ol><li>  <b>CSS Transitions</b> .  This is the fastest, easiest and most efficient way to animate  Suitable for simple things like <code>hover</code> effects. </li><li>  <b>CSS animations</b> .  They have the same performance characteristics as transitions: these are declarative animations that can be highly optimized by browsers and executed in separate streams.  CSS animations are more functional than transitions, and allow multiple steps and multiple iterations.  They are also more difficult to implement because they require named declarations <code>@keyframes</code> , and often explicit <code>animation-fill-mode</code> .  (And named pieces have always been the hardest parts of computer science!) </li><li>  <b>Web Animations API</b> .  This programming interface provides <i>almost</i> the same performance as CSS animations (these animations are carried out by the same engine, but the JavaScript code still works in the main thread), and they are almost as easy to use.  They should be your first choice for any animation where interactivity, random effects, programmable sequences and everything that is more functional than purely declarative animation is needed. </li><li>  <b>requestAnimationFrame</b> .  There are no borders in the universe, but you need to build a spaceship.  The possibilities here are endless, and the rendering methods are unlimited (HTML, SVG, canvas - whatever), but this technology is much more difficult to use and it may not work as well as the previous versions. </li></ol><br>  No matter what technique you use, here are some simple tips that you can always use to make your animation look much better: <br><br><ul><li>  <b>Custom curves</b> .  You hardly want to use inline <code>timing-function</code> like <code>ease-in</code> , <code>ease-out</code> and <code>linear</code> .  You will save a lot of time if you globally determine the number of <a href="http://tinyurl.com/css-easings">cubic-bezier custom variables</a> . </li><li>  <b>Performance</b> .  By all means, avoid <a href="http://jankfree.org/">slowdowns</a> in your animations.  In CSS, for this, you should exclusively animate cheap properties ( <code>transform</code> and <code>opacity</code> ) and drop animations on the GPU whenever possible (using <code>will-change</code> ). </li><li>  <b>Speed</b>  Animations should never interfere.  The main task of animations is to make the interface responsive, harmonious, pleasant and complete.  There is no hard limit on the duration of the animation, it depends on the effects and the curve, but in most cases you should not exceed 500 seconds. </li></ul><br><h3>  Intersection observer </h3><br>  Express animation begins playing automatically as soon as it appears in the field of view (you can experience this by <a href="https://stripe.com/connect">scrolling through the page</a> ).  Usually this is accompanied by observation of scrolling, which works as a trigger, but historically it has been implemented through resource-intensive event listeners, which led to verbose and inefficient code. <br><br>  The Connect landing page uses the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer API</a> , which provides a much, much more reliable and productive way to determine element visibility.  Here is how we begin to play the Express animation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observeScroll = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[entry]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry.intersectionRatio &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; callback(); <span class="hljs-comment"><span class="hljs-comment">// Stop watching the element observer.disconnect(); },{ threshold: 1 }); // Start watching the element observer.observe(element); }; const element = document.getElementById("express-animation"); observeScroll(element, startAnimation);</span></span></code> </pre> <br>  The helper <code>observeScroll</code> makes it easier for us to detect (for example, when an element is fully visible, the callback is generated only once) without executing any code in the main thread.  Thanks to the Intersection Observer API, we are now one step closer to absolutely smooth web pages! <br><br><h3>  Polyfills and kickbacks </h3><br>  All these new and brilliant software interfaces are very nice, but unfortunately, they are not yet universally available.  A typical workaround is the use of a polyfill, which checks for the presence of a feature for a specific API and is executed only if that API is not present.  An obvious disadvantage of this approach is that it takes resources <i>from everyone and always</i> , forcing everyone to download a polyfill, regardless of whether it is used or not.  We chose another solution. <br><br>  <b>For JavaScript APIs, the</b> Connect landing page performs a test on whether a polyfill is needed and can dynamically load it onto the page.  The scripts are dynamically created and added to the document, they are asynchronous by default, that is, the order of execution is not guaranteed.  Obviously, this is a problem, since this script can be executed earlier than the expected polyfill.  Fortunately, this can be corrected by explicitly indicating that our scripts are <i>not</i> asynchronous and therefore are lazily loaded only when necessary: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> insert = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> el = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"script"</span></span>); el.src = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">.js`</span></span>; el.async = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Keep the execution order document.head.appendChild(el); }; const scripts = ["main"]; if (!Element.prototype.animate) scripts.unshift("web-animations-polyfill"); if (!("IntersectionObserver" in window)) scripts.unshift("intersection-observer-polyfill"); scripts.forEach(insert);</span></span></code> </pre> <br>  <b>For CSS, the</b> problem and solutions are in many ways the same as for JavaScript polyfills.  A typical way to use modern CSS features is to write a rollback first, and then overlap it, if possible: <br><br><pre> <code class="javascript hljs">div { <span class="hljs-attr"><span class="hljs-attr">display</span></span>: flex } @supports (display: grid) { div { <span class="hljs-attr"><span class="hljs-attr">display</span></span>: grid } }</code> </pre> <br>  CSS function requests are simple, robust, and most likely they should be used first.  However, they are not suitable for our audience, because about <b>90% of</b> our visitors already use a Grid-compatible browser.  In our case, it makes no sense to penalize the absolute majority of visitors with hundreds of rollback rules for a small and decreasing share of browsers.  Given this statistic, we chose to dynamically create and insert a style sheet with rollback when necessary: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Some browsers not supporting Grid don't support CSS.supports // either, so we need to feature-test it the old-fashioned way: if (!("grid" in document.body.style)) { const fallback = "&lt;link rel=stylesheet href=fallback.css&gt;"; document.head.insertAdjacentHTML("beforeend", fallback); }</span></span></code> </pre> <br><h3>  The finish! </h3><br>  We hope you enjoyed (and perhaps benefited) from these frontend tips!  Modern browsers give us powerful tools for creating rich, fast and attractive interfaces, allowing you to be creative.  If you are just as excited about the opportunities as we are, we probably should <a href="https://stripe.com/jobs%3Fref%3Dblog">experiment together</a> . </div><p>Source: <a href="https://habr.com/ru/post/331548/">https://habr.com/ru/post/331548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331538/index.html">Russia vs Mexico: a historic robots football game driven by fans via Twitter</a></li>
<li><a href="../331540/index.html">Static call script</a></li>
<li><a href="../331542/index.html">Guide: how to use Python for algorithmic trading on the exchange. Part 1</a></li>
<li><a href="../331544/index.html">Mikrotik: Balancing in the CPSU and the observance of speed limits</a></li>
<li><a href="../331546/index.html">Installing ArchLinux ARM next to Android without chroot</a></li>
<li><a href="../331552/index.html">Autoencoders in Keras, Part 3: Variational autoencoders (VAE)</a></li>
<li><a href="../331554/index.html">New features of C # that can be expected soon</a></li>
<li><a href="../331556/index.html">Automated programming - a new milestone or myth? Part 1. Introduction</a></li>
<li><a href="../331558/index.html">Whether to limit users on resources?</a></li>
<li><a href="../331560/index.html">Selection of the distribution law of a random variable according to statistical sampling using Python tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>