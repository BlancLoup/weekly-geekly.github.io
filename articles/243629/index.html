<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Organization of simultaneous access to data in the cloud storage Microsoft Azure Storage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modern web applications, situations often arise when several users simultaneously work with the same data. 

 In order to ensure the success of eac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Organization of simultaneous access to data in the cloud storage Microsoft Azure Storage</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/603/741/e10/603741e10cc94afba95b6ec33db3b946.png" width="655"><br><br>  In modern web applications, situations often arise when several users simultaneously work with the same data. <br><br>  In order to ensure the success of each user‚Äôs actions, application developers need to carefully consider the processing and implementation of such scenarios, especially in those cases when simultaneous processing of data by a group of users is really necessary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most often, developers use the following three strategies for managing concurrent access to data: <br><a name="habracut"></a><br><ol><li>  <b>Optimistic concurrency</b> <b><br></b> <br>  The application will update the data only after checking it for changes since it was last accessed. <br><br>  For example, two users view the same wiki page, and then simultaneously decide to update it. <br><br>  In this case, the platform wiki must provide a process in which the update of the second user does not replace the update of the first, and both users will understand whether the action of each of them was performed. <br><br>  This strategy is used in web applications most often. <br><br></li><li>  <b>Pessimistic concurrency</b> <b><br></b> <br>  In this case, the application locks the updated data, and until the lock is released, i.e.  until the first user has finished editing the data, access to them will be restricted for other users. <br><br>  For example, in master / slave data replication scenarios, where only the master performs updates, as a rule, only he can establish a long-term data lock to prevent anyone else from editing the data. <br><br></li><li>  <b>"Wins the last" (Last writer wins)</b> <br><br>  This approach allows you to perform any operations with data without checking the data for an update since the last time the application was accessed. <br><br>  This strategy (or lack of a formal strategy) is usually applied where data is distributed in such a way that the probability of having multiple users accessing the same section is excluded. <br><br>  The method described above is also useful in processing short-term data streams. <br></li></ol><br>  This article will discuss how the Azure Storage platform simplifies the development of applications using data warehousing, providing support for all three concurrent access strategies. <br><br><h3>  Azure Storage - simplifies cloud development </h3><br>  Azure Storage supports all three concurrent data access strategies, although there are some features to support optimistic and pessimistic concurrency, since the repositories were originally designed for a strict concurrency model to ensure that at the moment the storage service completes the add and edit operations, all subsequent references to this data will find the latest update. <br><br>  Storage platforms that use the consistency model contain a lag - delay between the period when one user is recording and the period when the updated data is visible to other users, which complicates the development of client applications due to the need to prevent data inconsistencies for end users. <br><br>  In addition to choosing the right data access strategy, developers need to pay attention to how the storage platform organizes change isolation ‚Äî partial changes to the same objects in transactions. <br><br>  Azure Storage service uses isolation with snapshots to enable simultaneous read and write within a single partition. <br><br>  Unlike other isolation levels, isolation by snapshots ensures that all read operations see a consistent data snapshot even at the time of the updates taking place, especially when the last stored values ‚Äã‚Äãare returned during the execution of the update transaction. <br><br><h3>  Organization of simultaneous access to blobs </h3><br>  You can choose which parallelism strategy to use to control access to blob objects and containers in the blob service. <br><br>  If you do not explicitly specify a strategy, the ‚ÄúWins Last‚Äù strategy will be used by default. <br><br><h4>  Optimistic concurrency for blobs and containers </h4><br>  The storage service assigns an identifier for each stored object.  This ID is updated each time an update operation is performed on an object.  The identifier is returned to the client as part of the response to the HTTP GET request, using the ETag header (entity tag) defined in the HTTP protocol. <br><br>  A user performing an update on such an object can send along with the original ETag a conditional header in order to make sure that the update will occur only under certain conditions - in this case the condition is the ‚ÄúIf-Match‚Äù header that is required by the storage service. <br><br>  Below is a general outline of this process: <br><br><ol><li>  We get a blob from the repository service, the response includes an HTTP ETag header parameter that identifies the current version of the object in the repository service. </li><li>  When you update the blob, include the received ETag parameter from the previous step in the conditional header of the <b>If</b> <b>-</b> <b>Match</b> request that you send to the service. </li><li>  The service compares the ETag value in the request with the current ETag value in the blob. </li><li>  If the current ETag value of the blob differs from the ETag in the <b>If</b> <b>-</b> <b>Match</b> request header, the service returns error 412 to the client. This indicates to the client that another process has updated the blob since the client requested it. </li><li>  If the current ETag value does not differ from the ETag value in the request header, the service will perform the requested operation and update the current ETag value of the blob to show that the data has been updated. </li></ol><br>  The C # snippet below shows a simple example of creating an If-Match condition using the <b>AccessCondition</b> class based on the ETag value, which was derived from the properties of a previously extracted or added blob. <br><br>  This condition then uses the <b>AccessCondition</b> object during a <b>blob</b> update: the AccessCondition object adds an If-Match header to the request. <br><br>  If another process has updated the blob, the blob service will return an HTTP 412 message (Precondition Failed). <br><br>  A full example can be downloaded <a href="http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114">here</a> . <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  Etag  ,   - UploadText string orignalETag = blockBlob.Properties.ETag; //       string helloText = "Blob updated by a third party."; //    etag,     (   etag) blockBlob.UploadText(helloText); Console.WriteLine("Blob updated. Updated ETag = {0}", blockBlob.Properties.ETag); //    ,   ETag,     try { Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition"); blockBlob.UploadText(helloText,accessCondition: AccessCondition.GenerateIfMatchCondition(orignalETag)); } catch (StorageException ex) { if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed) { Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches"); } }</span></span></code> </pre> <br><br>  The vault service also supports other conditional headers, such as <b>If</b> <b>-</b> <b>Modified</b> <b>-</b> <b>Since</b> , <b>If</b> <b>-</b> <b>Unmodified</b> <b>-</b> <b>Since,</b> and <b>If</b> <b>-</b> <b>None</b> <b>-</b> <b>Match</b> <b>.</b> <br><br>  Additional information <a href="http://msdn.microsoft.com/ru-ru/library/dd179371.aspx">documentation on MSDN</a> . <br><br>  The table shows the operations on containers that accept conditional headers, such as <b>If</b> <b>-</b> <b>Match,</b> in the request and return the ETag in the response: <br><table border="1"><tbody><tr><td width="270">  <b>Operation</b> </td><td width="288">  <b>Returns</b> <b>the</b> <b>ETag</b> <b>value</b> <b>.</b> </td><td width="351">  <b>Accepts conditional headers</b> </td></tr><tr><td width="270">  Create Container </td><td width="288">  Yes </td><td width="351">  No </td></tr><tr><td width="270">  Get Container Properties </td><td width="288">  Yes </td><td width="351">  No </td></tr><tr><td width="270">  Get Container Metadata </td><td width="288">  Yes </td><td width="351">  No </td></tr><tr><td width="270">  Set container metadata </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get Container ACL </td><td width="288">  Yes </td><td width="351">  No </td></tr><tr><td width="270">  Set container ACL </td><td width="288">  Yes </td><td width="351">  Yes (*) </td></tr><tr><td width="270">  Delete Container </td><td width="288">  No </td><td width="351">  Yes </td></tr><tr><td width="270">  Lease container </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  List blobs </td><td width="288">  No </td><td width="351">  No </td></tr></tbody></table><br>  (*) The permissions defined by SetContainerACL are cached, and their update takes 30 seconds, during which the update consistency is not guaranteed. <br><br>  The table shows blob operations that accept conditional headers in the request, such as If-Match, and return an ETag value: <br><table border="1"><tbody><tr><td width="270">  <b>Operation</b> </td><td width="288">  <b>Returns the ETag value.</b> </td><td width="351">  <b>Accepts conditional headers</b> </td></tr><tr><td width="270">  Put blob </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get blob </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get blob properties </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Set Blob Properties </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get blob metadata </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Set blob metadata </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Lease Blob (*) </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Snapshot blob </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Copy blob </td><td width="288">  Yes </td><td width="351">  Yes (for source and destination blob) </td></tr><tr><td width="270">  Abort Copy Blob </td><td width="288">  No </td><td width="351">  No </td></tr><tr><td width="270">  Delete Blob </td><td width="288">  No </td><td width="351">  Yes </td></tr><tr><td width="270">  Put block </td><td width="288">  No </td><td width="351">  No </td></tr><tr><td width="270">  Put block list </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get block list </td><td width="288">  Yes </td><td width="351">  No </td></tr><tr><td width="270">  Put page </td><td width="288">  Yes </td><td width="351">  Yes </td></tr><tr><td width="270">  Get page ranges </td><td width="288">  Yes </td><td width="351">  Yes </td></tr></tbody></table><br>  (*) Leasing a blob does not change its etag. <br><br><h4>  Pessimistic concurrency in blobs </h4><br>  To block a blob for exclusive use, a leasing mechanism is applied.  When using leasing, you specify its duration: 15 - 60 seconds, or without termination, which means exceptional blocking.  You can also extend the lock, or unlock the blob after you finish working with it.  The blob service automatically disables leasing if it expires on the blob. <br><br>  Leasing allows you to use different synchronization strategies, including exclusive write / split read, exclusive write / exclusive read, split write / exclusive read. <br><br>  Where leasing exists, the storage service organizes an exclusive record (put, set, delete operations).  To ensure the exclusivity of reading operations, the developer is required to ensure that all client applications use the leasing identifier, and only one client has a suitable leasing identifier at a time.  Reading operations that do not include a leasing identifier occur in split reading. <br><br>  The code below (C #) shows an exclusive 30 second lease on the blob, an update on the blob, and an end to the lease.  If the necessary lease on the blob is already installed, then when trying to install a new one, the blob service will return the result ‚ÄúHTTP (409) Conflict‚Äù. <br><br>  When creating a request to update a blob in the storage service, in the code, for the information on leasing, the AccessCondition object is used. <br><br>  A full example can be downloaded <a href="http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114">here</a> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    15  string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null); Console.WriteLine("Blob lease acquired. Lease = {0}", lease); //  ,  .     const string helloText = "Blob updated"; var accessCondition = AccessCondition.GenerateLeaseCondition(lease); blockBlob.UploadText(helloText, accessCondition: accessCondition); Console.WriteLine("Blob updated using an exclusive lease"); //       Simulate third party update to blob without lease try { //    ,       Console.WriteLine("Trying to update blob without valid lease"); blockBlob.UploadText("Update without lease, will fail"); } catch (StorageException ex) { if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed) Console.WriteLine("Precondition failure as expected. Blob's lease does not match"); else throw; }</span></span></code> </pre><br>  If you perform a write operation on a blob with leasing without transferring the leasing identifier, the request will fall with error 412. Please note - if the leasing period expires before calling the <b>UploadText</b> method <b>,</b> and you still pass the leasing identifier, the request again drops with error 412. <br><br>  For information on managing the duration of the lease and the lease ID, see the <a href="http://msdn.microsoft.com/library/azure/ee691972.aspx/">documentation</a> . <br><br>  The following list describes blob operations that can use leasing for pessimistic concurrency: <br><ul><li>  Put blob </li><li>  Get blob </li><li>  Get blob properties </li><li>  Set Blob Properties </li><li>  Get blob metadata </li><li>  Set blob metadata </li><li>  Delete Blob </li><li>  Put block </li><li>  Put block list </li><li>  Get block list </li><li>  Put page </li><li>  Get page ranges </li><li>  Snapshot Blob - no leasing id required </li><li>  Copy Blob - an identifier is required if leasing is installed on the blob </li><li>  Abort Copy Blob - an identifier is required if unlimited leasing is installed on the blob </li><li>  Lease blob </li></ul><br><br><h4>  Pessimistic concurrency for containers </h4><br>  Container leasing provides support for the same synchronization strategy as for blobs (exclusive write / split read, exclusive write / exclusive read, and split write / exclusive read), however, unlike blobs, the storage service uses an exclusivity strategy for deletion operations. <br><br>  To remove the active leasing container, the customer must include the active leasing identifier in the removal request. <br><br>  Other operations on a leasing container do not have to contain a leasing identifier, and such operations are called shared. <br><br>  If an exclusive update (put or set) or read operation is required, then developers need each client to use the leasing identifier and only one client to use the currently suitable identifier. <br><br>  The following are container operations that can use leasing for pessimistic concurrency: <br><ul><li>  Delete Container </li><li>  Get Container Properties </li><li>  Get Container Metadata </li><li>  Set container metadata </li><li>  Get Container ACL </li><li>  Set container ACL </li><li>  Lease container </li></ul><br>  Additional Information: <br><ul><li>  <a href="http://msdn.microsoft.com/library/azure/dd179371.aspx/">Using conditional headers for blob service operations</a> </li><li>  <a href="http://msdn.microsoft.com/library/azure/jj159103.aspx/">Container leasing</a> </li><li>  <a href="http://msdn.microsoft.com/library/azure/ee691972.aspx/">Blob leasing</a> </li></ul><br><h3>  Organization of parallelism in the service Tables </h3><br>  The table service, while working with entities, by default uses an optimistic strategy for simultaneous access to data, as opposed to a blob service, where it is necessary to explicitly choose to use optimistic parallelism. <br><br>  Another difference between table and blob services is that with tables you can control the behavior of concurrent access only for entities, while for the blob service you can control concurrency, both when accessing containers and blobs. <br><br>  To use optimistic concurrency and check whether the entity has been modified by another process since its selection from the table service, you can use the ETag value obtained during the selection. <br><br>  An outline of this process is presented below: <br><br><ol><li>  Extracting an entity from a table storage service.  The response includes the value of ETag - the current identifier associated with the entity in the repository. </li><li>  When you update an entity, include the received ETag parameter from the previous step in the conditional header of the <b>If</b> <b>-</b> <b>Match</b> request that you send to the service. </li><li>  The service compares the ETag value in the request with the current ETag value of the entity. </li><li>  If the current ETag of the entity is different from the ETag in the <b>If</b> <b>-</b> <b>Match</b> request header, the service returns an error 412 to the client. This indicates to the client that the other process has updated the entity since the client has requested it. </li><li>  If the current ETag value does not differ from the ETag value in the <b>If</b> <b>‚Äì</b> <b>Match</b> or Header request header, the header contains the symbol (*), the service will perform the requested operation and update the current ETag value of the entity to indicate that the data has been updated. </li></ol><br>  Note that unlike the blob service, the table service requires the client to include an <b>If</b> <b>-</b> <b>Match</b> header in the update requests.  However, the possibility of forced unconditional update (the strategy ‚Äúwins the last‚Äù) remains and the inspection bypasses when the client sets the <b>If</b> <b>-</b> <b>Match</b> header <b>value to the (*) character</b> in the request. <br><br>  The code below (C #) demonstrates the customer entity, created or selected from existing data with an updated email address.  The initial insert or retrieval stores the ETag value in the customer object, and since the example uses the same instance of the object during the execution of the replace operation, it automatically sends the ETag value back to the table service, allowing the service to check for a violation while accessing simultaneously. <br><br>  If another process has updated the entity in the table storage, the service returns an HTTP 412 (Precondition Failed) message. <br><br>  A full example is available <a href="http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114">here.</a> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { customer.Email = <span class="hljs-string"><span class="hljs-string">"updatedEmail@contoso.org"</span></span>; TableOperation replaceCustomer = TableOperation.Replace(customer); customerTable.Execute(replaceCustomer); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Replace operation succeeded."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (StorageException ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex.RequestInformation.HttpStatusCode == <span class="hljs-number"><span class="hljs-number">412</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Optimistic concurrency violation ‚Äì entity has changed since it was retrieved."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre><br><br>  To explicitly block the simultaneous access check, you must set the ETag property of the employee object to ‚Äú*‚Äù before performing the update operation. <br><br>  <b>customer.ETag = ‚Äú*‚Äù;</b> <br><br>  The table shows how table operations use ETag values: <br><table border="1"><tbody><tr><td width="279">  <b>Operations</b> </td><td width="306">  <b>Returns the ETag value.</b> </td><td width="342">  <b>Requires</b> <b>conditional</b> <b>headers</b> </td></tr><tr><td width="279">  Query Entities </td><td width="306">  Yes </td><td width="342">  No </td></tr><tr><td width="279">  Insert entity </td><td width="306">  Yes </td><td width="342">  No </td></tr><tr><td width="279">  Update Entity </td><td width="306">  Yes </td><td width="342">  Yes </td></tr><tr><td width="279">  Merge entity </td><td width="306">  Yes </td><td width="342">  Yes </td></tr><tr><td width="279">  Delete Entity </td><td width="306">  No </td><td width="342">  Yes </td></tr><tr><td width="279">  Insert or Replace Entity </td><td width="306">  Yes </td><td width="342">  No </td></tr><tr><td width="279">  Insert or Merge Entity </td><td width="306">  Yes </td><td width="342">  No </td></tr></tbody></table><br>  Note that the <b>Insert</b> <b>or</b> <b>Replace</b> <b>Entity</b> and <b>Insert</b> <b>or</b> <b>Merge</b> <b>Entity</b> operations <i>do not perform</i> any simultaneous access checks, because they do not send the ETag value to the table service. <br><br>  As a rule, developers using tables should rely on an optimistic strategy for concurrent access to data when developing scalable applications. <br><br>  If there is a need for pessimistic locking, then a suitable option for accessing the tables for developers may be to allocate a special blob for each table and attempt to lease it before each operation on the table. <br><br>  This approach requires the application to ensure that any access to the tables is made through a preliminary attempt to lease the blob. <br><br>  Also note that the minimum lease duration is 15 seconds, which requires special attention when developing scalable solutions. <br><br>  Additional Information: <br><ul><li>  <a href="http://msdn.microsoft.com/library/azure/dd179375.aspx/">Entity operations</a> </li></ul><br><h3>  Organization of parallelism in the queue storage service </h3><br>  For queues, there is one scenario in which the need arises to use a parallel access strategy ‚Äî this is when several clients simultaneously retrieve messages from the queue.  When a message is retrieved from a queue, the response includes the message itself and the pop receipt value that is required to delete the message later. <br><br>  The message is not automatically removed from the queue, but after it has been retrieved, it becomes not visible to clients for a time by a certain visibilitytimeout. <br><br>  The client receiving the message waits for the message to be deleted in the period after it has been processed and until the time specified by the TimeNextVisible element in the response. <br><br>  To determine the TimeNextVisible, the value of visibilitytimeout is added to the time the message was retrieved. <br><br>  The queue storage service does not support an optimistic or pessimistic strategy, so customers processing messages retrieved from the queue must provide an idempotent way of processing messages. <br><br>  For update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL, and UpdateMessage, the strategy ‚Äúwins the last‚Äù is used. <br><br>  Additional Information: <br><ul><li>  <a href="http://msdn.microsoft.com/library/azure/dd179363.aspx/">Queuing REST API</a> </li><li>  <a href="http://msdn.microsoft.com/library/azure/dd179474.aspx/">Get Messages operation</a> </li></ul><br><h3>  Organization of parallelism in the file storage service </h3><br>  Access to the file service can be performed using two different protocols: SMB and REST.  The REST service does not support optimistic or pessimistic blocking, and all updates will be made based on the ‚Äúwins the last‚Äù strategy. <br><br>  Clients using SMB can use a file system-level locking mechanism to control access to shared files, including the possibility of pessimistic locking. <br><br>  When the SMB client opens the file, it determines the file access parameter and the shared access mode.  As a result of setting the file access option to ‚ÄúWrite‚Äù or ‚ÄúRead / Write‚Äù and shared access mode to ‚ÄúNone‚Äù, the SMB client will block the file until it is closed. <br><br>  If a REST operation is performed on a file blocked by an SMB client, the REST service will return error 409 with the code ‚ÄúSharing Violation‚Äù. <br><br>  When an SMB client opens a file for deletion, it marks the file as ‚Äúpending deletion‚Äù until all other SMB clients close it.  While the file is marked as pending deletion, any REST operations on this file will return a 409 error with the SMBDeletePending code.  Error code 404 (Not Found) will not be returned, as there is a possibility that the SMB client will clear the flag waiting to be deleted before closing the file.  In other words, the 404 error code will return only when the file is really deleted. <br><br>  Please note that while the file is in a state pending deletion by the SMB client, it will not be included in the results of the List Files. <br><br>  it is also necessary to take into account that the REST Delete File and Delete Directory operations are executed atomically and do not lead to the setting of the state ‚Äúpending deletion‚Äù. <br><br>  Additional Information: <br><ul><li>  <a href="http://msdn.microsoft.com/en-us/library/azure/dn194265.aspx">File Lock Organization</a> </li></ul><br><h3>  Conclusion </h3><br>  Microsoft Azure cloud storage was designed to meet the needs of complex web applications.  At the same time, developers are not required to sacrifice or rethink key design patterns, such as simultaneous access to data or ensuring the correct state of data.  Mechanisms to ensure them are included in the storage itself. <br><br>  Full sample application used in the article: <br><ul><li>  <a href="http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114">Organization of simultaneous access to data in the cloud storage Microsoft Azure Storage</a> </li></ul><br>  Detailed information about Azure Storage: <br><ul><li>  <a href="http://azure.microsoft.com/ru-ru/services/storage/">Microsoft Azure Storage Home</a> </li><li>  <a href="http://azure.microsoft.com/ru-ru/documentation/articles/storage-introduction/">Introduction to Azure Storage</a> </li><li>  <a href="http://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-blobs/">Blobs</a> , <a href="http://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-tables/">Tables</a> and <a href="http://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-how-to-use-queues/">Queues</a> </li><li>  Article: <a href="http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx">Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency</a> </li></ul><br><h3>  useful links </h3><br><ul><li>  <a href="http://l.techdays.ru/go/azuretrial">Try Azure</a> for free for 30 days! <br><ul><li>  <a href="http://www.azurehub.ru/">Microsoft Azure Development Center (azurehub.ru)</a> - scripts, tutorials, examples, design recommendations </li><li>  <a href="http://www.twitter.com/windowsazure_ru">Twitter.com/windowsazure_ru</a> - the latest Microsoft Azure news </li><li>  <a href="http://www.facebook.com/groups/azurerus/">Microsoft Azure Community on Facebook</a> - experts, questions </li></ul><br></li><li>  <a href="http://l.techdays.ru/go/mva">Explore</a> Microsoft Virtual Academy <a href="http://l.techdays.ru/go/mva">courses</a> on cloud and other technologies <br><ul><li>  <b><a href="http://www.microsoftvirtualacademy.com/training-courses/business-and-cloud-best-practices-solutions-rus">Business and the cloud: best practices solutions</a></b> </li><li>  <a href="http://www.microsoftvirtualacademy.com/training-courses/windows-8-1-update-for-enterprise-jump-start-rus">Windows 8.1 Update for large organizations.</a>  <a href="http://www.microsoftvirtualacademy.com/training-courses/windows-8-1-update-for-enterprise-jump-start-rus">Beginning of work</a> </li><li>  <a href="http://www.microsoftvirtualacademy.com/training-courses/the-microsoft-hybrid-cloud-best-practices-guidance-rus">Microsoft Hybrid Cloud: Typical Solutions Guide</a> </li><li>  <a href="http://www.microsoftvirtualacademy.com/training-courses/windows-8-1-user-readiness-toolkit_rus">Toolkit for preparing users for Windows 8.1</a> </li><li>  <a href="http://www.microsoftvirtualacademy.com/training-courses/introduction-to-the-graphics-library-win2d-rus">Introduction to the Win2D Graphic Library</a> </li></ul><br></li><li>  <a href="http://l.techdays.ru/go/getvs">Download</a> free or trial Visual Studio </li><li>  <a href="http://l.techdays.ru/go/winstart">Become a</a> universal Windows application <a href="http://l.techdays.ru/go/winstart">developer</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/243629/">https://habr.com/ru/post/243629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243617/index.html">What is wrong with Email and how to fix it</a></li>
<li><a href="../243619/index.html">Paul Graham (Y Combinator) and Dmitry Kalaev (FRII accelerator) about the reasons for the success and failure of startups</a></li>
<li><a href="../243623/index.html">There is only one step left to Kickstarter - is there a chance for the project?</a></li>
<li><a href="../243625/index.html">Dependency Injection; Good, but how?</a></li>
<li><a href="../243627/index.html">A glance from Japan on Russian traffic anomalies, ARM TrustZone errors, hacking smartphones via NFC - what PacSec had</a></li>
<li><a href="../243631/index.html">How decrepit large offices</a></li>
<li><a href="../243633/index.html">How to work with foreign currency accounts?</a></li>
<li><a href="../243635/index.html">The future in the prism of mobile technology: Russian App Day</a></li>
<li><a href="../243643/index.html">Operation "Modernization": how to improve the learning process at the university with the help of monoblocks?</a></li>
<li><a href="../243645/index.html">HDConf conference: video report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>