<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why, why, and when you need to use ValueTask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation appeared thanks to a good comment 0x1000000 . 
 




 In the .NET Framework 4, the System.Threading.Tasks space appeared, and with it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why, why, and when you need to use ValueTask</h1><div class="post__text post__text-html js-mediator-article"><p>  <sup>This translation appeared thanks to a good comment <a href="https://habr.com/ru/users/0x1000000/" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="image"></p><br><p>  In the .NET Framework 4, the System.Threading.Tasks space appeared, and with it the Task class.  This type and Task &lt;TResult&gt; spawned from it waited for a long time until they were recognized as standards in .NET as key aspects of the asynchronous programming model that was introduced in C # 5 with its async / await operators.  In this article, I will talk about new types of ValueTask / ValueTask &lt;TResult&gt; designed to improve the performance of asynchronous methods in cases where the cost of memory allocation needs to be taken into account. </p><a name="habracut"></a><br><h3 id="task">  Task </h3><br><p>  Task performs different roles, but the main one is a ‚Äúpromise‚Äù (promise), an object representing the possible completion of some operation.  You initiate an operation and get a Task object for it, which will be executed when the operation is completed, which can occur in synchronous mode as part of the initialization of the operation (for example, receiving data that is already in the buffer), in asynchronous mode with execution at the moment when you receive a Task (receiving data not from the buffer, but very quickly), or in asynchronous mode, but after the Task you already have (receiving data from a remote resource).  Since the operation may complete asynchronously, you either block the thread of execution, waiting for the result (which often makes the asynchronous call pointless), or create a callback function that will be activated after the operation is completed.  In .Net 4, the creation of a callback is implemented by the ContinueWith methods of the Task object, which explicitly demonstrate this model by accepting the delegate function (delegate) to start it after Task execution: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  But in the .NET Framework 4.5 and C # 5, Task objects can simply be called by the await operator, which makes it easy to get the result of an asynchronous operation, and the generated code that is optimized for the above options will work correctly in all cases of completing the operation in synchronous mode, fast asynchronous or asynchronous with callbacka execution: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Task is a very flexible class and it has several advantages.  For example, you can perform await several times for any number of consumers at the same time.  You can put it in a dictionary for repeated awaits in the future to use it as a cache of asynchronous call results.  You can block the execution, waiting for the Task to complete if necessary.  And you can write and apply various operations on Task objects (sometimes called ‚Äúcombinators‚Äù), for example, ‚Äúwhen any‚Äù to asynchronously wait for the first completion of several Task. <br>  But this flexibility becomes superfluous in the most common case: just call an asynchronous operation and wait for the task to complete: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Here we do not need to wait for execution several times.  We do not need to provide competitive expectations.  We do not need to perform synchronous locking.  We will not write combinators.  We are just waiting for the promise of an asynchronous operation.  After all, this is how we write synchronous code (for example, TResult result = SomeOperation ();), and this is translated into async / await in the usual way. </p><br><p>  Moreover, Task has a potential weakness, especially when a large number of instances are created, and high throughput and performance are key requirements ‚Äî Task is a class.  This means that any operation that Task needed is forced to create and place an object, and the more objects are created, the more work for the garbage collector (GC), and this work consumes resources that we could spend on something more useful. </p><br><p>  The runtime and system libraries help mitigate this problem in many situations.  For example, if we write this method: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  as a rule, there will be enough free space in the buffer, and the operation will be executed synchronously.  When this happens, there is no need to do anything with the Task, which should be returned, since the return value is missing, this is using Task as the equivalent of a synchronous method that returns a null value (void).  Therefore, the environment can simply cache one non-generic (Non-generic) Task and use it again and again as the execution result for any async method that is completed synchronously (this cached Singleton can be obtained via Task.CompletedTask).  Or, for example, you write: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  and generally expect the data to be already in the buffer, so the method simply checks the _bufferedCount value, sees that it is greater than 0, and returns true;  and only if there is no data in the buffer yet, you need to perform an asynchronous operation.  And since there are only two possible results of the Boolean type (true and false), there are only two possible Task objects that are needed to represent these results, the environment can cache these objects and return them with the corresponding value without memory allocation.  Only in the case of asynchronous completion, the method will need to create a new Task, because it will need to be returned before the result of the operation is known. <br></p><p>  The environment provides caching for some other types, but it is unrealistic to cache all possible types.  For example, the following method: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  will also often be performed synchronously.  But unlike the variant with the Boolean result, this method returns an Int32, which has about 4 billion values, and caching all Task &lt;int&gt; variants will require hundreds of gigabytes of memory.  The environment provides a small cache for Task &lt;int&gt;, but a strongly limited set of values, for example, if this method completes synchronously (data is already in the buffer) with a return value of 4, it will be a cached Task, but if it returns 42, you will need to create a new Task &lt;int&gt;, like calling Task.FromResult (42). </p><br><p>  Many library methods attempt to smooth this by providing their own cache.  For example, the overload in the .NET Framework 4.5 of the MemoryStream.ReadAsync method always ends synchronously, since it reads data from memory.  ReadAsync returns a Task &lt;int&gt;, where the result of the type Int32 shows how many bytes have been read.  This method is often used in a loop, often with the same required number of bytes for each call, and often this need is met in full.  So for repeated calls to ReadAsync, it is reasonable to expect Task &lt;int&gt; to return synchronously with the same value as in the previous call.  Therefore, a MemoryStream creates a cache for a single object that is returned in the last successful call.  And in the next call, if the result is repeated, it will return the cached object, and if not, create a new one with Task.FromResult, save it to the cache and return it. </p><br><p>  And yet there are many other cases where the operation is performed synchronously, but the Task &lt;TResult&gt; object is forcedly created. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; and synchronous execution </h4><br><p>  All this required the implementation of a new type in .NET Core 2.0, which is available in previous versions of .NET in the NuGet System.Threading.Tasks.Extensions: ValueTask &lt;TResult&gt; package. <br>  ValueTask &lt;TResult&gt; is created in .NET Core 2.0 as a structure that can wrap both TResult and Task &lt;TResult&gt;.  This means that it can be returned from the async method, and if this method executes synchronously and successfully, no object should be placed on the heap: you can simply initialize this ValueTask &lt;TResult&gt; structure to TResult and return it.  Only in the case of asynchronous execution, the Task &lt;TResult&gt; object will be placed, and ValueTask &lt;TResult&gt; will wrap it (to minimize the size of the structure and optimize the case of successful execution, the async method, which ends with an unsupported exception, will also allocate Task &lt;TResult&gt;, so ValueTask &lt;TResult&gt; will also simply wrap Task &lt;TResult&gt;, and will not carry an extra field for storing Exception). </p><br><p>  Based on this, a method like MemoryStream.ReadAsync, but returning ValueTask &lt;int&gt;, should not be caching, but instead can be written like this: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; and asynchronous execution </h4><br><p>  The ability to write an async method that can complete synchronously without the need for additional placement for the result is a big win.  That's why ValueTask &lt;TResult&gt; was added to .NET Core 2.0, and new methods that are likely to be used in applications that require performance are now announced with the return of ValueTask &lt;TResult&gt; instead of Task &lt;TResult&gt;.  For example, when we added a new ReadAsync overload to the Stream class in .NET Core 2.1, in order to be able to pass Memory instead of byte [], we return the ValueTask &lt;int&gt; type in it.  In this form, Stream objects (in which very often the ReadAsync method is executed synchronously, as in the earlier example for the MemoryStream) can be used with much less memory allocation. <br></p><p>  However, when we work with services with very high bandwidth, we still want to avoid allocating memory as much as possible, which means reducing and eliminating memory allocations along the asynchronous execution route. <br>  In the await model, for any operation that terminates asynchronously, we need the ability to return an object that represents the possible completion of the operation: the caller needs to redirect the callback that will be triggered upon completion of the operation, and this requires a unique object on the heap that can serve as a transmission channel for this particular operation.  This, at the same time, does not mean whether the object will be used again after the operation is completed.  If this object can be reused, the API can organize a cache for one or several such objects, and use it for sequential operations, in the sense of not using the same object for several intermediate async operations, but using it for noncompetitive access. <br>  In .NET Core 2.1, the ValueTask &lt;TResult&gt; class has been enhanced to support this kind of pooling and reuse.  Instead of simply wrapping a TResult or Task &lt;TResult&gt;, the refined class can wrap a new IValueTaskSource &lt;TResult&gt; interface.  This interface provides the basic functionality that is required to support an asynchronous operation with a ValueTask &lt;TResult&gt; object just as Task &lt;TResult&gt; does: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  The GetStatus method is used to implement properties like ValueTask &lt;TResult&gt; .IsCompleted, which returns information as an asynchronous operation or completed, and how it is completed (successfully or not).  The OnCompleted method is used by the waiting object to attach a callback to continue execution from the await point when the operation completes.  And the GetResult method is needed to get the result of the operation, so that after the end of the operation, the calling method can get a TResult object or pass any exception that was thrown. </p><br><p>  Most developers do not need this interface: the methods simply return a ValueTask &lt;TResult&gt; object, which can be created as a wrapper for an object that implements this interface, and the calling method will remain in the dark.  This interface is for developers who need to avoid memory allocation when using a performance-critical API. </p><br><p>  There are several examples of such an API in .NET Core 2.1.  The most well-known methods are Socket.ReceiveAsync and Socket.SendAsync with new overloads added in 2.1, for example </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  This overload returns ValueTask &lt;int&gt;.  If the operation completes synchronously, it can simply return a ValueTask &lt;int&gt; with the appropriate value: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  For asynchronous completion, it can use an object from the pool that implements the interface: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  The implementation of the Socket supports one such object in the pool for receiving, and one for transfer, since there can not be more than one object for each direction waiting to be executed at a time.  These overloads do not allocate memory, even in the case of asynchronous execution of the operation.  This behavior manifests itself further in the NetworkStream class. <br>  For example, in .NET Core 2.1 Stream provides: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  which is overridden in NetworkStream.  The NetworkStream.ReadAsync method simply uses the Socket.ReceiveAsync method, so the Socket win is translated to the NetworkStream, and NetworkStream.ReadAsync also does not actually allocate memory. </p><br><h4 id="neobobschyonnyy-valuetask">  Unsubscribed ValueTask </h4><br><p>  When ValueTask &lt;TResult&gt; appeared in .NET Core 2.0, only the case of synchronous execution was optimized in it in order to exclude the placement of the Task &lt;TResult&gt; object if the TResult value is already ready.  This meant that the non-generic ValueTask class was not needed: for the case of synchronous execution, the singletonton Task.CompletedTask could simply be returned from the method, and this was done by the environment implicitly in the async methods that return Task. </p><br><p>  However, with the receipt of asynchronous operations without memory allocation, the use of a non-generic ValueTask has become relevant again.  In .NET Core 2.1, we introduced the non-generic ValueTask and IValueTaskSource.  They provide direct equivalents for generic versions, for similar use, only with an empty return value. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Implementing IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  Most developers should not implement these interfaces.  Besides, it's not so easy.  If you decide to do this, several implementations in .NET Core 2.1 can serve as a starting point, for example: </p><br><ul><li>  AwaitableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;TResult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  To make it easier, in .NET Core 3.0 we plan to provide all the necessary logic included in the type of ManualResetValueTaskSourceCore &lt;TResult&gt;, a structure that can be embedded into another object that implements IValueTaskSource &lt;TResult&gt; and / or IValueTaskSource so that you can delegate to This structure is the main part of the functionality.  You can learn more about this from <a href="https://github.com/dotnet/corefx/issues/32664">https://github.com/dotnet/corefx/issues/32664</a> in the dotnet / corefx repository. </p><br><h4 id="patterny-primeneniya-valuetasks">  ValueTasks Application Patterns </h4><br><p>  At first glance, the scope of ValueTask and ValueTask &lt;TResult&gt; is much more limited than Task and Task &lt;TResult&gt;.  This is good, and even expected, since the main way to use them is simply to use it with the await operator. </p><br><p>  However, since they can wrap objects that are reused, there are significant restrictions on their use compared to Task and Task &lt;TResult&gt; if you deviate from the usual simple await method.  In general, the following operations should never be performed with ValueTask / ValueTask &lt;TResult&gt;: </p><br><ul><li>  <strong>Repeating Wait ValueTask / ValueTask &lt;TResult&gt;</strong> The result object can already be disposed of and used in another operation.  In contrast, Task / Task &lt;TResult&gt; never transitions from a completed state to an incomplete state, so you can re-wait it as many times as needed and get the same result every time. </li><li>  <strong>Parallel wait for ValueTask / ValueTask &lt;TResult&gt;</strong> The result object waits for processing by only one callback from one consumer at a time, and trying to wait for it from different threads at the same time can easily lead to racing and subtle program errors.  In addition, it is also a more specific case of the previous invalid operation ‚Äúre-wait‚Äù.  By comparison, Task / Task &lt;TResult&gt; provides any number of concurrent awaits. </li><li>  <strong>Using .GetAwaiter (). GetResult () when the operation is not completed.</strong> Implementing IValueTaskSource / IValueTaskSource &lt;TResult&gt; does not need support for locking until the end of the operation, and most likely will not do this, so this operation will definitely lead to racing and probably will not be executed as the caller expects.  Task / Task &lt;TResult&gt; blocks the calling thread until the task is executed. </li></ul><br><p>  If you received a ValueTask or ValueTask &lt;TResult&gt;, but you need to perform one of these three operations, you can use .AsTask (), get Task / Task &lt;TResult&gt; and then work with the received object.  After that, you can no longer use that ValueTask / ValueTask &lt;TResult&gt;. </p><br><p>  In short, the rule is this: when applying ValueTask / ValueTask &lt;TResult&gt;, you must either either await it directly (possibly with .ConfigureAwait (false)) or call AsTask () and not use it again: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  There is one more advanced pattern that programmers can use, I hope, only after careful measurement and obtaining significant advantages.  The ValueTask / ValueTask &lt;TResult&gt; classes have several properties that report the current status of the operation, for example, the IsCompleted property returns true if the operation has been completed (that is, it is no longer running and completed successfully or not successfully), and the IsCompletedSuccessful property returns true, only if completed successfully (when waiting and receiving the result did not throw an exception).  For the most intense execution threads, where the developer wants to avoid the costs that appear in asynchronous mode, these properties can be checked before an operation that actually destroys a ValueTask / ValueTask &lt;TResult&gt; object, such as await, .AsTask ().  For example, in the implementation of SocketsHttpHandler in .NET Core 2.1, the code reads from the connection and gets the ValueTask &lt;int&gt;.  If this operation is performed synchronously, we should not worry about early interruption of the operation.  But if it is executed asynchronously, we have to hook up the interrupt processing in order for the interrupt request to break the connection.  Since this is a very tight section of code, if profiling reveals the need for the next small change, it can be structured like this: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  Should each asynchronous API method return a ValueTask / ValueTask &lt;TResult&gt;? </h4><br><p>  In short: no, the default is to still choose Task / Task &lt;TResult&gt;. <br>  As highlighted above, Task and Task &lt;TResult&gt; are correctly used more easily than ValueTask and ValueTask &lt;TResult&gt;, and as long as performance requirements do not outweigh practicality requirements, Task and Task &lt;TResult&gt; are preferred.  In addition, there are small costs associated with returning ValueTask &lt;TResult&gt; instead of Task &lt;TResult&gt;, that is, micro-benchmarks show that await Task &lt;TResult&gt; is faster than await ValueTask &lt;TResult&gt;.  So, if you use task caching, for example, your method returns a Task or Task, for performance it is worth staying with Task or Task.  ValueTask / ValueTask &lt;TResult&gt; objects occupy several words in memory, so when they are expected and fields are reserved for them in the state machine that calls the async method, they will occupy more memory in it. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      ‚Äì   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/458828/">https://habr.com/ru/post/458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458812/index.html">JVM TI: how to make a plugin for a virtual machine</a></li>
<li><a href="../458814/index.html">Launching a site for a product with unformed demand</a></li>
<li><a href="../45882/index.html">Grand Theft Auto IV PC Edition</a></li>
<li><a href="../458820/index.html">On the implementation of the famous genre on the Minecraft platform</a></li>
<li><a href="../458826/index.html">How to eliminate old articles so that they grow dramatically in organics: + 104% of traffic in six months</a></li>
<li><a href="../458830/index.html">Dell Technologies Webinars: all the details about our tutorial</a></li>
<li><a href="../458834/index.html">The side of the personality of Paul Allen, about which not many people knew as I would like</a></li>
<li><a href="../458836/index.html">Index borscht. A systematic approach to assessing, comparing, determining the price / quality ratio</a></li>
<li><a href="../45884/index.html">Symfony 1.2</a></li>
<li><a href="../458840/index.html">How we pierced the Great Chinese Firewall (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>