<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of GLSL shaders on Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Our company is developing online games and now we are working on a mobile version of our main project. In this article we want to share the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of GLSL shaders on Kotlin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/qr/2o/e4/qr2oe43eauzbkvwv8r2tn2ze1do.jpeg"><br><br>  Hello! <br><br>  Our company is developing online games and now we are working on a mobile version of our main project.  In this article we want to share the experience of developing GLSL shaders for the Android project with examples and <a href="https://github.com/dananas/kotlin-glsl">sources</a> . <br><a name="habracut"></a><br><h3>  about the project </h3><br>  Initially, the game was browser-based on Flash, but the news of the imminent end of support for Flash made us move the project to HTML5.  Kotlin was used as the development language, and six months later we were able to launch the project on Android.  Unfortunately, the game lacked performance without optimization on mobile devices. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To increase the FPS, it was decided to rework the graphics engine.  Previously, we used several universal shaders, and now for each effect we decided to write a separate shader, sharpened for a specific task, in order to be able to make their work more efficient. <br><br><h3>  What we lacked </h3><br>  Shaders can be stored in a string, but this method eliminates syntax checking and type matching, so shaders are usually stored in Assets or Raw files, as this allows you to enable validation by installing a plugin for Android Studio.  But this approach also has a drawback - the lack of reuse: in order to make small edits, you have to create a new shader file. <br><br>  In the way that: <br><br>  - develop shaders on Kotlin, <br>  - have a syntax check at compile time, <br>  - be able to reuse code between shaders, <br>  it took to write a "converter" Kotlin to GLSL. <br><br>  Desired result: the shader code is described as the Kotlin class, in which the attributes, varyings, uniforms are properties of this class.  Parameters of the primary class constructor are used for static branching and allow reuse of the rest of the shader code.  The init block is the shader body. <br><br><h3>  Decision </h3><br>  For implementation, Kotlin <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">delegates</a> were used.  They allowed in the runtime to find out the name of the delegated property, catch the moments of get and set hits, and notify them about ShaderBuilder, the base class of all shaders. <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniforms = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> attributes = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> varyings = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> instructions = ArrayList&lt;Instruction&gt;() ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = ... }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Delegates implementation</b> <div class="spoiler_text">  Varying delegate: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VaryingDelegate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Variable</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factory: (ShaderBuilder) -&gt; T) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v: T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: VaryingDelegate&lt;T&gt; { v = factory(ref) v.value = p.name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thisRef: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, property: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: T { thisRef.varyings.add(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v.typeName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property.name}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thisRef: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, property: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;, value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { thisRef.varyings.add(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v.typeName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property.name}</span></span></span><span class="hljs-string">"</span></span>) thisRef.instructions.add(Instruction.assign(property.name, value.value)) } }</code> </pre><br>  Implementation of the remaining delegates on <a href="https://github.com/dananas/kotlin-glsl">GitHub</a> . <br></div></div><br>  Shader example: <br><br><pre> <code class="hljs pgsql">//    useAlphaTest     , //       , ,  , //   . <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FragmentShader(useAlphaTest: <span class="hljs-type"><span class="hljs-type">Boolean</span></span>) : ShaderBuilder() { private val alphaTestThreshold <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> uniform(::GLFloat) private val texture <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> uniform(::Sampler2D) private val uv <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-type"><span class="hljs-type">varying</span></span>(::Vec2) init { var color <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> vec4() color = texture2D(texture, uv) // static branching <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useAlphaTest) { // dynamic branching <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>(color.w lt alphaTestThreshold) { <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>() } } //     ShaderBuilder. gl_FragColor = color } }</code> </pre><br>  But the resulting GLSL source (the result of the execution of FragmentShader (useAlphaTest = true) .getSource ()).  Preserved content and structure of the code: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D texture; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alphaTestThreshold; varying vec2 uv; void main(void) { vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = texture2D(texture, uv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.w &lt; alphaTestThreshold)) { discard; } gl_FragColor = <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre><br>  It is convenient to reuse the shader code by setting different parameters when building the source code, but this does not completely solve the reuse problem.  In the case when you need to write the same code in different shaders, you can put these instructions in a separate ShaderBuilderComponent and add them, if necessary, to the main ShaderBuilders: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShadowReceiveComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShaderBuilderComponent</span></span></span></span>() { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, inp: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Vec4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { vShadowCoord = shadowMVP * inp ... parent.appendComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, brightness: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLFloat</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> float() pixel = texture2D(shadowTexture, vShadowCoord.xy).x ... parent.appendComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Hurray, the resulting functionality allows you to write shaders on Kotlin, reuse the code, check the syntax! <br><br>  And now let's remember about <a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)">Swizzling</a> in GLSL and look at its implementation in Vec2, Vec3, Vec4. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) var y by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) ... //  9 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> var xx by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) var xy by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) ... } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec4</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) ... //  16 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> var xy by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) ... //  64 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class"> var xxx by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class">) ... }</span></span></code> </pre><br>  In our project, the compilation of shaders can occur in the game cycle on demand, and similar selection of objects generate major GC challenges, lags appear.  Therefore, we decided to move the source code assembly to the compilation stage using the annotation processor. <br><br>  We mark the class with the ShaderProgram annotation: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ShaderProgram(VertexShader::class, FragmentShader::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderProgramName</span></span></span></span>(alphaTest: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>)</code> </pre><br>  And the annotation processor collects all sorts of shaders, depending on the parameters of the vertex and fragment constructors for us: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderProgramNameSources</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sources</span></span></span></span>(vertex: String, fragment: String): ShaderProgramSources { Source0(<span class="hljs-string"><span class="hljs-string">"&lt;vertex code&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;fragment code&gt;"</span></span>) ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphaTest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alphaTest) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Source0 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Source1 } }</code> </pre><br>  Now you can get the shader text from the generated class: <br><br><pre> <code class="hljs swift">val sources = <span class="hljs-type"><span class="hljs-type">ShaderProgramNameSources</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(replaceAlpha = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(sources.vertex) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(sources.fragment)</code> </pre><br>  Since the result of the get function, ShaderProgramSources, is the value from enum, it is convenient to use it as keys in the program registry (ShaderProgramSources) -&gt; CompiledShaderProgram. <br><br>  The <a href="https://github.com/dananas/kotlin-glsl">GitHub</a> has project sources, including the annotation processor and simple examples of shaders and components. </div><p>Source: <a href="https://habr.com/ru/post/425027/">https://habr.com/ru/post/425027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425015/index.html">Sales without bugs: digital security of e-commerce platforms</a></li>
<li><a href="../425019/index.html">Voronezh, waiting for you (and not only) + competition</a></li>
<li><a href="../425021/index.html">We are looking for a fast universal library for working with graphic files, we are sorting out with Google benchmark</a></li>
<li><a href="../425023/index.html">We translate the recipe into the multicooker language</a></li>
<li><a href="../425025/index.html">Golang testing outside gotour</a></li>
<li><a href="../425031/index.html">More practice! Teach the Spring Framework and profiling without any conferences</a></li>
<li><a href="../425033/index.html">Building a jetpack: JetPack Aviation Annual Report 2017</a></li>
<li><a href="../425037/index.html">IT Geek Hub news: how we made a cycle quest in Prague and what awaits you at the next meeting</a></li>
<li><a href="../425039/index.html">Security Week 37: Facebook, Twitter and Inflatable Bugs</a></li>
<li><a href="../425041/index.html">What is wrong with GraphQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>