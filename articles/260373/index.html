<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Logging anything in Perl</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For logging messages, Pearl offers several ready-made solutions. All of them, as usual, are posted on CPAN . On request "log" you can find a bunch of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Logging anything in Perl</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/603/72c/5a7/60372c5a78e84055a0d181f870b182e7.jpg" alt="Problem of choice"><br><br>  For logging messages, Pearl offers several ready-made solutions.  All of them, as usual, are posted on <a href="https://metacpan.org/">CPAN</a> .  On request <a href="https://metacpan.org/search%3Fq%3Dlog">"log"</a> you can find a bunch of modules for all occasions. <br><br>  However, among all these modules there is one special one, it is called <a href="https://metacpan.org/pod/Log::Any">Log :: Any</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The peculiarity of this module for logging is that it does not, in fact, deal with logging.  The Log :: Any module provides the program (and programmer) with a universal API for calls to other modules that deal directly with logging. <br><br>  If you are tormented by the problem of choosing the logging method in Perla - this article is for you. <br><a name="habracut"></a><br><h2>  Problem </h2><br>  Suppose you have a module that downloads a file from the network.  You would like to know what time the download started, how long it lasted and how many bytes were loaded.  You can do the simplest way - add lines to the module: <br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"$time   \n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">#    print "$time   \n"; print "$time  $size \n";</span></span></code> </pre> <br>  <i>Please note - in order to calculate the time $ time, some additional actions will be needed, but I will not even focus on this, because this is not the main problem.</i> <br><br>  Everything will be fine as long as you run this script with this module with your hands from the command line.  Messages will be displayed to you on the console, you will read them and find out everything you wanted. <br><br>  But at some point it will be necessary to keep these messages for the future.  Or it will be necessary to run this script from Krone, and not by hand.  Or it will be necessary to write these messages to the database for further analysis.  Well, there will be many downloaded files, and it will be difficult for you to read a long log from the console. <br><br>  And then you want to redirect the log output from the console somewhere else.  To a file, to a database, to another program, to some web service via API, to hell with horns, etc.  This is where the problem arises - where exactly and how to log messages? <br><br><ul><li>  Write to file?  What if your module will be used in an environment where files cannot be written? </li><li>  Write to the database?  What if the module for working with the database is not installed? </li><li>  Redirect to another program?  But what if the user of your script prefers a completely different program that you have chosen? </li></ul><br>  There are many excellent logging modules, but they all have the same common drawback - these modules are more than one.  You like one way of logging, and the user likes the other, the customers the third, the superiors the fourth.  Fatal flaw ¬©. <br><br><h2>  Decision </h2><br>  Use the Log :: Any module. <br><br>  Log :: Any solves the selection problem described above in such a way that everyone is satisfied - the programmer thinks only of <i>what</i> he wants to send to the log, and the log users themselves decide on where and how to record the received messages. <br><br>  The idea of ‚Äã‚Äãthis module is to divide the logging procedure into two separate parts, which can work independently of each other.  At the same time, the part that generates the messages has no idea how and where these messages will be further recorded.  And the part that writes messages somewhere, has no idea about where these messages came from and how they were formed. <br><br><h2>  This is how it works. </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/9c2/62a/92d/9c262a92d9a199d3993afc34be829a1b.png" alt="Log :: Any operation diagram"><br><br>  The dotted lines in the diagram indicate the connection of modules through <b>use</b> , and the solid ones indicate the direction of movement of the logged messages. <br><br><h4>  Sending messages </h4><br>  To send a message, your code (in a module or in a script, it does not matter) calls the standard function provided by the Log :: Any module: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    Log::Any     $log,         use Log::Any qw($log); #   -   (  error    ) $log-&gt;error("-    - ");</span></span></code> </pre><br>  The above two lines are all that is needed in order to start logging.  But the sent message will not be recorded anywhere yet, since we have not yet chosen where to write the log specifically. <br><br><h4>  Message recording </h4><br>  Now we need to decide where we write the log.  To do this, the script needs to use one of the adapters: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#           use Log::Any::Adapter ('Stdout'); #          use Log::Any::Adapter ('File', '/path/to/file.log'); #               Log::Dispatch use Log::Dispatch; my $log = Log::Dispatch-&gt;new(outputs =&gt; [[ ... ]]); Log::Any::Adapter-&gt;set( { category =&gt; 'Foo::Baz' }, 'Dispatch', dispatcher =&gt; $log );</span></span></code> </pre><br>  Included with Log :: Any comes a few simple built-in adapters - File, Stdout and Stderr.  As you can guess from the title, the first one writes messages to a file, and the other two send messages to standard outputs. <br><br>  In addition to the built-in adapters on CPAN, you can find external ones, such as <a href="https://metacpan.org/pod/Log::Any::Adapter::Log4perl">Log4perl</a> or <a href="https://metacpan.org/pod/Log::Any::Adapter::Syslog">Syslog</a> .  External adapters allow you to write logs anywhere - even on Twitter. <br><br>  And if you need to Facebook?  Not a problem either.  You can effortlessly write your own adapter to anything.  Creating your own adapter is described in the <a href="https://metacpan.org/pod/Log::Any::Adapter::Development">module documentation</a> , or <a href="http://pragmaticperl.com/issues/02/pragmaticperl-02-%25D1%2583%25D0%25B4%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25BE%25D0%25B5-%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5-%25D1%2581-logany.html">here</a> in Russian. <br><br>  I will not go into the details of writing the adapter here, because the links above this task is well described.  Instead, I will consider another task - the introduction of logging into an existing code. <br><br><h2>  Logging existing actions </h2><br><h4>  Connectors </h4><br>  If you are writing code from scratch, you can immediately add logging to the right places.  But if you already have some amount of code, then adding logging functions may require a lot of work on digging and modifying existing code.  Instead, there is a way to add logging without doing anything (almost). <br><br>  To do this, you need to use a connector - a module that connects to an existing code and adds logging functions to it. <br><br>  <i>Remark - the term "connector" I coined myself, perhaps there is some other common name.</i> <br><br>  Connector modules are usually located in the Log :: Any :: For namespace.  There are several ready-made connectors, for example, <a href="https://metacpan.org/pod/Log::Any::For::DBI">Log :: Any :: For :: DBI</a> or <a href="https://metacpan.org/pod/Log::Any::For::LWP">Log :: Any :: For :: LWP</a> . <br><br>  Writing your own connectors is not formalized, so much depends on what, in fact, the connector is written to.  In general, the connector works like this: <br><br><ul><li>  Intercepted event to be logged.  For this, different means can be used, such as <a href="https://metacpan.org/pod/Test::MockModule">mocks</a> or <a href="http://perldoc.perl.org/functions/tie.html">tie</a> . </li><li>  The event message is sent to the log using the standard $ log-&gt; method ('message'). </li></ul><br>  The use of the connector is as follows (for example, LWP connector): <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#  LWP use LWP::Simple #    LWP use Log::Any::For::LWP; #          LWP get "http://www.google.com/";</span></span></code> </pre><br>  In this code, no explicit action was taken to send messages to the log, except for connecting the connector.  But, however, the get function will magically get logging and start displaying all sorts of useful messages. <br><br><h4>  Logging warnings and exceptions </h4><br>  Unfortunately, from time to time in the program there are events that are not provided and - for good - should not happen.  For example, it suddenly turned out that in some function a call to an uninitialized variable occurs, or the connection to the database falls off, or the program crashes.  In such cases, the Pearl interpreter will throw out a warning or an exception. <br><br>  If such an event happened in a simple script that you launched from the console, then the corresponding message will appear in front of your eyes and you will immediately see it (although this is not a fact either).  If the program is launched from Krona or is running under a web server, or something else like this, then it will not be easy to notice such a message. <br><br>  The correct solution is to write such a message to the log.  But how?  After all, messages are written to the log that were explicitly sent to the programmer through the $ log object, and the interpreter throws out the varnings and exceptions, who do not know anything about our remarkable logging and dump all their messages simply on STDERR. <br><br>  This means that everything that goes to STDERR should be forcibly redirected to the log. <br><br>  To solve this problem, I did not find a suitable connector on CPAN, so I wrote my own - <a href="https://metacpan.org/pod/Log::Any::For::Std">Log :: Any :: For :: Std</a> .  This connector sends to the log all possible messages of the interpreter, at any stage of the program execution. <br><br>  To intercept STDERR, the tie function is used: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">tie</span></span> *STDERR, __PACKAGE_<span class="hljs-number"><span class="hljs-number">_</span></span>;</code> </pre><br>  This construction wraps up absolutely everything that is sent to STDERR in the package we need, and it is no longer difficult to redirect messages to the log using Log :: Any. <br><br>  If you wish, you can implement any other connector to intercept warnings and exceptions (or you may not intercept them at all). <br><br><h4>  Message Filtering </h4><br>  Circumstances may be such that the existing code already displays some messages.  For example, I have a big project with a legacy code, in which all the logging is done like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> STDERR <span class="hljs-string"><span class="hljs-string">"$time --- $login --- $pid ---  \n"</span></span>;</code> </pre><br>  As you can see, here all messages are sent to STDERR, and in the message text there are all sorts of variables, delimiters, plus a newline.  In addition, although it is not visible, all messages are written without using utf8. <br><br>  Redirecting messages from STDERR to the log is easily solved using the Log :: Any :: For :: Std connector, but you will have to remove extra garbage from the message text separately.  To do this, when you connect the Log :: Any module, you need to enable filtering. <br><br>  This is done like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Log::Any <span class="hljs-string"><span class="hljs-string">'$log'</span></span>, <span class="hljs-string"><span class="hljs-string">filter =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $msg = $_[<span class="hljs-number"><span class="hljs-number">2</span></span>]; utf8::decode($msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $msg };</code> </pre><br>  Each message sent to the log using $ log-&gt; method () will be passed through the function specified in the filter argument.  The variable <b>$ _ [2]</b> in this function contains the message to be sent.  If you want to do something with the message, then you must take it from this variable, modify it and return it.  The returned value will be recorded in the log. <br><br>  For example, in the above code, the message text is reduced to utf8. <br><br><h2>  Script example </h2><br>  Let's put it all together in the <b>test.pl</b> script: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use strict; use warnings; use Log::Any '$log', filter =&gt; sub { my $msg = $_[2]; $msg =~ s///; return $msg }; use Log::Any::Adapter ('Stdout'); use Log::Any::For::Std; print "  \n"; $log-&gt;info("    "); $log-&gt;info("     "); Module::func(); warn "    "; die "      "; #  package Module; use Log::Any '$log'; sub func { $log-&gt;info("     "); }</span></span></code> </pre><br>  Run and see the following: <br><br><pre> <code class="bash hljs">$ ./test.pl                          at ./test.pl line 18.        at ./test.pl line 20.</code> </pre><br>  All messages will be displayed on the console, but do not believe your eyes - only the first line is the usual output, everything else is a log.  Just this log is displayed on the console. <br><br>  But what if now we suddenly want to send the log not to the console, but to a file?  There is nothing simpler with the Log :: Any module: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#      # use Log::Any::Adapter ('Stdout'); #   use Log::Any::Adapter ('File', 'file.log');</span></span></code> </pre><br>  Run and see: <br><br><pre> <code class="bash hljs">$ ./test.pl   </code> </pre><br>  As expected, only print will be displayed on the console. <br><br>  But where did all the rest go: <br><br><pre> <code class="bash hljs">$ cat file.log [Fri Jun 19 17:25:44 2015]      [Fri Jun 19 17:25:44 2015]       [Fri Jun 19 17:25:44 2015]       [Fri Jun 19 17:25:44 2015]      at ./test.pl line 18. [Fri Jun 19 17:25:44 2015]        at ./test.pl line 20.</code> </pre><br><h2>  Summary </h2><br><ul><li>  The Log :: Any module allows you to add flexible logging to your programs and modules, which you will not need to redo later when changing the method of saving the log </li><li>  Adapters Log :: Any :: Adapter allow you to adapt your program to any way to save the log </li><li>  Log :: Any :: For Connectors allow you to connect logging to any message source </li></ul></div><p>Source: <a href="https://habr.com/ru/post/260373/">https://habr.com/ru/post/260373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260355/index.html">Manage dependencies in iOS applications correctly: Typhoon device</a></li>
<li><a href="../260357/index.html">Accidents in data centers that were (almost) impossible to foresee</a></li>
<li><a href="../260359/index.html">Hola and your safety</a></li>
<li><a href="../260363/index.html">Interactive robot to control the smart home. Electronics Overview</a></li>
<li><a href="../260371/index.html">Settings of search engines, ‚Äúgoodbye, vyglaglazny color‚Äù and other improvements in Vivaldi 1.0.201.2</a></li>
<li><a href="../260381/index.html">Report on ReactOS at RIF + OSDAY 2015 in Innopolis</a></li>
<li><a href="../260387/index.html">Complete CROC cloud translation to Violin Memory's All-Flash data storage.</a></li>
<li><a href="../260389/index.html">"Ajar data" / Notes on the traces of the open data board on June 15</a></li>
<li><a href="../260391/index.html">Blend4Web vs Unity. Battle of the Internet</a></li>
<li><a href="../260393/index.html">DDoS attack bypassing Qrator. How to protect yourself?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>