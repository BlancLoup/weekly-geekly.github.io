<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding Addictions in Angular 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good evening, ladies and gentlemen! 

 With all the unrelenting popularity of the AngularJS framework, we still did not have time to check out the boo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding Addictions in Angular 2</h1><div class="post__text post__text-html js-mediator-article">  Good evening, ladies and gentlemen! <br><br>  With all the unrelenting popularity of the AngularJS framework, we still did not have time to check out the book on its first version, and now we decided not to wait for the second and ask: how much does this work appeal to you, covering, apart from AngularJS, the wider context of JavaScript development? <br><br> <a href="http://habrahabr.ru/company/piter/blog/270837/"><img src="https://habrastorage.org/files/bd0/41f/72a/bd041f72a06b4c5ab845995984530c23.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the cut, you will find a translation of a regularly updated article by Pascal Precht (version of October 12, 2015), telling about such lofty matters as the introduction of dependencies in AngularJs and, most interestingly, those improvements that await this mechanism in Angular 2. <br><a name="habracut"></a><br>  Dependency injection has always been one of the most visible and trump features of Angular.  So, this framework allows you to embed dependencies in various components at different points in the application;  you do not need to know how these dependencies are created, or what dependencies they in turn need.  However, it turns out that the modern dependency injection mechanism (in Angular 1) has some problems to be solved in Angular 2 in order to build a new generation framework.  In this article we will talk about the new dependency injection system - for future generations. <br><br>  Before we start exploring new material, let's look at what ‚Äúdependency injection‚Äù (DI) is and what problems with DI arise in Angular 1. <br><br>  <b>Dependency injection</b> <br><br>  <a href="https://twitter.com/vojtajina">Vojta Gina</a> made an excellent report on the implementation of dependencies at the ng-conf 2014 conference. In his speech, he outlined the history of creating a new dependency injection system that will be developed for Angular 2, described the ideas on which it is based.  In addition, he clearly described that DI can be viewed in two ways: as a design pattern and as a framework.  In the first case, DI application patterns are explained, and in the second case, it is a question of a support system and dependency assemblies.  I‚Äôm going to build this article in the same way, since it will be easier to explain this whole concept. <br><br>  To begin, consider the following code and see what problems arise in it. <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Engine(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tires = Tires.getInstance(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doors = app.get(<span class="hljs-string"><span class="hljs-string">'doors'</span></span>); } }</code> </pre> <br><br>  Nothing special.  We have a class <code>Car <br></code> <code>Car <br></code>  with the constructor, in which we set everything necessary to create the car object (‚Äúcar‚Äù) as soon as we need it.  What is the problem with this code?  As you can see, the constructor not only assigns the necessary dependencies to the internal properties, but also knows how their object is created.  For example, an engine object (‚Äúengine‚Äù) is created using the <code>Engine <br></code> Designer. <code>Engine <br></code>  , <code>Tires <br></code> <code>Tires <br></code>  (bus) seems to be a lone interface, and <code>doors <br></code> <code>doors <br></code>  (doors) are queried through a global object acting as a <b>service locator</b> . <br><br>  It turns out code that is difficult to maintain and even harder to test.  Just imagine that you would like to test this class.  How would you replace the <code>Engine <br></code> in this code <code>Engine <br></code> <code>Engine <br></code>  <code>MockEngine <br></code> dependency <code>MockEngine <br></code>  ?  When writing tests, we want to test different scenarios in which our code can be used, since each scenario requires its own configuration.  If we need the code to be tested, it is assumed that this will be a reusable code.  Which leads us to the thesis that the <b>code under test = reused code</b> and vice versa. <br><br>  So, how could this code be improved and made more convenient for testing?  It's very simple, and you probably already know what this is about.  Change the code like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(engine, tires, doors) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine = engine; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tires = tires; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doors = doors; } }</code> </pre><br><br>  We simply removed the creation of dependencies from the constructor and expanded the constructor function ‚Äî now it counts on all the necessary dependencies.  There are no concrete implementations left in the code; we literally moved the responsibility for creating these dependencies to a higher level.  If we now wanted to create a car object, we would just have to pass all the necessary dependencies to the constructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> car = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Engine(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tires(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Doors() );</code> </pre><br><br>  Cool?  Now the dependencies are separated from our class, which allows us to report the mock dependencies when writing tests: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> car = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockEngine(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockTires(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockDoors() );</code> </pre><br><br>  Imagine, <b>this is the introduction of dependence</b> .  More precisely, this particular pattern is also called ‚Äú <b>constructor injection</b> ‚Äù.  There are two more patterns: introduction through the class method (setter injection) and introduction through the interface (interface injection), but we will not consider them in this article. <br><br>  Great, here we are using DI, but where does the DI system start to be involved?  As mentioned earlier, we literally moved the responsibility for creating dependencies to a higher level.  This is our new problem.  Who organizes the assembly of all these dependencies for us?  Ourselves. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> engine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Engine(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tires = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tires(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Doors(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> car = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car(engine, tires, doors); car.drive(); }</code> </pre><br><br>  Now we need support for the main function.  Doing this manually is quite cumbersome, especially as the application grows.  Maybe it's better to do something like this? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> injector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Injector(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> car = injector.get(Car); car.drive(); }</code> </pre><br><br>  <b>Deploying dependencies as a framework</b> <br><br>  Here we start using dependency injection as a framework.  As you know, Angular 1 has its own DI system, which allows you to annotate services and other components;  also with its help, the injector can find out which dependencies need to be instantiated.  For example, the following code shows how to annotate our class <code>Car <br></code> <code>Car <br></code>  in Angular 1: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ ... } Car.$inject = [<span class="hljs-string"><span class="hljs-string">'Engine'</span></span>, <span class="hljs-string"><span class="hljs-string">'Tires'</span></span>, <span class="hljs-string"><span class="hljs-string">'Doors'</span></span>];</code> </pre><br><br>  Then we register our <code>Car <br></code> <code>Car <br></code>  as a service, and whenever we ask for it, we get a single instance from him, without bothering to create the necessary dependencies for the "car". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'myApp'</span></span>, []); app.service(<span class="hljs-string"><span class="hljs-string">'Car'</span></span>, Car); app.service(<span class="hljs-string"><span class="hljs-string">'OtherService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Car</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Car });</span></span></code> </pre><br><br>  Everything is cool, but it turns out that the existing DI mechanism still has some problems: <br><br><ul><li>  Internal cache - dependencies are issued as loners.  Whenever we request a service, it is created only once within the life cycle of the application.  Creating factory machinery is quite burdensome. </li><li>  Namespace conflict - an application can have only one marker of a specific ‚Äútype‚Äù.  If we have a car service and a third-party extension, which also introduces the same-name service into the program, we have a problem. </li><li>  Framework Embedding - Dependency injection in Angular 1 is built right into the framework.  It is not possible to use this mechanism separately as an independent system. </li></ul><br><br>  These problems need to be resolved to take Angular's dependency injection to a new level. <br><br>  <b>Embedding Addictions in Angular 2</b> <br><br>  Before moving on to code review, you need to understand the concept behind the DI in Angular 2. The following figure illustrates the essential components of the new DI system. <br><br><img src="https://habrastorage.org/files/5e5/7d9/090/5e57d90903dd4fc4a3d55e5015fb52fb.png"><br><br>  The implementation of dependencies in Angular 2 basically consists of three elements: <br><br><ul><li>  Injector is an object that provides us with various APIs for creating dependency instances. </li><li>  The provider - the provider resembles a recipe that describes the injector how to create an instance of a dependency.  The provider has a marker that it maps to the factory function that creates the object. </li><li>  Dependency - A dependency is the type to which the created object should belong. </li></ul><br><br>  So, having got an idea about this concept, let's consider how it is implemented in the code.  We continue to work with our class <code>Car <br></code> <code>Car <br></code>  and its dependencies.  Here‚Äôs how you can use dependency injection in Angular 2 to get an instance of <code>Car <br></code> <code>Car <br></code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/di'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> injector = Injector.resolveAndCreate([ Car, Engine, Tires, Doors ]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> car = injector.get(Car);</code> </pre><br><br>  We import from Angular 2 <code>Injector <br></code> <code>Injector <br></code>  that provides some static APIs for creating injectors.  Method <code>resolveAndCreate() <br></code> <code>resolveAndCreate() <br></code>  - this is, in essence, a factory function that creates an injector and accepts a list of providers.  Soon we will discuss how these classes are supposed to be used as providers, but for now <code>injector.get() <br></code> focus on <code>injector.get() <br></code> <code>injector.get() <br></code>  .  See how we request a copy of <code>Car <br></code> <code>Car <br></code>  in the last line?  How does our injector know what dependencies need to be created to instantiate a ‚Äúcar‚Äù?  Well, consider the class <code>Car <br></code> <code>Car <br></code>  ... <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/di'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Inject(Engine) engine, @Inject(Tires) tires, @Inject(Doors) doors ) { ... } }</code> </pre><br><br>  We import the Inject entity from the framework and apply it as a decorator to the parameters of our constructor. <br><br>  <code>Inject <br></code> decorator <code>Inject <br></code>  attaches metadata to our <code>Car <br></code> class <code>Car <br></code>  which is then consumed by our DI system.  In principle, this is what we are doing here: we inform DI that the first parameter of the constructor must be an instance of the <code>Engine <br></code> type. <code>Engine <br></code>  the second is of type <code>Tires <br></code> <code>Tires <br></code>  and the third is <code>Doors <br></code> <code>Doors <br></code>  .  We can rewrite this code in the spirit of TypeScript to make it look more natural: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(engine: Engine, tires: Tires, doors: Doors) { ... } }</code> </pre><br><br>  Great, our class declares its own dependencies, and DI can read this information and instantiate everything that is needed to create a <code>Car <br></code> object. <code>Car <br></code>  .  But how does the injector know <b>how</b> to create such an object?  This is where providers come into play.  Remember the <code>resolveAndCreate() <br></code> method <code>resolveAndCreate() <br></code>  in which we passed the list of classes? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> injector = Injector.resolveAndCreate([ Car, Engine, Tires, Doors ]);</code> </pre><br><br>  Again, the question may arise as to how this list of classes will act as a list of providers. <br>  It turns out that this is just a shorthand syntax.  If we convert it into a longer and more extensive version, then the situation will somewhat clarify: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {provide} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/angular2'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> injector = Injector.resolveAndCreate([ provide(Car, {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: Car}), provide(Engine, {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: Engine}), provide(Tires, {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: Tires}), provide(Doors {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: Doors}) ]);</code> </pre><br><br>  We have a <code>provide() <br></code> function. <code>provide() <br></code>  that displays a marker on the configuration object.  This <b>marker</b> can be a type or a string.  If you read these providers now, it becomes much clearer what is happening.  We provide an instance of the type <code>Car <br></code> <code>Car <br></code>  through <code>Car <br></code> class <code>Car <br></code>  type <code>Engine <br></code> <code>Engine <br></code>  through class <code>Engine <br></code> <code>Engine <br></code>  etc.  This is the recipe mechanism that we talked about above.  So, with the help of providers, we do not just tell the injector what dependencies are used throughout the application, but also describe how the objects of these dependencies will be created. <br><br>  Now the next question arises: when is it desirable to use a longer syntax instead of a shorter one?  Why write <code>provide(Foo, {useClass: Foo}) <br></code> <code>provide(Foo, {useClass: Foo}) <br></code>  if you can get by with foo alone, right?  Yeah, right.  That is why we immediately started with abbreviated syntax.  However, a longer syntax opens up great, very large possibilities.  Take a look at the following code snippet. <br><br><pre> <code class="javascript hljs">provide(Engine, {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: OtherEngine})</code> </pre><br><br>  Right.  We can display a marker on almost anything.  Here we display the <code>Engine <br></code> marker. <code>Engine <br></code>  on class <code>OtherEngine <br></code> <code>OtherEngine <br></code>  .  So, if we now request an object of type <code>Engine <br></code> <code>Engine <br></code>  then we get an instance of the class <code>OtherEngine <br></code> <code>OtherEngine <br></code>  . <br>  This is an incredibly powerful mechanism that allows not only to avoid name conflicts, but also to create a type as an interface, tying it to a specific implementation.  In addition, we can unload this or that dependency in the right place, replacing it with a marker and not touching the rest of the code. <br><br>  The introduction of dependencies in Angular 2 also brings a couple of recipe providers, which we will discuss in the next section. <br><br>  <b>Other provider configurations</b> <br><br>  Sometimes we want to get not an instance of a class, but just a single value or a factory function, which may require additional configuration.  Therefore, the providers mechanism when working with DI in Angular 2 provides several recipes.  Let's quickly go over them. <br><br>  <b>Providing values</b> <br><br>  You can provide a simple value with <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">useValue</span></span>: value} provide(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, {<span class="hljs-attr"><span class="hljs-attr">useValue</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>})</code> </pre><br><br>  This is useful when we want to provide simple configuration values. <br><br>  <b>Aliases</b> <br><br>  You can map a marker alias to another marker, like this: <br><br><pre> <code class="javascript hljs">provide(Engine, {<span class="hljs-attr"><span class="hljs-attr">useClass</span></span>: Engine}) provide(V8, {<span class="hljs-attr"><span class="hljs-attr">useExisting</span></span>: Engine})</code> </pre><br><br>  <b>Providing factories</b> <br><br>  Yes, our favorite factories <br><br><pre> <code class="javascript hljs">provide(Engine, {<span class="hljs-attr"><span class="hljs-attr">useFactory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_V8) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> V8Engine(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> V6Engine(); } } }})</code> </pre><br><br>  Of course, a factory can accept its own dependencies.  To transfer dependencies to a factory, you simply add a list of tokens to this factory: <br><br><pre> <code class="javascript hljs">provide(Engine, { <span class="hljs-attr"><span class="hljs-attr">useFactory</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">car, engine</span></span></span><span class="hljs-function">) =&gt;</span></span> { }, <span class="hljs-attr"><span class="hljs-attr">deps</span></span>: [Car, Engine] })</code> </pre><br><br>  <b>Optional dependencies</b> <br><br>  Decorator <code>@Optional <br></code> <code>@Optional <br></code>  allows you to declare dependencies as optional.  This is convenient, for example, in cases where our application relies on a third-party library, and if this library is not available, a rollback mechanism is needed. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(@Optional(jQuery) $) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$) { <span class="hljs-comment"><span class="hljs-comment">//  } } }</span></span></code> </pre><br><br>  As you can see, DI in Angular 2 solves almost all the problems that existed with DI in Angular.  But one question we have not yet discussed.  Are loners still being created with the new DI?  Yes. <br><br>  <b>One-time dependencies and child injectors</b> <br><br>  If we need a one-time dependency (transient dependency) - one that, when requested, will always require its new instance, there are two options: <br><br>  Factories can return instances of classes.  It will not be loners. <br><br><pre> <code class="javascript hljs">provide(Engine, {<span class="hljs-attr"><span class="hljs-attr">useFactory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Engine(); } }})</code> </pre><br>  You can create a child injector using <code>Injector.resolveAndCreateChild() <br></code> <code>Injector.resolveAndCreateChild() <br></code>  .  The child injector introduces its own bindings, and this instance will be different from the parent injector. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> injector = Injector.resolveAndCreate([Engine]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> childInjector = injector.resolveAndCreateChild([Engine]); injector.get(Engine) !== childInjector.get(Engine);</code> </pre><br><br>  Child injectors are interesting not only this.  It turns out that the child injector can search for the marker binding on the parent injector, if no binding is registered for the specific marker on the child injector.  The following diagram shows what happens: <br><br><img src="https://habrastorage.org/files/079/d8c/793/079d8c7937ce44219c78cf59926726f3.png"><br><br>  The figure shows three injectors, two of which are children.  Each injector gets its own configuration of providers.  Now, if we request an instance of the Car type from the second child injector, then this child injector will create the ‚Äúcar‚Äù object.  However, the ‚Äúengine‚Äù (engine) will be created by the first child injector, and the ‚Äútires‚Äù (tires) and ‚Äúdoors‚Äù (doors) - the most superior of the external parent injectors.  It turns out something like a chain of prototypes. <br><br>  You can even configure the visibility of dependencies, as well as specify the level up to which the child injector should look for information.  However, this is a topic for another article. <br><br>  <b>How does all this work in Angular 2?</b> <br><br>  Now that we‚Äôve covered the implementation of dependencies in Angular 2, let's discuss how this mechanism works within the framework of the framework.  Should we create injectors manually when we assemble Angular 2 components?  Fortunately, the Angular team wasted no time and effort, and created a beautiful API that hides the entire injector machine when building components in Angular 2. <br><br>  Consider the following simple component Angular 2. <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app'</span></span> }) @View({ <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;h1&gt;Hello !&lt;/h1&gt;'</span></span> }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'World'</span></span>; } } bootstrap(App);</code> </pre><br><br>  Nothing special.  Suppose we want to extend this component with <code>NameService <br></code> <code>NameService <br></code>  used in component constructor.  Such a service might look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'Pascal'</span></span>; } getName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } }</code> </pre><br><br>  Again, nothing special.  Just create a class.  Then, in order to open up access to it as an object under implementation in our application, we must provide some information about the provider‚Äôs configuration to the injector of our application.  But how to do that?  We haven't even created an injector yet. <br><br>  <code>bootstrap() <br></code> method <code>bootstrap() <br></code>  is creating a root injector for our application when it boots up.  It accepts the list of providers as the second argument, and this list will be transmitted directly to the injector right at the stage of its creation.  In other words, here‚Äôs what you need to do here: <br><br><pre> <code class="javascript hljs">bootstrap(App, [NameService]);</code> </pre><br><br>  That's all.  Now, turning to the implementation as such, we apply the decorators <code>@Inject <br></code> studied above <code>@Inject <br></code>  . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(@Inject(NameService) NameService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = NameService.getName(); } }</code> </pre><br><br>  Or, if we dwell on TypeScript, we can simply add type annotations to our constructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(NameService: NameService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = NameService.getName(); } }</code> </pre><br><br>  Gorgeous!  The whole interior of Angular miraculously disappeared somewhere!  But one more question remains: what to do if we need a different configuration of bindings for a particular component? <br><br>  Suppose we have a service <code>NameService <br></code> <code>NameService <br></code>  that can be deployed across the entire application for the <code>NameService <br></code> type <code>NameService <br></code>  , but exactly one component needs a different service?  This is where the <code>providers <br></code> property comes in handy. <code>providers <br></code>  annotations <code>@Component <br></code> <code>@Component <br></code>  .  It allows us to add providers to a specific component (as well as its child components). <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app'</span></span>, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [NameService] }) @View({ <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;h1&gt;Hello !&lt;/h1&gt;'</span></span> }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre><br><br>  I will explain: <code>providers <br></code> <code>providers <br></code>  does not configure instances to be injected.  It configures the child injector that will be created for this component.  As mentioned above, we can also configure the visibility of our bindings, more precisely, to indicate which component it can embed.  For example, the viewProviders property allows you to open access to dependencies only for the representation of the component, but not for its descendants. <br><br>  <b>Conclusion</b> <br><br>  The new system of introducing dependencies in Angular solves all the problems that existed with DI in Angular 1. No more name conflicts.  This is a separate component of the framework, can be used as a standalone system, even without Angular 2. </div><p>Source: <a href="https://habr.com/ru/post/270837/">https://habr.com/ru/post/270837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270821/index.html">Pirate metrics: how to create an email campaign based on the AARRR principle. Part 4</a></li>
<li><a href="../270823/index.html">First article about checking C # project</a></li>
<li><a href="../270825/index.html">Component-oriented C # engine</a></li>
<li><a href="../270827/index.html">PostgreSQL on multicore servers Power 8</a></li>
<li><a href="../270829/index.html">Development and debugging of applications for Android Wear</a></li>
<li><a href="../270839/index.html">Class Requests at InterSystems Cach√©</a></li>
<li><a href="../270841/index.html">Cisco ipsec tunnel without using crypto map</a></li>
<li><a href="../270843/index.html">Digest of the game industry: October</a></li>
<li><a href="../270845/index.html">How to make an elephant out of a fly</a></li>
<li><a href="../270847/index.html">JS Programming Contest: Email Filters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>