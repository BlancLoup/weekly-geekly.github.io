<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Normalization of relationships. First and second normal forms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 The normalization of relations (tables) is one of the fundamental parts of the theory of relational databases. Normalization is intended to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Normalization of relationships. First and second normal forms</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  <b>The normalization of relations</b> (tables) is one of the fundamental parts of the theory of relational databases.  Normalization is intended to get rid of redundancy in the relationship and modify their structure so that the process of working with them is not burdened by various extraneous difficulties.  If you ignore this approach, the design efficiency rapidly decreases, which, together with other such liberties, can lead to critical consequences. <br><br>  It is useful for any specialist, by the nature of his activity, one way or another connected with the design of relational databases, to understand and be able to normalize relations.  And with this post I would like to start a small series of publications devoted to normal forms, aimed at giving those Habrahabr readers, who for various reasons have not yet mastered this topic, the ability to easily fill this gap in knowledge. <br><br>  The article is not intended to provide a detailed and accurate statement of the principles of normalization, since this is obviously not possible within the framework of a blog due to the large amounts of information required for publication with this approach.  In addition, for this purpose there is a large amount of literature written by excellent experts.  My task, I believe, is to popularly demonstrate and explain the <i>basic</i> principles. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Terms Used </h4><br>  <b>An attribute</b> is a property of some entity.  Often called a table field. <br>  <b>An attribute domain</b> is the set of valid values ‚Äã‚Äãthat an attribute can take. <br>  <b>A tuple</b> is a finite set of interrelated valid attribute values ‚Äã‚Äãthat together describe an entity (a row of a table). <br>  <b>A relation</b> is a finite set of tuples (table). <br>  <b>A relationship diagram</b> is a finite set of attributes that define an entity.  In other words, it is a table structure consisting of a specific set of fields. <br>  <b>Projection</b> is a relation obtained from a given by deleting and (or) rearranging some attributes. <br>  <b>The functional dependency</b> between attributes (attribute sets) X and Y means that for any valid set of tuples in this respect: if two tuples match on the value of X, then they match on the value of Y. For example, if the value of the attribute "Company Name" is Canonical Ltd , then the value of the ‚ÄúHeadquarters‚Äù attribute in such a tuple will always be Millbank Tower, London, United Kingdom.  Designation: {X} -&gt; {Y}. <br><br><h4>  First normal form </h4><br>  The relationship is <b>in the first normal form</b> (abbreviated 1NF) if all its attributes are atomic, that is, if none of its attributes can be divided into simpler attributes that correspond to some other properties of the described entity. <br><br>  We will call the original relation the main one, and the value of a non-atomic attribute - subordinate. <br><br>  In order to normalize the original relation, the attributes of which are non-atomic, it is necessary to combine the schemes of the main and subordinate relations.  In addition, if, for example, the table corresponding to the unnormalized relation is already contained in the database and is filled with information, the task is complicated by the fact that the value of a non-atomic attribute can in turn contain several tuples. <br><br>  It is necessary to clarify the above with an example.  Consider a relationship that has the attributes "Employee ID", "Full Name", "Position", "Projects".  Obviously, one employee can work on several projects.  Suppose that a project is described by an identifier, a name and a date of delivery. <br><table><tbody><tr><td width="90">  <b>Employee code</b> </td><td width="120">  <b>Full name</b> </td><td width="90">  <b>Position</b> </td><td>  <b>Projects</b> </td></tr><tr><td>  one </td><td>  Ivanov Ivan Ivanovich </td><td>  Programmer </td><td>  ID: 123;  Name: Steam boiler control system;  Delivery date: 09/30/2011 <br>  ID: 231;  Name: PS for control and notification of the maximum permissible concentration of various gases in the room;  Delivery date: 11/30/2011 <br>  ID: 321;  Name: Face Recognition Module for the protection system;  Delivery date: 12/01/2011 </td></tr></tbody></table>  It is easy to see that not all the attributes of this relationship are atomic (indivisible).  In particular, the ‚ÄúProjects‚Äù attribute can be divided into three simpler attributes: ‚ÄúProject code‚Äù, ‚ÄúName‚Äù, ‚ÄúDate of delivery‚Äù, and the value of this attribute for an employee Ivan Ivanovich Ivanov contains several tuples ‚Äî information about three projects. <br><br>  <i>Note: from a certain point of view, the ‚Äúfull name‚Äù attribute can also be considered non-atomic, and in this case it should also be divided into simpler ones, such as ‚ÄúLast Name‚Äù, ‚ÄúFirst Name‚Äù, ‚ÄúMiddle Name‚Äù.</i> <br><br>  Now it is time to consider the relationship normalization algorithm to 1NF. <br><ol><li>  Create a new relationship whose scheme will be obtained by merging the main and subordinate schemes of the original relationship into one. </li><li>  For each tuple of the original relation, include in the new as many lines as there are tuples in the subject relation of this tuple. </li><li>  Fill in the values ‚Äã‚Äãof the attributes of the new relationship that match the attributes of the subordinate relationship. </li><li>  Fill the lines of the new relationship with the values ‚Äã‚Äãof the atomic attributes of the source. </li></ol>  Apply this algorithm to the above relation.  The scheme of the new relationship will consist of 6 attributes: ‚ÄúEmployee ID‚Äù, ‚ÄúFull Name‚Äù, ‚ÄúPosition‚Äù, ‚ÄúProject ID‚Äù, ‚ÄúName‚Äù, ‚ÄúDelivery Date‚Äù.  For one single tuple of a given relation, we add three new lines to the new one for each project (by the number of tuples in the subordinate relation).  Now you can fill in the values ‚Äã‚Äãof separated attributes with tuples from the subordinate relation.  Then we transfer to each of these lines the values ‚Äã‚Äãof atomic attributes: ‚ÄúEmployee ID‚Äù, ‚ÄúFull Name‚Äù, ‚ÄúPosition‚Äù (as you guessed, all three lines will contain the same values ‚Äã‚Äãof these attributes). <br><br>  The result will look like this: <br><table><tbody><tr><td width="90">  <b>Employee code</b> </td><td width="120">  <b>Full name</b> </td><td width="90">  <b>Position</b> </td><td width="90">  <b>Project code</b> </td><td>  <b>Title</b> </td><td width="90">  <b>Date of delivery</b> </td></tr><tr><td>  one </td><td>  Ivanov Ivan Ivanovich </td><td>  Programmer </td><td>  123 </td><td>  Steam Boiler Control System </td><td>  09/30/2011 </td></tr><tr><td>  one </td><td>  Ivanov Ivan Ivanovich </td><td>  Programmer </td><td>  231 </td><td>  PS for monitoring and notification of the exceedances of MPC of various gases in the room </td><td>  11/30/2011 </td></tr><tr><td>  one </td><td>  Ivanov Ivan Ivanovich </td><td>  Programmer </td><td>  321 </td><td>  Face Recognition Module for Security System </td><td>  12/01/2011 </td></tr></tbody></table><h4>  Second normal form </h4><br>  It is clear that the relation in 1NF may also be redundant.  To eliminate it is the second normal form.  But before proceeding to its description, you must first identify the shortcomings of the first. <br><br>  Let the original relation contain information about the supply of certain goods and their suppliers. <br><table><tbody><tr><td width="90">  <b>Supplier Code</b> </td><td width="90">  <b>City</b> </td><td width="90">  <b>City status</b> </td><td width="90">  <b>Product code</b> </td><td width="90">  <b>amount</b> </td></tr><tr><td>  one </td><td>  Moscow </td><td>  20 </td><td>  one </td><td>  300 </td></tr><tr><td>  one </td><td>  Moscow </td><td>  20 </td><td>  2 </td><td>  400 </td></tr><tr><td>  one </td><td>  Moscow </td><td>  20 </td><td>  3 </td><td>  100 </td></tr><tr><td>  2 </td><td>  Yaroslavl </td><td>  ten </td><td>  four </td><td>  200 </td></tr><tr><td>  3 </td><td>  Stavropol </td><td>  thirty </td><td>  five </td><td>  300 </td></tr><tr><td>  3 </td><td>  Stavropol </td><td>  thirty </td><td>  6 </td><td>  400 </td></tr><tr><td>  four </td><td>  Pskov </td><td>  15 </td><td>  7 </td><td>  100 </td></tr></tbody></table>  It is known in advance that in this respect the following functional dependencies are contained: <br>  {{Supplier Code, Product Code} -&gt; {Quantity}, <br>  {Supplier Code} -&gt; {City}, <br>  {Supplier Code} -&gt; {Status}, <br>  {City} -&gt; {Status}} <br><br>  Primary key in relation to: {Supplier Code, Product Code}. <br><br>  Obviously, the relationship is redundant: it describes two entities - the supply and the supplier.  In this regard, the following anomalies occur: <br><ul><li>  Anomaly insertion.  Information about a supplier who has not yet delivered a single product can be added to an attitude. </li><li>  Anomaly removal.  If there was only one delivery from the supplier, then deleting the information about it will also delete all information about the supplier. </li><li>  Anomaly updates.  If you need to change any information about the supplier (for example, the supplier has moved to another city), then you will have to change the attribute values ‚Äã‚Äãin all delivery records from him. </li></ul>  The physical meaning of the redundancy of the original relationship lies in the fact that it describes <i>not one</i> entity, but <i>two</i> - the <i>supply</i> and the <i>supplier</i> . <br><br>  To eliminate these anomalies, it is necessary to break the original relation into a projection: <br><ol><li>  The first one should include the primary key and all non-key attributes that are <i>clearly</i> dependent on it. </li><li>  The remaining projections (in this case, it is one) will include non-key attributes that depend on the primary key <i>implicitly</i> , along with the <i>part of the</i> primary key on which these attributes depend explicitly. </li></ol>  As a result, two relationships will be obtained: <br><table><tbody><tr><td width="150">  <b>Supplier Code</b> </td><td width="150">  <b>Product code</b> </td><td width="150">  <b>amount</b> </td></tr><tr><td>  one </td><td>  one </td><td>  300 </td></tr><tr><td>  one </td><td>  2 </td><td>  400 </td></tr><tr><td>  one </td><td>  3 </td><td>  100 </td></tr><tr><td>  2 </td><td>  four </td><td>  200 </td></tr><tr><td>  3 </td><td>  five </td><td>  300 </td></tr><tr><td>  3 </td><td>  6 </td><td>  400 </td></tr><tr><td>  four </td><td>  7 </td><td>  100 </td></tr></tbody></table>  The first relation now corresponds to the following functional dependencies: <br>  {Supplier Code, Product Code} -&gt; {Quantity} <br><table><tbody><tr><td width="150">  <b>Supplier Code</b> </td><td width="150">  <b>City</b> </td><td width="150">  <b>City status</b> </td></tr><tr><td>  one </td><td>  Moscow </td><td>  20 </td></tr><tr><td>  2 </td><td>  Yaroslavl </td><td>  ten </td></tr><tr><td>  3 </td><td>  Stavropol </td><td>  thirty </td></tr><tr><td>  four </td><td>  Pskov </td><td>  15 </td></tr></tbody></table>  The second relation is: <br>  {{Supplier Code} -&gt; {City}, <br>  {Supplier Code} -&gt; {Status}, <br>  {City} -&gt; {Status}} <br><br>  Such a partition eliminated the anomalies described above: you can add information about the supplier who has not yet delivered the product, delete the delivery information without deleting information about the supplier, and easily update the information if the supplier moved to another city. <br><br>  Now we can formulate the definition of the second normal form, to which, most likely, the reader has already been able to guess independently: the relation is <b>in the second normal form</b> (abbreviated 2NF) if and only if it is in the first normal form and each of its non-key attributes is irreducibly dependent on primary key. <br><br><h4>  Literature </h4><br>  For a more in-depth and thorough study of this topic, we recommend the book ‚ÄúIntroduction to Database Systems‚Äù by Chris J. Data, on the basis of which this article was written. </div><p>Source: <a href="https://habr.com/ru/post/129195/">https://habr.com/ru/post/129195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129187/index.html">In the wake of Yet another Conference 2011</a></li>
<li><a href="../129188/index.html">% habrauser%, do you use Habralent 3.0?</a></li>
<li><a href="../129189/index.html">ZK + Spring 3 + Hibernate: two heads are good, but three is better, faster, stronger</a></li>
<li><a href="../129191/index.html">Forced type casting in Erlang</a></li>
<li><a href="../129193/index.html">Firefox 7 is released</a></li>
<li><a href="../129196/index.html">QNX RTOS: loosely coupled cross-tasking PPS</a></li>
<li><a href="../129198/index.html">Profit Zynga fell by 95%</a></li>
<li><a href="../129199/index.html">Cloud4Y at InfoSecurity Russia. StorageExpo. Documation '2011</a></li>
<li><a href="../129201/index.html">The implementation of dictionary objects, as in Javascript</a></li>
<li><a href="../129202/index.html">Put the objects on the stream, the pattern of the factory of objects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>