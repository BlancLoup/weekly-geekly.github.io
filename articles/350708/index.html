<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Containers of the introduction of dependencies and the benefits of their use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 Hello! I continue the series of translations, in which we analyze by bone what Dependency Injection is. 

 The previous articles in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Containers of the introduction of dependencies and the benefits of their use</h1><div class="post__text post__text-html js-mediator-article"><h3>  From translator </h3><br>  Hello!  I continue the series of translations, in which we analyze by bone what Dependency Injection is. <br><br>  The <a href="https://habr.com/ru/post/350708/">previous articles in the series</a> dealt with ‚Äúdependency injection‚Äù as an approach to designing applications and possible ways to implement such an approach.  Were analyzed the types of dependencies, options for their implementation, were given tips to reduce the connectivity of the code components. <br><br>  In today's translation, we‚Äôll talk about what a DI container is, its functions, advantages of use and difference from factories. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tr/ii/s6triigymr9y9-yns9vuo2pxs_q.jpeg"></div><a name="habracut"></a><br><a name="series"></a><h4>  The series includes the following articles. </h4><br><ul><li>  <a href="https://habrahabr.ru/post/349836/">Understanding Dependencies</a> </li></ul><br><ol><li>  <a href="https://habrahabr.ru/post/350068/">Dependency Injection</a> </li><li>  <a href="https://habr.com/ru/post/350708/">Dependency Injection Containers</a> </li><li>  <a href="https://habr.com/ru/post/350708/">Dependency Injection Benefits</a> </li><li>  When to use Dependency Injection </li><li>  Is Dependency Injection Replacing the Factory Patterns? </li></ol><br><a name="start_DI_containers"></a><h2>  Dependency Injection Containers </h2><br>  <b>Key terms</b> : container, component lifecycle management <br><br>  If all the components in your system have their own dependencies, then somewhere in the system some class or factory should know what to implement in all these components.  This is what a DI container does.  The reason why this is called a ‚Äú <b>container</b> ‚Äù rather than a ‚Äúfactory‚Äù is that a container usually takes responsibility not only for creating instances and introducing dependencies. <br><br>  When you configure a DI container, you determine which component instances it should be able to create, and which dependencies to embed in each component.  Also, you can usually configure an instance creation mode for each component.  For example, should a new instance be created every time?  Or should the same instance of the component be reused ( <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">singleton</a> ) wherever it is embedded? <br><br>  If some components are configured as singletones, then some containers have the ability to call singleton methods when the container is turned off.  Thus, a singleton can free up any resources it uses, such as connecting to a database or a network connection.  This is commonly referred to as " <b>object life cycle management</b> ."  This means that the container is able to control the component at different stages of the component life cycle.  For example, create, configure, and delete. <br><br>  Lifecycle management is one of the responsibilities that DI containers take in addition to creating instances and implementing them.  The fact that a container sometimes retains a reference to components after creating an instance is the reason why it is called a ‚Äúcontainer‚Äù rather than a factory.  DI containers typically retain references to objects whose life cycle they will have to manage or that will be reused for future implementations, such as Singleton or <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2586_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Adaptive</a> .  When the container is configured to create new instances of the components on every call, the container usually ‚Äúforgets‚Äù about the objects created.  Otherwise, the garbage collector will have a hot time when the time comes to collect all these objects. <br><br>  Currently there are several DI containers available.  For Java, there are <a name="containers"></a>  <a href="https://habr.com/ru/post/350708/">Butterfly Container</a> , <a href="https://spring.io/">Spring</a> , <a href="http://picocontainer.com/">Pico Container</a> ( <b><i>ed.</i></b> In its development was played by Martin Fowler), <a href="https://github.com/google/guice">Guice</a> (approx. By Google) and others ( <b><i>ed.</i></b> For example, there is also <a href="https://google.github.io/dagger/">Dagger</a> , also developed by Google. Jakob Jenkov, author translated article, developed <a name="bf_di"></a>  Butterfly Container.  Its <a href="https://github.com/jjenkov/butterfly-di-container">source code is available on github</a> , and the <a href="http://tutorials.jenkov.com/butterfly-container/index.html">documentation is contained in a separate series of posts</a> ). <br><br><a name="start_DI_benefits"></a><h2>  Benefits from using DI and DI containers </h2>  <b>Key terms</b> : dependency transfer, collaborators <br><br>  There are several advantages from using DI containers in comparison with the fact that components have to independently resolve their dependencies ( <b><i>note</i></b> ‚Äúto independently resolve dependencies‚Äù in this context means ‚Äúto create objects necessary for the component to work inside the component‚Äù). <br><br>  Some of these benefits are: <br><br>  <a href="https://habr.com/ru/post/350708/">Less dependencies</a> <br>  <a href="https://habr.com/ru/post/350708/">Less ‚Äútransfer‚Äù of dependencies</a> <br>  <a href="https://habr.com/ru/post/350708/">Code easier to reuse</a> <br>  <a href="https://habr.com/ru/post/350708/">Code easier to test</a> <br>  <a href="https://habr.com/ru/post/350708/">Code easier to read</a> <br><br>  These advantages are explained in more detail below. <br><br><a name="less_dep"></a><h3>  Less dependencies </h3><br>  DI makes it possible to eliminate or at least reduce optional component dependencies.  The component is vulnerable to changing its dependencies.  If the dependency changes, the component may need to adapt to these changes.  For example, if the signature of the dependency method changes, the component will have to change the call to this method.  When component dependencies are minimized, it is less susceptible to the need for change. <br><br><a name="easy_reuse"></a><h3>  Code easier to reuse </h3><br>  Reducing the number of dependencies of a component usually makes it easier to reuse in another context.  The fact that dependencies can be injected and, therefore, configured externally, increases the possibility of reusing this component.  If in another context a different implementation of an interface, or a different configuration of the same implementation, is required, the component can be configured to work with this implementation.  There is no need to change the code. <br><br><a name="easy_test"></a><h3>  Code easier to test </h3><br>  DI also enhances the ability to test components.  When dependencies can be embedded in a component, it is also possible to implement the mocks of these objects.  Mock objects are used for testing as a replacement for real implementation.  The behavior of the mock object can be configured.  Thus, all possible behavior of a component when using a mock object can be tested for correctness.  For example, handling a situation where mock returns a valid object, when it returns null, and when an exception is thrown.  In addition, mock objects usually record which of their methods were invoked and, thus, the test can verify that the component using the mock used them ( <b><i>ed.</i></b> Methods) as expected. <br><br><a name="easy_read"></a><h3>  Code easier to read </h3><br>  DI transfers dependencies to the component interface.  This makes it clearer what dependencies the component has, making the code more readable.  You do not have to look through all the code in order to see what dependencies you need to provide for this component.  They are all visible in the interface. <br><br><a name="less_transfer"></a><h3>  Less ‚Äútransfer‚Äù of dependencies </h3><br>  Another nice bonus from DI - eliminates the fact that I call the " <b>dependency transfer</b> ."  The transfer of dependencies is manifested in the fact that an object receives a parameter in one of its methods, which is not needed by the object itself, but is needed by one of the objects that it calls for its work.  This may sound a bit abstract, so let's give a simple example. <br><br>  Component A loads the application and creates a configuration object, Config, which is needed by some of the application objects, but not all components in the system.  Then A calls B, B calls C, C calls D. Neither B nor C needs a Config object, but D needs.  Here is the call chain. <br><br><pre><code class="hljs erlang-repl">A  Config A --&gt; B --&gt; C --&gt; D --&gt; Config</code> </pre> <br>  Arrows symbolize method calls.  If A creates B, and B creates C, and C creates D, and D needs Config, then the Config object must be passed through the entire chain: from A to B, from B to C, and finally from C to D. However, neither C nor D is needed for the operation of the Config object.  All they do is ‚Äútransfer‚Äù Config to D, which depends on Config.  From here and the name "transfer of dependences". <br><br>  If you worked on a large system, you may have seen many cases of dependency transfers ‚Äî parameters that are simply passed to a lower level. <br><br>  Migrating dependencies creates a lot of ‚Äúnoise‚Äù in the code, making it harder to read and maintain.  In addition, it makes testing components difficult.  If calling the method of component A requires an OX object just because it is needed by its CY "collaborator" (the original <b><i>editor</i></b> uses the word collaborator. <a href="https://sites.google.com/site/cs4217jan2011team2/programming-paradigms/the-crc-card/assigning-collaborators">By definition</a> , collaborators are classes that either depend on others or provide something to the other class. It turns out that the category ‚Äú <b>collaborator</b> ‚Äù combines the concepts of ‚Äúdependent class‚Äù and ‚Äúdependency‚Äù is their superset), you still need to provide an instance of OX when testing the method of object A, even if it does not use it.  Even if you use the mock implementation of the CY collaborator, which may not use the OX object.  You can work around this by passing null instead of OX if there is no null check in the test method.  Sometimes during the test it can be difficult to create an OX object.  If the OX constructor depends on many other objects or values, your test will also have to pass meaningful objects / values ‚Äã‚Äãfor these parameters.  And if OX depends on OY, which depends on OZ, it becomes real madness. <br><br>  When call stacks are deep, moving dependencies is a real pain.  Especially if you find that a component from the bottom of the stack needs another object that is available higher up the stack.  Then you will have to add this object as a parameter to all method calls down the stack, starting from where the required object is available and ending where it is needed. <br><br>  The common solution for the problem of ‚Äútransfer of dependencies‚Äù is to make the necessary objects static singleton.  Thus, any component of the system will be able to access the singleton through its static factory method ( <b><i>note ed.</i></b> <a href="http://stackoverflow.com/a/9914562">Not to be confused with the Factory Method pattern</a> ).  Unfortunately, static singletons are pulling a whole bunch of other problems behind them, which I won't dive here.  Static singletons are evil.  Do not use them if you can avoid it. <br><br>  When you use a DI container, you can reduce the ‚Äúdependency transfer‚Äù and reduce the use of static singletons.  The container knows about all the components in the application.  Therefore, it can perfectly link components without having to pass dependencies to one component through another.  An example with components using a container will look like this: <br><br><pre> <code class="hljs erlang-repl">  Config   D   Config   C   D   B   C   A   B A --&gt; B --&gt; C --&gt; D --&gt; Config</code> </pre> <br>  When A calls B, he does not need to pass the Config object to B. D already knows about the Config object. <br><br>  However, there may still be situations in which the transfer of dependencies cannot be avoided.  For example, if your application processes requests (this is a web application or a web service), and the components that process requests are singletones.  Then the request object may need to be passed down the chain of calls each time it needs access to a component of a lower layer. <br><br>  In the next article, When to use dependency injection, Jakob Jenkov gives practical examples of the use of DI.  How to write code if you need: embed configuration information in one or more components, embed the same dependency in one or more components, implement different implementations of the same dependency, implement the same implementation in different configurations, get some data from the container.  Also, the author tells about the cases in which you will not need DI.  Stay tuned! <br><br>  <a href="https://habr.com/ru/post/350708/">To top</a> </div><p>Source: <a href="https://habr.com/ru/post/350708/">https://habr.com/ru/post/350708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350694/index.html">New programming language framework</a></li>
<li><a href="../350696/index.html">Notes for the source editor (development environment)</a></li>
<li><a href="../350698/index.html">400 thousand servers may be subject to RCE attacks due to a vulnerability in the Exim mail agent</a></li>
<li><a href="../350700/index.html">The girls and the fourth industrial revolution</a></li>
<li><a href="../350702/index.html">A couple of tips for beginners gamedeveloper from novice gamedeveloper</a></li>
<li><a href="../350710/index.html">Investigate the minor features of C # 7</a></li>
<li><a href="../350712/index.html">FastTrack Training. "Network Basics". "Basics of routing." Eddie Martin December 2012</a></li>
<li><a href="../350716/index.html">Rust: why do we need macros</a></li>
<li><a href="../350718/index.html">We generate levels for the game using neural networks</a></li>
<li><a href="../350720/index.html">[Not only to students] Packet Tracer Lab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>