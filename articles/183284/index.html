<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>USB support in KolibriOS: what's inside? Part 3: Host Controller Support Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The support level of host controllers, as I wrote in the general overview , should cause higher levels when certain events occur and provide the funct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>USB support in KolibriOS: what's inside? Part 3: Host Controller Support Code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/882/61a/ae8/88261aae82f0dfcb06d32f7bfd94c4c6.png" align="right">  The support level of host controllers, as I wrote in the <a href="http://habrahabr.ru/company/kolibrios/blog/181586/">general overview</a> , should cause higher levels when certain events occur and provide the functions necessary for higher levels to work. <br>  For convenience, I will talk about the various elements of the support code in the order in which they receive control. <br><br><h1>  Starting USB Subsystem </h1><br><h3>  Preparation: USB controllers in the list of PCI devices </h3><br>  The USB subsystem is started by calling <code>usb_init</code> from <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Finit.inc">init.inc</a> during system boot. <br><br>  By the time USB is launched, a list of <code>pcidev_list</code> PCI devices found has already been prepared.  USB controllers are recognized among all PCI devices by class code, subclass, and interface: <table><tbody><tr><th>  Type of </th><th>  Class </th><th>  Subclass </th><th>  Interface </th></tr><tr><td>  Uhci </td><td>  0Ch </td><td>  03h </td><td>  00h </td></tr><tr><td>  OHCI </td><td>  0Ch </td><td>  03h </td><td>  10h </td></tr><tr><td>  EHCI </td><td>  0Ch </td><td>  03h </td><td>  20h </td></tr><tr><td>  Xhci </td><td>  0Ch </td><td>  03h </td><td>  30h </td></tr></tbody></table>  <code>usb_init</code> passes through the list of PCI devices several times, each time allocating USB controllers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Disable BIOS control </h3><br>  Some BIOSes can handle USB mice, USB keyboards and USB flash drives, providing data for operating systems that do not know about USB.  Data from mice and keyboards is converted into PS / 2 format and in one way or another is brought to the operating system in the same way as if a real PS / 2 mouse and / or keyboard existed in the system.  A USB flash drive seems to be a hard disk from the point of view of <a href="http://en.wikipedia.org/wiki/INT_13H"><code>int 13h</code></a> ‚Äî such support is found more often than mouse support, since it is necessary for booting from flash drives. <br>  The operating system can use any processor mode and independently handle any interrupts.  So that the BIOS in such conditions could still get control with a predictable environment, still around 486 (starting with the special i386SL version, to be exact), Intel came up with a special <a href="http://en.wikipedia.org/wiki/System_Management_Mode"><i>System Management Mode (SMM)</i></a> processor, in which the BIOS works, interrupting the operating system the system.  It is impossible to get into SMM using the processor itself;  The processor enters this mode when the motherboard hardware gives a special signal to the <i>System Management Interrupt (SMI)</i> .  USB controllers embedded in the chipset, as a rule, can generate SMI instead of interruption, depending on the settings. <br><br><a name="habracut"></a>  The first pass through the <code>pcidev_list</code> list is used to tell the BIOS that USB controllers are under the control of the operating system, so the BIOS should no longer do anything with them. <br><br>  It is important that on this aisle all companions are processed <i>to a</i> pair of EHCI controller.  For example, bypassing in ascending order of PCI coordinates guarantees this.  In the first versions of the code, this pass was not separately allocated, and all EHCI controllers were processed first;  This worked on many configurations, but during the <a href="http://board.kolibrios.org/viewtopic.php%3Fp%3D46724">tests</a> it turned out that not all BIOSes were written correctly and that the wrong order could cause the system to hang inside the SMM.  More specifically, the following scenario is possible: <br><ul><li>  The BIOS detects a stop request with EHCI; </li><li>  BIOS deconfigures the controller and forgets about it; </li><li>  possession of ports passes to the partner; </li><li>  A flash drive connected to the port also goes to the companion; </li><li>  a companion signals a new device; </li><li>  since the companion is still under the control of the BIOS, she considers the device her own, finds out what kind of device it is;  sees an old flash drive; </li><li>  and it turns out that the BIOS remembers the USB flash drive that it was located on the controller, which the BIOS successfully forgot about.  Attempting to use the data of a forgotten controller quickly leads to a sad end. </li></ul>  Handling companions before EHCI eliminates the possibility of this scenario. <br><br>  The method of reporting the BIOS that it is time to return the controller depends on the controller.  The corresponding functions are called <code>{u,o,e}hci_kickoff_bios</code> .  UHCI, being the chronologically first interface, does not provide a special message, so <code>uhci_kickoff_bios</code> simply turns off SMI generation and stops the controller.  In OHCI and EHCI, the procedure for communicating with the BIOS is theoretically described in the specification, but practically ... there are some details.  In both cases, the procedure is as follows: set a certain bit in a register and wait for the desired state of the other bit;  if the BIOS works with the controller, the controller will generate SMI, the processor will go to the SMM and cause the BIOS, the BIOS will untie the controller, change the other bit to the desired state and exit the SMM.  The detail of the procedure for OHCI is that, as it turned out during the <a href="http://board.kolibrios.org/viewtopic.php%3Fp%3D47076">tests</a> , the BIOS may well leave the controller with interrupt sources enabled;  if any event generates an interrupt and the interrupt is unmasked in the interrupt controller before the OHCI driver sets its handler, the system will again hang - the OHCI will generate the interrupt again and again, which cannot be processed.  Therefore, <code>ohci_kickoff_bios</code> disables interrupts during a conversation with the BIOS and turns off all OHCI interrupt sources at the end of a conversation.  In EHCI, in fact, it is impossible to immediately set the bit ‚Äúthe operating system has requested ownership of the controller,‚Äù you first need to check that the BIOS owns the controller;  Some BIOSes ‚Äúrelease‚Äù the controller and forget about it even before booting the system, do not clear the SMI generation bits and cannot process the request - the system will hang again due to the SMI generated again and again. <br><br><h3>  Controller initialization </h3><br>  If, on the first pass, <code>usb_init</code> does not detect USB controllers, it stops its operation.  If there are USB controllers, then <code>usb_init</code> creates a stream allocated for USB processing and makes two more passes through the list of PCI devices, calling <code>usb_init_controller</code> for each USB controller, passing the pointer to the corresponding <code>usb_hardware_func</code> structure in <code>usb_hardware_func</code> .  The second pass processes the EHCI, the third passes UHCI and OHCI.  Here, the EHCI is processed in front of the partners, so that the HS devices are immediately under the control of the EHCI instead of signaling the companion about themselves and immediately being taken away from it. <br><br>  The <code>usb_init_controller</code> function is in <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fhccommon.inc">hccommon.inc</a> .  It allocates memory for a couple of structures <code>*hci_controller</code> / <code>usb_controller</code> , initializes both of them with zeros, initializes some <code>usb_controller</code> fields, among which should be noted the <code>HardwareFunc</code> , indicating <code>usb_hardware_func</code> .  Further, it also calls the controller-specific initialization <code>usb_hardware_func.Init</code> .  If no error occurred, then the last action of <code>usb_init_controller</code> registers the controller in the general list of <code>usb_controllers_list</code> and wakes up the USB stream so that it can update the information about the next wake-up time. <br><br>  The specific initialization <code>usb_hardware_func.Init</code> does the following: <br><ul><li>  sets up channel groups and relationships between them, including a binary tree of interrupt channels; </li><li>  installs a controller interrupt handler <code>*hci_irq</code> ; </li><li>  writes the correct values ‚Äã‚Äãto the registers of the host controller, including writing the physical address of the structure <code>*hci_controller</code> ; </li><li>  calculates the number of ports of the <code>usb_controller.NumPorts</code> root hub and provides power to all ports. </li></ul><br>  The binary tree of interrupt channels has the same structure on all controllers, I described it in the <a href="http://habrahabr.ru/company/kolibrios/blog/183184/">previous article</a> .  Communications between channels of other types depend on the controller. <br><br><h3>  Channel Link: UHCI </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8a7/026/2bc8a7026736afb097c4547871923509.png"><br>  UHCI is chronologically the first controller with the simplest hardware.  It has only one register-pointer <code>UhciBaseAddressReg</code> pointing to the table included in the <code>uhci_controller</code> .  Each frame iron loads the corresponding element of the table and starts following the links.  The latest in the chain of periodic transmissions is the list of interrupt channels processed by each frame.  From the last channel of the list, the link leads to the first channel in the list of control programs.  All channels of control transmissions and transmissions of data arrays are connected in a ring.  When the controller finishes processing all non-periodic channels, it returns to the beginning of the list of non-periodic channels;  With this scheme, a new non-periodic transmission begins to be processed immediately, without waiting for the next frame. <br><br>  The obvious advantage of this scheme is the simplicity of hardware, while fully complying with the requirements of the USB specification for processing priorities.  Minuses: with a large load, when the controller does not have time to process all transmissions to the end of the frame, the channels of the same type are unequal - those who are lucky enough to be at the top of the list have a significant advantage - and at low loads the controller is constantly busy reading from memory only for to make sure that there is no new job.  The developers of the following controllers took into account the disadvantages of UHCI. <br><br><h3>  Channel Link: OHCI </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/830/10c/126/83010c126c8520a9c10ba804a8b0cd57.png"><br>  OHCI has seven pointer registers, six of which are connected to channels.  One of the <code>OhciHCCAReg</code> registers points to the periodic channel table, similar to the other controllers (with corrections for isochronous transfers), the second <code>OhciPeriodCurrentEDReg</code> indicates the current periodic channel and is not so interesting that it is not even shown in the diagram. <br><br>  Control channels and channels of data arrays are collected in independent lists.  Each list has two pointers: a pointer to the top of the <code>Ohci{Control,Bulk}HeadEDReg</code> and a pointer to the current <code>Ohci{Control,Bulk}CurrentEDReg</code> .  The controller can move through the three lists independently of each other;  The priorities of the lists are in accordance with the requirements of USB.  Each frame controller runs through the list of periodic channels, but, unlike UHCI, it does not lose its position in the other lists, therefore, within the limits of one list all channels are equal;  this closes the first minus of the UHCI.  The OHCI registers also have two bits ‚Äúthere is a new transfer in the list‚Äù, one for the list of control channels, the second for the list of channels of data arrays, the software must set the corresponding bit when adding a new transfer.  When the controller starts to go through the list, it clears the bit.  When the controller reaches the end of the list, it looks at the bit;  if the bit is set, the controller goes to the top of the list, otherwise it stops processing the list.  This closes the second minus UHCI. <br><br><h3>  Links between channels: EHCI </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/21e/3f3/605/21e3f3605b12285501034387516dd47f.png"><br>  EHCI is limited to two pointer registers.  One of them, <code>EhciPeriodicListReg</code> , points to a table of periodic channels, similar to other controllers.  Another, <code>EhciAsyncListReg</code> , points to the current non-periodic channel.  All non-periodic channels are closed in a ring, now it is a prerequisite, unlike UHCI, where it is one of the possible implementations.  Walking along the periodic and non-periodic channels do not depend on each other, which makes all non-periodic channels equal.  The requirement for the privilege of control channels to the channels of the data arrays Intel decided to ignore here.  In order for the controller, in the absence of operation in non-periodic channels, not to be too keen on endless readings from memory, one of the channels in the ring is marked as the ‚Äúbeginning‚Äù of the ring;  when the controller meets the ‚Äúbeginning‚Äù of the ring a second time without detecting active gears, it stops processing the ring for a while. <br><br><h1>  Work with USB device </h1><br>  Picture from the USB specification, describing various states of the device and transitions between them: <br><img src="https://habrastorage.org/getpro/habr/post_images/02d/911/10f/02d91110f03ac4fdec54b0573ecb6ba7.png"><br><br><h3>  Device connection </h3><br>  During initialization, the OHCI and EHCI controllers are configured to generate an interrupt when the device is connected and disconnected.  Unfortunately, there is no such possibility in UHCI, therefore, if there is a UHCI controller, the USB stream periodically wakes up on its own and polls the controller ports, checking for changes in the connection status.  The polling interval is <code>UHCI_POLL_INTERVAL</code> timer ticks, which is 1 second for the current value. <br><br>  The connected USB device begins interacting with the host controller in the Powered state. <br><br>  Initialization of a new USB device starts with ... a pause of 100 milliseconds.  Since USB devices are connected dynamically, when connected, it is possible to bounce contacts and several consecutive connecting / disconnecting events.  With each new event on the same port, the time countdown is restarted.  When the Powered state lasts for 100 milliseconds in a row, the connection is considered stable and the code proceeds to the next stage of initialization <code>*hci_new_port</code> . <br><br>  For the reason about which I will tell a bit later, the next several stages of connection processing cannot be carried out for several devices in parallel.  Therefore, before the next stage, the new USB device may have to wait until the current device passes all these stages.  The end of the wait is marked with <code>*hci_new_port.reset</code> , which is part of the internal function <code>*hci_new_port</code> in case the wait turned out to be unnecessary, and simultaneously brought into the interface for higher levels of <code>usb_hardware_func.InitiateReset</code> . <br><br>  Further, the code <code>*hci_new_port.reset</code> controller to activate the reset signal for the port of the new device.  According to the specification, the reset should last at least 10 milliseconds.  OHCI counts the time on its own, at the end of the interval it turns off the reset signal and generates an interrupt, the handler of which signals the USB stream to proceed to the next stage.  In UHCI and EHCI, you need to count the time programmatically.  In order not to load the processor with an idle standby cycle, the USB stream, after turning on the reset signal, schedules a wake-up timer and falls asleep.  The timer in KolibriOS ticks with a frequency of 100 Hz, once every 10 milliseconds.  To ensure that you get a minimum of 10 milliseconds of reset, the code waits for two countdowns of the timer.  After the second tick of the timer, the code turns off the reset signal for the port of the new device, <code>*hci_port_reset_done</code> , and proceeds to the next stage. <br><br>  In USB2, the speed of the device is determined during the reset process.  I recall from the previous part that EHCI can work only with HighSpeed ‚Äã‚Äãdevices, and all devices operating at one of the USB1 speeds should be directed to the USB1 companion or hub.  From a programmatic point of view, after the end of the reset, EHCI either permits data transfer to the port or not.  If, after resetting, the port remains prohibited, it means that the connected device does not work at USB2 speed.  In this case, it remains only to inform the logic of the choice of the owner about the port forwarding to the companion;  after that, the companion will see the normal connection event and process it. <br><br>  After a reset, many devices are ready to be configured at higher levels.  But not all.  The specification requires a pause of at least 10 milliseconds after the reset, and, as <a href="http://board.kolibrios.org/viewtopic.php%3Fp%3D45968">tests</a> show, some devices really need this pause.  Similar to the previous step, the USB stream falls asleep by two timer counts, this time for all controllers, including OHCI. <br><br>  After a reset and a subsequent pause, the device transitions from the Powered state to the Default state ‚Äî one of two ‚Äúhalf-working‚Äù states, when the device is already ready to receive and send data for the zero end point, but not yet fully initialized.  In the Default state, the device responds to the zero address on the USB bus.  This is the reason why it is impossible to perform a reset for two devices in parallel: otherwise, two devices would turn out, each of which would have thought that the subsequent setting relates specifically to it. <br><br>  The zero end point of the device is ready for operation, it's time to open the channel.  The channel structure contains the characteristics of the channel itself ‚Äî for example, its type ‚Äî and the device characteristics: device speed, device address on the bus, pointer to <code>usb_controller</code> .  The code <code>*hci_port_init</code> , called at this stage, delegates the work of the function <code>*hci_new_device</code> , rendered to the API for hubs <code>usb_hardware_func.NewDevice</code> .  The latter prepares a pseudo-channel structure in which the characteristics of the device are correctly filled, and the values ‚Äã‚Äãof the characteristics of the channel do not matter.  With this, the host controller support code finishes independent actions and transfers control of the <code>usb_new_device</code> function <code>usb_new_device</code> the logic device level;  further until the device is turned off, the host controller support code only executes requests from higher levels. <br><br><h3>  Opening a channel and channeling </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/3de/76b/cd63de76b6be358c47cd78126a8b8853.png"><br>  From the controller's point of view, the transmission descriptor queue (one descriptor can describe the whole transmission, or some part, depending on the controller) is organized as a simply linked list, the physical address of the first descriptor is in the channel structure, the physical address of the next descriptor is in the previous descriptor.  When the controller finishes processing one descriptor, it updates the channel structure by writing the address of the next descriptor there.  It follows that with a running transmission queue, the host controller support code cannot update the address of the next descriptor itself to avoid a race condition with hardware.  To organize work, you need an extra empty handle at the end of the queue.  An empty handle is marked as inactive for the controller.  When the code wants to add a descriptor, it fills the current empty descriptor, selects the next empty descriptor, puts a reference to the new one in the old descriptor, activates the old descriptor with the last action - and all this without intersections on the record with the controller.  When the controller reaches the inactive handle, it stops processing the queue, leaving a link to the inactive handle in the channel structure. <br><br>  After realizing the need for an empty descriptor, opening a channel and placing programs in a queue is fairly straightforward.  When opening a <code>usb_hardware_func.InitPipe = *hci_init_pipe</code> you need: <ul><li>  copy device characteristics from an existing channel or pseudo-channel, </li><li>  fill the channel characteristics based on the transmitted data, </li><li>  register in the channel structure the physical address of an empty descriptor, </li><li>  initialize an empty handle as inactive, </li><li>  The last action is to insert the channel into the appropriate list. </li></ul>  For periodic channels, you need to select the desired list;  This is done by the scheduler, which I will discuss in the next article.  Adding a transfer to a queue is divided into filling descriptors for one transfer stage <code>usb_hardware_func.AllocTransfer = *hci_alloc_transfer</code> , which is called twice or three times for control transfers, and activating the transfer <code>usb_hardware_func.InsertTransfer = *hci_insert_transfer</code> .  <code>AllocTransfer</code>         ,          .  <code>InsertTransfer</code>    . <br><br>      IOC, Interrupt on completion.         IOC,   .   -        . <br>  OHCI  -   ,      (      IOC)  :         ,      .           <code>ohci_controller</code> ,    ,    .   OHCI  ¬´¬ª     ,     . <br>  UHCI  EHCI   ,    UHCI  EHCI      ,    ,   ,        . <br>          USB,  <code>*hci_process_finalized_td</code> .   ‚Äî    ,          ;       .   ‚Äî   ,       callback- ,    . <br><br><h3>    </h3><br>     .    ,          ,  ‚Äî    (     ¬´ ¬ª   ). ,  <code>usb_hardware_func.SetDeviceAddress</code> :           . ,  <code>usb_hardware_func.SetEndpointPacketSize</code> :           .  UHCI       ‚Äî  ,      ,     .           ,       .    <a href="http://board.kolibrios.org/viewtopic.php%3Fp%3D47274"></a> ,    .  EHCI      ,       ,         ,      .  ,     :       ,   ,              ,         ,    . <br><br>     OHCI  EHCI ,         ,       .     ,     .      OHCI               .  EHCI    <i>Interrupt on Async Advance Doorbell</i> :        ¬´      ,  ¬ª   .  ,  . <a href="http://board.kolibrios.org/viewtopic.php%3Fp%3D47667">  </a> ,       . <br><br><h3>   </h3><br>   :       ‚Äî   OHCI  EHCI,    UHCI ‚Äî     <code>usb_device_disconnected</code>    ,          .  ,         100       ,      . <br><br><h1>    </h1><br> <a href="http://habrahabr.ru/company/kolibrios/blog/181586/"> 1:  </a> <br> <a href="http://habrahabr.ru/company/kolibrios/blog/183184/"> 2:    -</a> <br>  3:   - <br> <a href="http://habrahabr.ru/company/kolibrios/blog/186276/"> 4:   </a> <br> <a href="http://habrahabr.ru/company/kolibrios/blog/200172/"> 5:   </a> <br> <a href="http://habrahabr.ru/company/kolibrios/blog/203918/"> 6:  </a> </div><p>Source: <a href="https://habr.com/ru/post/183284/">https://habr.com/ru/post/183284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183272/index.html">US Supreme Court bans patent for human genes</a></li>
<li><a href="../183274/index.html">Shuttle KD20 - Home Mini NAS</a></li>
<li><a href="../183276/index.html">Cyber ‚Äã‚ÄãSecurity. Weekly Review June 3 - June 9, 2013</a></li>
<li><a href="../183278/index.html">We treat delays: the inclusion of 30 traffic exchange points and 57 peering available for you!</a></li>
<li><a href="../183282/index.html">What is a university and what to expect from it</a></li>
<li><a href="../183286/index.html">Samsung introduced a new thin lens family of cameras NX - 10mm F3.5 Fisheye</a></li>
<li><a href="../183288/index.html">For this there is a map</a></li>
<li><a href="../183290/index.html">What kind of php framework are you using?</a></li>
<li><a href="../183292/index.html">Proxy Authentication Technology</a></li>
<li><a href="../183294/index.html">10 years to the first camera for shooting Mars in high resolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>