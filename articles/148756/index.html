<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the Mediawiki parser works</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article The MediaWiki parser, uncovered . 



 2009 , , -,  , -, ,  Mediawiki, .  

 The Mediawiki parser is a fundamental part of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the Mediawiki parser works</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d0b/db8/e74/d0bdb8e746bcdb49b3064407684b8c15.jpg"><br>  Translation of the article <a href="http://musialek.org/%3Fp%3D94">The MediaWiki parser, uncovered</a> . <br><br><pre><code class="hljs 1c">   <span class="hljs-number"><span class="hljs-number">2009</span></span>   , , -,       <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ,  -,      ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> Mediawiki,      .</code> </pre> <br><br>  <a href="http://svn.wikimedia.org/doc/classParser.html">The Mediawiki parser</a> is a fundamental part of the <a href="http://www.mediawiki.org/wiki/Download">Mediawiki</a> engine code.  Without it, you would not be able to insert various tags into your Wikipedia articles: sections, links, or pictures.  You could not even see or quickly change the layout of other articles.  The wiki markup is flexible enough to make it equally easy for beginners and HTML experts to write articles.  Because of this, the parser code is somewhat complicated, and over the years it went through many attempts to improve it.  However, even today it still works fairly quickly for Wikipedia, one of the largest websites in the world.  Let's take a look at the insides of this valuable (but slightly abstruse) piece of code. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Short story </h5><br>  Disclaimer  This story, as I understand it, is mainly drawn from discussions in which I participated for many years in the Wikimedia mailing list, as well as from discussions at the Wikimania 2006 conference. Until 2008, the Mediawiki parser suffered greatly from the extraordinary complexity to fit in one pass (for speed), but also due to the fact that new rules were added to the existing code all the time.  Over time, the parser code became a real spaghetti code, which was very difficult to debug, and even harder to improve.  Rewrite it was almost impossible, because  It belongs to the engine core.  Millions of Wikipedia pages could fly in one moment if an error had occurred in some place of the new code. <br><br><h5>  What to do </h5><br>  There has been a lot of discussion about how to solve this problem.  Someone suggested rewriting the parser in C, which would make the parser faster, which would allow the parser to parse the text not in a single pass, but in a cycle - this was required by an increasing number of templates and sub patterns, which were included on Wikipedia pages.  There were also proposals to change the syntax of Mediawiki so as to eliminate uncertainties when parsing certain constructs (such as bold or italic, bold or italic, for example, or the relationship between triple and double curly braces in templates). <br>  In the end, it was decided, and I consider it a brilliant idea, to leave the parser for PHP (because rewriting it in C would lead to the division of Mediawiki developers into 2 classes) and the division of parsing into two stages, <b>preprocessing</b> and <b>parsing</b> .  The work of the preprocessor was to present the wikitext as an XML DOM.  At the actual parsing stage, the DOM tree was processed in a loop of as many iterations as was required (for template substitution, for example) in order to get valid static HTML.  Looping through the DOM is incredibly fast, and besides this is very natural from the XHTML point of view.  And in PHP, such processing is also very well supported. <br><br><h5>  Preprocessor </h5><br>  In the Mediawiki source folder you will find two versions of the preprocessor, the version of Hash and DOM, they can be found at the addresses /includes/parser/Preprocessor_Hash.php and /includes/parser/Preprocessor_DOM.php, respectively. <br>  We will focus on the DOM version, since it is almost identical to the Hash version, but it works faster because it uses PHP XML support, an optional component of PHP.  The most important function in the preprocessor class is called <b>preprocessToObj ()</b> .  Inside the Preprocessor_DOM.php file are several other important classes that the preprocessor uses: PPDStack, PPDStackElement, PPDPart, PPFrame_DOM and PPNode_DOM. <br><br><h5>  Preprocessor does less than you think. </h5><br>  So what is Mediawiki XML like?  Here is an example of how the wikitext "{{MyMash Pattern}} this [[test]]" looks like in an XML representation: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>mytemplate<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> this is a [[test]] <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Note  That the internal link is not processed at all.  The preprocessor code avoids the work that can be done at a later stage (and it has grounds for it), so the only real work of the preprocessor is to create XML elements for templates and a couple of other things.  These things, i.e.  base nodes (full list): template, tplarg, comment, ext, ignore, h. <br><br>  If you have ever worked with wikitext, then you already know which markup corresponds to these basic nodes.  Just in case, here it is: <br><br><ul><li>  <b>template</b> = double braces {{...}} </li><li>  <b>tplarg</b> = triple braces {{{...}}} </li><li>  <b>comment</b> = HTML-comment of any type </li><li>  <b>ext</b> = All that needs to be dealt with in a separate extension </li><li>  <b>ignore</b> = noinclude tags, as well as includeonly tags and content inside them </li><li>  <b>h</b> = sections </li></ul><br><br>  That's all.  Everything else is ignored and returned as a source wikitext to the parser. <br><br><h5>  How the preprocessor works </h5><br>  There is nothing special, but it is worth saying a few words.  In order to get the XML representation we need, the preprocessor passes the wikitext in the loop as many times as the characters contain this text.  There is no other way for correct processing of recursive templates that can be represented in the text as you like thanks to the syntax.  So, if a Wikipedia article contains 40,000 characters, then it is likely that the cycle will consist of 40,000 iterations.  Now I understand why speed is so important for the parser. <br><br><h5>  Parsing itself </h5><br>  Skip the rest of the preprocessor details and the extra classes that are used to generate the XML code.  Let's turn our attention to the parser itself and take a look at the typical case of the parser when clicking on a Wikipedia article.  Here, however, we should not forget that the wiki pages are cached by any possible means, so it is unlikely that each time you click on the page you will cause the parser to parse the page. <br><br>  Here is a typical parser call tree for the current version of the page, starting from the Article object. <br><table><tbody><tr><td>  01. Article-&gt; view </td></tr><tr><td>  02. --Article-&gt; getContent </td></tr><tr><td>  03. ---- Article-&gt; loadContent </td></tr><tr><td>  04. ------ Article-&gt; fetchContent-&gt; returns the wikitext extracted from the database </td></tr><tr><td>  05. --Article-&gt; outputWikiText-&gt; prepare for the parse </td></tr><tr><td>  06. ---- Parser-&gt; parse </td></tr><tr><td>  07. ------ Parser-&gt; internalParse </td></tr><tr><td>  08. -------- Parser-&gt; replaceVariables </td></tr><tr><td>  09. ---------- Parser-&gt; preprocessToDom </td></tr><tr><td>  10. ------------ Preprocessor-&gt; preprocessToObj </td></tr><tr><td>  11. ---------- Frame-&gt; expand </td></tr><tr><td>  12. -------- Parser-&gt; doTableStuff </td></tr><tr><td>  13. -------- Parser-&gt; replaceInternalLinks </td></tr><tr><td>  14. -------- Parser-&gt; replaceExternalLinks </td></tr><tr><td>  15. ------ Parser-&gt; doBlockLevels </td></tr><tr><td>  16. ------ Parser-&gt; replaceLinkHolders </td></tr></tbody></table><br><br>  Let's take a look at these features.  Again, these are the <u>main</u> functions, not all that are called in this example.  Items 2-4 retrieve and return wikitext articles from the database.  This text is passed to the outputWikiText object, which prepares it for passing to the Parser :: parse () function. <br>  Further, it becomes interesting again at points 8-11.  Inside the replaceVariables function, the text is transformed into a DOM representation; in a loop for each character of the article, the starting and ending labels of the templates, sub patterns and other nodes mentioned above are searched. <br><br>  Point number 11 is an interesting step that I‚Äôll skip right now because it requires some knowledge of other classes from the Preprocessor_DOM.php file (mentioned above).  Expand is a very important function, does a bunch of things (among which is its recursive call), but suffice it to say that it does the job of actually extracting text from DOM nodes (we remember that templates can be nested - so you don't always get the full text from each included article) and into a valid HTML text in which all wiki tags are revealed, with the exception of three types: tables, links and lists.  So, in the example above, "{{MyShablon}} this [[test]]" expand () will return the text of the form: <br><br>  ‚ÄúI included [[text]] from my template, this is [[test]]‚Äù <br><br>  As you can see from this simple example, at this stage everything is sorted out, with the exception of tables, links and lists. <br><br><h5>  Links are a special case. </h5><br>  Yes, the links have their own section.  And not only because they are perhaps the most significant part of what makes wiki its very (besides the possibility of editing).  But also because they understand a very special way from the rest of the markup in the parser code.  What makes them special is that they are processed in two stages: at the first stage, each link is assigned a unique id, and at the second stage its valid HTML is inserted in the place of the link holder.  In our example, this is the result after the first stage: <br><br>  ‚ÄúI have included &lt;! - LINK 0 -&gt; from my template, this is &lt;! - LINK 1 -&gt;‚Äù. <br><br>  As you can imagine, there is also an array that matches the text of the links with their ID of the form LINK #ID, this is a Parser class variable named mLinkHolders.  In addition to matching, this variable also stores Title objects for each link. <br><br>  So at the second stage of link analysis we use this array for simple search and replace.  That's it!  We send the finished text out the door! <br><br><h5>  Next stage </h5><br>  In the next post, I will focus more on the preprocessor and the details of the classes from the Preprocessor__DOM.php file, namely how they are used to build the original DOM XML tree.  I will also tell you about how I used them to cache infoboxes in the Unbox extension. </div><p>Source: <a href="https://habr.com/ru/post/148756/">https://habr.com/ru/post/148756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148749/index.html">Marissa Mayer started by making Yahoo free</a></li>
<li><a href="../148750/index.html">10 of the most original and useful gadgets according to OViVO</a></li>
<li><a href="../148753/index.html">The service "Hello" from Beeline or algorithm invisible debiting money from your account</a></li>
<li><a href="../148754/index.html">Android streaming video</a></li>
<li><a href="../148755/index.html">Blackberry10 development: all videos from Blackberry 10 Jam Moscow!</a></li>
<li><a href="../148757/index.html">ReSharper 7 supports Visual Studio 2012 and simplifies the development of Metro applications.</a></li>
<li><a href="../148758/index.html">Display of dependent data, for example, using two drop-down lists, using knockout</a></li>
<li><a href="../148759/index.html">Satellite monitoring. Part 1</a></li>
<li><a href="../148761/index.html">Yii 1.1.11</a></li>
<li><a href="../148762/index.html">Conclusions on SQL injection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>