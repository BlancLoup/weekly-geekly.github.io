<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing our SynchronizationContext</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This story began a long time ago when I first tried to work with a UI not from a UI thread. And when I started to catch various ‚Äúglitches‚Äù, I realized...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing our SynchronizationContext</h1><div class="post__text post__text-html js-mediator-article">  This story began a long time ago when I first tried to work with a UI not from a UI thread.  And when I started to catch various ‚Äúglitches‚Äù, I realized that this should be done carefully.  Later, I ran into this in the world of dots and it was at that moment that I first became acquainted with SynchronizationContext.  But then, after reading about the device of this object, I considered that this knowledge was enough for me.  You can do this, for example, here: <a href="http://habrahabr.ru/post/232169/">SynchronizationContext - when MSDN fails</a> . <br><br>  I remembered about SynchronizationContext only with the output of c # 5 and its async / await, since  This mechanism interacts with this very synchronization context.  This is done so that after an asynchronous operation, the code can be executed in the thread calling the asynchronous operation, which is very convenient when working with the UI.  But by running this small code in the UI thread and any other: <br><br><pre><code class="cs hljs">Debug.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; Debug.WriteLine(Thread.CurrentThread.ManagedThreadId)); Debug.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre> <br>  We will see that the code is returned to the original stream only when it is launched in the UI stream.  The thing is that the synchronization context is specified only in the UI stream (except for wcf, etc.).  The thought immediately comes to mind, you just need to set the synchronization context to the desired stream.  But here we have a problem; the standard implementation of SynchronizationContext does not give us the necessary capabilities.  It allows you to continue executing code in the current thread or in the thread from the pool.  After I did not find an implementation that you can just copy, run and see the desired result, I decided to try to implement my own and imagine how it could look like in practice.  This will be discussed below. <br><a name="habracut"></a><br>  To execute the code, SynchronizationContext provides two virtual methods, Send (synchronous execution) and Post (asynchronous).  Therefore, we inherit from SynchronizationContext and override the necessary methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">CustomSynchronizationContext</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomSynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span>, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AutoResetEvent _eventReset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Queue&lt;KeyValuePair&lt;SendOrPostCallback, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; _workItems; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Thread _thread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomSynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _eventReset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _workItems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;KeyValuePair&lt;SendOrPostCallback, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;(); _thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(DoWork); _thread.Start(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext.SetSynchronizationContext(obj <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SynchronizationContext); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_workItems.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = _workItems.Dequeue(); item.Key(item.Value); } _eventReset.Reset(); _eventReset.WaitOne(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _workItems.Enqueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;SendOrPostCallback, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(d, state)); _eventReset.Set(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _eventReset.Dispose(); _thread.Abort(); } }</code> </pre><br></div></div><br>  We start. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomSynchronizationContext(); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); syncContext.Post(o =&gt; Console.WriteLine(Thread.CurrentThread.ManagedThreadId), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }</code> </pre><br>  And we expect to see different streams.  What's going on here?  First, for convenience, we create and assign a stream inside the context, not a context to the stream.  So we will be sure that no one but us can influence this flow.  Secondly, we start a queue in which we will store delegates for execution in the created thread.  Thirdly, we ‚Äútap‚Äù the AutoResetEvent so that the thread does not terminate and not go in cycles.  Well, IDisposable.  Note that if you delete the context, there will also be an attempt to eliminate the stream.  Those.  such code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomSynchronizationContext()) { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); syncContext.Post(o =&gt; Console.WriteLine(Thread.CurrentThread.ManagedThreadId), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }</code> </pre><br>  most likely will display information only about the original stream.  Perhaps this is not what I would like, but for a demo, I think it will do.  In addition, it is easy to fix. <br><br>  What about exception handling?  Check it out. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomSynchronizationContext(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { syncContext.Post(o =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"TestException"</span></span>); }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Console.WriteLine(ex.Message); } }</code> </pre><br>  It is expected to fall in our ‚Äúspecial‚Äù stream.  It's time to remember that we also have the Send method, which is responsible for synchronous execution.  This should allow you to wait for the delegate to complete and get an exception.  Let's try. <br><br><div class="spoiler">  <b class="spoiler_title">CustomSynchronizationContext (final demo)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomSynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span>, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AutoResetEvent _workerResetEvent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;WorkItem&gt; _workItems; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Thread _thread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomSynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _workerResetEvent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _workItems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;WorkItem&gt;(); _thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(DoWork); _thread.Start(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext.SetSynchronizationContext(obj <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SynchronizationContext); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { WorkItem workItem; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_workItems.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> workItem)) workItem.Execute(); <span class="hljs-comment"><span class="hljs-comment">//Note: race condition here _workerResetEvent.Reset(); _workerResetEvent.WaitOne(); } } public override void Send(SendOrPostCallback d, object state) { if (Thread.CurrentThread == _thread) d(state); else { using (var resetEvent = new AutoResetEvent(false)) { var wiExecutionInfo = new WorkItemExecutionInfo(); _workItems.Enqueue(new SynchronousWorkItem(d, state, resetEvent, ref wiExecutionInfo)); _workerResetEvent.Set(); resetEvent.WaitOne(); if (wiExecutionInfo.HasException) throw wiExecutionInfo.Exception; } } } public override void Post(SendOrPostCallback d, object state) { _workItems.Enqueue(new AsynchronousWorkItem(d, state)); _workerResetEvent.Set(); } public void Dispose() { _workerResetEvent.Dispose(); _thread.Abort(); } private class WorkItemExecutionInfo { public bool HasException =&gt; Exception != null; public Exception Exception { get; set; } } private abstract class WorkItem { protected readonly SendOrPostCallback SendOrPostCallback; protected readonly object State; protected WorkItem(SendOrPostCallback sendOrPostCallback, object state) { SendOrPostCallback = sendOrPostCallback; State = state; } public abstract void Execute(); } private class SynchronousWorkItem : WorkItem { private readonly AutoResetEvent _syncObject; private readonly WorkItemExecutionInfo _workItemExecutionInfo; public SynchronousWorkItem(SendOrPostCallback sendOrPostCallback, object state, AutoResetEvent resetEvent, ref WorkItemExecutionInfo workItemExecutionInfo) : base(sendOrPostCallback, state) { if (workItemExecutionInfo == null) throw new NullReferenceException(nameof(workItemExecutionInfo)); _syncObject = resetEvent; _workItemExecutionInfo = workItemExecutionInfo; } public override void Execute() { try { SendOrPostCallback(State); } catch (Exception ex) { _workItemExecutionInfo.Exception = ex; } _syncObject.Set(); } } private class AsynchronousWorkItem : WorkItem { public AsynchronousWorkItem(SendOrPostCallback sendOrPostCallback, object state) : base(sendOrPostCallback, state) { } public override void Execute() { SendOrPostCallback(State); } } }</span></span></code> </pre><br></div></div><br>  Here, for convenience, we introduce the WorkItem class, which will execute the code (delegate) in the way we need.  From it we inherit two more SynchronousWorkItem and AsynchronousWorkItem, by names it is clear what is the difference between them.  In implementations, the only difference is that the synchronous version implements the wait (AutoResetEvent) and the absorption of the exception, which will then be thrown in the original stream.  Now KeyValuePair &lt;SendOrPostCallback, object&gt; can be changed to WorkItem, well, we change the simple queue to competitive.  Also, in the Send method, we add a check of the current thread and if it suddenly turns out to be ‚Äúour‚Äù, then simply run the delegate here. <br><br>  Check again. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomSynchronizationContext(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { syncContext.Send(o =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"TestException"</span></span>); }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Console.WriteLine(ex.Message); } }</code> </pre><br>  The exception has now been successfully processed.  Well, it's time to run the very first code example, which was mentioned in the article, on a stream with a newly created synchronization context. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomSynchronizationContext(); syncContext.Post(TestAsyncMethod, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; Console.WriteLine(Thread.CurrentThread.ManagedThreadId)); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); }</code> </pre><br>  My conclusion: <br><br>  9 <br>  ten <br>  9 </div><p>Source: <a href="https://habr.com/ru/post/269985/">https://habr.com/ru/post/269985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269969/index.html">AudioCodes SBC performance</a></li>
<li><a href="../269973/index.html">A series of webinars on working with data</a></li>
<li><a href="../269975/index.html">Microsoft events for IT professionals in November</a></li>
<li><a href="../269981/index.html">PG as Perl evolution for mathematicians at WeBWorK</a></li>
<li><a href="../269983/index.html">A simple generator of the DGML file of the state machine transition graph</a></li>
<li><a href="../269987/index.html">Virtual network interface</a></li>
<li><a href="../269989/index.html">Solving the problem of installing GitHub for Windows with Amazon Web Services S3</a></li>
<li><a href="../269991/index.html">Practical application of Fourier transform for signal analysis. Introduction for beginners</a></li>
<li><a href="../269993/index.html">JSON for fans of braces</a></li>
<li><a href="../269995/index.html">Cloud for development companies: BadgeKeeper Achievement System Designer - Developer Service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>