<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenSceneGraph: Group nodes, transformation nodes and switch nodes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 When drawing a point, line, or complex polygon in a three-dimensional world, the final result will ultimately be displayed on a flat, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenSceneGraph: Group nodes, transformation nodes and switch nodes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Introduction </h1><br>  When drawing a point, line, or complex polygon in a three-dimensional world, the final result will ultimately be displayed on a flat, two-dimensional screen.  Accordingly, three-dimensional objects pass a certain transformation path, turning into a set of pixels output to a two-dimensional window. <br><br>  The development of software tools that implement three-dimensional graphics has come, regardless of which one you choose, approximately to the same concept of both mathematical and algorithmic descriptions of the above transformations.  Ideologically, both ‚Äúclean‚Äù OpenGL-type graphics APIs and cool game engines like Unity and Unreal use similar mechanisms for describing the transformation of a three-dimensional scene.  OpenSceneGraph is no exception. <br><br>  In this article we will review the mechanisms for grouping and transforming three-dimensional objects in OSG. <br><a name="habracut"></a><br><h1>  1. Model Matrix, View Matrix and Projection Matrix </h1><br>  Three basic matrices are involved in the mathematical transformation of coordinates, carrying out the transformation between different coordinate systems.  Often, in terms of OpenGL, they are called <em>the model</em> <em>matrix, the view matrix,</em> and <em>the projection matrix</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The model matrix is ‚Äã‚Äãused to describe the location of the object in the 3D world.  It converts vertices from the <em>object</em> 's <em>local coordinate system</em> to the <em>world coordinate system</em> .  By the way, all the coordinate systems in OSG are <em>right-handed</em> . <br><br>  The next step is the transformation of world coordinates into a view space, performed using a view matrix.  Suppose we have a camera located at the origin of the world coordinate system.  The inverse matrix of the camera transformation matrix is ‚Äã‚Äãactually used as a view matrix.  In the right-of-screw coordinate system, OpenGL, by default, always determines the camera located at the point (0, 0, 0) of the global coordinate system and is directed along the negative direction of the Z axis. <br><br>  I note that OpenGL does not separate the concepts of the model matrix and the view matrix.  However, there is determined a model-view matrix that performs the transformation of the local coordinates of the object into the coordinates of the species space.  This matrix, in fact, is the product of the matrix of the model and the matrix of the form.  Thus, the transformation of a vertex V from local coordinates into a view space can be conventionally written as a product <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  The next important task is to determine how 3D objects will be projected onto the screen plane and calculate the so-called <em>clipping pyramid</em> - the area of ‚Äã‚Äãspace containing the objects to be displayed on the screen.  The projection matrix is ‚Äã‚Äãused to define the clipping pyramid defined in world space by six planes: left, right, bottom, top, near and far.  OpenGL provides the gluPerapective () function, which allows you to specify a clipping pyramid and a way to project a three-dimensional world onto a plane. <br><br>  The coordinate system obtained after the above-described transformations is called the <em>normalized coordinate system of the device</em> , has on each axis a range of coordinate changes from -1 to 1 and is a left-handed one.  And, as a last step, the received data is projected to the port of display (viewport) of the window, defined by the rectangle of the client area of ‚Äã‚Äãthe window.  After that, the 3D world appears on our 2D screen.  The final value of the screen coordinates of the vertices Vs can be expressed by the following transformation <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  or <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  where MVPW is the equivalent transformation matrix, equal to the product of three matrices: model-view matrix, projection matrix and window matrix. <br><br>  Vs in this situation is a three-dimensional vector that defines the position of a 2D pixel with a depth value.  By reversing the coordinate transformation operation we get a line in three-dimensional space.  Therefore, a 2D point can be viewed as two points ‚Äî one on the near point (Zs = 0), the other on the far clipping plane (Zs = 1).  The coordinates of these points in three-dimensional space <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  where invMVPW is the inverse of MVPW. <br><br>  In all the examples considered so far, we created one single three-dimensional object in the scenes.  In these examples, the local coordinates of the object always coincided with the global global coordinates.  Now it's time to talk about the tools that allow placing in the scene a lot of objects and changing their position in space. <br><br><h1>  2. Group nodes </h1><br>  The osg :: Group class is the so-called <em>group node</em> of the scene graph in OSG.  It can have any number of child nodes, including geometry node nodes or other group nodes.  These are the most frequently used nodes with wide functionality. <br><br>  The class osg :: Group is derived from the class osg :: Node, and is accordingly inherited from the class osg :: Referenced.  osg :: Group contains a list of child nodes, where each child node is controlled by a smart pointer.  This ensures there are no memory leaks when cascading a branch of a scene tree.  This class provides the developer with a number of public methods. <br><ol><li>  addChild () - appends a node to the end of the list of child nodes.  On the other hand, there is the insertChild () method, which places the child node at a specific position in the list, which is specified by an integer index or pointer to the node passed as a parameter. <br></li><li>  removeChild () and removeChildren () - remove a single node or group of nodes. <br></li><li>  getChild () - getting a pointer to a node by its index in the list <br></li><li>  getNumChildren () - getting the number of child nodes attached to this group. <br></li></ol><br><h2>  Parent node management </h2><br>  As we already know, the osg :: Group class manages groups of its child objects, among which there can be instances of osg :: Geode that control the geometry of scene objects.  Both of these classes have an interface for managing parent nodes. <br><br>  OSG allows scene nodes to have several parent nodes (we'll talk about this sometime later).  In the meantime, we will consider the methods defined in osg :: Node, used for manipulating the parent nodes: <br><ol><li>  getParent () - returns an osg :: Group pointer containing a list of parent nodes. <br></li><li>  getNumParants () - returns the number of parent nodes. <br></li><li>  getParentalNodePath () - returns all possible paths to the root node of the scene from the current node.  It returns a list of variables of the type osg :: NodePath. <br></li></ol><br>  osg :: NodePath is a std :: vector of pointers to scene nodes. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  For example, for the scene shown in the figure, the following code <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  returns the nodes Root, Child1, Child2. <br><br>  You should not use memory management mechanisms to refer to parent nodes.  When you delete the parent node, all the child nodes are automatically deleted, which may cause the application to crash. <br><br><h1>  3. Adding multiple models to the scene tree </h1><br>  We illustrate the mechanism for using groups with the following example. <br><br><div class="spoiler">  <b class="spoiler_title">The full text of the example group</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Fundamentally, the example differs from all previous ones in that we load two three-dimensional models, and to add them to the scene we create a group root node and add our model cards to it as child nodes. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  As a result, we get a scene consisting of two models - an airplane and a funny mirror cow.  By the way, a mirror cow will not be a mirror, unless you copy its texture from OpenSceneGraph-Data / Images / reflect.rgb and the data / Images directory of our project. <br><br>  The osg :: Group class can accept as node types of nodes, including nodes of its type.  In contrast, the osg :: Geode class does not contain any child nodes at all - it is an end node containing the geometry of the scene object.  This fact is useful when determining whether a node is a node of the osg :: Group type or another type derived from osg :: Node.  Consider a small example. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  The value returned by the osgDB :: readNodeFile () function is always of type osg :: Node *, but it can be converted to its successor osg :: Group *.  If the node node of the Cessna model is a group node, the transformation will be successful, otherwise the conversion will return NULL. <br><br>  You can also do this trick that works on most compilers. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  In performance-critical areas of the code, it is better to use special conversion methods. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. Transformation nodes </h1><br>  Nodes osg :: Group can not do any transformations, except the possibility of moving to their child nodes.  OSG provides the osg :: Transform class for spatial movement of geometry.  This class is an inheritor of the osg :: Group class, but it is also abstract - in practice, its heirs are used instead, which implement various spatial transformations of geometry.  When traversing a scene graph, the osg :: Transform node adds its transformation to the current OpenGL transformation matrix.  This is equivalent to multiplying the OpenGL transformation matrices by the glMultMatrix () command. <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  This example of a scene graph can be translated into the following OpenGL code. <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  We can say that the position of Geode1 is set in the coordinate system Transform1, and the position of Geode2 is set in the coordinate system Transform2, shifted relative to Transform1.  At the same time, in OSG, you can enable positioning in absolute coordinates, which will lead to object behavior equivalent to the result of the glGlobalMatrix () OpenGL command. <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  You can switch back to positioning mode relative coordinates <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. The concept of the coordinate transformation matrix </h1><br>  The osg :: Matrix type is an OSG base type not managed by smart pointers.  It provides an interface to 4x4 matrix operations describing coordinate transformations, such as moving, rotating, scaling, and calculating projections.  The matrix can be set explicitly. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  The osg :: Matrix class provides the following public methods: <br><br><ol><li>  postMult () and operator * () is the right multiplication of the current matrix by the matrix or vector, passed as a parameter.  The preMult () method performs multiplication on the left. <br></li><li>  makeTranslate (), makeRotate () and makeScale () - reset the current matrix and create a 4x4 matrix describing the movement, rotation and scaling.  their static versions translate (), rotate () and scale () can be used to create a matrix object with specific parameters. <br></li><li>  invert () - calculation of the inverse current matrix.  Its static version of inverse () takes a matrix as a parameter and returns a new matrix, the inverse of the given one. <br></li></ol><br>  OSG understands matrices as row matrices, and vectors as rows, therefore, to apply a matrix transformation to a vector, <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  The order of matrix operations is easy to understand by looking at how matrices are multiplied to produce an equivalent transformation. <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  The developer must read the transformation process from left to right.  That is, in the described code fragment, the vector is first scaled, and then it is moved. <br><br>  osg :: Matrixf contains float elements. <br><br><h1>  6. Application class osg :: MatrixTransform </h1><br>  Let's apply the received theoretical knowledge in practice, having loaded two models of the plane in different points of a scene. <br><br><div class="spoiler">  <b class="spoiler_title">Full transform example text</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  The example is actually quite trivial.  We load model of the plane from a file <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Create a transformation node <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Set the transformation matrix as a transformation matrix along the X axis 25 units to the left. <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Set the transformation node for our model as a child node <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  We act in the same way with the second transformation, but as the matrix we set the movement to the right by 25 units <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Create a root node and set the transform1 and transform2 nodes as child nodes for it. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Create a viewer and pass root node to it as scene data. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  Running the program gives such a picture <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  The structure of the scene graph in this example is <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  We should not be confused by the fact that the transformation nodes (Child 1.1 and Child 1.2) refer to the same child object of the airplane model (Child 2).  This is a regular OSG mechanism, when one child node of a scene graph can have several parent nodes.  Thus, it is not necessary for us to keep in memory two copies of the model in order to get two identical planes in the scene.  Such a mechanism makes it very efficient to allocate memory in the application.  The model will not be removed from memory as long as it is referred to as a child, at least one node. <br><br>  By its action, the osg :: MatrixTransform class is equivalent to the OpenGL commands glMultMatrix () and glLoadMatrix (), it implements all types of spatial transformations, but is difficult to use because of the need to calculate the transformation matrix. <br><br>  The osg :: PositionAttitudeTransform class works like OpenGL functions glTranslate (), glScale (), glRotate ().  It provides public methods for converting child nodes: <br><br><ol><li>  setPosition () - move the node to a given point in space, specified by the osg :: Vec3 parameter <br></li><li>  setScale () - scale the object along the axes.  The scaling factors for the respective axes are set by the parameter of the type osg :: Vec3 <br></li><li>  setAttitude () - set the spatial orientation of the object.  As a parameter, it accepts the quaternion of the transformation of rotation osg :: Quat, the constructor of which has several overloads, allowing to set the quaternion both directly (componentwise) and, for example, through Euler angles osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg :: Y_AXIS, zAngle, osg :: Z_AXIS) (angles are given in radians!) <br></li></ol><br><br><h1>  7. Switch nodes </h1><br>  Consider another class - osg :: Switch, which allows you to display or skip the rendering of a scene node, depending on some logical condition.  It is an inheritor of the osg :: Group class and attaches a logical value to each of its child nodes.  It has several useful public methods: <br><ol><li>  Overloaded addChild (), as the second parameter accepts a logical key that indicates whether or not to display this node. <br></li><li>  setValue () - setting the visibility / invisibility key.  Accepts the index of the child node we are interested in and the desired key value.  Accordingly, getValue () allows you to get the current key value by the index of the node of interest. <br></li><li>  setNewChildDefaultValue () - sets the default value for the visibility key of all new objects added as children. <br></li></ol><br>  Consider the use of this class by example. <br><br><div class="spoiler">  <b class="spoiler_title">The full text of the example switch</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  An example is trivial - we load two models: the ordinary Cessna and the Cessna with the effect of a burning engine <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  However, we create osg :: Switch as the root node, which allows us, when adding models to it as child nodes, to set a visibility key for each of them. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  That is, model1 will not be rendered, and model2 will be what we will observe by running the program <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  Swapping the key values ‚Äã‚Äãwill see the opposite picture. <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Having cocked both keys, we will see two models at the same time. <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  You can turn on the visibility and invisibility of the node that is a child of osg :: Switch right on the go, using the setValue () method <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Conclusion </h1><br>  In this lesson we covered all the main classes of intermediate nodes used in OpenSceeneGraph.  Thus, we have laid another basic brick in the foundation of knowledge about the device of this undoubtedly interesting graphic engine.  The examples considered in the article, as before, <a href="https://github.com/maisvendoo/OSG-lessons">are available in my repository on Github</a> . <br><br>  <i><a href="https://habr.com/ru/post/430348/">To be continued...</a></i> </div><p>Source: <a href="https://habr.com/ru/post/430242/">https://habr.com/ru/post/430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430230/index.html">How to keep your place in the maturing startup</a></li>
<li><a href="../430232/index.html">Generation of Close call in games: ‚ÄúJust a hair from defeat‚Äù or ‚ÄúA little bit won‚Äù</a></li>
<li><a href="../430236/index.html">NASA Announces New Moon Flight</a></li>
<li><a href="../430238/index.html">Another dsl on Kotlin or how I printed a PDF from react</a></li>
<li><a href="../430240/index.html">Bitcoin Pseudo Random Number Generator Vulnerability</a></li>
<li><a href="../430244/index.html">SpaceX received permission to deploy a satellite network of 11,943 satellites</a></li>
<li><a href="../430246/index.html">Moving to Austrian socialism</a></li>
<li><a href="../430252/index.html">The enemy is inside: how did I get caught on insider redtiming</a></li>
<li><a href="../430256/index.html">Application Configuration - Spring Configuration Metadata</a></li>
<li><a href="../430258/index.html">No landfills for MSW - put a verminimine under the window</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>