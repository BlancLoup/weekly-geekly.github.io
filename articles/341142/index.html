<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We look for typo names in PostgreSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with the fact that I needed to develop a search for patients for a single internal medical system. The logic of the work was that if we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We look for typo names in PostgreSQL</h1><div class="post__text post__text-html js-mediator-article">  It all started with the fact that I needed to develop a search for patients for a single internal medical system.  The logic of the work was that if we did not find a person in the system, then it must be created (and duplicate patients cannot be produced).  In this regard, one of the subtasks was the implementation of the search for people, taking into account typos in their names.  Well, since I love PostgreSQL (and when you have a hammer in your hands, everything looks like nails), it‚Äôs not hard to guess what I decided to do with a typo search ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/rm/sq/sjrmsqmnovu_xaq--unhed2a3qs.jpeg"></div><br><a name="habracut"></a><br>  Usually, a similar problem is solved in two ways: using a fuzzy search or using phonetic algorithms.  Being a lazy and holy man who believed that everything had been <s>stolen</s> long before was invented before us, I turned to the PostgreSQL documentation.  There are currently two modules in PostgreSQL that can help you search with typos: <a href="https://postgrespro.ru/docs/postgresql/10/pgtrgm">pg_trgm</a> and <a href="https://postgrespro.ru/docs/postgresql/10/fuzzystrmatch">fuzzystrmatch</a> . <br><br><ol><li>  pg_trgm works with trigrams, can search by substring and fuzzy search.  As indexes it works with <a href="https://postgrespro.ru/docs/postgresql/10/gist">gist</a> and <a href="https://postgrespro.ru/docs/postgresql/10/gin">gin</a> . <br></li><li>  fuzzystrmatch can read the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein distance</a> between words and three phonetic algorithms: <a href="https://ru.wikipedia.org/wiki/Soundex">Soundex</a> , <a href="https://ru.wikipedia.org/wiki/Metaphone">Metaphone</a> and <a href="https://en.wikipedia.org/wiki/Metaphone">Double Metaphone</a> .  The pitfalls are, firstly, that the Levenshtein function in this module does not allow creating an index for an arbitrary search query.  Secondly, all phonetic algorithms are implemented for the Latin alphabet. <br></li></ol><br>  In this regard, I began to look for the solution of the problem where it is lighter, namely with the pg_trgm module. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Trigrams </h3><br>  For simplicity of the model, consider the info table with the patient ID, his last name, first name and patronymic.  Since we want gist / gin indexes, first we need to know an important but unpleasant moment: one gist / gin index is one column of the table.  It cannot be created, for example, by concatenating multiple columns.  Therefore, below the cat will be created: <br><br><ul><li>  pg_trgm extension <br></li><li>  patient table storing full name in the form of jsonb (with checks for the existence and filling of keys) <br></li><li>  Immunity function for building an index of trigrams, which converts the name from jsonb to text <br></li></ul><br><div class="spoiler">  <b class="spoiler_title">Boring SQL code</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> extension pg_trgm; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> info ( patid <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, fullname jsonb, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> info_pk primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (patid), <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> fullname_exists <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ( fullname ? <span class="hljs-string"><span class="hljs-string">'lname'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> fullname ? <span class="hljs-string"><span class="hljs-string">'fname'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> fullname ? <span class="hljs-string"><span class="hljs-string">'sname'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> fullname_notnull <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ( (fullname -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'lname'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (fullname -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'fname'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fullname(in_fullname jsonb) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> plpgsql immutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> regexp_replace( <span class="hljs-keyword"><span class="hljs-keyword">lower</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">trim</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(in_fullname-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'lname'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-string"><span class="hljs-string">' '</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(in_fullname-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'fname'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-string"><span class="hljs-string">' '</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(in_fullname-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'sname'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) ) ), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span> ); exception when others then raise exception '%', sqlerrm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$;</code> </pre> <br></div></div><br>  We insert into the table about 300 thousand full name entries and proceed. <br><br><h4>  Trigrams and GIST </h4><br>  So, first check the gist index for a fuzzy search by trigrams. <br><br><div class="spoiler">  <b class="spoiler_title">Even more boring SQL code</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> info_gist_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist (fullname(fullname) gist_trgm_ops); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">15054</span></span>,<span class="hljs-number"><span class="hljs-number">102</span></span> ms <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, buffers) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> patid, fullname(fullname) &lt;-&gt; <span class="hljs-string"><span class="hljs-string">'  '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dist <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> dist <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; Limit (cost=0.28..4.35 rows=10 width=8) (actual time=157.378..157.688 rows=10 loops=1) Buffers: shared hit=5743 -&gt; Index Scan using info_gist_idx on info (cost=0.28..126822.96 rows=312084 width=8) (actual time=157.371..157.655 rows=10 loops=1) Order By: (fullname(fullname) &lt;-&gt; '  '::text) Buffers: shared hit=5743 Planning time: 0.225 ms Execution time: 158.223 ms (7 rows)</code> </pre><br></div></div><br>  The index was created 15 seconds, the size of 45 MB, the search for an incomplete name with misspellings - 158 ms. <br><br><h4>  Trigrams and GIN </h4><br>  Next, consider the gin index for a fuzzy trigram search. <br><br><div class="spoiler">  <b class="spoiler_title">Do you think the previous SQL spoilers were boring?</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> info_trgm_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(fullname(fullname) gin_trgm_ops); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">10163</span></span>,<span class="hljs-number"><span class="hljs-number">401</span></span> ms <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, buffers) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> patid, similarity(fullname(fullname), <span class="hljs-string"><span class="hljs-string">'  '</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sml <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> fullname(fullname) % <span class="hljs-string"><span class="hljs-string">'  '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sml <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; Limit (cost=1180.22..1180.25 rows=10 width=8) (actual time=133.086..133.117 rows=8 loops=1) Buffers: shared hit=5741 -&gt; Sort (cost=1180.22..1181.00 rows=312 width=8) (actual time=133.080..133.090 rows=8 loops=1) Sort Key: (similarity(fullname(fullname), '  '::text)) DESC Sort Method: quicksort Memory: 25kB Buffers: shared hit=5741 -&gt; Bitmap Heap Scan on info (cost=26.70..1173.48 rows=312 width=8) (actual time=132.828..133.048 rows=8 loops=1) Recheck Cond: (fullname(fullname) % '  '::text) Heap Blocks: exact=7 Buffers: shared hit=5741 -&gt; Bitmap Index Scan on info_gist_idx (cost=0.00..26.62 rows=312 width=0) (actual time=132.699..132.699 rows=8 loops=1) Index Cond: (fullname(fullname) % '  '::text) Buffers: shared hit=5734 Planning time: 0.573 ms Execution time: 133.225 ms (15 rows)</code> </pre> <br></div></div><br>  Creating an index of 10 seconds, the size of 18 MB, search for an incomplete name with typos - 133 ms. <br><br>  To be honest, the results are so-so - after all, I have a Chinese ssd disk on my laptop from the glorious city of Shenzhen.  Therefore, we will try to speed up the process by combining fuzzy and full-text search. <br><br><h4>  Trigrams and full text search </h4><br>  The idea is extremely simple - to collect from all spellings of surnames, names and middle names a separate dictionary table.  First, we cut the input search string into lexemes, search each of the lexemes in the dictionary table through a fuzzy search, select all possible spellings of each lexeme from there, put them in tsquery and do a full-text search by tsvector index of the info table.  The benefit of this plan is that the speed of fuzzy search by trigrams depends on the width of the string and their number in the column with the text.  Obviously, the full name dictionary will be more compact than the original column in the info table, which means that the search will be faster.  There is only one drawback to the method - when adding each new patient, you will have to update the dictionary if there are no tokens from the full name in it.  To check, we will need to build from the <a href="https://github.com/postgrespro/rum">rum</a> source code an index to build the tsvector index by the name in the info table.  Rum is a modified version of the gin index that stores additional information in the leaves.  In our case, we use the rum_tsvector_ops operator class, which stores positional information about the token in the index.  Therefore, unlike gin, we can use an index-only tsquery query of the form <pre> <code class="bash hljs">(||)&lt;-&gt;()&lt;-&gt;()</code> </pre>  without accessing the table for more information about the order of the token in the tuple.  Moreover, the recommendation for gin is the physical existence of the tsvector column, since all found pointers to tuples will have to be rechecked in the table.  And if physically there is no tsvector column (you built it with a function for the index), then for each tuple you will have to perform an additional tsvector calculation.  In general, the rum in this story will be much more productive. <br><br><div class="spoiler">  <b class="spoiler_title">Everest in the world of boring SQL</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> extension rum; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> info_rum_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum ( to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>::regconfig, fullname(fullname)) rum_tsvector_ops ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">7.545</span></span>s (<span class="hljs-number"><span class="hljs-number">7</span></span> seconds) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> patname ( lex <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> patname_uniq_idx <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> (lex) ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> patname_fuzzy_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> patname <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin (lex gin_trgm_ops); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">0.596</span></span>s <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> patname (lex) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat($$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>, fullname(fullname)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> info $$); <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, buffers) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> fio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> lexeme <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> lex, positions[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>,<span class="hljs-string"><span class="hljs-string">'  '</span></span>)) ), <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>, string_agg(q.tq,<span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.pos, <span class="hljs-string"><span class="hljs-string">'('</span></span>||string_agg(p.lex,<span class="hljs-string"><span class="hljs-string">'|'</span></span>)||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tq <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> patname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> p.lex % f.lex <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> f.pos ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> q ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>::regconfig, fullname(fullname)) &lt;=&gt; (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rank</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>::regconfig, fullname(fullname)) @@ (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>::regconfig, fullname(fullname)) &lt;=&gt; (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>); Sort (cost=6453.71..6457.61 rows=1560 width=100) (actual time=68.201..68.202 rows=1 loops=1) Sort Key: ((to_tsvector('simple'::regconfig, fullname(info.fullname)) &lt;=&gt; $3)) Sort Method: quicksort Memory: 25kB Buffers: shared hit=536 CTE fio -&gt; Function Scan on unnest (cost=0.00..0.10 rows=10 width=34) (actual time=0.023..0.034 rows=3 loops=1) CTE query -&gt; Aggregate (cost=1484.60..1484.86 rows=1 width=32) (actual time=11.829..11.830 rows=1 loops=1) Buffers: shared hit=325 -&gt; HashAggregate (cost=1484.30..1484.48 rows=10 width=34) (actual time=11.640..11.644 rows=2 loops=1) Group Key: f.pos Buffers: shared hit=325 -&gt; Nested Loop (cost=16.58..1480.53 rows=755 width=19) (actual time=2.940..11.442 rows=62 loops=1) Buffers: shared hit=325 -&gt; CTE Scan on fio f (cost=0.00..0.20 rows=10 width=34) (actual time=0.028..0.053 rows=3 loops=1) -&gt; Bitmap Heap Scan on patname p (cost=16.58..147.28 rows=75 width=17) (actual time=1.905..3.717 rows=21 loops=3) Recheck Cond: (lex % f.lex) Rows Removed by Index Recheck: 321 Heap Blocks: exact=275 Buffers: shared hit=325 -&gt; Bitmap Index Scan on patname_fuzzy_idx (cost=0.00..16.57 rows=75 width=0) (actual time=1.277..1.277 rows=342 loops=3) Index Cond: (lex % f.lex) Buffers: shared hit=50 InitPlan 3 (returns $3) -&gt; CTE Scan on query (cost=0.00..0.02 rows=1 width=32) (actual time=0.004..0.006 rows=1 loops=1) InitPlan 4 (returns $4) -&gt; CTE Scan on query query_1 (cost=0.00..0.02 rows=1 width=32) (actual time=11.834..11.839 rows=1 loops=1) Buffers: shared hit=325 -&gt; Bitmap Heap Scan on info (cost=31.99..4885.97 rows=1560 width=100) (actual time=68.184..68.187 rows=1 loops=1) Recheck Cond: (to_tsvector('simple'::regconfig, fullname(fullname)) @@ $4) Heap Blocks: exact=1 Buffers: shared hit=536 -&gt; Bitmap Index Scan on info_rum_idx (cost=0.00..31.60 rows=1560 width=0) (actual time=67.847..67.847 rows=1 loops=1) Index Cond: (to_tsvector('simple'::regconfig, fullname(fullname)) @@ $4) Buffers: shared hit=517 Planning time: 5.012 ms Execution time: 68.583 ms (37 rows)</code> </pre> <br></div></div><br>  Total, the full-text search index was created 7 seconds (size 13 MB), the lexemes dictionary index was created in 0.6 seconds (size 5.8 MB), the search was 68 ms.  Among the disadvantages - the selectivity is worse than the previous options. <br><br><h3>  Phonetic algorithms </h3><br>  Having tried the options of a fuzzy search from the pg_trmg module, I decided to look again at fuzzystrmatch.  I did not invent how to index the Levenshtein function, but I was extremely interested in the phonetic algorithms.  As mentioned above, out of the box in PostgreSQL, phonetic functions are implemented only for Latin and sharpened under English names.  Searching the Internet for their Russian implementations led me to a wonderful <a href="https://habrahabr.ru/post/114947/">article</a> on Habr√©, which described the working Metaphone algorithm for Russian names (consisting of Russian letters).  There was only one sadness - even though it was simple, it was somehow quite sad to implement this logic on plpgsql, then it was a matter of some Python ... And then I remembered that plpython3u is unsafe (functions on it can access file system with the rights of the postgres process), but perfectly working language in PostgreSQL.  And sin would not use it.  Therefore, I wrote two immunity functions: <br><br><ul><li>  <i>phoneme</i> on plpython3u, which turns a token into a phoneme ("smirnov" in "smirnaf") according to an algorithm from an article on Habr√© <br></li><li>  <i>metaphone</i> on plpgsql, which turns not one lexeme into a phoneme, but the whole text into a set of phonemes.  In fact, this is just a binding over the phoneme function. <br></li></ul><br><h4>  Metaphone and btree </h4><br>  Next, we will try to create an ordinary btree index using the metaphone function and estimate the speed. <br><div class="spoiler">  <b class="spoiler_title">Pass by, there is nothing interesting</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> phoneme (in_lexeme <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> plpython3u immutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Lexeme: <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> __init__(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>): <span class="hljs-string"><span class="hljs-string">""" :type body: str """</span></span> self.body = body.lower().strip() <span class="hljs-comment"><span class="hljs-comment">#    self._vowels = {"(?:|||)": "", "[]": "", "[]": "", "[]": ""} #    self._consonants = {"": "", "": "", "": "", "": ""} #    ,         _deafening_chars self._deafening_chars = ["", "", "", "", "", "", ""] #   self._removable_chars = {"[]": ""} def _remove_double_chars(self): return Lexeme("".join((char for num, char in enumerate(self.body) if char != self.body[num - 1]))) def _deafen_consonants(self): modified_body = "" for num, char in enumerate(self.body): if char in self._consonants and ( num &lt; len(self.body) - 1 and self.body[num + 1] in self._deafening_chars or num == len(self.body) - 1 ): modified_body += self._consonants[char] else: modified_body += char return Lexeme(modified_body) @staticmethod def _regexp_replace(text, char_dict): modified_body = text for item in char_dict: modified_body = re.sub(item, char_dict[item], modified_body) return Lexeme(modified_body) def _replace_vowels(self): return self._regexp_replace(self.body, self._vowels) def _remove_chars(self): return self._regexp_replace(self.body, self._removable_chars) def metaphone(self): return self._remove_chars()._replace_vowels()._deafen_consonants()._remove_double_chars().body return Lexeme(in_lexeme).metaphone() $$; create or replace function metaphone (in_phonemes text) returns text language plpgsql immutable as $$ begin return ( select string_agg(q.lex,' ') from ( select phoneme(lexeme) as lex from unnest(to_tsvector('simple', in_phonemes)) order by positions ) as q ); exception when others then raise '%', SQLERRM using errcode = SQLSTATE; end; $$; create index info_metaphone_idx on info ( metaphone(fullname(fullname)) text_pattern_ops ); CREATE INDEX Time: 114.757s (a minute) explain (analyze, buffers) select patid, fullname from info where metaphone(fullname(fullname)) like regexp_replace(metaphone('  '),'\s','%','g')||'%' limit 10; Limit (cost=76.03..1388.96 rows=10 width=96) (actual time=22.452..129.944 rows=3 loops=1) Buffers: shared hit=239 -&gt; Bitmap Heap Scan on info (cost=76.03..4146.10 rows=31 width=96) (actual time=22.447..129.927 rows=3 loops=1) Filter: (metaphone(fullname(fullname)) ~~ '%%%'::text) Rows Removed by Filter: 244 Heap Blocks: exact=234 Buffers: shared hit=239 -&gt; Bitmap Index Scan on info_metaphone_idx (cost=0.00..76.02 rows=1560 width=0) (actual time=0.061..0.061 rows=247 loops=1) Index Cond: ((metaphone(fullname(fullname)) ~&gt;=~ ''::text) AND (metaphone(fullname(fullname)) ~&lt;~ ''::text)) Buffers: shared hit=5 Planning time: 1.012 ms Execution time: 129.977 ms (12 rows) Time: 131,802 ms</span></span></code> </pre> <br></div></div><br>  The index was created 114 seconds, the size is 22 MB (it seems I didn‚Äôt write the most optimal function on python for performance), the query is 131 ms.  The index is triggered only by a small part of the substring, and then the filter works because of the "%".  Poorly. <br><br><h4>  Metaphone and trigrams </h4><br>  Let's try on the base of the metaphone function created on plpython3u to build an index of trigrams.  But we will use it now not for a fuzzy search, but to search for a substring. <br><br><div class="spoiler">  <b class="spoiler_title">How to reduce the query time of folk remedies using ...</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> info_metaphone_trgm_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin (metaphone(fullname(fullname)) gin_trgm_ops); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">124.713</span></span>s (<span class="hljs-number"><span class="hljs-number">2</span></span> minutes) <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, buffers) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> patid, fullname <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> metaphone(fullname(fullname)) <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%'</span></span>||regexp_replace(metaphone(<span class="hljs-string"><span class="hljs-string">'  '</span></span>),<span class="hljs-string"><span class="hljs-string">'\s'</span></span>,<span class="hljs-string"><span class="hljs-string">'%'</span></span>,<span class="hljs-string"><span class="hljs-string">'g'</span></span>)||<span class="hljs-string"><span class="hljs-string">'%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; Limit (cost=92.24..134.98 rows=10 width=96) (actual time=9.562..10.638 rows=3 loops=1) Buffers: shared hit=103 -&gt; Bitmap Heap Scan on info (cost=92.24..224.74 rows=31 width=96) (actual time=9.554..10.617 rows=3 loops=1) Recheck Cond: (metaphone(fullname(fullname)) ~~ '%%%%'::text) Heap Blocks: exact=2 Buffers: shared hit=103 -&gt; Bitmap Index Scan on info_metaphone_trgm_idx (cost=0.00..92.23 rows=31 width=0) (actual time=8.354..8.354 rows=3 loops=1) Index Cond: (metaphone(fullname(fullname)) ~~ '%%%%'::text) Buffers: shared hit=101 Planning time: 2.029 ms Execution time: 10.726 ms (11 rows) Time: 14,480 ms</code> </pre> <br></div></div><br>  Index creation time - 124 seconds, size 15 MB (hello my curved hands and plpython3u), search - 14 ms. <br><br><h3>  Results </h3><br>  Let's summarize a summary table of various search options with typos <br>  <b>UPDATE 1:</b> added the <a href="https://habrahabr.ru/users/moveax/" class="user_link">movax</a> <a href="https://habrahabr.ru/post/341142/">implementation</a> of the <a href="https://habrahabr.ru/users/moveax/" class="user_link">metaphone</a> . <br>  <b>UPDATE 2:</b> added the implementation of Metaphone on plpgsql from Ivan Milovanov (telegram - milovanov) <br><div class="spoiler">  <b class="spoiler_title">Metaphone on plpgsql</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> phoneme (in_lexeme <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> plpgsql immutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> res <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res := <span class="hljs-keyword"><span class="hljs-keyword">lower</span></span>(in_lexeme); res := regexp_replace(res,'[]','','g'); res := regexp_replace(res,'(|||)','','g'); res := regexp_replace(res,'[]','','g'); res := regexp_replace(res,'[]','','g'); res := regexp_replace(res,'','','g'); res := regexp_replace(res,'([]|$)','\1','g'); res := regexp_replace(res,'([]|$)','\1','g'); res := regexp_replace(res,'([]|$)','\1','g'); res := regexp_replace(res,'([]|$)','\1','g'); res := regexp_replace(res,'([]|$)','\1','g'); res := regexp_replace(res,'','','g'); res := regexp_replace(res,'','','g'); res := regexp_replace(res,'(.)\1','\1','g'); return res; exception when others then raise exception '%', sqlerrm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$;</code> </pre><br></div></div><br><table><tbody><tr><td>  <b>Search type</b> <br></td><td>  <b>Index creation time</b> <br></td><td width="100">  <b>Index size</b> <br></td><td>  <b>Missing search speed</b> <br></td><td>  <b>Remarks</b> <br></td></tr><tr><td>  Gist trigrams <br></td><td>  15 sec <br></td><td>  45 MB <br></td><td>  158 ms <br></td><td></td></tr><tr><td>  Gin trigrams <br></td><td>  10 sec <br></td><td>  18 MB <br></td><td>  133 ms <br></td><td></td></tr><tr><td>  Trigrams and full text search <br></td><td>  7.6 seconds <br></td><td>  18.8 MB <br></td><td>  68 ms <br></td><td>  Worse selectivity, you need to maintain a dictionary of tokens <br></td></tr><tr><td>  Metaphone btree <br></td><td>  114 seconds <br></td><td>  22 MB <br></td><td>  131 ms <br></td><td>  Plpython3u insecure language <br></td></tr><tr><td>  Metaphone trigram <br></td><td>  124 sec <br></td><td>  15 MB <br></td><td>  14 ms <br></td><td>  Plpython3u insecure language <br></td></tr><tr><td>  <a href="https://habrahabr.ru/post/341142/">The implementation</a> of the <a href="https://habrahabr.ru/users/moveax/" class="user_link">metagram</a> trigram from <a href="https://habrahabr.ru/users/moveax/" class="user_link">movEAX</a> <br></td><td>  77.8 seconds <br></td><td>  16 MB <br></td><td>  14 ms <br></td><td>  Plpython3u insecure language <br></td></tr><tr><td>  Implementation of Ivan Milovanov on plpgsql <br></td><td>  72.0 seconds <br></td><td>  16 MB <br></td><td>  14 ms <br></td><td></td></tr></tbody></table><br>  <b>UPDATE 3:</b> when the index contains <i>‚ÄúSmirnaf Dinis Anatalievich‚Äù</i> , the letter <i>‚ÄúB‚Äù in the middle name is</i> not stunned (since after it comes a vowel).  If you search for the <i>metaphone</i> substring <i>('anatoliev')</i> , then the letter <i>‚Äúc‚Äù</i> is not behind the vowel, but at the end it will be stunned.  To get around this problem, the <i>mquery</i> function is written below and the search is performed by the expression <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> metaphone(<span class="hljs-string"><span class="hljs-string">'  '</span></span>) similar <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> mquery(<span class="hljs-string"><span class="hljs-string">'  '</span></span>);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mqery function</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> mquery(in_fullname <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> plpgsql immutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> res <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res := metaphone(in_fullname); res := regexp_replace(res, '(|)', '(|)', 'g'); res := regexp_replace(res, '(|)', '(|)', 'g'); res := regexp_replace(res, '(|)', '(|)', 'g'); res := regexp_replace(res, '(|)', '(|)', 'g'); res := regexp_replace(res, '(|)', '(|)', 'g'); res := regexp_replace(res, '\s', '%', 'g'); return '%'||res||'%'; exception when others then raise exception '%', sqlerrm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$;</code> </pre><br></div></div><br><br>  Since in my case the system will be focused on reading, not on writing (maximum addition of a couple of patients per minute), my version is Metaphone with trigrams.  If someone has ideas on how to optimize a function in Python for speed, then write in the comments, I will add data to the tests. </div><p>Source: <a href="https://habr.com/ru/post/341142/">https://habr.com/ru/post/341142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341130/index.html">Chronology of CO level in the atmosphere of the USA (solution of the Kaggle problem using Python + Feature Engineering)</a></li>
<li><a href="../341132/index.html">Environment for developing TypeScript and React web applications: from 'hello world' to modern SPA. Part 2</a></li>
<li><a href="../341134/index.html">Design pattern "state" twenty years later</a></li>
<li><a href="../341138/index.html">Step-by-step tutorial on working with Antlr4 with Maven project for Java through Intellij Idea</a></li>
<li><a href="../341140/index.html">Bonus vs depreirovanie</a></li>
<li><a href="../341144/index.html">What every C programmer should know about Undefined Behavior. Part 2/3</a></li>
<li><a href="../341146/index.html">$ mol - the best cure for hemorrhoids</a></li>
<li><a href="../341148/index.html">Fuzzy string comparison: understand me if you can</a></li>
<li><a href="../341152/index.html">Development of 2D sandboxes on JavaScript from scratch</a></li>
<li><a href="../341154/index.html">What every C programmer should know about Undefined Behavior. Part 3/3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>