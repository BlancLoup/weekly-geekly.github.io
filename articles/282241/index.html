<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing final tasks Technokubka 2016</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mail.Ru Group together with MIPT and MGTU im. N. E. Bauman summed up Technokubka - the first programming contest for students of 8-11 grades. Schoolch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing final tasks Technokubka 2016</h1><div class="post__text post__text-html js-mediator-article">  Mail.Ru Group together with MIPT and MGTU im.  N. E. Bauman summed up <a href="https://it.mail.ru/technocup/">Technokubka</a> - the first programming contest for students of 8-11 grades.  Schoolchildren from more than 20 cities in Russia and the CIS fought for the title of the most talented young programmer.  A total of 2132 participants registered for the Olympiad, 113 came to the internal finals, which took place simultaneously at two venues: at Moscow State Technical University.  N. E. Bauman and MIPT.  The award ceremony took place at the Mail.Ru Group office.  The Olympiad was held on the <a href="http://codeforces.com/">Codeforces</a> platform. <br><br><img src="https://habrastorage.org/files/cca/6d6/5a8/cca6d65a838b4f249f209217f6631b80.jpg"><br><br>  The guys had three hours to solve the seven tasks that were made by teachers and specialists from leading technical universities of Russia.  The last, the most difficult, was decided only by one of the participants - Vladislav Makeev, who eventually won first place.  In total, 27 participants of the Olympiad became winners, they shared diplomas of the I, II and III degrees.  The winners (diploma of I degree) received an additional eight points for admission, holders of diplomas of II and III degree - six points each.  The first place was taken by Vladislav Makeev (Moscow, 11th class), the second - Aleksandra Drozdova (Nizhny Novgorod, 10th class), the third - Grigory Reznikov (Moscow, 11th class).  The full list of winners is available <a href="http://codeforces.com/technocup2016/standings">here</a> .  In this post, we suggest that you familiarize yourself with the tasks of the final and their solutions. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/222/d2e/b2a/222d2eb2ac2f4104bd33fd0e446061f3.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/0d8/f0d/027/0d8f0d027e7f422ab82271632b6dceae.jpg"><br><br><h1>  Task A. Level 80 Programmer </h1><br>  Idea: Mikhail Mirzayanov, SSU <br>  Development: Alexander Frolov, SSU <br>  Subject: modeling <br><br><h3>  Condition </h3><br>  Vasily dreams of becoming a <i>k-</i> th programmer.  He has <i>n</i> days to fulfill his plans - to raise his level from the 1st to the <i>kth</i> .  To move from level <i>x</i> to level <i>x</i> + 1, it is necessary to solve <i>x</i> problems from the moment <i>x is</i> obtained. <br><br>  On the <i>i-</i> th day, <i>a <sub>i</sub></i> tasks are published on one well-known website, and all of them are available for solving only on the day of publication.  Every day Vasily solves problems one after another, and on the <i>i-</i> th day he can solve no more than <i>a <sub>i</sub></i> tasks.  As soon as the total number of problems solved by Vasiliy since the last level <i>x was</i> received, becomes equal to <i>x</i> , he stops and does not solve more problems on this day.  In this case, at the end of the day he makes the transition to the next level <i>x</i> + 1. At the same time, the tasks that Vasily did not have time to solve this day, he will not solve it ever. <br><br>  The solved tasks do not accumulate during the transition to the next level, that is, for each <i>x,</i> to go to level <i>x</i> + 1, Vasily needs to solve <i>x</i> problems, being a programmer of level <i>x</i> . <br><br>  Vasily can start classes any day from 1 to <i>n</i> , while he wants to minimize the <b>difference</b> between the number of the day when he becomes a programmer of level <i>k</i> and the day when he begins to study. <br><br><img src="https://habrastorage.org/files/58c/f9f/690/58cf9f6904374bc58f0f04f6c19546ea.jpg"><br><br>  <i>Input data</i> <br><br>  The first line of input data contains two integers <i>n</i> and <i>k</i> (1 ‚â§ <i>n</i> ‚â§ 500, 2 ‚â§ <i>k</i> ‚â§ <i>n</i> + 1) - the total number of days and the level that Vasily wants to achieve, respectively. <br><br>  The second line contains <i>n</i> integers <i>a <sub>1</sub></i> , <i>a <sub>2</sub></i> , ..., <i>a <sub>n</sub></i> (1 ‚â§ <i>a <sub>i</sub></i> ‚â§ 500), where <i>a <sub>i</sub></i> is equal to the number of tasks available on the <i>i-</i> th day. <br><br>  <i>Output</i> <br><br>  Print a single integer - the minimum number of days during which Vasily will be able to achieve the <i>k</i> -th level of programming. <br><br>  If Vasily cannot achieve the desired, output -1. <br><br><h3>  Parsing </h3><br>  To begin with, we note that in the process of solving problems it is never beneficial to take breaks, since the excess tasks remaining on a given day can simply not be used. <br><br>  Thus, the only thing that makes sense to change is the day the pumping starts.  We will enumerate all possible variants of the first day and simulate the programmer‚Äôs build process for each one.  The complexity of this solution is <i>O (n <sup>2</sup> )</i> , since the possible variants of the starting day <i>n</i> and for each day are simulated during the time <i>O (n)</i> . <br><br><h1>  Task B. Replacing letters </h1><br>  Authors of the idea: Gleb Evstropov, HSE, and Mikhail Mirzayanov, SSU <br>  Development: Alexander Frolov, SSU <br>  Topics: Hamming distance, counting <br><br><h3>  Condition </h3><br>  Ivan loves to read newspapers; he is especially interested in political and sports news.  Ivan also has a favorite string <i>s</i> . <br><br>  Ivan has a lot of free time, and he reads very quickly, but there are not so many newspapers that interest him.  Therefore, recently, after reading a regular newspaper, Ivan began to consider the number of occurrences of his favorite string <i>s</i> in the text <i>t</i> written in the newspaper as a substring.  A substring of the string x is a sequence of consecutive characters of the string <i>x</i> . <br><br>  But soon, and with counting the occurrences, Ivan began to cope very quickly, and after reading the next newspaper he decided to replace in his favorite line no more than <i>k</i> characters so as to maximize the number of occurrences of the modified line <i>s</i> in the text of the newspaper <i>t</i> . <br><br>  Your task is to help Ivan and count the maximum number of occurrences of his favorite string <i>s</i> after replacing no more than <i>k</i> characters in it in the text of the newspaper <i>t</i> .  Ivan does not have to replace exactly <i>k</i> letters, and he may not even have to replace a single letter.  You can replace the letter from the string <i>s</i> with any other. <br><br><img src="https://habrastorage.org/files/f07/c4c/89b/f07c4c89b8994cb3a1572bc9062e1657.jpg"><br><br>  <i>Input data</i> <br><br>  The first input line contains three integers <i>n</i> , <i>m</i> and <i>k</i> (1 ‚â§ <i>n</i> ‚â§ <i>m</i> ‚â§ 250, 0 ‚â§ <i>k</i> ‚â§ <i>n</i> ) - the length of the string <i>s</i> , the length of the string <i>t</i> and the number of characters that Ivan can replace in his favorite string, respectively. <br><br>  The second line of input should be a non-empty string <i>s</i> , consisting of <i>n</i> lowercase English letters - Ivan‚Äôs favorite string. <br><br>  The third line of the input data is followed by a non-empty string <i>t</i> consisting of <i>m</i> lowercase English letters - text written in a newspaper.  It is guaranteed that the length of string <i>s</i> does not exceed the length of string <i>t</i> . <br><br>  <i>Output</i> <br><br>  Output a single integer - the maximum number of occurrences of Ivan‚Äôs favorite string <i>s</i> after replacing no more than <i>k</i> characters in it in the text of the newspaper <i>t</i> . <br><br><h3>  Parsing </h3><br>  A naive solution that goes through all the options for changing the original string <i>s</i> and considers the answer for them has exponential complexity.  However, we note that there are no more different variants having at least one occurrence than |  <i>t</i> |  - |  <i>s</i> |  + 1, that is, the number of ways to "attach" the string <i>s</i> to the string <i>t</i> . <br><br>  We change the order of calculations, iterate all possible positions of the application of the string <i>s</i> to the string <i>t,</i> and for each we calculate exactly which positions and which characters need to be changed to get an entry in this position (or we can determine that it is impossible to keep within <i>k</i> changes).  It is required in some way to code the necessary changes in order to be able to distinguish whether the line requires identical changes for two different positions of the application or different ones.  In this problem there were small restrictions on the length of the strings <i>t</i> and <i>s</i> , therefore it was allowed to use almost any polynomial solution.  For example, the necessary changes could simply be represented by an array of length |  <i>s</i> |. <br><br>  Now select the groups of the same changes and find the group of the same size.  This can be done in many different ways, for example using sorting or hashes. <br><br><h1>  Problem C. Prize fund </h1><br>  Author of the idea and development: Alexey Dmitriev, MIPT <br>  Subject: Math <br><br><h3>  Condition </h3><br>  HackerCook company has its grand championship in sports programming with a large prize fund, but the distribution of prize money has not yet been announced.  The only thing that is known about the final distribution is that a participant with a higher place will receive no less prize money than a participant with a lower place. <br><br>  Now, one HackerCook employee wants to distribute the prize fund so that his friends receive a sum of money as much as possible.  Determine what part of the prize fund each participant will receive, provided that the employee distributes the money optimally. <br><br><img src="https://habrastorage.org/files/67f/30c/624/67f30c624f634e46b6bc8feee4962e3e.jpg"><br><br>  <i>Input data</i> <br><br>  The first line of the input data contains two integers <i>n</i> and <i>k</i> (1 ‚â§ <i>k</i> ‚â§ <i>n</i> ‚â§ 1 000 000) - the total number of participants and the number of friends of the Hacker Cook employee. <br><br>  The second line contains <i>k</i> different integers <i>a <sub>i</sub></i> (1 ‚â§ <i>a <sub>i</sub></i> ‚â§ <i>n</i> ) in ascending order ‚Äî the places that were occupied by the friends of the cunning developer. <br><br>  <i>Output</i> <br><br>  Print <i>n</i> non-negative integers <i>b <sub>1</sub></i> , <i>b <sub>2</sub></i> , ..., <i>b <sub>n</sub></i> ( <img src="https://habrastorage.org/files/ef2/df8/1e9/ef2df81e90de4ed48a9f1109350f3d8c.png">  ), which means that the participant who took the <i>i-</i> th place must receive <img src="https://habrastorage.org/files/4ef/da5/a04/4efda5a0489f44e58c90a097708dd6fc.png">  part of the prize pool. <br><br>  If there are several possible answers, you can print any. <br><br>  It is guaranteed that there is an optimal answer satisfying the condition described in the output format. <br><br><h3>  Parsing </h3><br>  Briefly: consider all the options to distribute all the money equally between the first few participants, at least one of these options will be the best answer. <br><br>  How to prove it?  Consider some optimal answer.  Let there be some two participants <i>A</i> and <i>B</i> receive a different positive amount of money, let us denote their earnings by <i>a</i> and <i>b</i> (then 0 &lt; <i>a</i> &lt; <i>b</i> ).  We divide all participants with a positive amount of money into those who received at least <i>b</i> , and those who received less <i>b</i> .  Let in these groups <i>X</i> and <i>Y</i> participants, respectively, and among them x and y friends, respectively (at least one of the numbers <i>x</i> and <i>y is</i> positive). <br><br>  Suppose we chose the number <i>k</i> and increase the earnings of each participant in the first group by <i>k / X</i> , and in the second group decrease by <i>k / Y</i> (note that the total amount is saved).  Then the earnings of friends change to <i>k (x / X - y / Y)</i> .  Note that we can pick up both positive and negative <i>k</i> in such a way that after a change no participant gets more money than those who are higher than him, and all earnings are non-negative.  Since our answer is optimal, <i>x / X = y / Y</i> (otherwise, by choosing the number <i>k of the</i> desired sign, we could improve it).  Choose <i>k</i> such that in the second group one of the participants has 0 money.  The number of participants with a positive gain has decreased;  we will repeat this process until all participants with a positive amount of gain do not equal. <br><br>  Technically, the task is very simple: among all the prefixes of the sequence, you must choose such that the share of friends in it is maximum.  This is done by a simple linear approach and saving the current answer as a fraction <i>a / b</i> . <br><br><h1>  Task D. Flowers </h1><br>  Author of the idea and development: Mikhail Mirzayanov, SSU <br>  Topics: greed, event handling <br><br><h3>  Condition </h3><br>  Vasya wants to give Masha a bouquet on March 8.  He knows one secret path in the woods outside the city, along which grow beautiful, and most importantly, free flowers.  The path can be represented as a straight line, and we can assume that Vasya initially appears on it at point 0 and moves at a speed of 1, without taking the time to pick flowers. <br><br>  Flower number <i>i</i> grows at the point of the path with the coordinate <i>x <sub>i</sub></i> , and after Vasya breaks it, the flower remains alive <i>t <sub>i</sub></i> units of time.  Naturally, Vasya should dial an odd number of flowers into a bouquet, and they should all be alive at the moment when he brings them to point 0 to meet Masha (if the <i>i</i> -th flower is brought exactly <i>t <sub>i</sub></i> units of time after it is torn off, then no longer considered alive). <br><br>  Vasya is a straight line man, and even for the sake of Masha he is not ready to turn (that is, change the direction of his movement along the path) more than twice.  Help him collect the largest bouquet of odd size. <br><br><img src="https://habrastorage.org/files/7e6/6a4/03f/7e66a403fb8f4342adf2d6c60e6a7130.jpg"><br><br>  <i>Input data</i> <br><br>  The first line of the input data contains a single integer <i>n</i> (1 ‚â§ <i>n</i> ‚â§ 200 000) - the number of flowers growing along the path. <br><br>  Each of the following <i>n</i> lines contains two integers <i>x <sub>i</sub></i> and <i>t <sub>i</sub></i> (‚Äì10 <sup>9</sup> ‚â§ <i>x <sub>i</sub></i> ‚â§ 10 <sup>9</sup> , 0 ‚â§ <i>t <sub>i</sub></i> ‚â§ 10 <sup>9</sup> ) - the coordinate of the <i>i</i> -th flower and the time it will be alive after he'll be ripped off, respectively.  At one point can grow more than one flower. <br><br>  <i>Output</i> <br><br>  Print a single number - the maximum possible number of flowers in a bouquet.  If it is impossible to collect a bouquet from even one flower, output 0. <br><br><h3>  Parsing </h3><br>  The condition that Vasya is ready to change the direction of movement no more than twice clearly defines the form of the answer: first we go to one of the two sides until it stops, then, returning, we collect all the flowers, go through 0 and go the other way until some moment , then again we turn around and go to 0, again collecting all the flowers in its path.  From how far we go from point 0 before the last turn, it depends, on the one hand, how many flowers we can collect on the way back, and on the other, how many flowers collected in the first section will have time to wither. <br><br>  Without loss of generality, we will assume that we first went from point 0 to the left (negative coordinates), and then to the right.  Then ‚Äúturn the world‚Äù and solve a symmetric problem.  Of course, we will collect a bouquet of the maximum size, and then we simply find the odd number nearest to this maximum. <br><br>  A flower to the right of point 0 can be delivered to Masha if <i>x <sub>i</sub></i> &lt; <i>t <sub>i</sub></i> for the corresponding <i>i</i> .  Let us go to the right from point 0 to coordinate R. Then the flower <i>i</i> , located to the left of point 0, can be delivered to Masha uncomfortable if <i>t <sub>i</sub></i> + <i>x <sub>i</sub></i> - 2 <i>R</i> &gt; 0 or <i>R</i> &lt;( <i>t <sub>i</sub></i> + <i>x <sub>i</sub></i> ) / 2. Thus, <i>n</i> events are located along the ray with positive coordinates, each of which either adds a new flower or removes it.  Go from 0 to the coordinates of the maximum event and find the maximum positive balance.  It should carefully handle events located at one point and between integer points (here the problem will be solved by multiplying all coordinates by 2). <br><br><h1>  Problem E. Berland Hockey League </h1><br>  Author of the idea and development: Alexander Ostanin, MIPT <br>  Topics: Mathematics, Graphs <br><br><h3>  Condition </h3><br>  In the championship of the Berland Hockey League <i>n</i> teams participate.  The tournament is held in a round robin: each team plays exactly one match with each, and there are no draws in the tournament.  Unlike traditional tournaments, the distribution of prizes in the Berland Hockey League does not depend on the final place of the team, but on the number of victories.  Namely: all teams that have won at least <i>w</i> games receive prizes.  Hockey expert Don Berry wonders if, based on the results of this tournament, exactly <i>k</i> teams will receive prizes.  If such a tournament exists, you need to display a winner for each match. <br><br><img src="https://habrastorage.org/files/c43/f57/793/c43f577933a24c108b5b78a7bcbf7cee.jpg"><br><br>  <i>Input data</i> <br><br>  The only input line contains three numbers <i>n</i> , <i>w</i> and <i>k</i> (2 ‚â§ <i>n</i> ‚â§ 1000, 0 ‚â§ <i>w</i> ‚â§ <i>n</i> , 0 ‚â§ <i>k</i> ‚â§ <i>n</i> ) - the number of participating teams, the minimum number of wins for receiving the prize and the number of winners of the tournament, predicted by the expert . <br><br>  <i>Output</i> <br><br>  If a tournament with such properties does not exist, output "NO" (without quotes) in the only line of the output. <br>  Otherwise, in the first line print "YES" (without quotes).  Then output <i>n</i> lines of length <i>n</i> , <i>j</i> -th character of the <i>i-</i> th of them should match the match between teams <i>i</i> and <i>j</i> .  If <i>i</i> = <i>j</i> , then the corresponding symbol must be equal to 0. If the <i>i</i> team defeated the <i>j</i> command, then this symbol is 1, otherwise 0. For all <i>i ‚â† j,</i> exactly one of the two symbols corresponding to the meeting of these teams must be equal to 1. <br><br><h3>  Parsing </h3><br>  We will solve a more difficult task: we will construct such a tournament, that the minimum of points among the first <i>k</i> teams is as large as possible, and the maximum points among the last <i>n - k</i> teams are as small as possible (it is stated that in some tournament the optimal values ‚Äã‚Äãof these values ‚Äã‚Äãare reached simultaneously).  Then either this tournament is the answer, or there is no answer. <br><br>  It is obvious that in the optimal tournament each of the first <i>k</i> teams must win each of the last <i>n - k</i> , it remains to decide how all the first teams will play each other and how all the last teams will play.  We would like to see as many points as possible in the microtournament among the first <i>k</i> teams, and as many points as possible in the last teams tournament. <br><br>  Let <i>m</i> teams participate in a tournament and <i>m is</i> odd.  Then, in a complete graph on <i>m</i> vertices, all the degrees of the vertices are even, which means that there exists an Euler cycle in it (and it can be constructed in <i>O (m <sup>2</sup> ) time</i> ).  If we orient the edges along the cycle and say that the edge leads from the winning team to the loser, we get a tournament in which each team won exactly <i>(m-1) / 2</i> times. <br><br>  Now suppose that <i>m is</i> even.  Then it is impossible to build a tournament with the same number of points for all teams and the last team will have no more <i>(m-2) / 2</i> points.  But a tournament with such a property can be built if you throw out one vertex, apply the algorithm from the previous paragraph to the remaining <i>m</i> - 1 teams, and then put extra team wins in half of the remaining teams.  In the resulting tournament, half the teams <i>(m-2) / 2</i> points, and the other half - <i>m / 2</i> points. <br><br>  This way of building the most ‚Äúeven‚Äù tournament is suitable both for the first <i>k</i> teams and for the last <i>n - k</i> teams.  In the end, we check that it really is the answer (that is, all the first teams won at least <i>w</i> times, and the rest won less than <i>w</i> times). <br><br><h1>  Problem F. Carlson </h1><br>  Authors of the idea and development: Gleb Evstropov, HSE, and Mikhail Mirzayanov, SSU <br>  Topics: greed, dynamic programming <br><br><h3>  Condition </h3><br>  Twenty years have passed.  Carlson is stout and no longer flies.  The kid got a job, became a top manager and now lives in a huge house on the <i>n-</i> th floor. <br><br>  Carlson decided to go on a visit to the Kid.  Of course, he is not going to go up on foot, so on the first floor Carlson enters the elevator. <br><br>  Buttons in the elevator are located from bottom to top in such a way that a person with an increase in <i>h</i> can reach any button corresponding to the floor from 1 to <i>h</i> inclusive.  At the same time, on the <i>i-</i> th floor, Carlson has a friend with an increase in <i>h <sub>i</sub></i> , and he can be asked to press any button he can reach.  Of course, to ask a friend from the <i>i-</i> th floor to press a button, you first need to be on floor <i>i</i> .  Carlson wants to get to the Kid, turning for help to the minimum possible number of friends. <br><br>  Unfortunately, over time, Carlson's character also deteriorated, so sometimes he quarrels with his friends, but not more than one friend at a time.  For each <i>i,</i> Carlson wants to determine the minimum number of friends to whom he will have to ask for help if he quarrels with his friend number <i>i</i> and cannot address him with a request to press a button. <br><br><img src="https://habrastorage.org/files/95b/f61/f87/95bf61f8735b4052a1aae4bf15abd7ce.jpg"><br><br>  <i>Input data</i> <br><br>  The first line of the input data contains two integers <i>n</i> and <i>h</i> (2 ‚â§ <i>n</i> ‚â§ 10 <sup>6</sup> , 1 ‚â§ <i>h</i> ‚â§ 10 <sup>9</sup> ) - the number of the floor on which the Kid lives and the height of Carlson, respectively.  The next line contains integers <i>h <sub>1</sub></i> , <i>h <sub>2</sub></i> , ..., <i>h <sub>n - 1</sub></i> (1 ‚â§ <i>h <sub>i</sub></i> ‚â§ 10 <sup>9</sup> ), the <i>i</i> -th of which corresponds to the height of a friend of Carlson living on the <i>i-</i> th floor. <br><br>  <i>Output</i> <br><br>  Output <i>n</i> - 1 number of <i>ans <sub>1</sub></i> , <i>ans <sub>2</sub></i> , ..., <i>ans <sub>n - 1</sub></i> , where <i>ans <sub>i</sub></i> is equal to the minimum number of friends you have to ask for help if Carlson quarrels with a friend living on the <i>i-</i> th floor.  If, having quarreled with his <i>i</i> -th friend, Carlson cannot get to the Kid, then output -1 instead of the corresponding value of <i>ans <sub>i</sub></i> . <br><br><h3>  Parsing </h3><br>  First, we solve the problem under the condition that Carlson is friends with all his friends.  At any given time, we can assume that some prefix of floors is available to it, because if Carlson could get to floor <i>x</i> , he could get to all intermediate floors.  Then, obviously, the most profitable move will take the help of the highest friend on this prefix.  The complexity of this solution is <i>O (n)</i> . <br><br>  This immediately gives us a way to solve the original problem in a quadratic time ‚Äî to sort through which friends Carlson is quarreling with and solve the problem for each case.  Now we will notice that on each prefix we are interested only in two maximum values, and we will count the following values: <br><br>  <i>f <sub>i</sub></i> - the minimum number of steps for which Carlson can get to Tiny if he has access to the prefix of floors 1 to i and at the same time he did not quarrel with the highest friend on this prefix; <br>  <i>g <sub>i</sub></i> is the minimum number of steps for which Carlson can get to Toddler if he has access to the prefix of floors 1 to <i>i</i> and he has quarreled with the highest friend on this prefix (and therefore, he will have to ask for the second highest friend). <br><br>  We denote by <i>a <sub>i</sub></i> the highest friend among the first <i>i</i> , and by <i>b <sub>i</sub></i> - the second highest.  Then <i>f <sub>i</sub></i> = <i>f <sub>ai</sub></i> + 1, and <i>g <sub>i</sub></i> = <i>g <sub>bi</sub></i> + 1, if <i>a <sub>i</sub></i> = <i>a <sub>bi</sub></i> , and <i>g <sub>i</sub></i> = <i>f <sub>bi</sub></i> + 1 otherwise. <br><br>  Now let's learn how to calculate the answer using these values.  If one of Carlson's friends did not initially enter into the optimal answer, then the answer for the case of a quarrel with this friend is equal to the optimal one.  If it did, then the answer for this <i>i</i> would be <i>k</i> - 1 + <i>g <sub>i</sub></i> , where <i>k</i> is the sequence number of this friend in the optimal answer. <br><br><h1>  Problem G. Rock, paper, scissors </h1><br>  Author of the idea and development: Konstantin Semenov, MIPT <br><br><h3>  Condition </h3><br>  Petya and Vasya play the famous game ‚ÄúRock, Scissors, Paper‚Äù.  The game takes place in n rounds.  In each round, Petya and Vasya choose one of three figures: stone, scissors, or paper.  If the figures of the players do not match, the winner is determined in the standard way (the stone defeats the scissors, the scissors defeats the paper, the paper defeats the stone), otherwise a draw is declared.  For victory, <i>w</i> points are awarded, for a draw - <i>d</i> points, for defeat - 0 points.  The total score of each player is the sum of points for all rounds. <br><br>  Petya determined in advance which figure he would choose in each round, and wrote it down as a string of length <i>n</i> with the letters <i>r</i> , <i>s,</i> and <i>p</i> .  Here, the letter <i>r</i> at the <i>i</i> -th position in the line means that in the <i>i-</i> th round, Petya will choose a stone, <i>s</i> - scissors, and <i>p</i> - paper. <br><br>  Vasya got a certain cyclical shift of Petr's line and wants to use this information to maximize his final score.  Find the maximum score that Vasya can guarantee himself no matter what kind of cyclic shift of the source line is the line known to Vasya. <br><br><img src="https://habrastorage.org/files/f28/709/bd7/f28709bd7d7c467dbccd726c7c06f24a.png"><br><br>  <i>Input data</i> <br><br>  The first line of input contains three integers <i>n</i> , <i>w</i> and <i>d</i> (1 ‚â§ <i>n</i> ‚â§ 100 000, 0 ‚â§ <i>d</i> ‚â§ <i>w</i> ‚â§ 10 <sub>9</sub> ) - the number of rounds, the number of points for the victory and the number of points for a draw, respectively. <br><br>  The second line contains a string of length <i>n</i> , consisting of the characters <i>r, s, p</i> , the cyclic shift of the line written by Petya. <br><br>  <i>Output</i> <br><br>  Output one number - the maximum score that Vasya can guarantee himself. <br><br><h3>  Parsing </h3><br>  Suppose we have already seen the first few characters of Petina‚Äôs string and they make up the string <i>t</i> .  Let <i>f (t)</i> denote the maximum bill that we can provide for ourselves;  the answer to the original problem is <i>f (empty string)</i> .  If the string length <i>t</i> is equal to <i>n</i> , the game is over and <i>f (t)</i> = 0. <br><br>  Let <i>t be</i> less than <i>n</i> .  If our next move is, for example, <i>r</i> (stone), in the worst case we will earn the minimum among the numbers: <i>f (t + p)</i> (the next Petin move is paper, we lost), <i>d + f (t + r), w + f (t + s)</i> .  If any of these values ‚Äã‚Äãis not defined (for example, if the string <i>t + p is</i> not a prefix of any cyclic shift), we set by definition <i>f (t)</i> = ‚àû.  For the remaining two possible moves, the result in the worst case is calculated in the same way;  since we can choose our next move, among the results for the three possible moves we choose the maximum, this maximum is equal to <i>f (t)</i> . <br><br>  This method allows us to calculate the answer to the problem.  All possible values ‚Äã‚Äãof the string <i>t</i> , for which <i>f (t) is</i> not equal to infinity, are conveniently represented as a root tree, a boron, in which a letter is associated with each edge and a line is associated with any path from the root ‚Äî a sequence of letters along which the path passes.  The previous algorithm can be represented as dynamic programming on a tree in which all cyclic shifts of the source line are present.  The tree size and complexity of the algorithm are <i>O (n <sub>2</sub> )</i> . <br><br>  To optimize, we need an advanced structure - a compressed suffix tree.  We construct a boron, which contains all the suffixes of the string <i>s</i> , after which we ‚Äúcompress‚Äù into one edge a chain of vertices from which only one transition proceeds (now a line of some length is written on each edge).  The resulting tree will contain <i>O (| s |)</i> vertices and edges;  in addition, it can be constructed in linear time (for example, using the Ukkonen algorithm or using a suffix automaton). <br><br>  Let's return to our task.  If we calculate the value of <i>f</i> at the vertex, from which only one transition comes, we simply add <i>w</i> to the value of <i>f</i> for the only son of that vertex.  This means that the method of calculating <i>f is</i> easily transferred to a ‚Äúcompressed‚Äù bur: when we go along an edge of length <i>L,</i> we add <i>w</i> ( <i>L</i> - 1) to the result. <br><br>  Construct a compressed suffix tree for a doubled source line.  This tree contains all the cyclic shifts of the original row, so it is possible to calculate the values ‚Äã‚Äãof the function <i>f from it</i> , carefully examining cases where we go to the vertices at a depth greater than <i>n</i> .  The final solution works in linear time. <br><br>  If you are interested in such tasks, you can take part in the <a href="http://russiancodecup.ru/%3Futm_source%3DHabra%26utm_medium%3DTechnoCupTasks%26utm_campaign%3Drcc2016">Russian Code Cup 2016</a> and compete for a cash prize! </div><p>Source: <a href="https://habr.com/ru/post/282241/">https://habr.com/ru/post/282241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282231/index.html">Determine gender and age using Microsoft Project Oxford and C #</a></li>
<li><a href="../282233/index.html">Setup of VLAN on Mikrotik together with Cisco</a></li>
<li><a href="../282235/index.html">Time of unexpected analogies: river crayfish and electrical conductivity sensors</a></li>
<li><a href="../282237/index.html">3D multimedia reconstruction of the theatrical production ‚ÄúThe Seagull‚Äù on the stage of the Alexandrinsky Theater (October 17, 1896)</a></li>
<li><a href="../282239/index.html">Looking for a way - King Sultan masters the Laplacian</a></li>
<li><a href="../282243/index.html">Joomla Licensing FAQ</a></li>
<li><a href="../282245/index.html">Friday gamedev: good videos on how to make games</a></li>
<li><a href="../282247/index.html">Security Week 16: hacking a mouse from 225 meters, a cryptographic detector on Mac OS X, a million dollars for hacking an iPhone</a></li>
<li><a href="../282249/index.html">Easter eggs for Easter</a></li>
<li><a href="../282251/index.html">Hub 2.0: a link for JetBrains team products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>