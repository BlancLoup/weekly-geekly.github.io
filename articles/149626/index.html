<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing MVC implementation for Backbone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One gloomy morning, I thought that it would be a good idea to thoroughly refactor one of my old projects. This is a non-commercial lightweight applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing MVC implementation for Backbone</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/acc/144/dde/acc144ddeb46a09b3125f7bdb1a10769.png" alt="image"><br><br>  One gloomy morning, I thought that it would be a good idea to thoroughly refactor one of my old projects.  This is a non-commercial lightweight application for customizing HUD in one 3D shooter.  I wrote it 2 years ago, was hot and inexperienced.  As a result, a bunch of excellent spaghetti code, which, despite all its flaws, did its job.  Having become wiser and more experienced, I decided to completely rewrite the application, give it a new architecture, simplify support and updating.  How to do it?  The answer seemed simple - to use MVC, divide it into levels, and tie everything together.  So I was faced with the problem of choosing a simple and efficient framework that would become a solid foundation.  After a quick study, I chose <a href="http://backbonejs.org/">backbone.js</a> .  Loved its simplicity and flexibility.  You can simply open the source and understand how everything works and works.  The only nuance that didn‚Äôt please was the MV pattern.  I didn‚Äôt want to blur logic on numerous views, so the idea was born to write my own bike, which would provide the missing pieces of the puzzle.  Plus, creating something new is always exciting and interesting.  Without thinking twice, I started implementing controllers for the backbone. <br><a name="habracut"></a><br><h4>  Task setting and implementation of basic methods </h4><br>  So, I need the ability to create controllers that link all parts of an application into one.  Each controller should have access to all models and collections (both to basic designers, and to already created copies).  It also requires the ability to create components (views) and be able to listen to their events in order to respond appropriately. <br><br>  The controller skeleton will look like this: <br><pre><code class="javascript hljs">Controller = { <span class="hljs-attr"><span class="hljs-attr">views</span></span>: {}, <span class="hljs-comment"><span class="hljs-comment">// views hash map models: {}, // models hash map collections: {}, // collections hash map // Set of methods to get existing view, get view constructor and create new view using constuctor getView: function() {}, getViewConstructor: function() {}, createView: function() {}, // Set of methods to get existing model, get model constructor and create new model using constuctor getModel: function() {}, getModelConstructor: function() {}, createModel: function() {}, // Set of methods to get existing collection, // get collection constructor and create new collectionusing constuctor getCollection: function() {}, getCollectionConstructor: function() {}, createCollection: function() {}, // This method will subscribe controller instance to view events addListeners: function() {} }</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So far, everything is very simple.  But for a complex application, we need to have several controllers, it is desirable that the set of collections and models be common to the entire application.  This is how <code>Application</code> - a basic constructor that will merge controllers into a single application - comes to the rescue. <br><br>  The skeleton of the application will look like this: <br><pre> <code class="javascript hljs">Application = { <span class="hljs-comment"><span class="hljs-comment">//Method that will initialize all controllers upon applicaiton launch initializeControllers: function() {}, // Set of methods to get existing model, get model constructor and create new model using constuctor getModel: function() {}, getModelConstructor: function() {}, createModel: function() {}, // Set of methods to get existing collection, get collectionconstructor and create new collectionusing constuctor getCollection: function() {}, getCollectionConstructor: function() {}, createCollection: function() {}, }</span></span></code> </pre><br>  It would also be useful to immediately create instances of all collections at the time the application starts.  And it would be nice to call the callback function of each controller after the application starts.  This callback must be called at the moment when all the preliminary data is ready.  Thus, each controller will ‚Äúknow‚Äù that the application is ready for operation.  Without hesitation, add methods: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Create collection instances upon application start Application.buildCollections() // Initialize all application controllers Application.initializeControllers()</span></span></code> </pre><br><br>  It remains only to teach the controllers to communicate with each other.  For this purpose, we create another entity that will enable communication between all the components of the application. <br><br><pre> <code class="javascript hljs">EventBus = { <span class="hljs-comment"><span class="hljs-comment">// Function to add event listeners addListeners: function() {}, // Function to fire event listneres fireEvent: function() {} }</span></span></code> </pre><br><br>  Now that the base objects are defined, we can proceed to the concrete implementation of all parts of our application. <br><br><h4>  Application Implementation </h4><br>  Let's start with the main designer - <code>Application</code> .  The base class is implemented in the same way as the backbone does. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Application = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ _.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, options || {}); <span class="hljs-comment"><span class="hljs-comment">// Create a new instance of EventBus and pass the reference to out application this.eventbus = new EventBus({application: this}); // Run application initialization if needed this.initialize.apply(this, arguments); // Create documentReady callback to lauch the application $($.proxy(this.onReady, this)); };</span></span></code> </pre><br><br>  Further, using <code>_.extend</code> , we extend the prototype: <br><pre> <code class="javascript hljs">_.extend(Application.prototype, { <span class="hljs-comment"><span class="hljs-comment">// Hash maps to store models, collections and controllers models: {}, collections: {}, controllers: {}, /** * Abstract fuction that will be called during application instance creation */ initialize: function(options) { return this; }, /** * Called on documentReady, defined in constructor */ onReady: function() { // initialize controllers this.initializeControllers(this.controllers || {}); // call to controller.onLauch callback this.launchControllers(); // call application.lauch callback this.launch.call(this); }, /** * Function that will convert string identifier into the instance reference */ parseClasses: function(classes) { var hashMap = {}; _.each(classes, function(cls) { var classReference = resolveNamespace(cls), id = cls.split('.').pop(); hashMap[id] = classReference; }, this); return hashMap; }, /** * Abstract fuction that will be called during application lauch */ launch: function() {}, /** * Getter to retreive link to the particular controller instance */ getController: function(id) { return this.controllers[id]; }, /** * Function that will loop throught the list of collection constructors and create instances */ buildCollections: function() { _.each(this.collections, function(collection, alias) { this.getCollection(alias); }, this); } });</span></span></code> </pre><br><br>  To initialize our controllers, we need two methods.  <code>Application.initializeControllers</code> will create instances and subtract sets of collections and models to store the links directly in the application itself.  And <code>Application.launchControllers</code> will go through already created controllers and execute <code>Controller.onLaunch</code> callback. <br><pre> <code class="javascript hljs">_.extend(Application.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Fuction that will loop through all application conrollers and create their instances * Additionaly, read the list of models and collections from each controller * and save the reference within application */</span></span> initializeControllers: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controllers</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.controllers = {}; _.each(controllers, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classReference = resolveNamespace(ctrl), id = ctrl.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>).pop(); <span class="hljs-comment"><span class="hljs-comment">// create new Controller instance and pass reference to the application var controller = new classReference({ id: id, application: this }); controller.views = this.parseClasses(controller.views || []); _.extend(this.models, this.parseClasses(controller.models || [])); _.extend(this.collections, this.parseClasses(controller.collections || {})); this.buildCollections(); this.controllers[id] = controller; }, this); }, /** * Launch all controllers using onLauch callback */ launchControllers: function() { _.each(this.controllers, function(ctrl, id) { ctrl.onLaunch(this); }, this); } ... });</span></span></code> </pre><br><br>  To provide communication between controllers and give the opportunity to subscribe to events from specific components, let's add the <code>Application.addListeners</code> method, which delegates work to our EventBus: <br><pre> <code class="javascript hljs">_.extend(Application.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Abstract fuction that will be called during application lauch */</span></span> addListeners: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">listeners, controller</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventbus.addListeners(listeners, controller) } ... });</code> </pre><br><br>  To work with models and collections, we will need functions for obtaining a reference to an instance, references to a constructor, and a method for creating a new entity.  Consider a specific implementation using models as an example; functions for collections will work in a similar way. <br><pre> <code class="javascript hljs">_.extend(Application.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Getter to retreive link to the particular model instance * If model instance isn't created, create it */</span></span> getModel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._modelsCache = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._modelsCache || {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._modelsCache[name], modelClass = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getModelConstructor(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!model &amp;&amp; modelClass) { model = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createModel(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._modelsCache[name] = model; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model || <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }, <span class="hljs-comment"><span class="hljs-comment">/** * Getter to retreive link to the particular model consturctor */</span></span> getModelConstructor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.models[name]; }, <span class="hljs-comment"><span class="hljs-comment">/** * Function to create new model instance */</span></span> createModel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelClass = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getModelConstructor(name), options = _.extend(options || {}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> modelClass(options); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model; }, <span class="hljs-comment"><span class="hljs-comment">/** * Getter to retreive link to the particular collection instance * If collection instance isn't created, create it */</span></span> getCollection: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ ... }, <span class="hljs-comment"><span class="hljs-comment">/** * Getter to retreive link to the particular collection consturctor */</span></span> getCollectionConstructor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ ... }, <span class="hljs-comment"><span class="hljs-comment">/** * Function to create new collection instance */</span></span> createCollection: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, options</span></span></span><span class="hljs-function">) </span></span>{ ... }, ... });</code> </pre><br><br>  Now, our basic application constructor is ready.  The <code>Application.parseClasses</code> method should be mentioned.  The fact is that I decided to transfer lists of controllers, models, collections and view as an array of strings.  Getting at the entrance <br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'myApplication.controller.UserManager'</span></span>, <span class="hljs-string"><span class="hljs-string">'myApplication.controller.FormBuilder'</span></span> ]</code> </pre><br>  The Application.parseClasses function will turn this array into a mapping. <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">'UserManager'</span></span>: myApplication.controller.UserManager, <span class="hljs-string"><span class="hljs-string">'FormBuilder'</span></span>: myApplication.controller.FormBuilder }</code> </pre><br><br>  So I solve 2 problems.  First, all links will automatically be associated with a unique identifier that is equal to the name of the constructor.  This will save the developer from having to bother with the names for each individual entity.  Secondly, we can determine the basic parts, without waiting until they are available.  This will allow you to upload files in random order.  Parsing names into links will occur only after all the scripts have been loaded. <br><br><h4>  Controller implementation </h4><br>  The controller will get a little simpler code, so we delegate all work with models and collections to <code>Application</code> .  To start the announcement: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Controller = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ _.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, options || {}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialize.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); };</code> </pre><br>  And then you can expand the prototype <br><pre> <code class="javascript hljs">_.extend(Controller.prototype, { <span class="hljs-attr"><span class="hljs-attr">views</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">models</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">collections</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ }, <span class="hljs-comment"><span class="hljs-comment">/** * Add new listener to the application event bus */</span></span> addListeners: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">listeners</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getApplication().addListeners(listeners, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-comment"><span class="hljs-comment">/** * Abstract fuction that will be called during application lauch */</span></span> onLaunch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">application</span></span></span><span class="hljs-function">) </span></span>{ }, <span class="hljs-comment"><span class="hljs-comment">/** * Getter that will return the reference to the application instance */</span></span> getApplication: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application; } });</code> </pre><br><br>  Add methods to work with Views: <br><pre> <code class="javascript hljs">_.extend(Controller.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Getter that will return the reference to the view constructor */</span></span> getViewConstructor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.views[name]; }, <span class="hljs-comment"><span class="hljs-comment">/** * Function to create a new view instance * All views are cached within _viewsCache hash map */</span></span> createView: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getViewConstructor(name), options = _.extend(options || {}, { <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: name }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> view(options); } ... });</code> </pre><br><br>  We delegate work with models and collections to our <code>Application</code> <br><pre> <code class="javascript hljs">_.extend(Controller.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to get model instance reference */</span></span> getModel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.getModel(name); }, <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to get model constructor reference */</span></span> getModelConstructor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.getModelConstructor(name); }, <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to create model instance */</span></span> createModel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.createModel(name) }, <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to get collection instance reference */</span></span> getCollection: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.getCollection(name); }, <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to get collection constructor reference */</span></span> getCollectionConstructor: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.getCollectionConstructor(name); }, <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to create collection instance */</span></span> createCollection: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.createCollection(name); } ... });</code> </pre><br><br>  And finally, let our controllers communicate using <code>Application.EventBus</code> <br><pre> <code class="javascript hljs">_.extend(Controller.prototype, { ... <span class="hljs-comment"><span class="hljs-comment">/** * Delegate method to fire event */</span></span> fireEvent: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">selector, event, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.application.eventbus.fireEvent(selector, event, args); } ... });</code> </pre><br>  The base constructor for the controller is ready!  Very little is left :) <br><br><h4>  EventBus implementation </h4><br>  To begin with we will describe the designer.  To enable the controller to listen to events from the view, we need to slightly extend the basic <code>Backbone.View</code> prototype.  The fact is that we need a certain selector by which events will be tracked.  To do this, we introduce the <code>alias</code> property, which will automatically be assigned when the component is created.  And add the <code>fireEvent</code> method, which will call the ‚Äúnative‚Äù <code>View.trigger()</code> and <code>EventBus</code> about the new event. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EventBus = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; _.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, options || {}); <span class="hljs-comment"><span class="hljs-comment">// Extend Backbone.View.prototype _.extend(Backbone.View.prototype, { alias: null, /* * Getter that wll return alias */ getAlias: function() { return this.options.alias; }, /* * Instead of calling View.trigger lets use custom function * It will notify the EventBus about new event */ fireEvent: function(event, args) { this.trigger.apply(this, arguments); me.fireEvent(this.getAlias(), event, args); } }); };</span></span></code> </pre><br><br>  Now you can safely extend the prototype.  We use <code>EventBus.addListeners</code> to subscribe to new events, and <code>EventBus.fireEvent</code> wears the necessary handler and executes it. <br><pre> <code class="javascript hljs">_.extend(EventBus.prototype, { <span class="hljs-comment"><span class="hljs-comment">// Hash Map that will contains references to the all reginstered event listeners pool: {}, /** * Function to register new event listener */ addListeners: function(selectors, controller) { this.pool[controller.id] = this.pool[controller.id] || {}; var pool = this.pool[controller.id]; if(_.isArray(selectors)) { _.each(selectors, function(selector) { this.control(selector, controller); }, this) } else if(_.isObject(selectors)) { _.each(selectors, function(listeners, selector) { _.each(listeners, function(listener, event) { pool[selector] = pool[selector] || {}; pool[selector][event] = pool[selector][event] || []; pool[selector][event].push(listener); }, this); }, this) } }, /** * Function to execute event listener */ fireEvent: function(selector, event, args) { var application = this.getApplication(); _.each(this.pool, function(eventsPoolByAlias, controllerId) { var events = eventsPoolByAlias[selector]; if(events) { var listeners = events[event] controller = application.getController(controllerId); _.each(listeners, function(fn) { fn.apply(controller, args); }); } }, this); }, /** * Getter to receive the application reference */ getApplication: function() { return this.options['application']; } });</span></span></code> </pre><br><br>  Hooray!  Now all the main parts are implemented!  Final touch <br><pre> <code class="javascript hljs">Application.extend = Backbone.Model.extend; Controller.extend = Backbone.Model.extend;</code> </pre><br>  Now we can create inherit from our basic constructors using the <code>extend</code> function. <br><br><h4>  Documentation and examples </h4><br><br>  <a href="">Source files</a> and <a href="">documentation</a> on the official <a href="https://github.com/namad/Backbone.Application">Backbone.Application</a> page <br><br>  I also created a simple <a href="http://namad.github.com/Backbone.Application/examples/ToDo/">example</a> - this is classic ToDo using MVC.  Source code and comments for implementation can be viewed here - <a href="">github.com/namad/Backbone.Application/blob/master/examples/ToDo/js/todos.js</a> <br><br>  And as a bonus, a more complex example, for which I wrote this whole bike - <a href="http://namad.github.com/visualHUD/">visualHUD</a> , the HUD editor for my favorite game Quake Live.  At the moment, the new version is still in development, you need to finish a bunch of small things, but in general, all the functionality works and you can feel it with your own hands.  Who cares, the source of the old version of the <a href="http://code.google.com/p/visualhud/source/browse/">Google code</a> <br><br>  <i>PS This is my first article of a similar nature and I have no idea what happened :) So any adequate feedback is worth its weight in gold.</i>  <i>Thank!</i> </div><p>Source: <a href="https://habr.com/ru/post/149626/">https://habr.com/ru/post/149626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149620/index.html">Business is like football</a></li>
<li><a href="../149621/index.html">Making a standalone exe on IronPython</a></li>
<li><a href="../149622/index.html">Runetology (160): co-founder of MoySklad service, Askar Rakhimberdiev</a></li>
<li><a href="../149624/index.html">The real Android problem</a></li>
<li><a href="../149625/index.html">Reflections on Design</a></li>
<li><a href="../149627/index.html">Graphic framework. Social services icons set</a></li>
<li><a href="../149628/index.html">Double star nanoCAD: free 3.7 and paid 4.0</a></li>
<li><a href="../149629/index.html">How to earn more!</a></li>
<li><a href="../149630/index.html">C # combinator library</a></li>
<li><a href="../149631/index.html">CocoaPods - a powerful tool in the hands of an Objective-C developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>