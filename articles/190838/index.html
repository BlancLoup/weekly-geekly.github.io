<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Are there any reasons to use a statically typed functional programming language?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fact, in a sense, this question does not make sense in 2010, when most (or most of the most common) languages ‚Äã‚Äãare languages ‚Äã‚Äãof many paradigms. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Are there any reasons to use a statically typed functional programming language?</h1><div class="post__text post__text-html js-mediator-article">  In fact, in a sense, this question does not make sense in 2010, when most (or most of the most common) languages ‚Äã‚Äãare languages ‚Äã‚Äãof many paradigms.  Why limit yourself only functional programming?  Perhaps someone will find the answer obvious, but if such articles appear as " <a href="http://habrahabr.ru/post/190492/">Ten reasons not to use a statically typed functional programming language,</a> " then you will have to discuss and explain the opposite point of view.  "Ten reasons ..." are based on irony and, it seems, the author implies that these shortcomings do not even require discussion, but only ironic remarks.  But it is not, let's go for these ten reasons. <br><a name="habracut"></a><br><h4>  Reason 1. I do not want to follow the latest trends. </h4><br>  The most ridiculous reason.  And, strictly speaking, why should I follow the trends?  And how?  Multithreading for some was a discovery in the 2000s (although the problem itself existed before) and seemed to be a trend.  But some people still haven't come across it so far.  Not because they are not ‚Äúfashionable‚Äù (ie, in trend) programmers, there were simply no such tasks: either a single-user application, or the container was watching it.  And someone did not have time to saddle Web programming, someone did not have time to follow mobile developments.  Can you as a developer keep up with all the trends at once?  You can, but you have a choice: either pick up on the tops, or delve into one topic.  Or be in the middle.  But not all at the same time.  Perhaps it was meant that the functional approach is so fundamental that any programmer should know about it.  This is more like the truth, but there is no need to appeal to trends. <br><br>  But is this trend so important?  And is it possible to convince someone that ‚Äúa new fashionable language will soon conquer the world‚Äù?  It may be a revelation to someone, but the syntax or style of the language has rarely been the basis for distribution or popularity.  Perhaps in the '60s and' 80s, when various programming styles just appeared, but not now.  Let's look at the list of the most common (popular) languages ‚Äã‚Äãat the moment: <br><br>  C / C ++ - Although both of their popularity should be grateful to the syntax, but this is a matter of the distant past.  Yes, the C syntax allowed us to write more compact code (but unlike the arguments in favor of a functional language, it provided a shorter expression for the same language constructs that existed before, and did not remove them at all).  Yes, the C ++ syntax was, in a sense, ‚Äúsyntactic sugar‚Äù over C, which resented adherents of C and for a long time there were disputes about performance C against C ++.  But, in the end, this pair of languages ‚Äã‚Äãis still alive, because a lot of compilers have been created for various platforms, and they are a natural choice for anyone who is interested in performance, first of all, since the output is an executable file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Objective-C - Popularity is based on binding to the Apple platform. <br><br>  Java - Practically at least a new syntax compared to C ++, but ‚Äúonce written, it will start everywhere‚Äù (and, yes, it works).  Plus applets (which eventually failed, but which were precursors of Flash and HTML5).  Plus, mobile development (because I needed a language with portability for very different phones).  In addition, I found a niche on the server side and enterprayze. <br><br>  C # - Another clone of C ++, all the ‚Äúsugar‚Äù appeared later, and the prevalence is based on binding to Windows.  Mono?  Are you sure that the task of launching absolutely any program written in C # will ever be achieved?  And this is taking into account that .Net is developing with its speed, while Mono is trying to keep up.  In addition, many libraries are very much tied to Windows. <br><br>  PHP / Ruby - Two languages ‚Äã‚Äãthat are tied to Web development.  Many people do not like the fact that they are in the same pair, but this is the harsh truth of life.  And, by the way, dislike for PHP among a certain number of programmers is explained by the ‚Äúbad‚Äù syntax of the language.  What does not prevent it from being more popular than any functional language.  Although, paradoxically, but PHP became popular precisely because of the ‚Äúsimple‚Äù syntax and rapid development of Web applications. <br><br>  JavaScript - Another language linked to the Web, but on the browser side.  And with which, you want - you don't want, almost any Web developer should be familiar.  But there are miscalculations in design.  And nothing lives.  Moreover, in recent years, he even began to live outside the browser and be a separate language.  Why?  How is it worse Python? <br><br>  Python / Perl - Two languages ‚Äã‚Äãthat were originally "scripting" (as an alternative to Shell languages) and Web-oriented.  But, gradually, Perl began to die off, precisely because of its shorter and sometimes esoteric syntax.  Think about it.  There is still some sort of syntax brevity. <br><br>  Visual Basic - Binding to the Windows / Office platform. <br><br>  Shell - Binding to Unix. <br><br>  Assembler - Ability to write the most effective code for any device.  Again, in many ratings, more popular than any functional language. <br><br>  The conclusion is obvious: languages ‚Äã‚Äãhave become popular / widespread not through syntax, but through practical application.  The current trend of using functional programming is not based on the ‚Äúunexpected‚Äù discovery of the functional style itself, but on the fact that OOP purists did not add functionality to languages, although initially they included elements of OOP and procedural programming. <br><br><h4>  Reason 2. I get paid for lines of code. </h4><br>  If you get paid for the lines of code, then you should definitely change jobs, if only because if management incorrectly assesses work efficiency (as in this case), then you may have problems in the future. <br><br>  Speaking seriously, what are ‚Äúlines of code‚Äù?  For example, I have an application with 100 lines of code, I found a library that reduced them to 5. And no functional programming.  And maybe I even found 5 more libraries that do the same and reduce the code to 3, 7, 10, 15 and 8 lines of code.  Whether to choose the shortest or which has the best support, more options, provides better performance, etc.? <br><br>  If to speak even more seriously, for some reason, many consider brevity to be an unambiguous advantage of the code.  Yes, we have seen odious examples of such ‚Äúbeauty‚Äù in C, Pearl and other languages.  All this is beautiful for a joke or charade, but not for long-term development.  Who can read and understand correctly?  Who will support?  Why do some people draw an analogy between ‚Äúshort code‚Äù and ‚Äúgood code‚Äù?  Sometimes she is, sometimes she is not. <br><br>  In many cases, the brevity and clarity of the code are polar concepts.  The shorter the code, the more confusing it is, and the more clearly everything is written, the clearer it is.  Although it happens the other way around.  Is it possible at the same time short and clear code?  It depends on what you mean.  Look at the natural language.  Is it possible to express the meaning of the novel in one phrase?  Probably you can, just come out funny.  Is it possible to substitute the participle verb or other structure?  Of course, it is possible, but this is a matter of style - and you always have a choice in natural language. <br><br>  And does brevity depend on a programming language?  If you have three calls to functions or methods that describe the behavior of the domain, then you cannot simply take and replace them with one if this is not possible.  And if possible, it‚Äôs not a problem to reduce them in any programming language.  And does it really depend a lot on the syntax of a programming language?  If you have to write your own algorithm, then either you do not know about the existence of a library that solves this problem, or there is no such library in your programming language, or you have not written your own library that solves this problem.  A library call looks the same in almost any language, with the exception of ryushechek in the form of punctuation. <br><br><h4>  Reason 3. I love braces. </h4><br>  Surprised by this "serious" argument.  If you work with the language for quite a long time, then you automatically put all the brackets, and often the editor itself does it for you.  So what difference does it make or not?  Moreover, many believe that even in a single-line block of code (after a condition or iteration) it is necessary to put curly brackets so that the boundaries of the block are clearly visible and that there are fewer errors when the code is inserted into the wrong block. <br><br><h4>  Reason 4. I love to see explicit types. </h4><br>  I do not like to see explicit types, but I love that the compiler sees explicit types.  I don't want him to lose control of the types.  It protects me in many situations.  But, of course, it's beautiful when the types are implicit and everything somehow works behind the scenes.  But the price of beauty: the loss of control over how it all works.  And in many cases, the price of beauty is performance and implicit operations.  And yes, I want to see that the method will return to me from a library that I did not write, or even say a type of expression that includes variables declared somewhere else in the program.  I do not want to guess whether it will be a string or a list of objects. <br><br><h4>  Reason 5. I like to fix bugs. </h4><br><h4>  Reason 6. I live in a debugger. </h4><br>  Perhaps these are the most serious arguments.  If this were true, then I think millions of developers would want to immediately switch to functional languages.  But let me doubt that this is so.  Why adherents of functional languages, believe that they have fewer bugs can be read <a href="http://www.simontylercousins.net/journal/2013/3/7/why-bugs-dont-like-f.html">here</a> and <a href="http://www.haskell.org/haskellwiki/Why_Haskell_just_works">here</a> .  Arguments come down to <br><br>  - no null s (solved by static code analysis) <br>  - immutable data (available in all programming languages, but this approach is not always possible, especially when it comes to performance and memory allocation problems) <br>  - very strict type system (‚Äúvery‚Äù is already a subjective word, therefore we leave this argument on the authors' conscience) <br>  - composition of small functions (lambda functions already exist in C # and other languages, will soon be in Java) <br>  - abstraction of asynchronous programming (this is only a question of abstraction, everything can be done using the library) <br>  - higher order functions for collections (available in C # and other languages, and will be in Java) <br>  - units of measure (valid for F #, not applicable to all tasks) <br>  - the order of operations is clearly expressed in the code (no problem to use in any programming language, but in it we will have the choice to use this approach or not) <br><br>  For some reason, all the errors here are reduced to more likely code or data errors, although from my experience, most of the errors are related more to behavior, rules, interaction between objects.  What is the difference what programming language, if your algorithm turned out in field 5, but should be 3?  Such errors are well treated not by ‚Äúgood‚Äù syntax, but by unit tests and development through testing.  Although for adherents of the functional style, <a href="http://www.simontylercousins.net/journal/2011/3/20/tdd-challenged.html">TDD is replaced by the REPL</a> , but it is not clear how the REPL helps when the meaning of the code can change several times after writing? <br><br>  These arguments are reminiscent of the promises of a ‚Äúbeautiful life‚Äù without bugs in tongues with garbage collectors.  Yes, there are fewer incomprehensible memory bugs, but, by and large, they simply turned into a zero-point exception.  Yes, memory leaks have become much less, but, by and large, they are still in long-lived applications.  Of course, you began to think less about the distribution of memory, but you cannot say that you should not think about it at all. <br><br><h4>  Reason 7. I don't want to think about every little thing. </h4><br>  Again an emotional argument.  All this depends more on the developer, not on the language. <br><br><h4>  Reason 8. I like to check for null. </h4><br>  Very ambiguous argument.  Imagine that you have a task to dig a hole, according to an algorithm you have an excavator.  Analogue null-a - the absence of a digger.  If not, then yes, I want the whole task to be interrupted, this is an exception.  I do not want quiet execution, as if there is a digger, but the pit has not been dug.  You will say that such situations are also monitored in functional languages.  But, excuse me, what difference does it make: do I check null or something else?  Good or bad, but checking for null sometimes has semantics, and is not just a check for the presence of an object.  Yes, in any programming language, instead of null, you can return a dummy null value (Null object pattern), but think carefully about whether to do it: it's easier to catch an obvious error than an implicit one. <br><br><h4>  Reason 9. I apply design patterns everywhere. </h4><br>  Is it a secret that many design patterns are the result of object-oriented programming features?  And aren't closures, monads, or currying, also templates of functional programming only?  And it is possible that many templates of functional programming still await us in the future - who knows? <br><br><h4>  Reason 10. Too much math. </h4><br>  This is also a rather emotional argument.  Mathematics is in any programming language.  Another thing is that in order to prove the beauty of functional programming, most often examples of pure mathematics are given, or only algorithmic problems (I don‚Äôt even know whether the entire sorting algorithm is mathematics or not).  But who solves the algorithmic problems in the 2010s?  Knuth's book is over 40 years old, and you still write sorting algorithms?  Use libraries, do not reinvent the wheel. <br><br>  I can not assess whether monads and functors are a problem for other people to understand, but if, yes, then functional programming is doomed to remain the lot of the elect.  What should rather grieve than to please those chosen ones.  The fewer people who can master these concepts, the less likely functional languages ‚Äã‚Äãare.  Lisp is already 50 years old, and he is still waiting for his finest hour.  And also has always been the lot of the elect.  Think about it. <br><br><h4>  Conclusion </h4><br>  Of course, the functional style has a bright future.  Rather, it is surprising that it did not come even 20 years ago.  And it is even more surprising to speak 60 years after the appearance of the first functional language. <br><br>  Perhaps, designers of programming languages ‚Äã‚Äã20 years ago believed that an obvious confusion of concepts was fraught with problems or simply wanted to preserve the ‚Äúpurity‚Äù of languages.  However, the 2010s are in the courtyard, and the languages ‚Äã‚Äãof many paradigms run the show.  And this is good.  Because, by and large, whether to use ‚Äúnouns‚Äù (as in OOP) or ‚Äúverbs‚Äù (as in FP) in the first place is my choice.  I do not want to choose between objects and functions, I want to use them, depending on the tasks at hand. <br><br>  After all, the pure functional programming of many just scares its "beauty".  Here it is useful to recall the story of Smalltalk, which is also a ‚Äúclean‚Äù OOP language, unlike C ++, Java, C #.  But that never ‚Äútook off‚Äù, unlike languages, which did not reject elements of the procedural approach.  Partly, because not all tasks require a ‚Äúpure‚Äù approach, and sometimes it is not applicable at all.  In addition, this usually involves the use of abstractions with implicit operations behind the scene, which usually threaten not very good performance.  And, if in your practice you met with tasks to implement a GUI in a logical language (like the Prologue) or Web development on Lisp, then you yourself must present the whole complexity of ‚Äúcramming in‚Äù.  However, it is worth noting that F #, mentioned in the original article, is also a language of many paradigms, and not a ‚Äúpure‚Äù functional language. <br><br>  Perhaps you admire another trend: a multitude of programming languages ‚Äã‚Äãbased on JVM or .Net platforms.  Of course, this is a plus, that you can write with any syntactic sugar, but receive the same byte-code.  However, it all depends on the implementation of the programming language - it can use multi-way combinations for one call or be based on reflection, which is fraught with performance problems.  Besides, who needs this variety of languages?  Why do we need ten functional programming languages ‚Äã‚Äãonly with different brackets, commas and colons?  No, in fact. <br><br>  You can create a simple program in a new language in 1 day, learn to write more or less in 1 week, master in 1 month, and master well in 1 year.  After all, the problem is not only in syntax, but also in numerous nuances, ‚Äúcorrect‚Äù calls of ‚Äúcorrect‚Äù functions, and much more.  Why, you jump from one language to another?  And if in each project?  And if every half a year?  Of course, this is an intellectual challenge.  But whether all employers agree to pay for your internal needs for an intellectual challenge is a question.  Although the matter is not even in employers, but even in you - because every time you have to simultaneously solve the problems of the subject area and the problems of entering a new programming language.  And in return, you expect a hazy future (maybe you will never need a new language in the future) and the same hazy past (it is possible that you will already forget the experience of working with previous languages).  Again, there is the problem of supporting the code - how to find a person who understands the code, or who could learn to understand in minimal time. <br><br>  However, if you refer to history, then the Babylonian pandemonium of languages ‚Äã‚Äãwas always.  Some were born, some were dying.  Who remembers Algol or PL / 1 now?  But there were still many others.  Programming languages ‚Äã‚Äãhave their own evolution, and the strongest among them also survive.  And the strongest are not languages ‚Äã‚Äãwith beautiful syntax, but which is necessary.  Such a need for functional languages ‚Äã‚Äãmay be associated with reduced development time and fewer bugs, as described <a href="http://www.simontylercousins.net/journal/2013/2/22/does-the-language-you-choose-make-a-difference.html">here</a> .  However, the evidence presented is based on certain projects in a vacuum, so it is absolutely incomprehensible what the numbers of the lines of code mean.  Therefore, the answer to the article‚Äôs topic is rather ‚Äúno more than yes, but the future will judge us.‚Äù </div><p>Source: <a href="https://habr.com/ru/post/190838/">https://habr.com/ru/post/190838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190824/index.html">Color as a factor in labor efficiency</a></li>
<li><a href="../190826/index.html">He himself invented - he patented himself</a></li>
<li><a href="../190830/index.html">Binary watch with alarm clock on Atmega48 (EvILeg-1124)</a></li>
<li><a href="../190832/index.html">Metric # 19 - Podcast on technologies and design of interfaces and services</a></li>
<li><a href="../190834/index.html">Oracle Java SE 7 Programmer II Exam Preparation (1Z0-804)</a></li>
<li><a href="../190840/index.html">The line between UI and UX</a></li>
<li><a href="../190842/index.html">Webinar vs. live meeting</a></li>
<li><a href="../190850/index.html">Brute force optimization</a></li>
<li><a href="../190852/index.html">ROSA Media Player in Ubuntu. We collect from source codes</a></li>
<li><a href="../190854/index.html">LG Optimus L5 II Dual review: budget smartphone with a number of strange features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>