<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RHEL 8 Beta Workshop: We build working web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RHEL 8 Beta offers developers a lot of new features, which can take pages to list, however, it is always better to learn new things in practice, so we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RHEL 8 Beta Workshop: We build working web applications</h1><div class="post__text post__text-html js-mediator-article">  RHEL 8 Beta offers developers a lot of new features, which can take pages to list, however, it is always better to learn new things in practice, so we offer the following practical training to create real application infrastructure based on Red Hat Enterprise Linux 8 Beta. <br><br><img src="https://habrastorage.org/webt/h9/gm/gv/h9gmgvu8uau6n5dgvseh-yop_-4.jpeg" width="100%"><br><br>  Take Python, a combination of Django and PostgreSQL, a fairly common link for building applications, and configure RHEL 8 Beta to work with them.  Then add a couple more (non-secret) ingredients. <br><a name="habracut"></a><br>  The test environment will change, because it is curious to explore the possibilities of automation, working with containers and try environments with several servers.  To start working with a new project, you can start by creating a small simple prototype manually - this way you can see what exactly should happen and how the interaction takes place, and then move on to automating and creating more complex configurations.  Today, the story of the creation of such a prototype. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Begin by deploying the RHEL 8 Beta VM virtual machine image.  You can install a virtual machine from scratch, or use a KVM guest image that is available with a Beta subscription.  When using a guest image, you will need to configure a virtual CD, which will contain metadata and user data for cloud initialization (cloud-init).  You do not need to do anything special with the disk structure or available packages, any configuration will do. <br><br>  Let's look at the whole process in more detail. <br><br><h3>  Install django </h3><br>  The latest version of Django will require a virtual environment (virtualenv) with Python 3.5 or later.  In the Beta notes you can see that Python 3.6 is available, let's check if this is really the case: <br><br><pre><code class="plaintext hljs">[cloud-user@8beta1 ~]$ python -bash: python: command not found [cloud-user@8beta1 ~]$ python3 -bash: python3: command not found</code> </pre> <br>  Red Hat actively uses Python as a system tool in RHEL, so why is this result? <br><br>  The fact is that many developers using Python are still thinking about switching from Python 2 to Python 2, while Python 3 itself is under active development, and more and more new versions are constantly appearing.  Therefore, in order to satisfy the need for stable system tools, and at the same time offer users access to various new versions of Python, system Python was transferred to a new package and provided the ability to install both Python 2.7 and 3.6.  More information about the changes and why this was done can be found in a <a href="https://developers.redhat.com/blog/2018/11/27/what-no-python-in-rhel-8-beta/">blog post by Langdon White</a> . <br><br>  So, to get a working Python, you need to install only two packages, while the python3-pip will pull up in the form of a dependency. <br><br><pre> <code class="plaintext hljs">sudo yum install python36 python3-virtualenv</code> </pre><br>  Why should you not use direct calls to the module, as Langdon suggests, and not install pip3?  Keeping in mind the upcoming automation, it is known that Ansible will require an installed pip, since the pip module does not support virtual environments (virtualenvs) with a custom pip executable file. <br><br>  With a working python3 interpreter at your disposal, you can continue the Django installation process and get a working system along with our other components.  The network presents many options for implementation.  One version is presented here, but users can use their own processes. <br><br>  PostgreSQL and Nginx versions that are available in RHEL 8 will be installed by default using Yum. <br><br><pre> <code class="plaintext hljs">sudo yum install nginx postgresql-server</code> </pre><br>  PostgreSQL requires psycopg2, but you only need it to be available in virtualenv environment, so we will install it using pip3 with Django and Gunicorn.  But first we need to set up virtualenv. <br><br>  There is always a lot of controversy about choosing the right place to install Django projects, but when there are any doubts, you can always refer to the Linux Filesystem Hierarchy Standard.  In particular, the FHS states that / srv is used for: ‚Äústoring site-specific data ‚Äî data that the system issues, for example, web server data and scripts, data stored on FTP servers, and control system repositories versions (appeared in FHS-2.3 in 2004). ‚Äù <br><br>  This is our case, so we add everything we need to / srv, which is owned by our application user (cloud-user). <br><br><pre> <code class="plaintext hljs">sudo mkdir /srv/djangoapp sudo chown cloud-user:cloud-user /srv/djangoapp cd /srv/djangoapp virtualenv django source django/bin/activate pip3 install django gunicorn psycopg2 ./django-admin startproject djangoapp /srv/djangoapp</code> </pre><br>  Setting up PostgreSQL and Django is easy: create a database, create a user, set up permissions.  There is one thing to keep in mind during the initial installation of PostgreSQL ‚Äî the postgresql-setup script, which is installed along with the postgresql-server package.  This script helps you perform basic tasks associated with administering a cluster of databases, such as initializing a cluster or the upgrade process.  To set up a new PostgreSQL instance on the RHEL system, we need to run the command: <br><br><pre> <code class="plaintext hljs">sudo /usr/bin/postgresql-setup -initdb</code> </pre><br>  After that, you can run PostgreSQL using systemd, create a database and set up a project in Django.  Remember to restart PostgreSQL after making changes to the client authentication configuration file (usually pg_hba.conf) to configure the storage of the password for the application user.  If you encounter other difficulties, make sure to change the IPv4 and IPv6 settings in the pg_hba.conf file. <br><br><pre> <code class="plaintext hljs">systemctl enable -now postgresql sudo -u postgres psql postgres=# create database djangoapp; postgres=# create user djangouser with password 'qwer4321'; postgres=# alter role djangouser set client_encoding to 'utf8'; postgres=# alter role djangouser set default_transaction_isolation to 'read committed'; postgres=# alter role djangouser set timezone to 'utc'; postgres=# grant all on DATABASE djangoapp to djangouser; postgres=# \q</code> </pre><br>  In the /var/lib/pgsql/data/pg_hba.conf file: <br><br><pre> <code class="plaintext hljs"># IPv4 local connections: host all all 0.0.0.0/0 md5 # IPv6 local connections: host all all ::1/128 md5</code> </pre><br>  In the /srv/djangoapp/settings.py file: <br><br><pre> <code class="plaintext hljs"># Database DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': '{{ db_name }}', 'USER': '{{ db_user }}', 'PASSWORD': '{{ db_password }}', 'HOST': '{{ db_host }}', } }</code> </pre><br>  After configuring the settings.py file in the project and setting up the database configuration, you can start the development server to make sure everything works.  After starting the development server, it is nice to create the admin user to test the database connection. <br><br><pre> <code class="plaintext hljs">./manage.py runserver 0.0.0.0:8000 ./manage.py createsuperuser</code> </pre><br><h3>  WSGI?  Wai? </h3><br>  The development server is useful for testing, but to run the application you need to configure the appropriate server and proxy for the Web Server Gateway Interface (WSGI).  There are several common links, for example, Apache HTTPD with uWSGI or Nginx with Gunicorn. <br><br>  The goal of the Web Server Gateway Interface is to redirect requests from the web server to the Python web framework.  WSGI is such a legacy of a terrible past, when CGI mechanisms were in use, and today WSGI is actually a standard, regardless of the web server used or the Python framework.  But despite its wide distribution, there are still many nuances when working with these frameworks, and many choices.  In this case, we will try to establish interaction between Gunicorn and Nginx through a socket. <br><br>  Since both of these components are installed on the same server, try using a UNIX socket instead of a network socket.  Since for communications, in any case, we need a socket, we will try to take another step and configure the activation of a socket for Gunicorn via systemd. <br><br>  The process of creating socket activated services is quite simple.  First, a unit-file is created that contains a ListenStream directive indicating the point at which the UNIX socket will be created, then a unit-file for the service, in which the directive will point to the unit-file of the socket.  Then, in the unit-file of the service, all that remains is to call Gunicorn from the virtual environment and create a WSGI binding for the UNIX socket and the Django application. <br><br>  Here are some examples of unit files that can be taken as a base.  First we set up a socket. <br><br><pre> <code class="plaintext hljs">[Unit] Description=Gunicorn WSGI socket [Socket] ListenStream=/run/gunicorn.sock [Install] WantedBy=sockets.target</code> </pre><br>  Now you need to configure the gunicorn daemon. <br><br><pre> <code class="plaintext hljs">[Unit] Description=Gunicorn daemon Requires=gunicorn.socket After=network.target [Service] User=cloud-user Group=cloud-user WorkingDirectory=/srv/djangoapp ExecStart=/srv/djangoapp/django/bin/gunicorn \ ‚Äîaccess-logfile - \ ‚Äîworkers 3 \ ‚Äîbind unix:gunicorn.sock djangoapp.wsgi [Install] WantedBy=multi-user.target</code> </pre><br>  For Nginx, simply create proxy configuration files and set up a directory for storing static content, if you use it.  Nginx configuration files in RHEL are /etc/nginx/conf.d.  You can copy the following example there into the /etc/nginx/conf.d/default.conf file, and start the service.  Be sure to specify server_name according to your hostname. <br><br><pre> <code class="plaintext hljs">server { listen 80; server_name 8beta1.example.com; location = /favicon.ico { access_log off; log_not_found off; } location /static/ { root /srv/djangoapp; } location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://unix:/run/gunicorn.sock; } }</code> </pre><br>  Run a Gunicorn socket and Nginx using systemd, and you can begin testing. <br><br><h3>  Bad gateway error? </h3><br>  If you enter the address in the browser, you will most likely receive an error 502 Bad Gateway.  It may be caused by improperly configured permissions for a UNIX socket, or due to more complex problems associated with access control in SELinux. <br><br>  In the nginx error log you can find a line like this: <br><br><pre> <code class="plaintext hljs">2018/12/18 15:38:03 [crit] 12734#0: *3 connect() to unix:/run/gunicorn.sock failed (13: Permission denied) while connecting to upstream, client: 192.168.122.1, server: 8beta1.example.com, request: "GET / HTTP/1.1", upstream: "http://unix:/run/gunicorn.sock:/", host: "8beta1.example.com"</code> </pre><br>  If we test Gunicorn directly, we get an empty answer. <br><br><pre> <code class="plaintext hljs">curl ‚Äîunix-socket /run/gunicorn.sock 8beta1.example.com</code> </pre><br>  Let's see why this happens.  If you open the log, then most likely you will see that the problem is related to SELinux.  Since we have a daemon running for which no policy was created, it is marked as init_t.  Let's test this theory in practice. <br><br><pre> <code class="plaintext hljs">sudo setenforce 0</code> </pre><br>  All this can cause criticism and bloody tears, but this is just a debugging of the prototype.  Turn off the check only to make sure that the problem is exactly this, after which we will return everything back to its place. <br><br>  By refreshing the page in the browser or by restarting our curl command, you can see the Django test page. <br><br>  So, after making sure that everything works, and there are no more permissions problems, we re-enable SELinux. <br><br><pre> <code class="plaintext hljs">sudo setenforce 1</code> </pre><br>  There will be no talk about audit2allow and creating policies based on alerts using sepolgen, because there is currently no real Django application, there is no complete map of what Gunicorn may want to access, and what this access should be denied.  Therefore, it is necessary to save SELinux‚Äôs work to protect the system, and at the same time allow the application to start and leave messages in the audit log so that you can then create a real policy based on them. <br><br><h3>  Specifying Permitted Domains (permissive domains) </h3><br>  Not all heard about the allowed domains in SELinux, but there is nothing new in them.  Many even worked with them, themselves without knowing it.  When a policy is created based on audit messages, the policy created is a permitted domain.  Let's try to create a simple permissive policy. <br><br>  To create a specific allowed domain for Gunicorn, you need some kind of policy, and also need to mark the appropriate files.  In addition, the necessary tools to collect new policies. <br><br><pre> <code class="plaintext hljs">sudo yum install selinux-policy-devel</code> </pre><br>  The mechanism of allowed domains is a great tool for identifying problems, especially when it comes to a custom application or applications that ship without already created policies.  In this case, the allowed domain policy for Gunicorn will be as simple as possible - we will declare the main type (gunicorn_t), declare the type we will use to mark several executable files (gunicorn_exec_t), and then configure the transition for the system to correctly mark the running processes .  The last line sets the policy as allowed by default at the time of its loading. <br><br>  <b>gunicorn.te:</b> <br><pre> <code class="plaintext hljs">policy_module(gunicorn, 1.0) type gunicorn_t; type gunicorn_exec_t; init_daemon_domain(gunicorn_t, gunicorn_exec_t) permissive gunicorn_t;</code> </pre><br>  You can compile this policy file and add it to the system. <br><br><pre> <code class="plaintext hljs">make -f /usr/share/selinux/devel/Makefile sudo semodule -i gunicorn.pp sudo semanage permissive -a gunicorn_t sudo semodule -l | grep permissive</code> </pre><br>  Let's check if SELinux is blocking something else besides what our unknown demon is referring to. <br><br><pre> <code class="plaintext hljs">sudo ausearch -m AVC type=AVC msg=audit(1545315977.237:1273): avc: denied { write } for pid=19400 comm="nginx" name="gunicorn.sock" dev="tmpfs" ino=52977 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:var_run_t:s0 tclass=sock_file permissive=0</code> </pre><br>  SELinux does not allow Nginx to write data to the UNIX socket used by Gunicorn.  Usually, in such cases, they begin to change policies, but other tasks still lie ahead.  You can also change the settings of a domain, turning it from a domain of restrictions into a domain of permissions.  Now we will transfer httpd_t to the permission domain.  This will provide Nginx with the necessary access, and we will be able to continue further debugging work. <br><br><pre> <code class="plaintext hljs">sudo semanage permissive -a httpd_t</code> </pre><br>  So, when you managed to save SELinux protection (in fact, you should not leave the project with SELinux in restriction mode) and the permission domains are loaded, you need to find out what you need to mark as gunicorn_exec_t in order for everything to work again as expected.  Let's try to access the website to see new messages about access restrictions. <br><br><pre> <code class="plaintext hljs">sudo ausearch -m AVC -c gunicorn</code> </pre><br>  You can see a lot of messages containing 'comm = "gunicorn"' that perform various actions on files in / srv / djangoapp, so obviously, this is just one of the commands that should be marked. <br><br>  But in addition, a message appears like this: <br><br><pre> <code class="plaintext hljs">type=AVC msg=audit(1545320700.070:1542): avc: denied { execute } for pid=20704 comm="(gunicorn)" name="python3.6" dev="vda3" ino=8515706 scontext=system_u:system_r:init_t:s0 tcontext=unconfined_u:object_r:var_t:s0 tclass=file permissive=0</code> </pre><br>  If you look at the status of the gunicorn service or run the ps command, then no running processes will appear.  It seems that gunicorn is trying to access the Python interpreter in our virtualenv environment, possibly to run workers (workers).  Therefore, we now mark these two executable files and check whether we can open our test page Django. <br><br><pre> <code class="plaintext hljs">chcon -t gunicorn_exec_t /srv/djangoapp/django/bin/gunicorn /srv/djangoapp/django/bin/python3.6</code> </pre><br>  You will need to restart the gunicorn service so that you can select a new tag.  You can restart it immediately or stop the service and let the socket start when the site is opened in the browser.  Make sure the processes get the correct labels using ps. <br><br><pre> <code class="plaintext hljs">ps -efZ | grep gunicorn</code> </pre><br>  Do not forget to create a normal SELinux policy! <br><br>  If you look at AVC messages now, then the last message contains permissive = 1 for everything related to the application, and permissive = 0 for the rest of the system.  If you understand what kind of access is needed for a real application, you can quickly find the best way to solve such problems.  But until then, it‚Äôs best to have the system protected and to get a understandable and usable audit of the Django project. <br><br><pre> <code class="plaintext hljs">sudo ausearch -m AVC</code> </pre><br><h3>  Happened! </h3><br>  A working Django project with Nginx and Gunicorn WSGI front-end appeared.  We configured Python 3 and PostgreSQL 10 from the RHEL 8 Beta repositories.  Now you can go ahead and create (or simply deploy) Django applications or explore other available tools in RHEL 8 Beta to automate the configuration process, improve performance, or even containerize this configuration. </div><p>Source: <a href="https://habr.com/ru/post/447540/">https://habr.com/ru/post/447540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447526/index.html">Your bike to sync MariaDB and Sphinx</a></li>
<li><a href="../447528/index.html">Who is responsible for the quality?</a></li>
<li><a href="../447530/index.html">OceanLotus: Malvari update for macOS</a></li>
<li><a href="../447536/index.html">IdM implementation. Preparation for implementation by the customer</a></li>
<li><a href="../447538/index.html">CUBA 7: what's new?</a></li>
<li><a href="../447546/index.html">Bowers & Wilkins PX. Belated Neobzor</a></li>
<li><a href="../447548/index.html">How justified is the introduction of VDI in small and medium-sized businesses?</a></li>
<li><a href="../447552/index.html">How to optimize catalog sections in an online store: step-by-step instructions</a></li>
<li><a href="../447554/index.html">An overview of the new features of NestJS 6</a></li>
<li><a href="../447556/index.html">Mypy extension with plugins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>