<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Design and architecture in the OP. Introduction and Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the world of functional programming, there is one big gap, namely, the topic of high-level design of large applications is almost no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Design and architecture in the OP. Introduction and Part 1</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  In the world of functional programming, there is one big gap, namely, the topic of high-level design of large applications is almost not covered.  I decided to study this question for myself.  Are there significant differences in the <a href="http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell">design of applications in the OP world</a> from that in the imperative world?  What is a ‚Äúcanonical opcode‚Äù?  What are the development idioms, does it make sense to talk about design patterns <a href="http://patternsinfp.wordpress.com/">as applied to the OP</a> ?  These and other important questions often flare up <a href="http://stackoverflow.com/questions/11339637/functional-design-patterns">here</a> and <a href="http://stackoverflow.com/questions/11339637/functional-design-patterns">there</a> , but for the time being I don‚Äôt know of a single book similar to the book of the Gang of Four.  Probably, my research has already been repeated by someone, but all the better: similar results will confirm the correctness, others will indicate a place in the theory that needs to be improved. <br><a name="habracut"></a><br><h5>  About the material </h5><br>  The basis of these articles is the experience in developing the game ‚ÄúThe Amoeba World‚Äù.  The language used is Haskell.  I initially made the game as part of the Ludum Dare contest # 27, but the scope was on prototyping the infrastructure for another game, more ambitious, whose name is Big Space.  ‚ÄúThe Amoeba World‚Äù is just a ‚Äúcat‚Äù on which I explore approaches in ‚Äúfunctional‚Äù game development.  Competition-oriented game has become a good starting point for further thought. <br><br>  The code for ‚ÄúThe Amoeba World‚Äù <a href="https://github.com/graninas/The-Amoeba-World">is here</a> .  Documentation on the "Big Space" - <a href="https://github.com/graninas/BigSpace-Documentation">here</a> .  By the way, a long time ago I did something similar.  It was <a href="http://habrahabr.ru/post/120590/">the Haskell Quest Tutorial</a> , as part of which I, um, also developed the game.  If you can call it that.  But it was a very simple low-level material for the study of the Haskell language, but here we will deal with completely different matters.  Accordingly, it is assumed that the reader is sufficiently familiar with the FP and the Haskell programming language. <br><br><h5>  Plan </h5><br>  At least the following topics should be covered further: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="http://habrahabr.ru/post/211871/">Part 1</a> .  FP application architecture.  Descending design in OP.  Fighting software complexity. </li><li>  <a href="http://habrahabr.ru/post/215161/">Part 2</a> .  Ascending design in OP.  The idea is the basis of good design.  Antipatterns in haskell </li><li>  <a href="http://habrahabr.ru/post/222015/">Part 3</a>  Properties and laws.  Scripts.  Inversion of Control in Haskell. </li><li>  Part 4. FRP </li></ol><br><br>  Also this series of articles can be found in a single document <a href="https://docs.google.com/document/d/1Gypzxp13aMpzD7o5XAmgy5zRrchQKrEbJArm6hDmwqk/edit%3Fusp%3Dsharing">here</a> . <br><br><h3>  Part one </h3><br>  <b>FP application architecture.</b>  <b>Descending design in OP.</b>  <b>Fighting software complexity.</b> <br><br><h5>  Some theory </h5><br>  The software development process is proceeding far and wide.  We have been using standardized techniques for a long time in our practice, including various methodologies, software design techniques, and modeling tools.  UML, for example, is very well known, an object-oriented (for the most part) design language.  It is used for end-to-end development, starting with requirements and ending, if lucky, with code generation.  And the design patterns?  Today it is necessary to know them in order to solve typical problems in the OO code.  And there is only one question - how applicable is this knowledge base to the functional paradigm?  Is it possible to invent your own modeling language?  Do you need patterns for functional languages? <br><br>  It seems that the initial stages - the collection and <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7_%25D1%2582%25D1%2580%25D0%25B5%25D0%25B1%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B9">analysis of requirements</a> , the definition of program functionality, the writing of business scenarios - will always be present to some degree, no matter what the software is.  Imagine that the requirements are already known to us, and we will skip the first stages so far, focusing on more engineering ones. <br><br>  And the first truly engineering stage is the development of software architecture, or, equivalently, the architectural design of software.  Here we solve the issues of high-level structure and functioning of the program in order to support all non-functional requirements collected earlier.  The choice of programming paradigm is also an architectural issue.  Choosing the OP, we almost completely reject the UML due to its object nature.  So, class diagrams, objects and sequences almost lose their meaning.  There are no classes or objects in Haskell, there is no encapsulated mutability, but there is only a data conversion process.  The sequence diagram needed to describe the interactions of these very objects could somehow be used for chains of functions, but the thing is that the chains themselves will be more readable and understandable.  All other diagrams, however, are quite applicable.  In a large program on the OP, there are also subsystems or components, which means that diagrams of components, packages and communications remain in the system.  The state diagram is universal: processes and finite automata are very common.  It could be applied even in other areas, not only in software development.  Finally, the use case diagram generally has little to do with software design;  it associates business requirements with system requirements at the analysis stage. <br><br>  But if you look closely at the "applicable" diagrams, you can come to the conclusion that they will not help much in the high-level design of the code (which is located below the architecture design), or even can harm, pushing to imperative thinking.  For example, when thinking about component architecture, we recall <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D1%258F_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">Inversion of Control</a> .  IoC solves one of the main problems of software development - it helps to fight against complexity by highlighting abstractions.  And what if you take it into service?  And here we remember that there is one of the ways to implement it - <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Dependency Injection</a> .  It can probably be adapted to our needs - in the following parts we will look at several different solutions, such as: Existential Types, module-level abstractions, monad abstraction, and also monad state injection.  But in fact, having first-class functions, we can forget about DI altogether, since this is a <a href="http://stackoverflow.com/questions/14327327/dependency-injection-in-haskell-solving-the-task-idiomatically">non-idiomatic approach</a> , since it leads (explicitly or implicitly) to the state in the FP program.  And this is not always good.  Although, in fairness, you need to recognize that IoC is also present in the AF. <br><br>  And what else, if not IoC, helps in dealing with the complexity of software design?  From <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B8_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D1%2580%25D0%25B5%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC">SICP,</a> we know that there are three important techniques: <br><br><ol><li>  abstractions for hiding implementation details (‚Äúblack box‚Äù); </li><li>  public interfaces for interaction between independent systems; </li><li>  domain-specific languages ‚Äã‚Äã(DSL, <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">Domain Specific Languages</a> ). </li></ol><br><br>  It can be assumed that the first two methods are known to us.  Interfaces, abstraction, concealment of details are all about one thing, and IoC is an example.  Due to the dominance of OOP languages, we have established strong associative links ‚Äúabstraction‚Äù =&gt; ‚Äúinheritance‚Äù and ‚Äúinterface‚Äù =&gt; ‚ÄúOOP interface‚Äù.  In fact, this is only part of the truth.  We too narrow the terms ‚Äúinterface‚Äù and ‚Äúabstraction‚Äù to OOP concepts and thereby cut off ‚Äúinappropriate‚Äù paradigms.  However, the ideas underlying the first two methods are more general, they are valid for all worlds, and knowledge of other approaches cannot be superfluous. <br><br>  Regarding the third method, we can say the following.  In view of its nature, FNs have to write all kinds of subject-oriented languages ‚Äã‚Äã- internal, external.  Firstly, because the binding code of parsers and translators is short, understandable and easily modified.  Secondly, the syntax of FP languages ‚Äã‚Äãallows you to make embedded DSL without overloading the main code.  Subject-oriented languages ‚Äã‚Äãcan drastically reduce the complexity of the program and reduce the number of errors.  The side effect (and maybe the main one) of the DSL implementation is a clearer understanding of the subject area.  Code in a domain-specific language is much better suited for formalizing requirements than low-level approaches. <br><br>  However, it should be recognized: specialized languages ‚Äã‚Äãare greatly underestimated in real life.  There is a myth that it is difficult, difficult and expensive to maintain.  Its reason is that an imperative programmer needs to go out of his comfort zone and imagine a different syntax, semantics, and maybe even a different paradigm to create <i>an external</i> DSL.  Without knowing this, he will be able to come up with DSL only within his own framework, which will automatically lead him to the current code, and then to the question ‚ÄúWhy then DSL?‚Äù.  But that's not all.  How to implement DSL?  Dominant OOP languages ‚Äã‚Äã(with rare exceptions) do not offer an elegant solution in comparison with functional ones;  Indeed, with the traditional approach, considerable effort is required so that the <i>external</i> DSL does not increase the risks.  To remove the risks, it is necessary to study other paradigms and tighten the theory;  As a result, the complexity of implementing <i>external</i> DSL in a familiar language is transferred to the very idea of ‚Äã‚ÄãDSL.  This error is for some reason considered to be a strong argument ‚Äúagainst‚Äù ... And it is easily broken by the fact that in addition to the <i>external</i> DSL there is an <i>internal one</i> (embedded, embedded DSL, eDSL).  For an external DSL, inexpressible grammar of the current language, we need at least a parser and translator, which leads to an additional serving code.  But the <i>internal</i> DSL is within the grammar of the current language, which means that no parsers and translators are needed.  However, it is still necessary to come up with a different code organization;  and again we came to the conclusion that one cannot do without a broad programmer outlook.  And this is a natural requirement for a modern programmer.  Well, <a href="http://www.ozon.ru/context/detail/id/6967089/">Martin Fowler</a> to help us. <br><br>  What else can you say about architecture as applied to the OP?  The important point is that side effects are undesirable in AF.  But in any large program it is necessary to work with the outside world;  that is, there must be some mechanisms for controlling side effects.  And they are.  Haskell's notorious monads are a great option, but they are more likely a tool of lower design than an element of the overall architecture.  So, the code of communication with an external server can be implemented within the framework of the IO monad, which will not differ much from imperative.  The second solution is that the code can be declared on DSL.  In this DSL there are bricks with side effects, there are bricks with pure behavior, but all of them are just a declaration, therefore, all the code will be clean and less error prone.  It will probably be understandable, flexible, combinable and manageable, in essence - the constructor.  Execution of this code can be entrusted to the finite state machine, working on a thin layer of monadic IO-code.  And please, we received quite a good architectural solution, thanks to which we also reduced the complexity of formalizing our business processes. <br><br>  To combat side effects, there is another architectural solution known as " <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">reactive programming</a> ."  When applied to functional languages, it is worth talking about FRP, that is, about Functional Reactive Programming.  This concept is mathematical, so it fits well with FP.  The essence of FRP is to propagate changes to the data model.  Each element of such a model is a value depending on other values ‚Äã‚Äãby the desired formulas.  Thus, the ‚Äúreactive model‚Äù is a tree, where leaf values ‚Äã‚Äãcan vary in time, exciting a wave in terms of recalculation of higher values.  Sources of values ‚Äã‚Äãcan be any functions, including those with side effects.  The model code will be declarative and composable. <br><br>  In general, in functional programming, the code written in the <a href="http://www.haskell.org/haskellwiki/Combinator_pattern">combinatorial style is the</a> most idiomatic as a constructor.  The idea is simple: an arbitrarily large self-applicable system is made up of small bricks of the same type.  The better the designer is designed, the more powerful and expressive the code.  Usually, the combinatorial code is also some eDSL, which significantly reduces the complexity of development.  Many Haskell libraries use this principle, for example: Parsec, Netwire, HaXml, Lenses ... The idea of ‚Äã‚Äãmonadic parser combinators was so successful that <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a> became known outside of Haskell.  There are its ports on F #, Erlang, Java, other languages.  It is curious that Parsec implements as many as three ideas: combinators, DSL and monads, and all this is organically connected in a single coherent API. <br><br>  Now it is not difficult to single out another very powerful method of dealing with complexity (the title is author's): <br><br>  4. Domain-specific combinators. <br><br>  DSC is an eDSL whose elements are combinators.  The most convenient DSCs are obtained in functional languages ‚Äã‚Äãdue to syntax (functions are the essence of transformation combinators), but this is also possible in ordinary languages.  Of course, it is even harder to design a DSC than a simple DSL, which is why this approach is probably completely unknown in the mainstream. <br><br><h5>  Some practice </h5><br>  Moving from abstract thinking to practice, let's turn to the Big Space project of the big game.  In short, this is a realistic, space-based 3D spacecraft with real-world scale and fully programmable game elements, and probably with the possibility of time travel.  Curious can look into the <a href="https://github.com/graninas/BigSpace-Documentation/blob/master/BigSpace%2520Design%2520Document.odt">design document</a> and other <a href="https://github.com/graninas/BigSpace-Documentation">related materials</a> for a more detailed acquaintance, and this description is enough for us to think through the general architecture of the game.  But first - a small digression. <br><br>  The beginning of any project lies in the idea, which, being born, requires development and reflection.  In the case of Big Space, the main assistants in this were <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D0%25B5%25D0%25B9">memory cards</a> , which make it possible to realize and structure the key moments of the future game in an excellent way.  Starting with generalized concepts (such as "Concept", "Cosmos", "Motivation", "Exploring the Galaxy"), you can go down deeper until you get specific game elements.  Memory cards also help to see and eliminate inconsistencies and inconsistencies. <br><br><div class="spoiler">  <b class="spoiler_title">Big Space: MM-01 'Concept'</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/81c/b0f/912/81cb0f912a207e3b62abf9b1fd0b18af.png"></div></div><br>  Can memory cards be considered as alternative use cases?  <a href="http://www.change-vision.com/en/ExploringUserRequirementsThroughMindMapping_Letter.pdf">Here is an article</a> whose author raises the same question.  It follows that memory cards are a more general tool, as they can easily contain use cases.  Memory cards answer the question "what is in general, and what solutions in particular," and use cases answer the question "what is allowed to be done to solve the problem."  The latter is expressed in the fact that a short story (user story) is usually associated with each use case, in which high-level changes in the system are described step by step.  And several of these options will be leverage for which you need to pull the user to the system took the necessary state.  It can be concluded that memory cards and use cases correlate in the same way as declarative (in the Prolog style) and imperative programming correlate.  In the first case, we describe what we want to get;  in the second case, we describe how we want to achieve this.  That is, memory cards are more suitable for functional programming, since declarative solutions are encouraged in the FP. <br><br>  By replacing the use case diagram in the first step, you can go further.  <a href="http://en.wikipedia.org/wiki/Concept_map">Concept cards</a> ‚Äî relatives of memory cards ‚Äî are well-suited for displaying requirements for a draft architecture.  This is achieved through three stages (the names of the author). <br><br><ol><li>  Map of need.  Contains as large blocks as possible.  Links are optional, the blocks are placed on the subject.  The map shows what the game is based on.  When designing you need to take into account the most general requirements;  for example, for the requirements of ‚Äúhuge realistic space‚Äù, ‚Äú3D graphics‚Äù, ‚Äúcross-platform‚Äù, there will be Cloud Computing, OpenGL and SDL units.  If you need a third-party game engine, you need to designate it here. </li><li>  Map elements.  In the free form we open the previous diagram, without worrying about the structure.  The elements are such blocks: ‚Äúsubsystem‚Äù, ‚Äúconcept‚Äù, ‚Äúdata‚Äù, ‚Äúlibrary‚Äù, ‚Äúobject of the subject area‚Äù.  Links show the most general idea of ‚Äã‚Äãhow the system works.  You can designate the nature of the relationship, for example: "uses", "implements" and others.  Blocks are divided into layers.  The diagram should take into account most of the conceptual requirements.  It's okay if several levels of abstraction are mixed, competing options appear, or something does not look the best.  The diagram only outlines the field of activity and offers possible solutions, but is not the final architecture of the program. </li><li>  Subsystem map.  In this diagram, specific architectural decisions are taken from those proposed at the second stage.  Information is structured and placed in such a way as to separate the application layers.  Libraries and approaches to implementation are indicated.  The diagram does not describe a fully high-level design, but will show important dependencies between the subsystems and help to separate them into layers. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Big Space: CM-01 Necessity Map</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/22a/b7e/576/22ab7e57648c3abb91c95e544ca2ce37.png"></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Big Space: CM-02 Elements Map</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/d96/b6e/235/d96b6e2359762ee8b417602973d50b13.png"></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Big Space: CM-03 Subsystems Map</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/ec3/bb7/ba5ec3bb794c9592b39ea3ede42e7d10.png"></div></div><br><br>  The last diagram shows that there are three layers in the game: Views, Game Logic, Application ( <a href="http://www.amazon.com/Game-Coding-Complete-Fourth-Edition/dp/1133776574/ref%3Dcm_cr_pr_product_top">Mike McShaffry, Game Coding Complete</a> ).  The Views and Game Logic layers are separated from the main code by their own command interpreters and eDSL facades.  It is assumed that all game logic, with the exception of the game state, will be implemented outside the IO monad.  The game state, although it relates to the game logic, is separate because it requires shared access from the views and from the application side (for network communication, for periodic data upload, for GPGPU and cloud computing).  The diagram shows that the <a href="http://www.haskell.org/haskellwiki/Software_transactional_memory">Software Transactional Memory</a> concept will be used to work with the game state;  also includes the Netwire, SDL, Cloud Haskell, and other libraries.  Almost all game logic, according to the plan, should be implemented using several internal and external languages.  Of course, the proposed version of the architecture is one of a thousand, and the diagram does not say anything about the lower level of design;  research and prototypes are needed to find bottlenecks or miscalculations.  But in general, the architecture looks slim and neat. <br><br>  After the subsystem diagram, you can proceed to the next design stage.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having knowledge of architecture, you can build two models: a data model and a type model, and paint the interfaces of all public modules. </font><font style="vertical-align: inherit;">Finally, the final step will be the implementation of these interfaces and the writing of internal libraries. </font><font style="vertical-align: inherit;">But these final stages are already low-level design and implementation. </font><font style="vertical-align: inherit;">We will review them in part in the following chapters.</font></font><br><br><h5>  Conclusion </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The approach presented in this article is downward, that is, directed from the most general to the most particular. </font><font style="vertical-align: inherit;">We have seen that UML is weakly applicable to OP. </font><font style="vertical-align: inherit;">Therefore, we designed a high-level architecture, inventing our own diagrams and building our own methodology. </font><font style="vertical-align: inherit;">We also learned about the methods of dealing with complexity, which we will surely come in handy when designing subsystems.</font></font></div><p>Source: <a href="https://habr.com/ru/post/211871/">https://habr.com/ru/post/211871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211855/index.html">IBM can get rid of semiconductor business</a></li>
<li><a href="../211863/index.html">Polyfill to work around browser forms autocomplete</a></li>
<li><a href="../211865/index.html">MDIF announced the creation of a free network Outernet</a></li>
<li><a href="../211867/index.html">Qwt and Qt Creator. Quick and easy. Part 2: Display and Control Elements</a></li>
<li><a href="../211869/index.html">Arista. Acquaintance</a></li>
<li><a href="../211877/index.html">Translation Code Club Scratch Curriculum, crowdsourcing</a></li>
<li><a href="../211879/index.html">Modification of UEFI BIOS, part two: useful modifications</a></li>
<li><a href="../211881/index.html">On solving an incomplete cubic equation</a></li>
<li><a href="../211885/index.html">Lightweight Tables or practical tips when designing a database ...</a></li>
<li><a href="../211889/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ95 (February 2 - 8, 2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>