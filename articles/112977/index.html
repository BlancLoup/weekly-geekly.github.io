<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visually about the execution thread in Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the comments to my previous topic about asynchronous programming, callbacks and the use of process.NextTick (), Node.js asked a lot of questions ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visually about the execution thread in Node.js</h1><div class="post__text post__text-html js-mediator-article">  In the comments to my <a href="http://habrahabr.ru/blogs/nodejs/112742/">previous topic</a> about asynchronous programming, callbacks and the use of process.NextTick (), Node.js asked a lot of questions about how a great performance is obtained or can be obtained by using non-blocking code.  I will try to demonstrate this visually :) The article is intended mainly to clarify some aspects of the work of Node.js (and libeio in its composition), which can be difficult to describe in words. <br><br>  <b><i>Example of processing requests by the server with blocking reading:</i></b> <br><img src="https://habrastorage.org/storage/b1df5ae0/b2a9dcab/418eee6a/aedc929c.gif"><br><br>  First, I will comment on the usefulness of using non-blocking I / O.  As a rule, using blocking operations in Node.js is only at the stage of application initialization, and not always.  Proper error handling will in any case require using try / catch, so code using non-blocking operations will not be more complicated than using blocking operations. <br>  It only needs to be remembered that there may be more requests for non-blocking operations than libeio threads.  In this case, new requests will queue up and block execution, but this will be transparent to the programmer. <br><a name="habracut"></a><br>  <b><i>Example of processing requests by a server with non-blocking reading:</i></b> <br><img src="https://habrastorage.org/storage/e191c611/4e8036c1/ad1dde0e/c08d3a9b.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, these two examples show the case when server performance is maximized.  However, the benefit of non-blocking reading is at any time between incoming requests, even in the worst case, to improve productively due to the involvement of libeio threads in the processing of requests. <br>  The total request processing time (the time between the client sending the first request and receiving the last processing result, the blue number on the right) will be less anyway, if there are enough threads for all requests.  But even in the worst case, this time will not exceed the processing time when using synchronous reading. <br><br>  <b><i>An example of reducing the processing time when two requests arrive almost simultaneously:</i></b> <br><img src="https://habrastorage.org/storage/03b39e2c/f0d0af34/6ffc193f/c95db890.gif"><br><br>  And here we come to the most illogical technique that is used by Node.js programmers and can cause confusion for most developers.  If the I / O takes most of the time to process the request, then the rest of the code should not be optimized.  However, the time to receive data from memcached can be commensurate with the execution time of the application business logic and template making.  And if you use caching or a database in the memory of the Node.js process ( <a href="https://github.com/felixge/node-dirty">Dirty</a> or <a href="https://github.com/pgte/alfred">Alfred</a> ), then the time to work with the database may be less than the time of the rest of the application.  Therefore, to split the code into separate parts and call callbacks use process.nextTick (): <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// blocking callbacks function func1_cb(str, cb) { var res = func1(str); cb(res); } function func2_cb(str, cb) { var res = func2(str); cb(res); } // non-blocking callbacks function func1_cb(str, cb) { var res = func1(str); process.nextTick(function () { cb(res); }); } function func2_cb(str, cb) { var res = func2(str); process.nextTick(function () { cb(res); }); } // usage example func1_cb(content, function (str) { func2_cb(str, function (result) { // work with result }); });</span></span></code> </pre> <br>  When using this approach in separating the execution of calc (1) and calc (2), the total processing time for the previous example with almost simultaneous arrival of requests does not change, however, the first request will be returned to the client later. <br><br>  <b><i>An example of ‚Äúharm‚Äù from process.nextTick () with the almost simultaneous arrival of two queries:</i></b> <br><img src="https://habrastorage.org/storage/49abb28b/5a51acc8/26b1ece2/3b82f296.gif"><br><br>  However, this is the worst case in terms of the applicability of process.nextTick ().  In case requests come rarely, as in the first example considered, there will be no harm from process.nextTick () at all.  In case requests come at an ‚Äúaverage‚Äù frequency, the use of process.nextTick () will speed up the processing of requests due to the fact that the initial processing of a new request and the start of a non-blocking read can interfere at the moment the flow is interrupted.  This reduces both the total processing time and the average processing time for a single request. <br><br>  <b><i>An example of the "benefit" of process.nextTick ():</i></b> <br><img src="https://habrastorage.org/storage/eefef6e6/369dbe7f/f53fb755/0688add3.gif"><br><br>  Let's summarize a little topic.  First, when using Node.js, non-blocking I / O is worth using.  It is desirable even in cases where not the standard number of libeio threads is used, but less, or with a large number of incoming requests.  problems can be removed using caching and in-process DB, and the performance will not be much different from the use of other parallelization technologies.  Secondly, the use of process.nextTick () "on average" can improve server performance, and in general it is more beneficial than harm. <br><br>  UPD (02.02): Slightly improved circuitry.  The source code is available at: <a href="https://github.com/Sannis/papers_and_talks/tree/master/2011_node_article_async_process_nexttick">github.com/Sannis/papers_and_talks/tree/master/2011_node_article_async_process_nexttick</a> . </div><p>Source: <a href="https://habr.com/ru/post/112977/">https://habr.com/ru/post/112977/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112968/index.html">Moving from SVN to Mercurial: personal experience</a></li>
<li><a href="../112969/index.html">So we put a factory into your algorithm or how not to consider factorials</a></li>
<li><a href="../112973/index.html">33needs allows you to become a startup investor</a></li>
<li><a href="../112974/index.html">ACM ICPC World Programming Championship Final moved</a></li>
<li><a href="../112976/index.html">LSB steganography</a></li>
<li><a href="../112978/index.html">Google accuses Bing of copying its search results</a></li>
<li><a href="../112982/index.html">Google competitors in Europe: Yandex and Seznam</a></li>
<li><a href="../112984/index.html">OpenStore - free build online store based on Drupal and Ubercart</a></li>
<li><a href="../112988/index.html">Mentioner. Partnership system</a></li>
<li><a href="../112989/index.html">Brainfuck Interpreter on Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>