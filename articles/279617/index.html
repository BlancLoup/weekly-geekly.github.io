<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SoftMocks: our replacement runkit for PHP 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo was one of the first to switch to PHP 7 - we just wrote about it recently. In that article, we talked about changes in the testing infrastructur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SoftMocks: our replacement runkit for PHP 7</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f8d/389/7ad/f8d3897ad72e46df86bafb5a28222dfb.jpg" align="left" width="500">  Badoo was one of the first to switch to PHP 7 - we just <a href="https://habrahabr.ru/company/badoo/blog/279047/">wrote about it</a> recently.  In that article, we talked about changes in the testing infrastructure and promised to tell you more about the replacement we developed for the runkit extension called SoftMocks. <br><br><h3>  Softmocks </h3><br>  The idea of ‚Äã‚ÄãSoftMocks is very simple and is reflected in the name: you need to implement an analog for runkit, which is as compatible as possible with it in semantics, in pure PHP.  Soft here emphasizes that it is implemented not inside the PHP core, but on top of it, without using the Zend API and other hardcore.  The fact that it is in pure PHP means that we can safely upgrade to a new version of PHP and simply add support for the new syntax, rather than rewrite extensions with the new version of the Zend API and catch millions of bugs due to various subtleties in semantics. <br><a name="habracut"></a><br>  In pure PHP, this can be done in the same way that many Go tools work, such as <a href="https://github.com/mailgun/godebug">godebug</a> , go test -cover, etc.  - automated rewriting of the code, in our case - on the fly, right before the "incluses".  You can find the <a href="https://github.com/Codeception/AspectMock">AspectMock</a> testing <a href="https://github.com/Codeception/AspectMock">framework</a> on the <a href="https://github.com/goaop/framework">Go!</a> Library on the Internet <a href="https://github.com/goaop/framework">!</a>  <a href="https://github.com/goaop/framework">AOP</a> , which also deals with rewriting code and provides the ability to write in AOP-style.  The framework is good, but it does not allow completely replacing the runkit in our conditions, so we decided to write our solution in the image and likeness of this library.  Unfortunately, the aforementioned framework does not provide the ability to intercept functions and methods on the fly (that is, without first announcing the intention to intercept a specific function).  This is different from the behavior of runkit and uopz, although it also has its scope. <br><br><h3>  What runkit allows you to do </h3><br>  The runkit extension in PHP allows you to perform various manipulations on the state of objects, functions, methods and constants during the execution of PHP code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Example from the documentation (http://php.net/manual/en/function.runkit-function-redefine.php). <br><br>  Test program: <br><blockquote><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Original Testme Implementation\n"</span></span>; } testme(); runkit_function_redefine(<span class="hljs-string"><span class="hljs-string">'testme'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">'echo "New Testme Implementation\n";'</span></span>); testme();</code> </pre> <br></blockquote><br>  Test program output: <br><blockquote><pre> <code class="php hljs">Original Testme Implementation <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> Testme Implementation</code> </pre><br></blockquote><br>  Such runkit features are very widely used during functional and unit testing.  Basically, the use of this extension is limited to the substitution of the implementation of methods, functions, and constant values. <br><br><h3>  API of our library </h3><br>  We would like to get the same functionality with the ability to override any functions and methods on the fly, without preliminary declarations.  This is how the program looks like using SoftMocks instead of runkit (the same example): <br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  test.php function testme() { echo "Original Testme Implementation\n"; } testme(); \QA\SoftMocks::redefineFunction('testme', '', 'echo "New Testme Implementation\n";'); testme();</span></span></code> </pre><br></blockquote><br>  The command to run the example is as follows: <br><blockquote><pre> <code class="php hljs">$ php -r <span class="hljs-string"><span class="hljs-string">'require("init.inc"); require(SoftMocks::rewrite("test.php"));'</span></span></code> </pre><br></blockquote><br>  The output of the test program is the same as in runkit. <br><br>  The init.inc file contains the code for initializing the SoftMocks class and looks like this (the specific type of file will depend on your application): <br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//     PhpParser // (    ,   SoftMocks) require($php_parser_dir . "Autoloader.php"); \PhpParser\Autoloader::register(true); $out = []; exec('find ' . escapeshellarg($php_parser_dir) . " -type f -name '*.php'", $out); foreach ($out as $f) { require_once($f); } //    SoftMocks (  !) require_once("SoftMocks.php"); \QA\SoftMocks::init();</span></span></code> </pre><br></blockquote><br><h3>  Idea implementation </h3><br>  The initial idea was quite simple: we can wrap all calls to methods and functions, as well as calls to constants to calls to our wrapper, which checks whether there is a mock object for a particular method and function or not. <br><br>  So the code from such <br><blockquote><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::test($a, $b); $c = file_get_contents(<span class="hljs-string"><span class="hljs-string">"something.txt"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c; } }</code> </pre></blockquote><br>  will turn into this: <br><blockquote><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ \QA\SoftMocks::call([<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::class, <span class="hljs-string"><span class="hljs-string">'test'</span></span>], [$a, $b]); $c = \QA\SoftMocks::call(<span class="hljs-string"><span class="hljs-string">'file_get_contents'</span></span>, [<span class="hljs-string"><span class="hljs-string">'something.txt'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c; } }</code> </pre></blockquote><br>  The code for the SoftMocks :: call () method could then look like this: <br><blockquote><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($func, $args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::isMocked($func)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_user_func_array($func, $args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::callMocks($func, $args); }</code> </pre></blockquote><br><h3>  Start implementation: recursive rewriting include </h3><br>  First, we wrote a simple parser that could only do one thing - to substitute the include (...) and require (...) calls so that we could include the use of SoftMocks in the front controller or, for PHPUnit tests, in bootstrap.php , and all files would be recursively rewritten by our parser. <br><br>  Example: <br><blockquote><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   (front.php) </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> require('autoload.php'); $app = new App(); $app-&gt;run(...);</span></span></code> </pre></blockquote><br>  Here, autoload.php loads classes for an autoload project, registers and initializes everything you need, possibly loading some more files with include (...).  The original file with the front controller must be moved to another location, for example, front-orig.php, and replaced with this: <br><blockquote><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> if ($soft_mocks_enabled) { require('soft_mocks_init.inc'); include(\QA\SoftMocks::rewrite("front-orig.php")); } else { include("front-orig.php"); }</span></span></code> </pre></blockquote><br>  After passing our parser, the front-orig.php file will look like this: <br><blockquote><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   SoftMocks </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> require(\QA\SoftMocks::rewrite('autoload.php')); $app = new App(); $app-&gt;run(...);</span></span></code> </pre></blockquote><br>  The SoftMocks :: rewrite ($ filename) method rewrites the file, replacing require, include, method calls, and so on with a call to wrappers.  The return value of this function is the new path to the file that contains the already wrapped code and allows you to redefine the values ‚Äã‚Äãof functions, methods and constants on the fly. <br><br>  For example, <code>front-orig.php</code> will be turned into <code>/tmp/mocks/&lt;hash-code&gt;/front-orig.php_&lt;version&gt;</code> .  On the way to the compiled file, the &lt;hash-code&gt; is considered based on the content and the path to the file, which allows us to cache the compiled files and perform the procedure of parsing and rewriting the file only once. <br><br>  At first, we wanted to rewrite only include and require in order to evaluate the complexity of full parsing.  It turned out that PHP allows you not to use brackets for such constructions (that is, you can write <code>require "a.php";</code> instead of <code>require("a.php"))</code> , and expressions and calls to other functions are supported.  This makes the simplest task of replacing "inclusions" more difficult than necessary.  There are also constants __FILE__ and __DIR__, the values ‚Äã‚Äãof which change dynamically, depending on the location of the file.  We often have code like <code>include(dirname(__DIR__) . ‚Äú/something.php‚Äù);</code>  , and calls to the constants __DIR__ and __FILE__ need to be replaced with their contents. <br><br>  Another unpleasant problem was that it is possible to use relative paths in include ( <code>require "a.php"</code> ), and, accordingly, one should pay attention to the include_path setting and replace the current directory value (".") With the source directory, rather than rewritten file. <br><br><h3>  token_get_all () vs PHP Parser </h3><br>  The first version of our parser tried to use the token_get_all () function, which works very quickly and returns an array of tokens in the file.  The problem is that on its basis it is very difficult to parse the nested function arguments and even more so to replace the argument lists with an array, as we need in the case of wrapping a function call in SoftMocks :: call (). <br><br>  Therefore, we took the library of Nikita Popov called <a href="https://github.com/nikic/PHP-Parser">PHP Parser</a> .  This library is able to build an AST tree based on the list of tokens returned to token_get_all (), and also provides convenient tools for traversing the tree and modifying it.  The library makes it easy to implement exactly what we need. <br><br>  Unfortunately, the parser has drawbacks: <br><br><ol><li>  Poor performance: file parsing takes, according to our benchmarks, about 15 times longer than token_get_all (). </li><li>  The inability to print the modified tree back with the original line numbers. </li></ol><br>  If it is difficult to do something with the first problem, since the library is in PHP, then we have eliminated the second shortcoming by expanding the proposed out-of-the-box printer.  For our purposes, it was not so important that the output file was ‚Äúbeautiful‚Äù, we only needed to preserve the original line numbers to the maximum so that the error messages in PHPUnit and the calculation of code coverage by tests did not suffer. <br><br><h3>  Final implementation </h3><br>  Based on PHP Parser, we quickly wrote a prototype that does exactly what we originally wanted - wraps calls to methods and functions into calls to its layer.  Unfortunately, in the case of the methods, there were many problems with this approach: <br><br><ol><li>  The call_user_func * family does not allow calling private and protected methods, so you need to use Reflection, which doesn‚Äôt have a good effect on performance. </li><li>  To call the parent method, you need to resort to "special street magic" - calls to parent methods are written as <code>parent::call_something(...)</code> , while the call is not really static, but dynamic.  In addition, the value of the static class should be preserved, and not point to the parent class.  Unfortunately, we did not find a simple way to save the current static context when making calls via Reflection - probably there is no such method yet. </li><li>  Since we always call methods via Reflection using setAccessible (true), we, in fact, always call private and protected methods as if they were public, whereas in "real" code this could lead to a Fatal error during execution .  It turns out that we are changing the behavior of the code under test, which is impermissible. </li><li>  It is not possible in this way to override the implementation for "magic" methods, for example, for __construct, and also __get, __set, __clone, __wakeup, etc. </li></ol><br>  As a result, we came to the conclusion that we will carry out mock-objects for class methods by inserting additional code before each method definition.  Example <br><blockquote><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre></blockquote><br>  will turn into the following: <br><blockquote><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SoftMocks::isMocked(...)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>(SoftMocks::getMockCode(...)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre></blockquote><br>  We do not wrap method calls, but we still do it for functions.  This approach does not allow intercepting methods of the built-in classes, however, surprisingly, we did not need this opportunity.  Interestingly, the AspectMock library uses a similar approach for mock method objects. <br><br>  When working with the functions of the problem, too. <br><br><ol><li>  Some functions depend on the current context, for example, get_called_class (). </li><li>  Values ‚Äã‚Äãlike <code>static</code> (string) and <code>self</code> can be passed to the function, and since the function is called through our wrapper, functions get different values ‚Äã‚Äãfor these keywords.  In such cases, it is required to modify the test code so that the function does not pass strings, but class names, for example, <code>static::class</code> instead of <code>static</code> . </li><li>  Functions that can call a callback, for example, preg_replace_callback, can call private methods.  Since the real call to the preg_replace_callback function comes from the SoftMocks class, an access error occurs and private methods from this context become inaccessible.  The solution to the problem is also rewriting the code, for example, passing anonymous functions instead of <code>array($this, 'callback')</code> . </li></ol><br>  To solve most of these problems, we made support for the "black list" of functions that do not turn around and are always called directly.  Here are some of them: get_called_class, get_parent_class, func_get_args, usort, array_walk_recursive, extract, compact, get_object_vars.  These functions cannot be changed using SoftMocks. <br><br>  Interception of global constants and class constants is very simple: we replace all calls to constants with function calls.  The only exceptions are cases in which constants are specified as default values ‚Äã‚Äãin the arguments of functions or class properties.  That is, the following places we can not rewrite: <br><blockquote><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $b = SOME_CONST; } <span class="hljs-comment"><span class="hljs-comment">//    ,  parse error function doSomething($a = OTHER_CONST) { //           , //    ,    //     }</span></span></code> </pre></blockquote><br>  We also decided not to wrap the constants true, false and null for performance reasons.  This means that, unlike the runkit, SoftMocks will not be able to <code>redefineConstant("true", false);</code>  . <br><br><h3>  Performance </h3><br>  Since SoftMocks is written in pure PHP, one would expect its performance to be worse than runkit.  In fact, our tests began to run faster and more stable, since SoftMocks does not suffer from such problems as the need to reset the runtime cache during any call.  Our library does not suffer from performance degradation with an increase in the number of loaded classes and functions, so the overall performance in our case turned out to be even slightly better. <br><br>  If you do not use the SoftMocks functions at all, but still execute the rewritten code, then its performance, according to our estimates, decreases by about 3 times.  In general, we would recommend using SoftMocks for unit tests and not using this library in production for both performance and security reasons: the library creates temporary files and includes from a directory that can be written from the web context. <br><br><h3>  PHPUnit integration </h3><br>  Since we replace the paths to files that are ‚Äúincluded‚Äù, the backtrace becomes unreadable due to auto-generated files instead of the original.  Also, since PHPUnit itself downloads files, and we don‚Äôt rewrite its source code, this makes it impossible to replace the functions and methods defined in test files. <br><br>  To solve these problems, we prepared a pull-request for PHPUnit: <a href="https://github.com/sebastianbergmann/phpunit/pull/2116">github.com/sebastianbergmann/phpunit/pull/2116</a> <br><br><h3>  Conclusion </h3><br>  Our SoftMocks project is posted on GitHub at: <a href="https://github.com/badoo/soft-mocks/">github.com/badoo/soft-mocks</a> . <br>  We use Nikita Popov's PHP Parser, which is also available on GitHub: <a href="https://github.com/nikic/PHP-Parser">github.com/nikic/PHP-Parser</a> . <br><br>  We ensured that when rewriting the code on the fly, it was possible to substitute the implementation of functions, user-defined methods and constants - and all this in pure PHP, without using third-party extensions.  In our case, we were able to completely get rid of runkit, ‚Äúdrive out‚Äù our entire suite of 60,000 unit tests for PHP 7 and fix the incompatibilities found (there were very few of them, and some of them are errors in dev versions of PHP 7, o which we told the developers). <br><br>  Currently, badoo.com is working on PHP 7, and we were able to achieve this, including through the development of SoftMocks.  I hope your experience will be as positive as ours. <br>  Enjoy testing! <br><br>  Yuri Nasretdinov, senior PHP developer </div><p>Source: <a href="https://habr.com/ru/post/279617/">https://habr.com/ru/post/279617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279603/index.html">ICQ Contest. The results of the competition for the redesign of the mobile application</a></li>
<li><a href="../279607/index.html">HabroStatistics - at what time is it better to publish an article on Habr√©?</a></li>
<li><a href="../279609/index.html">48-hour online Angularjs Attack hackathon</a></li>
<li><a href="../279613/index.html">Automating the integrity check of a raid array on a Dell server</a></li>
<li><a href="../279615/index.html">Cloud storage for thematic data</a></li>
<li><a href="../279619/index.html">Non-technical program PHDays, or From hackers to artists one step</a></li>
<li><a href="../279621/index.html">Erlang in wargaming</a></li>
<li><a href="../279623/index.html">Remarkable zippers, or how I learned not to worry and fell in love with tree data structures</a></li>
<li><a href="../279625/index.html">Release CLion 2016.1: new tools and new languages</a></li>
<li><a href="../279627/index.html">Interrupts for the smallest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>