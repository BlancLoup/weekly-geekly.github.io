<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Artificial intelligence with fuzzy logic in an arcade game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction or as I wrote my first AI 
 Good day. I wrote my first artificial intelligence many years ago when I was in college. Then it was an AI fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Artificial intelligence with fuzzy logic in an arcade game</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction or as I wrote my first AI </h1><br>  Good day.  I wrote my first artificial intelligence many years ago when I was in college.  Then it was an AI for a snake in an unusual game for snakes - <a href="http://gamedev.ucoz.org/publ/proekt_quot_zmejki_quot_serpent_39_s_madness/1-1-0-4">Serpent's Madness</a> (link leads to my game site), in which the latter can move in any direction.  The screenshot below demonstrates this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c5/da8/60d/8c5da860d4ff297830c4a221df21a1a7.jpg"><br><br>  Then it was a deterministic algorithm, i.e.  an algorithm with a clear sequence of actions, when at each step you can say exactly what will be next.  He looked something like this <a name="habracut"></a>  (pseudocode): <br><pre> rwarn = 0 // danger threatening the snake on the right
 lwarn = 0 // danger threatening the snake on the left
 for all opponents op {
	 If the point is the center of the opponent's bone op lies within the semicircle of the snake, then {
		 If the point lies to the right of the snake, then
			 rwarn ++;
		 If the point lies to the left of the snake, then
			 lwarn ++;
	 }
	 If we move parallel to one of the walls at a distance not more than the specified one with the maximum deviation of the motion vector along one of the coordinates (x or y) not more than the specified one, then {
		 If the wall is to the right of the snake, then
			 rwarn + = 100;
		 If the wall is to the left of the snake, then
			 lwarn + = 100;
	 }
	 If rwarn! = 0 and lwarn! = 0, then {
		 If rwarn&gt; lwarn, then turn left.  Otherwise - to the right.
	 }
 } // for all opponents op
</pre><br>  Those.  this AI for the given arrangements of snakes always does the same thing: turns in the direction where there are fewer snakes and / or walls.  Yes, yes, I indicated the magic number "100", which increases the danger if there is a wall.  Magic numbers are a bad programming style, but at the time it was excusable.  I did this so that the snakes more often hit other snakes than the walls, although the condition is relatively relative: if there are more than 100 bones (= parts) of other snakes within the semi-circle of the snake, the algorithm will choose to crash into the wall.  Despite this, the algorithm worked quite well: the AI ‚Äã‚Äãcircled around the snakes from different angles, circled the walls (never crashed into them, if other snakes were not forced), and also balanced between the wall and the snake when it was done. <br>  However, he had 2 drawbacks: <br>  1) When the snake was traveling close to the wall, and the AI ‚Äã‚Äãwas between the wall and the snake, then even if it was where to go, the following occurred periodically: the AI ‚Äã‚Äãgot confused, jerked - slightly to the left, slightly to the right, slightly to the left ... and died. <br>  2) At the same predetermined distance from the snake, the AI ‚Äã‚Äãalways began to turn.  If it turned out that the snake was at a greater distance from the AI, and a little later - at a much smaller one (turned sharply in the direction of the AI), then the AI ‚Äã‚Äãcrashed.  Provided that he could turn in advance or at least start turning.  I was thinking about introducing another semicircle with a large radius - for which you need to turn "a little".  Then I told myself stop, because  the algorithm became, it seems to me, too complicated.  Well, if you complicate things, you will definitely enter waypoints, I thought. <br>  These two flaws can be described in one word - the snake was in some cases "jerky" and because of this, it occasionally died. <br>  Now, when after 5 years, I have ported <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness to android</a> , I decided that this shortcoming must be fought.  And this helped me "fuzzy logic."  I understand fuzzy logic as a tool for inserting our ‚Äúfuzzy‚Äù reasoning into an algorithm.  So, take a look at the task from a new point of view. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Principle </h1><br>  The snake in <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness</a> , which I am developing, can move left, right or forward.  She cannot move at all.  Thus, the AI ‚Äã‚Äãwill have the following outputs: <br>  1) turn left <br>  2) turn right <br>  3) go ahead <br>  In accordance with this, we will present a table with linguistic variables ‚Äî variables that can take on the meaning of phrases from a natural or artificial language. <br><table><tbody><tr><td></td><td>  Distance to snakes </td><td>  Snake density </td><td>  Distance to the walls </td><td>  Hitting the corner </td></tr><tr><td>  Left </td><td></td><td></td><td></td><td></td></tr><tr><td>  On right </td><td></td><td></td><td></td><td></td></tr><tr><td>  Ahead </td><td></td><td></td><td></td><td></td></tr></tbody></table><br><br>  There will be terms in the cells.  By term, I mean the very meaning of the phrase for variables (linguistic). <br>  far, just, close - when it comes to distance (columns 1 and 3) <br>  no, small, medium, many - when it comes to the density of snakes (column 2) <br>  No, perhaps for sure - when it comes to hitting a corner (column 4) <br><br>  For each term, membership functions are determined.  In the sense here it will be ‚Äúdanger function‚Äù from 0 to 1, the greater the value, the greater the danger of going in a given direction. <br>  For each row i, we calculate the maximum values ‚Äã‚Äãin the cells m (i).  So let's say the maximum danger for the parameters in a given direction.  Then from all such m (i) we find the minimum.  At a minimum, this will be the answer to the question - what to do, turn left / right or go straight. <br><br>  Below are a few examples.  I draw attention to the fact that the numerical interpretation is given only as an example.  Actually, in the developed system, there may be other values. <br><br>  Example ‚Ññ1 <br><table><tbody><tr><td></td><td>  Distance to snakes </td><td>  Snake density </td><td>  Distance to the walls </td><td>  Hitting the corner </td></tr><tr><td>  Left </td><td>  just </td><td>  few </td><td>  not </td><td>  not </td></tr><tr><td>  On right </td><td>  long away </td><td>  not </td><td>  just </td><td>  exactly </td></tr><tr><td>  Ahead </td><td>  close </td><td>  lot </td><td>  long away </td><td>  not </td></tr></tbody></table><br>  The result should be a decision to turn left. <br>  What is obtained from the calculations: <br>  min (max (0.5, 0.33, 0, 0), max (0, 0, 0.5, 1), max (1, 1, 0, 0)) = min (0.5, 1, 1) = 0.5 = turn left <br><br>  Example 2 <br><table><tbody><tr><td></td><td>  Distance to snakes </td><td>  Snake density </td><td>  Distance to the walls </td><td>  Hitting the corner </td></tr><tr><td>  Left </td><td>  close </td><td>  average </td><td>  long away </td><td>  not </td></tr><tr><td>  On right </td><td>  long away </td><td>  not </td><td>  long away </td><td>  not </td></tr><tr><td>  Ahead </td><td>  close </td><td>  average </td><td>  long away </td><td>  not </td></tr></tbody></table><br>  The result should be the decision to turn right. <br>  min (max (1, 0.75, 0, 0), max (1, 0.75, 0, 0), max (0,0,0,0) = min (1,1,0) = 0 = turn right <br><br>  Example 3 <br><table><tbody><tr><td></td><td>  Distance to snakes </td><td>  Snake density </td><td>  Distance to the walls </td><td>  Hitting the corner </td></tr><tr><td>  Left </td><td>  close </td><td>  average </td><td>  long away </td><td>  not </td></tr><tr><td>  On right </td><td>  long away </td><td>  not </td><td>  close </td><td>  not </td></tr><tr><td>  Ahead </td><td>  close </td><td>  average </td><td>  long away </td><td>  not </td></tr></tbody></table><br>  The resulting decision is difficult to make - everywhere there is a danger of inevitable death. <br>  What the snake will solve: <br>  min (max (1, 0.75, 0,0), max (1, 0.75, 0, 0), (0,0, 1, 0)) = min (1,1,1) = 1 = turn left <br><br>  I want to add to the logic in perspective the following: the same term (let's say close) for snakes has a lesser degree of belonging than for walls.  This will give in case of imminent death, say in all directions a collision with a snake, and not a wall - this is so that players can score points faster. <br><br><h1>  Calculation Rules </h1><br>  When developing I will pay attention to the following moments.  They save CPU time. <br>  1) if the term for the function max is calculated and is 1, then there is no sense in calculating the rest, the maximum will give 1. <br>  2) if the term for the min function is calculated and is 0, then there is no point in calculating the rest, the min will give 0. <br><br><h1>  Graphic interpretation </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/97a/f8c/880/97af8c880731b328ccc55b9d0815ea46.jpg"><br>  At the left, in front, on the right - 1,2,3 respectively.  The vertical bar is the snake symbol. <br>  These are areas of analysis.  It makes no sense for us to analyze what is behind, so areas 1 and 2 are bounded below by a horizontal line.  It should be noted that when ‚Äúfilling‚Äù the sector with walls, it is not the sector of the circle that is used (as is the case with the bones of snakes), but the triangle inscribed in it. <br>  Implementation of membership functions for terms <br>  It turns out that we have 3 areas: <br>  left, right and front.  All these areas add up to half the circumference, and one by one - sectors of 1/3 each. <br>  A sector may contain: <br>  1) the bones of all snakes (including the snake itself - you need to go around your tail), i.e. their coordinates and number <br>  2) walls (maximum two, when the angle they have a common point) <br>  Such a sector is fed to the input of the function ‚Äúdistance to snakes‚Äù, ‚Äúdensity of snakes‚Äù, ‚Äúdistance to walls‚Äù and ‚Äúhitting the corner‚Äù.  Next comes the degree of belonging, and with them we already know what to do.  The functions themselves are also not complicated. <br>  The most difficult moment is to form such sectors. <br><br><h1>  Sector fields and responsibilities </h1><br>  Circle Sector class CircleSector <br>  Behavior: <br>  1) check the ownership of the point sector <br>  2) find the intersection with the rectangle (from 0 to 4 points), bearing in mind that the sector is always centered inside the rectangle <br>  3) Initialize according to snake bones and walls (using the methods above) <br>  4) learn the min.  Distance to snakes (lingv. Variable 1) <br>  5) find out the density of snakes (ling. Trans. 2) <br>  6) learn the min.  Distance to the walls (ling. Trans. 3) <br>  7) find out the degree of hitting the corner <br>  8) find out the degree of maximum danger <br>  From 4 to 7 - the implementation of membership functions. <br>  8 - looking for a maximum of 4-7. <br>  Fields: <br>  points - coordinates (centers) of snake bones <br>  points - coordinates of wall segments (0, 2, 3 (angle), 4) <br><br><h1>  Alteration </h1><br>  Having implemented the first version of fuzzy AI, I launch <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness</a> and see a number of flaws. <br>  It is revealed that the snake is spinning and spinning when there is no danger. <br>  Minmax function with the same values ‚Äã‚Äãof threats in the sectors returns the first sector.  And the first - right.  I did the first - the front sector.  Now the default snake goes forward, as required. <br>  Noticed that the snake, when traveling perpendicular to the wall - crashes into it.  In this case, the analysis proceeds as usual (everything is initialized correctly).  It seems that when moving perpendicularly, all sectors equally contain one wall, and the front sector turns out to be ‚Äúclosest‚Äù to it, respectively, the threat in it is minimal.  Fix it, let the front sector be slightly longer than the rest.  Then the membership function will return a greater threat when moving perpendicular to the wall.  Already increasing the radius of the sector by 1.1 times compared with other sectors saves us from this bug. <br>  Sometimes snakes hit their heads together or even the four of us.  It was established experimentally that with the increase in all sectors twice the collisions become less frequent.  But then the snakes become overly cautious - at a great distance from the minimal danger they turn and it becomes not so interesting to play.  Nevertheless, snakes still sometimes encounter "foreheads" together.  This, in my opinion, is the problem of this kind of intelligence: an analysis of only a nearby area at the current moment without an analysis of possible actions of the enemy in the following points in time. <br><br><h1>  Listings of Java &amp; Android SDK (v2.1) </h1><br>  And now I will give the working code, which for some reason is rarely done in most articles (which I have seen) on artificial intelligence with fuzzy logic.  You can clearly see how this AI works by playing in <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness</a> long-snake levels.  At the time of editing the article, this is the 4th level. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.iz.serpents.tools; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.LinkedList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.RectF; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.iz.serpents.model.Movement; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.iz.serpents.model.Serpent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.iz.serpents.model.SerpentCollidable; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Deepscorn * There are three sectors, which in sum gives us one half of circle, * these sectors corresponds to aim, specified in constructor. * Each sector (LEFT, RIGHT, FORWARD) is 60 degrees. * So, sector is 1/6 of circle square. * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CircleSector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* * Checks if circle sector has the given point. * Algorithm is: * 1) check distance &lt; radius * 2) check point is to the left of the first line * 3) check point is to the right of the second line */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector pt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pt.qdist(O) &lt; rad &amp;&amp; pt.isOnLine(O, A)&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pt.isOnLine(O, B)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* * Creates sector * @param movementType - one of Movement.*, used in sector creation, different * movementTypes means different sectors * Note, that FORWARD sector will have radius greater, than specified in circleRadius. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CircleSector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> circleRadius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> movementType, Vector aim, Vector circleCenter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movementType == Movement.FORWARD) rad = circleRadius * <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rad = circleRadius; O = circleCenter; type = movementType; _ptBones = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Vector&gt;(); _ptWalls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Vector&gt;(); Vector ortAim = (Vector) aim.clone(); ortAim.normalize(); Vector vC = ortAim.mul(rad); Vector vAC = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, vCB = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Movement.LEFT || type == Movement.FORWARD) { vAC = (Vector) vC.clone(); vAC.qrotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, Movement.LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Movement.FORWARD || type == Movement.RIGHT) { vCB = (Vector) vC.clone(); vCB.qrotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, Movement.RIGHT); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Movement.LEFT: Vector lo = (Vector) ortAim.clone(); lo.leftOrtogonalRotate(); A = O.add( lo.mul(rad) ); B = O.add(vAC); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Movement.FORWARD: A = O.add(vAC); B = O.add(vCB); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Movement.RIGHT: Vector ro = (Vector) ortAim.clone(); ro.rightOrtogonalRotate(); A = O.add(vCB); B = O.add( ro.mul(rad) ); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } possibleBonesInside = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((rad*rad)/ (<span class="hljs-number"><span class="hljs-number">6f</span></span>*Serpent.boneRad()*Serpent.boneRad())); } <span class="hljs-comment"><span class="hljs-comment">/* * Fills sector with content */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addBones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? extends Serpent&gt; serpents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indAI)</span></span></span><span class="hljs-function"> </span></span>{ _indAI = indAI; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;serpents.size();j++) { Serpent s = serpents.get(j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(j==indAI) start = SerpentCollidable.afterNeckInd; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=start;i&lt;s.numBones();i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hasPoint(s.bone(i))) _ptBones.add(s.bone(i)); } } } <span class="hljs-comment"><span class="hljs-comment">/* * Gets number of bones in sector */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNumBones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ptBones.size(); } <span class="hljs-comment"><span class="hljs-comment">/* * Fills sector with content */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addWalls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RectF walls)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Vector&gt; walls_points = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Vector&gt;(); walls_points.add(Vector.create(walls.left, walls.top)); walls_points.add(Vector.create(walls.right, walls.top)); walls_points.add(Vector.create(walls.right, walls.bottom)); walls_points.add(Vector.create(walls.left, walls.bottom)); walls_points.add(Vector.create(walls.left, walls.top)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;walls_points.size()-<span class="hljs-number"><span class="hljs-number">1</span></span>;i++) { Vector common; <span class="hljs-comment"><span class="hljs-comment">//left common = Vector.intersect(walls_points.get(i), walls_points.get(i+1), O, A); if(common!=null) _ptWalls.add(common); //right common = Vector.intersect(walls_points.get(i), walls_points.get(i+1), O, B); if(common!=null) _ptWalls.add(common); //forward common = Vector.intersect(walls_points.get(i), walls_points.get(i+1), A, B); if(common!=null) _ptWalls.add(common); //corner if(_ptWalls.size()==1) _ptWalls.add(walls_points.get(i+1)); } } /* * Gets number of wall's ends in sector: * 0 - no walls * 2 - one wall * 3 - two walls (corner) * 4 - two walls * wall is a line with two (!) ends */ public int getNumWallEnds() { return _ptWalls.size(); } /* * Gets distance to closest serpent in range [0;rad] * Attention! Distance = rad, when there actually * no serpents! */ public float distToClosestSerpent() { float res = rad; for(int i=0;i&lt;_ptBones.size();i++) { float dist = _ptBones.get(i).qdist(O); if(dist &lt; res) res = dist; } return res; } /* * Gets distance to closest wall in range [0;rad] * Attention! Distance = rad, when there actually * no walls! */ public float distToClosestWall() { float res = rad; for(int i=0;i&lt;_ptWalls.size();i++) { float dist = _ptWalls.get(i).qdist(O); if(dist &lt; res) res = dist; } return res; } //RELATION FUNCTIONS// //all relation functions returns value in ragne [0;1], //where 1 - is "the worst" or "the biggest" threat //and 0 - means no threat at all public float rel_distToClosestSerpent() { return 1 - distToClosestSerpent()/rad; } public float rel_serpentsStrength() { return ((float)getNumBones())/possibleBonesInside; } public float rel_distToClosestWall() { return 1 - distToClosestWall()/rad; } public float rel_inCorner() { float res = 0; if(getNumWallEnds()==4) res = 0.5f; if(getNumWallEnds()==3) res = 1f; return res; } public float rel_max_threat() { return Math.max( Math.max(rel_distToClosestSerpent(), rel_serpentsStrength()), Math.max(rel_distToClosestWall(), rel_inCorner())); } /* * Finds minimal threat and returns index of the element. * Keep in mind, that if all threats are equal, than the first * sector will be returned. */ public static int findMinThreatReturnIndex(ICircleSectorReadable sector[]) { float min = sector[0].rel_max_threat(); int result = 0; for(int i=1;i&lt;sector.length;i++) { float cur = sector[i].rel_max_threat(); if(min&gt;cur) { result = i; min = cur; } } return result; } //RELATION FUNCTIONS END// //sector geometry private Vector O; private Vector A; private Vector B; private final float rad; private final int type; private final int possibleBonesInside; //sector is presented as two lines: (O,A) - left line, (0,B) - right line, //O - is center of circle, which sector it is //rad - radius of circle, which sector it is //type is one of Movement.*, used in sector creation, different //movementTypes means different sectors //when working with walls there used triangular instead of circle center - for //performance reasons //initialed if necessary: //sector content private List&lt;Vector&gt; _ptBones = null; private List&lt;Vector&gt; _ptWalls = null; //sector owner private int _indAI; }</span></span></code> </pre> <br><br><h1>  results </h1><br>  Below are screenshots from <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness</a> in AI debugging mode. <br>  White marked the boundaries of the sectors - triangles (for the walls, for the bones - easy to imagine). <br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/ddd/b17/a7cdddb17529b1701290b9a1de586337.jpg"><br>  Yellow highlighted bones in the sector. <br><img src="https://habrastorage.org/getpro/habr/post_images/776/ec3/933/776ec39338601686bb7e14a6f01ce02b.jpg"><br>  And red - the walls in the sector. <br><img src="https://habrastorage.org/getpro/habr/post_images/dae/6e2/400/dae6e24009c29b8afaaf711044943ab0.jpg"><br>  Sometimes they still collide.  As I wrote above, this is eliminated by an increase in sectors.  But within the framework of the game, an invincible AI was not needed. <br><img src="https://habrastorage.org/getpro/habr/post_images/7de/1dd/a93/7de1dda93a980b2678c1a61f86d586b3.jpg"><br>  But overall, the AI ‚Äã‚Äãis great: <br><img src="https://habrastorage.org/getpro/habr/post_images/7d6/24a/11f/7d624a11fb06e885d1cccb48162a485d.jpg"><br>  This is my first development for the Android platform and the first AI with fuzzy logic, if you have any suggestions and comments - always ready to listen.  Thanks for attention.  If you are interested in the game, you can download it from Android Market: <br>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.gamelift.serpents">Serpent's Madness</a> <br></div><p>Source: <a href="https://habr.com/ru/post/137159/">https://habr.com/ru/post/137159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137153/index.html">XenForo: add a new page to the help section</a></li>
<li><a href="../137154/index.html">Creating an Event Waiting Badge with HTML5 canvas</a></li>
<li><a href="../137155/index.html">Managing Arduino from your phone</a></li>
<li><a href="../137157/index.html">Easy pay and tax</a></li>
<li><a href="../137158/index.html">iPhonekino - video review of applications and games for the iPhone</a></li>
<li><a href="../137160/index.html">Request to add a blog "Bioinformatics"</a></li>
<li><a href="../137161/index.html">Audit tables with features in PostGIS / PostgreSQL</a></li>
<li><a href="../137162/index.html">Nuances in the logic of the 3g PeopleNET operator</a></li>
<li><a href="../137163/index.html">Racing technologies: Electronic Control Unit</a></li>
<li><a href="../137166/index.html">The results of the tender tender VKontakte to create smiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>