<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We overclock JTAG router</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If suddenly you need to debug several microcontrollers / microprocessors in the Crimea, drinking smoothies from the stuffy office in Khimki. If the mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We overclock JTAG router</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/246/ed6/597/246ed659739644049ad207725286591d.png"><br>  If suddenly you need to debug several microcontrollers / microprocessors in the Crimea, drinking smoothies from the stuffy office in Khimki.  If the microprocessor board is on a moving object and there is no way to reach out to it with a JTAG debugger (the board is on a balloon / quadcopter).  If you just need galvanic isolation between the host and the debugged board (for example, a high-voltage device).  And it‚Äôs good that it‚Äôs still cheap, cheerful and universal to the manufacturer (STM, Broadcom, Xilinx, etc) or architecture (ARM, MIPS, FPGA, etc).  Then you need a router, yes, yes, just a router, let's say, like this. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/geektimes/post_images/3a9/c06/f83/3a9c06f8316481c4695a7cab8b686b4f.jpg" alt="image"><br>  <i>Picture from sagemcom.ru</i> <br><br>  Let's look inside: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c8e/2ff/765/c8e2ff765b2a6c1c4a479e9c7b5ea6c8.png" alt="image"><br>  <i>wiki.openwrt.org</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So this is Sagem F @ ST2704 V2, distributed by Rostelecom throughout the country.  We have a SoC BCM6328 core MIPS architecture, 320 MHz, a pair of unsoldered USB ports [1].  There is wifi and ethernet.  And the most pleasant thing is the release of openwrt on this model.  All that is needed from the equipment for the above purposes. <br><br>  Immediately there is an idea to pick up the st-link and try to forward the USB through the network.  It looks like a crutch, most likely promises to work is not fast and not very stable, the overhead head is huge.  Looking further, what can be done. <br><br>  You can port openocd to openwrt, pick up a st-link or ftdi-chip and run a gdb server.  The blessing in openwrt already ported openocd.  It seems enough to dwell on this option.  But I also want to see what options openocd gives us.  And here in the documentation interface sysfsgpio comes across.  What you need, it is possible to control the signals tck, tdi, tdo, using standard OS linux tools via / sys / class / gpio on the soldered pins of the chip. <br><br>  We try.  To begin with, we collect openwrt (using the chaos_calmer branch) together with openocd.  By default, the soldered GPIO features light indication functions, as well as polling buttons for executing some commands (rfkill, reset, and wpsc).  So that they do not interfere, I turned them off, removing the corresponding kernel modules from the assembly. <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$cat</span></span> target/linux/brcm63xx/config-3.18 b/target/linux/brcm63xx/config-3.18 ... <span class="hljs-comment"><span class="hljs-comment"># CONFIG_NEW_LEDS is not set ‚Ä¶ $cat .config ‚Ä¶ # CONFIG_PACKAGE_kmod-input-gpio-keys-polled is not set ... # CONFIG_PACKAGE_kmod-input-polldev is not set ... CONFIG_PACKAGE_openocd=y</span></span></code> </pre> <br>  assembly itself: <br><br><pre> <code class="bash hljs">./scripts/feeds update -a ./scripts/feeds install -a make V=s</code> </pre><br>  Firmware: <br><br><pre> <code class="bash hljs">mtd -q write openwrt-brcm63xx-generic-F@ST2704V2-squashfs-cfe.bin linux</code> </pre><br>  For the sysfsgpio test we make a config: <br><br><pre> <code class="bash hljs">root@OpenWrt:~<span class="hljs-comment"><span class="hljs-comment"># cat sysfs.cfg.2.11 interface sysfsgpio transport select swd sysfsgpio_swclk_num 482 sysfsgpio_swdio_num 491 source [find target/stm32f1x.cfg]</span></span></code> </pre><br>  Connect as in the photo: <br><br><img src="https://habrastorage.org/files/e07/279/152/e07279152f9c4347af961fc1368c2275.png"><br><br>  Run: <br><br><pre> <code class="hljs pgsql">root@OpenWrt:~# openocd -f sysfs.cfg<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">On</span></span>-Chip Debugger <span class="hljs-number"><span class="hljs-number">0.10</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>+dev<span class="hljs-number"><span class="hljs-number">-00085</span></span>-gfced6ac6-dirty (<span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-03</span></span>-xx<span class="hljs-number"><span class="hljs-number">-21</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span>) Licensed under GNU GPL v2 <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> bug reports, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> http://openocd.org/doc/doxygen/bugs.html SysfsGPIO num: swclk = <span class="hljs-number"><span class="hljs-number">482</span></span> SysfsGPIO num: swdio = <span class="hljs-number"><span class="hljs-number">491</span></span> SysfsGPIO num: trst = <span class="hljs-number"><span class="hljs-number">481</span></span> adapter speed: <span class="hljs-number"><span class="hljs-number">1000</span></span> kHz adapter_nsrst_delay: <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> separate cortex_m reset_config sysresetreq <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SysfsGPIO JTAG/SWD bitbang driver <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SWD <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> mode enabled (specify tck, tms, tdi <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tdo gpios <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> JTAG mode) Warn : gpio <span class="hljs-number"><span class="hljs-number">482</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> already exported Warn : gpio <span class="hljs-number"><span class="hljs-number">491</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> already exported <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : This adapter doesn<span class="hljs-string"><span class="hljs-string">'t support configurable speed Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span></span></code> </pre> <br>  We start debug in IDE, everything works. <br><br><img src="https://habrastorage.org/files/3f0/983/aec/3f0983aecb41441592f838b44e8ca5db.png"><br><br>  Only very slowly. <br><br>  We try to quantify the speed, go telnet to the router: <br><br><pre> <code class="bash hljs">telnet 10.65.9.239 4444</code> </pre><br>  We make a memory dump. <br><br><pre> <code class="hljs swift">&gt; dump_image <span class="hljs-built_in"><span class="hljs-built_in">dump</span></span>.bin <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x1ffff</span></span> dumped <span class="hljs-number"><span class="hljs-number">131071</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>.013523s (<span class="hljs-number"><span class="hljs-number">2.327</span></span> <span class="hljs-type"><span class="hljs-type">KiB</span></span>/s)</code> </pre><br>  Hmm, for example, st-linkv2 on my host gives a speed of about 45 KiB / s.  20 times the difference! <br><br><img src="https://habrastorage.org/files/a12/7ef/250/a127ef250a2c41adae14f1f5ae211050.png"><br><br>  The point, of course, is because of the slow work with files in / sys / class / gpio.  We are picked further in openocd.  Find the interface driver for RaspberryPi (src / jtag / drivers / bcm2835gpio.c).  Judging by the tests [5], it should have a speed like about st-link.  This is achieved, in many respects, through direct access to the GPIO registers.  We will do the same for our SoC, as well as this will be true for the entire bcm63xx chip family. <br><br><div class="spoiler">  <b class="spoiler_title">This is the interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @file * This driver implements a bitbang jtag interface using gpio lines via * router ob BCM63XX SoC. * The aim of this driver implementation is use system GPIOs but avoid the * need for a additional kernel driver. * (Note memory mapped IO is another option, however it doesn't mix well with * the kernel gpiolib driver - which makes sense I guess.) * * A gpio is required for tck, tms, tdi and tdo. One or both of srst and trst * must be also be specified. The required jtag gpios are specified via the * bcm63xx_gpio_jtag_nums command or the relevant bcm63xx_gpio_XXX_num commang. * The srst and trst gpios are set via the bcm63xx_gpio_srst_num and * bcm63xx_gpio_trst_num respectively. GPIO numbering follows the kernel * convention of starting from 0. * * The gpios should not be in use by another entity, and must not be requested * by a kernel driver without also being exported by it (otherwise they can't * be exported by bcm63xx_). * * The bcm63xx gpio interface can only manipulate one gpio at a time, so the * bitbang write handler remembers the last state for tck, tms, tdi to avoid * superfluous writes. * For speed the bcm63xx "value" entry is opened at init and held open. * This results in considerable gains over open-write-close (45s vs 900s) * * Further work could address: * -srst and trst open drain/ push pull * -configurable active high/low for srst &amp; trst */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_CONFIG_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jtag/interface.h&gt; #include "bitbang.h" #include &lt;sys/mman.h&gt; /* * Helper func to determine if gpio number valid * * Assume here that there will be less than 1000 gpios on a system */ static int is_gpio_valid(int gpio) { return gpio &gt;= 0 &amp;&amp; gpio &lt; 32; } off_t address_dir = NULL; off_t address_val = NULL; static int dev_mem_fd = -1; static volatile uint32_t *pio_base = NULL; static volatile uint32_t *pval_base = NULL; static volatile uint32_t *pads_base = NULL; static unsigned int jtag_delay = 0; static void set_dir_gpio(const int gpio, const int direction) { if(direction) *pio_base |= 1 &lt;&lt; gpio; else *pio_base &amp;= ~(1 &lt;&lt; gpio); } static void set_value_gpio(const int gpio, const int value) { if(value) *pval_base |= 1 &lt;&lt; gpio; else *pval_base &amp;= ~(1 &lt;&lt; gpio); for (unsigned int i = 0; i &lt; jtag_delay; i++) asm volatile (""); } static int read_gpio(const int gpio) { uint32_t val = *pval_base &amp; (1 &lt;&lt; gpio); val = val ? 1 : 0; return val; } static int setup_bcm63xx_gpio(int gpio, int is_output, int init_high) { char buf[40]; char gpiostr[4]; int ret; if (!is_gpio_valid(gpio)) return ERROR_OK; if((address_dir == NULL) || (address_val == NULL)){ perror("address of gpio register don't set"); return ERROR_FAIL; } if( dev_mem_fd &lt; 0 ) { dev_mem_fd = open("/dev/mem", O_RDWR | O_SYNC); if (dev_mem_fd &lt; 0) { perror("open"); return ERROR_FAIL; } const uint32_t mapped_size = getpagesize(); const off_t target_mmap = address_dir &amp; ~(off_t)(mapped_size - 1); pads_base = mmap(NULL, mapped_size, PROT_READ | PROT_WRITE, MAP_SHARED, dev_mem_fd, target_mmap); if (pads_base == MAP_FAILED) { perror("mmap. Check correct register address."); close(dev_mem_fd); return ERROR_FAIL; } pio_base = (char*)pads_base + (unsigned)(address_dir - target_mmap); pval_base = (char*)pads_base + (unsigned)(address_val - target_mmap); } set_dir_gpio(gpio, is_output); set_value_gpio(gpio, init_high); return 0; } /* gpio numbers for each gpio. Negative values are invalid */ static int tck_gpio = -1; static int tms_gpio = -1; static int tdi_gpio = -1; static int tdo_gpio = -1; static int trst_gpio = -1; static int srst_gpio = -1; static int swclk_gpio = -1; static int swdio_gpio = -1; /* * file descriptors for /sys/class/gpio/gpioXX/value * Set up during init. */ static int tck_fd = -1; static int tms_fd = -1; static int tdi_fd = -1; static int tdo_fd = -1; static int trst_fd = -1; static int srst_fd = -1; static int swclk_fd = -1; static int swdio_fd = -1; static int last_swclk; static int last_swdio; static bool last_stored; static bool swdio_input; static void bcm63xx_gpio_swdio_drive(bool is_output) { set_dir_gpio(swdio_gpio, is_output ? 1 : 0); last_stored = false; swdio_input = !is_output; } static int bcm63xx_gpio_swdio_read(void) { return read_gpio(swdio_gpio); } static void bcm63xx_gpio_swdio_write(int swclk, int swdio) { const char one[] = "1"; const char zero[] = "0"; size_t bytes_written; if (!swdio_input) { if (!last_stored || (swdio != last_swdio)) { set_value_gpio(swdio_gpio, swdio ? 1 : 0); } } /* write swclk last */ if (!last_stored || (swclk != last_swclk)) { set_value_gpio(swclk_gpio, swclk ? 1 : 0); } last_swdio = swdio; last_swclk = swclk; last_stored = true; } /* * Bitbang interface read of TDO * * The bcm63xx value will read back either '0' or '1'. The trick here is to call * lseek to bypass buffering in the bcm63xx kernel driver. */ static int bcm63xx_gpio_read(void) { return read_gpio(tdo_gpio); } /* * Bitbang interface write of TCK, TMS, TDI * * Seeing as this is the only function where the outputs are changed, * we can cache the old value to avoid needlessly writing it. */ static void bcm63xx_gpio_write(int tck, int tms, int tdi) { if (swd_mode) { bcm63xx_gpio_swdio_write(tck, tdi); return; } const char one[] = "1"; const char zero[] = "0"; static int last_tck; static int last_tms; static int last_tdi; static int first_time; size_t bytes_written; if (!first_time) { last_tck = !tck; last_tms = !tms; last_tdi = !tdi; first_time = 1; } if (tdi != last_tdi) { set_value_gpio(tdi_gpio,tdi); } if (tms != last_tms) { set_value_gpio(tms_gpio,tms); } /* write clk last */ if (tck != last_tck) { set_value_gpio(tck_gpio,tck); } last_tdi = tdi; last_tms = tms; last_tck = tck; } /* * Bitbang interface to manipulate reset lines SRST and TRST * * (1) assert or (0) deassert reset lines */ static void bcm63xx_gpio_reset(int trst, int srst) { LOG_DEBUG("bcm63xx_gpio_reset"); const char one[] = "1"; const char zero[] = "0"; size_t bytes_written; /* assume active low */ if (srst_fd &gt;= 0) { set_value_gpio(srst_gpio,srst); } /* assume active low */ if (trst_fd &gt;= 0) { set_value_gpio(trst_gpio,trst); } } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionums) { if (CMD_ARGC == 4) { COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], tms_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], tdi_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], tdo_gpio); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO nums: tck = %d, tms = %d, tdi = %d, tdo = %d", tck_gpio, tms_gpio, tdi_gpio, tdo_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tck) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tck = %d", tck_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tms) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tms_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tms = %d", tms_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tdo) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdo_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tdo = %d", tdo_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_tdi) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdi_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: tdi = %d", tdi_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_srst) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], srst_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: srst = %d", srst_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_jtag_gpionum_trst) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], trst_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: trst = %d", trst_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionums) { if (CMD_ARGC == 2) { COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio); COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], swdio_gpio); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO nums: swclk = %d, swdio = %d", swclk_gpio, swdio_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionum_swclk) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: swclk = %d", swclk_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_handle_swd_gpionum_swdio) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swdio_gpio); command_print(CMD_CTX, "bcm63xx_GPIO num: swdio = %d", swdio_gpio); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_jtag_delay) { if (CMD_ARGC == 1) COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], jtag_delay); command_print(CMD_CTX, "bcm63xx_GPIO jtag_delay:= %d tics", jtag_delay); return ERROR_OK; } COMMAND_HANDLER(bcm63xx_gpio_adresses) { if (CMD_ARGC == 2) { COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address_dir); COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], address_val); } else if (CMD_ARGC != 0) { return ERROR_COMMAND_SYNTAX_ERROR; } command_print(CMD_CTX, "bcm63xx_GPIO address: direction = %x, value = %x", address_dir, address_val); return ERROR_OK; } static const struct command_registration bcm63xx_gpio_command_handlers[] = { { .name = "bcm63xx_gpio_jtag_nums", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionums, .mode = COMMAND_CONFIG, .help = "gpio numbers for tck, tms, tdi, tdo. (in that order)", .usage = "(tck tms tdi tdo)* ", }, { .name = "bcm63xx_gpio_tck_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tck, .mode = COMMAND_CONFIG, .help = "gpio number for tck.", }, { .name = "bcm63xx_gpio_tms_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tms, .mode = COMMAND_CONFIG, .help = "gpio number for tms.", }, { .name = "bcm63xx_gpio_tdo_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tdo, .mode = COMMAND_CONFIG, .help = "gpio number for tdo.", }, { .name = "bcm63xx_gpio_tdi_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_tdi, .mode = COMMAND_CONFIG, .help = "gpio number for tdi.", }, { .name = "bcm63xx_gpio_srst_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_srst, .mode = COMMAND_CONFIG, .help = "gpio number for srst.", }, { .name = "bcm63xx_gpio_trst_num", .handler = &amp;bcm63xx_gpio_handle_jtag_gpionum_trst, .mode = COMMAND_CONFIG, .help = "gpio number for trst.", }, { .name = "bcm63xx_gpio_swd_nums", .handler = &amp;bcm63xx_gpio_handle_swd_gpionums, .mode = COMMAND_CONFIG, .help = "gpio numbers for swclk, swdio. (in that order)", .usage = "(swclk swdio)* ", }, { .name = "bcm63xx_gpio_swclk_num", .handler = &amp;bcm63xx_gpio_handle_swd_gpionum_swclk, .mode = COMMAND_CONFIG, .help = "gpio number for swclk.", }, { .name = "bcm63xx_gpio_swdio_num", .handler = &amp;bcm63xx_gpio_handle_swd_gpionum_swdio, .mode = COMMAND_CONFIG, .help = "gpio number for swdio.", }, { .name = "bcm63xx_gpio_jtag_delay", .handler = &amp;bcm63xx_gpio_jtag_delay, .mode = COMMAND_CONFIG, .help = "qty tics gpio delay.", }, { .name = "bcm63xx_gpio_adresses", .handler = &amp;bcm63xx_gpio_adresses, .mode = COMMAND_CONFIG, .help = "addresses for direction and value setup. (in that order)", .usage = "(address_dir address_val)* ", }, COMMAND_REGISTRATION_DONE }; static int bcm63xx_gpio_init(void); static int bcm63xx_gpio_quit(void); static const char * const bcm63xx_gpio_transports[] = { "jtag", "swd", NULL }; struct jtag_interface bcm63xxgpio_interface = { .name = "bcm63xxgpio", .supported = DEBUG_CAP_TMS_SEQ, .execute_queue = bitbang_execute_queue, .transports = bcm63xx_gpio_transports, .swd = &amp;bitbang_swd, .commands = bcm63xx_gpio_command_handlers, .init = bcm63xx_gpio_init, .quit = bcm63xx_gpio_quit, }; static struct bitbang_interface bcm63xx_gpio_bitbang = { .read = bcm63xx_gpio_read, .write = bcm63xx_gpio_write, .reset = bcm63xx_gpio_reset, .swdio_read = bcm63xx_gpio_swdio_read, .swdio_drive = bcm63xx_gpio_swdio_drive, .blink = 0 }; static void unusing_all_gpio(void) { munmap(pads_base, sysconf(_SC_PAGE_SIZE)); close(dev_mem_fd); LOG_INFO("unusing_all_gpio\n"); } static bool bcm63xx_gpio_jtag_mode_possible(void) { if (!is_gpio_valid(tck_gpio)) return 0; if (!is_gpio_valid(tms_gpio)) return 0; if (!is_gpio_valid(tdi_gpio)) return 0; if (!is_gpio_valid(tdo_gpio)) return 0; return 1; } static bool bcm63xx_gpio_swd_mode_possible(void) { if (!is_gpio_valid(swclk_gpio)) return 0; if (!is_gpio_valid(swdio_gpio)) return 0; return 1; } static int bcm63xx_gpio_init(void) { bitbang_interface = &amp;bcm63xx_gpio_bitbang; LOG_INFO("bcm63xx_gpio JTAG/SWD bitbang driver"); if (bcm63xx_gpio_jtag_mode_possible()) { if (bcm63xx_gpio_swd_mode_possible()) LOG_INFO("JTAG and SWD modes enabled"); else LOG_INFO("JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)"); if (!is_gpio_valid(trst_gpio) &amp;&amp; !is_gpio_valid(srst_gpio)) { LOG_ERROR("Require at least one of trst or srst gpios to be specified"); return ERROR_JTAG_INIT_FAILED; } } else if (bcm63xx_gpio_swd_mode_possible()) { LOG_INFO("SWD only mode enabled (specify tck, tms, tdi and tdo gpios to add JTAG mode)"); } else { LOG_ERROR("Require tck, tms, tdi and tdo gpios for JTAG mode and/or swclk and swdio gpio for SWD mode"); return ERROR_JTAG_INIT_FAILED; } /* * Configure TDO as an input, and TDI, TCK, TMS, TRST, SRST * as outputs. Drive TDI and TCK low, and TMS/TRST/SRST high. * For SWD, SWCLK and SWDIO are configures as output high. */ if (tck_gpio &gt;= 0) { tck_fd = setup_bcm63xx_gpio(tck_gpio, 1, 0); if (tck_fd &lt; 0) goto out_error; } if (tms_gpio &gt;= 0) { tms_fd = setup_bcm63xx_gpio(tms_gpio, 1, 1); if (tms_fd &lt; 0) goto out_error; } if (tdi_gpio &gt;= 0) { tdi_fd = setup_bcm63xx_gpio(tdi_gpio, 1, 0); if (tdi_fd &lt; 0) goto out_error; } if (tdo_gpio &gt;= 0) { tdo_fd = setup_bcm63xx_gpio(tdo_gpio, 0, 0); if (tdo_fd &lt; 0) goto out_error; } /* assume active low*/ if (trst_gpio &gt;= 0) { trst_fd = setup_bcm63xx_gpio(trst_gpio, 1, 1); if (trst_fd &lt; 0) goto out_error; } /* assume active low*/ if (srst_gpio &gt;= 0) { srst_fd = setup_bcm63xx_gpio(srst_gpio, 1, 1); if (srst_fd &lt; 0) goto out_error; } if (swclk_gpio &gt;= 0) { swclk_fd = setup_bcm63xx_gpio(swclk_gpio, 1, 0); if (swclk_fd &lt; 0) goto out_error; } if (swdio_gpio &gt;= 0) { swdio_fd = setup_bcm63xx_gpio(swdio_gpio, 1, 0); if (swdio_fd &lt; 0) goto out_error; } if (bcm63xx_gpio_swd_mode_possible()) { if (swd_mode) bitbang_swd_switch_seq(JTAG_TO_SWD); else bitbang_swd_switch_seq(SWD_TO_JTAG); } return ERROR_OK; out_error: unusing_all_gpio(); return ERROR_JTAG_INIT_FAILED; } static int bcm63xx_gpio_quit(void) { unusing_all_gpio(); return ERROR_OK; }</span></span></span></span></code> </pre><br></div></div><br>  Compared with sysfsgpio, added a couple of options: <br><br><ul><li>  bcm63xx_gpio_jtag_delay </li><li>  bcm63xx_gpio_adresses </li></ul><br>  The first setting sets the delay between pin switching, is an indirect analogue of bcm2835gpio_speed_coeffs for the RaspberryPi driver, which sets the frequency of jtag operation.  For example, with zero delay, the switching frequency was about one megahertz, everything worked quite stably, but for reliability it is better to be able to set this parameter. <br><br>  And the second option is an analogue of bcm2835gpio_peripheral_base, only for it you need to register two addresses for the register, which defines the input / output function of the pins, and the register, which is responsible for the input / output logical value on gpio.  In the beginning, I took the values ‚Äã‚Äãof registers from the kernel header files.  But with these values, nothing worked.  It turned out that the peripheral registers cannot be directly accessed from userspace, i.e.  REMAP must be made still in the kernel.  It‚Äôs good that for me this is already implemented by the gpio driver and the necessary values ‚Äã‚Äãcan be taken from / proc / iomem. <br><br>  <a href="https://github.com/ser-mk/openocd/commit/7f17ba233db12e29c5c39f8065173d445db15fe1">Add our interface to the openocd assembly</a> <br><br>  Do not forget to add the --enable-bcm63xxgpio to the CONFIGURE_ARGS file in the feeds / packages / utils / openocd / Makefile. <br><br>  Reassemble, install and run on the router: <br><br><pre> <code class="hljs pgsql">root@OpenWrt:~# openocd -f interface/bcm63xx-swd.cfg -f target/stm32f1x.cfg <span class="hljs-keyword"><span class="hljs-keyword">Open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">On</span></span>-Chip Debugger <span class="hljs-number"><span class="hljs-number">0.10</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>+dev<span class="hljs-number"><span class="hljs-number">-00085</span></span>-gfced6ac6-dirty (<span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-03</span></span>-xx<span class="hljs-number"><span class="hljs-number">-21</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span>) Licensed under GNU GPL v2 <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> bug reports, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> http://openocd.org/doc/doxygen/bugs.html bcm63xx_GPIO num: swclk = <span class="hljs-number"><span class="hljs-number">2</span></span> bcm63xx_GPIO num: swdio = <span class="hljs-number"><span class="hljs-number">11</span></span> bcm63xx_GPIO jtag_delay:= <span class="hljs-number"><span class="hljs-number">10</span></span> tics bcm63xx_GPIO address: direction = <span class="hljs-number"><span class="hljs-number">10000084</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">1000008</span></span>c adapter speed: <span class="hljs-number"><span class="hljs-number">1000</span></span> kHz adapter_nsrst_delay: <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> separate cortex_m reset_config sysresetreq <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : bcm63xx_gpio JTAG/SWD bitbang driver <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : SWD <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> mode enabled (specify tck, tms, tdi <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tdo gpios <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> JTAG mode) <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> : This adapter doesn<span class="hljs-string"><span class="hljs-string">'t support configurable speed Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span></span></code> </pre><br>  Check the speed of the dump. <br><br><pre> <code class="hljs swift">&gt; dump_image <span class="hljs-built_in"><span class="hljs-built_in">dump</span></span>.bin <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x1ffff</span></span> dumped <span class="hljs-number"><span class="hljs-number">131071</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>.729815s (<span class="hljs-number"><span class="hljs-number">27.062</span></span> <span class="hljs-type"><span class="hljs-type">KiB</span></span>/s)</code> </pre><br>  Very well, we lose twice the st-link and raspberry, but the difference is not noticeable by the eye.  There are no freezes when debugging, well, wait for the extra couple of seconds with the firmware - ‚ÄúPonte‚Äù. <br><br>  All tests were conducted on the STM32F103C8T6 microcontroller and only on the SWD interface, on the debugged board, unfortunately, there was no jtag.  Accordingly, therefore, I cannot guarantee full-fledged work on jtag.  In addition, we must not forget about the coordination of signal levels (in particular for the MK AVR). <br><br>  The router itself was taken from a handful of junk, among which was full of Sagem F @ st 2704V2 and V7.  Unfortunately, all devices were out of whack.  But it was possible to restore the board without any problems (see [2]). <br><br>  If someone is ready to make a debugger / programmer out of this constructor, then he is ready to share his stock with the public on a gratuitous basis with the removal of all responsibility and funds for sending (from default-city). <br><br>  Updated firmware <a href="">here</a> . <br>  I warn you that the standard network settings and firewall are changed. <br><br>  That's all, successful debugging! <br><br><h3>  List of useful resources </h3><br><ol><li>  <a href="https://wiki.openwrt.org/toh/sagem/fast2704">wiki.openwrt.org/toh/sagem/fast2704</a> </li><li>  <a href="http://radiohlam.ru/forum/viewtopic.php%3Ff%3D54%26t%3D3749">radiohlam.ru/forum/viewtopic.php?f=54&amp;t=3749</a> </li><li>  <a href="http://openocd.org/">openocd.org</a> </li><li>  <a href="https://developer.mbed.org/handbook/CMSIS-DAP">developer.mbed.org/handbook/CMSIS-DAP</a> </li><li>  <a href="https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Programming-an-STM32F103XXX-with-a-generic-ST-Link-V2-programmer-from-Linux">github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Programming-an-STM32F103XXX-with-a-generic-ST-Link-V2-programmer-from-Linux</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/402233/">https://habr.com/ru/post/402233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../402221/index.html">Dear hackers, where are your autonomous lawn mowers?</a></li>
<li><a href="../402225/index.html">Silicon Graphics O2 - Small station with great potential</a></li>
<li><a href="../402227/index.html">Intel will pay $ 15.3 billion for a company developing equipment for ro-mobiles</a></li>
<li><a href="../402229/index.html">China is developing a reusable spacecraft for the flight to the moon</a></li>
<li><a href="../402231/index.html">Ask Ethan: Can dark energy lead to a repetition of the life cycle of the universe?</a></li>
<li><a href="../402235/index.html">Detailed road maps are needed for smart cars, not for people.</a></li>
<li><a href="../402237/index.html">Why Intel Mobileye?</a></li>
<li><a href="../402239/index.html">Religious Network</a></li>
<li><a href="../402241/index.html">Arduino-compatible PLC CONTROLLINO, part 1</a></li>
<li><a href="../402243/index.html">Micro-UPS on ionistors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>