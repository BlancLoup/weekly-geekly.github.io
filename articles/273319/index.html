<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Star Wars Universe Social Network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Someone is waiting for Christmas, someone - a new series of Star Wars, "The Awakening of Power." And at this time I decided to process the entire six-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Star Wars Universe Social Network</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/496/3e6/710/4963e671083f06363a57f5005cfe17cc.png" alt="image"><br><br>  Someone is waiting for Christmas, someone - a new series of Star Wars, "The Awakening of Power."  And at this time I decided to process the entire six-part cycle from a quantitative point of view and isolate the social networks contained in it - both from each film separately, and from the whole universe of pollutants together.  A close look at the social networks reveals interesting differences between the original parts and their prequels. <br><br>  Below is a social network extracted from all 6 films in total. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/4fb/c4c/e2b/4fbc4ce2b0d4ec915d94e8788f7e4794.png" alt="image"><br><br>  <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/interactions.html"><b>open</b></a> <br><a name="habracut"></a><br>  You can open an interactive page, where visualization will be presented with mouse pulling capabilities of individual nodes.  When you hover over the node you will see the name of the character. <br><br>  Nodes are characters.  Their connecting line means that they speak in the same scene.  The more they say, the thicker the line.  The size of each node is proportional to the number of scenes in which the character appears.  We had to make a lot of difficult decisions: for example, Anakin and Darth Vader are obviously the same character, but they are represented by different nodes in the visualization, since this separation is important for the plot.  And vice versa, I specifically united Palpatine with Darth Sidious, and Amidala - with Padme. <br><br>  The characters of the original trilogy are mostly located to the right and practically separated from the characters of the prequels, since most of the characters appear only in one of the trilogies.  The main nodes connecting both networks are Obi-Wan Kenobi, R2-D2 and C-3PO.  Robots, obviously, are of particular importance for the plot, because they appear most often in films.  The structure of both subnets is different.  The original trilogy has fewer important knots (Luke, Hahn, Leah, Chewbacca, and Darth Vader), and they are tightly interconnected.  Prequels show more nodes and more connecting lines. <br><br><h4>  Character timelines </h4><br>  Since the same characters are found in different films, I created a comparative timeline, broken down into episodes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcb/5e7/635/fcb5e763502d90cb61a0b373bfb6aa22.png" alt="image"><br><br>  Here are all the references to the characters, including the mention of their names in the conversations of others.  Anakin appears with Darth Vader in episode 3, and then Darth Vader picks up.  Anakin reappears by the end of episode 6, in which Darth Vader turns away from the Dark Side. <br><br>  The same characters that are constantly involved in all the films are in the center of the social network.  These are Obi-Wan, C-3PO and R2-D2.  Yoda and the Emperor are also in all films, but they speak to a small number of people. <br><br>  Networks for individual episodes <br><br>  Now consider the episodes separately.  Notice how the number of nodes and the complexity of networks vary from prequels to original episodes.  (clickable). <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode1-interactions.html"><img src="https://habrastorage.org/getpro/habr/post_images/005/7ea/eb8/0057eaeb8bdb4a6fe02f57df0fc64813.png" alt="image"></a> <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode2-interactions.html"><img src="https://habrastorage.org/getpro/habr/post_images/838/d4d/64e/838d4d64ea726abc87f48a75e4a90a39.png" alt="image"></a> <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode3-interactions.html"><img src="https://habrastorage.org/getpro/habr/post_images/e3b/3fc/881/e3b3fc8814a7591ea2efe9aa6bc2befe.png" alt="image"></a> <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode4-interactions.html"><img src="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode4.png" alt="image"></a> <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode5-interactions.html"><img src="https://habrastorage.org/getpro/habr/post_images/294/b10/2ee/294b102ee63a206d56939e84a510bc70.png" alt="image"></a> <br><br> <a href="http://evelinag.com/blog/2015/12-15-star-wars-social-network/episode6-interactions.html"><img src="https://habrastorage.org/getpro/habr/post_images/055/ffa/709/055ffa70982ff3213d1ac184b2c7d647.png" alt="image"></a> <br><br>  Again it is clear that in the prequels there are more characters and more interactions of different characters with each other.  In the original films, the characters are smaller, but they interact more often. <br><br>  George Lucas once <a href="http://www.theguardian.com/commentisfree/2015/dec/14/myth-star-wars-force-awakens-heroic-legends">said</a> : <br><blockquote>  In fact, this is the story of the tragedy of Darth Vader, it begins when he is nine years old, and ends with his death. </blockquote><br><br>  But is Darth Vader / Anakin really a central character?  Let's try to apply the methods of network analysis to identify the central characters and their social structure.  I calculated two parameters showing the importance of the character on the network. <br><br><ul><li>  degree of importance: the number of connecting lines at the node in the network.  That is, the total number of scenes in which he talks. </li><li>  Intermediateness: The number of shortest paths leading through a node.  For example, if you are Leia, and you want to send a message to Grido, then the shortest path to it will be the path through Han Solo.  And in order to send a message to Luke, it is not necessary to go through Hana, since Leia knows him personally.  In this way, the interimness of Khan is calculated - through the number of shortest paths between all other characters passing through it. </li></ul><br><br>  The first parameter as a result shows how many characters the character contacts, and the second one is how important it is for the story as a whole.  Characters with high intermediateness unite different parts of social networks. <br><br>  The larger the parameter, the more important it is.  Below are the Top-5 characters, ranked by parameters, for each movie. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdd/ba8/095/bddba8095219443804ec8a95421f50fa.png" alt="image"><br><br>  In the first three episodes, Anakin was the most connected character.  At the same time, he practically does not participate in integration - his interimness is so small that he did not even get into the Top-5.  It turns out that other characters communicate personally, and not through him.  And what will it look like for the original trilogy? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c7/393/12a/1c739312af1e2a5064968f9399284456.png" alt="image"><br><br>  The analysis of centrality numerically expresses our impression from the visualization of social networks.  In prequels, the social structure is more complex, more characters.  And Anakin is not a central figure - some storylines develop in parallel, or relate to it only indirectly.  On the other hand, the original trilogy looks more coherent.  There are fewer characters linking the story. <br><br>  Perhaps because of this, the original trilogy is more popular.  The plots are more consistent, and develop thanks to the main characters.  The prequel structure is less centralized, there is no central character. <br><br>  And what will these measurements look like when applied to all films at once?  I made two versions of the calculations - with the separation of the characters of Anakin and Darth Vader, and with the union. <br><br>  On the left - two separate characters, on the right - the characters are combined: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/c0a/826/7b8c0a826596b4bb214188d023246ff8.png" alt="image"><br><br>  In the first case, Anakin remains the most connected character, but not the central one.  When they are combined, he becomes the third most important character in the intermediate ranking.  In any case, it turns out that in reality, the films are united by the character Obi-Wan Kenobi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/0bc/575/ee20bc5758797c7c74c7b4b76239c289.jpg" alt="image"><br><br><h4>  How is it done </h4><br>  For the most part, I used <a href="http://fsharp.org/">F #</a> , combining it with <a href="http://d3js.org/">D3.js</a> for social network visualizations, and <a href="https://www.r-project.org/">R</a> for analyzing the centrality of networks.  All sources are available on <a href="https://github.com/evelinag/StarWars-social-network">github</a> .  Here I will analyze only the individual, most interesting parts of the code. <br><br><h5>  Parsing scripts </h5><br>  I freely downloaded all the scripts from <a href="http://www.imsdb.com/">The Internet Movie Script Database</a> (IMSDb) (example: <a href="http://www.imsdb.com/scripts/Star-Wars-A-New-Hope.html">Episode IV script: The New Hope</a> ).  True, there are mostly drafts, which are often different from the final versions. <br><br>  The first step is the analysis of scenarios.  It turned out that different files have a slightly different format.  They are all represented in HTML, either between tags, or between.  I used the <a href="http://fsharp.github.io/FSharp.Data/library/HtmlParser.html">Html Parser</a> from the F # Data library, which allows accessing individual tags using queries like: <br><br><pre><code class="java hljs">open FSharp.Data let url = <span class="hljs-string"><span class="hljs-string">"http://www.imsdb.com/scripts/Star-Wars-A-New-Hope.html"</span></span> HtmlDocument.Load(url).Descendants(<span class="hljs-string"><span class="hljs-string">"pre"</span></span>)</code> </pre> <br><br>  The code is available in the <a href="">parseScripts.fs</a> file <br><br>  The next step is to extract the necessary information from the scripts.  Usually they look like this: <br><br> <code>INT. GANTRY - OUTSIDE CONTROL ROOM - REACTOR SHAFT <br> <br> Luke moves along the railing and up to the control room. <br> <br> [...] <br> LUKE <br> He told me enough! It was you <br> who killed him. <br> <br> VADER <br> No. I am your father. <br> <br> Shocked, Luke looks at Vader in utter disbelief. <br> <br> LUKE <br> No. No. That's not true! <br> That's impossible! <br></code> <br><br>  Each scene begins with a scene designation and INT notes.  (inside) or EXT.  (outside).  There may also be an explanatory text.  In the dialogs, the names of the characters are indicated in capital letters and bold. <br><br>  Therefore, the separators of scenes can be notes INT.  and EXT., written by bold. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// split the script by scene // each scene starts with either INT. or EXT. let rec splitByScene (script : string[]) scenes = let scenePattern = "&lt;b&gt;[ 0-9]*(INT.|EXT.)" let idx = script |&gt; Seq.tryFindIndex (fun line -&gt; Regex.Match(line, scenePattern).Success) match idx with | Some i -&gt; let remainingScenes = script.[i+1 ..] let currentScene = script.[0..i-1] splitByScene remainingScenes (currentScene :: scenes) | None -&gt; script :: scenes</span></span></code> </pre><br><br>  A recursive function that accepts the entire script and searches for patterns - EXT.  or int.  Bolds, before which the scene number can go.  It breaks the lines into the current scene and the rest of the text, and then recursively repeats the procedure. <br><br><h5>  Get a list of characters </h5><br>  In some scenes, the names of the characters are in the format that I described earlier.  Some use only colon names.  And all this can be present on one line.  The only common feature was the presence of names written in capital letters. <br><br>  I had to use regulars. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Extract names of characters that speak in scenes. // A) Extract names of characters in the format "[name]:" let getFormat1Names text = let matches = Regex.Matches(text, "[/A-Z0-9 -]+ *:") let names = seq { for m in matches -&gt; m.Value } |&gt; Seq.map (fun name -&gt; name.Trim([|' '; ':'|])) |&gt; Array.ofSeq names // B) Extract names of characters in the format "&lt;b&gt; [name] &lt;/b&gt;" let getFormat2Names text = let m = Regex.Match(text, "&lt;b&gt;[ ]*[/A-Z0-9 -]+[ ]*&lt;/b&gt;") if m.Success then let name = m.Value.Replace("&lt;b&gt;","").Replace("&lt;/b&gt;","").Trim() [| name |] else [||]</span></span></code> </pre><br><br>  Each regular season is looking for not only capital, but also numbers, dashes, spaces and slashes.  Since the names of the characters are different: "R2-D2" or even "FODE / BEED". <br><br>  I also had to take into account that some characters have several names.  Palpatine - Darth Sidious - Emperor, Amidala - Padme.  I made the <a href="">aliases.csv</a> alias <a href="">file</a> , where I <a href="">specified the</a> names to be merged. <br><br><pre> <code class="java hljs">let aliasFile = __SOURCE_DIRECTORY__ + <span class="hljs-string"><span class="hljs-string">"/data/aliases.csv"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use csv type provider to access the csv file with aliases type Aliases = CsvProvider&lt;aliasFile&gt; /// Dictionary for translating character names between aliases let aliasDict = Aliases.Load(aliasFile).Rows |&gt; Seq.map (fun row -&gt; row.Alias, row.Name) |&gt; dict /// Map character names onto unique set of names let mapName name = if aliasDict.ContainsKey(name) then aliasDict.[name] else name /// Extract character names from the given scene let getCharacterNames (scene: string []) = let names1 = scene |&gt; Seq.collect getFormat1Names let names2 = scene |&gt; Seq.collect getFormat2Names Seq.append names1 names2 |&gt; Seq.map mapName |&gt; Seq.distinct</span></span></code> </pre><br><br>  And now, finally, you can extract the names of the characters from the scenes.  The following function retrieves all character names from all scripts for which URLs are specified. <br><br><pre> <code class="java hljs">let allNames = scriptUrls |&gt; List.map (fun (episode, url) -&gt; let script = getScript url let scriptParts = script.Elements() let mainScript = scriptParts |&gt; Seq.map (fun element -&gt; element.ToString()) |&gt; Seq.toArray <span class="hljs-comment"><span class="hljs-comment">// Now every element of the list is a single scene let scenes = splitByScene mainScript [] // Extract names appearing in each scene scenes |&gt; List.map getCharacterNames |&gt; Array.concat ) |&gt; Array.concat |&gt; Seq.countBy id |&gt; Seq.filter (snd &gt;&gt; (&lt;) 1) // filter out characters that speak in only one scene</span></span></code> </pre><br><br>  There is one more problem - some character names were not names.  These were names like ‚ÄúPilot‚Äù, ‚ÄúOfficer‚Äù or ‚ÄúCaptain‚Äù.  I had to manually filter the names that were real.  This is how the characters.csv list appeared. <br><br><h5>  Character interaction </h5><br>  To build networks, I needed to identify all the cases where the characters spoke to each other.  They talk in the same scene (cases when people talk to each other on the intercom or walkie-talkie, and therefore, are in different scenes, I dropped). <br><br><pre> <code class="java hljs">let characters = File.ReadAllLines(__SOURCE_DIRECTORY__ + <span class="hljs-string"><span class="hljs-string">"/data/characters.csv"</span></span>) |&gt; Array.append (Seq.append aliasDict.Keys aliasDict.Values |&gt; Array.ofSeq) |&gt; set</code> </pre><br><br>  Here I created a set of all character names and their aliases for searching and filtering.  Then I used it to search for characters in each of the scenes. <br><br><pre> <code class="java hljs">let scenes = splitByScene mainScript [] |&gt; List.rev let namesInScenes = scenes |&gt; List.map getCharacterNames |&gt; List.map (fun names -&gt; names |&gt; Array.filter (fun n -&gt; characters.Contains n))</code> </pre><br><br>  Then I used a filtered list of characters to determine the social network. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Create weighted network let nodes = namesInScenes |&gt; Seq.collect id |&gt; Seq.countBy id // optional threshold on minimum number of mentions |&gt; Seq.filter (fun (name, count) -&gt; count &gt;= countThreshold) let nodeLookup = nodes |&gt; Seq.map fst |&gt; set let links = namesInScenes |&gt; List.collect (fun names -&gt; [ for i in 0..names.Length - 1 do for j in i+1..names.Length - 1 do let n1 = names.[i] let n2 = names.[j] if nodeLookup.Contains(n1) &amp;&amp; nodeLookup.Contains(n2) then // order nodes alphabetically yield min n1 n2, max n1 n2 ]) |&gt; Seq.countBy id</span></span></code> </pre><br><br>  This is how the list of nodes came out, with the number of conversations throughout the script ‚Äî this calculation is used to determine the size of the node.  Then I created a line between two characters that speak in the same scene, and calculated their number.  Together, nodes and lines define the entire social network. <br><br>  Finally, I output this data in JSON format.  All social networks, global and individual by episode, can be found on my github.  The complete code for this step is in the getInteractions.fsx file. <br><br><h5>  Mentions characters </h5><br>  I also decided to find references to all the characters to build a timeline.  The code turned out to be similar to the one that extracts the dialogues of the characters, only here I was looking for all the mentions, not only in the dialogues.  I also counted the scene numbers.  The following code returns a list of scene numbers and characters mentioned in them. <br><br><pre> <code class="java hljs">let scenes = splitByScene mainScript [] |&gt; List.rev let totalScenes = scenes.Length scenes |&gt; List.mapi (fun sceneIdx scene -&gt; <span class="hljs-comment"><span class="hljs-comment">// some names contain typos with lower-case characters let lscene = scene |&gt; Array.map (fun s -&gt; s.ToLower()) characters |&gt; Array.map (fun name -&gt; lscene |&gt; Array.map (fun contents -&gt; if containsName contents name then Some name else None ) |&gt; Array.choose id) |&gt; Array.concat |&gt; Array.map (fun name -&gt; mapName (name.ToUpper())) |&gt; Seq.distinct |&gt; Seq.map (fun name -&gt; sceneIdx, name) |&gt; List.ofSeq) |&gt; List.collect id, totalScenes</span></span></code> </pre><br><br>  To extract the timelines, I used scene numbering to assign an interval to each episode in the form [episode index-1, episode index].  This gave me a relative scale of the appearance of characters in the episodes.  Times in cells of intervals [0,1] refer to Episode I, in cells [1,2] to episode II, etc. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// extract timelines [0 .. 5] |&gt; List.map (fun episodeIdx -&gt; getSceneAppearances episodeIdx) |&gt; List.mapi (fun episodeIdx (sceneAppearances, total) -&gt; sceneAppearances |&gt; List.map (fun (scene, name) -&gt; float episodeIdx + float scene / float total, name))</span></span></code> </pre><br><br>  <a href="">I saved it in csv</a> , where each line contains the name of the character and the exact times in which he appeared in movies, separated by commas.  The full code is available in the getMentions.fsx file. <br><br><h5>  Add characters without words </h5><br>  Looking through the statistics of character conversations, I saw that R2-D2 and Chewbacca were missing from it.  Wookie not only did not get a medal, but disappeared from all the dialogues.  Of course, they are mentioned in the script, but only as characters without dialogues. <br><br>  Of course, it was impossible to ignore them, and I decided to insert them into the social network on the basis of dialogues. <br><br>  I extracted the sizes of nodes and the connection between two missing characters from the network, determined by their references.  To turn this into a connection within the social network, I decided to scale all the data obtained in proportion to other similar characters that participate in the script.  I chose C-3PO because he is a R2-D2 intermediary, and Han is an intermediary of Ch√ºy, assuming that their interactions will be similar.  I applied the following formula to calculate the strength of connections in the interactive social network: <br><br><img src="http://i.imgur.com/YL6VxSv.jpg?1" alt="image"><br><br><h4>  Visualization </h4><br>  After the manual return of Chewbacca and R2-D2, I had a complete set of social networks for both individual films and the entire franchise.  I used Force to visualize social networks ... Well, in fact, <a href="http://bl.ocks.org/mbostock/4062045">force-directed network layout</a> from the D3.js library.  This method uses physical simulation of charged particles.  The most important in the code is the following: <br><br><pre> <code class="javascript hljs">d3.json(<span class="hljs-string"><span class="hljs-string">"starwars-episode-1-interactions-allCharacters.json"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, graph</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* More code here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> link = svg.selectAll(<span class="hljs-string"><span class="hljs-string">".link"</span></span>) .data(graph.links) .enter().append(<span class="hljs-string"><span class="hljs-string">"line"</span></span>) .attr(<span class="hljs-string"><span class="hljs-string">"class"</span></span>, <span class="hljs-string"><span class="hljs-string">"link"</span></span>) .style(<span class="hljs-string"><span class="hljs-string">"stroke-width"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(d.value); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = svg.selectAll(<span class="hljs-string"><span class="hljs-string">".node"</span></span>) .data(graph.nodes) .enter().append(<span class="hljs-string"><span class="hljs-string">"circle"</span></span>) .attr(<span class="hljs-string"><span class="hljs-string">"class"</span></span>, <span class="hljs-string"><span class="hljs-string">"node"</span></span>) .attr(<span class="hljs-string"><span class="hljs-string">"r"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .style(<span class="hljs-string"><span class="hljs-string">"fill"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.colour; }) .attr(<span class="hljs-string"><span class="hljs-string">"r"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(d.value) + <span class="hljs-number"><span class="hljs-number">2</span></span>; }) .call(force.drag); <span class="hljs-comment"><span class="hljs-comment">/* More code here */</span></span> });</code> </pre><br><br>  In the previous steps, I saved all the networks in JSON.  Here I load them and define nodes and links.  For each node, a different color is added, and a value denoting importance (number of character phrases).  This parameter defines the radius r, as a result, all nodes are scaled in importance.  Also for links - the thickness of each link was stored in JSON, and here it is displayed through the width of the line. <br><br><h4>  Central analysis </h4><br>  And at the end I analyzed the centrality of each character.  For this, I used <a href="http://bluemountaincapital.github.io/FSharpRProvider/">RProvider</a> along with the <a href="http://igraph.org/r/">R igraph package</a> to analyze networks in F #.  First, I loaded the network from JSON via FSharp.Data: <br><br><pre> <code class="java hljs">open RProvider.igraph let [&lt;Literal&gt;] linkFile = __SOURCE_DIRECTORY__ + <span class="hljs-string"><span class="hljs-string">"/networks/starwars-episode-1-interactions.json"</span></span> type Network = JsonProvider&lt;linkFile&gt; let file = __SOURCE_DIRECTORY__ + <span class="hljs-string"><span class="hljs-string">"/networks/starwars-full-interactions-allCharacters.json"</span></span> let nodes = Network.Load(file).Nodes |&gt; Seq.map (fun node -&gt; node.Name) let links = Network.Load(file).Links</code> </pre><br><br>  The variable links contains all the links in the network, and the nodes are characterized by their indices.  To simplify the work, I assigned the character names to the indexes: <br><br><pre> <code class="java hljs">let nodeLookup = nodes |&gt; Seq.mapi (fun i name -&gt; i, name) |&gt; dict let edges = links |&gt; Array.collect (fun link -&gt; let n1 = nodeLookup.[link.Source] let n2 = nodeLookup.[link.Target] [| n1 ; n2 |] )</code> </pre><br><br>  Then I created a graph object using the igraph library: <br><br><pre> <code class="java hljs">let graph = namedParams[<span class="hljs-string"><span class="hljs-string">"edges"</span></span>, box edges; <span class="hljs-string"><span class="hljs-string">"dir"</span></span>, box <span class="hljs-string"><span class="hljs-string">"undirected"</span></span>] |&gt; R.graph</code> </pre><br><br>  Counting Intermediateness and Centralness: <br><br><pre> <code class="java hljs">let centrality = R.betweenness(graph) let degreeCentrality = R.degree(graph)</code> </pre><br><br>  The complete code <a href="">can be found here</a> . <br><br><h4>  Results </h4><br>  As is always the case with scientific research, the most difficult thing is to bring the data into a readable form.  Since the SW scripts had a slightly different format, I spent most of the time defining the general properties of the documents to create one function to process them.  After that, it was necessary to tinker only with the problems of the Wookiees and the droid, who did not have any replicas.  <a href="https://github.com/evelinag/StarWars-social-network/tree/master/networks">Networks in JSON format can be downloaded on github</a> . <br><br><h4>  Links </h4><br>  Sources <a href="https://github.com/evelinag/StarWars-social-network">github.com/evelinag/StarWars-social-network</a> <br>  Social networks in JSON format: <a href="https://github.com/evelinag/StarWars-social-network/tree/master/networks">github.com/evelinag/StarWars-social-network/tree/master/networks</a> <br>  Scripts: <a href="http://www.imsdb.com/">www.imsdb.com</a> </div><p>Source: <a href="https://habr.com/ru/post/273319/">https://habr.com/ru/post/273319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273301/index.html">War, peace and ABBYY Compreno: the continuation of our affair with Tolstoy</a></li>
<li><a href="../273305/index.html">Evolution of data structures in Yandex. Metric</a></li>
<li><a href="../273307/index.html">Digital Data Layer - the heart of your tag-management system</a></li>
<li><a href="../273311/index.html">NW + Edge.js + Fiddler or a tale about the dockability of the untangible</a></li>
<li><a href="../273313/index.html">Predreliznoe testing has unexpectedly epic proportions</a></li>
<li><a href="../273323/index.html">Vivaldi Beta 2 browser release</a></li>
<li><a href="../273325/index.html">Santa Claus asks a question. Contest for Intel Blog Readers</a></li>
<li><a href="../273327/index.html">"War and Peace" - the test of time</a></li>
<li><a href="../273329/index.html">5 brightest scams with WhatsApp in 2015</a></li>
<li><a href="../273331/index.html">Comparative analysis of C # and C ++ languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>