<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The architecture of the online game server on the example of Skyforge</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I'm Andrei Frolov, lead programmer, working in Mail.Ru on Next-Gen MMORPG Skyforge. You could read my article about database architecture in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The architecture of the online game server on the example of Skyforge</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I'm Andrei Frolov, lead programmer, working in Mail.Ru on Next-Gen MMORPG Skyforge.  You could read my article about database architecture in online games.  Today I will reveal the secrets concerning the device of the Skyforge server.  I will try to tell you in as much detail as possible, with examples, and also explain why this or that architectural decision was made.  Without exaggeration, we can write a whole book on our server, so in order to fit into an article, I will have to go through only the main points. <br><br> <a href="http://habrahabr.ru/company/mailru/blog/220359/"><img src="https://habrastorage.org/getpro/habr/post_images/868/a84/75a/868a8475a37a53f800246308d7c88657.jpg" alt="image"></a> <br><br><a name="habracut"></a><br><h4>  Overview </h4><br><ul><li>  A server is nearly two million lines of Java code.  To connect to the server and display a beautiful picture, use a client written in C ++. </li><li>  Fifty programmers contributed to the server code.  The code has been written for many years by the best specialists of the Russian "Orthodox" game dev.  It contains all the most successful ideas from around the world. </li><li>  At the moment, we have written about 5,200 automated tests, continuous integration and load testing using bots have been established. </li><li>  The server can run and work on tens and hundreds of servers, support the game of hundreds of thousands of people at the same time.  We decided to abandon the traditional MMO shardirovaniya technique and run all the players into one big world. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first and most important rule of server development: the client is in the hands of the enemy.  The client is protected, but theoretically it can be hacked, it can decipher the client-server protocol.  Hacking a client can lead to bypassing game rules, cheating, boating, etc.  Such things destroy the game for everyone.  To avoid this, we must emulate the entire game world with all the game rules on our server, and the client should be used only to display a beautiful picture.  In addition, the client should be checked for hacking, tracking suspicious behavior, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a99/0ed/3a8a990ed380402a0462f727159cbaa9.png"></div><br><br><h4>  Service Architecture </h4><br>  One of the main features of the development is that we do not know how many players we will have.  Maybe only one - the developer himself, or maybe 100,000 at a time.  Therefore, the server should be able to run in a small configuration, on a laptop, and stretch to tens and hundreds of powerful servers, if necessary. <br><br>  The second feature is that at the start of development we had no idea what our game would be about, what features, services, etc. would be in it.  The server structure should be as flexible as possible in terms of adding new services and features. <br><br>  The third big problem is multithreading.  As you know, the best way to cope with multithreading is to avoid it.  Deadlock, livelock, lock contention, and other issues that are dear to the programmer‚Äôs heart can be circumvented if the server architecture saves you from having to synchronize the threads manually.  Ideally, a programmer should generally write simple single-threaded code and not think about such things. <br><br>  From here, our universal server structure was born, which is used in Skyforge: <br><ul><li>  There is a pool of physical servers on which the game will run.  This set of servers and our server application that runs on them is called Realm. </li><li>  Each server runs a server application (JVM), called a role.  There are different roles: account server, game mechanics, chat, etc.  Each role assumes a large piece of functionality.  Some roles exist in the singular, some run in multiple instances. </li><li>  The role consists of a set of services.  A service is a regular thread (thread), which deals with its specific task.  An example of a service might be an authorization service, a name reservation service, a load balancer, etc.  Each service knows nothing about the physical location of other services.  They may be nearby, or they may be on a different physical machine.  Services interact through a messaging system that hides such details from them. </li><li>  Each service consists of a set of modules.  A module is a ‚Äúpiece of functionality‚Äù that has one tick () method.  An example of a module may be a statistics module, a transaction execution module, a time synchronization module.  The whole work of the service is to call the tick () method on its modules in an infinite loop.  One such cycle is called a ‚Äúserver frame‚Äù.  We consider the rate to be good if the server frame varies from 3 to 20 ms. </li><li>  This whole structure is described in XML files.  The startup system just needs to ‚Äúfeed‚Äù the role name.  It will find the appropriate file, launch all the necessary services and give them the list of modules.  The modules themselves will be created using java reflection. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ed/a08/e63/2eda08e63951f2637a3c610467031d0f.png"></div><br><br>  Thus, we can launch the ‚Äúlocal server‚Äù role, where everything is needed, and we can split the server into several dozen roles ‚Äî account server, item server, game mechanics, etc.  - and run it on dozens of different physical servers.  The structure was extremely flexible and convenient, I advise you to seriously look at it. <br><br><h4>  Basic services </h4><br>  There is a set of services that carries the main game load.  Each server must be able to scale.  Ideally - to infinity.  Unfortunately, writing servers so that they scale up is not an easy task.  Therefore, we began with the fact that we made the main services scalable, and every additional trifle that does not carry the main load was left for later.  If we have a lot of users, then we will have to improve them to ensure scalability. <br><ul><li>  Account service.  Responsible for authorizing and connecting new customers. </li><li>  Server game mechanics.  This is actually the game itself.  After passing the authorization, the client connects here and plays here.  The client does not directly interact with other services.  There are several dozen or even hundreds of such services.  These services bear the main load. </li><li>  Database services.  These services perform operations on the data of game characters, their objects, money, progress of development.  They usually run a few pieces.  More information about the architecture of the database can be found in my last report.  ( <a href="http://habrahabr.ru/company/mailru/blog/182088/">habrahabr.ru/company/mailru/blog/182088</a> ) </li><li>  Chat.  Routing chat messages between users. </li><li>  All other services.  There are several dozen of them, and they usually do not create a strong load, so they do not require separate servers. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92e/f6b/4c3/92ef6b4c3cf90c771d6ebe21ffd31515.png"></div><br><br><h4>  Network </h4><br>  By the word ‚Äúnetwork‚Äù I mean the message delivery system from one service to another or from one object to another.  Historically, we have two such systems at once.  One is based on posts.  The second system is based on remote procedure call (RPC).  In Skyforge, the message system is used inside the game mechanics service to send a message from the avatar to the mob, as well as for communication between the client and the server.  RPC is used for communication between services. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94a/f35/19d/94af3519d75ee08a84fbfea7b0ffbd35.png"></div><br><br><h5>  Messages </h5><br>  All objects that want to send or receive messages are called subscribers.  Each subscriber is registered in the general directory and receives a unique identifier - the address.  Anyone who wants to send a message to a subscriber must specify the addresses ‚Äúfrom‚Äù and ‚Äúwhere‚Äù.  The network engine knows where the subscriber is located, and delivers the message to him.  A message is a Java object that has a run () method.  When sent, this object is serialized, arrives at the target subscriber, is deserialized there, and then the run () method is called on the target subscriber. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f6/cca/163/2f6cca16324edd4886711e6e37f231e5.png"></div><br><br>  This approach is very convenient in that it allows you to implement simple commands like ‚Äústrike‚Äù, ‚Äúgive unlock‚Äù, ‚Äústart fireball‚Äù.  All this logic is external to the object on which the action is performed.  The big disadvantage of this approach is that if the command logic requires the execution of some code on several subscribers, then we need to make several messages that will send each other along the chain.  The logic is fragmented into several classes, and the message chain is often quite long and difficult to unravel. <br><br><h5>  RPC </h5><br>  Remote procedure call or RPC appeared to solve the message thread problem. <br>  The basic idea is to use cooperative multitasking (Coroutine, Fibers).  Anyone who is not familiar with this concept, I advise you to look into Wikipedia for understanding the topic.  <a href="http://en.wikipedia.org/wiki/Coroutine">en.wikipedia.org/wiki/Coroutine</a> . <br>  A service that wants to be called through a remote procedure call must implement a special interface and register in a special directory.  Then anyone can ask the directory to give him the interface of this service, and the directory will return a special wrapper on the service.  Calling services via RPC is possible only inside a coroutin, i.e.  A special execution context that can be interrupted and resumed at break points.  When calling wrapper methods, it will send RPC calls to a remote service, interrupt the current filer while waiting for a response, and return the result when the remote server answers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/fd0/92e/857fd092e8d5eb471b9e988c5af03238.png"></div><br><br>  Thus, we concentrate logic in one method, rather than spreading it over hundreds of messages.  The code is greatly simplified, it can be written in terms of calling functions of some objects, and not in terms of sending messages.  But there are problems with some kind of multithreading, since  after we returned from a remote call, the environment could already have changed.  In general, this approach is very convenient when the service has a limited interface of a dozen methods.  When there is a lot of methods, it is better to split the interface into several. <br><br>  You can learn more about our implementation of the firewalls from the lecture by Sergey Zagursky ( <a href="http://www.youtube.com/watch%3Fv%3DYWLHELcvNbE">www.youtube.com/watch?v=YWLHELcvNbE</a> ). <br><br><h5>  Serialization </h5><br>  In order for us to have a system for sending messages and remote procedure calls, we need a client-server protocol and a way to serialize / de-serialize objects.  Let me remind you that we need to send commands and data from the client to the server, i.e.  from C ++ to Java and back.  To do this, we use Java classes to generate copies of them in C ++, and also generate methods for serializing and deserializing objects into a byte stream.  The serialization code is embedded directly inside the classes and accesses the fields of the class directly.  Thus, the server does not spend processor time to crawl classes using reflection.  We generate all this with a self-written plug-in for IntelliJ IDEA.  Intraserver protocol for communication between services is completely analogous to the client-server protocol. <br><br>  When serializing any class into a byte stream, first the class id is written, then the field data of this class.  On the other side, the id is read, the corresponding class is selected, and a special constructor is called from it, which restores the class from the byte stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/e54/bcc/c21e54bccba7fd73f66deb7f53a02923.png"></div><br><br><h4>  Game mechanics </h4><br>  The main service that would be of interest to you is the game mechanics service.  It is there that the entire code that is directly related to the game is executed, it is there that the entire game world is modeled, the fireballs fly and ‚Äúrobbed are corowed‚Äù. <br><br><h5>  Maps and load balancing </h5><br>  On the game mechanics servers, maps are created on which, in fact, there are players, mobs and all the fun happens.  Each card has a limit on the number of players that can be on it.  For example, the limit may be equal to one for personal adventures, 10‚Äì30 for group activities and 250 for large cards.  What happens if another player wants to hit the card when the limit is reached?  Then another copy of the same card will be created.  Players from these cards will not see each other, will not interfere with each other.  Those.  in any gaming city there may be thousands of people, but there will not be crowded.  This way of organizing players is called ‚Äúchannels‚Äù. <br><br>  The creation of cards is the responsibility of the central card balancer service, which distributes the cards among the game mechanics services depending on the population, load and other magical causes, trying to maintain a uniform distribution of the load and the normal density of the players so that they do not get bored. <br><br>  On each server of the game mechanics, information about the passability map, collisions and other similar things is loaded.  When a player or mob tries to move to any point, the server calculates whether the player can get there, whether he is trying to count and go through the wall.  When a player tries to throw a fireball at an enemy, then using the same information, the server calculates whether the player sees the enemy and if there are no obstacles in his path. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b2/0e1/28b/8b20e128b08394200de00d08b3dee114.png"></div><br><br><h5>  Avatars and Mobs </h5><br>  An avatar is a character controlled by a player, a mob is a monster that a player kills.  These are very different, but often very similar entities.  Both mob and avatar can walk on the map, they have health, they can use spells, etc.  Only the avatar is controlled by the player, and the mob has its own brain.  In addition, the maps have a lot of chests, plants and other interactive entities.  Very often you need to do some kind of functionality and hook it to different entities.  For these purposes, we use the component approach, collecting game essence from a set of functionalities.  Let me explain by example.  Suppose a player and mob have a health indicator.  In this case, we design the ‚Äúhealth‚Äù element as a separate Java class in which we describe how health behaves: how it can decrease, how to recover, what timers are, and so on.  Then we simply add all the functionality to a special HashMap inside the entity and take it from there as necessary.  We have hundreds of such components, half of the game mechanics are collected on them. <br><br>  Since the server application is very complex, the occurrence of errors is inevitable.  You need to make sure that the occurrence of an error, even an unprocessed NullPointerException, does not cause the server to crash.  You can simply log the error and go further, but if the error occurs in the middle of some long action on the avatar, then the avatar may be in a broken and inconsistent state.  Here we come to the aid of a concept called "locale".  A locale is a context within which objects can refer to each other.  Objects from one locale cannot refer to objects from another.  If an unhandled exception is thrown from the locale, then the locale is deleted entirely.  Avatars, mobs and other entities are locales, are deleted entirely and cannot keep links to other avatars and mobs.  Therefore, all the interaction between avatars and mobs goes through the message system, although they are together on the same machine and in theory could keep a direct link to each other. <br><br><h5>  Replication </h5><br>  You need to simulate the game world not only on the server, but also partially on the client.  For example, the client needs to see other players and mobs that are next to him.  For this, client-server replication mechanism is used, when updates from the surrounding gaming world are sent from the server to clients.  This is done with the help of a code generator that embeds sending updates into the setters of server Java objects.  A circle of a certain radius is created around the player, and if someone, for example, another avatar, falls into this circle, he begins to replicate to the client.  There is a fundamental problem with replication.  If N avatars are crowded in one place, then N replicas will have to be sent to each of them.  Thus, a quadratic dependence arises, which limits the number of avatars that can be collected in one place.  It is because of this fundamental quadraticity that all MMO customers are slowed down in capitals.  We avoid this problem by limiting the number of players on the map and distributing them across channels. <br><br><h5>  Resource system </h5><br>  In the game there are hundreds and thousands of spells, items, quests and other similar entities.  As you can probably guess, programmers do not write all hundreds of quests, game designers do it.  A programmer develops one Java quest class, and descriptions of all quests with their logic, tasks, and texts are contained in XML files called resources.  When the server starts, we load these resources and, based on them, collect Java classes describing the world.  These classes can already be used by the server.  Approximately the same system exists on the client side, only there resources are not loaded from XML files, but the pre-created ‚Äúpiece of memory‚Äù is simply loaded, containing all the necessary objects and links between them.  There are hundreds of thousands of resource files in our server, but downloading them on the server takes about two minutes.  On the client, everything is loaded in seconds.  The system is very sophisticated, supports features such as prototypes and inheritance, nested descriptors, etc.  Above the resource system, we have created specialized programs for editing maps and other game entities. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1f/164/75d/f1f16475dd08f13f32521bf42c601d8c.png"></div><br><br><h4>  Server in action </h4><br>  Let's now take a look at examples of several scenarios of how the whole system works in action. <br><br><h5>  Kill dog </h5><br>  The classic test, which we always carry out, if we have greatly changed the infrastructure and want to check that everything is working, is called "Kill the Dog."  You need to go to the server to the client and kill some mob there.  This test covers almost all the main points of the server and serves as an excellent example to put all of the above together.  Let's take a look at the points, what and how is happening when killing an unhappy dog.  Of course, some steps are simplified, but this is not critical for understanding. <br><ul><li>  The client sends a message to the account server: "I want to enter the game." </li><li>  The account server requests the database, performs authorization and requests from the balancer the card on which the player was last. </li><li>  The balancer selects a card from the already loaded ones or creates a new one on the least loaded game mechanics server. </li><li>  The client connects to the mechanics where the map was created for him.  While he connects, his avatar is loaded for him. </li><li>  The server begins to replicate all the objects around the avatar to the client.  The client draws a smart picture and sends commands to the server that the player sends. </li><li>  The player begins to run around the map, and the server moves him around the world and replicates changes in the surrounding reality.  The player finds a mob and presses the "hit" button. </li><li>  The ‚Äúhit‚Äù command arrives at the server, the server checks that the strike is possible, and a message is sent to the mob about damage. </li><li>  The ‚Äúdamage‚Äù command is worked out on the mob, calculates all the resists and other similar things, then takes the ‚Äúhealth‚Äù functionality and writes off a certain amount. </li><li>  The client is sent a response with confirmation of the damage, the client draws a blow. </li></ul><br><br><h5>  Scaling </h5><br>  Let's go on the other side and see how the server behaves under load. <br><ul><li>  0 customers.  If there is no one on the server, it can be launched in one application with minimal settings and without maps.  There is no activity on the server, and most of the time it is idle. </li><li>  1 client  For one client, you have to create a map, mobs, server objects that begin to consume memory and processor time for their life. </li><li>  500 customers.  500 clients are usually already quite a lot so that the processor time of one person is not enough for the server to work.  You have to run realm on several machines or on more powerful servers. </li><li>  10,000 customers.  10,000 clients already require multiple servers.  Since most of the load is on game mechanics, you need to run realm with additional services of game mechanics. </li><li>  100,000 customers.  With 100,000 simultaneous players, more than half of the servers are busy with game mechanics. </li><li>  More customers than iron.  If suddenly there will be more players, and the iron will suddenly come to an end, we will have to restrict people from entering the game until new servers are brought up.  To do this, there is a queue at the entrance, which makes the players wait for the server to be ready to accept them.  This queue ensures that at the same time one realm cannot contain more players than we are ready to accept.  In turn, players may start to bet even if, due to a bug or for some reason, the server suddenly began to work more slowly than a certain threshold.  It is better to make an acceptable service for a limited number of customers than to fall for everyone. </li></ul><br><br><h4>  Conclusion </h4><br>  I hope our experience will help you understand how modern game servers work, and create your own, if it comes to that. <br>  To better understand other aspects of game development, I would recommend you read the articles of my colleagues. <br><ul><li>  Non-preemptive multitasking in Java <a href="http://www.youtube.com/watch%3Fv%3DYWLHELcvNbE">www.youtube.com/watch?v=YWLHELcvNbE</a> </li><li>  Load testing at Skyforge, or Bots - orderlies at <a href="http://habrahabr.ru/company/mailru/blog/193452/">habrahabr.ru/company/mailru/blog/193452</a> server <a href="http://habrahabr.ru/company/mailru/blog/191378/">habrahabr.ru/company/mailru/blog/191378</a> </li><li>  Databases in online games.  From Allods Online to Skyforge <a href="http://habrahabr.ru/company/mailru/blog/182088/">habrahabr.ru/company/mailru/blog/182088</a> </li><li>  Other articles <a href="http://allodsteam.ru/">allodsteam.ru/#posts</a> </li></ul><br><br>  <b>And of course, recording on a closed beta test.</b>  <a href="http://sf.mail.ru/">sf.mail.ru</a> <br><br><h4>  Fun statistics </h4><br>  Statistics by lines of code.  Only server is included in statistics. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/5f5/407/7f05f540734e20d2349292a189ff1247.png"></div><br><br>  Authors collected from code comments. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/017/cd9/051017cd9e118af4bf04ac15b2d2f7b5.png"></div><br><br>  PS: As usual, we answer all questions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/220359/">https://habr.com/ru/post/220359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220343/index.html">Duplex asynchronous data exchange for the web, mobile and desktop in one implementation</a></li>
<li><a href="../220351/index.html">Blogs are small media.</a></li>
<li><a href="../220353/index.html">iOS / PSW.SSLCredsThief.A for iOS c jailbreak</a></li>
<li><a href="../220355/index.html">A new biotechnology department has been created at DARPA</a></li>
<li><a href="../220357/index.html">Docsvision start - and continue</a></li>
<li><a href="../220363/index.html">Wolf hunters from Wall Street. Part 2</a></li>
<li><a href="../220365/index.html">FORTH: Self-Defined Words</a></li>
<li><a href="../220367/index.html">LibreSSL: a clean version of OpenSSL (the OpenBSD project)</a></li>
<li><a href="../220369/index.html">Indexing handwriting in images: from European languages ‚Äã‚Äãto Asian</a></li>
<li><a href="../220371/index.html">History of torrent rendering for 3ds max</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>