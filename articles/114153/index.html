<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quantile Image Segmentation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Segmentation is the assignment of tags to image pixels so that areas with similar properties in a certain sense have the same labels. Also, segmentati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quantile Image Segmentation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/941006a0/baad5c95/3860ed93/1be5312c.png" alt="image" align="left">  Segmentation is the assignment of tags to image pixels so that areas with similar properties in a certain sense have the same labels.  Also, segmentation is sometimes called the search for the projection of an object in an image.  This topic will tell you about a simple but effective method of searching for the projection of an object, called the quantile method.  The area of ‚Äã‚Äãapplicability of the method is indicated and some modifications that increase the efficiency are given. <a name="habracut"></a><br><br><h4>  Some concepts and assumptions </h4><br>  In order to be able to find an object in an image, we must assume that the object has some distinctive features represented in the image.  As such a feature, we will use the brightness.  We call an object a <b>bright spot</b> if the average brightness of the pixels belonging to the projection of the object is higher than the average brightness of the pixels of the surrounding background.  (Dark spots are determined in a similar way.) Such objects are found, for example, in infrared aerial photographs of a terrain: a heated technique looks brighter than the surrounding earth.  In general, the practice (mainly in the military) shows that in many cases it is possible to select such a range of wavelengths for shooting, so that the condition of the difference in average brightness is fulfilled. <br><br>  Segmentation of the entire image is a difficult task at once, so it is often broken down into subtasks: first, small fragments are found in the image that presumably contain the object of interest, and then they are segmented.  A small (usually, without loss of generality, square) image fragment containing only the object itself and some of its surroundings (background) is called the <b>zone of interest</b> .  In our case, we will work with the zones of interest.  The first subtask (search for zones of interest) is solved by its own methods and is not discussed in this topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is also assumed that we know the geometric features of the object, namely, the <b>area of ‚Äã‚Äãthe projection of the</b> object in the image.  This assumption is fulfilled when we know in advance <i>what</i> we are looking for in the image, but we do not know <i>where the</i> object is located.  It is also assumed that the projection of the object is a <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B0_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">connected set</a> . <br><br><h4>  Initial data and problem statement </h4><br>  So, we have an image of the zone of interest, on which the object is located, which is a bright spot.  In reality, images are not perfect, many random factors impede the segmentation task.  Therefore, the original image is distorted by Gaussian noise (in connection with the presence of noise, we talked about medium brightness, and not just brightness, in the definition of a bright spot).  We know the area S of the projection of the object in the image. <br><br>  It is necessary to mark the pixels belonging to the projection of the object. <br><br>  As an example, take this image: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/941006a0/baad5c95/3860ed93/1be5312c.png" alt="image"></div><br>  It has a size of 140x140 pixels.  It shows a square of 80x80 pixels, located in the center and rotated 15 degrees.  The average background brightness is 80, the average brightness of the object is 120. Gaussian noise has a standard deviation of 20. <br><br><h4>  Original Quantile Method </h4><br>  The quantile method was first described in [1].  The method in its original form assumes that the brightness of <i>any</i> pixel of the object in the image is higher than the brightness of <i>any</i> pixel of the background.  From this assumption follows a simple segmentation method.  Sort all the pixels of the image in descending order of brightness.  From our assumption it follows that the pixels belonging to the projection of the object will be located at the beginning of the ordered sequence.  Therefore, we can mark the first S pixels with the label ‚ÄúObject‚Äù - they will belong to the desired projection. <br><br>  Unfortunately, this assumption is not always fulfilled.  Our picture here is also no exception.  The result of the segmentation method described below.  Object pixels are marked in white, background pixels are black. <br><img src="https://habrastorage.org/storage/e2bd6ca3/da6dfdda/46f4a9f7/45a1bd08.png"><br><br>  It is worth discussing another small issue.  On real images, like ours, it is unlikely that it will be possible to pick up such a threshold brightness value, so <i>that the</i> greater threshold has exactly S pixels of the image.  Often at one threshold of brightness (t) we cut off A &lt;S pixels, and at threshold (t-1) - B&gt; S pixels.  ‚ÄúArrange‚Äù, as suggested above, the pixels of the same brightness, we can not, we must either take all the pixels of brightness (t), or not take.  The easiest way to decide is to see what is less: (SA) or (BS).  We look at which number - A or B - is closer to what needs to be obtained, and take the corresponding threshold.  This method was used to obtain images presented in the topic. <br><br><h4>  "Improved" quantile method </h4><br>  The assumption of the original method is often not carried out due to the influence of noise: although on average the brightness of an object pixel is higher than the brightness of the background pixel, but in some cases it can be the other way around.  (It is worth noting here that when the difference in average brightness is large and the noise dispersion is small, the first method can also work.) The ‚Äúimproved‚Äù quantile method uses precisely the assumption about the difference in <i>average</i> values ‚Äã‚Äãof object and background brightness. <br><br>  Mathematical statistics tells us that in our case of Gaussian noise, the estimate of the average brightness value at a point, made by calculating the average arithmetic brightness over a neighborhood, will be a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BE%25D1%2586%25D0%25B5%25D0%25BD%25D0%25BA%25D0%25B0">consistent</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D1%2581%25D0%25BC%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BE%25D1%2586%25D0%25B5%25D0%25BD%25D0%25BA%25D0%25B0">unbiased</a> estimate.  In other words, we do not know the true average brightness for each pixel of the image, but we can take some neighborhood of this pixel B (z, r), where z is the coordinates of the pixel, r is the radius of the neighborhood: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/906b0d2c/baa35d82/7f1a0ff8/ecf6d3cc.png" alt="Square neighborhood B (z, r)"></div><br>  and calculate the arithmetic average of the brightness for this neighborhood: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/3ae2f5c8/70661824/739a4729/2c53bc42.png" alt="The arithmetic average of the neighborhood"></div><br>  Here Q is the set of image pixels, x <sub>t</sub> is the brightness of the image at t.  We can quite legally use this estimate instead of the true average value, and the larger the radius of the neighborhood we take, the more accurate the estimate will be. <br><br>  In the ‚Äúimproved‚Äù quantile method, first of all, the arithmetic average is calculated using the above formula at each point.  Then the same procedure is performed as in the original method, but instead of the immediate brightness values, the mean values ‚Äã‚Äãare used.  <i>(Note: instead of smoothing the image by calculating the arithmetic average, in practice, Gaussian image smoothing is often used - this is a weighted average with coefficients of the corresponding distribution; such smoothing solves some problems of the arithmetic average.)</i> <br><br>  For our image we get the following result (segmentation with r = 1): <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/7fa39e3f/4de10d2f/eacedc7b/7c3b8042.png" alt="Improved quantile method, r = 1"></div><br>  The result has noticeably improved.  Increase the radius to calculate the arithmetic average to r = 2: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/89259015/981dc343/8c9ee6a3/ec012fb2.png" alt="Improved quantile method, r = 2"></div><br>  With a radius of 2 extraneous "specks" completely gone!  It can be noted, however, that with increasing radius, the boundary of the object is distorted.  This is due to the fact that the estimate of the true average of the arithmetic average is true only when the neighborhood B (z, r) lies either entirely on the object, or entirely on the background, that is, when random variables with the same estimated average fall into it by value.  On the border, pixels and background and object fall into the neighborhood, which naturally distorts the estimate. <br><br><h4>  Algorithm modification </h4><br>  As stated above, it is assumed that the projection of the object is a connected set.  In this regard, we can filter out the extra ‚Äúspots‚Äù that arise after segmentation as follows: we calculate the area of ‚Äã‚Äãeach connected component and leave the one of them, the area of ‚Äã‚Äãwhich is the largest. <br><br>  Below are the results obtained after the selection of the largest connected component on the images with the segmentation result by the original method and the ‚Äúimproved‚Äù method with r = 1 (with r = 2, only one connected component remains): <br><img src="https://habrastorage.org/storage/a875e9b5/6cf17aea/9eac93de/d54bf603.png"><img src="https://habrastorage.org/storage/718f709f/74945b49/80581b48/a0b11354.png"><br>  In both cases, this made it possible to filter out extra ‚Äúspots‚Äù and get a good result even for the original quantile method. <br><br><h4>  Conclusion </h4><br>  The quantile method was invented long ago, very simple to implement.  For all its simplicity, the method gives good results.  Although in the currently complex image processing tasks, such simple methods are not enough to get the desired result and more complex segmentation methods have been developed, simple methods do not lose their relevance.  They are used as an integral part of more complex algorithms, and are also very useful for implementing ‚Äúin hardware‚Äù, when simple, in terms of calculations, but reliable algorithms are required. <br><br><h4>  Sources </h4><br>  [1] Doyle W. Operations useful for invariant pattern recognition.  // Journal ACM.  1962. Vol.  9, No. 2. P. 259-267. </div><p>Source: <a href="https://habr.com/ru/post/114153/">https://habr.com/ru/post/114153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114146/index.html">Metawidget - a tool that generates Java forms</a></li>
<li><a href="../114147/index.html">The practice of using the Onboard Administrator in BladeSystem c3000</a></li>
<li><a href="../114150/index.html">Storing and encrypting Microsoft Windows passwords</a></li>
<li><a href="../114151/index.html">WordPress 3.1 Reinhardt Released</a></li>
<li><a href="../114152/index.html">Resurrecting a dream. A remake of your favorite iphone game</a></li>
<li><a href="../114154/index.html">B-tree</a></li>
<li><a href="../114156/index.html">280 crinkles or explosive power of regular expressions</a></li>
<li><a href="../114157/index.html">What is the speed of your internet access?</a></li>
<li><a href="../114158/index.html">Scala + Processing is a fun way to learn a new language.</a></li>
<li><a href="../114159/index.html">Introduction to eZ Publish on the example of creating a site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>