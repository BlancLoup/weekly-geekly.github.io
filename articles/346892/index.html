<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lua. Brief introduction to metatables for dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Writing this article led me to a large number of questions on metatables and OOP in Lua, since this is the most difficult and problematic section for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lua. Brief introduction to metatables for dummies</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pw/h-/ka/pwh-kakokqutguzo8rusfsaqezm.png"></div><br>  Writing this article led me to a large number of questions on metatables and OOP in Lua, since this is the most difficult and problematic section for students of this language, but since Lua was designed as a language for beginners and non-programmers and, in general, it has a small amount material for the development, it is unsuitable to leave it "for later", given that with the help of metatables you can work wonders and extremely elegant solutions of intricate tasks. <br><a name="habracut"></a><br>  This publication will describe all the standard meta-methods for versions Lua 5.1-5.3, with examples.  Let's start. <br><br><h3>  Metatables </h3><br>  What it is? <br><br>  In fact, the metatable is no different from a regular table, except that it is listed as a control table. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is possible to present schematically, for example, like this: <br><br><img src="https://habrastorage.org/webt/nd/eo/14/ndeo14kgyseidba6hp6xorhpkkw.png"><br><br>  The metatable describes the reaction of the main table to influences, for example, calling the table as a function, dividing the table into an arbitrary value, or trying to extract a key from it that it does not have, thanks to special keys (Lua 5.1, if not specified otherwise): <br><br><h4>  General metamethods </h4><br><ul><li>  __index - a function or a table by which the original table searches for keys if they do not exist; </li><li>  __newindex - the function, how to add to the table * new * keys, on existing ones - does not work; </li><li>  __call - the function that will be called when the table is tried to be called as a function; </li><li>  __tostring - the function that is called when trying to convert a table to a string, for example, when printing or tostring, is combined with __concat; </li><li>  __concat - a function that is invoked when an attempt is made to concatenate a table with something, is combined with __tostring; </li><li>  __metatable - the value that is returned when trying to take a metatable from a given table allows you to hide metatables; </li><li>  __mode - the string that controls the "power" of connections in the table during garbage collection, with its help you can create weak reference tables or <a href="https://habrahabr.ru/post/163679/">ephemerons</a> ; </li><li>  __gc - a function that will be called when collecting userdata (5.1+) or a table (5.2+) by a scavenger, if you really want to 5.1 - there is a way to use it; </li><li>  __len is the function that will be called when trying to calculate the length of the table using the # (5.2+) operator; </li><li>  __pairs is a function, an alternative to the iterator pairs for this table (5.2+); </li><li>  __ipairs - a function, an alternative to ipairs (5.2+); </li></ul><br><h4>  Mathematical metamethods and comparison (functions) </h4><br><ul><li>  __add - (+) addition; </li><li>  __sub - (-) subtraction; </li><li>  __mul - (*) multiplication; </li><li>  __div - (/) division; </li><li>  __pow - (^) exponentiation; </li><li>  __mod - (%) modulo division; </li><li>  __idiv - (//) division with the withdrawal of the whole part (5.3+); </li><li>  __eq - (==) equality comparison; </li><li>  __lt - (&lt;) ‚Äúless than‚Äù comparison, in the opposite direction is performed automatically, reversing the arguments; </li><li>  __le - (&lt;=) less or equal comparison; </li></ul><br><h4>  Bit operations (functions, 5.3+ only) </h4><br><ul><li>  __band - (&amp;) "and"; </li><li>  __bor - (|) "OR"; </li><li>  __bxor - (~) the exclusive "OR" (a ~ b); </li><li>  __bnot - (~) "NO" (~ a); </li><li>  __bshl - (&lt;&lt;) bit shift to the left; </li><li>  __bshr - (&gt;&gt;) bit shift to the right. </li></ul><br><h3>  Examples </h3><br><h4>  Index </h4><br>  One of the most common metamethods, and causing the most questions. <br>  It can be a table or a function, with arguments (self, key), where self is the table to look for, and key is the key whose value we want to get. <br><br>  Based on this meta-method, a large number of features are built, such as OOP, proxy tables, default values ‚Äã‚Äãof tables, and much more. <br><br>  Sometimes it can be harmful when you need to get the exact key for THIS table, in such cases they use the value = rawget (table, key) function, which is the default access function for the tables (it is called in bytecode when trying to get the value by key) . <br><br><pre><code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--[[1]]</span></span> foo = {} foo.key = <span class="hljs-string"><span class="hljs-string">'value'</span></span> <span class="hljs-comment"><span class="hljs-comment">--[[2]]</span></span> mt = {<span class="hljs-built_in"><span class="hljs-built_in">__index</span></span> = foo} <span class="hljs-comment"><span class="hljs-comment">-- setmetatable       --[[3]] bar = setmetatable({}, mt) bar.key2 = 'value2' -- : --[[4]] print('bar.key2', bar.key2) --&gt; 'value2' --[[5]] print('bar.key', bar.key) --&gt; 'value' --[[6]] bar.key = 'foobar' foo.foo = 'snafu' print('bar.key', bar.key) --&gt; 'foobar' print('bar.foo', bar.foo) --&gt; 'snafu' print('bar.foobarsnafu', bar.foobarsnafu) --&gt; nil --[[7]] foo = {key = 'FooBar'} --    bar = setmetatable({}, {__index = foo}) snafu = setmetatable({}, {__index = bar}) print('snafu.key', snafu.key) --&gt; 'FooBar' --[[8]] foo = {} foo.__index = foo setmetatable(foo, foo) -- print('foo.key', foo.key) --&gt; error: loop in gettable print('foo.__index', foo.__index) --&gt; "table: 0x12345678" print('rawget(foo, "key")', rawget(foo, "key")) --&gt; nil --[[9]] foo = {} foo.key = 'value' setmetatable(foo, {__index = function(self, key) return key end}) print('foo.key', foo.key) --&gt; 'value' print('foo.value', foo.value) --&gt; 'value' print('foo.snafu', foo.snafu) --&gt; 'snafu' --[[10]] fibs = { 1, 1 } setmetatable(fibs, { __index = function(self, v) self[v] = self[v - 1] + self[v - 2] return self[v] end })</span></span></code> </pre> <br>  What's going on here: <br><br>  1. foo is a table in which we will look for keys that we don‚Äôt have. <br>  2. mt is a table with the key __index = foo.  If you attach it to something like a metatable, it will indicate: "If you have no keys, try finding them in foo." <br>  3. Here is the process of clinging the metatable mt to an empty table (which becomes bar) <br>  4. An example of direct access to table keys.  In this case, we take the key as usual from the bar table. <br>  5. An example of access to keys on __index.  In this case, in the bar table there is no key ["key"], and we look for it by __index metatables - in the foo table. <br>  6. Specification: if we enter the key key in the bar table, it will be found in it and if we try to pick up the value, the chain of metamethods will not be called.  But all other non-existent keys, such as [‚Äúfoo‚Äù], will continue to invoke the metamethod chain.  The key [‚Äúfoobarsnafu‚Äù] is missing in both tables, and its value is a logical nil. <br>  7. Index allows you to create search chains.  In this case, the key search algorithm is as follows: <br><br>  1. We are looking for the key ["key"] in the snafu table. <br>  2. Not found.  The metatable snafu has the __index key pointing to the bar table.  We are looking for there. <br>  3. Again not found.  But there is also a metatable with the __index key pointing to the table foo.  Are looking for. <br>  4. Found!  Here it is our key, and its value is ‚ÄúFooBar‚Äù! <br><br><img src="https://habrastorage.org/webt/js/mq/pr/jsmqprpne1ts9mqlhcjxhxy0cj4.png"><br><br>  8. In this case, we create a table with the key __index, equal to it, and set it as a metatable for ourselves.  When trying to get a value for any missing key, a recursive cycle of searching within itself, and __index transitions of the metatable and further search occurs.  Therefore, it is better not to make closed search chains.  If you use rawget, no metamethod is invoked, and we get the exact value of this key. <br>  9. As a __index key, a metatable can have a function with two arguments - self - the table itself, key - the key whose value we want to get.  The return value of the function becomes the value.  With this, you can create arbitrary indexing on the tables, or create a proxy. <br>  10. An example is taken from Wikipedia.  In this case, the __index of the fibs table automatically recalculates the values ‚Äã‚Äãof Fibonacci numbers with memoization, i.e.  print (fibs [10]) will print the tenth fibonacci number.  Works through recursive calculation of missing table values.  Subsequent values ‚Äã‚Äãare memosized into a table.  It takes a little time to understand: if fibs [v - 1] is absent, the same set of actions as for fibs [v] is performed for it. <br><br><h4>  Newindex </h4><br>  Not so common metamethod, but also sometimes convenient for creating closed tables, filtering or proxying, and a few more things. <br><br>  It can always be only a function, with arguments (self, key, value). <br><br>  It can sometimes be harmful, so the rawset function (self, key, value) is used to force non-use of a given metamethod, which is a function for tables by default. <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--[[1]]</span></span> foo = {} mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__newindex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key, value)</span></span></span></span> foo[key] = value <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> bar = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({a = <span class="hljs-number"><span class="hljs-number">10</span></span>}, mt) bar.key = <span class="hljs-string"><span class="hljs-string">'value'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'bar.key'</span></span>, bar.key) <span class="hljs-comment"><span class="hljs-comment">--&gt; nil print('foo.key', foo.key) --&gt; 'value' --[[2]] bar.a = 20 print('bar.a', bar.a) --&gt; 20 --[[3]] mt = {} function mt.__newindex(self, key, value) if type(value) == 'number' then --       __newindex rawset(self, key, value) end end foo = setmetatable({}, mt) foo.key = 'value' foo.key2 = 100500 print('foo.key', foo.key) --&gt; nil print('foo.key2', foo.key2) --&gt; 100500</span></span></code> </pre><br>  1. This is the simplest example of adding keys through a proxy table using the metamethod __newindex.  All new value keys that we add to the bar table are added to foo according to the function.  Self, in this case, the bar table; <br><br>  2. __newindex applies only to non-existent keys; <br><br>  3. An example of a filter function that allows you to add only numeric values ‚Äã‚Äãto a table.  In the same way, we can check ‚Äúadd only numeric keys‚Äù, or create several tables in advance for row-tables, etc., and add values ‚Äã‚Äãto the appropriate (classification / balancing, etc.). <br><br><h4>  Call </h4><br>  This metamethod is convenient for reducing elements or calling default methods of functions with tables and for slightly more comfortable OOP, when we call table-class as a function, and we get an object. <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--[[1]]</span></span> mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, a, b, c, d)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a..b..c..d <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, mt) foo.key = <span class="hljs-string"><span class="hljs-string">'value'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(foo(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-string"><span class="hljs-string">'!'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">--&gt; 102030! print(foo.key) --&gt; 'value' print(foo.bar) --&gt; nil --[[2]] mt = {} --  -  ,      -- : a, b, c, d = ... function mt.__call(self, ...) return self.default(...) end foo = setmetatable({}, mt) function foo.mul2(a, b) return a * b end function foo.mul3(a, b, c) return a * b * c end foo.default = foo.mul2 print('foo.mul2(2, 3)', foo.mul2(2, 3)) --&gt; 6 print('foo.default(2, 3)', foo.default(2, 3)) --&gt; 6 print('foo.mul3(2, 3, 4)', foo.mul3(2, 3, 4)) --&gt; 24 --    . print('foo(2, 3)', foo(2, 3)) --&gt; 6 foo.default = foo.mul3 print('Default was changed') print('foo(2, 3, 4)', foo(2, 3, 4)) --&gt; 24</span></span></code> </pre><br>  1. An example of using a metatable, a table can be called as a function.  The table itself is passed as self, called as a function. <br><br>  2. In this example, we fill the table with functions, and the metatable indicates that if it is called as a function, it will return the result of the function under the default key. <br><br><h4>  Tostring and Concat </h4><br>  Just casting an object to a string and concatenation. <br><br><pre> <code class="lua hljs">mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__tostring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>..<span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">concat</span></span>(self, <span class="hljs-string"><span class="hljs-string">', '</span></span>)..<span class="hljs-string"><span class="hljs-string">']'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, mt) foo[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> foo[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">20</span></span> foo[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, foo) <span class="hljs-comment"><span class="hljs-comment">--&gt; [10, 20, 30] -- print('foo..foo', foo..foo) -- !   ! function mt.__concat(a, b) return tostring(a)..tostring(b) end print('foo.."!"', foo.."!") --&gt; [10, 20, 30]! print('"!"..foo', "!"..foo) --&gt; ![10, 20, 30] print('foo..foo', foo..foo) --&gt; [10, 20, 30][10, 20, 30]</span></span></code> </pre><br><h4>  Metatable </h4><br>  Hiding metatables is sometimes useful. <br><br><pre> <code class="lua hljs">mt = {} mt.id = <span class="hljs-number"><span class="hljs-number">12345</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, mt) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">getmetatable</span></span>(foo).id) <span class="hljs-comment"><span class="hljs-comment">--&gt; 12345 mt.__metatable = 'No metatables here!' print(getmetatable(foo)) --&gt; 'No metatables here!' mt.__metatable = false print(getmetatable(foo)) --&gt; false</span></span></code> </pre><br><h4>  Mode </h4><br>  Row, indicates the mode of relations of table values.  If it contains the letter 'k', then keys will be declared weak; if it contains the letter 'v', the values ‚Äã‚Äãwill become weak.  You can use them together.  The examples will use the function collectgarbage - forced collection of all garbage. <br><br>  Tables in Lua are always passed by reference. <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--[[1]]</span></span> mt = {<span class="hljs-built_in"><span class="hljs-built_in">__mode</span></span> = <span class="hljs-string"><span class="hljs-string">'v'</span></span>} foo = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, mt) <span class="hljs-comment"><span class="hljs-comment">--[[2]]</span></span> bar = {foobar = <span class="hljs-string"><span class="hljs-string">'fu'</span></span>} foo.key = bar foo.key2 = {barfoo = <span class="hljs-string"><span class="hljs-string">'uf'</span></span>} foo[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">100500</span></span> <span class="hljs-comment"><span class="hljs-comment">--[[3]]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'foo.key.foobar'</span></span>, foo.key.foobar) <span class="hljs-comment"><span class="hljs-comment">--&gt; 'fu' print('foo.key2.barfoo', foo.key2.barfoo) --&gt; 'uf' print('foo[1]', foo[1]) --&gt; 100500 collectgarbage() print('foo.key.foobar', foo.key.foobar) --&gt; 'fu' print('foo[1]', foo[1]) --&gt; 100500 -- print('foo.key2.barfoo', foo.key2.barfoo) --&gt; , key2  ! --[[4]] bar = nil collectgarbage() -- print('foo.key.foobar', foo.key.foobar) --&gt; , key  !</span></span></code> </pre><br>  1. An example of a table of weak values: if there are no references to values, except in this table, they will be deleted during the garbage collection process. <br><br>  2. After the execution of this part of the code on the table <br>  "{foobar = 'fu'}" there are two links (in the global space and in the table foo), and the table <br>  "{barfoo = 'uf'}" - one, inside foo. <br><br>  3. We see that while in the foo table there are all the values, but after garbage collection, the table key2 disappears.  This is because there are no more strong links to it, only the weak ones that allow the scavenger to collect it.  This does not apply to foo [1], since 100500 is not a reference type (not a table, not a function, not a userdata, etc., but a number). <br><br>  4. If we remove the only strong bar reference, the {foobar = 'fu'} table will also be destroyed after garbage collection. <br><br>  It works in a similar way with 'k', only with respect to the table reference keys (foo [{key = 'value'}] = true). <br><br><h4>  GC </h4><br>  The __gc function will be called if the table is collected by the garbage collector.  Can be used as a finalizer.  Functions with tables and cdata / userdata. <br><br><pre> <code class="lua hljs">mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__gc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'Table '</span></span>..<span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(self)..<span class="hljs-string"><span class="hljs-string">' has been destroyed!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- lua 5.2+ foo = {} setmetatable(foo, mt) -- Lua 5.1 if _VERSION == 'Lua 5.1' then --  __gc   5.1     cdata-. --   -  ,   . --     'foo',    local t = foo -- newproxy  cdata-,   Lua 5.1. local proxy = newproxy(true) --  __gc  cdata -  __gc-  foo getmetatable(proxy).__gc = function(self) mt.__gc(t) end foo[proxy] = true end print(foo) foo = nil collectgarbage() --&gt; 'Table 0x12345678 has been destroyed!'</span></span></code> </pre><br><h4>  Len </h4><br>  The function that overrides the algorithm for computing the length of the table (Lua 5.2+). <br><br><pre> <code class="lua hljs">mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> keys = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> keys = keys + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keys <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, mt) foo[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> foo[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">20</span></span> foo.key = <span class="hljs-string"><span class="hljs-string">'value'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'#foo'</span></span>, #foo) <span class="hljs-comment"><span class="hljs-comment">--&gt; 3 (2  Lua 5.1)</span></span></code> </pre><br><h4>  Pairs and Ipairs </h4><br>  Override standard table iterators for this table (Lua 5.2+). <br><br><pre> <code class="lua hljs">mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mt.__pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> key, value = <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> key, value = <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(self, key) <span class="hljs-comment"><span class="hljs-comment">--  - . while key and type(key) == 'number' do key, value = next(self, key) end return key, value end end function mt.__ipairs(self) local i = 0 -- ipairs   . return function() i = i - 1 return self[i] and i, self[i] end end foo = setmetatable({}, mt) foo[1] = 10 foo[2] = 20 foo[-1] = -10 foo[-2] = -20 foo.foo = 'foobar' foo.bar = 'barfoo' -- Lua 5.1    , -- 5.2+ -    for k, v in pairs(foo) do print('pairs test', k, v) end --&gt; foo foobar --&gt; bar barfoo -- Lua 5.1      , -- 5.2+ -     for i, v in ipairs(foo) do print('ipairs test', i, v) end --&gt; -1 -10 --&gt; -2 -20</span></span></code> </pre><br><h4>  Operator Overloading </h4><br>  Overloading of all operators works according to one scheme, detailed examples for each are not needed. <br><br><pre> <code class="lua hljs">]] <span class="hljs-comment"><span class="hljs-comment">--[[1]]</span></span> vector_mt = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_mt.__add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> v = {} vx = ax + bx vy = ay + by <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>(v, vector_mt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_mt.__div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> v = {} vx = ax / bx vy = ay / by <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>(v, vector_mt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">--   function vector_mt.__tostring(self) return '['..self.x..', '..self.y..']' end vec1 = setmetatable({}, vector_mt) vec1.x = 1 vec1.y = 2 vec2 = setmetatable({}, vector_mt) vec2.x = 3 vec2.y = 4 vec3 = vec1 + vec2 print('vec3', vec3) --&gt; [4, 6] print('vec2 / vec1', vec2 / vec1) --&gt; [3, 2] --[[2]] mt = {} function mt.__add(a, b) local insert_position = 1 if type(a) == 'table' and getmetatable(a) == mt then insert_position = #a + 1 else a, b = b, a end table.insert(a, insert_position, b) return a end --   function mt.__tostring(self) return '['..table.concat(self, ', ')..']' end foo = setmetatable({}, mt) --[[3]] foo = 3 + 4 + foo + 10 + 20 + 'a' + 'b' print('foo', foo) --&gt; [7, 10, 20, a, b] foo = '12345' + foo print('foo', foo) --&gt; [12345, 7, 10, 20, a, b]</span></span></code> </pre><br>  1. An example of operator overloading on tables that behave like vectors, thanks to the metatable.  The order of the arguments should be monitored; each operation returns a new table, the ‚Äúvector‚Äù. <br><br>  2. A table in which elements can be added using the "+" operator. <br>  The order of addition determines whether we add an element to the end or to the beginning. <br><br>  3. 3 + 4 will be executed first, so the first element is ‚Äú7‚Äù. <br>  In other cases, the following will be added to the result of the previous item: <br>  ((7 + foo -&gt; foo) + 10 -&gt; foo) ... <br><br><h3>  What can you do with all this? </h3><br><h4>  OOP </h4><br>  The first thing that suggests itself is an attempt to make OOP. <br><br>  Let's try to write a simple function that implements some abstract "class": <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> class = {} <span class="hljs-comment"><span class="hljs-comment">--   . local mClass = {__index = class} -- ,   ""  . function class.instance() return setmetatable({}, mClass) end return class end --   . Rectangle = Class() function Rectangle.new(x, y, w, h) local self = Rectangle.instance() self.x = x or 0 self.y = y or 0 self.w = w or 10 self.h = h or 10 return self end function Rectangle.area(self) return self.w * self.h end --  rect = Rectangle.new(10, 20, 30, 40) print('rect.area(rect)', rect.area(rect)) --&gt; 1200 print('rect:area()', rect:area()) --&gt; 1200</span></span></code> </pre><br>  Here, already something similar to OOP.  There is no inheritance and any cool stuff, but this is not bad. <br>  When rect.area is called, the object table does not have an area key, so it goes to look for it through __index at the class table, finds it, and substitutes itself with the first argument. <br><br>  Small deviation from metatables: an example of the second call - the first appearance in this article of a colon.  The colon is the syntactic sugar of the Lua language.  If you call a function in the table with a colon and not a dot, the table itself will be substituted with the first argument to this function, so this code is equivalent. <br><br>  In details: <br><br><pre> <code class="lua hljs">foo = {x = <span class="hljs-number"><span class="hljs-number">10</span></span>, y = <span class="hljs-number"><span class="hljs-number">20</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo.bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (self.x + a) * (self.y + b) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'foo.bar(foo, 1, 2)'</span></span>, foo.bar(foo, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">--&gt; 242 -- ,  self "" . function foo:bar(a, b) return (self.x + a) * (self.y + b) end print('foo:bar(1, 2)', foo:bar(1, 2)) --&gt; 242</span></span></code> </pre><br>  You can try to slightly improve this option. <br><br>  First, add the ability to call the class as a function with the return of the object, second, add the ability to overload the operators of the class itself, Third, inheritance. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> class = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mClass = {} <span class="hljs-comment"><span class="hljs-comment">--      . --     . class.__index = class --       __index, --  ,   ,   . mClass.__index = parent --   Super  . class.Super = parent -- ,       function mClass:__call(...) local instance = setmetatable({}, class) --    "init" if type(class.init) == 'function' then --         init return instance, instance:init(...) end --     -  . return instance end return setmetatable(class, mClass) end --  . Shape = Class() function Shape:init(x, y) --   self     . self.x = x or 0 self.y = y or 0 return '!!!' end function Shape:posArea() return self.x * self.y end --    Shape      , --     . function Shape:__tostring() return '[' .. self.x .. ', ' .. self.y ..']' end local foo, value = Shape(10, 20) print('foo, value', foo, value) --&gt; [10, 20] !!! --  Rectangle = Class(Shape) function Rectangle:init(x, y, w, h) --   , self -   , --     Rectangle,  . --     Super. self.Super.init(self, x, y) --      -  . self.w, self.h = self:getDefault(w, h) end function Rectangle:area() return self.w * self.h end function Rectangle:getDefault(w, h) return w or 10, h or 20 end function Rectangle:__tostring() return '['..self.x..', '..self.y..', '..self.w .. ', '..self.h..']' end rect = Rectangle(10, 20, 30, 40) print('rect', rect) --&gt; [10, 20, 30, 40] print('rect:area()' , rect:area()) --&gt; 30 * 40 = 1200 --    print('rect:posArea()', rect:posArea()) --&gt; 10 * 20 = 200</span></span></code> </pre><br>  Thus, in 15 lines of useful code, it is possible to implement the maximum of the truly necessary OOP in Lua. <br><br>  Of course, there is something to improve and weigh something, and such work has been done in the middleclass or hump.Class libraries, but sometimes this is useful. <br><br>  By the way, if you do not want to bother with the function-classes, and you just need to write one or two classes, you can use the construction <a href="http://tylerneylon.com/a/learn-lua/">from here</a> . <br><br><h4>  Proxy tables </h4><br>  Here, finally, an example of a full-fledged proxy, with tracking of actions. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> real_table = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> logger = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> metatable = {} <span class="hljs-comment"><span class="hljs-comment">--         function metatable:__index(key) local value = rawget(real_table, key) table.insert(logger, "Get key "..tostring(key)..' is '.. tostring(value)) return value end --     ,    function metatable:__newindex(key, value) table.insert(logger, "Set key "..tostring(key)..' as '..tostring(value)) rawset(real_table, key, value) end return setmetatable({}, metatable), logger end prox, log = proxy() prox.a = 10 prox.a = 20 print('prox.a', prox.a) --&gt; 20 print('log', '\n'..table.concat(log, '\n')) --&gt; Set key a as 10 --&gt; Set key a as 20 --&gt; Get key a, is 20</span></span></code> </pre><br>  The output table, which logs its use.  In this case, the proxy table is always empty, there are no keys in it, so __newindex will be called every time. <br><br><h4>  Temporary object tables </h4><br>  From time to time, you may need temporary objects that exist for some time, but when there is a shortage of memory, they take up space.  This example will require the presence of the <a href="https://github.com/brunoos/luasec">Luasec</a> library (https-requests), although with the same success you can use <a href="https://github.com/diegonehab/luasocket">Luasocket</a> , only without https. <br><br><pre> <code class="lua hljs">page = {} page.https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span><span class="hljs-string"><span class="hljs-string">'ssl.https'</span></span> page.cache = <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>({}, {<span class="hljs-built_in"><span class="hljs-built_in">__mode</span></span> = <span class="hljs-string"><span class="hljs-string">'v'</span></span>}) <span class="hljs-comment"><span class="hljs-comment">--     page._meta = {} function page._meta:__tostring() return 'Page: ['..self.url.. ']: '.. self.status end setmetatable(page, page) function page:__call(url) return self.cache[url] or self:request(url) end function page:request(url) local page = setmetatable({}, self._meta) page.url = url page.data, page.status, page.error, page.hate = self.https.request(url) print(page.data, page.status, page.error, page.hate) self.cache[url] = page return page end -- , , . p = page('https://yandex.ru') print('p', p) --&gt; Page: [https://yandex.ru]: 200 print('p.status', p.status) --&gt; 200 --     , --     -   . print('page.cache[...]', page.cache['https://yandex.ru']) --&gt; Page: [https://yandex.ru]: 200 --     ,      "p". collectgarbage() print('page.cache[...]', page.cache['https://yandex.ru']) --&gt; Page: [https://yandex.ru]: 200 p = nil collectgarbage() --     -   ,    . print('page.cache[...]', page.cache['https://yandex.ru']) --&gt; Nil</span></span></code> </pre><br><h3>  Bye all </h3><br>  I believe that this material is enough to more or less learn metatables, if there are interesting or funny examples - write in the comments. <br><br>  For those who want to ask a bunch of questions - leave a link to <a href="https://t.me/ProLua">chat in the cart</a> . </div><p>Source: <a href="https://habr.com/ru/post/346892/">https://habr.com/ru/post/346892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346880/index.html">Flask Mega-Tutorial, Part 7: Error Handling (Edition 2018)</a></li>
<li><a href="../346882/index.html">Autopilot simulation on a flight simulator</a></li>
<li><a href="../346884/index.html">How we chose between Elastic and Tarantool, and made our (fastest) in-memory database. With Join and Full-Text Search</a></li>
<li><a href="../346888/index.html">Azure ML Workbench: Getting Started</a></li>
<li><a href="../346890/index.html">Writing code in the docker environment</a></li>
<li><a href="../346896/index.html">Experiment to account for time, or What I learned by analyzing a whole month of my life</a></li>
<li><a href="../346898/index.html">School of speakers: analysis of the speech of Evgeny Rossinsky, ivi</a></li>
<li><a href="../346900/index.html">Expressive Kotlin. Extensions</a></li>
<li><a href="../346902/index.html">Safety of football stadiums: some implicit features</a></li>
<li><a href="../346904/index.html">Agile communication in distributed teams that do not intersect at work time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>