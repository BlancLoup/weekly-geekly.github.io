<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hardware bit banding CortexM3 / M4 (ARM), kernel architecture, assembler, C / C ++ 14 and a drop of metaprogramming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Attention, this is not another ‚ÄúHello world‚Äù article about how to blink a LED or get into your first interruption on STM32. However, I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hardware bit banding CortexM3 / M4 (ARM), kernel architecture, assembler, C / C ++ 14 and a drop of metaprogramming</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Attention, this is not another ‚ÄúHello world‚Äù article about how to blink a LED or get into your first interruption on STM32.  However, I tried to give exhaustive explanations on all the issues raised, so the article will be useful not only for many professional and dreaming developers (as I hope), but also for beginner programmers of microcontrollers, since this topic somehow comes along on countless sites / blogs "programming teachers MK." <br><br><img src="https://habrastorage.org/webt/e5/rs/75/e5rs75rpejygxwippglfvpftzci.png" alt="image"><br><a name="habracut"></a><br><h2>  Why did I decide to write it? </h2><br>  Although I exaggerated, having said earlier that the hardware bit banding of the Cortex-M family is not described in specialized resources, there are still places where this opportunity is covered (and even here I met one article), but this topic clearly needs to be supplemented and modernized.  I note that this applies to English-speaking resources.  In the next section, I will explain why this kernel feature can be extremely important. <br><br><h2>  Theory </h2><br>  <i>(and those who are familiar with it, can jump immediately into practice)</i> <br>  Hardware bit banding is a feature of the core itself, and therefore does not depend on the family and the manufacturer of the microcontroller, the main thing is that the core is suitable.  In our case, let it be the Cortex-M3.  Consequently, information on this issue should be sought in the official document on the core itself, and there is such a document, <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/DDI0337E_cortex_m3_r1p1_trm.pdf">here it is</a> , section 4.2 describes in detail how to use this tool. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here I would like to make a small technical digression for programmers who are not familiar with assembler, of which most are now, due to the propagated complexity and uselessness of the assembler for such ‚Äúserious‚Äù 32bit microcontrollers as STM32, LPC, etc. Moreover, you can often find censure for the use of the assembler in this area, even on Habr√©.  In this section I want to briefly describe the mechanism for writing to the memory of the MC, which should clarify the advantages of bit banding. <br><br>  I will explain on a concrete simple example for the majority of STM32.  Suppose I need to turn PB0 into a general-purpose output.  The usual solution will look like this: <br><br><pre><code class="cpp hljs">GPIOB-&gt;MODER |= GPIO_MODER_MODER0_0;</code> </pre> <br>  Obviously, we use a bitwise "OR" so as not to overwrite the other bits of the register. <br><br>  For the compiler, this translates into the following set of 4 instructions: <br><br><ol><li>  Download the general purpose register (RON) address GPIOB-&gt; MODER </li><li>  Download to another RON values ‚Äã‚Äãat the address specified in RON from P1. </li><li>  Make a bitwise "OR" of this value with GPIO_MODER_MODER0_0. </li><li>  Download the result back to GPIOB-&gt; MODER. </li></ol><br>  Also, we must not forget that this kernel uses the instruction set thumb2, which means they can be different in size.  I also note that everywhere we are talking about the level of optimization of O3. <br><br>  In assembly language, it looks like this: <br><br><img src="https://habrastorage.org/webt/kt/px/tf/ktpxtfc4bapih79fj96yf7poi64.png" alt="image"><br><br>  It can be seen that the very first instruction is nothing more than a pseudo-instruction with an offset; we find at the PC address (taking into account the conveying) + 0x58 value of the register address. <br><br><img src="https://habrastorage.org/webt/wf/ar/ea/wfareavtgdjjmqckiemg0jfbygs.png" alt="image"><br><br>  It turns out that we have 4 steps (and there are even more cycles) and 14 bytes of memory for one operation. <br>  If you want to know more about this, then I recommend the book [2], by the way, is in Russian. <br><br><h3>  Moving on to the bit_banding method. </h3><br>  The bottom line, peasantly, is that there is a dedicated memory area in the processor, by writing values ‚Äã‚Äãto which we do not change other bits of the peripheral register or RAM.  That is, we do not need to comply with paragraphs 2) and 3), described above, and for this it is enough just to recount the address using the formulas from [1]. <br><br><img src="https://habrastorage.org/webt/t1/fo/yu/t1foyujiyauoiecjczide1myroi.png" alt="image"><br><br>  We are trying to do a similar operation, its assembler: <br><br><img src="https://habrastorage.org/webt/j_/g-/6d/j_g-6dq9yi1cjt0yxbo7rzqbmrw.png" alt="image"><br><br>  Recalculated address: <br><br><img src="https://habrastorage.org/webt/du/1k/qp/du1kqpsrhjinmp6y4i2hkuqeut4.png" alt="image"><br><br>  Here we added the instruction for recording # 1 in RON, but all the same, in the end, it turns out 10 bytes, instead of 14, and a couple of clocks less. <br><br><h2>  So what if the difference is funny? </h2><br>  On the one hand, the savings are not significant, especially in cycles, when it‚Äôs already a habit to overclock the controller to 168 MHz.  On an average project, the moments where this method can be applied will be 40 - 80, respectively, in bytes, the savings can reach 250 bytes if the addresses differ.  And if we consider that the programming of the MK directly on the registers is now considered a ‚Äúzashkvar‚Äù, and it‚Äôs ‚Äúcool‚Äù to use all kinds of cubes, then the savings can be much more. <br><br>  Also, the figure of 250 bytes is distorted by the fact that high-level libraries are actively used in the community, the firmware is blown up to indecent sizes.  Programming at a low level is at least 2 - 5% of software volume for an average project, with competent architecture and O3 optimization. <br><br>  <i>Again, I do not want to say that this is some kind of super-duper mega cool tool that every self-respecting programmer MK should use.</i>  <i>But if I can cut costs even for such a small part, why not do it?</i> <br><br><h2>  Implementation </h2><br>  All options will be given only to configure the periphery, since I did not come across a situation when it would be necessary for RAM.  Strictly speaking, the formula for the RAM is similar, you just need to change the base addresses for the calculation.  So how to implement it? <br><br><h4>  Assembler </h4><br>  Let's go from the bottom, with my favorite assembler. <br><br>  On assembly projects, I usually allocate a couple of 2 bytes (according to the instructions working with them) RON for # 0 and # 1 for the whole project, and I also use them in macros, which reduces me to 2 more bytes on an ongoing basis.  Remark, I did not find CMSIS on the Assembler for STM, because I immediately put the bit number in the macro, and not its value in the register. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation for GNU Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">@  . MOVW R0, 0x0000 MOVW R1, 0x0001 @   .macro PeriphBitSet PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+(((\PerReg) - BIT_BAND_REGION) * 32) + ((\BitNum) * 4)) STR R1, [R3] .endm @   .macro PeriphBitReset PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+((\PerReg - BIT_BAND_REGION) * 32) + (\BitNum * 4)) STR R0, [R3] .endm</code> </pre> <br></div></div><br>  Examples: <br><br><div class="spoiler">  <b class="spoiler_title">Examples for the Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">PeriphSet TIM2_CCR2, 0 PeriphBitReset USART1_SR, 5</code> </pre><br></div></div><br>  The undoubted advantage of this option is that we have complete control, which cannot be said about further options.  And as the last section of the article will show, plus this one is <b>very</b> significant. <br><br>  However, no one needs projects for MK in Assembler, approximately from the end of zero, which means you need to switch to SI. <br><br><h4>  Plain c </h4><br>  Honestly, the simple Cishny version was found by me at the beginning of the path, somewhere in the vast network.  At that time, I had already implemented bit banding in Assembler, and accidentally stumbled upon a C file, it immediately started working and I decided not to invent anything. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation for plain C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*!&lt;=================PLAIN C SECTION========================&gt;!*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT31(A) (A==0x80000000)? 31 : 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT30(A) (A==0x40000000)? 30 : MASK_TO_BIT31(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT29(A) (A==0x20000000)? 29 : MASK_TO_BIT30(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT28(A) (A==0x10000000)? 28 : MASK_TO_BIT29(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT27(A) (A==0x08000000)? 27 : MASK_TO_BIT28(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT26(A) (A==0x04000000)? 26 : MASK_TO_BIT27(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT25(A) (A==0x02000000)? 25 : MASK_TO_BIT26(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT24(A) (A==0x01000000)? 24 : MASK_TO_BIT25(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT23(A) (A==0x00800000)? 23 : MASK_TO_BIT24(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT22(A) (A==0x00400000)? 22 : MASK_TO_BIT23(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT21(A) (A==0x00200000)? 21 : MASK_TO_BIT22(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT20(A) (A==0x00100000)? 20 : MASK_TO_BIT21(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT19(A) (A==0x00080000)? 19 : MASK_TO_BIT20(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT18(A) (A==0x00040000)? 18 : MASK_TO_BIT19(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT17(A) (A==0x00020000)? 17 : MASK_TO_BIT18(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT16(A) (A==0x00010000)? 16 : MASK_TO_BIT17(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT15(A) (A==0x00008000)? 15 : MASK_TO_BIT16(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT14(A) (A==0x00004000)? 14 : MASK_TO_BIT15(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT13(A) (A==0x00002000)? 13 : MASK_TO_BIT14(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT12(A) (A==0x00001000)? 12 : MASK_TO_BIT13(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT11(A) (A==0x00000800)? 11 : MASK_TO_BIT12(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT10(A) (A==0x00000400)? 10 : MASK_TO_BIT11(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT09(A) (A==0x00000200)? 9 : MASK_TO_BIT10(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT08(A) (A==0x00000100)? 8 : MASK_TO_BIT09(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT07(A) (A==0x00000080)? 7 : MASK_TO_BIT08(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT06(A) (A==0x00000040)? 6 : MASK_TO_BIT07(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT05(A) (A==0x00000020)? 5 : MASK_TO_BIT06(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT04(A) (A==0x00000010)? 4 : MASK_TO_BIT05(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT03(A) (A==0x00000008)? 3 : MASK_TO_BIT04(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT02(A) (A==0x00000004)? 2 : MASK_TO_BIT03(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT01(A) (A==0x00000002)? 1 : MASK_TO_BIT02(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT(A) (A==0x00000001)? 0 : MASK_TO_BIT01(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) (*(volatile uint32_t*)(PERIPH_BB_BASE+32*((uint32_t)(&amp;(reg))-PERIPH_BASE)+4*((uint32_t)(MASK_TO_BIT(reg_val)))))</span></span></code> </pre><br></div></div><br>  As you can see, a very simple and straightforward piece of code written in the pre processor language.  The main work here is the translation of CMSIS values ‚Äã‚Äãinto a bit number, which was absent as a need for an assembler version. <br><br>  Oh yeah, use this option like this: <br><br><div class="spoiler">  <b class="spoiler_title">Examples for plain C</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = 1; // (!0)</span></span></code> </pre><br></div></div><br>  However, modern (massively, according to my observations, approximately since 2015) trends are in favor of replacing C with C ++, even for MC.  And macros are not the most reliable tool, so the next version was destined to be born. <br><br><h4>  Cpp03 </h4><br>  Here comes a very interesting and discussed, but little used in view of its complexity, with one hackneyed example of factorial, a tool - metaprogramming. <br><br>  After all, the task of translating the value of a variable into the number of bits is ideal (there are already values ‚Äã‚Äãin CMSIS), and in this case it is practical for compile time. <br><br>  I implemented it as follows, using templates: <br><br><div class="spoiler">  <b class="spoiler_title">Implementation for C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> comp_val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cur_bit_num&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = (val == comp_val) ? cur_bit_num : bit_num_from_value&lt;val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, cur_bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::bit_num }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class">&lt;val, static_cast&lt;uint32_t&gt;(0x80000000), static_cast&lt;uint32_t&gt;(31)&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = <span class="hljs-number"><span class="hljs-number">31</span></span> }; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value&lt;static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)&gt;::bit_num)))</span></span></span></span></code> </pre><br></div></div><br>  You can use the same: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ 03 Examples</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = true; //</span></span></code> </pre><br></div></div><br>  And why was the macro left?  The fact is that I do not know of any other way to ensure that this operation is inserted without switching to another area of ‚Äã‚Äãthe program code.  I would be very happy if the comments prompt.  Neither templates nor inline features provide such a guarantee.  Yes, and the macro here copes with its task perfectly well; there is no point in changing it just because someone who considers the <s>conformist</s> considers this ‚Äúnot safe‚Äù. <br><br>  Surprisingly, time still did not stand still, compilers increasingly supported C ++ 14 / C ++ 17, why not take advantage of the innovations to make the code more understandable. <br><br><h4>  Cpp14 / Cpp17 </h4><br><div class="spoiler">  <b class="spoiler_title">Implementation for C ++ 14</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bit_num_from_value_cpp14</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comp_val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bit_num = (val == comp_val) ? bit_num : bit_num_from_value_cpp14(val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value_cpp14(static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)))))</span></span></span></span></code> </pre><br></div></div><br>  As you can see, I simply replaced the templates with the recursive constexpr function, which, in my opinion, is more understandable to the human eye. <br><br>  Use the same.  By the way, in C ++ 17, in theory, you can use the recursive lambda constexpr function, but I'm not sure that it will lead to at least some simplifications, and also will not complicate the assembler order. <br><br>  <b>Summarizing, all three C / Cpp implementations give an equally correct set of instructions, according to the Theory section.</b>  <b>I have been working for a long time with all implementations on IAR ARM 8.30 and gcc 7.2.0.</b> <br><br><h2>  Practice is a bitch </h2><br>  That seems to be the case.  Memory savings calculated, the implementation chosen, ready to improve performance.  It was not there, it was just a case of divergence between theory and practice.  And when was it different? <br><br>  I would never have published it if I hadn‚Äôt tested it, but to what extent the occupied volume decreases on projects.  I specifically on a couple of old projects replaced this macro with a regular implementation without a mask, and looked at the difference.  The result was unpleasantly surprised. <br><br>  As it turned out, the volume practically does not change.  I specifically chose the projects where exactly 40-50 such instructions were used.  According to the theory, I should have saved at least 100 bytes, and at most 200. In practice, the difference turned out to be 24 - 32 bytes.  But why? <br><br>  Usually, when you configure peripherals, you configure 5-10 registers almost in a row.  And at a high level of optimization, the compiler does not have instructions exactly in the order of the registers, but has instructions as it seems to him correct, sometimes interfering with them in seemingly inseparable places. <br><br>  I see two options (here are my guesses): <br><br><ol><li>  Or the compiler is so smart that it knows for you how it will be better to optimize the set of instructions. </li><li>  Either the compiler is still not smarter than a human, and he confuses himself when meeting such constructions </li></ol><br>  That is, it turns out that this method in high-level languages ‚Äã‚Äãwith a high level of optimization works correctly only if there are no similar operations in close proximity to one such operation. <br><br>  By the way, at the O0 level, the theory and practice converge anyway, but this level of optimization is not interesting to me. <br><br><h2>  I summarize </h2><br>  A negative result is also a result.  I think everyone will draw conclusions for himself.  Personally, I will continue to use this technique, it will not be worse from him. <br><br>  I hope it was interesting and I want to express the greatest respect to those who read to the end. <br><br><h2>  References </h2><br><ol><li>  Cortex-M3 Technical Reference Manual, Section 4.2, ARM 2005. </li><li>  The definitive guide to the ARM Cortex-M3, Joseph Yiu. </li></ol><br>  PS I have in stock a bag of little-lit topics related to the development of embedded electronics.  Let me know, if interested, I will slowly get them. <br><br>  PPS Somehow it turned out to be inserted into the code sections, please tell me how to improve, if possible.  In general, you can copy the interesting piece of code in notepad and avoid unpleasant emotions when analyzing. <br><br><h2>  UPD: </h2>  At the request of readers, I indicate that the operation of bit banding itself is atomic, which gives us some security when working with registers.  This is one of the most important features of this method. </div><p>Source: <a href="https://habr.com/ru/post/454408/">https://habr.com/ru/post/454408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45440/index.html">Contextual advertising for various types of sites (seminar for advertisers)</a></li>
<li><a href="../454400/index.html">Daily reports on the status of virtual machines using R and PowerShell</a></li>
<li><a href="../454402/index.html">Unity's state machine architecture for organizing unit behaviors</a></li>
<li><a href="../454404/index.html">Training Cisco 200-125 CCNA v3.0. Day 6. Fill in the blanks (DHCP, TCP, ‚Äúhandshake‚Äù, common port numbers)</a></li>
<li><a href="../454406/index.html">Akihabara: Otaku nesting site</a></li>
<li><a href="../45441/index.html">Antispam by postfix + spamassassin</a></li>
<li><a href="../454410/index.html">New in PHP 7.4</a></li>
<li><a href="../454414/index.html">SDL 2 Tutorial: Lesson 2 - Main Not Rubber</a></li>
<li><a href="../454416/index.html">Import Substitute Hadoop Distribution</a></li>
<li><a href="../454418/index.html">Three unobvious examples of using template engines in backend.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>