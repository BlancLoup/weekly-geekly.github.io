<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compressed Prefix Trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of prefix search trees has already been raised a number of times. Here , for example, it briefly describes what a prefix tree is and why it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compressed Prefix Trees</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/bf3/75b/20f/bf375b20f14ca1d5d6823a73f81c8251.jpg" align="right">  The topic of prefix search trees has already been raised a number of times.  <a href="http://habrahabr.ru/post/111874/" title="Habrahabr: Trie, or a loaded tree">Here</a> , for example, it briefly describes what a prefix tree is and why it is needed, and discusses the main operations on such trees (search, insert, delete).  Unfortunately, nothing is said about the implementation.  <a href="http://habrahabr.ru/post/147963/" title="Habrahabr: Prefix Trees in Python">This recent post</a> discusses the Pitona datrie library, which is the <a href="http://linux.thai.net/~thep/datrie/datrie.html" title="http://linux.thai.net/~thep/datrie/datrie.html">cython</a> wrapper of the <a href="http://linux.thai.net/~thep/datrie/datrie.html" title="http://linux.thai.net/~thep/datrie/datrie.html">libdatrie</a> library.  The last link has a good description of the implementation of partially compressed prefix trees in the form of deterministic finite automata (using arrays).  I decided to add my five kopecks to this topic, having considered the implementation of C ++ prefix trees using pointers.  In addition, there was another goal - to compare the search for strings with each other using a balanced binary search tree ( <a href="http://habrahabr.ru/post/150732/" title="Habrahabr: AVL-trees">AVL-tree</a> ) and a compressed prefix tree. <br><br><a name="habracut"></a><br><br><h1>  Introduction </h1><br>  Recall that a prefix tree is a data structure intended for storing objects with a bitwise structure, for example, strings.  Next, we will consider the implementation of prefix trees to store exactly the lines in the ASCII alphabet, each line ends with a terminal character that is not found anywhere else in the line.  In the figures and examples, the terminal symbol will be denoted by a dollar sign, and in the code, a zero symbol (thus, in our implementation, the strings will be standard C strings, which will allow us to use the standard library string.h).  On the other alphabets all the following should be transferred elementary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the usual prefix tree, each edge is assigned a symbol, in the vertices there is a different service (or user) information stored.  Thus, any path from the root of a tree to some of its leaves defines exactly one line.  It is believed that this string <em>is stored</em> in a given tree.  For example, in the following image, the prefix tree stores the next set of lines {abab $, aba $, bc $, b $, bac $, baca $}.  The root is on the left, the leaves (their number coincides with the number of rows) is on the right.  The path corresponding to the baca $ line is highlighted in red. <br><br><img src="https://habrastorage.org/storage2/c13/b36/dca/c13b36dca1192b9c47f16994e91b2f96.jpg"><br><br>  An attentive reader will easily notice that in this version the prefix tree is a usual deterministic <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582%2522">finite automaton</a> , the receiving states of which correspond to the leaves of the tree.  Actually, the implementation of prefix trees in the <a href="http://linux.thai.net/~thep/datrie/datrie.html" title="http://linux.thai.net/~thep/datrie/datrie.html">libdatrie</a> library is built on this consideration.  The automaton itself is represented using arrays. <br><br>  To reduce the size of the machine, the tree view is used in a partially compressed form, when all tree ‚Äútails‚Äù (areas without branches containing leaves) are packed in rows (figure <em>a</em> below).  It is possible to go further and compress all chains without branches in general in the same way (Figure <em>b</em> ).  In this case, the tree ceases to be a finite automaton (or rather, it remains an automaton, but above the alphabet of strings, not characters) and its implementation using arrays becomes problematic - working with the tree as with an automaton essentially relies on the fact that the size of the alphabet is finite and that for any character it is possible to determine its sequence number in this alphabet in O (1) time (with strings such a technique will not work).  However, in the case of implementation of pointers problems with storing lines should not arise. <br><br><img src="https://habrastorage.org/storage2/4fc/916/675/4fc916675be7ea482bc1f13bdc3e46e9.jpg"><br><br><br><h1>  Tree view using pointers </h1><br>  So, we will represent the edges of the tree with pointers.  First of all, we note that in this case it is not very convenient to store information in the edges of the tree, to put it mildly.  Therefore, we move the chains of characters from the edges to the vertices (using the obvious property of the oriented tree ‚Äî exactly any edge enters any node except the root node).  We get just such a structure. <br><br><img src="https://habrastorage.org/storage2/1bd/5c6/8e7/1bd5c68e7655756193612eed910ab2a3.jpg"><br><br>  Another problem is the outgoing degree of a tree node can be arbitrary (up to the size of the alphabet used).  To solve this problem, we apply the standard method, namely, we will store in each node a <em>list of</em> child nodes.  The list will be simply connected and we will keep in the node only the head of the list (the eldest daughter).  This will allow us at the same time to abandon the empty root.  Now the tree will be represented by a pointer to the head of the list of child nodes of the old root (that is, we replace the tree with the forest).  Thus, each node will now contain exactly two pointers: link - to the eldest child node, next - to its younger sister.  The following figure shows the process of such a transformation, the blue arrows correspond to the link signs, the red arrows to the next signs. <br><br><img src="https://habrastorage.org/storage2/2b1/1e1/109/2b11e1109cc39e70e87ae728a948dd81.jpg"><br><br>  In the future, to understand the logic of working with a tree, it is useful to keep in mind the diagram shown in the figure on the left, while the actual tree representation will be as shown on the right. <br><br>  So, imperceptibly, we have moved from a tree with a variable outgoing degree (a general tree) to a <em>binary tree</em> , in which the pointers to the right and left subtrees are played by the pointers link and next.  The following picture clearly demonstrates this. <br><br><img src="https://habrastorage.org/storage2/8c9/468/67c/8c946867cd7bec02a0ecbfc37771166b.jpg"><br><br>  Now you can go to the implementation.  A tree node is a string of key symbols, its length is len (the string does not have to end with terminal symbols, so you need to know its length explicitly), and two pointers, link and next.  Plus a minimal constructor that creates a trivial tree consisting of one node with a given key (for copying characters we will use the standard function strncpy), and an even more minimal destructor. <br><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> //      {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; node* link; node* next; node(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : len(n), link(<span class="hljs-number"><span class="hljs-number">0</span></span>), next(<span class="hljs-number"><span class="hljs-number">0</span></span>) { key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[n]; <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(key,x,n); } ~node() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] key; } };</code> </pre> <br><br><h1>  Key search </h1><br>  The first operation we consider is the operation of inserting a new line into the prefix tree.  The idea of ‚Äã‚Äãthe search is standard.  Moving from the root of the tree.  If the root is empty, then the search is unsuccessful.  Otherwise, compare the key key in the node with the current row x.  To do this, we use the following function, which calculates the length of the greatest common prefix of two lines of a given length. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> prefix(<span class="hljs-type"><span class="hljs-type">char</span></span>* x, <span class="hljs-type"><span class="hljs-type">int</span></span> n, <span class="hljs-type"><span class="hljs-type">char</span></span>* key, <span class="hljs-type"><span class="hljs-type">int</span></span> m) //      x  key { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-type"><span class="hljs-type">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;n; k++ ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==m || x[k]!=key[k] ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br>  In the case of a search, we are interested in three cases: <br><ol><li>  the common prefix can be empty, then you have to recursively continue the search in the younger sister of this node, i.e  follow the link next; </li><li>  the common prefix is ‚Äã‚Äãequal to the search string x - the search is successful, the node is found (here we essentially use the fact that the end of the string due to the presence of a terminal symbol in it can only be found in a leaf of the tree); </li><li>  the common prefix coincides with the key, but does not coincide with x - we recursively follow the link link to the senior child node, passing it the search string x without the prefix found. </li></ol><br>  If there is a common prefix, but does not match the key, the search is also unsuccessful. <br><br><pre> <code class="hljs lua">node* <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(node* t, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* x, int n=<span class="hljs-number"><span class="hljs-number">0</span></span>) //   x   t { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !n ) n = strlen(x)+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !t ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; int k = prefix(x,n,t-&gt;key,t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>,x,n); //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==n ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(t-&gt;link,x+k,nk); //     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The length n of the string x defaults to zero (and then it is explicitly computed) so that you can call the search function, indicating only the root of the tree and the string to search for: <br><br><pre> <code class="hljs swift"> ... node* p = <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(t,<span class="hljs-string"><span class="hljs-string">"baca"</span></span>); ...</code> </pre><br>  The following figure shows the process of finding three lines (one successful and two not so) in the above tree. <br><br><img src="http://habrastorage.org/storage2/98b/e95/a73/98be95a73a9e37322c6e58639eefde6d.jpg"><br><br>  Note that the search function, if successful, returns a pointer to the leaf of the tree where the search ended.  It is in this node should be located all the information associated with the desired line. <br><br><h1>  Insert keys </h1><br>  Inserting a new key (as in binary search trees) is very similar to a key search.  Naturally with a few differences.  First, in the case of an empty tree, you need to create a node (a trivial tree) with the specified key and return a pointer to this node.  Secondly, if the length of the common prefix of the current key and the current string x is more than zero, but less than the key length (the second case of non-daily search), then the current node should be split into two, leaving the found prefix in the parent node and placing the remaining p node in the child node p part of the key.  This operation is implemented by the split function.  After splitting, you need to continue the process of inserting the string x in the node p without the prefix found. <br><br><img src="http://habrastorage.org/storage2/7ee/66c/737/7ee66c737e620468ac0391784216ff66.jpg"><br><br>  Node Split Code: <br><br><pre> <code class="hljs erlang-repl">void split(node* t, int k) //   t  k-   { node* p = new node(t-&gt;key+k,t-&gt;len-k); p-&gt;link = t-&gt;link; t-&gt;link = p; char* a = new char[k]; strncpy(a,t-&gt;key,k); delete[] t-&gt;key; t-&gt;key = a; t-&gt;len = k; }</code> </pre><br>  Insert code: <br><br><pre> <code class="hljs lua">node* <span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(node* t, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* x, int n=<span class="hljs-number"><span class="hljs-number">0</span></span>) //   x   t { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !n ) n = strlen(x)+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !t ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new node(x,n); int k = prefix(x,n,t-&gt;key,t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==<span class="hljs-number"><span class="hljs-number">0</span></span> ) t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>,x,n); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;n ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;t-&gt;<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> ) //   ? split(t,k); t-&gt;link = <span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(t-&gt;link,x+k,nk); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre><br><br>  An example of inserting the abaca $ and abcd $ keys into the above tree is shown in the following figure. <br><br><img src="http://habrastorage.org/storage2/15c/5a2/dad/15c5a2dadecd9747ce4f2f7b55adc95a.jpg"><br><br>  Note that if the specified string x is already contained in the tree, then no insertion will be made.  From this point of view, the prefix tree behaves like a respectable set. <br><br><h1>  Deleting keys </h1><br>  As usual, deleting a key is the most difficult operation.  Although in the case of a prefix tree, everything does not look so scary.  The point is that deleting a key removes just one leaf node corresponding to the suffix of some key to be deleted.  First we find this node, if the search is successful, then we delete it and return a pointer to the younger sister of this node (he has no daughters, he is a sheet, but there may be sisters). <br><br><img src="http://habrastorage.org/storage2/1fc/46e/216/1fc46e216b5b8e0ded4932fcbe327a9a.jpg"><br><br>  In principle, the deletion process could have been completed, but a small problem arises - after deleting a node in the tree, a chain of two nodes t and p can form, in which the first node t has a <em>single</em> child node p.  Therefore, if we want to keep the tree in a compressed form, then we need to combine these two nodes into one, after performing the merge operation. <br><br><img src="http://habrastorage.org/storage2/d01/55c/9be/d0155c9beefc176a4e345bec93affee1.jpg"><br><br>  The merge function code is quite trivial - we form a new key, re-hang the subtree of node p to node t, delete the node p: <br><br><pre> <code class="hljs erlang-repl">void join(node* t) //   t  t-&gt;link { node* p = t-&gt;link; char* a = new char[t-&gt;len+p-&gt;len]; strncpy(a,t-&gt;key,t-&gt;len); strncpy(a+t-&gt;len,p-&gt;key,p-&gt;len); delete[] t-&gt;key; t-&gt;key = a; t-&gt;len += p-&gt;len; t-&gt;link = p-&gt;link; delete p; }</code> </pre><br>  The senior node is responsible for the merger, because the junior has no information about his parent.  The criteria for a merge is 1) deleting a key by the link link, and not by next;  2) after deletion, the new link has no link next (the child node is only one, which means it can be merged with the current one). <br><br><pre> <code class="hljs perl">node* remove(node* t, char* <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n=<span class="hljs-number"><span class="hljs-number">0</span></span>) //   <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>   t { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !n ) n = strlen(<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !t ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = prefix(<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>,n,t-&gt;key,t-&gt;len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==n ) //   { znode* p = t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==<span class="hljs-number"><span class="hljs-number">0</span></span> ) t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">next</span></span> = remove(t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k==t-&gt;len ) { t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span> = remove(t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>+k, nk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span> &amp;&amp; !t-&gt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">next</span></span> ) //   t   ? <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre><br>  Examples of deleting keys without merging: <br><br><img src="http://habrastorage.org/storage2/c38/440/8fd/c384408fd549efe54b53cd15589d477e.jpg"><br><br>  and merge: <br><br><img src="http://habrastorage.org/storage2/344/300/dc8/344300dc853c7f3f299585f1a314aa3c.jpg"><br><br><h1>  Efficiency </h1><br>  A small numerical study was conducted comparing AVL-trees and prefix trees with respect to operation time and consumed memory.  The results turned out to be somewhat discouraging for me (perhaps the curvature of someone‚Äôs hands might have affected).  But in order ... For testing, 8 test rows were formed.  Their brief characteristics are listed in the table. <br><br><img src="http://habrastorage.org/storage2/1b4/646/8a5/1b46468a5f40bfe46cc5b22b7512bf6c.jpg"><br><br>  First of all, the time of building a tree was measured by a given set of rows and the time it took to search for all the keys from the same set (that is, only a successful search).  The following graph shows a comparison of the construction time of the AVL-tree and the prefix tree.  It can be seen that the prefix tree is built a little faster. <br><br><img src="http://habrastorage.org/storage2/cf9/c3f/dc0/cf9c3fdc05d4c9069b24ce9d838ae82d.jpg"><br><br>  The following graph shows the comparison of time spent searching for all the available keys for the same two trees.  And here everything turned out to be wrong.  A balanced binary tree spends on search about two times less time than a prefix one. <br><br><img src="http://habrastorage.org/storage2/5f3/0f3/a65/5f30f3a6538861155ff3a5e3d0a8053c.jpg"><br><br>  Finally, it was interesting to see what the cost of memory per symbol is.  The results are shown in the following graph. <br><br><img src="http://habrastorage.org/storage2/79f/a67/607/79fa6760740ce695cc1bee8e57297d58.jpg"><br><br>  On average, for both types of trees, about 2 bytes per character are obtained, which in my opinion is not very bad.  Interestingly, in the case of flags, a prefix tree spends less than one byte per character (many common long prefixes). <br><br>  So, a clear winner was not identified as a result.  It would be necessary to make a comparison of the working time of these two trees relative to the number of rows, but judging from the above graphs, nothing revolutionary can be expected anyway.  And, of course, it would be interesting to compare these two campaigns with hash tables ... <br><br>  Thanks for attention! <br><br>  I would be grateful for comments and comments! </div><p>Source: <a href="https://habr.com/ru/post/151421/">https://habr.com/ru/post/151421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151416/index.html">Top 10 Mac OS X Top Tips</a></li>
<li><a href="../151417/index.html">Too much information</a></li>
<li><a href="../151418/index.html">MySQL Query Killer - DBMS Overload Fuse</a></li>
<li><a href="../151419/index.html">Elastic MapReduce. Distributed implementation</a></li>
<li><a href="../151420/index.html">Simple way to protect from classic HTTP DDoS</a></li>
<li><a href="../151422/index.html">Fujifilm stops film production</a></li>
<li><a href="../151423/index.html">Eviterra.com - smart booking form and pleasant things.</a></li>
<li><a href="../151424/index.html">Hybrid "solar" system for producing hydrogen for fuel cells</a></li>
<li><a href="../151425/index.html">What will people say if you give an iPhone 4S and say that it is the 5th</a></li>
<li><a href="../151426/index.html">Review of 7 TechCrunch Disrupt SF 2012 finalists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>