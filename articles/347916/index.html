<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Examine pattern matching in C # 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C # 7, a long-awaited opportunity finally came to be called pattern matching . If you are familiar with functional languages ‚Äã‚Äãsuch as F #, you may...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Examine pattern matching in C # 7</h1><div class="post__text post__text-html js-mediator-article">  In C # 7, a long-awaited opportunity finally came to be called <b>pattern matching</b> .  If you are familiar with functional languages ‚Äã‚Äãsuch as F #, you may be a little disappointed with this feature in its current form, but even today it can simplify your code in a variety of scenarios. <br><br>  Each new opportunity is fraught with danger for a developer working in an application critical for productivity.  New levels of abstractions are good, but in order to use them effectively, you need to know what is going on under the hood.  Today we are going to study the insides of pattern matching in order to understand how this is implemented. <a name="habracut"></a><br>  The C # language introduced the concept of a pattern that can be used in an is-expression and inside a <b>case</b> block of a <b>switch statement</b> . <br><br>  There are 3 types of templates: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Const pattern </li><li>  Type Template </li><li>  Var template </li></ul><br><h4>  Pattern matching in is-expressions </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExpressions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Alternative way checking for null if (o is null) Console.WriteLine("o is null"); // Const pattern can refer to a constant value const double value = double.NaN; if (o is value) Console.WriteLine("o is value"); // Const pattern can use a string literal if (o is "o") Console.WriteLine("o is \"o\""); // Type pattern if (o is int n) Console.WriteLine(n); // Type pattern and compound expressions if (o is string s &amp;&amp; s.Trim() != string.Empty) Console.WriteLine("o is not blank"); }</span></span></code> </pre> <br>  An is-expression can check whether the value is equal to a constant, and a type check can optionally create a <b>pattern variable</b> . <br><br>  I found several interesting aspects related to pattern matching in is-expressions: <br><br><ul><li>  The variable entered in the <b>if statement</b> rises to the outer scope. </li><li>  The variable entered in the <b>if statement is</b> definitely assigned only when the pattern is matched. </li><li>  The current implementation of const pattern matching in is-expressions is not very efficient. </li></ul><br>  We first check the first two cases: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeAndDefiniteAssigning</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"o is not empty string"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Can't use 's' any more. 's' is already declared in the current scope. if (o is int n || (o is string s2 &amp;&amp; int.TryParse(s2, out n))) { Console.WriteLine(n); } }</span></span></code> </pre> <br>  The first <b>if statement</b> introduces the variable <b>s</b> , and the variable is visible within the entire method.  This is reasonable, but it will complicate the logic if other if-statements in the same block try to reuse the same name again.  In this case, you <b>need to</b> use a different name to avoid collisions. <br><br>  The variable entered in the is-expression is fully defined only when the predicate is <b>true</b> .  This means that <b>n</b> in the second <b>if statement is</b> not defined in the right operand, but since this variable is already declared, we can use it as <b>out</b> in the <b>int.TryParse</b> method. <br><br>  The third aspect, mentioned above, is the most important.  Consider the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); }</code> </pre> <br>  In most cases, the is-expression is converted to <b>object.Equals (constValue, variable)</b> (even if the specification says that <b>the == operator</b> should be used for primitive types): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(<span class="hljs-number"><span class="hljs-number">42</span></span>, n)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); } }</code> </pre> <br>  This code causes 2 boxing, which can seriously affect performance if they are used in a critical application path.  Once the expression <b>o is null</b> also caused the package (see <a href="https://github.com/dotnet/roslyn/issues/13247">Suboptimal code for e is null</a> ) and I hope that the current behavior will also be corrected soon (here is the corresponding tick on github). <br><br>  If the <b>n-</b> variable is of type <b>object</b> , then <b>o is 42</b> will result in one memory allocation (for packing a literal <b>42</b> ), although such a code based on a switch does not result in memory allocations. <br><br><h4>  var pattern in is-expressions </h4><br>  Sample <b>var</b> is a special case of a sample type with one key difference: the sample will match any value, even if the value is <b>null</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsVar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"x: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre> <br>  <b>o is object true</b> when <b>o is</b> not <b>null</b> , but <b>o is var x is</b> always <b>true</b> .  The compiler knows this and, in Release (*) mode, completely removes the if construct and simply leaves the call to the console method.  Unfortunately, the compiler does not warn that the code is not reachable in the following case: <br>  <b>if (! (o is var x)) Console.WriteLine ("Unreachable")</b> .  I hope this will be fixed too. <br><br>  (*) It is not clear why the behavior differs only in the Release mode.  But I think that all problems are of the same nature: the initial implementation of the feature is not optimal.  But based on <a href="https://github.com/dotnet/roslyn/issues/22654">this comment by</a> Neil Gafter, this will change: ‚ÄúBad code corresponding to pattern matching is being rewritten from scratch (to support recursive patterns too).  I expect that most of the improvements you‚Äôre looking for here will be ‚Äúfree‚Äù in the new code. ‚Äù <br><br>  The lack of <b>null</b> checking makes this case very special and potentially dangerous.  But if you know exactly what is happening, you may find this matching option useful.  It can be used to insert a temporary variable inside an expression: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VarPattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.FirstOrDefault(o =&gt; o != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n)) { Console.WriteLine(n); } }</code> </pre> <br><h4>  Is-expression and "Elvis" operator </h4><br>  There is another case that I found very useful.  The type pattern matches the value only if the value is not <b>null</b> .  We can use this ‚Äúfiltering‚Äù logic with a <b>null-propagating</b> operator to make the code more readable: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithNullPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s?.FirstOrDefault(str =&gt; str.Length &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>)?.Length <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) { Console.WriteLine(length); } <span class="hljs-comment"><span class="hljs-comment">// Similar to if (s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length is var length2 &amp;&amp; length2 != null) { Console.WriteLine(length2); } // And similar to var length3 = s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length; if (length3 != null) { Console.WriteLine(length3); } }</span></span></code> </pre> <br>  Note that the same template can be used for both value types and reference types. <br><br><h4>  Pattern Matching switch </h4><br>  C # 7 extends the <b>switch statement</b> to use samples in <b>case</b> blocks: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IEnumerable&lt;T&gt; e) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ICollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IReadOnlyCollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-comment"><span class="hljs-comment">// Matches concurrent collections case IProducerConsumerCollection&lt;T&gt; pc: return pc.Count; // Matches if e is not null case IEnumerable&lt;T&gt; _: return e.Count(); // Default case is handled when e is null default: return 0; } }</span></span></code> </pre> <br>  The example shows the first set of changes in the switch statement. <br><br><ol><li>  The <b>switch statement</b> can use any type of variable. </li><li>  The <b>case</b> clause may specify a pattern. </li><li>  The order of sentences in the <b>case</b> is important.  The compiler produces an error if the previous <b>case</b> corresponds to the base type, and the next <b>case</b> corresponds to the derived type. </li><li>  All <b>case</b> blocks contain an implicit <b>null</b> (**) check.  In the previous example, the last <b>case</b> block is correct, since it will only work if the argument is not <b>null</b> . </li></ol><br>  (**) The last <b>case</b> block shows another feature added in C # 7, called the ‚Äú <b>discard</b> ‚Äù pattern.  The <b>_</b> name is special and tells the compiler that the variable is not needed.  A type pattern in a <b>case</b> clause requires a variable name, and if you are not going to use it, you can ignore it with <b>_</b> . <br><br>  The following fragment shows another <b>switch</b> -based pattern matching feature ‚Äî the possibility of using predicates: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s when s.Contains(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>) || s.Contains(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>): Console.WriteLine(s); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: Console.WriteLine(n); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  <b>A switch</b> can have more than one <b>case</b> block with the same type.  In this case, the compiler combines all type checks in one block to avoid redundant computations: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// All cases can match only if the value is not null if (o != null) { if (o is string s &amp;&amp; (s.Contains("Fizz") || s.Contains("Buzz"))) { Console.WriteLine(s); return; } bool isInt = o is int; int num = isInt ? ((int)o) : 0; if (isInt) { // The type check and unboxing happens only once per group if (num % 5 == 0 &amp;&amp; num % 3 == 0) { Console.WriteLine("FizzBuzz"); return; } if (num % 5 == 0) { Console.WriteLine("Fizz"); return; } if (num % 3 == 0) { Console.WriteLine("Buzz"); return; } Console.WriteLine(num); } } }</span></span></code> </pre> <br>  But you need to keep in mind two things: <br><br><ol><li>  The compiler combines only consecutive <b>case</b> blocks with the same type, and if you mix blocks for different types, the compiler will generate less optimal code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-comment"><span class="hljs-comment">// The generated code is less optimal: // If o is int, then more than one type check and unboxing operation // may happen. case int n when n == 1: return 1; case string s when s == "": return 2; case int n when n == 2: return 3; default: return -1; }</span></span></code> </pre> <br>  The compiler converts it like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n &amp;&amp; n == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s == <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 &amp;&amp; n2 == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br></li><li>  The compiler is doing everything possible to prevent typical problems with the wrong order of <b>case</b> blocks. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Error: The switch case has already been handled by a previous case. case int n when n == 1: return 2; }</span></span></code> </pre> <br>  But the compiler does not know that one predicate is stronger than another and, in fact, makes the following blocks unreachable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Will never match, but the compiler won't warn you about it case int n when n &gt; 1: return 2; }</span></span></code> </pre> </li></ol><br><h4>  Pattern Matching 101 </h4><br><ul><li>  The following patterns were entered into C # 7: const pattern, type pattern, var pattern, and <b>discard</b> pattern. </li><li>  Samples can be used in is-expressions and in <b>case</b> blocks. </li><li>  The implementation of the const pattern in is-expressions for value types is far from perfect in terms of performance. </li><li>  The var sample matches any value, and you should be careful with it. </li><li>  The <b>switch statement</b> can be used for a set of type checks with additional predicates in <b>when</b> clauses. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/347916/">https://habr.com/ru/post/347916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347906/index.html">7 sins when working with requirements in the pre-project</a></li>
<li><a href="../347908/index.html">CQRS. Facts and Fallacies</a></li>
<li><a href="../347910/index.html">[BugBounty] Disclosing 5 million links to private Telegram chats and the ability to edit any article telegra.ph</a></li>
<li><a href="../347912/index.html">The most harmful advice. How to implement</a></li>
<li><a href="../347914/index.html">Technical duty and its habitat</a></li>
<li><a href="../347918/index.html">Animations in Android on the shelves (Part 1. Basic animations)</a></li>
<li><a href="../347920/index.html">Mobile devices from the inside. Changing the tablet memory layout</a></li>
<li><a href="../347922/index.html">What really happened to Vista: an insider retrospective</a></li>
<li><a href="../347924/index.html">Experience of two attempts at putting JNCIE-SP</a></li>
<li><a href="../347926/index.html">Flask Mega-Tutorial, Part IX: Pagination (Edition 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>