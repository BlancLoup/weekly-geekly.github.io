<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GDB was a tough nut to crack.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GDB is a hard tool to do without. Of course, as Brooks says, ‚ÄúThe quality of software product development is achieved through proper design, not endle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GDB was a tough nut to crack.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/63a/aba/68a/63aaba68a9acbeeb10abead3da826399.png" alt="Gdb" align="left">  GDB is a hard tool to do without.  Of course, as Brooks says, ‚ÄúThe quality of software product development is achieved through proper design, not endless testing.‚Äù  However, proper design does not protect against logical errors, typos, null pointers, and so on.  And this is where code debugging tools like GDB help us.  My goal is to show that not less useful tools are static code analyzers, which reveal many errors at the very early stages.  It is much better if the error is corrected in the code, even before the testing and debugging phase.  To demonstrate the benefits of static code analysis, we will look for errors inside GDB using the PVS-Studio analyzer. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  After a recent good <a href="http://www.viva64.com/ru/b/0425/">article</a> reviewing the GCC, I decided to write an article about GDB as well.  This time, writing the article went harder.  Apparently affects the size of the projects.  However, it is difficult for me to compare the size of the source code.  In both projects, there are files containing large data tables.  They make a significant contribution to the size of the code and the number of lines of code.  For example, in the GDB project, there is an i386-tbl.h file of 5 megabytes in size and containing a table of the following form: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/130/6c8/52b/1306c852bd575a080df3501401522e77.png" alt="gdb array"></div><p></p><br>  I think that the present code in the GCC project is several times larger than the size of the GDB code.  While checking GCC, I easily managed to collect enough errors for an article by skimming through the report and without going into suspicious but difficult to understand third-party code fragments.  In the case of GDB, I had to look more carefully and still I was able to find few suspicious places. <br><br><h2>  Check </h2><br>  The source code for <a href="https://www.gnu.org/software/gdb/">GDB</a> version 7.11.1 has been verified.  The code was verified by the PVS-Studio version working under Linux. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Quick reference.</b>  <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> is a commercial static analyzer that detects errors in source code written in C, C ++, C #.  Works in Linux and Windows environment. <br><br>  In order to test GDB with the help of the PVS-Studio static analyzer, you need to perform a few simple steps: <br><br>  0) Read the documentation: " <a href="http://www.viva64.com/ru/d/0519/">How to run PVS-Studio in Linux</a> ."  I chose a way to quickly test a project without integrating the analyzer into the build system. <br><br>  1) Download the latest version of the source code from the official repository: <br><br><pre><code class="hljs ruby">$ git clone <span class="hljs-symbol"><span class="hljs-symbol">git:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/sourceware.org/git</span></span><span class="hljs-regexp"><span class="hljs-regexp">/binutils-gdb.git</span></span></code> </pre> <br>  2) Modify the PVS-Studio.cfg configuration file, namely the output-file and sourcetree-root parameters.  In my case: <br><br><pre> <code class="hljs ruby">exclude-path = <span class="hljs-regexp"><span class="hljs-regexp">/usr/include</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ exclude-path = /usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/lib64/</span></span> lic-file = <span class="hljs-regexp"><span class="hljs-regexp">/home/andr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PVS-Studio.lic output-file = /home</span></span><span class="hljs-regexp"><span class="hljs-regexp">/andr/gdb</span></span>.log sourcetree-root = <span class="hljs-regexp"><span class="hljs-regexp">/home/andr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/binutils-gdb</span></span></code> </pre> <br>  3) Go to the downloaded directory: <br><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> binutils-gdb</code> </pre> <br>  4) Create a Makefile: <br><br><pre> <code class="hljs ruby">$ ./configure</code> </pre> <br>  5) Start the gdb assembly and the PVS-Studio analyzer: <br><br><pre> <code class="hljs pgsql">$ pvs-studio-analyzer trace <span class="hljs-comment"><span class="hljs-comment">-- make -j3</span></span></code> </pre> <br>  6) Run the analysis (specify the path to the PVS-Studio.cfg configuration file): <br><br><pre> <code class="hljs pgsql">$ pvs-studio-analyzer <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-comment"><span class="hljs-comment">--cfg /home/andr/PVS-Studio.cfg</span></span></code> </pre> <br>  After successful completion of the analysis, a log file gdb.log will appear in the home directory, which can be viewed in Windows using the PVS-Studio Standalone utility.  This is exactly what I did, since it is more familiar to me. <br><br>  If you want to study the report in Linux, then the converter utility (plog-converter), whose source code is included in the PVS-Studio distribution kit, will help you.  The utility can convert <i>* .plog</i> files to various formats (see the <a href="http://www.viva64.com/ru/d/0519/">documentation</a> ).  You can also independently adapt the converter to your needs. <br><br>  <b>IMPORTANT.</b>  Do not try to watch <i>* .log</i> directly by opening it in some kind of text editor.  It will be terrible.  This file contains a lot of redundant and duplicate information.  And that's why these files are so big.  For example, if some kind of warning relates to an h-file, you will see it in the file as many times as this h-file is included in cpp-files.  When you use PVS-Studio Standalone or plog-converter, these tools automatically remove such duplicates. <br><br>  Suppose it is convenient for you to view a report in Qt Creator, after converting the <i>* .log</i> file to the <a href="http://doc.qt.io/qtcreator/creator-task-lists.html">Qt Task List File</a> format.  Then we should use the plog-converter utility as follows: <br><br><pre> <code class="hljs pgsql">$ plog-converter -t tasklist -o /home/andr/gdb.tasks -r /home/andr/binutils-gdb/ -a GA:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> /home/andr/gdb.<span class="hljs-keyword"><span class="hljs-keyword">log</span></span></code> </pre> <br>  Although for a start it would be better to use <i>GA: 1.2</i> .  Not the best idea to start dating with the analyzer, including all three levels of warnings. <br><br>  After executing this command, the report file <i>gdb.tasks</i> will appear in the home directory, which can be viewed with Qt Creator: <br><br><p></p><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7b0/67b/ff2/7b067bff2f73b871e7d1b0bac4d52504.png" alt="Qt Creator and PVS-Studio log"></a> </div><p></p><br><br>  View plog-converter options: <br><br><pre> <code class="cpp hljs">$ plog-converter --help</code> </pre> <br><h2>  Test results </h2><br>  As I said, this time I was able to find few errors demonstrating the capabilities of the PVS-Studio analyzer.  The reason I think lies in the high quality of the source code of the GDB project and the fact that it is well tested by a huge number of users who are programmers themselves, and therefore more attentive and demanding than the average users of programs. <br><br>  We'll see what interesting I could find.  Let's start with an error in the comparison function.  I highlight this bug in a new error pattern.  I encounter similar errors in a large number of projects and soon plan to write a new article on this topic, which will be in the spirit of ‚Äú <a href="http://www.viva64.com/ru/b/0260/">Last line effect</a> ‚Äù. <br><br>  <b>Incorrect comparison function</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">psymbol_compare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sym1</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr1</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sym2</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr2</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span> (&amp;sym1-&gt;ginfo.value, &amp;sym1-&gt;ginfo.value, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (sym1-&gt;ginfo.value)) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sym1-&gt;ginfo.language == sym2-&gt;ginfo.language &amp;&amp; PSYMBOL_DOMAIN (sym1) == PSYMBOL_DOMAIN (sym2) &amp;&amp; PSYMBOL_CLASS (sym1) == PSYMBOL_CLASS (sym2) &amp;&amp; sym1-&gt;ginfo.name == sym2-&gt;ginfo.name); }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0139/">warning</a> : <a href="http://www.viva64.com/ru/d/0139/">V549</a> The first argument of the memcmp function is equal to the second argument.  psymtab.c 1580 <br><br>  The first and second arguments of the <i>memcmp ()</i> function <i>are the</i> same.  Obviously here they wanted to write: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span> (&amp;sym1-&gt;ginfo.value, &amp;sym2-&gt;ginfo.value, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (sym1-&gt;ginfo.value))</code> </pre> <br>  <b>Wrong code that works correctly.</b> <br><br>  Static code analyzers work with the source code of the program and can find places where, from the point of view of a person, a mistake is made.  What is interesting, despite the error, this code, thanks to luck, can work perfectly correctly.  Let's look at one of these interesting cases. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct event_location * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_to_explicit_location</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argp, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* It is assumed that input beginning with '-' and a non-digit character is an explicit location. "-p" is reserved, though, for probe locations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span> || !<span class="hljs-built_in"><span class="hljs-built_in">isalpha</span></span> ((*argp)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) || ((*argp)[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span> &amp;&amp; (*argp)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'p'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0117/">warning</a> : <a href="http://www.viva64.com/ru/d/0117/">V528</a> It is odd that the pointer to the 'char' type is compared with the '\ 0' value.  Probably meant: ** argp == '\ 0'.  location.c 527 <br><br>  We are interested in the following code: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argp .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span></code> </pre> <br>  The literal <i>'\ 0'</i> is a <a href="http://www.viva64.com/ru/t/0088/">terminal zero</a> , which is used when you want to check the empty string or not.  To do this, check the first element of the buffer containing the string, and if there is a terminal zero, then the string is considered empty.  This is exactly what the programmer wanted to do here.  But he did not take into account that the variable <i>argp</i> is not a pointer to characters, but a pointer to a pointer. <br><br>  Therefore, the correct check should look like this: <br><br><pre> <code class="cpp hljs">*argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\0'</span></span></code> </pre> <br>  Or so: <br><br><pre> <code class="cpp hljs">**argp == <span class="hljs-string"><span class="hljs-string">'\0'</span></span></code> </pre> <br>  However, if we write this code <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span></code> </pre> <br>  then it is dangerous.  We need to add one more check to the null pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span></code> </pre> <br>  Now the code is correct.  But note that it is redundant.  If the first character is not a dash '-', then it does not matter what character it is.  Anyway, the terminal is there zero or any other character.  Therefore, we can simplify the code as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span></code> </pre> <br>  Please note that this correct code is equivalent to the code that was originally: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *argp == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || *argp[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'-'</span></span></code> </pre> <br>  The difference is in how 0 is written. In the first case, it is <i>NULL</i> .  In the second, this is <i>'\ 0'</i> .  In essence, this is the same thing and the code behaves in the same way. <br><br>  Funny.  Despite the fact that the code was written incorrectly, it works absolutely correctly. <br><br>  <b>Wrong buffer size calculation</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_memory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CORE_ADDR memaddr, gdb_byte *myaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ssize_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">java_value_print</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... gdb_byte *buf; buf = ((gdb_byte *) alloca (gdbarch_ptr_bit (gdbarch) / HOST_CHAR_BIT)); .... read_memory (address, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (buf)); .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0181/">warning</a> : <a href="http://www.viva64.com/ru/d/0181/">V579</a>  It is possibly a mistake.  Inspect the third argument.  jv-valprint.c 111 <br><br>  This error most likely arose in the process of refactoring.  I would venture to suggest that at some point the code was approximately as follows: <br><br><pre> <code class="cpp hljs">gdb_byte buf[gdbarch_ptr_bit (gdbarch) / HOST_CHAR_BIT)]; .... read_memory (address, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (buf));</code> </pre> <br>  Then the <i>sizeof ()</i> operator calculated the buffer size correctly.  Then, they began to allocate memory for the buffer using the <i>alloca ()</i> function.  As a result, the <i>sizeof (buf)</i> operator does not calculate the size of the buffer, but the size of the pointer. <br><br>  I think the correct code should be: <br><br><pre> <code class="cpp hljs">gdb_byte *buf; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = gdbarch_ptr_bit (gdbarch) / HOST_CHAR_BIT; buf = ((gdb_byte *) alloca (size)); .... read_memory (address, buf, size);</code> </pre> <br>  But this is not the end, the most interesting is waiting for us next.  I just decided to start to explain the essence of the error and how it could arise.  Everything becomes more interesting if you show a few more lines below: <br><br><pre> <code class="cpp hljs">read_memory (address, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (buf)); address += gdbarch_ptr_bit (gdbarch) / HOST_CHAR_BIT; <span class="hljs-comment"><span class="hljs-comment">/* </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">FIXME:</span></span></span><span class="hljs-comment"> cagney/2003-05-24: Bogus or what. It pulls a host sized pointer out of the target and then extracts that as an address (while assuming that the address is unsigned)! */</span></span> element = extract_unsigned_integer (buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (buf), byte_order);</code> </pre> <br>  As you can see, I am not the first to notice that something is wrong with this code.  The error lives in this code at least since 2003.  It is not clear why it is still not corrected. <br><br>  As I understand, this comment relates to the line: <br><br><pre> <code class="cpp hljs">element = extract_unsigned_integer (buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (buf), byte_order);</code> </pre> <br>  When calling the <i>extract_unsigned_integer ()</i> function, the same error was made that was considered by me above. <br><br>  The PVS-Studio analyzer also gives a warning message on this line: V579  It is possibly a mistake.  Inspect the second argument.  jv-valprint.c 117 <br><br>  The analyzer generates two more warnings for the <i>java_value_print ()</i> function code: <br><br><ul><li>  <i>V579</i>  <i>It is possibly a mistake.</i>  <i>Inspect the third argument.</i>  <i>jv-valprint.c 123</i> </li><li>  <i>It is a V579 version.</i>  <i>It is possibly a mistake.</i>  <i>Inspect the second argument.</i>  <i>jv-valprint.c 129</i> </li></ul><br>  <b>Double assignment</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FILE * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate_source</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Source_File *sf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max_width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*annote) (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ .... bfd_boolean new_line; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nread; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_line) { (*annote) (annotation, max_width, line_num, arg); <span class="hljs-built_in"><span class="hljs-built_in">fputs</span></span> (annotation, ofp); ++line_num; new_line = FALSE; } new_line = (buf[i] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); fputc (buf[i], ofp); } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0108/">warning</a> : <a href="http://www.viva64.com/ru/d/0108/">V519</a> The 'new_line' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 253, 256. source.c 256 <br><br>  Line <i>new_line = FALSE;</i>  does not make sense.  Immediately after this, the value of the variable <i>new_line is overwritten by</i> another value.  Those.  The following code snippet is extremely suspicious: <br><br><pre> <code class="cpp hljs"> new_line = FALSE; } new_line = (buf[i] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>);</code> </pre> <br>  Apparently there is some kind of logical error.  Or the first assignment is just unnecessary and can be deleted. <br><br>  <b>Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_tracepoint_bkpts</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct thread_info *tinfo, CORE_ADDR stop_pc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ipa_trace_buffer_is_full; CORE_ADDR ipa_stopping_tracepoint; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ipa_expr_eval_result; CORE_ADDR ipa_error_tracepoint; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_trace_buffer_is_full) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to full buffer."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_stopping_tracepoint) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to tpoint"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_stopping_tracepoint) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to error"</span></span>); .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0183/">warning</a> : <a href="http://www.viva64.com/ru/d/0183/">V581</a> The conditional expressions of the 'if' are agreed alongside each other are identical.  Check lines: 4535, 4537. tracepoint.c 4537 <br><br>  If the variable <i>ipa_stopping_tracepoint</i> is TRUE, two debug messages will be printed: <br><br><pre> <code class="cpp hljs">lib stopped due to tpoint lib stopped due to error</code> </pre> <br>  I am not familiar with how the code works, but it seems to me that in the latter case the condition should not use the <i>ipa_stopping_tracepoint</i> variable, but the <i>ipa_error_tracepoint</i> variable.  Then the code will be like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_trace_buffer_is_full) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to full buffer."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_stopping_tracepoint) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to tpoint"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipa_error_tracepoint) trace_debug (<span class="hljs-string"><span class="hljs-string">"lib stopped due to error"</span></span>);</code> </pre> <br>  <b>Break operator forgotten</b> <br><br>  The classic mistake.  In one place inside the <i>switch,</i> the <i>break</i> <i>statement is</i> forgotten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> debug_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stab_xcoff_builtin_type</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dhandle, struct stab_handle *info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typenum)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (-typenum) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: name = <span class="hljs-string"><span class="hljs-string">"unsigned int"</span></span>; rettype = debug_make_int_type (dhandle, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: name = <span class="hljs-string"><span class="hljs-string">"unsigned"</span></span>; rettype = debug_make_int_type (dhandle, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: name = <span class="hljs-string"><span class="hljs-string">"unsigned long"</span></span>; rettype = debug_make_int_type (dhandle, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  PVS-Studio warning: V519 The 'name' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 3433, 3436. stabs.c 3436 <br><br>  Regardless of whether we are working with the type "unsigned" or "unsigned long", we will give the type the name "unsigned long". <br><br>  Correct code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: name = <span class="hljs-string"><span class="hljs-string">"unsigned"</span></span>; rettype = debug_make_int_type (dhandle, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  <b>Tangled case</b> <br><br>  In the code shown below, the <i>alt</i> variable is twice assigned a value, since there is no <i>break</i> between two <i>cases</i> .  But according to the comment, the programmer does not specifically use <i>break</i> .  Consider incomprehensible to me code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *in_template, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeflag)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> alt = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*p) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'{'</span></span>: alt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intel_syntax) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*++p != <span class="hljs-string"><span class="hljs-string">'|'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*p == <span class="hljs-string"><span class="hljs-string">'}'</span></span> || *p == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span> (); } <span class="hljs-comment"><span class="hljs-comment">/* Fall through. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'I'</span></span>: alt = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } }</code> </pre> <br>  PVS-Studio warning: V519 The 'alt' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 14098, 14107. i386-dis.c 14107 <br><br>  So, comment <i>/ * Fall through.</i>  <i>* /</i> says that the <i>break</i> statement is not needed here.  But then it is not clear why the <i>alt</i> variable is assigned the value 0. Anyway, then the value of the variable will be replaced by one.  And between these two assignments, the <i>alt</i> variable is not used at all.  Unclear‚Ä¶ <br><br>  Here either a logical error, or the first assignment should be deleted. <br><br><h2>  Conclusion </h2><br>  Long live PVS-Studio for Linux!  As you can see, now I can show the benefits of static analysis not only for open Windows projects, but also to help the Linux open source community.  I think that soon our <a href="http://www.viva64.com/ru/inspections/">list of articles</a> on proven projects will be replenished with a large number of articles about programs from the Linux world. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a2/f22/531/6a2f225318e1883d3c9afbad1ae395a9.png" alt="PVS-Studio for Linux"></div><p></p><br>  In order not to miss anything interesting I invite you to subscribe to my twitter <a href="https://twitter.com/Code_Analysis">@Code_Analysis</a> . <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0430/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey karpov.  <a href="http://www.viva64.com/en/b/0430/">Only a few bugs found by PVS-Studio</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/310156/">https://habr.com/ru/post/310156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310144/index.html">We raise Owncloud from scratch with dynamic IP and Let's Encrypt. A thousand elephants! *</a></li>
<li><a href="../310146/index.html">Chained together, or add comfort comments Vkontakte</a></li>
<li><a href="../310148/index.html">CUBA Platform: Java RAD open source framework</a></li>
<li><a href="../310150/index.html">4C: Kyiv - Video Game Developers Conference</a></li>
<li><a href="../310152/index.html">.Net Core, WCF and ODATA clients</a></li>
<li><a href="../310158/index.html">Duty of knowledge</a></li>
<li><a href="../310160/index.html">Installing Quartus II on CentOS</a></li>
<li><a href="../310162/index.html">Progrobot: programming language help bot</a></li>
<li><a href="../310164/index.html">Linux debugging tools</a></li>
<li><a href="../310166/index.html">Modern web development for schoolchildren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>