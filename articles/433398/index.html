<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional thinking. Part 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue our series of articles on functional F # programming. Today we have a very interesting topic: the definition of functions. Including, let'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional thinking. Part 7</h1><div class="post__text post__text-html js-mediator-article"><p>  We continue our series of articles on functional F # programming.  Today we have a very interesting topic: the definition of functions.  Including, let's talk about anonymous functions, functions without parameters, recursive functions, combinators and much more.  Look under the cat! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://habr.com/company/microsoft/blog/415189/">First part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/420039/">The second part of</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/422115/">The third part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/430620/">Fourth part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/430622/">Fifth part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/413195/">Sixth part</a></strong> <a name="habracut"></a></li></ul><br><h1>  Definition of functions </h1><br><p>  We already know how to create ordinary functions using the "let" syntax: </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  In this article we will look at some other ways to create functions, as well as tips on how to define them. </p><br><h2>  Anonymous functions (lambda) </h2><br><p>  If you are familiar with lambdas in other languages, the following paragraphs will seem familiar.  Anonymous functions (or "lambda expressions") are defined as follows: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Compared to C # lambdas, there are two differences: </p><br><ul><li>  lambdas must begin with the <code>fun</code> keyword, which is not required in C # </li><li>  Single arrow <code>-&gt;</code> is used instead of double <code>=&gt;</code> from C #. </li></ul><br><p>  Lambda-definition of the addition function: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  The same function in the traditional form: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas are often used in the form of small expressions or when there is no desire to define a separate function for the expression.  As you have seen, this is not uncommon when working with lists. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Note that you need to use brackets around lambdas. </p><br><p>  Also lambdas are used when obviously another function is needed.  For example, the previously discussed " <code>adderGenerator</code> ", which we <a href="https://habr.com/company/microsoft/blog/422115/">discussed earlier,</a> can be rewritten using lambda. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  The lambda version is slightly longer, but immediately makes it clear that an intermediate function will be returned. </p><br><p>  Lambda can be nested.  Another example of the definition of <code>adderGenerator</code> , this time only in lambda. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Is it clear to you that all three definitions are equivalent? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  If not, reread <a href="https://habr.com/company/microsoft/blog/430620/">the currying chapter</a> .  This is very important to understand! </p><br><h2>  Pattern matching with pattern </h2><br><p>  When a function is defined, parameters can be passed to it explicitly, as in the examples above, but it can also be mapped to a template directly in the parameters section.  In other words, the parameters section may contain patterns (matching patterns), and not just identifiers! </p><br><p>  The following example demonstrates the use of templates in a function definition: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  This type of matching can occur only when a match is always solvable.  For example, it is impossible to match types of association and lists in this way, because some cases cannot be compared. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  The compiler will give a warning about the incompleteness of the match (an empty list will cause an error in runtime at the entrance to this function). </p><br><h2>  Common error: tuples vs.  many parameters </h2><br><p>  If you come from a C-like language, the tuple used as the only function argument can painfully resemble a multi-parameter function.  But this is not the same thing!  As I noted earlier, if you see a comma, this is most likely a tuple.  Parameters are separated by spaces. </p><br><p>  An example of confusion: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  The first definition, " <code>addTwoParams</code> ", takes two parameters, separated by a space. </li><li>  The second definition, " <code>addTuple</code> ", takes one parameter.  This parameter binds the "x" and "y" from the tuple and summarizes them. </li><li>  The third definition, " <code>addConfusingTuple</code> ", takes one parameter as well as " <code>addTuple</code> ", but the trick is that this tuple is unpacked (matched with the pattern) and bound as part of the parameter definition using pattern matching.  Behind the scenes, everything is exactly the same as in <code>addTuple</code> . </li></ul><br><p>  Look at the signatures (always look at them if you are not sure about something). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  And now here: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Here we see an error in the second call. </p><br><p>  First, the compiler treats <code>(1,2)</code> as a generalized tuple of the form <code>('a * 'b)</code> , which it tries to pass as the first parameter to " <code>addTwoParams</code> ".  After that, it complains that the expected first parameter <code>addTwoParams</code> not an <code>int</code> , but an attempt was made to transfer a tuple. </p><br><p>  To make a tuple, use a comma! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  And vice versa, if you pass several arguments to a function waiting tuple, you also get an incomprehensible error. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  This time, the compiler decided that once two arguments were <code>addConfusingTuple</code> , <code>addConfusingTuple</code> should be curried.  And the " <code>addConfusingTuple 1</code> " entry is a partial application and should return an intermediate function.  An attempt to call this intermediate function with the parameter "2" will generate an error, because  There is no intermediate function!  We see the same error as in the currying chapter, where we discussed problems with too many parameters. </p><br><h3>  Why not use tuples as parameters? </h3><br><p>  The discussion of tuples above shows another way to define functions with multiple parameters: instead of transferring them separately, all parameters can be gathered into one structure.  In the example below, the function takes a single parameter ‚Äî a tuple of three elements. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Note that the signature is different from the signature of a function with three parameters.  There is only one arrow, one parameter and asterisks pointing to the tuple <code>(int*int*int)</code> . </p><br><p>  When do I need to submit arguments with separate parameters, and when with a tuple? </p><br><ul><li>  When tuples are significant in their own right.  For example, for operations in three-dimensional space, triple tuples will be more convenient than three coordinates separately. </li><li>  Sometimes tuples are used to combine data that must be stored together into a single structure.  For example, the <code>TryParse</code> methods from the .NET library return the result and a boolean variable in the form of a tuple.  But for storing a large amount of related data it is better to define a class or record ( <a href="https://habr.com/company/microsoft/blog/422115/">record</a> . </li></ul><br><h3>  Special case: tuples and functions of the .NET library </h3><br><p>  When calling .NET libraries, commas are very common! </p><br><p>  They all take tuples, and the calls look the same as in C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  The reason lies in the fact that classic .NET functions are not curried and cannot be partially applied.  <em>All</em> parameters must <em>always</em> be transmitted immediately, and the most obvious way is to use a tuple. </p><br><p>  Note that these calls only look like the transfer of tuples, but in fact this is a special case.  You cannot transfer real tuples to such functions: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  If there is a desire to partially apply the .NET functions, it is enough to write wrappers over them, as was done <a href="https://habr.com/company/microsoft/blog/430622/">earlier</a> , or as shown below: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Selection Guide for Individual and Grouped Parameters </h2><br><p>  Discussion of tuples leads to a more general topic: when parameters should be separate, and when grouped? </p><br><p>  Attention should be paid to how F # differs from C # in this respect.  In C #, <em>all</em> parameters are <em>always</em> transferred, so this question does not even arise there!  In F #, due to partial application, only some of the parameters can be represented, so it is necessary to distinguish between the case when the parameters should be combined and the case when they are independent. </p><br><p>  General recommendations on how to structure the parameters when designing your own functions. </p><br><ul><li>  In general, it is always better to use separate parameters instead of passing one structure, be it a tuple or a record.  This allows for more flexible behavior, such as partial application. </li><li>  But, when a group of parameters has <em>to</em> be transferred at once, some grouping mechanism should be used. </li></ul><br><p>  In other words, when developing a function, ask yourself "Can I provide this option separately?".  If the answer is no, then the parameters should be grouped. </p><br><p>  Consider a few examples: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Finally, make sure that the order of the parameters helps in partial application (see the manual <a href="https://habr.com/company/microsoft/blog/430622/">here</a> ).  For example, why did I put <code>myCredentials</code> before <code>aName</code> in the last function? </p><br><h2>  Functions without parameters </h2><br><p>  Sometimes you may need a function that does not accept any parameters.  For example, you need the function "hello world" which can be called multiple times.  As shown in the previous section, the naive definition does not work. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  But this can be corrected by adding the unit parameter to the function or using lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  After that, the function must always be called with the <code>unit</code> argument: </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  What happens quite often when interacting with .NET libraries: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Remember, call them with <code>unit</code> parameters! </p><br><h2>  Definition of new operators </h2><br><p>  You can define functions using one or more operator symbols (see the <a href="http://msdn.microsoft.com/en-us/library/dd233204">documentation</a> for a list of symbols): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  You must use brackets around the characters to define a function. </p><br><p>  Operators starting with <code>*</code> require a space between the bracket and <code>*</code> , since  in F # <code>(*</code> plays the role of the beginning of a comment (like / <code>/*...*/</code> in C #) </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Once defined, a new function can be used in the usual way if it is wrapped in parentheses: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  If the function is used with two parameters, you can use the infix operator record without brackets. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  You can also define prefix operators starting with <code>!</code>  or <code>~</code> (with some restrictions, see the <a href="http://msdn.microsoft.com/en-us/library/dd233204">documentation</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  In F #, the definition of operators is quite a frequent operation, and many libraries will export operators with names like <code>&gt;=&gt;</code> and <code>&lt;*&gt;</code> . </p><br><h2>  Point-free style </h2><br><p>  We have already seen many examples of functions that lacked the latest parameters in order to reduce the level of chaos.  This style is called <strong>point-free style</strong> or <strong>silent programming (tacit programming)</strong> . </p><br><p>  Here are some examples: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  This style has its pros and cons. </p><br><p>  One of the advantages is that the emphasis is on the composition of higher-order functions instead of fussing with low-level objects.  For example, " <code>(+) 1 &gt;&gt; (*) 2</code> " is an explicit addition followed by multiplication.  And " <code>List.reduce (+)</code> " makes it clear that the addition operation is important, irrespective of the information about the list. </p><br><p>  Pointless style allows you to focus on the basic algorithm and to identify common features in the code.  The " <code>reduce</code> " function used above is a good example.  This topic will be discussed in a scheduled list processing series. </p><br><p>  On the other hand, excessive use of this style can make the code obscure.  Explicit parameters act as documentation and their names (such as "list") make it easier to understand what the function does. </p><br><p>  Like everything in programming, the best recommendation is to prefer the approach that provides the most clarity. </p><br><h2>  Combinators </h2><br><p>  " <strong>Combinators</strong> " call functions whose result depends only on their parameters.  This means that there is no dependence on the outside world, and, in particular, no other functions or global values ‚Äã‚Äãcan affect them. </p><br><p>  In practice, this means that combinatorial functions are limited by the combination of their parameters in various ways. </p><br><p>  We have already seen several combinators: the "pipe" (pipeline) and the composition operator.  If you look at their definitions, it is clear that all they do is reorder the parameters in various ways. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  On the other hand, functions like "printf", although primitive, are not combinators, because they are dependent on the external world (I / O). </p><br><h3>  Combinatorial birds </h3><br><p>  Combinators are the basis of a whole section of logic (naturally called "combinatorial logic"), which was invented many years before computers and programming languages.  Combinatorial logic has a very large influence on functional programming. </p><br><p>  To learn more about combinators and combinatorial logic, I recommend the book "To Mock a Mockingbird" by Raymond Smullyan.  In it, he explains other combinators and fancifully gives them the <a href="">names of birds</a> .  Here are a few examples of standard combinators and their bird names: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Letter names are quite standard, so you can refer to the K-combinator to anyone who is familiar with this terminology. </p><br><p>  It turns out that many common programming patterns can be represented through these standard combinators.  For example, Kestrel is a regular pattern in the fluent interface where you do something, but return the original object.  Thrush is a pipe, Queer is a direct composition, and the Y-combinator does an excellent job with creating recursive functions. </p><br><p>  In fact, there is a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0%3Foldformat%3Dtrue">well-known theorem</a> that any computable function can be constructed using only two basic combinators, Kestrel and Starling. </p><br><h3>  Combinator Libraries </h3><br><p>  Combinator libraries are libraries that export a multitude of combinatorial functions that are designed to be shared.  The user of such a library can easily combine functions together to get even larger and more complex functions, like cubes easily. </p><br><p>  A well-designed combinator library allows you to focus on high-level features and hide low-level ‚Äúnoise‚Äù.  We have already seen their power in several examples in the "why use F #" series, and the <code>List</code> module is full of such functions, " <code>fold</code> " and " <code>map</code> " are also combinators, if you think about it. </p><br><p>  Another advantage of combinators is that they are the safest type of function.  Since  they do not have dependencies on the outside world; they cannot change when the global environment changes.  A function that reads a global value or uses library functions may break or change between calls if the context changes.  This will never happen to combinators. </p><br><p>  In F #, combinator libraries are available for parsing (FParsec), creating HTML, testing frameworks, etc.  We will discuss and use the combinators later in the next series. </p><br><h2>  Recursive functions </h2><br><p>  Often a function needs to refer to itself from its body.  A classic example is the Fibonacci function. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Unfortunately, this function will not be able to compile: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  You must tell the compiler that this is a recursive function using the keyword <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Recursive functions and data structures are very common in functional programming, and I hope to devote a whole series to this topic later. </p><br><h1>  Additional resources </h1><br><p>  For F #, there are many tutorials, including materials for those who come with C # or Java experience.  The following links may be helpful as you learn more about F #: </p><br><ul><li>  <a href="https://docs.microsoft.com/en-US/dotnet/fsharp/">F # Guide</a> </li><li>  <a href="https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/">F # for Fun and Profit</a> </li><li>  <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">F # Wiki</a> </li><li>  <a href="https://learnxinyminutes.com/docs/fsharp/">Learn X in Y Minutes: F #</a> </li></ul><br><p>  Several other ways <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/">to get started with learning F # are</a> also described. </p><br><p>  Finally, the F # community is very friendly to beginners.  There is a very active Slack chat, supported by the F # Software Foundation, with rooms for beginners that you <a href="http://foundation.fsharp.org/join">can freely join</a> .  We strongly recommend that you do this! </p><br><p>  Do not forget to visit the site of the <a href="http://fsharplang.ru/">Russian-speaking community F #</a> !  If you have any questions about learning the language, we will be happy to discuss them in chat rooms: </p><br><ul><li>  Room <code>#ru_general</code> in <a href="http://foundation.fsharp.org/join">Slack chat F # Software Foundation</a> </li><li>  <a href="https://t.me/Fsharp_chat">chat in Telegram</a> </li><li>  <a href="http://gitter.im/fsharplang_ru">chat in gitter</a> </li><li>  Room #ru_general in <a href="http://foundation.fsharp.org/join">Slack chat F # Software Foundation</a> </li></ul><br><h2>  About authors of translation </h2><br><p>  Translated by <a href="https://habrahabr.ru/users/kleidemos/"><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Translation and editorial changes are made by the efforts of the <a href="http://fsharplang.ru/">Russian-speaking community of F # -developers</a> .  We also thank <a href="https://habrahabr.ru/users/schvepsss/"><em>@schvepsss</em></a> and <a href="https://habr.com/users/shwars/"><em>@shwars</em></a> for preparing this article for publication. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433398/">https://habr.com/ru/post/433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433386/index.html">How using computer vision to assess the condition of the car. Experience Yandex.Taxi</a></li>
<li><a href="../433388/index.html">Fun formula or why we play games</a></li>
<li><a href="../433390/index.html">Yandex has joined the protection of Linux and the IT-industry from patent trolling</a></li>
<li><a href="../433392/index.html">Snom D725 IP Phone Review</a></li>
<li><a href="../433396/index.html">Frontend 2018: Results of the Year</a></li>
<li><a href="../433400/index.html">React Tutorial, Part 2: Functional Components</a></li>
<li><a href="../433402/index.html">Functional thinking. Part 8</a></li>
<li><a href="../433404/index.html">React Tutorial, Part 3: Component Files, Project Structure</a></li>
<li><a href="../433408/index.html">Efficient memory management in Node.js</a></li>
<li><a href="../433414/index.html">PRTG Network Monitor testing and comparison with Zabbix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>