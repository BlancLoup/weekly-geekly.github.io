<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wavelet compression on fingers: practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a previous post, we looked at the theoretical foundations of image compression using discrete wavelet transform. And although many important issues...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wavelet compression on fingers: practice</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png" align="left"><br>  In a <a href="http://habrahabr.ru/post/168517/">previous post,</a> we looked at the theoretical foundations of image compression using discrete wavelet transform.  And although many important issues were not addressed, the results obtained are enough to try to do something in practice. <br><br>  Why words?  Let's write a program that compresses images!  (There are a lot of pictures under the cut!) <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Tools </h4><br><br>  We will write in the programming language Python.  Yes, I know that many people would like me to illustrate the presentation of the code in <i>[enter your favorite programming language]</i> .  But Python seems to me to be the best choice because of its extreme simplicity (this is, in fact, interpreted pseudo-code). <br><br>  We will need an interpreter and a PIL (Python Imaging Library) library.  The network has enough instructions for installing them, so I will not dwell on this. <br><br>  The only thing I want to recommend for development is to use ipython notebook.  Wonderful thing, providing a web interface, reminiscent of the package Mathematica, but programmable in Python. <br><br><h4>  Summary of the previous series </h4><br><br>  So, we have already found out that in real images there is a huge amount of redundant information.  This redundancy is due to the fact that the neighboring brightness values ‚Äã‚Äãof the pixels change quite smoothly.  We also learned that this redundancy can be eliminated with the help of ordinary linear transformations, that is, multiplications by a matrix. <br><br>  The first transformation considered ‚Äî the Haar transformation ‚Äî works with pairs of luminance values.  Transformation is multiplication by a matrix <br><img src="https://habrastorage.org/storage2/f10/657/ddb/f10657ddb6497900c525b4d795bb8afc.png"><br><br>  The second transformation, the Daubechies D4 transformation, already uses fours of values ‚Äã‚Äãthat are shifted relative to each other by two values.  Therefore, the matrix will already be bigger (we denote the cumbersome coefficients by c <sub>i</sub> ): <br><img src="https://habrastorage.org/storage2/031/fce/db2/031fcedb29a53a3e7f0532a24eda21fd.png"><br><br>  We found the transformation coefficients by solving a system of nonlinear equations.  The second line is simply the coefficients written in reverse order with alternating characters. <br><br>  Multiplying this matrix by a column vector of 4 brightness values, we get only two values ‚Äã‚Äã(low-frequency and high-frequency coefficients).  It is because of this injustice that the four must not be taken in succession, but ‚Äúoverlapped‚Äù, with a step of 2. <br><br>  For example, if we have the values ‚Äã‚Äã[1, 2, 3, 4], then we need to take two fours: [1, 2, 3, 4] (surprise, surprise!) And [3, 4, 1, 2].  The latter has such a strange appearance due to the fact that we did not have enough values ‚Äã‚Äãon the right and had to return in a circle to the beginning. <br><br>  By the way, the matrix of the entire transformation in this case will be: <br><img src="https://habrastorage.org/storage2/f1f/4ff/e3b/f1f4ffe3b109c2c729ebb4acb04bc49c.png"><br><br>  Similarly, you can write higher order transformation matrices: D6, D8, and so on.  (The numbers are always even. Think about why.) <br><br><h4>  Getting started! </h4><br><br>  Suppose we chose the D4 wavelet transform for programming.  In order not to carry out calculations each time, put the coefficients in the list. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sqrt CL = [(<span class="hljs-number"><span class="hljs-number">1</span></span> + sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), (<span class="hljs-number"><span class="hljs-number">3</span></span> + sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), (<span class="hljs-number"><span class="hljs-number">3</span></span> - sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), (<span class="hljs-number"><span class="hljs-number">1</span></span> - sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>))]</code> </pre> <br><br>  The letter L means that these are the coefficients of the first line related to the low (L, low) filter. <br><br>  This is a fairly universal approach.  If we want to implement a different conversion, simply replace the list. <br><br>  We will find the coefficients of the high-frequency filter (HPF, high-pass filter) using a separate function that records the list in reverse order and alternating signs. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hpf_coeffs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CL)</span></span></span><span class="hljs-function">:</span></span> N = len(CL) <span class="hljs-comment"><span class="hljs-comment">#   CH = [(-1)**k * CL[N - k - 1] #        for k in xrange(N)] return CH</span></span></code> </pre><br><br>  The expression in brackets, if anyone does not know, is a list generator.  Very handy thing. <br><br><h4>  Direct one-dimensional transform </h4><br><br>  Now that we have coefficients, we can do the conversion itself.  Its result will be a list containing weighted sums with coefficients alternately from the lists CL and CH. <br><br>  Weighted sums (sums of pairwise products) are products of rows of a matrix by a column vector.  The even rows of the matrix are the low-pass filter, and the odd lines are the high-frequency filter.  That's where the alternation. <br><br>  Lists of weighted sums calculated ‚Äúalong‚Äù another list in mathematics are called convolutions.  There are effective algorithms for calculating these convolutions based on the Fourier transform.  (Suddenly, right? The Fourier transform is the sine and cosine, and suddenly it is used for summation!) But we are supporters of simplicity and will not deal with premature optimizations.  Count in the forehead, so clearer.  And optimizations and beautiful hacks will be left to the reader as an exercise. <br><br>  The function is called pconv.  P - from the word pair (pair), and conv - convolution (convolution). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pconv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, CL, CH, delta = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(len(CL) == len(CH)) <span class="hljs-comment"><span class="hljs-comment">#       N = len(CL) M = len(data) out = [] #   ,   for k in xrange(0, M, 2): #   0, 2, 4‚Ä¶ sL = 0 #   sH = 0 #   for i in xrange(N): #     sL += data[(k + i - delta) % M] * CL[i] sH += data[(k + i - delta) % M] * CH[i] out.append(sL) #     out.append(sH) return out</span></span></code> </pre><br><br>  It may be unclear what the delta value is, which is equal to zero by default.  It allows us to start convolving not from the first element, but from an arbitrary one.  This is useful to us a little later. <br><br>  The calculation of the remainder (the expression "% M") when calculating weighted sums is necessary in order not to go beyond the boundaries of the list.  If M = 4, and the index suddenly turns out to be equal to 5, then we will return again to the 1st element, since 5% 4 results in 1. <br><br>  Let's test our function on the unregulated Haar transform (which is with half sums and half differences). <br><br><pre> <code class="python hljs">&gt;&gt;&gt;C = [<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>] &gt;&gt;&gt;pconv([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], C, hpf_coeffs(C)) [<span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>]</code> </pre><br><br>  Works! <br><br><h4>  And back? </h4><br><br>  As the reader remembers, we specially designed our matrices so that the inverse transformation was performed as simply as possible.  Due to the orthogonality of the matrices H and D4, the inverse matrices for them can be found by simple transposition. <br><br>  Consider once again the transformation matrix D4, but for a column vector of arbitrary length: <br><img src="https://habrastorage.org/storage2/2e1/4bc/c04/2e14bcc04bc6fe416c2154f05195a149.png"><br><br>  Multiplying such a matrix by a column vector with pixel brightness values, we get the decorrelated values.  True, the matrix is ‚Äã‚Äãvery large, so instead of explicit multiplication, we used a convolution. <br><br>  The inverse matrix can be obtained by transposition: <br><img src="https://habrastorage.org/storage2/0a2/515/543/0a2515543dca5c97b5dc08447c87e732.png"><br><br>  Very similar to the original matrix, but there is no square piece in the lower left corner.  Although if you ‚Äúcut off‚Äù the last two columns and ‚Äúglue‚Äù to the beginning, you will get a matrix of the same form (albeit with different coefficients) and we will be able to use the ready-made pconv function.  Stop!  But we have the delta parameter there, which sets the offset in the source data.  But this is the very cutting and gluing.  The secret of the delta parameter is revealed! <br><br>  For D4, you need to "cut off" the last 2 columns, for D6 - four, etc. <br><br>  Things are easy - to determine the order of the coefficients in the rows of the inverse matrix.  For D4, the order is obvious: <br><img src="https://habrastorage.org/storage2/a0b/b5a/7f8/a0bb5a7f8d159e3fcf207105d030c607.png"><br><br>  But what about the case of D6, D8 and others?  Let's look at the D4 transformation matrix.  We are interested in the rows of the transposed matrix, that is, the columns of the original. <br><br>  Our vectors are the third and fourth columns.  Regardless of the order of conversion, the offset of the rows always occurs by two elements, so the pattern here is as follows. <br><br>  First vector: <br>  [the penultimate element of the first row, the penultimate element of the second, the first element of the first line (it coincides with the third), the first element of the second]. <br><br>  Second vector: <br>  [last element of the first line, last element of the second, second element of the first line (it coincides with the third), second element of the second]. <br><br>  That is, the coefficients are alternately selected in steps of 2 from CL and CH starting from the second to last for the first row of the inverse matrix or the last for the second row. <br><br>  This rule will be true for D4, and for D6 and even for the Haar transform (which is actually the same as D2). <br><br>  In Python, the penultimate element can be accessed at index -2, and the last at index -1.  We used this useful feature in pconv. <br><br>  We write a function to obtain a list of coefficients of the inverse matrix, working according to the described algorithm. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icoeffs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CL, CH)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(len(CL) == len(CH)) <span class="hljs-comment"><span class="hljs-comment">#       iCL = [] #    iCH = [] #    for k in xrange(0, len(CL), 2): iCL.extend([CL[k-2], CH[k-2]]) iCH.extend([CL[k-1], CH[k-1]]) return (iCL, iCH)</span></span></code> </pre><br><br>  Check her work: <br><pre> <code class="python hljs">&gt;&gt;&gt;C = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt;icoeffs(C, hpf_coeffs(C)) ([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>])</code> </pre><br><br>  It appears that the coefficients are reordered correctly. <br><br>  You can test the operation of functions by converting a list (say, [0, 1, 2, 3]), and then performing the inverse transformation. <br><pre> <code class="python hljs">&gt;&gt;&gt;CL = [(<span class="hljs-number"><span class="hljs-number">1</span></span> + sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span> + sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span> - sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)), &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span> - sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)) / (<span class="hljs-number"><span class="hljs-number">4</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>))] &gt;&gt;&gt;X = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt;CH = hpf_coeffs(CL) &gt;&gt;&gt;iCL, iCH = icoeffs(CL, CH) &gt;&gt;&gt;Y = pconv(X, CL, CH) &gt;&gt;&gt;X2 = pconv(Y, iCL, iCH, len(CL) - <span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">2.5077929123346285e-16</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.9999999999999991</span></span>, <span class="hljs-number"><span class="hljs-number">2.9999999999999991</span></span>]</code> </pre><br><br>  What nonsense!  It should have turned out again [0, 1, 2, 3]!  Stop, false alarm.  The first number is only <img src="https://habrastorage.org/storage2/cdc/8ff/973/cdc8ff97322810897566dbfa56f75124.png">  , that is almost zero.  The remaining numbers are also close to the original.  The fact is that we work with irrational numbers, and in such cases rounding errors are inevitable. <br><br><h4>  2D transformation </h4><br><br>  So, we have programmed the transformations.  But these transformations are one-dimensional!  And the pictures that we plan to compress, very even two-dimensional.  But this is easily solved.  A two-dimensional wavelet transform is performed as one-dimensional across all lines, and then across all bars (or vice versa, to taste). <br><br>  We will work with images using the numpy-based PIL library.  And there is a convenient way to refer to the elements of two-dimensional arrays. <br><br>  If the brightness values ‚Äã‚Äãof the pixels of our image are stored in the image variable, then we can get the list of 4th brightness, for example, lines, like this: <br><pre> <code class="python hljs">image[<span class="hljs-number"><span class="hljs-number">4</span></span>, :]</code> </pre><br><br>  And the list of brightnesses in the 3rd column is as follows: <br><pre> <code class="python hljs">image[:, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br><br>  Take for experiments some kind of image.  It is important that its size was a power of two!  (In general, it is important that they are even, but we will then do repeated conversions.) <br><br>  For example, you can take this (since Lena is fed up with everything): <br><img src="https://habrastorage.org/storage2/328/5b4/a25/3285b4a2561416779c3cdd7e4e380cab.png"><br><br>  It has dimensions of 512 √ó 512, so that it suits us. <br><br>  Load it into memory (at the same time transforming to a black-and-white look and forming a brightness matrix): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PIL.Image <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Image image = Image.open(<span class="hljs-string"><span class="hljs-string">'/tmp/boat.png'</span></span>).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) image = array(image) / <span class="hljs-number"><span class="hljs-number">255.0</span></span> <span class="hljs-comment"><span class="hljs-comment">#   ‚Äî [0, 1] imshow(image, cmap=cm.gray) #   </span></span></code> </pre><br><br>  Something should appear on the screen: <br><img src="https://habrastorage.org/storage2/40b/71e/4c5/40b71e4c5fbe942593a23a5b5a705fa4.png"><br><br>  So, the variable image is an array of brightness. <br><br>  We write the function for the two-dimensional wavelet transform.  Since the alternating low and high frequency coefficients look ugly, we will reorder them.  Low-frequency - left and up, high-frequency - right and down. <br><br>  Since the transformations are performed both by rows and by column, the low-frequency coefficients, which make up a reduced copy of the original picture, are grouped in the upper left corner. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwt2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, CL)</span></span></span><span class="hljs-function">:</span></span> CH = hpf_coeffs(CL) <span class="hljs-comment"><span class="hljs-comment">#    w, h = image.shape #   imageT = image.copy() #      for i in xrange(h): #   imageT[i, :] = pconv(imageT[i, :], CL, CH) for i in xrange(w): #   imageT[:, i] = pconv(imageT[:, i], CL, CH) #     data = imageT.copy() data[0:h/2, 0:w/2] = imageT[0:h:2, 0:w:2] data[h/2:h, 0:w/2] = imageT[1:h:2, 0:w:2] data[0:h/2, w/2:w] = imageT[0:h:2, 1:w:2] data[h/2:h, w/2:w] = imageT[1:h:2, 1:w:2] return data</span></span></code> </pre><br><br>  Let us test the operation of our function on the D4 transform, the coefficients of which we put in CL and CH. <br><pre> <code class="python hljs">data2 = dwt2(image, CL) imshow(data2, cmap=cm.gray)</code> </pre><br><br>  Immediately warn you!  Since we have not optimized anything, it will work slowly.  On my humble netbook, the calculation took a half dozen seconds. <br><br>  In the end, you should get this picture. <br><img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png"><br><br>  Everything, as we expected!  The reduced image in the corner and small in magnitude (as indicated by black color) are the coefficients in the rest. <br><br>  And here is a graph of values ‚Äã‚Äãalong the 50th line of the transformed image. <br><img src="https://habrastorage.org/storage2/3cc/59b/1d7/3cc59b1d7c0bf57150839450b1e58638.png"><br><br>  It can be seen that in the first half of the corresponding reduced copy, the range of change is high, while the high-frequency coefficients are close to zero. <br><br>  You can try with the Haar wavelet: <br><pre> <code class="python hljs">C = [<span class="hljs-number"><span class="hljs-number">1</span></span>/sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>/sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)] data3 = dwt2(image, C) imshow(data3, cmap=cm.gray)</code> </pre><br><br><img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png"><br><br>  With a good view and a monitor, you can see that more details appear in the high-frequency part.  This is understandable - after all, only the linear component was filtered, and in D4 - also the quadratic component. <br><br>  Or even take the coefficients for D6 from <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582%25D1%258B_%25D0%2594%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2588%25D0%25B8">Wikipedia</a> (do not forget to divide them by <img src="https://habrastorage.org/storage2/f76/6f9/eec/f766f9eec1869f743a665d5e2cdf835d.png">  they are normalized to a deuce there).  And the most daring can even get the coefficients analytically. <br><br>  The larger the conversion order, the darker the areas with high-frequency coefficients will be. <br><br><h4>  Inverse two-dimensional transform </h4><br><br>  The fact that we can do a two-dimensional transformation is great, but this skill is useless without the inverse transformation. <br><br>  It's just easy to do.  We perform the same steps as with the direct transformation, but in reverse order.  And do not forget about the other coefficients and the non-zero value of delta in pconv. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idwt2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, CL)</span></span></span><span class="hljs-function">:</span></span> w, h = data.shape <span class="hljs-comment"><span class="hljs-comment">#   #      imageT = data.copy() imageT[0:h:2, 0:w:2] = data[0:h/2, 0:w/2] imageT[1:h:2, 0:w:2] = data[h/2:h, 0:w/2] imageT[0:h:2, 1:w:2] = data[0:h/2, w/2:w] imageT[1:h:2, 1:w:2] = data[h/2:h, w/2:w] CH = hpf_coeffs(CL) iCL, iCH = icoeffs(CL, CH) image = imageT.copy() #      for i in xrange(w): #   image[:, i] = pconv(image[:, i], iCL, iCH, delta=len(iCL)-2) for i in xrange(h): #   image[i, :] = pconv(image[i, :], iCL, iCH, delta=len(iCL)-2) return image</span></span></code> </pre><br><br>  For verification, we perform the inverse transformation of the previously obtained image2 image. <br><pre> <code class="python hljs">&gt;&gt;&gt;image_rec = idwt2(image2, CL) &gt;&gt;&gt;imshow(image_rec, cmap=cm.gray)</code> </pre><br><br><img src="https://habrastorage.org/storage2/40b/71e/4c5/40b71e4c5fbe942593a23a5b5a705fa4.png"><br><br>  We got the original image (well, or very, very similar), so everything works for us! <br><br><h4>  Do not stop there! </h4><br><br>  Well, we got a lot of coefficients close to zero.  But we still have a quarter of the pictures occupied by low-frequency data.  And what if they convert?  This can be done in a loop, converting the upper left corner until it becomes too small. <br><br>  For the D4 wavelet, the ‚Äúcorner‚Äù size limit is 4 √ó 4 dimensions, since the smaller image cannot be converted anymore - there are not enough values ‚Äã‚Äãto multiply by 4 matrix coefficients. <br><br>  For example, for the D4 transformation, a similar recursive transformation can be programmed as follows: <br><pre> <code class="python hljs">data = image.copy() w, h = data.shape <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> w &gt;= len(CL) &amp;&amp; h &gt;= len(CL): data[<span class="hljs-number"><span class="hljs-number">0</span></span>:w, <span class="hljs-number"><span class="hljs-number">0</span></span>:h] = dwt2(data[<span class="hljs-number"><span class="hljs-number">0</span></span>:w, <span class="hljs-number"><span class="hljs-number">0</span></span>:h], CL) w /= <span class="hljs-number"><span class="hljs-number">2</span></span> h /= <span class="hljs-number"><span class="hljs-number">2</span></span> imshow(data, cmap=cm.gray)</code> </pre><br><br>  The picture is not very interesting. <br><img src="https://habrastorage.org/storage2/12d/e67/a4f/12de67a4f8e15f465fb30c6c9f527b28.png"><br><br>  Let's see in which range the values ‚Äã‚Äãchange.  Here is a plot of values ‚Äã‚Äãfrom the zero line. <br><img src="https://habrastorage.org/storage2/064/ea4/df7/064ea4df7f8d286fa8ed2343c0a4e216.png"><br><br>  The first few values ‚Äã‚Äãare really going wild.  But the rest are small. <br><br><h4>  Remove unnecessary </h4><br><br>  And now let's do something for the sake of which, all this was intended - we get a lot of zeros! <br><br>  This can be done in different ways.  For example, you can round the values ‚Äã‚Äãto the required number of significant digits (a special case of quantization).  But we will proceed more simply - we will replace the coefficients smaller in absolute value of some value by zero. <br><br>  As such a threshold value we take 0.05.  The more, the more zeros, but the greater the loss! <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abs threshold = <span class="hljs-number"><span class="hljs-number">0.05</span></span> data[abs(data)&lt;threshold] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  After that, the schedule will be noticeably smoother. <br><img src="http://habrastorage.org/storage2/d80/f20/fe6/d80f20fe6fd9654915911c910afaad78.png"><br><br>  Calculate the number of zeros: <br><pre> <code class="python hljs">&gt;&gt;&gt;sum(data == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">224000</span></span></code> </pre><br><br>  Not bad!  Considering that the image is only 512 √ó 512 = 262144 pixels, it turns out that we simply discarded <b>85.4% of the</b> existing coefficients !!! <br><br>  Is it bad for the image? <br><br>  Perform the inverse transform.  (How exactly - an exercise for the reader!) <br><br>  In the small figure, the distortion cannot be seen at all, therefore I will give full-size pictures - the original and the reconstructed image. <br><br><img src="http://habrastorage.org/storage2/ccd/a1d/80f/ccda1d80f02c0efeb31bff15e5ba99ec.png"><img src="http://habrastorage.org/storage2/780/49e/aa0/78049eaa0f4f4550ce4b234909ad0c49.png"><br><br>  Who saw the differences - that fellow!  I found it with difficulty. <br><br>  And if we take 0.1 (92.9% of coefficients are reset)? <br><img src="http://1450827299750550431942"><br>  It's not bad too! <br><br>  Let us now take a threshold equal to 0.2 (96.9% of the rejected coefficients). <br><img src="http://habrastorage.org/storage2/063/351/507/0633515071a88e1afd7b771ee6685a57.png"><br>  Already noticeable serious distortion. <br><br>  Finally, let's try to drop everything that is smaller in modulus than 0.5 (99.2% is dropped). <br><img src="http://habrastorage.org/storage2/f61/2e5/e1b/f612e5e1b97dc3431992f2a7ba65c57c.png"><br>  Creepy soap!  But the squares are not as contrasting as in compressed JPEGs.  We used D4, so the soap is ‚Äúquadratic‚Äù, with smooth gradients inside. <br><br>  For comparison, we will try to compress the image with the same threshold (that is, 0.5), but already using the Haar transform. <br><img src="http://habrastorage.org/storage2/446/5e5/32d/4465e532d60f8bec8764701491e22d79.png"><br><br>  Horror, horror!  Also linear distortions.  And only 99.2% of the coefficients are rejected.  Worse than D4. <br><br><h4>  findings </h4><br>  So. <br><br>  1. After the conversion of D4, we can safely discard 90% of the coefficients by simple zeroing and will not lose in quality.  And if you apply advanced quantization techniques, the result can be further improved. <br><br>  2. D4 is better than D2 (Haar transform).  D6 will be better than D4 and so on.  But there is a problem.  The higher the order, the earlier we will have to stop the process of recursive transformation of the upper left corner.  So in everything you need to know when to stop. <br><br><h4>  What's next? </h4><br>  Actually, we haven't finished yet.  Yes, we have discarded 90% of the ratios.  But these are real coefficients occupying 8 bytes!  So the compression will be very, very small.  Therefore, when saving to a file, the coefficients are rounded off and use a limited number of bits to store.  In addition, for better packaging, the coefficients can be reordered in a special way.  About this you can write more than one article. <br><br>  But even if you simply save the array with the coefficients in the form of floating-point numbers with half precision (float16), then after compression by the xz archiver, a file of 43604 bytes is obtained. <br><br>  Saving can be done like this. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> save save(<span class="hljs-string"><span class="hljs-string">"boat"</span></span>, data.astype(float16))</code> </pre><br><br>  Despite the significant loss of accuracy due to the conversion float64 ‚Üí float16 and compression in the forehead without any special algorithms, we get a pretty good result: <br><img src="http://1450827299750550431942"><br><br>  In this case, a compression factor of (512 √ó 512) / 43604 ‚âà 6 or 1.33 bits / pixel was obtained.  God knows that, but we didn‚Äôt try hard to squeeze.  Proper quantization and a good compression algorithm can greatly improve this result!  So there is room to grow!  But this is already beyond the scope of our "project for the evening."  Maybe some other time.  ;) <br><br><h4>  Homework </h4><br>  1. Try to combine the given pieces of code into one script.  Let it take as parameters the name of the image file, the threshold value and the type of conversion, compress the specified image, and save the results to a file.  Provide two modes of operation: compression and decompression. <br>  2. Experiment with encoding and decoding different images. <br>  3. Try other transformations. <br>  4. Consider how to more economically compress coefficients. <br>  5. Try to speed up the program. <br>  6. Implement the compression of color images. <br>  7. Remove the restriction on the size (for now they must be powers of two). <br>  eight. ??? <br>  9. PROFIT !!! <br><br>  Another JPEG Killer Ready!  ;) <br><br>  Thanks to all!  I hope it was interesting! </div><p>Source: <a href="https://habr.com/ru/post/169615/">https://habr.com/ru/post/169615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../169603/index.html">Ubuntu Phone will be available next week.</a></li>
<li><a href="../169605/index.html">Elastix as an automatic message recording system with sending them to performers</a></li>
<li><a href="../169607/index.html">Python in Europe under threat</a></li>
<li><a href="../169611/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ44 (February 9 - 15, 2013)</a></li>
<li><a href="../169613/index.html">Android 4.2.2 is available for some devices.</a></li>
<li><a href="../169617/index.html">Skype owns a third of international telephone traffic</a></li>
<li><a href="../169619/index.html">Friday story about synchronized methods in the Thread class</a></li>
<li><a href="../169623/index.html">Tracker: real-time management</a></li>
<li><a href="../169629/index.html">Review of the calculator Felix M</a></li>
<li><a href="../169635/index.html">Questions to post Alex Rublev about design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>