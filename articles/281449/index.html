<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular 2 and dependency injection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second version of the angular is getting closer to the release and more and more people are becoming interested in it. So far, the information on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular 2 and dependency injection</h1><div class="post__text post__text-html js-mediator-article"><p>  The second version of the angular is getting closer to the release and more and more people are becoming interested in it.  So far, the information on the framework is not so much, especially in Russian, and more and more often questions arise on some topics. </p><br><p>  One of the topics that causes a lot of questions is dependency injection.  Some people have not come across this technology.  Others do not fully understand how it works within the framework of Angular 2, as they are accustomed to other implementations that occur in other frameworks. </p><br><p>  And the answer lies in the fact that the DI in the second angular is indeed somewhat different from the others, and this is primarily due to the general approach and philosophy of the 2nd version.  It lies in the fact that the entities from which the entire application is built are <strong>components</strong> .  The service layer, the router, the dependency injection system are secondary and they make sense only within the component.  This is a very important point that underlies the understanding of the architecture of the new framework. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  This is a retelling of 2 pages from the office.  documentation regarding dependency injection in Angular 2: <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">this one</a> and <a href="https://angular.io/docs/ts/latest/guide/hierarchical-dependency-injection.html">this one</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Why typescript</b> <div class="spoiler_text"><p>  In the article I will use Typescript.  Why? <br>  The framework itself is written in Typescript, and the information on the Angular2 + Typescript bundle is the most. <br>  The syntax-based Typescript code is a fresh implementation of the ES standard, additional typing, and some minor features.  However, applications can be written on both Javascript and Dart.  In the JS version, you can not use ES6 + syntax, however, the brevity and clarity of the code is lost.  And if you configure Babel to support fresh features, then syntactically everything will be very similar to the TS code: classes, annotations / decorators, etc.  Well, only without the types, so dependency injection will look a little different. </p></div></div><br><h3 id="problema-zavisimostey">  Dependency problem </h3><br><p>  Imagine that we are writing a kind of abstract application, dividing the code into small logical pieces (to avoid confusion with the angular language, I <em>will not</em> call them "components," let it be just the service classes that contain business logic). </p><br><pre><code class="hljs pgsql">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Engine { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> cylinders = <span class="hljs-number"><span class="hljs-number">4</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> } export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Tires { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> make = <span class="hljs-string"><span class="hljs-string">'Flintstone'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> model = <span class="hljs-string"><span class="hljs-string">'Square'</span></span>; } export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Car { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> engine: Engine; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> tires: Tires; constructor() { this.engine = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Engine(); this.tires = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Tires(); } drive() {} }</code> </pre> <br><p>  Of course, there is no logic at all, but for illustration it is quite suitable. </p><br><p>  So what's the problem?  At the moment, <code>Car</code> strictly dependent on 2 services that are manually created in its constructor.  From the point of view of the consumer of the <code>Car</code> service, this is good, because the <code>Car</code> addiction itself took care of its dependencies.  But, if we, for example, want to make sure that the required parameter is passed to the Engine constructor, then the code of the <code>Car</code> itself will have to be changed: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine2</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(public cylinders: number) { } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ public engine: Engine; public tires: Tires; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Engine2(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tires = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tires(); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Constructors in TS</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//  ,          //       : export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Engine2 { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> cylinders constructor(cylinders: number) { this.cylinders = cylinders } }</code> </pre> </div></div><br><p>  Therefore, creating instances of dependencies in the consumer is not so good. </p><br><p>  Rewrite the code so that instances of the <code>Car</code> dependencies are transmitted from the outside: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> engine: Engine, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> tires: Tires) { } }</code> </pre> <br><p>  Already better.  The code of the service itself has decreased, and the service itself has become more flexible.  It is easier to test and configure: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockEngine</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span></span>{ cylinders = <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockTires</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tires</span></span></span><span class="hljs-class"> </span></span>{ make = <span class="hljs-string"><span class="hljs-string">"YokoGoodStone"</span></span>; } let car = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Car</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Engine</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Tires</span></span>()); let supercar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Car</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Engine2</span></span>(<span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Tires</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mockCar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Car</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MockEngine</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MockTires</span></span>());</code> </pre> <br><p>  However, now the problems start at the consumer of the <code>Car</code> service: you need to create not only the service itself, but all its dependencies, and then transfer the instances of the created service dependencies to the <code>Car</code> designer. </p><br><p>  And with each new component and each new dependency, it is becoming more and more difficult to create instances of services.  You can, of course, make a factory into which all the logic for creating a <code>Car</code> service is put into: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarFactory</span></span></span><span class="hljs-class"> </span></span>{ createCar() { let car = new Car(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createEngine(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createTires()); car.description = <span class="hljs-string"><span class="hljs-string">'Factory'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } createEngine() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Engine(); } createTires() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Tires(); } }</code> </pre> <br><p>  But the problems will not become much less: we will need to manually maintain the factory up to date when the <code>Car</code> dependencies change. </p><br><h3 id="na-puti-k-vnedreniyu">  On the road to implementation </h3><br><p>  How can I improve the code?  Every consumer knows what services he needs.  But in order to reduce the connectivity of the system, the consumer should not create them himself.  You can create a singleton class in which the instances of all our services are created and stored.  In this class, we determine how to create the necessary services, and you can receive them, for example, by a certain key.  Then in the services it will be enough just to somehow get a copy of such a singleton, and from it already get ready-made dependency instances.  Such a pattern is called a ServiceLocator.  This is one type of inversion control.  Then the code would look something like this: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {ServiceLocator} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'service-locator.ts'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... let computer = ServiceLocator.instance.getService(Car) //     </span></span></code> </pre> <br><p>  On the one hand, we got rid of the rigid connection of the consumer and his dependencies: all services are created outside of consumers.  But on the other hand, now consumers are now tightly connected with a service locator: every consumer should know where the service locator instance is located.  Well, the creation of services is still manual. </p><br><p>  I would like to be able to simply somehow indicate in the consumer his dependencies and the variable in which the dependency instance will be placed, and make the creation and implementation of the services themselves automatic. </p><br><p>  This is what DI frameworks do.  They manage the life cycle of the implemented dependencies, track the places where these dependencies are required and implement them, i.e.  transfer to the consumer the created dependency instance that the consumer has requested.  A hard dependence on the service locator disappears from consumers: now the DI framework works with the locator. </p><br><p>  The essence of the work is approximately as follows: </p><br><ul><li>  First, you must somehow register all the dependencies being implemented in the ‚Äúinjector‚Äù: for each service, you need to describe how to create it and how to find it later in the service locator. </li><li>  The consumer indicates the necessary dependencies. </li><li>  The DI container scans the program for deployment points. </li><li>  When someone needs a dependency, the container will find the necessary instance of the service in its service locator and inject the instance where appropriate. </li></ul><br><p>  And depending on the DI framework, these items will look different in the code. </p><br><h3 id="angulyar-1">  Angulyar number 1 </h3><br><p>  For a better understanding of the device of the second version of this framework, in particular, DI, I would like to describe a little how the first part works. </p><br><p>  The life cycle of an application consists of several stages.  I would like to highlight 2 stages: </p><br><ul><li>  <strong>Config</strong> .  At this stage, the modules included in the application are configured.  Only limited dependency injection is available.  Configuring modules usually involves configuring services that will be used in the future.  Services can be configured through their <em>providers</em> - special objects that can be implemented at this stage and which will later return the configured service instance. </li><li>  <strong>Run</strong> .  Here the configured application is up and running.  All dependencies are available, services have already been created (in fact, there is lazy initialization, but not the essence) and are configured. </li></ul><br><p>  At the top level are the modules.  A module, in essence, is simply an object in which various parts of an application can be registered and stored: services, controllers, directives, filters.  Also, the module can have config- and run-kolbek, which will be launched at the appropriate stages of the application. </p><br><p>  So, how dependency injection in the first version looks like: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lua"> // - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var privateField = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { publicField: <span class="hljs-string"><span class="hljs-string">'public'</span></span>, publicMethod: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> * privateField; } }; } var module = angular.module(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, []); //   //     <span class="hljs-string"><span class="hljs-string">'MyService'</span></span>    //   ,  ,   - (<span class="hljs-number"><span class="hljs-number">2</span></span>- )      module.factory(<span class="hljs-string"><span class="hljs-string">'MyService'</span></span>, factory); //     <span class="hljs-string"><span class="hljs-string">'MyController'</span></span> //            module.controller(<span class="hljs-string"><span class="hljs-string">'MyController'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyService)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(MyService.publicMethod(<span class="hljs-number"><span class="hljs-number">21</span></span>)); //    })</code> </pre> </div></div><br><p>  Yes, there are a lot of nuances.  For example, in the first angulyar there are already <a href="https://habrahabr.ru/post/190342/">5 different types of services</a> , so that you can register a service in different ways.  When minifying code, function arguments may change, so it‚Äôs better to use a different syntax for declaring dependencies ... </p><br><p>  But I do not want to go deep into the jungle of the first angular, I will write only the main points: </p><br><ul><li>  All services are singletones. </li><li>  Registration of something (services, controllers, etc.) occurs in the module by calling the appropriate functions, thus.  The module is a kind of storage for various parts of the application </li><li>  Dependency injection occurs on the line, i.e.  the service locator stores and searches everything in the object, where the key is the name of the service being implemented, and the value is the instance.  In fact, you can still implement controllers.  For them, not an instance is stored, but a constructor function. </li><li>  The application has a special service $ injector.  This is a service locator, through which you can get a dependency manually.  Usually, it is one for the entire application. </li><li>  Dependencies are searched among those registered in the main module.  The main module is the one that directly loads onto the HTML page. </li><li>  If you specify dependencies when creating a module, $ injector will look for a dependency not only in the current module, but also in the dependent ones. </li></ul><br><h2 id="angular-2-novyy-put">  Angular 2: new way </h2><br><p>  The second version of the angular was announced as a new framework written from scratch, which took into account all the errors of the first part.  As far as using the 2nd version, I got exactly this impression.  Unnecessary entities and concepts have disappeared.  What remains is only better and more convenient, and innovations fit well and look logical. </p><br><p>  The first angular was, in fact, simply a set of useful techniques, techniques, and patterns glued together with DI.  But its separate parts were somehow in themselves, were slightly fragmented.  There was no single concept. </p><br><ul><li>  The controller could be inserted into the DOM in a bunch of different ways: through the attribute, through the router (of which there are already 3 versions: simple original, clever third-party, and backport from the 2nd part), through the directive. </li><li>  Parallel to the DOM tree, there was a tree with a hierarchy of scopes in which data accessible via controllers was stored.  The scopes themselves could be inherited, almost like prototypes, but they could be isolated.  There were also extremely difficult to understand transclude scopes. </li><li>  There was its own event system related to the hierarchy of scopes, through which it was possible to transfer data in different directions </li></ul><br><p>  As a result, the structure of the application could be completely different.  But instead of freedom, it usually meant blending concepts. </p><br><h3 id="komponentnyy-podhod">  Component approach </h3><br><p>  What is a component in Angular 2?  This is just a class with certain metadata and an associated presentation layer (template).  To make a component of a class, you need to add to it the most specific metadata.  The easiest way is to wrap it in the <code>@Component</code> decorator, which links the view with its ViewModel (that is, by the class itself).  And from the point of view of type hierarchy, a component is a special case of a directive (which is defined using the <code>@Directive</code> decorator), which has a template: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app'</span></span></span><span class="hljs-meta">, template: `&lt;h1&gt;Hello, {{ greetings }}&lt;/h1&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ greetings: string = <span class="hljs-string"><span class="hljs-string">'World'</span></span>; }</code> </pre> <br><p>  The decorator must pass an object that must contain at least 2 required fields: <code>selector</code> and <code>template</code> . </p><br><p>  The <code>selector</code> field contains a string that will be used as a css selector to search for a component in the DOM.  You can pass any valid selector, but most often use a selector tag that is not included in the standard set of HTML tags.  Thus, custom tags are created. </p><br><p>  The <code>template</code> field contains a <code>template</code> string that replaces the contents of the DOM element found by the selector.  Instead of a string with a template, you can pass a string with the path to the template file (only the field will be called <code>templateUrl</code> ).  You can read more about the syntax of templates for the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">docks page</a> or <a href="https://habrahabr.ru/post/274743/">its Russian translation</a> . </p><br><h3 id="ierarhiya-komponentov">  Component Hierarchy </h3><br><p>  What was wrong with the first angulyar?  There was a hierarchy of scopes, but the service layer was common to all.  The services were set up once and for all before the launch of the application, and they were also singletones. </p><br><p>  There were also problems with routers.  The original was rather poor, did not allow to create a normal hierarchy.  The UI-router was richer in features, allowed the use of multiple views, knew how to build a hierarchy of states. <br>  But the main problem of both routers was that the whole hierarchy of paths was absolutely in no way connected with the hierarchy of scopes and was extremely non-flexible. </p><br><p>  What did the second version do?  At the heart of the second angulyar, as I said, are the components.  The entire application consists only of components that form a tree-like hierarchical structure.  The root component is loaded using the bootstrap function on the HTML page (if the browser is used as a target platform).  All other components are placed inside the root and form a tree of components. </p><br><p>  How to make so that, on the one hand, each component could be as independent as possible, reusable and self-sufficient, while avoiding duplication of code? <br>  To ensure the independence of the component, it has metadata that allows you to fully describe everything that is needed for this component to work: setting up routing, a list of used directives, pipes and services.  In order not to be connected through the service layer, each component now has its own router and its own injector.  And they, in turn, also form a hierarchy, which is always associated with the hierarchy of components. </p><br><p>  <strong>This is what distinguishes DI in Angular2 from other DI frameworks: in an angular, an application does not have one injector, each component can have its own injector</strong> </p><br><h2 id="vnedrenie-zavisimostey-v-angular2">  Deploy dependencies in Angular2 </h2><br><p>  What does dependency injection in the second angular look like?  Services are now implemented by type.  Implementation usually takes place in the user‚Äôs constructor. </p><br><h3 id="servisy">  Services </h3><br><p>  The service in Angular 2 is a simple class. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { username: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; email: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; } export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserService</span></span> { getCurrent(): User { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { username: <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, email: <span class="hljs-string"><span class="hljs-string">'admin@example.com'</span></span> }; } }</code> </pre> <br><h3 id="registraciya-servisov">  Registration of services </h3><br><p>  To be able to implement the service, you first need to register it.  We do not need to manually create the injector, the angular itself creates a global injector when the <code>bootstrap</code> function is called: </p><br><pre> <code class="hljs lisp">bootstrap(<span class="hljs-name"><span class="hljs-name">AppComponent</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  The second argument can be an array containing the providers.  So one way to make a service available is to add its class to the list: </p><br><pre> <code class="hljs lisp">bootstrap(<span class="hljs-name"><span class="hljs-name">AppComponent</span></span>, [UserService])<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  This code will make our service available for the entire application.  However, doing so is not always good.  Framework developers advise to register only system providers in this place, and only if they are needed in the entire system.  For example, providers of a router, forms and Http-services. </p><br><p>  The second way to register a service is to add it to the component metadata in the providers field: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {bootstrap} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/platform/browser'</span></span>; @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app'</span></span>, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [UserService], <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;h1&gt;App&lt;/h1&gt;`</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ } bootstrap(AppComponent);</code> </pre> <br><h3 id="vnedrenie-servisov-v-komponent">  The introduction of services in the component </h3><br><p>  The easiest way to implement a service is through a constructor.  Since TypeScript supports types, it suffices to write this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app'</span></span></span><span class="hljs-meta">, providers: [UserService], template: ` &lt;h1&gt;App&lt;/h1&gt; Username: {{ user.username }} &lt;br&gt; Email: {{ user.email }} `, })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ user: User; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(userService: UserService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = userService.getCurrent(); } } bootstrap(AppComponent);</code> </pre> <br><p>  And that's it!  If the <code>UserService</code> was registered, then the angular will inject the necessary instance into the constructor argument. </p><br><h3 id="vnedrenie-servisov-v-servisy">  The introduction of services in services </h3><br><p>  For the service to be able to inject dependencies itself, you need to wrap it with <code>@Injectable</code> decorator.  Developers also recommend adding this decorator in general for any services, since you never know whether any dependencies within the service will ever be needed.  So follow their advice. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/core'</span></span>; @Injectable() //   export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Logger { logs: string[] = []; log(message: string) { this.logs.push(message); console.log(message); } } @Injectable() //   export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserService { constructor(private _logger: Logger) {} //        getCurrent() { this._logger.log(<span class="hljs-string"><span class="hljs-string">' ...'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { username: <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, email: <span class="hljs-string"><span class="hljs-string">'admin@example.com'</span></span> }; } }</code> </pre> <br><p>  Now you need to remember to register the service <code>Logger</code> , otherwise the angular will generate an error: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">EXCEPTION</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> provider <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Logger! (AppComponent -&gt; UserService -&gt; Logger)</code> </pre> <br><p>  So add the <code>Logger</code> to the list of component providers: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">providers</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[UserService, Logger]</span></span>,</code> </pre> <br><h3 id="opcionalnye-zavisimosti">  Optional dependencies </h3><br><p>  If the service being introduced is not required, add the <code>@Optional</code> annotation: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Optional, Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/core'</span></span>; @Injectable() //   export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserService { constructor(@Optional() private _logger: Logger) {} //        getCurrent() { this._logger.log(<span class="hljs-string"><span class="hljs-string">' ...'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { username: <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, email: <span class="hljs-string"><span class="hljs-string">'admin@example.com'</span></span> }; } }</code> </pre> <br><p>  Now, even if you forget to register the <code>Logger</code> , errors will not occur. </p><br><h3 id="provaydery">  Providers </h3><br><p>  The provider provides a specific version of the service being implemented in runtime.  In fact, we always register not the service itself, but its provider.  Just in most cases they are the same. <br>  As part of the framework is a class <code>Provider</code> .  He describes exactly how the injector should instantiate the dependency. </p><br><p>  When we add a service class to the list of providers (component or bootstrap function), in practice this means the following: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Logger</span></span>], <span class="hljs-comment"><span class="hljs-comment">//        [new Provider(Logger, {useClass: Logger})], //  ,   provide [provide(Logger, {useClass: Logger})],</span></span></code> </pre> <br><p>  Both the <code>Provider</code> class constructor and the <code>provide</code> function take 2 arguments: </p><br><ul><li>  The token that acts as the key by which the service locator will look for dependency </li><li>  The object that contains the recipe for exactly how to create the embedded value. </li></ul><br><p>  In fact, when I said that the introduction is of a type, I did not say the whole truth.  The token over which an injection can occur can be not only a class, but more on that a little later. </p><br><h3 id="alternativnye-provaydery-servisov">  Alternative Service Providers </h3><br><p>  Suppose we want to use an instance of the class <code>BetterLogger</code> as a service instead of the <code>Logger</code> class.  There is no need to search and change the dependence of the <code>Logger</code> on <code>BetterLogger</code> throughout the application, it is enough to register the provider for the <code>Logger</code> with the <code>useClass</code> option: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">provide(Logger, {useClass: BetterLogger})</span></span>]</code> </pre> <br><p>  Even if the alternative class has some kind of dependency, which the original service does not have: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EvenBetterLogger</span></span></span><span class="hljs-class"> </span></span>{ logs:string[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _timeService: TimeService) { } log(message: string) { message = `${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timeService.getTime()}: ${message}`; console.log(message); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logs.push(message); } }</code> </pre> <br><p>  We can still use it just the same, we just need to register the necessary dependencies: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta"> TimeService, provide(Logger, {useClass: EvenBetterLogger}) </span></span>]</code> </pre> <br><h3 id="aliasy-provayderov">  Aliases providers </h3><br><p>  Suppose we have some old component that depends on the old service of the <code>OldLogger</code> logger.  This service has the same interface as the new logger <code>NewLogger</code> .  But for some reason, we cannot change that old component.  So we want to use the new one instead of the old logger.  If we try to do this: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta"> NewLogger, provide(OldLogger, {useClass: NewLogger}) </span></span>]</code> </pre> <br><p>  That is not what we wanted: 2 instances of a new logger will be created.  One will be used where the old is being introduced, the other is where the new logger is being introduced.  To create only 1 instance of the new logger, which would be used everywhere, register the provider with the <code>useExisting</code> option: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta"> NewLogger, provide(OldLogger, {useExisting: NewLogger}) </span></span>]</code> </pre> <br><h3 id="provaydery-znacheniy">  Value providers </h3><br><p>  Sometimes it‚Äôs easier not to create a separate class to replace the service provider with it, but simply to use a ready-made value.  For example: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     ,    Logger let silentLogger = { logs: [<span class="hljs-string"><span class="hljs-string">'Silent logger says "Shhhhh!". Provided via "useValue"'</span></span>], log: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} }</code> </pre> <br><p>  To use a ready-made object, register a provider with the <code>useValue</code> option: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">provide(Logger, {useValue: silentLogger})</span></span>]</code> </pre> <br><h3 id="provayder-fabrika--fabrichnyy-provayder">  Provider Factory / Factory Provider </h3><br><p>  Sometimes you need to register your provider dynamically, using information that is not available from the very beginning.  For example, this information can be obtained from a session and be different from time to time.  Also assume that the service being deployed does not have independent access to this information. <br>  In such cases, use the provider-factory / factory provider. </p><br><p>  Let us have a certain service <code>BookService</code> , which as well as <code>EvenBetterLogger</code> needs information from another service.  Suppose we want to check if a user is authorized using data from <code>AuthService</code> .  But, unlike <code>EvenBetterLogger</code> we cannot implement a service directly, i.e.  in this case, the <code>BookService</code> does not have access to the <code>AuthService</code> .  Services look like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ isLoggedIn: boolean = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookService</span></span></span><span class="hljs-class"> </span></span>{ books: any[]; <span class="hljs-comment"><span class="hljs-comment">// ,   extraBooks: any[]; // ,     constructor(private _logger: Logger, private _isLoggedIn: boolean) {} getBooks() { if (this._isLoggedIn) { this._logger.log(' '); return [...this.books, ...this.extraBooks]; } this._logger.log(' '); return this.books; } }</span></span></code> </pre> <br><p>    <code>Logger</code> ,     boolean-. <br>     -    <code>BookService</code> ,     : </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookServiceFactory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger: Logger, authService: AuthService</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BookService(logger, authService.isLoggedIn); }</code> </pre> <br><p>   ,  ,    <code>useFactory</code>  ,    <code>deps</code> ‚Äî   : </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">provide(BookService, {useFactory: bookServiceFactory, deps: [Logger, AuthService</span></span>]})</code> </pre> <br><h3 id="tokeny-vnedreniya-zavisimostey">    </h3><br><p>    -   ,       ,     . ,     .       ,   : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger: Logger = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._injector.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(Logger);</code> </pre> <br><p>   ,      - : </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">private</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _logger: Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{}</span></span></span></span></code> </pre> <br><p>                  . </p><br><h3 id="neklassovye-zavisimosti">   </h3><br><p>        ? ,    , ,   .. </p><br><p> ,    -,     .   ,      ,     -  : </p><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Config</span></span> { apiEndpoint: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, title: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } export <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG: Config = { apiEndpoint: <span class="hljs-string"><span class="hljs-string">'api.heroes.com'</span></span>, title: <span class="hljs-string"><span class="hljs-string">'Dependency Injection'</span></span> };</code> </pre> <br><p>     ,      .    : </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// FAIL [provide(Config, {useValue: CONFIG})] // FAIL constructor(private _config: Config) {}</span></span></code> </pre> <br><p>     :       . <br>   ,   Java  C#       ( DI-    ),   .      .     ,   JavaScript.   ,  <code>interface</code> ‚Äî   TypeScript,       .     ,        . </p><br><h4 id="reshenie-problemy">  Solution to the problem </h4><br><p>      <code>OpaqueToken</code> ,   -   : </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {OpaqueToken} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'angular2/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> APP_CONFIG = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpaqueToken(<span class="hljs-string"><span class="hljs-string">'app.config'</span></span>);</code> </pre> <br><p>      <code>OpaqueToken</code> ,     . <br>     : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">providers</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[provide(APP_CONFIG, {useValue: CONFIG})]</span></span></code> </pre> <br><p>    ,   <code>@Inject</code> : </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Inject(APP_CONFIG)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">private</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">config</span></span></span><span class="hljs-function">:</span></span> Config) <span class="hljs-comment"><span class="hljs-comment">{}</span></span></code> </pre> <br><p>  ,   ,    . </p><br><p>  ,      : </p><br><pre> <code class="hljs perl">[provide(<span class="hljs-string"><span class="hljs-string">'Congig'</span></span>, {useValue: CONFIG})] //... constructor(@Inject(<span class="hljs-string"><span class="hljs-string">'Config'</span></span>) private _config: Config) {}</code> </pre> <br><h2 id="ierarhicheskoe-vnedrenie-zavisimostey">    </h2><br><p>   ,  Angular2- ‚Äî   .         .       . </p><br><p>     ? ,          -,    ,    .  ,    -           ,          .      ,    - .      ,       <code>providers</code> . </p><br><p> ,        .     -    - .      ,     - .       .  ,       :    ,     .             . </p><br><p> ,        .     .    ,     ,       . </p><br><p>      ?         <code>providers</code> ,       .           ,      <code>bootstrap</code> . <br>   <code>providers</code>  ,         <code>Injector.resolveAndCreate([...])</code> ,          .      <code>parent</code> ,      .    ,       .   ,        . </p><br><p>   ,     : </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {bootstrap} from <span class="hljs-string"><span class="hljs-string">'angular2/platform/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable, Component} from <span class="hljs-string"><span class="hljs-string">'angular2/core'</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggerA</span></span></span><span class="hljs-class"> </span></span>{ logs: string[] = []; log(message: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logs.push(message); console.log(<span class="hljs-string"><span class="hljs-string">'Logger a: '</span></span> + message); } } <span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggerB</span></span></span><span class="hljs-class"> </span></span>{ logs: string[] = []; log(message: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logs.push(message); console.log(<span class="hljs-string"><span class="hljs-string">'Logger b: '</span></span> + message); } } <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'child'</span></span></span><span class="hljs-meta">, providers: [LoggerA], template: ` &lt;div&gt; &lt;h4&gt;Child&lt;/h4&gt; &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"update()"</span></span>&gt;Update&lt;/button&gt; &lt;p&gt;Logs:&lt;/p&gt; &lt;strong&gt;LogA: &lt;pre&gt;{{ logA.logs | json }}&lt;/pre&gt;&lt;/strong&gt; &lt;strong&gt;LogB: &lt;pre&gt;{{ logB.logs | json }}&lt;/pre&gt;&lt;/strong&gt; &lt;/div&gt;` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> logA: LoggerA, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> logB: LoggerB) {} update() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logA.log(<span class="hljs-string"><span class="hljs-string">'Child: A'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logB.log(<span class="hljs-string"><span class="hljs-string">'Child: B'</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app'</span></span></span><span class="hljs-meta">, providers: [LoggerA, LoggerB], directives: [ChildComponent], template: ` &lt;div&gt; &lt;div style=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"display: inline-block; vertical-align: top;"</span></span></span><span class="hljs-meta">&gt; &lt;h3&gt;App&lt;/h3&gt; &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"update()"</span></span>&gt;Update&lt;/button&gt; &lt;p&gt;Logs:&lt;/p&gt; &lt;strong&gt;LogA: &lt;pre&gt;{{ logA.logs | json }}&lt;/pre&gt;&lt;/strong&gt; &lt;strong&gt;LogB: &lt;pre&gt;{{ logB.logs | json }}&lt;/pre&gt;&lt;/strong&gt; &lt;/div&gt; &lt;div style=<span class="hljs-string"><span class="hljs-string">"display: inline-block; vertical-align: top;"</span></span>&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; &lt;/div&gt;` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> logA: LoggerA, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> logB: LoggerB) {} update() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logA.log(<span class="hljs-string"><span class="hljs-string">'App: A'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logB.log(<span class="hljs-string"><span class="hljs-string">'App: B'</span></span>); } } bootstrap(AppComponent);</code> </pre> </div></div><br><p> <a href="http://plnkr.co/edit/nbpmh3wb5g34WetQ3AAE%3Fp%3Dpreview">http://plnkr.co/edit/nbpmh3wb5g34WetQ3AAE?p=preview</a> </p><br><p>  2   2 .     2  ( <code>LoggerA</code>  <code>LoggerB</code> ),   ‚Äî  <code>LoggerA</code> .     <code>Update</code> ,       <code>LogB</code> ,    ,      <code>LoggerB</code>  ,    .    <code>LoggerA</code>     .        ,   ‚Äî  . </p><br><p>   ,    Angular2   ?        1-  .        ,                . </p><br><h2 id="vyvody">  findings </h2><br><ul><li>    Angular 2   , <code>OpaqueToken</code> ',   . -    -. </li><li>    ,  <code>OpaqueToken</code> . </li><li>      ,  Angular2-    . </li><li>     .          . </li><li>    ,   . </li><li>        . </li></ul><br><p>    : </p><br><ul><li>      .      .   <code>bootstrap</code>     . </li><li>          . </li><li>           ,      . </li><li>     (   )  -.    <code>OpaqueToken</code>      . </li><li>  -     ,      . ,  <em></em>       . </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/281449/">https://habr.com/ru/post/281449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281439/index.html">New contests for PHDays VI: we break hydroelectric power station and smart home</a></li>
<li><a href="../281441/index.html">Vostok-1 spacecraft in 3D - render in Blender</a></li>
<li><a href="../281443/index.html">PHP UK Conference 2016</a></li>
<li><a href="../281445/index.html">Who lost the keys: in the wake of SSH</a></li>
<li><a href="../281447/index.html">The largest coworking of the Moscow Region opened in Khimki near Moscow</a></li>
<li><a href="../281451/index.html">Controller board based on STM32F7 with video output</a></li>
<li><a href="../281453/index.html">Develop HTML5 games in Intel XDK. Part 2. Cocos2d-JS</a></li>
<li><a href="../281455/index.html">The use of machine learning methods in the task of assessing the actions of a pilot at the landing stage</a></li>
<li><a href="../281457/index.html">DataPro Data Center: cooling and fire suppression systems</a></li>
<li><a href="../281459/index.html">Hello, Bot! Chat bots - the next generation of applications?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>