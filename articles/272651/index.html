<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MongoDB as a monitoring tool for LOG files</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about using MongoDB non-relational database for monitoring log files. There are many tools for monitoring log files, from ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MongoDB as a monitoring tool for LOG files</h1><div class="post__text post__text-html js-mediator-article">  In this article I will talk about using MongoDB non-relational database for monitoring log files.  There are many tools for monitoring log files, from monitoring with shell scripts tied to cron to an apache hadoop cluster. <br><br> <a href="http://habrahabr.ru/company/at_consulting/blog/272651/"><img src="https://habrastorage.org/files/164/e78/021/164e780210cd4cb99faf4fadaf32b4ed.jpg"></a> <br><br>  The approach with monitoring scripts of text files is convenient only in the simplest cases, when, for example, problems are detected by the presence of ERROR, FAILURE, SEVERE lines in the log file, etc.  To monitor large files, it is convenient to use the Zabbix system, where the Zabbix Agent (active) will only read new data and send it to the server at regular intervals. <br><a name="habracut"></a><br>  Up to a certain point, Zabbix has had enough, but for monitoring business processes, analyzing metrics within an SLA, more complex tasks often appear, for example: <br>  - determining the number of operations that have passed through the system during the time interval; <br>  - determination of the processing time of various operations; <br>  - identifying the percentage of errors, exceptions, broken down by operations and business data; <br>  - collection of statistics on non-monetary transactions, service level analysis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Typically, such tasks are a headache for system administrators who have to search for sophisticated methods of collecting, aggregating and presenting such data, if the system was not originally designed to calculate their collection. <br><br>  To solve these problems, we had to find a more flexible and universal solution. <br><br>  Initially, I had to teach an application to write logs using structured documents in MongoDB using a java driver.  The data model was specifically designed to store unified documents in JSON format. <br><br>  The advantages of this method are the lack of delay in obtaining new data (as in the case of apache hadoop), the presence of replication and, if necessary, segmentation, convenient means of sampling and analyzing data using the MongoDB API, mapReduce and JavaScript functions, but first things first. <br><br><h2>  <font color="#00a9c0">Example</font> </h2><br>  Suppose an application writes documents to the database: <br><br><pre><code class="hljs vbscript">{ _id: ObjectId id: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> operation: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: ISODate data: { info: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> result: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> message: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>: [a1, a2, ... ,aN] }</code> </pre> <br>  Having a collection of such documents, using a simple query, we can understand how many test operations the application has performed in the last 5 minutes: <br><br><pre> <code class="hljs pgsql">db.test.count({ "operation": "test", "time": {$gte: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>() - <span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">5</span></span>)} })</code> </pre> <br>  Such a request is easy to ‚Äúwrap‚Äù in a shell script that will connect to mongo, and output its result to the terminal.  This script can later be connected to the monitoring system, which we did by getting a graphic chart and ‚Äúhanging‚Äù the triggers on inappropriate values. <br><br>  For the query to be executed quickly, it suffices to build a single index <code>db.test.ensureIndex( {time: 1}, {background: true} )</code> .  Then MongoDB will only look at the data for the last 5 minutes, and not all documents in the collection.  You can add several more indices at once, but if there are too many of them, for each <code>insert</code> operation, the binary trees corresponding to them will be appended, which creates additional load.  And at some point, the indexes may not fit in the RAM, then reading will occur from the disk, which will significantly slow down data access. <br><br><h2>  <font color="#00a9c0">Work with dates</font> </h2><br>  The field of time (in this case, time) I used most often.  At the beginning of working with the MongoDB shell, it would be easy to find information on drawing up simplest queries, but there were problems with queries by date.  I will describe several ways how to select documents in the specified time interval. <br><br>  If the application inserts a <code>new Date()</code> in the time field of an insert operation, the date will be written in ISODate format.  Entering the <code>new Date()</code> command in the mongo shell console will display the current date in the format <code>ISODate("YYYY-MM-DDThh:mm:ss[.sss]Z")</code> - you can take this line and substitute it in the query like: <br><br>  <code>db.test.find({ time: {$gte: ISODate("YYYY-MM-DDThh:mm:ss[.sss]"), $lte: ISODate("YYYY-MM-DDThh:mm:ss[.sss]")} })</code> , where <code>$gte</code> is greater than or equal to, <code>$lte</code> is less than or equal to, <code>[.sss]</code> is the number of milliseconds. <br><br>  You can also directly set the date via <code>new Date()</code> : <br><br>  <code>db.test.find({ time: {$gte: new Date(YYYY, MM, DD, hh, mm, ss, sss) } })</code> , where the months count (MM) starts at 0. <br><br>  or <br><br>  <code>db.test.find({ time: {$gte: new Date( new Date() -1000*300 ) } })</code> - display documents in the last 5 minutes.  Instead of the expression <code>"-1000*300"</code> you can substitute any time in milliseconds.  Also, before the request, you can pre-define variables with dates: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> today = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> yesterday = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); yesterday.setDate(today.getDate() - <span class="hljs-number"><span class="hljs-number">1</span></span>); db.test.find( {<span class="hljs-string"><span class="hljs-string">"time"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">$gte</span></span> : yesterday, <span class="hljs-attr"><span class="hljs-attr">$lt</span></span> : today} } );</code> </pre> <br>  In some cases it is convenient to use POSIX, for example: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = today.getTime(); i &lt; yesterday.getTime(); i=i+<span class="hljs-number"><span class="hljs-number">300</span></span>*<span class="hljs-number"><span class="hljs-number">1000</span></span>) {var b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b = db.test.find({ <span class="hljs-string"><span class="hljs-string">"time"</span></span>: { $gte: new Date(i), $lte: new Date(i+<span class="hljs-number"><span class="hljs-number">300</span></span>*<span class="hljs-number"><span class="hljs-number">1000</span></span>) } //   getTime   POSIX    }).count(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .count()     <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>=new Date(i); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     i <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(b+<span class="hljs-string"><span class="hljs-string">"; "</span></span>+time.toTimeString().<span class="hljs-keyword"><span class="hljs-keyword">split</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) } //    (b) +  <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>   timeString,   <span class="hljs-keyword"><span class="hljs-keyword">split</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]      .</code> </pre> <br>  After the execution of this request, we will receive in the console the total number of documents that have passed through the system, broken down into 5-minute intervals per day. <br><br><h2>  <font color="#00a9c0">ForEach method</font> </h2><br>  Since JSON-like aggregation output is often inconvenient, the <code>.forEach()</code> method helps, which is applied to the cursor and is able to modify the document in an arbitrary way using javascript. <br><br>  For example, you need to display a list of <code>id</code> for a specified period of time (take the last 5 minutes): <br><br><pre> <code class="hljs php">db.test.aggregate({$match:{time:{$gte:<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date()<span class="hljs-number"><span class="hljs-number">-1000</span></span>*<span class="hljs-number"><span class="hljs-number">300</span></span>)}}}).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>( doc.id ) } )</code> </pre> <br>  Instead of <code>aggregate</code> in this case, you can use <code>find</code> or <code>distinct</code> - the main thing is that the input <code>forEach()</code> an array.  Since the format of the aggregation output somewhat changed from version to version, in version 2.6, for example, you should use <code>aggregate({...},...,{...}).result.forEach</code> , since the output has the format <code>"result":[{...},...,{...}]</code> . <br><br>  Another example: you need to find out what the final status of each <code>id</code> and unload into the table. <br><br><pre> <code class="hljs perl">db.cbh.aggregate( {$match: {<span class="hljs-keyword"><span class="hljs-keyword">time</span></span>: {$gte: new Date(new Date()-<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">300</span></span>)}}}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     {$group: { _id: <span class="hljs-string"><span class="hljs-string">"$id"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   id <span class="hljs-string"><span class="hljs-string">"count"</span></span>: {$sum:<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      id <span class="hljs-string"><span class="hljs-string">"result"</span></span>: {$push:<span class="hljs-string"><span class="hljs-string">"$data.result"</span></span>} //     } }, {$match: { <span class="hljs-string"><span class="hljs-string">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  id   <span class="hljs-number"><span class="hljs-number">4</span></span>  {$match: { <span class="hljs-string"><span class="hljs-string">"result"</span></span>: { $ne:[] }}} //   result ).result.forEach(function(doc) {<span class="hljs-keyword"><span class="hljs-keyword">print</span></span>( doc._id+<span class="hljs-string"><span class="hljs-string">", "</span></span>+doc.result )} )</code> </pre> <br>  Such a query will output to the console the result of the form ‚Äú <code>id, data.result</code> ‚Äù, which can be imported into excel or any relational DBMS. <br><br><h2>  <font color="#00a9c0">Functions</font> </h2><br>  With the help of functions it is convenient to count metrics, complex monitoring requests, generate reports.  I will give an example of a simple function for calculating the average time of an operation. <br><br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avgDur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(operation, period)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> avg=<span class="hljs-number"><span class="hljs-number">0</span></span>; db.test.aggregate( { $match : { <span class="hljs-string"><span class="hljs-string">"time"</span></span> : { $gte : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date - period*<span class="hljs-number"><span class="hljs-number">1000</span></span>) } } }, { $group : {_id: <span class="hljs-string"><span class="hljs-string">"$id"</span></span>, <span class="hljs-string"><span class="hljs-string">"operation"</span></span>:{$addToSet : <span class="hljs-string"><span class="hljs-string">"$operation"</span></span>}, <span class="hljs-string"><span class="hljs-string">"time"</span></span>:{$push : <span class="hljs-string"><span class="hljs-string">"$time"</span></span>}, <span class="hljs-string"><span class="hljs-string">"count"</span></span>:{$sum: <span class="hljs-number"><span class="hljs-number">1</span></span>} } }, { $match : {<span class="hljs-string"><span class="hljs-string">"operation"</span></span>: operation, <span class="hljs-string"><span class="hljs-string">"count"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> }, { $project : {_id:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}} ).result.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op)</span></span></span><span class="hljs-function"> </span></span>{ dur=op.time[<span class="hljs-number"><span class="hljs-number">3</span></span>]-op.time[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sum=sum+dur; i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; }); avg=sum/i; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(avg/<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br>  Before saving the function, it is better to run it in the console, <code>avgDur(test,300)</code> and check its operation.  Next, save it: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">db</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.system</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.save</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">_id</span></span>: <span class="hljs-string"><span class="hljs-string">"avgDur"</span></span>, value : <span class="hljs-built_in"><span class="hljs-built_in">function</span></span>(operation, period) { ... } } )</code> </pre> <br>  After that, run <code>db.loadServerScripts();</code>  and call the <code>avgDur(test,300)</code> . <br><br>  If you save an invalid function, with <code>db.loadServerScripts()</code> we can get an error and cannot access other functions, so we check carefully before saving. <br><br><h2>  <font color="#00a9c0">Underwater rocks</font> </h2><br>  The first thing I encountered on the server without replication was the difficulty of freeing up disk space.  MongoDB writes documents to the disk in a row, and if you manually delete part of the collection with the <code>db.test.remove({...})</code> command, the disk space will not be freed, because  this would cause severe fragmentation.  In order to avoid this, MongoDB leaves all documents in place, and adds links in the gaps.  Then, in order to ‚Äúcompress the collection‚Äù, you need to execute <code>db.repairDatabase()</code> , but the command will require as much disk space as the database takes, since  first, the base is copied to the new location, and only then the files of the old base are deleted. <br><br>  To avoid such problems, I found several solutions that can be combined: <br><br>  <b>1.</b> Replication.  If there is a backup server, you can always stop the slave replica, perform <code>repairDatabase()</code> and start the server back.  It is even <a href="https://docs.mongodb.org/manual/core/index-ttl/">better to set up a TTL</a> (time-to-live) index, where the documents themselves will be deleted after a certain lifetime, for example, after 30 days.  But in this case, you still have to periodically <code>repairDatabase()</code> . <br><br>  <b>2.</b> Create a collection of a limited amount of <a href="https://docs.mongodb.org/manual/core/capped-collections/">Capped collection</a> immediately.  When the collection reaches its limit, the oldest documents will begin to be overwritten with the newest ones. <br><br>  <b>3.</b> See how much disk space the collection will take after 30 days of logging, then <a href="https://docs.mongodb.org/manual/reference/command/convertToCapped/">convertToCapped</a> this collection and set the limit with a margin. <br><br>  <b>4.</b> Write temporary collections to a separate database, since  when <code>db.dropDatabase()</code> executed, disk space will be guaranteed free.  But <code>db.collectioName.drop ()</code> , unfortunately, does not free disk space.  Data is simply marked as inaccessible. <br><br>  Starting from version 2.6, the preallocation strategy has changed a little, the default for the collection is the <a href="https://docs.mongodb.org/master/release-notes/2.6/">usePowerOf2Sizes</a> option.  The disk space freed up as a result of deleting documents has become more efficient, but it is safer to initially determine the size of the collection. <br><br><h2>  <font color="#00a9c0">Aggregation of large amounts of data</font> </h2><br>  Aggregation is not the best tool for processing huge amounts of data: it will be difficult to aggregate 100 million documents, such as in the example above. <br><br>  The first constraint that you have to face is that the size of the resulting document should not exceed 16 MB.  However, starting from version 2.6, the result of the aggregation is passed as a cursor, and using the <code>cursor.next()</code> method applied to the cursor, you can select the necessary data sequentially. <br><br>  There is also a limit of 64 MB to use when processing the buffer, which can overflow with so many documents.  Starting with version 2.6, the <code>{allowDisckUse:true}</code> aggregation parameter helps to avoid this. <br><br>  Large data volumes are best handled by mapReduse, where multi-thread processing is used, as well as load distribution between servers in a segmented cluster. <br><br>  But all this stuff.  Real flours will begin if the data scheme is not suitable for mongodb, when there are tasks requiring data binding from several collections or a recursive approach in document search and aggregation. <br><br>  I will give an example: <br><br>  Suppose you need to calculate the average time to complete all successful operations.  But if the transaction logging approach involves recording documents of the type ‚Äúrequest‚Äù and ‚Äúanswer‚Äù, and there will be several such documents in one transaction, then in our scheme the ‚Äúdata.result‚Äù field with the result of the transaction will appear only in the last document of the series. <br><br>  So how do you calculate time in this case?  If in the aggregation in the <code>$match</code> block we search for all documents with <code>"data.result":"SUCCESS"</code> , then only the latest documents inside each <code>id</code> will be <code>"data.result":"SUCCESS"</code> in the selection.  The mapReduce paradigm will not help here either, since  at the stage of the map MongoDB passes through the collection only 1 time. <br><br>  You can go through the collection and build an array with all the necessary <code>id</code> and perform aggregation, substituting this array in <code>$match</code> : <br><br><pre> <code class="hljs coffeescript">ids=[]; var monthBegin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getFullYear(),<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getMonth()<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) var monthEnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getFullYear(),<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getMonth(),<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(),   YYYY   ,   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getFullYear(),   MM  <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getMonth()  <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getMonth()<span class="hljs-number"><span class="hljs-number">-1</span></span>     . db.test.find({time:{$gte:monthBegin, $lt:monthEnd}, <span class="hljs-string"><span class="hljs-string">"operation"</span></span>:<span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"data.result"</span></span>:<span class="hljs-string"><span class="hljs-string">"SUCCESS"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} ).forEach(function(op) { ids.push(op.id) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   id     }); db.test.aggregate( {$match:{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:{$in:ids}}}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    id   {...} )</code> </pre> <br>  However, it should be understood that this array will be in memory all this time, and if there are several million elements in it, there is a high probability of getting out of memory.  To avoid problems with memory allocation, you can write ‚Äúprepared data‚Äù into a new collection: <br><br><pre> <code class="hljs lua">db.getSiblingDB(<span class="hljs-string"><span class="hljs-string">"testDb"</span></span>).test.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>({ <span class="hljs-string"><span class="hljs-string">"time"</span></span> : { $gte : new Date(monthBegin.getTime()), $lte : new Date(monthEnd.getTime()) }, <span class="hljs-string"><span class="hljs-string">"operation"</span></span> : <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"data.result"</span></span> : <span class="hljs-string"><span class="hljs-string">"SUCCESS"</span></span> }).addOption(DBQuery.Option.noTimeout).forEach( //   noTimeout   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc)</span></span></span></span> { db.test.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>({<span class="hljs-string"><span class="hljs-string">"id"</span></span> : doc.id}).forEach( //    id,      <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span></span> { db.getSiblingDB(<span class="hljs-string"><span class="hljs-string">"anotherDb"</span></span>).newTest.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>({ //      id     . <span class="hljs-string"><span class="hljs-string">"id"</span></span> : doc.id, <span class="hljs-string"><span class="hljs-string">"time"</span></span> : row.<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>, }); } ); } );</code> </pre> <br>  Thus, we recorded a new collection with documents like <code>{id:sting, time:ISODate(...)}</code> .  Next, we perform a simple aggregation of the new collection and get the desired result: <br><br><pre> <code class="hljs php">i=<span class="hljs-number"><span class="hljs-number">0</span></span>; sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; avg=<span class="hljs-number"><span class="hljs-number">0</span></span>; db.getSiblingDB(<span class="hljs-string"><span class="hljs-string">"anotherDb"</span></span>).newTest.aggregate( {$group:{_id:<span class="hljs-string"><span class="hljs-string">"$id"</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span>:{$push:<span class="hljs-string"><span class="hljs-string">"$time"</span></span>}, }} ).result.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op)</span></span></span><span class="hljs-function"> </span></span>{ dur=op.time[op.time.length<span class="hljs-number"><span class="hljs-number">-1</span></span>]-op.time[<span class="hljs-number"><span class="hljs-number">0</span></span>] sum=sum+dur; i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(sum/i) <span class="hljs-comment"><span class="hljs-comment">//  .</span></span></code> </pre> <br>  Thus, the approach described above has made it possible to simplify the search for the necessary records, set up very accurate monitoring at all levels, and also generate reports and statistics based only on log data from MongoDB.  Management of data from the application and ease of deployment will save development time. <br><br>  However, the MongoDB data scheme is not suitable for every project.  If it is known that a recursive approach to data retrieval or join is not required, most likely, there will be no serious problems! </div><p>Source: <a href="https://habr.com/ru/post/272651/">https://habr.com/ru/post/272651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272641/index.html">FireEye Specialists Discover New Bootkit</a></li>
<li><a href="../272643/index.html">Implementing automatic restarting of failed tests in the current build and overcoming attendant troubles</a></li>
<li><a href="../272645/index.html">How Cloud Foundry is Developed</a></li>
<li><a href="../272647/index.html">IBM cloud service translates applications into 9 languages</a></li>
<li><a href="../272649/index.html">Photoshop for coder (programmer)</a></li>
<li><a href="../272653/index.html">On the other side of the game: an open course on game design</a></li>
<li><a href="../272655/index.html">How we taught 1C to generate an IVR menu for Asterisk</a></li>
<li><a href="../272657/index.html">Architecture IoT-solutions on a real example</a></li>
<li><a href="../272659/index.html">Next, in search of palindromes 3</a></li>
<li><a href="../272661/index.html">NOT unlimited mailbox, or Tale about the secret limitation of Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>