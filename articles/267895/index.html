<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a JavaScript Synthesizer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I had an idea to make a browser synthesizer quite a long time ago, even when the Audio API was in a very embryonic state and practically the only chan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a JavaScript Synthesizer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fac/bac/da0/facbacda06cf4c42afaf7868600804fa.png"><br><br>  I had an idea to make a browser synthesizer quite a long time ago, even when the Audio API was in a very embryonic state and practically the only chance to extract sound from the browser (except for playing finished files) was the generation of WAV with its subsequent encoding to base64 and writing to an audio tag.  And if the synthesis and coding succeeded without problems (WAV format is quite simple), then with streaming audio for playing in real time everything was worse and no tricks were able to achieve seamless buffering, and therefore the idea stalled, not having time to be born.  Over the years, browsers in the Audio API support have noticeably added, which in turn inspired me to new experiments in this area.  This article describes step by step the process of creating a browser-based synthesizer using HTML5 tools, starting with the generation of a simple sine wave, continuing with switching and modulation of signals and ending with audio effects. <br><a name="habracut"></a><br>  As a hobby musician, but a full-time programmer, I often catch up with musical ideas right at work, when there is no musical instrument at hand to estimate the realization, and ideally also to record.  Thus, the idea of ‚Äã‚Äãan online MIDI sequencer was first born, which would allow us to jot down and save most of the ideas.  But what kind of sequencer without the ability to play and record the melody that came to mind in real time "without departing from the cash register", using at least a mouse with a keyboard?  As a result, in the process of working on the simplest synthesizer, a little thought crept in and not to wipe us at anything bigger.  Of course, the idea of ‚Äã‚Äãa JavaScript synthesizer is not new, and realizations of varying degrees of persuasion continually <a href="http://www.audiotool.com/product/device/heisenberg">arose</a> here and there, but at least here, in Habr√©, I found only a few articles on the Audio API topic and not a single one concerning the synthesis that and prompted to sit behind this text. <br><br>  As was briefly noted in the preface, the first thing I thought about is the synthesis and processing of sound completely analytically and then encoded directly into the WAV format, but in the process of dealing with streaming playback of this format and scrolling through the documentation on related topics, the idea suddenly came up to try Audio API browsers, as described in MDN.  Audio API with no tweaks and minimal means makes it possible to create a virtual audio path from functional blocks, customizing and commuting them to your taste.  Practically all the necessary basic elements are presented in the API: oscillators, amplifiers, splitters, etc. I recommend referring to the <a href="https://developer.mozilla.org/en-US/docs/tag/Web%2520Audio%2520API">appropriate section of the MDN</a> for a complete list and usage examples, so the main issue is to correctly and conveniently switch and create and control effects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the first version, we need to determine the minimum functionality that we would like to implement.  As for me, it is absolutely necessary to choose the waveform (sine wave, sawtooth, meander), as well as effects such as vibrato (tone fluctuation), tremolo (volume variation) and echo.  In addition, from the classic functions I would like to see the ADSR-envelope setting, which is a simplified approximation of the phases of the intensity of the sound of a note played on a real musical instrument. <br><br>  Considering that tremolo and vibrato are modulating effects (amplitudes and pitch, respectively), the implementation of a universal modulator for any of the system parameters seems to be the most natural and flexible solution.  The whole point of modulators is that they can influence not only directly the signal parameters, but also the parameters of other seb-like modulators, obtaining possibilities limited for imagination to form sounds.  At one time, this idea was also the basis of analog synthesizers, but then the switching looked like this: <br><br><img src="https://habrastorage.org/files/3b0/c06/62c/3b0c0662c4e8405fbb4d5e1100d64194.jpg"><br><br>  Here it will look like this: <br><br><pre><code class="javascript hljs">synth.connect(volume); volume.connect(delay.input); delay.connect(pan); pan.connect(audioCtx.destination); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vibrato = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SineModulator(); vibrato.modulate(synth, <span class="hljs-string"><span class="hljs-string">'pitchShift'</span></span>);</code> </pre> <br>  Let's start with a simple sound synthesizing, for which we construct an AudioContext object, within which we create an oscillator, set its frequency, connect it to the audio output and then make it oscillate, producing the sound. <br><pre> <code class="javascript hljs"> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oscillator = audioContext.createOscillator() ; oscillator.frequency.value = <span class="hljs-number"><span class="hljs-number">440</span></span>; oscillator.connect(audioContext.destination); oscillator.start(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  If everything is done correctly, a pleasant sound should be heard in the speakers / headphones with the familiar frequency of a telephone hooter (or a tuning fork - here it is closer to someone).  You can stop this process by calling the appropriate .stop () medo of the same object.  By the way, the parameter passed to the start and stop functions is the time in seconds, after which the specified actions should be implemented in relation to the signal.  We do not need this yet, so the parameter is set to 0, but you can not specify it at all.  It is also necessary to pay attention to the .connect () and .disconnect () methods, which are part of the common for all AudioNode interface nodes and are used for switching their inputs and outputs.  By calling the .connect () oscillator, we specify to send the resulting audio signal to the node passed as a parameter, in this case audioContext.destination, which from the point of view of our program is the final point, directing the sound to the operating system for further playback. <br><br>  As the first function of our synthesizer, we implement the choice of waveform.  The most common waveforms (for example, saw or square wave) are available as part of the API and can be used by specifying the appropriate parameter for the oscillator (eg audioContext.createOscillator ('square')).  For more interesting cases, there is a PeriodicWave interface that allows you to specify the waveform of an arbitrary shape.  Two arrays with Fourier coefficients are passed to the function, the calculation of which for an arbitrary waveform can be easily found in the literature (for example, briefly <a href="http://mathworld.wolfram.com/FourierSeries.html">here</a> ).  So, for example, for the same sawtooth wave, which is the sum of all harmonics of a signal with a proportional decrease in amplitude, the coefficients for cosines (valid in complex recording) will be 0, and for sines (imaginary) 1 / n, i.e. look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dd5/0dc/f91/dd50dcf9172f49268a98211892add37a.png"></div><br><br>  Naturally, for greater sharpness of the saw, it is necessary to increase the number of folding harmonics.  The process is illustrated in animation: <br><br><img src="https://habrastorage.org/files/6b8/f8b/b7f/6b8f8bb7f3164ae2a33857379b9610ec.gif"><br><br>  Therefore, the calculation of the coefficients and their transfer to PeriodicWave for this signal will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> global.AudioContext(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> steps = <span class="hljs-number"><span class="hljs-number">128</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> global.Float32Array(steps); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> real = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> global.Float32Array(steps); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; steps; i++) { imag[i] = <span class="hljs-number"><span class="hljs-number">1</span></span> / (i * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wave = context.createPeriodicWave(real, imag); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = wave;</code> </pre><br>  The next step is the ability to select the pitch of the sound.  In real synthesizers, this is done through the keyboard, but we will construct an ersatz keyboard on the monitor screen for starters.  I‚Äôm not a designer, and I still couldn‚Äôt make a high-quality design, so I‚Äôll draw all the graphics by hand to disguise the poverty of my design ideas.  As a result, we have a keyboard with basic functions, as well as three waveforms to choose from: <br><br><img src="https://habrastorage.org/files/29e/dc0/568/29edc056800f4ecd93cf2c52961c0782.png"><br><br>  Each keystroke should send a signal to the synthesizer with information about the number of the note you want to play.  The same is true for the key release event.  Although classical synthesizers at first had one oscillator modulated by the pitch of a keystroke, due to the lack of technical limitations, I decided not to complicate life and make as many oscillators as needed to simultaneously play an arbitrary number of notes.  For convenient switching with subsequent modules, we agree to have one common output node to which all oscillators will be connected and which will mix all their signals in one stream.  The rule of one entry point and one exit point will be further applied for all subsequent modules.  The simplest GainNode with a gain of 1 (the default) is used as such a point.  Schematically it looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/56e/b8b/8e3/56eb8b8e3c1f4bf9bf589864c873cfb8.png" width="308" height="246"></div><br><br>  And in the code like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Synth</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioContext = context; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output = context.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._oscillators = {}; } Synth.prototype.play = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oscillator; oscillator = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._oscillators[note.pitch] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioContext.createOscillator(); oscillator.frequency.value = note.frequency; oscillator.connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output); oscillator.start(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oscillator; }; Synth.prototype.stop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._oscillators[note.pitch].stop(<span class="hljs-number"><span class="hljs-number">0</span></span>); };</code> </pre><br>  One of the basic functions, without which no device designed to produce sounds can be imagined, is to adjust the volume and balance of channels. For this, the Audio API provides the GainNode and StereoPanner interfaces, respectively.  Add them to the circuit, commuting with the help of the same connect method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> volume = audioContext.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pan = audioContext.createStereoPanner(); volume.gain.value = <span class="hljs-number"><span class="hljs-number">1</span></span>; pan.pan.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; synth.output.connect(volume); volume.connect(pan); pan.connect(audioContext.destination);</code> </pre><br>  To adjust the parameters, create two input fields and directly connect them to the corresponding nodes.  For reading and transferring the values, I created a simple object controls that implements the mediator pattern and sends the field values ‚Äã‚Äãto the interested as they change.  It makes no sense to dwell on its implementation, let‚Äôs focus better on what happens when a value changes in a field: <br><br><pre> <code class="javascript hljs">controls.on(<span class="hljs-string"><span class="hljs-string">'volume-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ volume.gain.value = value; }); controls.on(<span class="hljs-string"><span class="hljs-string">'pan-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ pan.pan.value = value; });</code> </pre><br>  Thinking ahead about the development of the vibrato effect, as well as about controlling the pitch by means of a physical lever on a MIDI device, add the ability to change the pitch for all sounds generated by the Synth module.  The function is implemented by the admixture to the source module: <br><br><div class="spoiler">  <b class="spoiler_title">PitchShifter code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PitchShifter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pitchShift = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oscillators = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"pitchShift"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ps</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pitchShift = ps; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pitch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> oscillators) { oscillators[pitch].frequency.value = oscillators[pitch].baseFrequency * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pitchShift/<span class="hljs-number"><span class="hljs-number">1200</span></span>); } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pitchShift; } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> old = { <span class="hljs-attr"><span class="hljs-attr">play</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.play, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stop }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.play = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> osc = oscillators[note.pitch] = old.play.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, note); osc.baseFrequency = note.frequency; osc.frequency.value = osc.baseFrequency * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pitchShift/<span class="hljs-number"><span class="hljs-number">1200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osc; }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oscillators[note.pitch]; old.stop.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; }</code> </pre></div></div><br>  Here we are closer to the implementation of the first effect - vibrato, i.e.  periodic change of tone in height.  For these purposes, as mentioned, we will conclude a modulator, and, as planned, the modulator should be implemented in such a way that it can modulate any system parameter, including the properties of other modulators, such as amplitude and frequency. <br><br>  <i>( <b>UPD</b> : in the comments rightly hinted at the non-optimal approach with intervals, especially considering that the oscillators can control the parameters directly, which I did not know at the time of writing this article, therefore the part about modulators is more theoretical than practical value)</i> <br><br>  The first problem with which there is a risk of encountering a ‚Äúhead-on‚Äù frequency change is a jump between signal levels, which, unfortunately, is also clearly audible, as can be seen in the following illustration: <br><br><img src="https://habrastorage.org/files/942/78f/8a2/94278f8a25a0429d8c6f75bad60ef030.gif"><br><br>  Moreover, the difference in the phases of the previous and subsequent sinusoids depends on the current point in time, which makes it very ugly.  To avoid this undesirable effect, when changing the frequency, it is necessary to compress or stretch the sinusoid not relative to zero, but relative to the current point along the X axis. For this, the phase of the signal will be permanently stored in the object and used as a reference point when calculating further amplitudes. <br><br><img src="https://habrastorage.org/files/d7a/497/f1f/d7a497f1f2be4b168e57a6696e1f3330.gif"><br><br>  The second important point in the implementation of modulators is their additivity.  Since theoretically the waveform obtained as a result of the addition of an arbitrary number of sinusoids has no limitations, having modulators that satisfy the additivity condition, we get additional scope for creativity. <br><br>  Taking into account the above conditions, we realize the necessary modulator: <br><br><div class="spoiler">  <b class="spoiler_title">Modulator Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SineModulator</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ options = options || {}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._frequency = options.frequency || <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._phaseOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._startedAt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._interval = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._prevValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = options.depth || <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"frequency"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">frequency</span></span></span><span class="hljs-function">) </span></span>{ frequency = <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(frequency); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._phaseOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._phaseNow(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._startedAt = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._frequency = frequency; }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._frequency; } }); } SineModulator.prototype.modulate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object, property</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._objToModulate = object; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._propertyToModulate = property; }; SineModulator.prototype.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._startedAt = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> this_ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._interval = setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = this_._modValueNow(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = value - this_._prevValue; this_._objToModulate[this_._propertyToModulate] += diff; this_._prevValue = value; }, <span class="hljs-number"><span class="hljs-number">10</span></span>); }; SineModulator.prototype._phaseNow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeDiff = (<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._startedAt) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phase = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._phaseOffset + timeDiff * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frequency % <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phase; }; SineModulator.prototype._modValueNow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phase = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._phaseNow(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin((phase) * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI) * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth; }; SineModulator.prototype.stop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ clearInterval(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._interval); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = SineModulator;</code> </pre></div></div><br>  Now that we have a modulator, we will try to make a cyclical change in pitch, while at the same time adding effect parameter input fields to the interface and linking them to the corresponding modulator properties. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vibrato = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SineModulator(); vibrato.modulate(synth, <span class="hljs-string"><span class="hljs-string">'pitchShift'</span></span>); controls.on(<span class="hljs-string"><span class="hljs-string">'vibrato-on-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value) ? vibrato.start() : vibrato.stop(); }); controls.on(<span class="hljs-string"><span class="hljs-string">'vibrato-depth-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ vibrato.depth = value; }); controls.on(<span class="hljs-string"><span class="hljs-string">'vibrato-freq-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ vibrato.frequency = value; });</code> </pre><br>  We start and analyze the resulting signal, we state the presence of vibration.  Effect achieved: <br><br><img src="https://habrastorage.org/files/f5d/b6b/b07/f5db6bb07a87417f8283196c414086cb.png"><br><br>  The next item on the list - tremolo - will be similar in principle, the only difference is the modulated parameter, this time it‚Äôs loudness.  The code for this effect is also minimalistic and almost identical: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tremolo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SineModulator(); tremolo.modulate(volume.gain, <span class="hljs-string"><span class="hljs-string">'value'</span></span>); controls.on(<span class="hljs-string"><span class="hljs-string">'tremolo-on-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value) ? tremolo.start() : tremolo.stop(); }); controls.on(<span class="hljs-string"><span class="hljs-string">'tremolo-depth-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ tremolo.depth = value; }); controls.on(<span class="hljs-string"><span class="hljs-string">'tremolo-freq-change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ tremolo.frequency = value; });</code> </pre><br>  Having two modulation data and combining, or vice versa spreading, their frequencies, you can already get effects that are quite interesting in sound, and making the periods mutually simple, and amplitudes wide, even catch an unprepared listener unawares with chaos and unpredictability! <br><br>  The next logical step is to try to follow the level above and modulate one of the parameters of any of the existing modulators, for example, the frequency of the vibrato, as a result of which the effect of playing on the speed of vibration should be obtained.  To achieve this, we will create two modulators and assign one of them as a modulated parameter to the frequency property of the second: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vibrato = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SineModulator(); vibrato2.modulate(synth, <span class="hljs-string"><span class="hljs-string">'pitchShift'</span></span>) vibrato2.frequency = <span class="hljs-number"><span class="hljs-number">5</span></span>; vibrato2.depth = <span class="hljs-number"><span class="hljs-number">50</span></span>; vibrato.modulate(synth, <span class="hljs-string"><span class="hljs-string">'pitchShift'</span></span>); vibrato.start(); vibrato2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SineModulator(); vibrato2.modulate(vibrato, <span class="hljs-string"><span class="hljs-string">'frequency'</span></span>); vibrato2.frequency = <span class="hljs-number"><span class="hljs-number">0.2</span></span>; vibrato2.depth = <span class="hljs-number"><span class="hljs-number">3</span></span>; vibrato2.start();</code> </pre><br>  The cyclic change in the frequency of the tone change is audible to the naked ear, the resulting signal, recorded and opened in the audio editor, looks appropriate (the higher density sections correspond to the sound with a higher frequency): <br><br><img src="https://habrastorage.org/files/948/62c/a7d/94862ca7d1ed46038c20583212317737.png"><br><br>  At this, experiments with modulations can be considered successful, and the effects realized.  Although modulation by an arbitrary signal can be achieved by adding sinusoids, in the future it would be much more convenient to have a set of pre-fabricated modulators, at least for the most commonly used waveforms (saw, square wave), for this scenario, you can create a set of designers by analogy with the existing SineModulator, and use the mechanism for specifying the waveform through the Fourier coefficients, applied by us when specifying the oscillator waveform.  This task is no longer directly related to the Audio API, so for now I propose to complete this topic and go on to implement the first non-modulating effect, namely, echo. <br><br>  In most cases, this effect is characterized by three parameters: the number of responses, the response time and the attenuation coefficient.  Working with the number of responses different from zero and one implies branching the signal and creating delay lines for each branch.  The delay line is a node that delays the passage of a signal for a certain period of time.  We will use the delay lines provided by the Audio API and created by the AudioContext.createDelay function.  The presence of the attenuation coefficient turns each of the branches into a circuit of the delay line - amplifier.  In addition, we need to switch between a pure signal and a signal with an effect, as well as to ensure the possibility of simple switching with the previous and subsequent links of the path (remember the agreement to have one input and one output), which ultimately results in the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a15/d2b/0d9/a15d2b0d97a442ccb7cb053f718fae5a.png" width="438" height="280"></div><br><br>  Unfortunately, I did not find a way to create elements that would fully implement the AudioNode interface and which could be directly used as parameters for the connect method of other nodes.  The Internet search also did not give any result, so in the end I followed the advice given by supposedly knowledgeable people on the Internet, the essence of which boils down to the fact that the object is a container for a set of standard nodes, and the connection to the input is not directly, but through the input property, which is the base node GainNode. <br><br>  Tests, implementation, run.  We have a wave of the following form: <br><br><img src="https://habrastorage.org/files/331/601/c49/331601c49f874eb392fa4d68caac6de4.png" width="283" height="192"><br><br>  Reached here by such code: <br><br><div class="spoiler">  <b class="spoiler_title">Echo implementation</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">audioCtx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._audioCtx = audioCtx; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input = audioCtx.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLines = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._gainNodes = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLinesInput = audioCtx.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._output = audioCtx.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._taps = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._latency = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._feedback = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"feedback"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">freq</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._feedback = freq; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._applyParams(); }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._feedback; } }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"latency"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">freq</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._latency = freq; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._applyParams(); }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._latency; } }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"taps"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prevTaps = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._taps; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = value - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._taps; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; diff; i++) { diff &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._popTap() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pushTap(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._taps = value; }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._taps; } }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input.connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._output); } Delay.prototype._applyParams = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLines.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLines[i].delayTime.value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._latency / <span class="hljs-number"><span class="hljs-number">1000</span></span> * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._gainNodes[i].gain.value = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._feedback, (<span class="hljs-number"><span class="hljs-number">1</span></span> + i)) } }; Delay.prototype._pushTap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delay = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._audioCtx.createDelay(<span class="hljs-number"><span class="hljs-number">10.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLines.push(delay); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gainNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._audioCtx.createGain(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._gainNodes.push(gainNode); gainNode.connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._output); delay.connect(gainNode); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLinesInput.connect(delay); }; Delay.prototype._popTap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastDelayLine = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLines.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastGainNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._gainNodes.pop(); lastDelayLine.disconnect(lastGainNode); lastGainNode.disconnect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._output); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLinesInput.disconnect(lastDelayLine); }; Delay.prototype.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._started) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input.connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLinesInput); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._started = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } Delay.prototype.stop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._started) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input.disconnect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._delayLinesInput); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._started = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }; Delay.prototype.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._output.connect(target); }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Delay;</code> </pre><br></div></div><br>  Progress is evident: the sounds resulting from the application of effects largely possess the musicality <s>and spirit of the old school</s> .  The only thing that cuts off hearing is unaesthetic clicks when you turn off oscillators, they are visible in the previous graph, and they especially rush to the ears when using echo, since in this case each one of them repeats many times, moreover, during the sound of other notes. <br><br>  To overcome this effect in particular, but in terms of its main function, to give dynamics, we can be helped by the so-called ADSR envelope (Attack-Decay-Sustain-Release), which characterizes the shape of the synthesized wave in time, approximately describing the behavior of the sound taken on a real musical instrument. <br><br><img src="https://habrastorage.org/files/1fd/8ae/6e1/1fd8ae6e18f142c5b059f97ba5f5ab13.png" width="399" height="261"><br><br>  By applying such an envelope to each reproduced note, as a result of a gradual increase and attenuation of the volume, we remove the jump-like stall with a vertical front, which the ear perceives as a high-frequency click.  The implementation, as in the case of the pitch shift - impurity directly to the synthesizer.  When creating each of the oscillators, we wedge an amplifier between it and the output node, subsequently controlling the gain in accordance with the specified parameters of the ADSR envelope: <br><br><div class="spoiler">  <b class="spoiler_title">A piece of code is longer</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADSR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR = { <span class="hljs-attr"><span class="hljs-attr">A</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">D</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">S</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">R</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oscillators = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gainNodes = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> old = { <span class="hljs-attr"><span class="hljs-attr">play</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.play, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stop }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.play = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> osc = oscillators[note.pitch] = old.play.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, note); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gain = gainNodes[note.pitch] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioContext.createGain(); osc.disconnect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output); osc.connect(gain); gain.connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output); gain.gain.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.A = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.A); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.D = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.D); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.S = <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.S); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.R = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ADSR.R); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> this_ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startedAt = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interval = setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - startedAt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &lt; this_.ADSR.A) { gain.gain.value = diff / this_.ADSR.A; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &lt; this_.ADSR.A + this_.ADSR.D) { gain.gain.value = <span class="hljs-number"><span class="hljs-number">1</span></span> - (diff - this_.ADSR.A) / (this_.ADSR.D / (<span class="hljs-number"><span class="hljs-number">1</span></span> - this_.ADSR.S)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gain.gain.value = this_.ADSR.S; clearInterval(interval); } }, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osc; }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">note</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> releasedAt = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> this_ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arguments_ = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gain = gainNodes[note.pitch]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> osc = oscillators[note.pitch]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gainOnRelease = gain.gain.value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interval = setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - releasedAt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &lt; this_.ADSR.R) { gain.gain.value = gainOnRelease * (<span class="hljs-number"><span class="hljs-number">1</span></span> - diff / this_.ADSR.R); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clearInterval(interval); gain.gain.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; old.stop.apply(this_, arguments_); osc.disconnect(gainNodes[note.pitch]); gain.disconnect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oscillators[note.pitch]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> gain[note.pitch]; } }, <span class="hljs-number"><span class="hljs-number">20</span></span>); }; } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = ADSR;</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/a33/a59/2e0/a33a592e0a5f4ce09bb2d0acaafc8631.png"><br><br>  So, having made this stroke, we got a completely functional basic synthesizer that generates sounds suitable for human listening.  Further steps to improve could be interface changes such as, for example, visual creation, tuning and switching of oscillators and modulators, and directly to the synthesis, adding filters, introducing harmonics, nonlinear distortions and other things, but this is a topic for further research.  In future articles, we plan to connect MIDI instruments to the resulting synthesizer, in particular, a keyboard and a guitar, as well as to switch to sound recording and real audio effects.  All this, of course, in the browser! <br><br>  The program demonstration is available at the following link: <a href="https://miroshko.github.io/Synzer/">miroshko.github.io/Synzer</a> <br><br>  All source code is available on github: <a href="https://github.com/miroshko/Synzer">github.com/miroshko/Synzer</a> , I will be glad to have asterisks, forks, and pull requests. </div><p>Source: <a href="https://habr.com/ru/post/267895/">https://habr.com/ru/post/267895/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267881/index.html">12 typical database backup errors</a></li>
<li><a href="../267883/index.html">Optimization of communication channels for mining in the north of Russia</a></li>
<li><a href="../267887/index.html">.sorting in Perl 6</a></li>
<li><a href="../267889/index.html">GitFlow and Semantic Versioning for every day</a></li>
<li><a href="../267893/index.html">Checking Appleseed source code</a></li>
<li><a href="../267899/index.html">Online Trading: How to become a developer of systems for trading on the exchange</a></li>
<li><a href="../267901/index.html">The digest of news from the world of development on Unity</a></li>
<li><a href="../267903/index.html">Common Python problems and solutions (translation)</a></li>
<li><a href="../267905/index.html">Egret Free open source HTML5 game engine</a></li>
<li><a href="../267907/index.html">SAP Afaria. Small SMS for hacking a large company</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>