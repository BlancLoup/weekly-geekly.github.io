<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[Translation] Why Go is not so good</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Recently a translation of an article about how TJ Holowaychuk was saying goodbye to Node.js, deciding to move towards Go, was released. At the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[Translation] Why Go is not so good</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Recently a <a href="http://habrahabr.ru/post/228751/">translation of an article</a> about how <a href="https://github.com/visionmedia">TJ Holowaychuk was saying</a> goodbye to Node.js, deciding to move towards Go, was released.  At the end of the article there was a link to <a href="https://github.com/wyager/">Will Yager's</a> <a href="http://yager.io/programming/go.html">post</a> on the comparison and criticism of the Go language, which they were asked to translate - in fact, I suggest that you read the results of the translation.  I tried more or less to preserve both the verbose writing style inherent in the author and the original breakdown into sentences and paragraphs. <br>  I would be very happy with any constructive comments and suggestions for translation, misprints and / or design, but please remember that the translator‚Äôs point of view may not coincide with the position of the author of the translated article. <br><a name="habracut"></a><br><h4>  Why go is not so good </h4><br>  I like Go.  I use it for some things (including this blog at the time of this writing).  Go comfortable.  However, Go cannot be called a good language.  Of course, he is not bad, but not good. <br><br>  You need to be careful in using languages ‚Äã‚Äãthat are not too good, because in the end you can get stuck and have to use them for 20 years [as with PHP - approx.  translator]. <br>  Below I give a list of my main complaints about Go;  some of them are quite common, and some are very rare. <br><br>  I will also give comparisons with the <a href="http://www.rust-lang.org/">Rust</a> and <a href="http://www.haskell.org/">Haskell languages</a> (which I consider to be good languages) - in order to show that the problems I‚Äôm going to talk about are in fact already solved [in other languages ‚Äã‚Äã- approx.  translator]. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Generalizations </h4><br><h5>  The essence of the problem </h5><br>  Suppose we want to write code that we could use for a lot of different things.  For example, if I write a function for summing a list of numbers, it would be nice if I could use it for lists of floating-point numbers, lists of integers, lists of any other type of elements that can also be summed.  It would also be cool if this code provided the same type safety and speed as the individual functions for each type - the function of summation of lists of integers, lists of numbers with floating point, etc. <br><br><h5>  The correct approach: <a href="http://en.wikipedia.org/wiki/Generic_programming">generalizations</a> <a href="http://en.wikipedia.org/wiki/Constraint_programming">with restrictions</a> and <a href="http://en.wikipedia.org/wiki/Parametric_polymorphism">parametric polymorphism</a> </h5><br>  I think the best existing implementations of generalizations are those that are present in the Rust and Haskell languages ‚Äã‚Äã(they can also be called ‚Äúsystems with limited types‚Äù).  The version from Haskell is called ‚Äútype classes‚Äù, and the variant from Rust is called ‚Äútreit‚Äù [or ‚Äúadmixture‚Äù / ‚Äúmixin‚Äù, depending on the translation - approx.  translator].  They look like this: <br><br>  (Rust, <a href="http://habrahabr.ru/post/228485/">version 0.11</a> ) <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span></span>&lt;T&gt;(item: T) -&gt; T { item }</code> </pre> <br>  (Haskell) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">id</span></span> :: t -&gt; t id a = a</code> </pre><br>  In this synthetic example, we defined the function <code>id</code> with a generic parameter that simply returns the parameter passed to it.  The cool thing here is that this function works with any type, and not with any one.  In both Haskell and Rust, this function stores the type of the passed parameter, provides type safety, and does not create additional overhead during execution due to the support of generics.  By analogy, you can write, for example, the function <code>clone</code> . <br><br>  Generalizations can also be used to define data structures.  For example, <br><br>  (Rust) <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span></span>&lt;T&gt; { items: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt; }</code> </pre><br>  (Haskell) <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> t = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> [t]</span></span></code> </pre><br>  And again static type safety and the absence of performance loss during execution due to the support of generics are provided. <br><br>  If we want to write a generic function that does something with parameters, we need to somehow tell the compiler that this function can work only with parameters for which these actions are defined.  For example, if we want to define a function that would add three parameters and return their sum, we need to explain to the compiler that the parameters must support addition.  You can do it like this: <br><br>  (Rust) <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add3</span></span></span></span>&lt;T:Num&gt;(a:T, b:T, c:T) -&gt; T { a + b + c }</code> </pre><br>  (Haskell) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add3</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> t =&gt; t -&gt; t -&gt; t -&gt; t add3 abc = a + b + c</code> </pre><br>  Here, we kind of say to the compiler: ‚ÄúThe parameters of the function <code>add3</code> can be of any type <code>T</code> , but with the restriction that <code>T</code> must be one of the <code>Num</code> subtypes (numerical type)‚Äù.  Since the compiler knows that addition is defined for numeric types, the code will pass a type check.  Such constraints can also be used in defining data structures.  Well, this is a very elegant and easy way for type-safe and extensible programming with generalizations. <br><br><h5>  Go approach: <code>interface{}</code> </h5><br>  Due to the very mediocre type system, Go has very poor support for generic programming. <br><br>  Similarities of generic functions are written fairly easily.  For example, you would like to write a function that displays the hash of any object that can be hashed.  To do this, you can define an interface that allows you to do this with a type safety guarantee, that is, something like <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Hashable <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Hash() []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item Hashable)</span></span></span></span> { fmt.Println(item.Hash()) }</code> </pre><br>  Now you can pass any implementing interface to a <code>Hashable</code> object, and static type checking will also be performed, which is good in general. <br><br>  But what happens if you want to define a data structure with generic types?  Let's throw a simple <code>LinkedList</code> link type list.  Here is a typical way to do this in Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> LinkedList <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { value <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} next * LinkedList } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldNode * LinkedList)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkedList</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;LinkedList{value, oldNode} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkedList</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;LinkedList{value, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ll * LinkedList)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ll == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } fmt.Println(ll.value) traverse(ll.next) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node := tail(<span class="hljs-number"><span class="hljs-number">5</span></span>).prepend(<span class="hljs-number"><span class="hljs-number">6</span></span>).prepend(<span class="hljs-number"><span class="hljs-number">7</span></span>) traverse(node) }</code> </pre><br>  Did you notice anything?  Type field <code>value</code> - <code>interface{}</code> .  Here, <code>interface{}</code> is what we call the ‚Äúbase type,‚Äù which means that all other types inherit from it.  This is the direct equivalent of the <code>Object</code> class in Java.  Damn it. <br>  (Note: there is some disagreement about whether there is a base type in Go, since Go implies the absence of subtypes. Despite this, the analogy remains.) <br><br>  The ‚Äúright‚Äù way to build generalized structures in Go is to bring entities to the base type and then add them to the data structure.  This is about how it was taken in Java year in 2004.  Then people realized that this approach completely breaks the type system.  When data structures are used in this way, all the advantages of a strict type system simply evaporate [in fact, I don‚Äôt see a big problem here - instead of the basic <code>interface{}</code> you can, in principle, specify a more specific interface, bringing specific implementations to it and not crashing this way types - approx.  translator]. <br><br>  For example, here is an absolutely correct code: <br><br><pre> <code class="go hljs">node := tail(<span class="hljs-number"><span class="hljs-number">5</span></span>).prepend(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>).prepend([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>})</code> </pre><br>  This deprives a well-structured program of its advantages.  For example, the method expects a coherent list of integers as a parameter, but suddenly some tired, persistent coffee programmer with a deadline on the nose suddenly sends a string.  And the compiler will not notice anything, because the generalized structures in Go do not know anything about the types of their values, and one day the program will simply fall on the cast to <code>interface{}</code> . <br><br>  Similar problems can arise with any generalized structures - even with <code>list</code> , <code>map</code> , <code>graph</code> , <code>tree</code> , <code>queue</code> . <br><br><h4>  Language extensibility </h4><br><h5>  The essence of the problem </h5><br>  High-level languages ‚Äã‚Äãoften have keywords and symbols, which are shortcuts for more complex tasks.  For example, in many languages ‚Äã‚Äãthere is a way to bypass all the elements of data collections, at least the same arrays: <br><br>  (Java): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : names) { ... }</code> </pre><br>  (Python): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> names: ...</code> </pre><br>  It would be nice if we could use similar syntactic sugar for any collection, and not just for built-in language (like arrays). <br><br>  It would also be convenient if we could define operations like addition for our types of operation and write things like these: <br>  [Speech, for example, about <a href="http://en.wikipedia.org/wiki/Operator_overloading">operator overloading</a> - approx.  translator] <br><br><pre> <code class="python hljs">point3 = point1 + point2</code> </pre><br><h5>  The correct approach: operators are functions </h5><br>  A good decision is to make the operators "labels" to the corresponding functions / methods, and keywords - aliases to the standard functions / methods. <br><br>  Some languages: Python, Rust, Haskell, etc.  - allowed to redefine operators [and Haskell also define its own - approx.  translator].  All that needs to be done is to write the class methods, and then when using any operator (for example, " <code>+</code> ") the corresponding method is simply called.  In Python, the <code>+</code> operator calls <code>__add__()</code> .  In Rust, " <code>+</code> " is defined in the <code>Add</code> as <code>add()</code> method.  In Haskell, " <code>+</code> " corresponds to the <code>+</code> function defined in the <code>Num</code> type. <br><br>  Many languages ‚Äã‚Äãsupport a way to extend the scope of different keywords like <code>for-each</code> .  There are no loops in Haskell, but in languages ‚Äã‚Äãlike Rust, Java, and Python there are iterators that make it possible to use <code>for-each</code> with any collections of any type. <br><br>  The downside is that you can redefine the operators so that they will do something completely non-intuitive.  For example, bylokloder [orig.  "Crazy coder" - approx.  translator] can define the " <code>-</code> " operator as multiplication of two vectors, but this is still not the problem of operator overloading itself, since functions can be poorly called in any language. <br><br><h5>  Go approach: no </h5><br>  Go does not support operator overloading and keyword expansion. <br><br>  But what if we suddenly want to use the <code>range</code> keyword with something else ‚Äî a tree or a linked list?  Will not work.  Language does not support this.  You can use <code>range</code> only with embedded structures.  It is the same with <code>make</code> - it can be used to allocate memory and initialize only embedded structures. <br><br>  The closest available analogy of an extensible iterator is to write a wrapper over a data structure that returns <code>chan</code> ( <a href="http://www.golang-book.com/10/index.htm">channel</a> - comment of the translator), and then iterate through it, but this is slow, difficult, and can cause a lot of bugs. <br><br>  Such an approach is justified approximately as follows: ‚Äúit is easy to understand, and the code that is written to the page is the code that is being executed‚Äù.  That is, if Go would allow the expansion of <code>range</code> items, this could cause confusion, because the details of the <code>range</code> implementation for a particular case may not be obvious.  But for me, this argument means little, because people have to bypass data structures, regardless of whether it makes Go easy and convenient.  Instead of hiding the implementation details behind the <code>range</code> , we have to hide the implementation details behind another auxiliary function ‚Äî not too much like a big improvement.  Well-written code is easy to read, and poorly written code is difficult, and, obviously, Go cannot change this. <br><br><h4>  Basic cases and error checking </h4><br><h5>  The essence of the problem </h5><br>  When working with recursive data structures ‚Äî linked lists or trees ‚Äî we want to have a way to show that the end of the structure has not yet been reached. <br><br>  Using the same functions that can fail, or data structures that may lack any data, we want to be able to show that the task cannot be completed. <br><br><h5>  Go approach: <code>Nil</code> and multiple return values </h5><br>  I'm going to talk about the Go approach first, because after that it will be easier to explain the right approach. <br>  In Go there is a <code>nil</code> - <a href="http://en.wikipedia.org/wiki/Pointer_%2528computer_programming%2529">null pointer</a> .  I think it is shameful that such a new and modern language - so to speak, <a href="http://en.wikipedia.org/wiki/Tabula_rasa">tabula rasa</a> - implements this unnecessary, crutch functionality that leads to bugs. <br><br>  The null pointer has a long and buggy history.  For historical and practical reasons, the data used was almost never stored at <code>0x0</code> , so pointers to <code>0x0</code> were usually used to represent a particular situation.  For example, a function that returns a pointer may return <code>0x0</code> if it failed.  Recursive data structures can use <code>0x0</code> to define some basic case (like, say, the current tree node is a leaf, or that the current linked list item is the last).  For all this, a null pointer is used in Go. <br><br>  However, using a null pointer may be unsafe.  In fact, this pointer is a violation of the type system;  it allows you to create an instance of a type that is not really a type at all.  It is extremely common for a programmer to forget to check the pointer to zero, and this potentially leads to crashes and, in even more terrible cases, to vulnerabilities.  The compiler cannot simply take and protect against this, because the null pointer is knocked out of the adopted type system. <br><br>  To the credit of Go, it is correct and generally preferable to strengthen the mechanism of multiple return of values ‚Äã‚Äãadopted in Go, returning the second ‚Äúunsuccessful‚Äù value if there is a probability that the function failed.  However, this mechanism can easily be ignored or misused, and, as a rule, useless to represent basic cases in recursive data structures. <br><br><h5>  The correct approach: algebraic data types and type safe failures </h5><br>  Instead of violence over the type system to represent erroneous states or basic cases, we can use the type system to safely hide all of these situations. <br><br>  Suppose we want to implement a linked list.  We want to present two possible cases: first, if the end of the list is not yet reached and the current element has data, and, second, if the end of the list is reached.  A type-safe path involves the implementation of two types, respectively representing one of these cases, and then combining them together using algebraic data types.  Suppose we have type <code>Cons</code> , representing an element of a linked list with some data, and type <code>End</code> , which is the end of the list.  We can write this as follows: <br><br>  (Rust) <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;T&gt; { Cons(T, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;List&lt;T&gt;&gt;), End } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_list = Cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> End)));</code> </pre><br>  (Haskell) <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> t = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">End</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> t (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) let my_list = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> 1 (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> 2 (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> 3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">End</span></span></span><span class="hljs-class">))</span></span></code> </pre><br>  Each type defines a base case ( <code>End</code> ) for any recursive algorithm that performs operations on a data structure.  Neither Rust nor Haskell allow null pointers, so we are 100% sure that we will never encounter bugs related to null pointers (of course, as long as we don‚Äôt do some crazy low-level things). <br><br>  These algebraic data types also allow writing incredibly short (and therefore weakly subject to bugs) code due to such features of the language as <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> , as will be shown below. <br><br>  Well, and what should we do if the function can return or not return a value of some type, or if the data structure may or may not contain data?  That is, how can we hide the error state in our type system?  To solve this problem, Rust has something called <a href="http://doc.rust-lang.org/std/option/">Option</a> , and Haskell has something called <a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe">Maybe</a> . <br><br>  Imagine a function that looks for a string starting with an <code>'H'</code> in an array of non-empty strings, and returns the first matching string or some error if such a string is not found.  In Go, in case of an error, you would have to return <code>nil</code> .  And here is how we can do it safely and without crutches with pointers in Rust and Haskell: <br><br>  (Rust): <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(strings: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> strings.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> string.as_slice()[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'H'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(string.as_slice()); } } <span class="hljs-literal"><span class="hljs-literal">None</span></span> }</code> </pre><br>  (Haskell): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">search</span></span> [] = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> search (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (head x) == '<span class="hljs-type"><span class="hljs-type">H'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> search xs</code> </pre><br>  Instead of returning a string or null pointer, we return an object that may or may not contain a string.  We never return a null pointer, and developers using <code>search()</code> know that a function can complete successfully or unsuccessfully, because its type says so, and that they must be ready for both.  Farewell to the null pointer bugs! <br><br><h4>  Type inference </h4><br><h5>  The essence of the problem </h5><br>  It becomes a bit old-fashioned to indicate the type of each variable in the program code.  There are situations where the type of value is obvious: <br><br><pre> <code class="rust hljs">int x = <span class="hljs-number"><span class="hljs-number">5</span></span> y = x*<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  It is quite clear that <code>y</code> also of type <code>int</code> .  Of course, there are more complex situations, for example, the output of a type returned by a function based on the types of its parameters (or vice versa). <br><br><h5>  The right approach: general type inference </h5><br>  Since both Rust and Haskell are based on <a href="http://en.wikipedia.org/wiki/Hindley%25E2%2580%2593Milner_type_system">the Hindley-Milner type system</a> , they are both very good at type inference, and you can do these cool things: <br><br>  (Haskell): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">map</span></span> :: (a -&gt; b) -&gt; [a] -&gt; [b] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doubleNums nums = map (*<span class="hljs-number"><span class="hljs-number">2</span></span>) nums doubleNums :: <span class="hljs-type"><span class="hljs-type">Num</span></span> t =&gt; [t] -&gt; [t]</code> </pre><br>  Since the function <code>(*2)</code> takes a parameter of type <code>Num</code> and returns a value of type <code>Num</code> , Haskell can determine that the type is both <code>a</code> and <code>b</code> - <code>Num</code> , and from here it can infer that the function accepts and returns a list of values ‚Äã‚Äãof type <code>Num</code> .  It is much more powerful than those simple type inference systems that are supported by languages ‚Äã‚Äãlike Go and C ++.  This allows you to make the minimum number of explicit type indications, and the compiler can correctly determine everything else, even in very complex programs. <br><br><h5>  Go approach: operator <code>:=</code> </h5><br>  Go supports the assignment operator <code>:=</code> , which works like this: <br><br>  (Go): <br><br><pre> <code class="go hljs">foo := bar()</code> </pre><br>  All it does is output the type returned by the <code>bar()</code> function and assign the same to <code>foo</code> .  It turns out about the same as here: <br><br>  (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = bar();</code> </pre><br>  This is not very interesting.  All it does is eliminate the two-second effort to look at the type returned by the <code>bar()</code> function, and from writing a few characters of the type name of the variable <code>foo</code> . <br><br><h4>  <a href="http://en.wikipedia.org/wiki/Immutable_object">Immutability state</a> </h4><br><h5>  The essence of the problem </h5><br>  The immutability of the state (immobility) - the idea, the essence of which is that the values ‚Äã‚Äãare set only once at the time of creation and then cannot change.  The advantages of this approach are very obvious: if the values ‚Äã‚Äãare unchanged, the possibility of bugs caused by a change in the data structure in one place at the time of use in another place is significantly reduced. <br><br>  State immutability is also useful for some types of optimization. <br><br><h5>  The correct approach: default state immutability </h5><br>  Programmers should try to use immutable data structures as often as possible.  The immutability of the state makes it much easier to determine the possible side effects and safety of the program, eliminating the whole classes of possible errors. <br><br>  In Haskell, all values ‚Äã‚Äãare immutable.  If you want to change the state of the data structure, you will have to create another structure with the necessary values.  This is still fast, because Haskell uses <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy calculations</a> and <a href="http://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structures</a> .  Rust is a system programming language, so it cannot use lazy computations, and state immutability cannot always be as practical as Haskell.  However, in Rust, all declared variables are immutable by default [in this case, it is not correct to call them variables, but it was in the original - approx.  translator], but there is also the ability to change the state if it is required.  And this is great because it forces the programmer to explicitly state that the variable being declared must be variable, and this encourages the use of best programming practices and allows the compiler to optimize better. <br><br><h5>  Go approach: no </h5><br>  Go does not support state immutability. <br><br><h4>  Control structures </h4><br><h5>  The essence of the problem </h5><br>  Control Structures [orig.  "Control flow structures" - approx.  translator] is part of what distinguishes programming languages ‚Äã‚Äãfrom machine code.  They allow us to use abstractions to control the execution of a program in the right direction.  Obviously, all programming languages ‚Äã‚Äãsupport some control constructs, otherwise nobody would use them.  However, there are several control constructs that I lack in Go. <br><br><h5>  The Right Approach: Pattern Matching and Compound Expressions </h5><br>  Pattern matching is a really cool way to work with data structures and values.  It looks like <code>case</code> / <code>switch</code> on steroids.  You can compare with the sample as follows: <br><br>  (Rust): <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> x { <span class="hljs-number"><span class="hljs-number">0</span></span> | <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; action_1(), <span class="hljs-number"><span class="hljs-number">2</span></span> .. <span class="hljs-number"><span class="hljs-number">9</span></span> =&gt; action_2(), _ =&gt; action_3() };</code> </pre><br>  You can work with structures in this way: <br><br><pre> <code class="rust hljs">deg_kelvin = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> temperature { Celsius(t) =&gt; t + <span class="hljs-number"><span class="hljs-number">273.15</span></span>, Fahrenheit(t) =&gt; (t - <span class="hljs-number"><span class="hljs-number">32</span></span>) / <span class="hljs-number"><span class="hljs-number">1.8</span></span> + <span class="hljs-number"><span class="hljs-number">273.15</span></span> };</code> </pre><br>  The previous example shows something called ‚Äúcompound expression‚Äù [orig.  "Compound expressions" - approx.  translator].  In languages ‚Äã‚Äãlike C and Go, the <code>if</code> and <code>case</code> / <code>switch</code> simply direct the flow of program execution;  they do not calculate values.  In languages ‚Äã‚Äãlike Rust and Haskell, the <code>if</code> and pattern matching are able to calculate values ‚Äã‚Äãthat can be assigned to something.  In other words, the <code>if</code> and pattern matching can indeed ‚Äúreturn‚Äù values.  Here is an example with an <code>if</code> : <br><br>  (Haskell): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><h5>  Go Approach: C-free operators </h5><br>  I don't want to humiliate Go right now - it has some valid control structures for certain things like <code>select</code> for parallelization.  However, it does not contain compound expressions and pattern matching, which I love so much.  Go only supports the assignment of atomic expressions like <code>x := 5</code> or <code>x := foo()</code> . <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programming for embedded systems </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writing programs for </font></font><a href="http://en.wikipedia.org/wiki/Embedded_system"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">embedded systems is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> very different from writing programs with full-featured operating systems. </font><font style="vertical-align: inherit;">Some languages ‚Äã‚Äãare much better suited for working with special programming requirements for embedded systems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I‚Äôm surprised a lot of people offering Go as a programming language for robots. </font><font style="vertical-align: inherit;">Go is not suitable for programming for embedded systems for a number of reasons. </font><font style="vertical-align: inherit;">This section is not about Go criticism, just Go was not designed for this. </font><font style="vertical-align: inherit;">This section is about the misconceptions of people who recommend writing to Go for embedded systems.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number 1: </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8_%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258F%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic memory allocation</font></font></a> </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A heap is a section of memory that can be used to store an arbitrary number of objects created during execution. Heap usage is called dynamic memory allocation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is generally unwise to use a bunch when programming for embedded systems. The main reason is that a heap, as a rule, requires considerable additional memory costs and some very complex structures for management, none of which is suitable when writing under an eight-mega-hertz controller with two kilobytes of RAM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, of course, it‚Äôs unwise to use a bunch on </font></font><a href="http://en.wikipedia.org/wiki/Real-time_computing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">real-time systems.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(systems that can fail if the operation takes too long), because the amount of time required for allocating and freeing memory on the heap is not deterministic. For example, if your microcontroller controls a rocket engine, it will suck if you try to allocate a certain amount of memory in a heap and it takes a few hundred milliseconds more than usual, and this will lead to untimely adjustment of the valve and a strong explosion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are other aspects of dynamic memory allocation that make its use unsuitable for efficient programming for embedded systems. </font><font style="vertical-align: inherit;">For example, many languages ‚Äã‚Äãthat use a heap rely on the garbage collector, which during work usually suspends program execution to find and remove objects that are no longer used. </font><font style="vertical-align: inherit;">This makes the program even more unpredictable than just using dynamic memory.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The correct approach: make dynamic memory optional </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard library Rust language has built on dynamic memory functionality - eg </font></font><code>boxes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, the compiler supports flags to completely disable all dynamic memory-using functionality and to force a static check that this functionality is not used in code. </font><font style="vertical-align: inherit;">Rust really allows you to write programs without using a heap at all.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go approach: no </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go is very tied to the use of dynamic memory. There is not a single practical way to force Go code to use only the stack, but for Go it is not a problem - of course, in the areas for which Go is intended. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go is also not a real-time language. It is absolutely impossible to give strict guarantees of the execution time of any sufficiently large program. This can be a little puzzling, so I will explain: Go is relatively fast, but this is not enough for real time. There is a big difference: speed is important for real time, but much more important is the ability to guarantee maximum response time, which cannot be easily predicted in the case of Go - of course, due to the strong use of the heap and because of garbage collection.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similar problems arise in the case of languages ‚Äã‚Äãlike Haskell, which are unsuitable for real-time tasks or for programming embedded systems because of the equally large string on the heap. </font><font style="vertical-align: inherit;">However, I have never seen anyone promoting Haskell as a programming language for robots, so there is no need to discuss this.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem number 2: writing unsafe low-level code </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you have to write programs for embedded systems, it is almost impossible to avoid writing unsafe code (unsafely typing or using address arithmetic). </font><font style="vertical-align: inherit;">In C or C ++, doing unsafe things is very simple. </font><font style="vertical-align: inherit;">Suppose I need to turn on the LED by writing </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the address </font></font><code>0x1234</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then I can just do the following: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(C / C ++):</font></font><br><br><pre> <code class="cpp hljs">* (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *) <span class="hljs-number"><span class="hljs-number">0x1234</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is extremely dangerous and only makes sense in very low-level system programming, so neither Go nor Haskell make it easy to do; </font><font style="vertical-align: inherit;">These are not system programming languages.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The right approach: isolating unsafe code </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust, which focuses on both security and system programming, provides a good way for a tool ‚Äî blocks of unsafe code [orig. </font><font style="vertical-align: inherit;">"Unsafe code blocks" - approx. </font><font style="vertical-align: inherit;">translator], a good way to explicitly separate a dangerous code from a safe one </font><font style="vertical-align: inherit;">Here is the same example with an entry </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at an address </font></font><code>0x1234</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the Rust language: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Rust):</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span>{ * (<span class="hljs-number"><span class="hljs-number">0x1234</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we tried to do this outside a block of unsafe code, the compiler would be loudly indignant. </font><font style="vertical-align: inherit;">This allows us to do all the unhappy, but necessary dangerous operations inherent in programming for embedded systems, while at the same time preserving the security of the code.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go approach: no </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go is not sharpened for such things and has no built-in support for them. </font></font><br><br><h4> <a href="http://en.wikipedia.org/wiki/Wikipedia:Too_long%3B_didn%2527t_read"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL; DR</font></font></a> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can still say, ‚ÄúBut why is Go not good? </font><font style="vertical-align: inherit;">This is just a list of complaints; </font><font style="vertical-align: inherit;">You can complain about any language at all! ‚Äù </font><font style="vertical-align: inherit;">It's true; </font><font style="vertical-align: inherit;">no perfect language. </font><font style="vertical-align: inherit;">However, I hope my whining still slightly showed that:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go does nothing new; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go was not superbly designed from scratch; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go is a step backwards compared to other modern languages. </font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/228849/">https://habr.com/ru/post/228849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228835/index.html">Google has published a preview version of the source code Android L for the Nexus line</a></li>
<li><a href="../228839/index.html">Integration of Asterisk with minicom DX-500 with ELF2-AE</a></li>
<li><a href="../228841/index.html">Best practices for hosting Drupal in a cloudy environment</a></li>
<li><a href="../228843/index.html">Useful materials for mobile developer # 60 (June 30-July 6)</a></li>
<li><a href="../228847/index.html">As part of a course at MIT, I developed an automatic dispenser for patches or in brief about design-thinking</a></li>
<li><a href="../228851/index.html">Dell prepares for the arrival of ARM processors in servers (part 3)</a></li>
<li><a href="../228859/index.html">ThinkServer RD640 - Lenovo server, charged for work</a></li>
<li><a href="../228861/index.html">Transparent OpenGL</a></li>
<li><a href="../228863/index.html">AngularJS: select subtleties within the directive template</a></li>
<li><a href="../228865/index.html">The first photo of the far side of the moon: a bit of history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>