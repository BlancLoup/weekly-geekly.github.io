<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free stack for Windows</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows does not like to love. However, often, the phrase: ‚ÄúI did not read the book of the writer, but I condemn it‚Äù describes this situation very wel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free stack for Windows</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3ce/d07/d64/3ced07d642e217d41af90e2311b7d543.png" align="left"><br>  Windows does not like to love.  However, often, the phrase: ‚ÄúI did not read the book of the writer, but I condemn it‚Äù describes this situation very well.  Despite the ingrained contempt for the "Wind", some things in it are implemented very well, and we would like to write about one of them.  Some fragments of WinAPI, although they were implemented for a long time, for various reasons, and often unfairly, fell out of sight of a wide audience. <br>  This article will discuss the implementation of the lock-free stack implementation in the OS and the comparison of its performance with cross-platform counterparts. <br><a name="habracut"></a><br>  So, for a long time already in WinAPI there is an implementation of a non-blocking stack based on a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684121(v%3Dvs.85).aspx">single</a> -linked list ( <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684121(v%3Dvs.85).aspx">Interlocked Singly Linked Lists</a> ), which is abbreviated SLIST.  Implemented initialization operations of such a list and stack primitives on it.  Without going into details of the implementation of its SList, Microsoft merely indicates that it uses some kind of non-blocking algorithm to implement atomic synchronization, increase performance, and problems with locks. <br><br>  Non-blocking, simply-connected lists can be implemented independently, and Maxim Khizhinsky ( <a href="http://habrahabr.ru/users/khizmax/" class="user_link">khizmax</a> ) has already written about this in detail in his monumental cycle of articles on lock-free algorithms on Habr√©, in particular, in many details.  However, prior to Windows 8, there was no 128-bit CAS operation, which sometimes created problems when implementing such algorithms in 64-bit applications.  Slist, therefore, helps to solve this problem. <br><br><h3>  Implementation </h3><br>  The features of the SList implementation include the memory alignment requirement for list items along the MEMORY_ALLOCATION_ALIGNMENT boundary.  However, similar requirements are made for other interlocked operations in WinAPI.  For us, this means having aligned_malloc / aligned_free when working with list item memory. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another feature is the requirement that the pointer to the next list item of the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686309(v%3Dvs.85).aspx">SLIST_ENTRY</a> type <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686309(v%3Dvs.85).aspx">be</a> located at the very beginning of the structure: to our own fields. <br><br>  The following is the implementation of a C ++ template that wraps the native WinAPI functions for working with a SList: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ Template Code</b> <div class="spoiler_text"><pre><code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">template</span></span>&lt;typename <span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">SList</span></span> { public: <span class="hljs-type"><span class="hljs-type">SList</span></span>() { // <span class="hljs-type"><span class="hljs-type">Let</span></span> <span class="hljs-type"><span class="hljs-type">Windows</span></span> initialize an <span class="hljs-type"><span class="hljs-type">SList</span></span> head m_stack_head = (<span class="hljs-type"><span class="hljs-type">PSLIST_HEADER</span></span>)_aligned_malloc(sizeof(<span class="hljs-type"><span class="hljs-type">SLIST_HEADER</span></span>), <span class="hljs-type"><span class="hljs-type">MEMORY_ALLOCATION_ALIGNMENT</span></span>); <span class="hljs-type"><span class="hljs-type">InitializeSListHead</span></span>(m_stack_head); //<span class="hljs-type"><span class="hljs-type">UPD</span></span>: <span class="hljs-number"><span class="hljs-number">22.05</span></span><span class="hljs-number"><span class="hljs-number">.2014</span></span>, thx to @gridem } ~<span class="hljs-type"><span class="hljs-type">SList</span></span>() { clear(); _aligned_free(m_stack_head); } bool push(const <span class="hljs-type"><span class="hljs-type">T</span></span>&amp; obj) { // <span class="hljs-type"><span class="hljs-type">Allocate</span></span> an <span class="hljs-type"><span class="hljs-type">SList</span></span> node node* pNode = alloc_node(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pNode) return false; // <span class="hljs-type"><span class="hljs-type">Call</span></span> the object's copy constructor init_obj(&amp;pNode-&gt;m_obj, obj); // <span class="hljs-type"><span class="hljs-type">Push</span></span> the node into the stack <span class="hljs-type"><span class="hljs-type">InterlockedPushEntrySList</span></span>(m_stack_head, &amp;pNode-&gt;m_slist_entry); return true; } bool pop(<span class="hljs-type"><span class="hljs-type">T</span></span>&amp; obj) { // <span class="hljs-type"><span class="hljs-type">Pop</span></span> an <span class="hljs-type"><span class="hljs-type">SList</span></span> node from the stack node* pNode = (node*)<span class="hljs-type"><span class="hljs-type">InterlockedPopEntrySList</span></span>(m_stack_head); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pNode) return false; // <span class="hljs-type"><span class="hljs-type">Retrieve</span></span> the node's <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> obj = pNode-&gt;m_obj; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Call</span></span></span><span class="hljs-class"> the destructor free_obj(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_obj</span></span></span><span class="hljs-class">); // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> the node's memory free_node(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">); return true; } void clear() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> (;;) { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pop</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">every</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">*)</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">InterlockedPopEntrySList(m_stack_head)</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> (!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">break</span></span></span><span class="hljs-class">; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Call</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">destructor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">free_obj</span></span></span><span class="hljs-class">(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_obj</span></span></span><span class="hljs-class">); // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node's</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">free_node</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">); } } private: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PSLIST_HEADER</span></span></span><span class="hljs-class"> m_stack_head; struct node { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">The</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">must</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">be</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SLIST_ENTRY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_slist_entry</span></span></span><span class="hljs-class">; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">follows</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_obj</span></span></span><span class="hljs-class">; }; node* alloc_node() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_aligned_malloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MEMORY_ALLOCATION_ALIGNMENT</span></span></span><span class="hljs-class">); } void free_node(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_aligned_free</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pNode</span></span></span><span class="hljs-class">); } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">* init_obj(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_cast</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">*&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">)) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T(init)</span></span></span><span class="hljs-class">; } void free_obj(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">-&gt;~</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">(); } };</span></span></code> </pre> </div></div><br><br><h3>  Performance test </h3><br>  To test the algorithm, a standard test with "manufacturers" and "consumers" was used.  However, in addition to each test run, we varied the number of threads of type consumer and type of producer.  At the same time, the total number of tasks also changed, since each ‚Äúproducer‚Äù, under the conditions of the test, always produces the same number of tasks (iterations) equal to 1 million, in this case.  Thus, with the number of threads of the producer type equal to N, the total number of jobs was N * 1M. <br><br><div class="spoiler">  <b class="spoiler_title">SList test code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> UMS::SList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"MS SList"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != iterations; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(++producer_count)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (WaitForSingleObject(hEvtDone, <span class="hljs-number"><span class="hljs-number">10</span></span>) != WAIT_OBJECT_0) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(value)) { ++consumer_count; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(value)) { ++consumer_count; } } };</code> </pre></div></div><br>  To ensure that consumer workflows do not ‚Äúthresh‚Äù at idle and do not freeze in guaranteed sleep, we used <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682396(v%3Dvs.85).aspx">Event</a> synchronization objects of Windows type, so that ‚Äúconsumers‚Äù clean up the stack after the ‚Äúmanufacturers‚Äù have finished their work.  The ‚Äúconsumers‚Äù start simultaneously with the ‚Äúproducers‚Äù, and by the time the ‚Äúproducers‚Äù stop and we activate the hEvtDone event, they already have time to sort out part of the tasks from the stack. <br><br>  Below is the function that calls our test with the required number of threads: <br><br><div class="spoiler">  <b class="spoiler_title">So we call the test</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> run_test(<span class="hljs-type"><span class="hljs-type">int</span></span> producers, // Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> producer threads <span class="hljs-type"><span class="hljs-type">int</span></span> consumers // Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> consumer threads ) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> namespace std; boost::thread_group producer_threads, consumer_threads; // Initiate a timer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> measure performance boost::timer::cpu_timer timer; cout &lt;&lt; T::get_name() &lt;&lt; "\t" &lt;&lt; producers &lt;&lt; "\t" &lt;&lt; consumers &lt;&lt; "\t"; // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> the counters <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> the previous test producer_count = consumer_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; done = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ResetEvent(hEvtDone); // <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> the producer threads <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a given thread proc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != producers; ++i) producer_threads.create_thread(T::producer); // <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> the consumer threads <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a given thread proc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != consumers; ++i) consumer_threads.create_thread(T::consumer); // Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the producers <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> complete producer_threads.join_all(); done = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; SetEvent(hEvtDone); // Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the consumers <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> complete consumer_threads.join_all(); // Report the <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> execution auto nanoseconds = boost::chrono::nanoseconds(timer.elapsed().<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> + timer.elapsed().<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>); auto seconds = boost::chrono::duration_cast&lt;boost::chrono::milliseconds&gt;(nanoseconds); auto time_per_item = nanoseconds.count() / producer_count; cout &lt;&lt; time_per_item &lt;&lt; "\t" &lt;&lt; seconds.count() &lt;&lt; endl; }</code> </pre></div></div><br>  The test was run under the following conditions: <br><ul><li>  OS: Windows 8 64-bit </li><li>  CPU: 4x Intel Core i7-3667U @ 2.00GHz </li><li>  RAM: 8GB </li><li>  Compiler: Microsoft C / C ++ Optimizing Compiler Version 18.00.21005.1 </li><li>  Configuration: Release, Static Runtime (/ MT), Optimize Speed ‚Äã‚Äã(/ Ox), x64 Architecture </li><li>  boost: version 1.55 </li><li>  libcds: version 1.5.0 </li></ul><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c36/7c3/e6c/c367c3e6c8e3c1110e2d1a0de9ee9467.png" align="left"></a> <br>  Variations of parameters in two dimensions (consumers, producers) give us the function t (p, c), whose graph is shown in the image on the left. <br><br>  In order not to have the eyes count the number of zeros in the results, instead of counting the number of tasks per second, we give the time to perform one task in nanoseconds, calculated as the total test time divided by the total number of tasks.  The lower this value, the faster the algorithm works. <br><br>  The number of threads of each type varied in sequence: <pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumThreads[] = { <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">56</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span> };</code> </pre> <br><br>  Pay attention to this surface.  Significant acceleration of the algorithm is noticeable with a small number of consumers (the area of ‚Äã‚Äãthe graph is colored in green).  A further increase in the number of streams of both types does not lead to a noticeable change in the speed of work, although it can be seen that the indicator is somewhat ‚Äúfloating‚Äù in a narrow corridor, but the graph retains a soothing orange tone. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/59a/f26/bde/59af26bde5b55e7b7e1c200a34c25853.png" align="right"></a> <br>  If we consider the same chart in a different version, this border is visible even more clearly.  In the image on the right, the fertile blue-green band is very clearly distinguishable, marking the entire region with four ‚Äúconsumers‚Äù and an arbitrary number of ‚Äúproducers‚Äù, which, by the way, coincides with the number of nuclei in the experiment.  Further, it will be shown that other implementations demonstrate similar dynamics.  This suggests the similarity of the algorithm used by Microsoft with that used in third-party libraries. <br><br>  <i>It is gratifying to see that the lock-free approach shines here in all its glory: it is difficult to imagine 72 (+72) streams, with 1 million tasks each hanging in the lock.</i>  <i>However, articles about lock-free usually begin with this.</i> <br><br><h3>  Comparison </h3><br>  An identical test was run on the same computer for the other two implementations of non-blocking containers taken from well-known libraries (boost :: lockfree and libcds) in the following cycle: <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumThreads[] = { <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">56</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p : NumThreads) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c : NumThreads) { run_test&lt;lf::boost::test&gt;(p, c); run_test&lt;lf::slist::test&gt;(p, c); run_test&lt;lf::libcds::test&gt;(p, c); }</code> </pre><br><br>  Despite some similarity of implementations, the following are the tests performed for these libraries and the results of each of them. <br><br><h4>  Boost.Lockfree library </h4><br>  This <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/lockfree.html">library</a> is part of the boost relatively recently.  It consists of three containers: a queue, a stack, and a ring buffer.  Use their classes, as always convenient.  There is documentation and even examples. <br><br>  Below is the code for a similar test using boost :: stack. <br><div class="spoiler">  <b class="spoiler_title">Boost test</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ::boost::lockfree::<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"boost::lockfree"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != iterations; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(++producer_count)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (WaitForSingleObject(hEvtDone, <span class="hljs-number"><span class="hljs-number">10</span></span>)!=WAIT_OBJECT_0) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(value)) { ++consumer_count; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(value)) { ++consumer_count; } } };</code> </pre><br></div></div><br>  We present the results of this test in the form of graphs: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/27b/93f/6bb/27b93f6bb17af0c25889b486e285ecd0.png" align="left"></a> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc4/7fb/021/bc47fb021b6c69b020bbf8f52ff770d5.png"></a> <br><br><h4>  Libcds library </h4><br>  This <a href="http://libcds.sourceforge.net/">library is</a> often referenced by <a href="http://habrahabr.ru/users/khizmax/" class="user_link">khizmax</a> in its articles.  Regardless of its consumer qualities, it seemed to us somewhat cumbersome and poorly documented (most of the information was found here in Habr√©).  In addition, in each stream where their lock-free containers are used, you need to attach your thread to their ‚Äúengine‚Äù (probably because of TLS?), Then do it detach and still need to initialize Hazard Pointer somewhere. <br><br>  Despite the inconceivable number of implemented lock-free containers, for every taste, this library can hardly be called beautiful - you need to get used to it. <br><br>  Below is the code for a similar test using cds :: container :: TreiberStack: <br><div class="spoiler">  <b class="spoiler_title">Libcds test</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xxxstack</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cds::container::TreiberStack&lt;cds::gc::HP, <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: cds::gc::HP hzpGC; xxxstack() { cds::Initialize(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> xxxstack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"libcds tb"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Attach the thread to libcds infrastructure cds::threading::Manager::attachThread(); for (int i = 0; i != iterations; ++i) { //int value = ++producer_count; while (!stack.push(++producer_count)); } // Detach thread when terminating cds::threading::Manager::detachThread(); } static void consumer(void) { // Attach the thread to libcds infrastructure cds::threading::Manager::attachThread(); int64_t value; while (WaitForSingleObject(hEvtDone, 10) != WAIT_OBJECT_0) { while (stack.pop(value)) { ++consumer_count; } } while (stack.pop(value)) { ++consumer_count; } // Detach thread when terminating cds::threading::Manager::detachThread(); } };</span></span></code> </pre><br></div></div><br>  We present the results of this test in the form of graphs: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cf/123/110/4cf123110fa3666c711b106d8aba2327.png" align="left"></a> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/30c/79b/ccf/30c79bccf8941f03319068a5c4aa1439.png"></a> <br><br><h4>  Performance comparison </h4><br>  <i>Despite the fact that SList is a native solution, and the other two are ‚Äúalmost‚Äù cross-platform, we believe that the comparison given below is valid, since all the tests were conducted under the same conditions and demonstrate the behavior of libraries under these conditions.</i> <br><img src="https://habrastorage.org/getpro/habr/post_images/d06/aa6/10b/d06aa610b2ad433cef94010714891432.png" align="right"><br>  Due to the linear increase in the number of tasks in the test as the number of threads increases, the full implementation of all the options takes a decent amount of time.  To stabilize the result, three passes were performed, so the results presented to you above are averaging between three runs. <br><br>  From the above three-dimensional graphs, it is noticeable that the diagonal (the values ‚Äã‚Äãof the arguments {p = c}) looks almost a straight line, so for a visual comparison of the three libraries we made a selection of results based on this criterion. <br><br>  On the left shows what we did. <br><br>  It can be seen that boost loses to the two other implementations, although it demonstrates greater resistance to changes in input parameters. <br><br>  The implementations on libcds and SList differ not so much, but throughout the input interval. <br><br><h3>  findings </h3><br>  It must be admitted that this time Microsoft has created a very good implementation (albeit of only one container), which can successfully compete with algorithms from well-known libraries.  Although the implementation described is not cross-platform, it can be useful for Windows application developers. <br><br>  Download the archive with the source code of the Visual Studio project <a href="http://gfile.ru/a5NV7">here.</a> <br><br><h6>  Used materials </h6><br>  <a href="http://onsitepcsolution.com/improving-windows-performance-part-1">Picture at the beginning of the article</a> <br>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684121(v%3Dvs.85).aspx">MSDN description slist</a> <br>  <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/lockfree.html">Boost.lockfree library</a> <br>  <a href="http://libcds.sourceforge.net/">Libcds library</a> <br>  <a href="http://habrahabr.ru/company/ifree/blog/216013">Lock-free data structures.</a>  <a href="http://habrahabr.ru/company/ifree/blog/216013">Stack evolution</a> <br>  <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/08/19/10197553.aspx">SList implementation details</a> <br><br>  <b>UPD:</b> <br>  At the request of <a href="http://habrahabr.ru/users/mickey99/" class="user_link">mickey99,</a> we had another test: this time I had to take an ordinary std :: stack, access to which was breasted with the usual std :: mutex. <br><div class="spoiler">  <b class="spoiler_title">Mutex test</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"mutex"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != iterations; ++i) { lock.lock(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(++producer_count); lock.unlock(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (WaitForSingleObject(hEvtDone, <span class="hljs-number"><span class="hljs-number">10</span></span>) != WAIT_OBJECT_0) { lock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.empty()) { value = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.top(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); ++consumer_count; } lock.unlock(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isEmpty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isEmpty) { lock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isEmpty = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.empty())) { value = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.top(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); ++consumer_count; } lock.unlock(); } } };</code> </pre><br></div></div><br>  Let's say right away: it took a long, long time to wait  Then the number of tasks per stream was reduced from 1 million to 100K, which, of course, led to not so accurate results (this probably is not required with such numbers), and the set for the number of input streams was changed so that there were fewer points to calculate : <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumThreads[] = { <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>};</code> </pre> <br><br>  Here are the results: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b5f/9aa/051/b5f9aa05150f15fcb2247ab545879382.png" align="left"></a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6d/138/50b/d6d13850b137d200952909ddb14959fd.png" align="right"><br><br clear="right">  The result is quite indicative: already in the presence of more than 4 streams of any type, the voltage dramatically increases by orders of magnitude.  This line is difficult to display on the schedule for the first three.  Probably it will be clearer with a logarithmic scale. </div><p>Source: <a href="https://habr.com/ru/post/223361/">https://habr.com/ru/post/223361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223349/index.html">Python Meetup: April Meeting</a></li>
<li><a href="../223351/index.html">And systemd embraced me to the depths of my distribution</a></li>
<li><a href="../223355/index.html">SQA Days 15 "the most sociable testers conference" died down</a></li>
<li><a href="../223357/index.html">Mini CRT monitor</a></li>
<li><a href="../223359/index.html">What is common between the ball of robots and the world exhibition of 1889?</a></li>
<li><a href="../223363/index.html">Monitoring the connection of USB drives and logging file operations</a></li>
<li><a href="../223365/index.html">Monitoring Asterisk Trunks with Zabbix Low-Level Detection</a></li>
<li><a href="../223367/index.html">Rubik's Cube is 40 years old</a></li>
<li><a href="../223369/index.html">The fight against piracy is gaining momentum. Is it necessary? And if necessary, how? What do you think?</a></li>
<li><a href="../223373/index.html">We write your package for Chocolatey</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>