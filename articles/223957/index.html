<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What language can you learn by asking questions to the search engine? Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The languages ‚Äã‚Äãin which Internet search users compose their search queries have appeared before our eyes. Lexically, they are poorly distinguishable ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What language can you learn by asking questions to the search engine? Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  The languages ‚Äã‚Äãin which Internet search users compose their search queries have appeared before our eyes.  Lexically, they are poorly distinguishable from more familiar languages, for example, Russian or English, and at the beginning of their existence coincided with their parent languages.  But the languages ‚Äã‚Äãof search queries quickly moved away from the parent and got their own sets of idioms, syntax, and even special "parts of speech."  The small size and simplicity of their grammars, as well as the opportunity to study the full set of sentences generated in such languages, make them ideal model objects for testing language learning models. <br><br>  I did a little research on the query language in which users turn to Yandex search, and based on it I prepared a report.  As it often happens, there are more questions than answers.  However, the results were quite interesting. <br><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://video.yandex.ru/iframe/ya-events/m-42221-1503f023439-6b769492b88536c6/&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhgubgxqHBIHGbx1W062xdIzVr_n6w" width="450" height="135" frameborder="0" scrolling="no" allowfullscreen="1"></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I would also like to thank <a href="http://tech.yandex.ru/people/127491/">Elena Gruntova</a> for one of the main ideas for research and assistance in preparing the report. <br><a name="habracut"></a><br>  We begin not entirely with the language of search queries, but with the problem of mastering the language and why it is so important for linguistics, cognitive science, and any thinking person may be interested.  The problem is that we do not fully understand how children so quickly master a fairly complex conceptual and grammatical apparatus, build up vocabulary at a level at which we still cannot teach a machine to understand natural language.  Mysteriousness of the process of mastering the language, people realized in the time of Plato, and even earlier.  Throughout this time, two main directions dominate disputes: nativism and empiricism.  The nativists believe that in mastering the language, most of the information in our brain is already ‚Äúprotected‚Äù in some way, and the empirists claim that we receive most of the information in the learning process based on our own experience. <br><br>  One of the ideas inherent in nativism is that all natural languages ‚Äã‚Äãhave the same set of features - universals.  Nativism also insists on the argument of poverty stimulus, which is designed to explain why a large amount of innate knowledge in mastering the language can not do.  It is estimated that by the time the child goes to school, his vocabulary totals about two thousand words.  This means that from the moment of birth, he learned one or two new words a day.  Each of them he hears no more than a few times, but this is enough for him to understand how these words are modified, combined with each other, to distinguish animate objects from inanimate objects, etc. <br><br>  When you try to repeat it in machine form in the form of some kind of algorithm that could learn languages ‚Äã‚Äãat least with a share of the same efficiency, there are some difficulties.  First, such a solver is limited by the fact that it receives only positive examples at its entrance, phrases that are permitted by the grammar of the language, and no refutations are received.  In addition, some algorithmic constraints are imposed on an algorithm that could simulate language learning.  In particular, we cannot afford to sort through all context-free grammars, which would suit all the examples known to us, and choose the simplest.  We are not allowed to do this by the fact that this task is NP-complete. <br><br>  Let's go directly to the query language.  My idea is that this is a simpler linguistic object than a full-fledged natural language, but not a trivial set of words.  He has his own structure, his developmental logic, and the logic of studying this language by a human being somewhat reminiscent of the logic of studying natural language. <br><br>  We can observe how the requests of the person who just started using the search engine are gradually changing.  There are two strategies: the first queries can consist of naming a single object, or they represent a well-formed and grammatically correct phrase in Russian.  After some time, people notice that certain constructions lead them to communicative success.  They see that the car has understood them, they achieve the desired result.  Other designs do not work.  For example, long phrases written in consistent Russian are often not understood by the machine.  The user begins to bring their requests to successful designs, to adopt them from other users (including through the sadst).  He notes that if at the end of the query you add the magic words ‚Äúfree download‚Äù, the machine understands it better, after which he can start adding these words anywhere, even if they do not matter for a particular query. <br><br>  As is customary in academic linguistics, I will further denote asterisks statements that are unacceptable from the point of view of the grammar of the language being studied.  In square brackets are traditionally search queries.  Consider three examples: <br><br><ul><li>  [Eastern music to listen to online] </li><li>  [listen online oriental music] </li><li>  <sup>*</sup> [Eastern music to listen to online] </li></ul><br>  The second option is valid both in the Russian language and in the query language, the first one is valid only in the query language, and the third one is unacceptable in both, although the agreement is better there than in the first one.  We have statistics on the prevalence of queries, and in those cases where we put an asterisk and say that the option is prohibited in the query language, it is understood that such forms of queries are extremely rare. <br><br>  The Russian version of the query language does not coincide with the usual Russian language, although its lexical composition is almost identical.  It appeared around 1997 and has been developing quite actively since then.  If at the very beginning the average query length was 1.2 words, then by 2013 this figure had already reached 3.5 words. <br><br>  Another argument in favor of perceiving the query language as a full-fledged linguistic object is <a href="http://ru.wikipedia.org/wiki/%25C7%25E0%25EA%25EE%25ED_%25D6%25E8%25EF%25F4%25E0">Zipf's law</a> .  In natural languages, the nth word in frequency of usage has a frequency of usage roughly proportional to 1 / n.  And this dependence is especially clearly visible if we place the graph on a double logarithmic scale.  We see that words in the language of questions ideally fall on a straight line with an inclination of 45 degrees, which according to Zipf‚Äôs law is a sign of natural language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/8c1/973/d178c19736bb5806206fd5b387497375.png" width="640"><br><br>  If we compare the vocabulary entropy (that is, how many bits we need on average to describe the occurrence of each next word) of the Russian language and the query language, then for the first one this figure will be about 11 bits (using the examples of L. N. Tolstoy), for the second - about 12. That is.  The vocabulary of all people who ask about 4 times more than Tolstoy‚Äôs vocabulary.  At the same time, it is obvious that the language of requests from the point of view of communications is quite a strange language, since  with its help, people do not communicate with each other, but turn to a search engine.  Accordingly, the pragmatics of statements are always the same, so the share of some constructions will differ markedly.  For example, the proportion of verbs in the query language in the query language is 5.4%, and in Russian - 17.5%.  The fact is that they are used with a different function, usually verbs that reflect the user's intention: ‚Äúdownload‚Äù, ‚Äúwatch‚Äù, ‚Äúlisten‚Äù.  So if you look at the share of the 10 most frequent among all the verbs, then it will be much higher - 46% against 11.4% in Russian.  Grammatically, the language is much simpler, since the average phrase length in it does not exceed four words.  These are not even full-fledged sentences, but statements.  The question arises, is it then possible to speak of the syntax of the query language at all?  We think it is possible.  In confirmation of this, we consider some examples in which we will see that in the query language we can see constructions that are not typical for the Russian language, but are often found in others, for example, in Japanese. <br><br><ul><li>  [photo kittens] </li><li>  [photo kittens] </li><li>  <sup>*</sup> [kittens photo] </li></ul><br>  So far, it is not very clear what happens in the first two queries, but we clearly see that in the third position we have the traditional nominal group, agreed on the genitive case.  Now consider the verb group: <br><br><ul><li>  [watch trailer family kruds] </li><li>  [family kruds trailer to watch] </li></ul><br>  We have one object - the ‚ÄúKruds family trailer‚Äù, with which we want to perform a certain action - ‚Äúwatch‚Äù.  Then we have a language construct, which practically does not occur in Russian - topicalization.  It is very common, for example, in Japanese.  There you can display a topic - what is being said - bring it to the top of the sentence.  In the query language, it is also possible to conduct a topization: <br><br><ul><li>  [family kruds trailer to watch] </li><li>  [family kruds watch trailer] </li></ul><br>  If we assume that this is exactly what is happening, and not some bag of words that people shuffle at random, then we can naturally assume that other constructions should be prohibited.  And indeed it is.  Constructions that are no worse than the four of the ones we quoted above never occur or are very rare: <br><br><ul><li>  <sup>*</sup> [trailer watch family kruds] </li><li>  <sup>*</sup> [watch family kruds trailer] </li></ul><br>  We can assume that our hypothesis about topicalization was confirmed, and we will try to figure out what happens in the first two queries about kittens: <br><br><ul><li>  [kittens photo] </li><li>  [photo kittens] </li></ul><br>  It seems that the first query is the original structure, and the second is another example of topicalization. <br><br><h4>  Computational Models </h4><br>  Having a large body of language, it is possible to evaluate its assimilation statistically using simple tests.  The body of the query language is huge simply by its nature.  Every day, hundreds of millions of search queries come to Yandex. Correspondingly, corpses for billions of sentences can be taken almost from the air.  This allows us not only to evaluate computational models, but also to compare them with each other until the statistical significance of the difference is reached, etc.  Let's come up with the simplest task that will help us assess whether the algorithm or model has learned the language and how well.  For example, the task of recovering the missing word: <br><br><ul><li>  [in the forest * she-tree in the forest she grew] </li><li>  [mp3 * free and without registration] </li></ul><br>  The idea is that in one hundred percent of cases this task cannot be solved, but the better someone has mastered the language, the more percent of cases he will solve this problem.  And if we have enough examples, no matter how much the difference between the tested, we can still see it and ensure that it is statistically significant.  When working with natural languages, this is most often impossible due to the limited shells. <br><br>  How can a model be constructed that tries to recover words in this way?  The simplest option is N-grams, when we take a sequence of words and say that the probability of the next word in the chain depends only on some previous ones.  Then we estimate the probability and substitute this word.  Such N-grams can give us the opportunity to restore the previous word, followed by a trace or a word in the middle: <br><br><ul><li>  [... download without * ...] =&gt; registration </li><li>  [... * princess pencil] =&gt; draw </li><li>  [... damn * druon] =&gt; kings </li></ul><br>  This is not a very interesting model.  In fact, we just remembered what constructions are in a language and by no means explicitly generalize anything.  It is obvious that a machine that uses only such templates without generalization will be much less proficient in speaking than a machine that applies more complex rules.  As such rules we will try to choose the same patterns, in which some words are replaced with sets of different words.  For example, we can note that if after the phrase ‚Äúfalcon and *‚Äù there are words denoting a book context (file format names, the word ‚Äúread‚Äù or ‚Äúauthor‚Äù), then the word ‚Äúswallow‚Äù is likely to be omitted. <br><br>  We can also study the level of ‚Äúknowledge‚Äù of a language depending on the number of teaching examples: 3100 phrases, 6200 phrases, 12,400 phrases, 24,800 phrases, 41,000 phrases.  The upper bound roughly corresponds to the number of phrases that a child hears in the first two years of life.  Potentially, it can be traced exactly when the curve will be bent and new information will cease to arrive.  But with 41,000 phrases even on the graphs of N-gram models, it can be seen that the movement does not stop.  The blue color on the graph indicates how many percent of the words the model guesses on the tests, and the red and blue marks the intervals of 3Œ£.  Interestingly, the contexts to the left of the guessing word help define it one percent better.  And if you use the right and left contexts simultaneously, the percentage of guessing increases by ten percent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/8f2/b85/b908f2b852a495382b5419415163c799.png" width="640"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a31/eb2/d4e/a31eb2d4e6460cf54ee034882c200618.png" width="640"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a41/99c/f7d/a4199cf7dcb3b8682022981317f7a20c.png" width="640"><br><br>  The next breakthrough should happen when we start using generalized patterned constructions.  As candidates for this role, we choose two different types: grammatical and context-conceptual.  We in Yandex have a wonderful tool - a lemmer.  He can tell each word about his lemma and how he came from this lemma to the current form.  allows you to determine the initial form of any word.  Thus, we can add grammatical context: <br><br><ul><li>  [(S, im, u) * torrent] =&gt; download </li><li>  [instruction * (S, dates, units)] =&gt; by </li></ul><br>  In the case of context-sensitive templates, we can try to generalize some sets of words.  For example, we can distinguish X as some set of words and phrases for which the expressions [X tuning] and [X price] are valid: <br><br><ul><li>  [knocking * X], allowable [X tuning] and [X price] =&gt; engine </li></ul><br>  Then the question arises whether it is possible to derive as much information as it is contained in grammes, only from contexts?  It would be just fine if we knew that it is possible not to mark parts of speech and not separate grammatical patterns from semantic patterns, but simply to reduce everything to a single conceptual type.  If we add generic patterns that use all the available grammar, we get a result that guarantees an increase of 0.2 percent.  This is quite ridiculous compared to what we saw above, but it is here somewhere that we are rapidly running into the very ceiling that is very difficult to pierce.  But it is he who corresponds to the understanding of the language to which everyone aspires.  Context-conceptual templates allow you to achieve an even smaller result - 0.04%.  It turns out that the answer to our question is negative: there is more information in the grammes.  However, the question of whether it is possible to derive the same information with the help of some stronger generalizations remains open.  We did not use the fact that the word forms of the same word are very similar to each other, and the suffixes of different word forms with the same gramme often resemble each other.  Is it possible, using such generalizations, to output information equivalent in its strength for solving a test problem only from word usage?  And if so, how to formalize this algorithm? <br><br><h4>  Results </h4><br>  A new linguistic object has grown before our eyes.  It is simpler than ordinary natural language.  He has one clear goal of communication, the same pragmatist.  In addition, we know his complete statistics on word usage, which is pure fiction for any natural language.  At the same time, it is still complex enough to remain interesting and lead us to some thoughts about the structure of "real" languages.  Many questions still await their researchers: <br><br><ul><li>  What are the ‚Äúparts of speech‚Äù in it? </li><li>  Is it possible to build a full parser for it? </li><li>  What natural languages ‚Äã‚Äãdoes it look like? </li><li>  How is it developing? </li></ul></div><p>Source: <a href="https://habr.com/ru/post/223957/">https://habr.com/ru/post/223957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223945/index.html">LinkMeUp. Issue number 15. Guest from Canada</a></li>
<li><a href="../223947/index.html">STM32 and LCD via I2C</a></li>
<li><a href="../223949/index.html">Android development application for working with OBDII protocol</a></li>
<li><a href="../223953/index.html">Ancient philosophers and modern scientists</a></li>
<li><a href="../223955/index.html">Li-Ion Battery Operation</a></li>
<li><a href="../223961/index.html">Steam Protocol 2 and Steam Files - Introduction</a></li>
<li><a href="../223965/index.html">Windows 8.1 with Bing challenges Android: one gig of RAM is again enough</a></li>
<li><a href="../223969/index.html">Motocoin - cryptocurrency with human mining</a></li>
<li><a href="../223971/index.html">Dynamic Adding Properties in the Java Language</a></li>
<li><a href="../223973/index.html">Hacking the D-Link DSP-W215 Smart Plug. Again</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>