<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>To steal in 1100 seconds - the strangest bug that I saw</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Two days ago, I received a strange message from a client: the video call mysteriously broke off after exactly 18 minutes. And then it happened again, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>To steal in 1100 seconds - the strangest bug that I saw</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gt/dv/ke/gtdvkeqr2tmldk4hojfeityhcy4.jpeg"></div><br>  Two days ago, I received a strange message from a client: the video call mysteriously broke off after exactly 18 minutes.  And then it happened again, also after the 18th minute.  Coincidence? <br><br>  This bug was not only strange, but terribly awkward.  Our goal is to make a video call tool so simple that a conditional doctor or psychologist would like to use our service.  Need I say that a permanent gap after 18 minutes is inconsistent with this goal? <br><a name="habracut"></a><br><h2>  WebRTC is when you always deal with bugs. </h2><br>  Bugs are not a phenomenon for us.  Our product is based on WebRTC, a fairly new web standard that allows two browsers to directly exchange data (for example, video and audio in real time). <br><br>  In September 2017, WebRTC was finally supported <a href="https://bloggeek.me/webrtc-ios-support/">in all major browsers</a> .  In recent months, <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D816979">we</a> <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D175014">snatched</a> <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D180748">our</a> <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D180522">fair</a> <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D183201">share of</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D814298%26q%3Dcomponent%253ABlink%253EWebRTC%2520%26colspec%3DID%2520Pri%2520M%2520Stars%2520ReleaseBlock%2520Component%2520Status%2520Owner%2520Summary%2520OS%2520Modified">bugs</a> , while we made WebRTC work for everyone.  (Working with advanced technologies is a good way to get familiar with how to write bug reports to browser makers). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, this last bug was the strangest in my 5 years of working with WebRTC. <br><br><h2>  Tools for catching bugs WebRTC </h2><br>  Fortunately, we have a lot of bug catching tools (thanks to some cool contributors).  It is naive to think that someone will dump the <b>chrome: // webrtc-internals</b> and send it to you along with a script that is easy to reproduce. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ag/f1/lh/agf1lhxpm2kacj60g5ydsdeylpi.png"></div><br>  <font color="lightgray">Sample output based on <a href="https://fippo.github.io/webrtc-dump-importer/rtcstats">WebRTC dump</a> .</font>  <font color="lightgray">Green lines indicate a successful connection, the red line indicates a connection failure.</font> <br><br>  One of the best tools is <a href="https://github.com/opentok/rtcstats-server">rtcstats</a> , which gives output from <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getStats">getStats</a> and stores it in regular files (along with other useful tokens). <br><br><h2>  Bug confirmation </h2><br>  We quickly found the required files from two failed calls.  These were the video calls between Chrome 64 and Edge 16. Chrome fell at 18 minutes 20 seconds.  The subsequent <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Session_lifetime">restart of ICE</a> also failed, which automatically closed RTCPeerConnection. <br><br>  The riddle is that Edge did not agree with Chrome - on the Edge side, <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState">iceConnectionState</a> remained connected until the ICE restart, the browser broke the connection, but the ICE restart failed.  What was it? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/hj/tk/xzhjtkg-r0cr9llwhv2nwp_ibo0.png"></div><br>  <font color="lightgray">Screen from Edge, look at the <b>connected</b> timestamps and get a description of iceRestart, between them about 18 minutes 20 seconds.</font>  <font color="lightgray">Moreover, iceConnectionStateChange has not even changed to failed!</font> <br><br><h2>  Reproduce bug: magic number ‚Äú18 minutes 20 seconds‚Äù </h2><br>  A couple of months before we bought a cheap laptop with Windows to run Edge 16 and see the bugs in action.  We made a video call between this laptop and MacBook with Chrome 64. <br><br>  And then we waited.  And of course, exactly after 18 minutes and 20 seconds, the ICE status changes to failed, the ICE restarts and the connection is broken.  We have never seen anything like it, it was a shock. <br><br>  What to do next?  Where to begin?  In our code, there was no magic timer that would break connections after 18 minutes 20 seconds in some browsers.  It all seemed insurmountable, but we could only do one thing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pr/2n/jg/pr2njgpthdgrpxi-lnrlscvvxng.jpeg"></div><br>  <font color="lightgray">The team is blissfully unaware of the bugs that await it.</font>  <font color="lightgray">Picture taken in Alesund, Norway, during a working trip.</font> <br><br><h2>  One step at a time - methodical localization of the bug </h2><br>  We found a playable script, but still had to reduce the search area.  A series of tests was supposed to test our assumptions. <br><br>  First, will this happen between two Chrome browsers, which usually have the least problems with WebRTC?  On the same laptops, with the same initial conditions, we checked the call from Chrome to Chrome.  After 18 minutes 20 seconds, the call was still active, the ICE connection status remained stable.  That is, the bug did not happen. <br><br>  However, when testing from Firefox to the Edge, the call again failed. <br><br>  The main question: is it a bug in Edge or a bug in our code?  The <a href="https://appear.in/">appear.in</a> service <a href="https://appear.in/">is</a> also built on WebRTC and much has been done in our product in the same way, because half of our team used to work in appear.in.  We decided to test the call from Chrome to Edge through this platform in peer-to-peer mode (free of charge), all on the same machines.  Not a single break! <br><br>  We did not know to cry or laugh.  The scope of the search has narrowed and indicated an error in our code.  Confrere could not work for a bunch of chrome-edge. <br><br><h2>  When expectations fall </h2><br>  Since each test took 20 minutes, we decided that we should pause and continue from home. <br><br>  For the sake of superfluous verification, we tested Chrome-Edge from home.  What a surprise it was when, after 40 minutes of the test, the call was still active.  What?! <br><br>  We checked again and again.  Chrome logged that the office connection did this: relay &lt;-&gt; stun.  This means that one shoulder of the call must go through our servers (relayed), while the second shoulder can send data directly (STUN).  This is not uncommon for modern network configurations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/os/xc/tx/osxctxuuq33_xpocsz4rgc3wt8m.png"></div><br>  <font color="lightgray">The RTCStats dump shows the connection status of each ICE candidate pair.</font>  <font color="lightgray">Look at the very top: the local address is in relay status, and the remote address is in stun status.</font> <br><br>  Due to the specific network configuration in our office, my machine running Chrome was connected via cable to allow direct connections.  A laptop with an Edge clung over a very unstable Wi-Fi, and used a relay-server.  However, in the home network, the parties to the call were connected through local candidates, that is, they did not leave the home network. <br><br><h2>  IceTransportPolicy to the rescue! </h2><br>  The next step is to determine why the test was unsuccessful in the office, but now it‚Äôs working.  Could the reason be in stun or relay candidates?  Fortunately, we can force PeerConnection to use only relay candidates ‚Äî you need to set the <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration">appropriate value for iceTransportPolicy</a> when PeerConnection is created.  And of course, after 18 minutes and 20 seconds the call is terminated. <br><br>  Was it a coincidence that the Chrome-Edge bundle worked in appear.in?  Maybe our connection through appear.in used STUN, but TURN won in our service?  A quick test showed that it was our mistake, since the forced relay ( <a href="https://developer.mozilla.org/en-US/docs/Glossary/TURN">TURN</a> ) for appear.in did not cause any bugs. <br><br>  Finally, we tried something else.  We collected a special version of Confrere and, with the permission of appear.in, used their TURN servers for one test.  After 25 minutes, we concluded that the code in our client application was fine (because this code did not provoke a bug when using other TURN servers). <br><br><img src="https://habrastorage.org/webt/zd/br/p4/zdbrp4dzkrj7s4ya_fp5ah1rvmy.jpeg"><br>  <font color="lightgray">When each test takes at least 18 minutes, it requires patience.</font>  <font color="lightgray">On the left I, on the right - Svein (CEO)</font> <br><br><h2>  Logs rush to the rescue! </h2><br>  When we localized the problem - our configuration of the TURN servers was to blame - could we fix everything?  Not.  We still did not know what exactly caused this bug.  Our TURN infrastructure is mostly based on what we learned over 4 years of work in appear.in, it uses the same open source components, works in the same cloud and with the same configuration. <br><br>  When you are at a loss and do not know where to go next, <b>you can always refer to the logs</b> .  Logging was for us the main tool in the search for a bug, because it allows us to monitor the running system in real time.  Launching a new video call, we closely followed the logs. <br><br>  Somewhere on the 10-minute mark, messages such as: <br><br><pre><code class="hljs pgsql">turnserver: <span class="hljs-number"><span class="hljs-number">1054</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-number"><span class="hljs-number">000000000000000061</span></span>: realm &lt;confrere.com&gt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &lt;confrere:<span class="hljs-number"><span class="hljs-number">1520714985</span></span>&gt;: incoming packet message processed, error <span class="hljs-number"><span class="hljs-number">438</span></span>: Stale nonce</code> </pre> <br><br>  When the call ended after 18 minutes and 20 seconds, we looked through the logs again and found the first message mentioning <b>Stale nonce</b> : <br><br><pre> <code class="hljs pgsql">turnserver: <span class="hljs-number"><span class="hljs-number">1053</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-number"><span class="hljs-number">000000000000000034</span></span>: refreshed, realm=&lt;confrere.com&gt;, username=&lt;redacted&gt;, lifetime=<span class="hljs-number"><span class="hljs-number">600</span></span> turnserver: <span class="hljs-number"><span class="hljs-number">1053</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-number"><span class="hljs-number">000000000000000034</span></span>: realm &lt;confrere.com&gt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &lt;redacted&gt;: incoming packet <span class="hljs-keyword"><span class="hljs-keyword">REFRESH</span></span> processed, success turnserver: <span class="hljs-number"><span class="hljs-number">1053</span></span>: handle_udp_packet: <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> UDP endpoint: <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> addr &lt;redacted&gt;:<span class="hljs-number"><span class="hljs-number">443</span></span>, remote addr &lt;redacted&gt;:<span class="hljs-number"><span class="hljs-number">56031</span></span> turnserver: <span class="hljs-number"><span class="hljs-number">1053</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-number"><span class="hljs-number">000000000000000061</span></span>: realm &lt;confrere.com&gt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &lt;redacted&gt;: incoming packet message processed, error <span class="hljs-number"><span class="hljs-number">438</span></span>: Wrong nonce turnserver: <span class="hljs-number"><span class="hljs-number">1053</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-number"><span class="hljs-number">000000000000000061</span></span>: realm &lt;confrere.com&gt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &lt;redacted&gt;: incoming packet message processed, error <span class="hljs-number"><span class="hljs-number">438</span></span>: Stale nonce</code> </pre><br><br>  Why are there so many messages about <b>Stale nonce</b> ?  What is this one-time code (nonce) and how can it be overdue (stale)? <br><br><h2>  Understand the bug: Hi, ‚Äústale nonce‚Äù </h2><br>  If you, like me, did not know beforehand what a one-time code is (nonce): <br><br><blockquote>  Nonce (from nonce - ‚Äúnumber that can only be used once‚Äù is a number that can be used once) in cryptography is a one-time code, selected randomly or pseudo-randomly, which is used to securely transmit the main password, preventing replaying attacks . </blockquote>  - <a href="https://ru.wikipedia.org/wiki/Nonce">Wikipedia</a> <br><br>  And if this number is overdue: <br><br><blockquote>  Stale nonce is more of a warning than an error.  For SIP, your authorization data is encrypted in SIP headers.  To prevent this data from being intercepted by other people and make calls at your expense, a one-time code (nonce) is used. <br>  The SIP RFC standard requires that nonce be changed periodically.  If the client uses the old nonce, then it is ‚Äústale nonce‚Äù.  In this case, the client must use the current nonce instead of the old one.  Such a message means that the client is trying to use stale nonce, that is, either a replay attack occurs, or the client has failed to receive a new nonce </blockquote>  - from the <a href="http://lists.digium.com/pipermail/asterisk-users/2005-October/120923.html">Internet</a> <br><br>  Confrere uses coturn open source software, it manages TURN servers.  If you read the documentation carefully, you will see that there is a parameter in the configuration for stale nonce: <br><br><pre> <code class="hljs pgsql"># Uncomment <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> extra <span class="hljs-keyword"><span class="hljs-keyword">security</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> desired, # <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nonce <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">having</span></span> limited lifetime. # <span class="hljs-keyword"><span class="hljs-keyword">By</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, the nonce <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>, # <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> has unlimited lifetime. # <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> the nonce lifetime. # It defaults <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">600</span></span> secs (<span class="hljs-number"><span class="hljs-number">10</span></span> min) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> provided. <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> that delay, # the client will <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-number"><span class="hljs-number">438</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> will have <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> re-authenticate itself. # #stale-nonce=<span class="hljs-number"><span class="hljs-number">600</span></span></code> </pre><br><br>  In our configuration, we turned on the stale-nonce and everything worked flawlessly until the client base with the Edge browser started to grow. <br><br>  The logs of the stale nonce were familiar to <a href="https://medium.com/%40fippo">Philip Hanke</a> , and he also helped us understand what was happening.  <a href="https://blogs.windows.com/msedgedev/author/shijun-sun/">Shijun Sung</a> reported on a similar issue in May 2017 that allowed <a href="https://appear.in/">appear.in to</a> avoid problems. <br><br>  We had the opportunity to change the configuration of the TURN server and remove the stale-nonce flag so that nonce has no time limit. <br><br>  50 minutes in the test environment - and we were finally able to say: <b>‚ÄúWe found a bug!‚Äù</b> <br><br><h2>  And yet, why 18 minutes 20 seconds? </h2><br>  You must have noticed the title of this post.  Hijack in 1100 seconds.  I wrote ‚Äú18 minutes 20 seconds‚Äù in this text, but do you know how much it is in seconds?  <b>1100</b> <br><br>  We know that after 600 seconds from the beginning of the conversation, the initial nonce becomes invalid.  There is a message stale nonce and after another 500 seconds the connection is broken.  Where do another 500 seconds come from? <br><br>  If you look at the number 500 in the <a href="https://github.com/coturn/coturn">coturn sorts</a> , then <a href="">something interesting</a> will be found. <br><br>  It looks like a built-in sleep timer 500 seconds after some kind of connection check.  I‚Äôm not too familiar with the coturn internal device, but apparently, if the nonce becomes invalid, then after 500 seconds, the coturn will stop transmitting the packets to another member.  Of course, another participant will see that the connection is broken (after all, he no longer receives packets). <br><br>  This explains what is happening on the Chrome side, as it stops receiving packets.  But why Edge does not notice this? <br><br><h2>  The story of two packages </h2><br>  Connections in WebRTC can be of two types: UDP and TCP.  UDP packets do not require acknowledgment of receipt, delivery is not guaranteed and they may arrive in the wrong order.  In real-time communications, this is not a big problem, since codecs do a pretty good job with packet loss. <br><br>  TCP is different.  TCP is very useful when you need to deliver <b>all the</b> data to the other side, in the correct order and with delivery confirmation.  <a href="https://medium.com/the-making-of-appear-in/webrtc-and-turn-latency-around-the-world-4d172dd59e8e">Most WebRTC traffic is UDP</a> . <br><br>  In our history, <b>Edge sent UDP packets through a TURN server to the other side</b> .  When the WebRTC server stopped sending packets, Edge could <i>not know if Chrome was receiving packets or not</i> , so Edge continued to happily send data.  On the other hand, Chrome behaved correctly and sent packets via STUN.  So when iceRestart was happening, <b>Edge did not know what to do and just fell silently</b> . <br><br><h2>  Results </h2><br>  The conclusions are as follows: we will send a bug report to the <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/">Edge bug tracker</a> and for a while we will deploy new TURN servers without the stale-nonce flag.  New servers must ensure that in the future there will be no failures, and our users will receive long and high-quality video calls in <a href="https://confrere.com/features/">our service</a> . <br><br>  I am also extremely happy to be part of a community of people who willingly share knowledge and help each other.  From browser developers who responded to our bug reports and fixed bugs, to individual contributors who make an excellent and free toolkit for the WebRTC community. <br><br>  Special thanks to <a href="https://medium.com/%40fippo">Philip Hanke</a> for pointing out the stale-nonce flag and enduring my endless lamentations when it all seemed nonsense.  In addition, I express my gratitude to <a href="https://blogs.windows.com/msedgedev/author/shijun-sun/">Shijun Sun</a> for having discovered this problem in May 2017. <br><br>  We hope this story was helpful to you.  The author of the original article can be contacted via <a href="http://twitter.com/daginge">Twitter</a> or <a href="">mail</a> , and I am ready to share our experience using WebRTC in the comments! </div><p>Source: <a href="https://habr.com/ru/post/352730/">https://habr.com/ru/post/352730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352720/index.html">Centralized update of Let's Encrypt certificates</a></li>
<li><a href="../352722/index.html">How to issue a self-signed SSL certificate and make your browser trust it</a></li>
<li><a href="../352724/index.html">What will be Web 3.0: blockchain-marketplace for machine learning</a></li>
<li><a href="../352726/index.html">Enough automation - it's time to draw an owl on PowerShell and teach the console to speak</a></li>
<li><a href="../352728/index.html">Standoff on the web</a></li>
<li><a href="../352732/index.html">Creating a simple RESTful API with Spark Framework</a></li>
<li><a href="../352734/index.html">Building an extended anti-virus protection system for a small enterprise. Part 1. Choosing a strategy and decision</a></li>
<li><a href="../352736/index.html">ActiveDirectory Integration into Aether Management Console</a></li>
<li><a href="../352738/index.html">Experimenting with AR: when C # meets CSS</a></li>
<li><a href="../352740/index.html">Fintech Digest: 70 Russians will teach the digital economy for 650 million rubles, the US tax and cryptocurrency, chatbot will get smarter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>