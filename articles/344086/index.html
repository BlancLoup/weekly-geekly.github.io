<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Preview documents in a Python program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the systems to which I relate, doc-files are added to the database. 
 I wondered if it was possible to attach a view of these files into my ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Preview documents in a Python program</h1><div class="post__text post__text-html js-mediator-article">  In one of the systems to which I relate, doc-files are added to the database. <br>  I wondered if it was possible to attach a view of these files into my own program working with the database. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8u/db/qw/8udbqw7zd4uyl3hb1zvcma0yedo.jpeg"></div><br>  For some reason, the natural solution of such problems is usually considered to launch MSWord with the file name on the command line.  But this way, to put it mildly, is not too safe - there may be macros in doc-e, or it may not be a doc at all, but a file specially prepared by a cracker.  Therefore, it is better to use a special viewing object implemented in the Office.  It is more secure, as it is not able to do anything other than viewing the document. <br><br>  And if we are not limited to one doc format, then as a bonus we will be able to view attached documents in other formats for which standard viewers are registered in Windows. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Looking ahead - everything turned out with the help of PyWin32.  True, suddenly in the process I had to compile my package to support the necessary COM interface, but there were no casualties. <br><a name="habracut"></a><br>  So what we know. <br><br><ol><li>  According to <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/cc144143(v%3Dvs.85).aspx">MSDN</a> , there are viewers in the system that implement the standard <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb775315(v%3Dvs.85).aspx">IPreviewHandler</a> interface, the interface is described in the Shobjidl.h browser. </li><li>  <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/cc144144(v%3Dvs.85).aspx">You can check</a> whether there is a registered viewer in the system for a specific file extension - if there is a branch <i>HKEY_CLASSES_ROOT \ &lt;extn&gt; \ Shellex \ {8895b1c6-b41f-4c1c-a562-0d564250836f}</i> (where " <i>&lt;extn&gt;</i> " is the file extension with a dot, i.e. " <i>.doc</i> ", " <i>.pdf</i> ", and so on), and there is a default value in it, then this value is the CLSID of the corresponding component. </li><li>  All registered viewers are listed in the registry branch <i>HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ PreviewHandlers</i> </li></ol><br>  Operating procedure: <br><br>  4. There is a document on disk. <br><br>  5. According to the file extension, we find the CLSID, using it we create a viewer object. <br><br>  6. The object is initialized with our file ‚Äî either by name or by an IStream stream ‚Äî more on this later. <br><br>  7. We indicate to the object the window in which it should be displayed by calling the SetWindow method - here we need the window handle, but there are no problems, the Qt widgets have a winId () method for this. <br><br>  8. To start viewing, call the object's DoPrevew method. <br><br>  9. If the window is resized, then SetRect must be called to resize the view accordingly. <br><br>  10. When the viewer is no longer needed, we call Unload on it. <br><br>  We need to figure out the easiest way in Python (I have not said that I have <a href="https://habrahabr.ru/post/336478/">a python program</a> ?) To create a component using its CLSID. <br><br>  On Stack Overflow, it is advised to put <a href="https://github.com/mhammond/pywin32">PyWin32</a> for such things.  Ok, let's try. <br><br><pre><code class="bash hljs">C:\&gt;pip3 install pywin32 Collecting pywin32 Could not find a version that satisfies the requirement pywin32 (from versions: ) No matching distribution found <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pywin32</code> </pre> <br>  What the‚Ä¶?  In the sense of "I can not find the version"? <br>  Google again - aha, you need to install "pypiwin32", because, as <a href="https://mail.python.org/pipermail/python-win32/2016-October/013786.html">said</a> : <br><blockquote>  Pypiwin32 is a repackaging of pywin32 to use sane packaging tools (namely <br>  wheels).  Its repackaged by the BDFL of the Twisted project.  If you use <br>  pip, or virtualenvs (and you should be using pip and virtualenvs, if you are <br>  not, start), use pypiwin32. <br></blockquote><br><pre> <code class="bash hljs">C:\&gt;pip3 install pypiwin32</code> </pre> <br>  Uh, set.  Great job done! <br><br>  Now you need to check, I write a small script: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 # -*- coding: utf-8 -*- import pythoncom import pywintypes adobe = pywintypes.IID('{DC6EFB56-9CFA-464D-8880-44885D7DC193}') CLSID_IPreviewHandler = '{8895B1C6-B41F-4C1C-A562-0D564250836F}' iid = pywintypes.IID(CLSID_IPreviewHandler) handler = pythoncom.CoCreateInstance( adobe, None, pythoncom.CLSCTX_LOCAL_SERVER, iid) print(handler)</span></span></code> </pre><br>  Here you can create one of the browsers available in the system, specifically for Adobe pdf.  Just created, without further action.  If it works, then you can pull its methods. <br><br>  Run and get that very surprise <br><br><pre> <code class="bash hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"C:\Projects\pytest\w1.py"</span></span>, line 19, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; iid) TypeError: There is no interface object registered that supports this IID</code> </pre><br>  That is, he created a viewer, but could not return ‚Äî no, you see, he has a registered interface object that supports the entot IID. <br><br>  In some respects, I agree with him - Python needs to know what methods the created COM object has in order to allow them to be called from the Python script.  This information is provided by the IDispatch interface, but it is not in this object ... <br><br>  So what to do?  Googling through the text of the error message, I find the <a href="https://groups.google.com/d/msg/comp.lang.python/GsmcdeJIxeI/RAP8c7A6eycJ">answer of the developer package</a> Mark Hammond: <br><blockquote>  <i>&gt; The document PythonCOM.html says that this is done using a "pyd" module that</i> <i><br></i>  <i>&gt; is imported.</i>  <i>It is accessed in</i> <i><br></i>  <i>&gt; this manner is a C or C ++ module must be created specifically for that</i> <i><br></i>  <i>&gt; interface?</i> <br><br>  Exactly.  Note however that the IDispatch <br>  this is true. <br><br>  <i>&gt; If this is needed, it is there that I can see an example</i> <i><br></i>  <i>&gt; of the code for that module?</i>  <i>If not, how do I tell Python about the</i> <i><br></i>  <i>&gt; interface object associated with the IID?</i> <br><br>  There are a number of examples in the win32com sources.  The most <br>  recent set are in the ‚Äúinternet‚Äù and ‚Äúaxcontrols‚Äù directory. <br><br>  Also there are 2 options for generating the C code.  One <br>  is to use "makegw" that comes with win32com - it takes a .h file <br>  that has geen itself generated from an IDL file <br>  code.  But its not very flexible.  There is also a SWIG, which is far <br>  more flexible, but probably not. <br>  .H file generated from an IDL, <br>  then check out "makegw" and the samples I mentioned (which <br>  themselves where generated with makepy) </blockquote><br>  In short, it offers to guide on the old, good C. Inklyudniki, compiler, linker - this is all that, going to Python, I wanted to avoid.  And offers to take examples from the source package.  I downloaded the sources, then they came in handy. <br><br>  And two options for assembly <br><br><ul><li>  ‚ÄúMakegw‚Äù included in the package </li><li>  <a href="https://ru.wikipedia.org/wiki/SWIG">SWIG</a> , which is cooler. </li></ul><br>  About SWIG found an article on Habr√© " <a href="https://habrahabr.ru/post/139790/">Python, Modules, SWIG, Windows</a> " <a href="https://habrahabr.ru/users/mclander/" class="user_link">mclander</a> , where everything seems to be good, easy and cool.  I downloaded this SWIG, tried to figure it out - it didn‚Äôt come out of the raid, but makegw did it. <br><br>  The makegw is a module with actually one function that needs to be run with the necessary parameters ‚Äî the path to the original user, in this case, ShObjIdl.h from the Windows SDK, and the desired interface, so I wrote a script. <br><br> <code>mk.py</code> <br> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32com.makegw.makegw inc = <span class="hljs-string"><span class="hljs-string">"C:/Program Files (x86)/Windows Kits/10/Include/10.0.14393.0/um/"</span></span> h = inc + <span class="hljs-string"><span class="hljs-string">"ShObjIdl.h"</span></span> win32com.makegw.makegw.make_framework_support(h, <span class="hljs-string"><span class="hljs-string">"IPreviewHandler"</span></span>)</code> </pre> <br>  The script worked, it turned out two files PyIPreviewHandler.cpp and PyIPreviewHandler.h.  Looking into the sishnik, I see the following picture: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// *** The input argument hwnd of type "__RPC__in HWND" was not processed *** // Please check the conversion function is appropriate and exists! __RPC__in HWND hwnd; PyObject *obhwnd; // @pyparm &lt;o Py__RPC__in HWND&gt;|hwnd||Description for hwnd</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// *** The input argument prc of type "__RPC__in const RECT *" was not processed *** // Please check the conversion function is appropriate and exists! __RPC__in const RECT prc; PyObject *obprc; // @pyparm &lt;o Py__RPC__in const RECT&gt;|prc||Description for prc</span></span></code> </pre><br>  That is, makegw could not, and did not try to figure out what the constructions "__RPC__in HWND", "__RPC__in const RECT *" mean, and so on.  What and warned. <br><br>  It was foolish to try to compile it, and I didn‚Äôt want to correct it either, so I tried to get around the problem - to replace these constructions with monosyllabic equivalents. <br><br>  I took ShObjIdl.h, tore the description of the IPreviewHandler interface from it into a separate file, changed the types of the parameters. <br><br><div class="spoiler">  <b class="spoiler_title">preview.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rpc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rpcndr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"windows.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ole2.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//#define __RPC__in #ifndef __IPreviewHandler_INTERFACE_DEFINED__ #define __IPreviewHandler_INTERFACE_DEFINED__ /* interface IPreviewHandler */ /* [uuid][object] */ #include "prtypes.h" EXTERN_C const IID IID_IPreviewHandler; MIDL_INTERFACE("8895b1c6-b41f-4c1c-a562-0d564250836f") IPreviewHandler : public IUnknown { public: virtual HRESULT STDMETHODCALLTYPE SetWindow( /* [in] */ HWND hwnd, /* [in] */ CRECTPTR prc) = 0; virtual HRESULT STDMETHODCALLTYPE SetRect( /* [in] */ CRECTPTR prc) = 0; virtual HRESULT STDMETHODCALLTYPE DoPreview( void) = 0; virtual HRESULT STDMETHODCALLTYPE Unload( void) = 0; virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0; virtual HRESULT STDMETHODCALLTYPE QueryFocus( /* [out] */ HWNDPTR phwnd) = 0; virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( /* [in] */ MSGPTR pmsg) = 0; }; #endif</span></span></span></span></code> </pre><br></div></div><br>  New types are described in a separate file. <br><br> <code>prtypes.h</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RECT *CRECTPTR; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MSG *CMSGPTR; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> MSG *MSGPTR; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> HWND *HWNDPTR;</code> </pre><br>  Accordingly, the script has changed the name of the attendant.  At the same time I turned off the generation of the gateway object - the fact is that I am going to get the implemented interface from the external library, and not create it in python, so I don‚Äôt need the gateway responsible for the generation. <br><br> <code>mk.py</code> <br> <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32com.makegw.makegw win32com.makegw.makegw.make_framework_support(<span class="hljs-string"><span class="hljs-string">"preview.h"</span></span>, <span class="hljs-string"><span class="hljs-string">"IPreviewHandler"</span></span>, bMakeGateway = <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Launched <br><br><pre> <code class="bash hljs">C:\Projects\pytest&gt;python mk.py IPreviewHandler</code> </pre> <br>  So, now you need to collect the package.  Having smoked the documentation in Python, I find out ( <a href="https://docs.python.org/3.6/extending/building.html">here</a> and <a href="https://docs.python.org/3.6/distutils/setupscript.html">here</a> ) that it is necessary and sufficient to build the setup.py script to build.  You, probably, already knew, and this is my first time, in the sense of building a package.  Do what <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from distutils.core import setup, Extension pypacks = "C:/Python/Lib/site-packages/" wdkinc = "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.14393.0\\" wdklib = "C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.14393.0\\" pywinsrc = "C:/Projects/Source/pywin32-221/" example_module = Extension('_preview', sources=['PyIPreviewHandler.cpp','prtypes.cpp'], include_dirs=[wdkinc + "ucrt", pywinsrc + "com/win32comext/shell/src", pypacks + "win32/include", pypacks + "win32com/include"], library_dirs=[wdklib + "ucrt\\x86", pypacks + "win32/libs", pypacks + "win32com/libs"] ) setup (name = 'preview', version = '0.1', author = "My", description = """Simple swig example from docs""", ext_modules = [example_module], py_modules = ["preview"], )</span></span></code> </pre><br>  I already had a Windows SDK (more precisely, the WDK, but not fundamentally) and the Visual Studio Community 2017, I was wondering if it would find them setup.py.  The compiler itself was found, and the path to the SDK had to be specified. <br><br><pre> <code class="bash hljs">C:\Projects\pytest&gt;python.exe setup.py build_ext --inplace &gt;err.txt error: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\cl.exe'</span></span> failed with <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> status 2</code> </pre> <br>  Of course, it did not meet, however, I did not expect that it would meet the first time.  Errors are clear: <br><br> <code>PyIPreviewHandler.cpp(46): error C3861: 'PyObject_AsCRECTPTR': identifier not found <br></code> <br><br>  I used to define new data types, but now we need data conversion functions of these types from python objects to C and vice versa.  Searching among the sources of PyWin32, I found within the function PyObject_AsRECT, PyObject_FromRECT, and so on - in a word, everything I needed.  I had to fix the generated sishnik to use these functions. <br><br>  It was: <br><br><pre> <code class="cpp hljs"> CRECTPTR prc; PyObject *obprc; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bPythonIsHappy &amp;&amp; !PyObject_AsCRECTPTR( obprc, &amp;prc )) bPythonIsHappy = FALSE; ... PyObject_FreeCRECTPTR(prc);</code> </pre><br>  It became: <br><br><pre> <code class="cpp hljs"> RECT prc; PyObject *obprc; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bPythonIsHappy &amp;&amp; !PyObject_AsRECT( obprc, &amp;prc )) bPythonIsHappy = FALSE; ... <span class="hljs-comment"><span class="hljs-comment">//PyObject_FreeCRECTPTR(prc);</span></span></code> </pre><br>  And so on, the benefit of the IPreviewHandler methods is not so much.  However, the conversion functions had to be pulled from the source and inserted into the prtypes.cpp file, because they were not included in the library in PyWin32. <br><br><div class="spoiler">  <b class="spoiler_title">prtypes.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shell_pch.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prtypes.h"</span></span></span><span class="hljs-meta"> BOOL PyObject_AsMSG( PyObject *obpmsg, MSG *msg ) { PyObject *obhwnd; return PyArg_ParseTuple(obpmsg, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Oiiii(ii)"</span></span></span><span class="hljs-meta">, &amp;obhwnd,&amp;msg-&gt;message,&amp;msg-&gt;wParam,&amp;msg-&gt;lParam,&amp;msg-&gt;time,&amp;msg-&gt;pt.x,&amp;msg-&gt;pt.y) &amp;&amp; PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&amp;msg-&gt;hwnd); } PyObject *PyObject_FromMSG(const MSG *msg) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!msg) { Py_INCREF(Py_None); return Py_None; } return Py_BuildValue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Niiii(ii)"</span></span></span><span class="hljs-meta">, PyWinLong_FromHANDLE(msg-&gt;hwnd),msg-&gt;message,msg-&gt;wParam,msg-&gt;lParam,msg-&gt;time,msg-&gt;pt.x,msg-&gt;pt.y); } BOOL PyObject_AsRECT( PyObject *ob, RECT *r) { return PyArg_ParseTuple(ob, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iiii"</span></span></span><span class="hljs-meta">, &amp;r-&gt;left, &amp;r-&gt;top, &amp;r-&gt;right, &amp;r-&gt;bottom); } PyObject *PyObject_FromRECT(const RECT *r) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!r) { Py_INCREF(Py_None); return Py_None; } return Py_BuildValue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iiii"</span></span></span><span class="hljs-meta">, r-&gt;left, r-&gt;top, r-&gt;right, r-&gt;bottom); }</span></span></code> </pre><br></div></div><br>  But now it is compiled without reference to the sources.  Compiled, but not going. <br><br><pre> <code class="bash hljs">LINK : error LNK2001: unresolved external symbol PyInit__preview build\temp.win32-3.6\Release\_preview.cp36-win32.lib : fatal error LNK1120: 1 unresolved externals</code> </pre><br>  It feels like you have not been told something.  <code>PyInit_xxx</code> similar to the standard name for module initialization, the only question is what should be in it how to register the interface.  I had to unravel the PyWin32 sources again and figure out what was needed for a complete build.  By analogy with the functions found, PyInit_xxx added his own. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PythonCOMRegister.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// For simpler registration of IIDs ... //     static struct PyMethodDef preview_methods[] = {{NULL}}; PyObject *PyInit__preview(void) { static PyModuleDef _preview_def = { PyModuleDef_HEAD_INIT, "_previewer", "Preview Handler Interface", -1, preview_methods }; PyObject *module=PyModule_Create(&amp;_preview_def); //   PyCom_RegisterClientType(&amp;PyIPreviewHandler::type, &amp;IID_IPreviewHandler); return module; }</span></span></span></span></code> </pre><br>  Now the <code>_preview.cp36-win32.pyd</code> file was <code>_preview.cp36-win32.pyd</code> (and here Stirlitz guessed that underlining was superfluous).  Install the resulting package. <br><br><pre> <code class="bash hljs">C:\Projects\pytest&gt;python.exe setup.py install</code> </pre> <br>  I check - in the same test script after <code>import _preview</code> just add <code>import _preview</code> <br><br><div class="spoiler">  <b class="spoiler_title">whole script</b> <div class="spoiler_text"><pre> <code class="python hljs">&lt;source lang=<span class="hljs-string"><span class="hljs-string">"python"</span></span>&gt;<span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 # -*- coding: utf-8 -*- import pythoncom import pywintypes import _preview adobe = pywintypes.IID('{DC6EFB56-9CFA-464D-8880-44885D7DC193}') CLSID_IPreviewHandler = '{8895B1C6-B41F-4C1C-A562-0D564250836F}' iid = pywintypes.IID(CLSID_IPreviewHandler) handler = pythoncom.CoCreateInstance( adobe, None, pythoncom.CLSCTX_LOCAL_SERVER, iid) print(handler)</span></span></code> </pre><br></div></div><br>  I launch and get: <br><br><pre> <code class="bash hljs">C:\Projects\Python\<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>&gt;python wincom.py &lt;PyIPreviewHandler at 0x00817770 with obj at 0x00745FFC&gt;</code> </pre> <br>  However, it works, the object is created. <br><br>  It remains to use the product as intended.  To check on different document formats, I wrote a script using QFileSystemModel and QTreeView from PyQt5, i.e.  on the left, I will have a file system tree, and on the right, a preview of the selected file. <br><br><img src="https://habrastorage.org/webt/mh/od/i3/mhodi3ekbbihl_fn1imrcdfauis.png"><br><br>  Script below.  It is simple enough to parse it line by line, just to say that unlike many examples on the Internet using IPreviewHandler, I don‚Äôt read the file into memory, but either open it directly with the viewer through the IInitializeWithFile interface (if it exists), or create a standard stream WinAPI function <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb759866(v%3Dvs.85).aspx">SHCreateStreamOnFileEx</a> (she, it turns out, is also supported by PyWin32) and pass this stream to the interface IInitializeWithStream - each of the two viewers necessarily has one of the two interfaces. <br><br><div class="spoiler">  <b class="spoiler_title">filepreview.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 # -*- coding: utf-8 -*- import pythoncom, win32comext import win32comext.propsys.propsys as propsys import win32comext.shell.shell as shellext import pywintypes import _preview from PyQt5.QtCore import * from PyQt5.QtWidgets import * CLSID_IPreviewHandler = '{8895B1C6-B41F-4C1C-A562-0D564250836F}' iid = pywintypes.IID(CLSID_IPreviewHandler) class PreviewWin(QWidget): def __init__(self, parent=None): super().__init__(parent) self.handler = None self.isFirst = True self.topLay = QHBoxLayout(self) self.splitter = QSplitter(self) self.topLay.addWidget(self.splitter) self.model = QFileSystemModel(self) self.model.setRootPath(QDir.currentPath()) self.tree = QTreeView(self.splitter) self.tree.setModel(self.model) cur = self.model.index(QDir.currentPath()) self.tree.setCurrentIndex(cur) self.tree.expand(cur) self.view = QWidget() self.splitter.addWidget(self.tree) self.splitter.addWidget(self.view) self.tree.clicked.connect(self.previewIndex) self.tree.setColumnWidth(0, 200) self.setWindowState(Qt.WindowMaximized) def resizeEvent(self, event): super().resizeEvent(event) if self.handler: self.handler.SetRect(self.view.rect().getRect()); def previewIndex(self, index): try: if self.handler: self.handler.Unload() self.handler = None if not index.isValid(): return filePath = QDir.toNativeSeparators(self.model.filePath(index)) ext = self.model.fileInfo(index).suffix() regPath = "HKEY_CLASSES_ROOT\\." + ext + "\\shellex\\" + CLSID_IPreviewHandler sets = QSettings(regPath, QSettings.NativeFormat) if not sets.contains("."): return classId = sets.value(".") if not classId: return self.handler = pythoncom.CoCreateInstance(classId, None, pythoncom.CLSCTX_LOCAL_SERVER, iid) if not self.handler: return STGM_READ = 0 try: iwfile = self.handler.QueryInterface(propsys.IID_IInitializeWithFile) except: iwfile = None if iwfile: try: iwfile.Initialize(filePath, STGM_READ) except: iwfile = None if not iwfile: try: iwstream = self.handler.QueryInterface(propsys.IID_IInitializeWithStream) except: print(str(sys.exc_info()[1])) iwstream = None if iwstream: iis = shellext.SHCreateStreamOnFileEx(filePath,STGM_READ,0,False) if iis: iwstream.Initialize(iis, STGM_READ) else: return else: print("Can't initialize preview for",filePath) return r = self.view.rect().getRect() self.handler.SetWindow(self.view.winId(), r); self.handler.DoPreview(); self.handler.SetFocus(); except: print(str(sys.exc_info()[1])) if __name__ == '__main__': import sys app = QApplication(sys.argv) w = PreviewWin() w.show() sys.exit(app.exec_())</span></span></code> </pre><br></div></div><br>  All files <a href="https://github.com/sshmakov/preview">are stacked on Github</a> . </div><p>Source: <a href="https://habr.com/ru/post/344086/">https://habr.com/ru/post/344086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344070/index.html">As in banks: the state will insure exchange investments of citizens in the amount of up to 1.4 million rubles</a></li>
<li><a href="../344076/index.html">The release of CLion 2017.3: significant improvements in C ++ support, integration with Valgrind Memcheck and Boost.Test, and more</a></li>
<li><a href="../344080/index.html">Debugging an evil bug in Go runtime</a></li>
<li><a href="../344082/index.html">A rather remarkable case of introducing video conferencing in one industrial enterprise.</a></li>
<li><a href="../344084/index.html">How we help quickly certify the requirements of information security to those who move to the cloud</a></li>
<li><a href="../344090/index.html">How to build a community. Translation of the book "Social Architecture": Chapter 1. Toolkit</a></li>
<li><a href="../344092/index.html">Product Design Digest, November 2017</a></li>
<li><a href="../344094/index.html">What I learned after 1000 code review</a></li>
<li><a href="../344098/index.html">Four releases of 1.0 from CNCF and major announcements about Kubernetes with KubeCon 2017</a></li>
<li><a href="../344100/index.html">Designed for data centers: a new generation of Dell EMC PowerEdge servers and converged systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>