<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell - Aesthetics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I invent a special game in the space simulator genre. According to one of the key concepts, the game will have a built-in programming language with wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell - Aesthetics</h1><div class="post__text post__text-html js-mediator-article">  I invent a special game in the space simulator genre.  According to one of the key concepts, the game will have a built-in programming language with which you can develop and improve algorithms for the interaction of game elements.  The design of such a language is not easy, considering its ‚Äúnaturalness‚Äù, and not ‚Äútextual‚Äù.  That is, language constructs are expressed in the form of different graphic objects.  Drawing sketches of his designs, I was suddenly distracted and instead of using the language for the game I began to invent a language to visualize the Haskell code.  It turned out so interesting that I could not leave the sketches just paper drawings.  In January 2012, I started writing a visualization server, and this is what happened ... <br><br><img src="https://habrastorage.org/storage2/cf5/30d/fcd/cf530dfcde1f40490c32b21308d8b701.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To visualize something, you first need to parse it into meaningful units, and then match them with graphic elements.  In the case of code, such units will be syntactic elements of the language, so, in the first step, we need to parse the code into an abstract syntax tree (AST).  The GHC compiler knows how to do it best, and there are even binders for it, which are what they do.  Scion is a library that allows you to analyze code through the GHC API.  Scion is used, for example, in EclipseFP for syntax highlighting and error analysis on the fly.  And it would be good if it were not for its complexity, which was useless in the early stages of development.  I did not want to write the parser manually.  It is curious that there was another way, simple and at the same time sufficient: the Language.Haskell library. <br><br>  The Language.Haskell.Parser module is a parser for pure, no extensions Haskell'98 code (well, almost no extensions).  The ‚Äúadvanced‚Äù programs will not spoil them, but at the beginning, Haskell'98 will suffice for the eyes.  As a guinea pig, I took the factorial calculation code: <br><br><blockquote>  fact 'n <font color="#339933">|</font>  n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  <font color="#339933">|</font>  <font>otherwise</font> <font color="#339933">=</font> fact ' <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  Parsing and analyzing using a library is done elementary, here‚Äôs an example of a simple program: <br><br><blockquote>  <font>import</font> language <font color="#339933">.</font>  Haskell <font color="#339933">.</font>  Parser <br><br>  main <font color="#339933">=</font> <font>do</font> <br>  s <font color="#339933">&lt;-</font> <font>readFile</font> <font>"Fact.hs"</font> <br>  <font>let</font> parsed <font color="#339933">=</font> parseModule s <br>  <font>putStrLn</font> <font color="#339933">.</font>  <font>show</font> <font color="#339933">$</font> parsed </blockquote><br><br>  The parseModule function has the following type: <br><br><blockquote>  parseModule <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> ParseResult HsModule </blockquote><br><br>  where the first argument is the Haskell code, and the value of the HsModule type is returned.  To work with the HsModule type, you need to connect the Language.Haskell.Syntax module.  Its type structure fully describes a subset of Haskell'98 as an AST: <br><br><blockquote>  ParseOk <br>  <font>(</font> HsModule <br>  <font>(</font> SrcLoc <font>{</font> srcFilename <font color="#339933">=</font> <font>"&lt;unknown&gt;"</font> <font color="#339933">,</font> srcLine <font color="#339933">=</font> <font>3</font> <font color="#339933">,</font> srcColumn <font color="#339933">=</font> <font>1</font> <font>}</font> <font>)</font> <br>  <font>(</font> Module <font>"Main"</font> <font>)</font> <br>  <font>(</font> Just <font>[</font> HsEVar <font>(</font> UnQual <font>(</font> HsIdent <font>"main"</font> <font>)</font> <font>)</font> <font>]</font> <font>)</font> <br>  <font>[</font> <font>]</font> <br>  <font>[</font> HsFunBind <br>  <font>[</font> HsMatch <br>  <font>(</font> SrcLoc <font>{</font> srcFilename <font color="#339933">=</font> <font>"&lt;unknown&gt;"</font> <font color="#339933">,</font> srcLine <font color="#339933">=</font> <font>3</font> <font color="#339933">,</font> srcColumn <font color="#339933">=</font> <font>1</font> <font>}</font> <font>)</font> <br>  <font>(</font> HsIdent <font>"fact '"</font> <font>)</font> <br>  <font>[</font> HsPVar <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>]</font> <br>  <font>(</font> HsGuardedRhss <br>  <font>[</font> HsGuardedRhs <br>  <font>(</font> SrcLoc <font>{</font> srcFilename <font color="#339933">=</font> <font>"&lt;unknown&gt;"</font> <font color="#339933">,</font> srcLine <font color="#339933">=</font> <font>3</font> <font color="#339933">,</font> srcColumn <font color="#339933">=</font> <font>9</font> <font>}</font> <font>)</font> <br>  <font>(</font> HsInfixApp <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsQVarOp <font>(</font> UnQual <font>(</font> HsSymbol <font>"=="</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsLit <font>(</font> HsInt <font>0</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsLit <font>(</font> HsInt <font>1</font> <font>)</font> <font>)</font> <br>  <font color="#339933">,</font> HsGuardedRhs <br>  <font>(</font> SrcLoc <font>{</font> srcFilename <font color="#339933">=</font> <font>"&lt;unknown&gt;"</font> <font color="#339933">,</font> srcLine <font color="#339933">=</font> <font>4</font> <font color="#339933">,</font> srcColumn <font color="#339933">=</font> <font>9</font> <font>}</font> <font>)</font> <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"otherwise"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsInfixApp <br>  <font>(</font> HsApp <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"fact '"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsParen <br>  <font>(</font> HsInfixApp <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsQVarOp <font>(</font> UnQual <font>(</font> HsSymbol <font>"-"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsLit <font>(</font> HsInt <font>1</font> <font>)</font> <font>)</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsQVarOp <font>(</font> UnQual <font>(</font> HsSymbol <font>"*"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>)</font> <font>)</font> <font>)</font> <font>]</font> <font>)</font> <font>[</font> <font>]</font> <font>]</font> <font>]</font> <font>)</font> </blockquote><br><br>  In the GraphServer project, I divided the AST tree into its components so that it was more convenient to work with it: <br><br><blockquote>  t1 <font color="#339933">=</font> HsInfixApp <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsQVarOp <font>(</font> UnQual <font>(</font> HsSymbol <font>"-"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsLit <font>(</font> HsInt <font>1</font> <font>)</font> <font>)</font> <br><br>  t2 <font color="#339933">=</font> HsApp <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"fact '"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsParen t1 <font>)</font> <br><br>  t3 <font color="#339933">=</font> HsInfixApp t2 <br>  <font>(</font> HsQVarOp <font>(</font> UnQual <font>(</font> HsSymbol <font>"*"</font> <font>)</font> <font>)</font> <font>)</font> <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"n"</font> <font>)</font> <font>)</font> <font>)</font> <br><br>  t4 <font color="#339933">=</font> HsGuardedRhs <font>(</font> SrcLoc <font>{</font> srcFilename <font color="#339933">=</font> <font>"&lt;unknown&gt;"</font> <font color="#339933">,</font> srcLine <font color="#339933">=</font> <font>4</font> <font color="#339933">,</font> srcColumn <font color="#339933">=</font> <font>9</font> <font>}</font> <font>)</font> <br>  <font>(</font> HsVar <font>(</font> UnQual <font>(</font> HsIdent <font>"otherwise"</font> <font>)</font> <font>)</font> <font>)</font> <br>  t3 <br>  <font color="#339933">...</font> </blockquote><br><br>  When the server will work as usual, it will be possible to send a string of Haskell code to it, which will be parsed by the server to AST and then rendered.  Now, in the active phase of development, the server is idling.  I simply select this or that ‚Äút-function‚Äù and start the whole process of visualization;  but under the apparent simplicity of various mechanisms and algorithms are hidden, the result of which you can see in the picture: <br><br><img src="https://habrastorage.org/storage2/8c2/531/9dc/8c25319dcb2466d033f40c2b1c49ca58.png"><br><br>  Here are security expressions along with the right parts of the functions: <br><br><blockquote>  <font color="#339933">|</font>  n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  <font color="#339933">|</font>  <font>otherwise</font> <font color="#339933">=</font> fact ' <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br><img align="right" src="https://habrastorage.org/storage2/58e/781/806/58e7818069032751ef6533cdc4962674.png"><br>  I wanted the graphical language to reflect the meaning of the syntax.  Security expressions work as ‚Äúexecution filters‚Äù.  We show the intuitiveness of the frame of thought experiment.  Imagine that the execution flow is such a cube that can pass through the frame to the body of the function, or it can not pass, depending on its size (‚Äúlogical condition‚Äù).  The arrows in the picture above show the progress.  What is fun, the frame, if you look at the scene from the front, turns into the very vertical line that we see in the code. <br><br><img align="right" src="https://habrastorage.org/storage2/e84/92c/6fb/e8492c6fbc867ae172ac5fc5ae4c6976.png"><br>  I tried to figure out how the list created by the operator would look: inside the pattern matching, and came so far to the variant in the pictures.  The first corresponds to the expression (x1: x2: xs), the second to the expression (x1: _: []).  Instead of the ‚Äúunimportant‚Äù element, a flat platform is depicted, and the empty list is the empty one.  The conditional if statement and the case construct are also somewhat intuitive.  I have other draft sketches on paper, but much of the Haskell syntax still needs to be developed.  This also applies to type declarations, and do-designs with its features, and pattern matching, and other important things.  And then the created sketches need to be embodied in the code ... <br><br><img src="https://habrastorage.org/storage2/888/314/0ed/8883140ed7c078944244c227b64a04cf.png"><br><br>  So, there is a task: to generate graphic elements using syntax elements, somehow position and merge them into one scene, and then draw it.  As we know, the process by which one language is transformed into another is called compilation.  After several unsuccessful trials, I came to a phased compilation, in which the code does not turn into a mess, and it can be supplemented.  Here are the steps: <br><br>  I. Converting an AST Element to a StructureObject Element <br>  Ii.  Map primitive to the StructureObject element <br>  Iii.  Merge and position StructureObject relative to each other <br>  Iv.  Compiling graphics primitives into scene elements <br>  V. Rendering (rendering) of the scene <br><br>  Before we get to the implementation, consider the modules into which the server code is broken. <br><br>  GraphServer (Main) - the main module of the program.  Contains main function, server logic;  it is the initialization of OpenGL, the creation of the window and the initial settings.  In the same place lies the main program loop, and the draw function from the Draw.Draw module runs in it. <br><br>  Common - common data and algorithms. <br>  Common.Constants - common constants, settings, fixed data. <br>  Common.GLTypes - OpenGL types (vectors, vertices, etc.), as well as other definitions. <br>  Common.TestData - "t-functions", additional data for testing mechanisms. <br>  Common.Units are functions for working with units of space, with OpenGL vectors and vertices. <br><br>  Structure - data types and algorithms for compiling an AST tree into a StructureObject tree. <br>  Structure.Constants - constants and settings associated with phases I, II, III. <br>  Structure.StructureObject - the description of the central data type StructureObject. <br>  Structure.GraphObject ‚Äî The GraphObject type description and functions that create an object of this type. <br>  Structure.Dimensions - working with dimensions of graphical objects. <br>  Structure.SOConstruct - creating a StructureObject.  Corresponds to stages I, II. <br>  Structure.SOConnect - connecting multiple StructureObjects.  Corresponds to stage III. <br>  Structure.GOCompile - compilation of graphic primitives (GraphObject) into real objects of the scene.  Corresponds to stage IV. <br>  Structure.HsSyntaxTools - auxiliary functions for working with AST. <br>  Structure.Texture - auxiliary data types and functions for working with textures. <br><br>  Draw - functions that are responsible for rendering the scene. <br>  Draw.Draw - contains the draw function, in which the scene is compiled and rendered. <br>  Draw.GLInit - helper functions designed, as the name implies, to initialize OpenGL. <br>  Draw.Render - contains the render function.  Corresponds to stage V. <br>  Draw.TextureInit - helper functions for creating textures. <br><br>  Misc - other auxiliary functions. <br>  Misc.BoxSide - functions from the HOpenGL library, in which the faces of the boxes are created. <br><br>  ThirdParty - third-party utilities and programs. <br>  ThirdParty.Frag - code from the program Frag.  Download TGA files, create textures. <br>  ThirdParty.GLUtil - additional utilities for working with OpenGL. <br>  ThirdParty.ImageFormats - download TGA files. <br><br><img src="https://habrastorage.org/storage2/678/8ce/ee9/6788ceee9f18f078709393c5c6bb9941.png"><br><br>  I am testing and running algorithms in the draw function mentioned above: <br><br><blockquote>  draw <font color="#339933">::</font> DrawFunction <br>  draw GLResources texRes n <font color="#339933">=</font> <font>do</font> <br>  <font>putStr</font> <font color="#339933">$</font> <font>"Current n ="</font> <font color="#339933">++</font> <font>show</font> n <br>  GL <font color="#339933">.</font>  clear <font>[</font> GL <font color="#339933">.</font>  ColorBuffer <font color="#339933">,</font> GL <font color="#339933">.</font>  DepthBuffer <font>]</font> <br>  GL <font color="#339933">.</font>  loadIdentity <br>  GL <font color="#339933">.</font>  rotate <font>10</font> <font>(</font> vector3 <font>0</font> <font>1</font> <font>0</font> <font>)</font> <br>  GL <font color="#339933">.</font>  rotate <font>20</font> <font>(</font> vector3 <font>1</font> <font>0</font> <font>0</font> <font>)</font> <br>  GL <font color="#339933">.</font>  translate <font>(</font> vector3 <font>(</font> <font color="#339933">-</font> <font>5</font> <font>)</font> <font>(</font> <font color="#339933">-</font> <font>10</font> <font>)</font> <font>(</font> <font color="#339933">-</font> <font>30</font> <font>)</font> <font>)</font> <br><br>  <font color="#5d478b">- Construct a hierarchy from StructureObject</font> <br>  <font>let</font> c <font color="#339933">=</font> constructFramedGRhss <font>(</font> OcsGuardedRhss t6 <font>)</font> <br><br>  <font color="#5d478b">- Compile scene elements from graphic primitives</font> <br>  <font color="#5d478b">- and draw a scene</font> <br>  render texRes c <br>  <font>putStrLn</font> <font>"Ok."</font> </blockquote><br><br><img src="https://habrastorage.org/storage2/f0a/6ab/5d1/f0a6ab5d15f0db45e89424053893d43e.png"><br><br>  The constructFramedGRhss and render functions do all the work, and at the output we get the pictures that are presented at the beginning of the article.  The constructFramedGRhss function (and its analogues) from the Structure.SOConstruct module implements steps I - III.  She has this type: <br><br><blockquote>  constructFramedGRhss <font color="#339933">::</font> ObjectConstructSpec <font color="#339933">-&gt;</font> StructureObject </blockquote><br><br>  It accepts a certain ObjectConstruct-specification, and returns the finished hierarchy from StructureObject.  The specification is just an ADT, where it is stated what syntactic unit we are dealing with: <br><br><blockquote>  <font color="#5d478b">- Structure.StructureObject Module</font> <br>  <font>data</font> ObjectConstructSpec <br>  <font color="#339933">=</font> OcsApp HsExp <br>  <font color="#339933">|</font>  OcsExpArgument HsExp <br>  <font color="#339933">|</font>  OcsExpFuncName HsExp StructureObject <br>  <font color="#339933">|</font>  OcsInfixOperator HsQOp <br>  <font color="#339933">|</font>  OcsGuardedRhs HsGuardedRhs <br>  <font color="#339933">|</font>  OcsFoundationExp StructureObject <br>  <font color="#339933">|</font>  OcsGuardedRhss HsRhs <br>  <font color="#339933">|</font>  OcsArrowBridge <br>  <font color="#339933">|</font>  OcsEqualSignBridge <br>  <font color="#339933">|</font>  OcsMatch HsMatch </blockquote><br><br>  The structureObject data type must be general enough to describe any possible hierarchical structure. <br><br><blockquote>  <font color="#5d478b">- Structure.StructureObject Module</font> <br>  <font>data</font> StructureObject <font color="#339933">=</font> StructureObject <br>  <font>{</font> soObjectSpec <font color="#339933">::</font> ObjectSpec <br>  <font color="#339933">,</font> soGeometry <font color="#339933">::</font> Geometry <br>  <font color="#339933">,</font> soGraphObjectSpec <font color="#339933">::</font> GraphObjectSpec <br>  <font color="#339933">,</font> soStructureObjects <font color="#339933">::</font> StructureObjects <br>  <font>}</font> <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> <br><br>  <font>type</font> StructureObjects <font color="#339933">=</font> <font>[</font> StructureObject <font>]</font> </blockquote><br><br>  As you can see, the soStructureObjects field contains a list of child objects.  In fact, the AST hierarchy is transformed into a StructureObject hierarchy with the accumulation of information necessary for rendering: position, size, graphic primitive, textures.  The tree is built starting from the lowest levels, since it is the only way to determine where in the space the element of the overlying level should be located.  This scheme imposes the restriction that it is impossible for the StructureObject objects to immediately assign absolute coordinates in the scene space: moving upward from the child objects, we cannot even imagine where the parent element will be.  Thus, all StructureObjects can only be positioned relative to their parent object;  that is, each StructureObject has its own offset in the OX, OY and OZ axes relative to the zero point of the parent.  It looks like this: <br><br><img src="https://habrastorage.org/storage2/a8d/68a/ade/a8d68aade0383f34953c231f42293cc5.png"><br><br>  The diagram conventionally depicts two StructureObjects: white panels correspond to the space of the parent object, brick panels correspond to the space of the child.  By themselves, StructureObjects are not displayed on the scene, but are considered containers for graphic objects (blue in the diagram).  Graphic objects are positioned relative to the zero point of the StructureObject containing them.  Dimensions (dimensions) of the StructureObject are the common dimensions of all substructures and are needed for calculations in the parent element.  The soGeometry field is of type Geometry.  It contains the total displacement and dimensions given by a three-dimensional vector: <br><br><blockquote>  <font color="#5d478b">- Common.GLTypes module</font> <br>  <font>type</font> Geometry <font color="#339933">=</font> <font>(</font> Translation <font color="#339933">,</font> Dimension <font>)</font> <br>  <font>type</font> GLfVector3 <font color="#339933">=</font> GL <font color="#339933">.</font>  Vector3 GL <font color="#339933">.</font>  GLfloat <br>  <font>type</font> Translation <font color="#339933">=</font> GLfVector3 <br>  <font>type</font> Dimension <font color="#339933">=</font> GLfVector3 </blockquote><br><br>  Similar data, as well as a graphic object, contains the field soGraphObjectSpec of the following type: <br><br><blockquote>  <font>type</font> GraphObjectSpec <font color="#339933">=</font> <font>(</font> Translation <font color="#339933">,</font> Dimension <font color="#339933">,</font> GraphObject <font>)</font> </blockquote><br><br>  The creation code of the StructureObject is extensive and divided into two modules.  Syntax elements, simple and complex, are converted to StructureObjects in the Structure.SOConstruct module.  Initially, the translation offset in the soGeometry field is equal to the zero vector.  We simply cannot know how the newly created StructureObject is located relative to the parent, and the parent does not even exist yet, nor does it necessarily appear in the future.  The offset is reviewed later, in the code that the child creates for itself;  or it simply remains zero, - then this object will be the guideline for its sub-objects.  In the code below - the creation of three simple objects ("variable", "platform", "bridge") and one complex (infix operator with arguments): <br><br><blockquote>  <font color="#5d478b">- Constructs an object for variable expression:</font> <br>  constructExp <font>(</font> OcsExpArgument <font>(</font> HsVar var <font>)</font> <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  varText <font color="#339933">=</font> makeName <font color="#339933">.</font>  getHsQualName <font color="#339933">$</font> var <br>  rawDim <font color="#339933">=</font> GL <font color="#339933">.</font>  Vector3 <font>(</font> hsNameLength varText <font>)</font> <font>2</font> <font>2</font> <br>  dim <font color="#339933">=</font> derivedDimensions <font>(</font> FuncDimensions variableBoxDims <font>)</font> rawDim <br>  graphObjSpec <font color="#339933">=</font> variableBox varText dim <br>  <font>in</font> StructureObject OsArgument <font>(</font> nullVector3 <font color="#339933">,</font> dim <font>)</font> graphObjSpec <font>[</font> <font>]</font> <br><br>  <font color="#5d478b">- Designed "platform":</font> <br>  constructFoundation <font color="#339933">::</font> ObjectConstructSpec <font color="#339933">-&gt;</font> StructureObject <br>  constructFoundation <font>(</font> OcsFoundationExp expSo <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  expSoDim <font color="#339933">=</font> geometryDim <font color="#339933">.</font>  soGeometry <font color="#339933">$</font> expSo <br>  dim <font color="#339933">=</font> derivedDimensions FoundationDimensions expSoDim <br>  graphObjSpec <font color="#339933">=</font> foundationBox dim <br>  <font>in</font> StructureObject OsFoundation <font>(</font> nullVector3 <font color="#339933">,</font> dim <font>)</font> graphObjSpec <font>[</font> <font>]</font> <br><br>  <font color="#5d478b">- Constructed "bridge":</font> <br>  constructBridge <font color="#339933">::</font> ObjectConstructSpec <font color="#339933">-&gt;</font> StructureObject <br>  constructBridge ocsBridgeType <font color="#339933">=</font> <font>let</font> <br>  dim <font color="#339933">=</font> vector3 <font>2</font> <font>0.25</font> <font>2</font> <br>  <font>(</font> graphObjSpec <font color="#339933">,</font> bType <font>)</font> <font color="#339933">=</font> <font>case</font> ocsBridgeType <font>of</font> <br>  OcsArrowBridge <font color="#339933">-&gt;</font> <font>(</font> arrowBridgeBox dim <font color="#339933">,</font> OsArrowBridge <font>)</font> <br>  OcsEqualSignBridge <font color="#339933">-&gt;</font> <font>(</font> equalSignBridgeBox dim <font color="#339933">,</font> OsEqualSignBridge <font>)</font> <br>  <font>in</font> StructureObject bType <font>(</font> nullVector3 <font color="#339933">,</font> dim <font>)</font> graphObjSpec <font>[</font> <font>]</font> <br><br>  <font color="#5d478b">- A complex object is constructed - an infix operator with arguments:</font> <br>  constructExp <font>(</font> OcsExpArgument <font>(</font> HsInfixApp exp1 qOp exp2 <font>)</font> <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  exp1So <font color="#339933">=</font> constructExp <font>(</font> OcsExpArgument exp1 <font>)</font> <br>  qOpSo <font color="#339933">=</font> constructQOp <font>(</font> OcsInfixOperator qOp <font>)</font> <br>  exp2So <font color="#339933">=</font> constructExp <font>(</font> OcsExpArgument exp2 <font>)</font> <br>  <font>in</font> connectStructureObjects OsInfixApp <font>[</font> exp1So <font color="#339933">,</font> qOpSo <font color="#339933">,</font> exp2So <font>]</font> </blockquote><br><br>  Creating a complex object, we must somehow arrange its child objects.  It is clear that for different syntactic units there will be different positions.  We need to calculate and assign an offset to objects relative to zero.  The parent, being a newly created object, will be shifted to zero (that is, not displaced at all), since we do not yet know how much to shift and what to do about it.  Offsets are calculated by the connectStructureObjects function from the Structure.SOConnect module.  The form of the syntactic unit and the list of sub-objects created earlier are transferred to it.  For each case, the connectStructureObjects function has its own calculation options. <br><br><blockquote>  connectStructureObjects <font color="#339933">::</font> ObjectSpec <font color="#339933">-&gt;</font> StructureObjects <font color="#339933">-&gt;</font> StructureObject <br><br>  <font color="#5d478b">- Connect infix operator and two expressions:</font> <br>  connectStructureObjects OsInfixApp <font>(</font> exp1So: opSo: exp2So: <font>[</font> <font>]</font> <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  exp1SoDim <font color="#339933">@</font> <font>(</font> GL <font color="#339933">.</font> Vector3 e1dl e1dh e1dw <font>)</font> <font color="#339933">=</font> geometryDim <font color="#339933">.</font>  soGeometry <font color="#339933">$</font> exp1So <br>  exp2SoDim <font color="#339933">=</font> geometryDim <font color="#339933">.</font>  soGeometry <font color="#339933">$</font> exp2So <br>  opSoDim <font color="#339933">@</font> <font>(</font> GL <font color="#339933">.</font> Vector3 opdl opdh opdw <font>)</font> <font color="#339933">=</font> geometryDim <font color="#339933">.</font>  soGeometry <font color="#339933">$</font> opSo <br>  exp1Trans <font color="#339933">=</font> nullVector3 <font color="#5d478b">- Expression 1 starts at parent zero</font> <br>  opTrans <font color="#339933">=</font> vector3 e1dl <font>0</font> <font>0</font> <font color="#5d478b">- The operator is shifted along OX by the length of expression 1 (located next to it)</font> <br>  exp2Trans <font color="#339933">=</font> vector3 <font>(</font> e1dl <font color="#339933">+</font> opdl <font>)</font> <font>0</font> <font>0</font> <font color="#5d478b">- Expression 2 is shifted by OY by the length of expression 1 and the length of the operator</font> <br>  generalDim <font color="#339933">=</font> generalizedDimension <font>[</font> <font>(</font> exp1Trans <font color="#339933">,</font> exp1SoDim <font>)</font> <font color="#5d478b">- Overall dimensions of the parent</font> <br>  <font color="#339933">,</font> <font>(</font> exp2Trans <font color="#339933">,</font> exp2SoDim <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> opTrans <font color="#339933">,</font> opSoDim <font>)</font> <font>]</font> <br>  newOpGoSpec <font color="#339933">=</font> <font>(</font> opTrans <font color="#339933">,</font> opSoDim <font color="#339933">,</font> graphObjectFromSpec <font color="#339933">.</font> soGraphObjectSpec <font color="#339933">$</font> opSo <font>)</font> <br>  newExp1So <font color="#339933">=</font> exp1So <font>{</font> soGeometry <font color="#339933">=</font> <font>(</font> exp1Trans <font color="#339933">,</font> exp1SoDim <font>)</font> <font>}</font> <br>  newExp2So <font color="#339933">=</font> exp2So <font>{</font> soGeometry <font color="#339933">=</font> <font>(</font> exp2Trans <font color="#339933">,</font> exp2SoDim <font>)</font> <font>}</font> <br>  <font>in</font> StructureObject OsInfixApp <font>(</font> nullVector3 <font color="#339933">,</font> generalDim <font>)</font> newOpGoSpec <font>[</font> newExp1So <font color="#339933">,</font> newExp2So <font>]</font> </blockquote><br><br>  Imagine empty space, lined with coordinate axes.  In the center of coordinates - zero.  Mentally add a small box to the scene, shifted to the right-up.  Now add a box of a different size, shifted to us and to the left.  If both of these boxes are subobjects of a parent, then their edges limit its space.  In the above scheme, the StructureObject is clearly visible: the object's space is determined by its contents.  But how to calculate the total dimensions of the parent?  We must take into account the displacement and size of each sub-element and find common minima, maxima of coordinates.  Then the minima are subtracted from the highs, and the overall dimensions are obtained.  We kind of draw the planes along the outermost edges of the objects, outlining the required space.  This algorithm is well implemented by convolving a list of offsets and sizes, and the function is called generalizedDimension. <br><br><blockquote>  <font color="#5d478b">- Structure.Dimensions module</font> <br>  generalizedDimension <font color="#339933">::</font> Geometries <font color="#339933">-&gt;</font> Dimension <br>  generalizedDimension <font>(</font> g: gs <font>)</font> <font color="#339933">=</font> toDimension <font>(</font> <font>foldr</font> f g gs <font>)</font> <br>  <font>where</font> <br>  f <font>(</font> <font>(</font> GL <font color="#339933">.</font> Vector3 dx1 dy1 dz1 <font>)</font> <font color="#339933">,</font> <font>(</font> GL <font color="#339933">.</font> Vector3 ax1 ay1 az1 <font>)</font> <font>)</font> <br>  <font>(</font> <font>(</font> GL <font color="#339933">.</font> Vector3 dx2 dy2 dz2 <font>)</font> <font color="#339933">,</font> <font>(</font> GL <font color="#339933">.</font> Vector3 ax2 ay2 az2 <font>)</font> <font>)</font> <font color="#339933">=</font> <br>  <font>(</font> vector3 <font>(</font> <font>min</font> dx1 dx2 <font>)</font> <font>(</font> <font>min</font> dy1 dy2 <font>)</font> <font>(</font> <font>min</font> dz1 dz2 <font>)</font> <font color="#339933">,</font> <br>  vector3 <font>(</font> <font>max</font> <font>(</font> dx1 <font color="#339933">+</font> ax1 <font>)</font> <font>(</font> dx2 <font color="#339933">+</font> ax2 <font>)</font> <font>)</font> <br>  <font>(</font> <font>max</font> <font>(</font> dy1 <font color="#339933">+</font> ay1 <font>)</font> <font>(</font> dy2 <font color="#339933">+</font> ay2 <font>)</font> <font>)</font> <br>  <font>(</font> <font>max</font> <font>(</font> dz1 <font color="#339933">+</font> az1 <font>)</font> <font>(</font> dz2 <font color="#339933">+</font> az2 <font>)</font> <font>)</font> <font>)</font> <br>  toDimension <font>(</font> <font>(</font> GL <font color="#339933">.</font> Vector3 x1 y1 z1 <font>)</font> <font color="#339933">,</font> <font>(</font> GL <font color="#339933">.</font> Vector3 x2 y2 z2 <font>)</font> <font>)</font> <font color="#339933">=</font> <br>  vector3 <font>(</font> <font>abs</font> <font>(</font> x2 <font color="#339933">-</font> x1 <font>)</font> <font>)</font> <font>(</font> <font>abs</font> <font>(</font> y2 <font color="#339933">-</font> y1 <font>)</font> <font>)</font> <font>(</font> <font>abs</font> <font>(</font> z2 <font color="#339933">-</font> z1 <font>)</font> <font>)</font> </blockquote><br><br><img align="right" src="https://habrastorage.org/storage2/99f/8a7/ce1/99f8a7ce1a56282d6c400d4bd8f1a168.png"><br>  Despite the cumbersome functions in the modules Structure.SOConstruct and Structure.SOConnect, I haven‚Äôt yet come up with anything better.  There is probably some kind of declarative solution, but it is unlikely that there will be less code.  There are also special cases that are difficult to fit into a single declarative scheme;  so, according to the design of the language, the function looks like a box of one unit in height, and its arguments are located on it.  It follows that in order to calculate the length of the box, one must take into account the number of arguments, their sizes and the distance between them.  The expression in the graphic language looks like a pyramid, which means that additional calculations arise associated with the protrusions of each underlying layer.  Summarizing this task, I created a ‚Äúmechanism of inherited dimensions‚Äù, in which derivedDimensions from the Structure.Dimensions module plays a key role.  It accepts the original dimensions of the element, the sizes of the necessary children and the algorithm of inheritance, expressed as a higher order function, and returns new, "inherited" dimensions.  The following is a simplified code from the constructExp function of a pre-previous listing: <br><br><blockquote>  <font>let</font> <br>  rawDim <font color="#339933">=</font> GL <font color="#339933">.</font>  Vector3 <font>1</font> <font>2</font> <font>2</font> <br>  dim <font color="#339933">=</font> derivedDimensions <font>(</font> FuncDimensions variableBoxDims <font>)</font> rawDim <br>  <font color="#339933">...</font> </blockquote><br><br>  Here, rawDim is the original size of the box for the variable, and dim is the new, ‚Äúinherited‚Äù dimensions.  The data constructor FuncDimensions belongs to a special data type DerivedDimensions: <br><br><blockquote>  <font color="#5d478b">- Structure.Dimensions module</font> <br>  <font>data</font> DerivedDimensions <font color="#339933">=</font> FuncDimensions <font>(</font> GLfVector3 <font color="#339933">-&gt;</font> GLfVector3 <font>)</font> <br>  <font color="#339933">|</font>  FoundationDimensions </blockquote><br><br>  The derivedDimensions function and higher order functions are defined as follows: <br><br><blockquote>  <font color="#5d478b">- Structure.Dimensions module</font> <br>  derivedDimensions <font color="#339933">::</font> DerivedDimensions <font color="#339933">-&gt;</font> GLfVector3 <font color="#339933">-&gt;</font> GLfVector3 <br>  derivedDimensions <font>(</font> FuncDimensions f <font>)</font> dim <font color="#339933">=</font> f dim <br>  derivedDimensions FoundationDimensions <font>(</font> GL <font color="#339933">.</font> Vector3 l h w <font>)</font> <font color="#339933">=</font> vector3 <font>(</font> l <font color="#339933">+</font> <font>2</font> <font>)</font> <font>0.25</font> <font>(</font> w <font color="#339933">+</font> <font>2</font> <font>)</font> <br><br>  <font color="#5d478b">- Functions to place into DerivedDimensions</font> <br>  <font color="#5d478b">- | |</font>  <font color="#5d478b">Calculate function box dimensions according to dims</font> <br>  funcBoxDerivedDims <font color="#339933">::</font> GLfVector3 <font color="#339933">-&gt;</font> GLfVector3 <font color="#339933">-&gt;</font> GLfVector3 <br>  funcBoxDerivedDims <font>(</font> GL <font color="#339933">.</font> Vector3 opl oph opw <font>)</font> <font>(</font> GL <font color="#339933">.</font> Vector3 fBoxl fBoxh fBoxw <font>)</font> <font color="#339933">=</font> <br>  <font>(</font> GL <font color="#339933">.</font> Vector3 <font>(</font> f opl fBoxh <font>)</font> fBoxh <font>(</font> <font>max</font> opw fBoxw <font>)</font> <font>)</font> <br>  <font>where</font> <br>  f op box <font color="#339933">|</font>  op <font color="#339933">&gt; =</font> box <font color="#339933">=</font> op <font color="#339933">+</font> <font>1</font> <br>  <font color="#339933">|</font>  <font>(</font> box <font color="#339933">-</font> op <font>)</font> <font color="#339933">&lt;</font> <font>1</font> <font color="#339933">=</font> op <font color="#339933">+</font> <font>1</font> <br>  <font color="#339933">|</font>  <font>(</font> box <font color="#339933">-</font> op <font>)</font> <font color="#339933">&gt; =</font> <font>1</font> <font color="#339933">=</font> box <br><br>  <font color="#5d478b">- | |</font>  <font color="#5d478b">Calculate dims for variable box</font> <br>  variableBoxDims <font color="#339933">::</font> GLfVector3 <font color="#339933">-&gt;</font> GLfVector3 <br>  variableBoxDims <font>(</font> GL <font color="#339933">.</font> Vector3 varl varh varw <font>)</font> <font color="#339933">=</font> <br>  <font>(</font> GL <font color="#339933">.</font> Vector3 <font>(</font> <font>if</font> varl <font color="#339933">&lt;</font> <font>2</font> <font>then</font> <font>2</font> <font>else</font> varl <font>)</font> varh varw <font>)</font> </blockquote><br><br><img align="right" src="https://habrastorage.org/storage2/991/b4f/51e/991b4f51ee2e88347a745748e861f04c.png"><br>  As you can see, for the FoundationDimensions constructor, the simplest algorithm is set in the derivedDimensions function, where the original dimensions are simply changed by a certain amount.  The length and width increase by 2, and the height becomes 0.25.  More complex cases are implemented using funcBoxDerivedDims and variableBoxDims.  For example, the dim from that simplified code will become GL.Vector3 2 2 2, because the calculation will be reduced to calling variableBoxDims (GL.Vector3 1 2 2).  If necessary, you can write other similar functions.  For even more intuitiveness of the graphic language, I plan to add arity of functions in the future.  It will look like the grooves on the box;  empty grooves correspond to a curving or section.  Of course, the mechanism of inherited dimensions alone will not be enough, because to determine arity we need more advanced code analysis than a simple decomposition into syntax.  But that's another story‚Ä¶ <br><br>  Of great interest is the type of data GraphObject - primitive, template, blank, the prototype of the future element of the scene.  At the initial stages of compilation, we do not need to know exactly the entire array of vertices of the primitive, it is easier to first set up some kind of blank, which then will be turned into real vertices, lines, faces.  Thus, we abstract from the graphic representation and can modify it if necessary, or even replace it with something else. <br><br><blockquote>  <font color="#5d478b">- Structure.GraphObjec Module</font> <br>  <font>data</font> GraphObject <font color="#339933">=</font> NoGraphObject <br>  <font color="#339933">|</font>  PrimitiveBox GLfVertex3 TextureName <br>  <font color="#339933">|</font>  TexturedBox GLfVertex3 ObjectTextureSpec <br>  <font color="#339933">|</font>  GraphObjects <font>[</font> GraphObjectSpec <font>]</font> <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> </blockquote><br><br>  It is easy to see that a StructureObject can have as many graphic objects (the GraphObjects constructor), and not even have them at all (the NoGraphObject constructor).  And this is understandable: in the AST tree displayed above, there is nothing for the HsGuardedRhss value to match the graphical one.  Rather, it will be a container for other objects, namely, for the right-hand parts of the function that contain guard expressions (Rhss - ‚Äúright hand sides‚Äù).  At the same time, ‚Äúreal‚Äù graphic objects are so far represented by only two elements: the primitive box PrimitiveBox and the advanced box TexturedBox.  Both boxes have a value of the GLfVertex3 type - these are just the dimensions according to which six textured faces will be created at stage IV.  The primitive box has one texture, and for TexturedBox it is possible to set a separate texture for each face.  The ObjectTextureSpec type is designed like this: <br><br><blockquote>  <font color="#5d478b">- Structure.Texture Module</font> <br>  <font>data</font> ObjectTextureSpec <font color="#339933">=</font> BoxTextureSpec <br>  <font>{</font> quadSideTexes <font color="#339933">::</font> <font>[</font> <font>(</font> BoxSide <font color="#339933">,</font> QuadColorSpec <font>)</font> <font>]</font> <br>  <font color="#339933">,</font> defQuadSideTex <font color="#339933">::</font> QuadColorSpec <br>  <font>}</font> <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> <br><br>  <font>data</font> QuadColorSpec <font color="#339933">=</font> QuadTexture TextureName <br>  <font color="#339933">|</font>  QuadPlainColor GLfColor4 <br>  <font color="#339933">|</font>  NoQuadColorSpec <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> <br><br>  <font color="#5d478b">- The BoxSide type is described in the Common.GLTypes module.</font> <br>  <font color="#5d478b">- It is easy to guess what he is:</font> <br>  <font>data</font> BoxSide <font color="#339933">=</font> SideTop <br>  <font color="#339933">|</font>  Sidebottom <br>  <font color="#339933">|</font>  Sideleft <br>  <font color="#339933">|</font>  Sidelight <br>  <font color="#339933">|</font>  Sidereear <br>  <font color="#339933">|</font>  Sidefront <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font color="#339933">,</font> <font color="#cccc00">Eq</font> <font>)</font> </blockquote><br><br>  Do you want the arrow to be on the top face, and all the others are textured by default?  No problems! <br><br><blockquote>  <font>let</font> texes <font color="#339933">=</font> <font>[</font> <font>(</font> SideTop <font color="#339933">,</font> QuadTexture arrowTex <font>)</font> <font>]</font> <br>  defaultTex <font color="#339933">=</font> QuadTexture yellowBaseTex <br>  boxTexSpec <font color="#339933">=</font> BoxTextureSpec texes defaultTex </blockquote><br><br>  Or just two faces with textures, and the rest - in some color?  And it can. <br><br><blockquote>  <font>let</font> texes <font color="#339933">=</font> <font>[</font> <font>(</font> SideFront <font color="#339933">,</font> QuadTexture arrowTex <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> SideRear <font color="#339933">,</font> QuadTexture arrowTex <font>)</font> <font>]]</font> <br>  defaultTex <font color="#339933">=</font> QuadPlainColor <font>(</font> color3 <font>1</font> <font>0</font> <font>0</font> <font>)</font> <br>  boxTexSpec <font color="#339933">=</font> BoxTextureSpec texes defaultTex </blockquote><br><br>  Elements of type GraphObject are constructed using mnemonic functions during the creation of a StructureObject.  Now in the Structure.GraphObject module there are the following functions: primitiveBox, variableBox, functionBox, foundationBox, arrowBridgeBox, equalSignBridgeBox, bridgeBox, and guardFrame.  For example, here are just a few functions: <br><br><blockquote>  <font color="#5d478b">- Structure.GraphObject Module</font> <br>  primitiveBox trans dim <font color="#339933">@</font> <font>(</font> GL <font color="#339933">.</font> Vector3 l h w <font>)</font> texName <font color="#339933">=</font> <font>(</font> trans <font color="#339933">,</font> dim <font color="#339933">,</font> PrimitiveBox <font>(</font> vertex3 l h w <font>)</font> texName <font>)</font> <br>  variableBox <font color="#339933">_</font> dim <font color="#339933">@</font> <font>(</font> GL <font color="#339933">.</font> Vector3 l h w <font>)</font> <font color="#339933">=</font> <font>(</font> nullVector3 <font color="#339933">,</font> dim <font color="#339933">,</font> PrimitiveBox <font>(</font> vertex3 l h w <font>)</font> helloTex <font>)</font> <br><br>  arrowBridgeBox dim <font color="#339933">=</font> bridgeBox dim arrowTex <br>  equalSignBridgeBox dim <font color="#339933">=</font> bridgeBox dim equalSignTex <br><br>  bridgeBox dim <font color="#339933">@</font> <font>(</font> GL <font color="#339933">.</font> Vector3 l h w <font>)</font> texName <font color="#339933">=</font> <br>  <font>(</font> nullVector3 <font color="#339933">,</font> dim <font color="#339933">,</font> TexturedBox <font>(</font> vertex3 lh w <font>)</font> boxTexSpec <font>)</font> <br>  <font>where</font> <br>  boxTexSpec <font color="#339933">=</font> BoxTextureSpec texes defTex <br>  texes <font color="#339933">=</font> <font>[</font> <font>(</font> SideTop <font color="#339933">,</font> QuadTexture texName <font>)</font> <font>]</font> <br>  defTex <font color="#339933">=</font> QuadTexture yellowBaseTex </blockquote><br><br><img src="https://habrastorage.org/storage2/2c1/451/550/2c14515509efb7fa104ba226f9457ebf.png"><br><br>  We should also tell about the rendering system.  At the moment I compile graphic primitives in the objects of the scene and immediately draw them.  This happens in the render function, which, as part of the draw function, is always spinning in the program loop.  Of course, such code is inefficient, because when you compile the same StructureObject tree, you get the same scene with objects, and you could prepare it ahead of time.  There are no obstacles here, besides rendering and compilation are easily separated if you return the list of actions [IO ()], and not to perform on the spot, as it is done now: <br><br><blockquote>  <font color="#5d478b">- Draw.Render module</font> <br>  render texRes <font>(</font> StructureObject <font color="#339933">_</font> <font>(</font> soTrans <font color="#339933">,</font> <font color="#339933">_</font> <font>)</font> goSpec objects <font>)</font> <font color="#339933">=</font> <font>do</font> <br>  GL <font color="#339933">.</font>  translate soTrans <font color="#5d478b">- set relative offset</font> <br>  <font>mapM_</font> <font>(</font> render texRes <font>)</font> objects <font color="#5d478b">- recursively descend the tree</font> <br>  <font>sequence_</font> <font color="#339933">$</font> compileGraphObjectSpec texRes goSpec <font color="#5d478b">- compile primitives and execute OpenGL calls</font> <br>  GL <font color="#339933">.</font>  translate  negateVector3 <font color="#339933">$</font> soTrans <font color="#5d478b">- remove the relative offset</font> </blockquote><br><br>  The rendering algorithm is recursive.  Going down the tree from the root StructureObject, we expose all new and new offsets for the child elements, and when returning to the previous level, we remove these offsets.  The compileGraphObjectSpec function compiles a GraphObject object into a scene object.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function sequence_ performs a list of actions [IO ()]. </font><font style="vertical-align: inherit;">Graphic objects also have a relative offset, so we make analogous coordinate shifts:</font></font><br><br><blockquote> <font color="#5d478b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Structure.GOCompile module</font></font></font> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compileGraphObjectSpec texRes </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goTrans </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_,</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> go </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let</font></font></font> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forwardTrans </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GL </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translate goTrans </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiled </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compileGraphObject texRes go </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">backwardTrans </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GL </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">google translate and </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negateVector3 </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goTrans </font></font><br> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forwardTrans: compiled </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++ </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> backwardTrans </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the code in the Structure.GOCompile module is very interesting for the techniques used (for example, convolutions and list comprehensions). Of course, such a code is harder to understand, but it seems to me that it has some kind of inner beauty and completeness, valuable in itself:</font></font><br><br><blockquote>  <font color="#5d478b">- | |</font>  <font color="#5d478b">Box side drawings.</font> <br>  <font color="#5d478b">- | |</font>  <font color="#5d478b">It should be used only in this module.</font> <br>  f <font color="#339933">::</font> PreparedTextureObjects <br>  <font color="#339933">-&gt;</font> GLfVertex3 <br>  <font color="#339933">-&gt;</font> <font>(</font> BoxSide <font color="#339933">,</font> QuadColorSpec <font>)</font> <br>  <font color="#339933">-&gt;</font> <font>(</font> <font>[</font> BoxSide <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font>]</font> <font>)</font> <br>  <font color="#339933">-&gt;</font> <font>(</font> <font>[</font> BoxSide <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font>]</font> <font>)</font> <br>  f texRes boxDim <font>(</font> side <font color="#339933">,</font> qColorSpec <font>)</font> <font>(</font> sList <font color="#339933">,</font> ioList <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  boxIO <font color="#339933">=</font> <font>do</font> setQuadColorSpec texRes qColorSpec <br>  GL <font color="#339933">.</font>  renderPrimitive GL <font color="#339933">.</font>  Quads <font>(</font> boxSide boxDim side <font>)</font> <br>  <font>in</font> <font>(</font> side: sList <font color="#339933">,</font> boxIO: ioList <font>)</font> <br><br>  <font color="#5d478b">- | |</font> <font color="#5d478b">Compiles GraphObject into action list structure, which is ready-to-eval. ([IO ()])</font> <br> compileGraphObject <font color="#339933">::</font> PreparedTextureObjects <font color="#339933">-&gt;</font> GraphObject <font color="#339933">-&gt;</font> <font>[</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font>]</font> <br><br> compileGraphObject <font color="#339933">_</font> NoGraphObject <font color="#339933">=</font> <font>[</font> <font>]</font> <br><br> compileGraphObject texRes <font>(</font> GraphObjects gObjectSpecs <font>)</font> <font color="#339933">=</font> <br> <font>concatMap</font> <font>(</font> compileGraphObjectSpec texRes <font>)</font> gObjectSpecs <br><br> compileGraphObject texRes <font>(</font> PrimitiveBox boxDim texName <font>)</font> <font color="#339933">=</font> <br> <font>[</font> <font>do</font> GL <font color="#339933">.</font> color colorWhite <br>  GL <font color="#339933">.</font> textureBinding GL <font color="#339933">.</font> Texture2D GL <font color="#339933">.$=</font> <font>lookup</font> texName texRes <br>  GL <font color="#339933">.</font>  renderPrimitive GL <font color="#339933">.</font> Quads <font>(</font> allBoxSides boxDim <font>)</font> <font>]</font> <br><br> compileGraphObject texRes <font>(</font> TexturedBox boxDim boxTexSpec <font>)</font> <font color="#339933">=</font> <font>let</font> <br> <font>(</font> BoxTextureSpec sideTexes defTex <font>)</font> <font color="#339933">=</font> boxTexSpec <br> <font>(</font> textedSides <font color="#339933">,</font> textedSideDrawList <font>)</font> <font color="#339933">=</font> <font>foldr</font> <font>(</font> f texRes boxDim <font>)</font> <font>(</font> <font>[</font> <font>]</font> <font color="#339933">,</font> <font>[</font> <font>]</font> <font>)</font> sideTexes <br> untextedSides <font color="#339933">=</font> <font>[</font> s <font color="#339933">|</font> s <font color="#339933">&lt;-</font> boxSideList <font color="#339933">,</font> s ` <font>notElem</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">`textedSides </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></font> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untextedQColor </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setQuadColorSpec texRes defTex </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untextedSidesDraw </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GL </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></font>  renderPrimitive GL <font color="#339933">.</font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quads </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> boxSides boxDim untextedSides </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <br> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untextedQColor: untextedSidesDraw: textedSideDrawList</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boxes consist of faces, and faces are filled with color or texture. </font><font style="vertical-align: inherit;">In OpenGL, any shape can be drawn vertically; </font><font style="vertical-align: inherit;">in our case, these will be the vertices of the quadrilateral. </font><font style="vertical-align: inherit;">The vertices are calculated from the length, height and width contained in dim, and the zero point corresponds to the corner of the box from left to bottom to back (simply because the axes in the OpenGL coordinate system are so directed: OX to the right, OY to up, OZ to us) . </font><font style="vertical-align: inherit;">Faces are created in the Misc.BoxSide module using functions from the HOpenGL library.</font></font><br><br><blockquote> boxSide <font color="#339933">::</font> GLfVertex3 <font color="#339933">-&gt;</font> BoxSide <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br><br> boxSide <font>(</font> GL <font color="#339933">.</font> Vertex3 x y z <font>)</font> SideTop <font color="#339933">=</font> <font>do</font> <br>  GL <font color="#339933">.</font> texCoord texCoordDR <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 x y z <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordUR <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 x y <font>0</font> <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordUL <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 <font>0</font> y <font>0</font> <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordDL <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 <font>0</font> y z <font>)</font> <br><br> boxSide <font>(</font> GL <font color="#339933">.</font> Vertex3 x y z <font>)</font> SideFront <font color="#339933">=</font> <font>do</font> <br>  GL <font color="#339933">.</font> texCoord texCoordUR <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 x y z <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordUL <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 <font>0</font> y z <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordDL <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 <font>0</font> <font>0</font> z <font>)</font> <br>  GL <font color="#339933">.</font> texCoord texCoordDR <font color="#339933">&gt;&gt;</font> GL <font color="#339933">.</font> vertex <font>(</font> vertex3 x <font>0</font> z <font>)</font> <br><br> <font color="#5d478b">-- ...      6 .</font> <br><br> boxSideList <font color="#339933">=</font> <font>[</font> SideTop <font color="#339933">,</font> SideBottom <font color="#339933">,</font> SideLeft <font color="#339933">,</font> SideRight <font color="#339933">,</font> SideRear <font color="#339933">,</font> SideFront <font>]</font> <br> boxSides    boxDim <font color="#339933">=</font> <font>mapM_</font> <font>(</font> boxSide boxDim <font>)</font> <br> allBoxSides boxDim <font color="#339933">=</font> boxSides boxDim boxSideList </blockquote><br><br><img align="right" src="https://habrastorage.org/storage2/6c2/813/4c5/6c28134c50cd1cf6ec25ab91ff40d7d8.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, we rather superficially traced the general structure of the GraphServer program. I will not describe how the server part of the program is arranged, how pictures are loaded from files, how textures are created from pictures, how third-party utilities are used. There is still a lot of work, the visualization server is ready for 10 percent. The work is complicated by the fact that not all sketches are ready for all elements of Haskell. There are difficulties with visualization, which is very clearly seen in the screenshots; Still, debug textures are far from ideal. I would like to normalize the stretching of textures on an object, decorate it, create something more harmonious, and work on the design. Still need fonts and line drawing; in the future, analysis of functions on arity will be added, and this is another refactoring, other approaches, other methods. And again, it will require subtle techniques, tricky algorithms,smart data structures, which themselves are not easy to develop oh ... The project is large-scale, deep and bringing aesthetic pleasure. I invite everyone to join it: this is a practice in Haskell, and experience in designing large programs, and knowledge in graphics, and the study of algorithms. But above all, this art and creativity - that makes our lives more beautiful.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is open and located on GitHub: </font></font><a href="https://github.com/graninas/GraphServer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/graninas/GraphServer</font></font></a> <br><br>  This is a cross article.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the design of the graphic language, read the article </font></font><a href="http://habrahabr.ru/blogs/Haskell/139167/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Haskell - Design</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="http://habrahabr.ru/blogs/Haskell/139167/"><font style="vertical-align: inherit;">" </font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Please readers: if you are interested in joining the project, contact me in a personal, in ICQ or by mail. </font><font style="vertical-align: inherit;">Mail on Google, nickname is the same as on Habr√©. </font><font style="vertical-align: inherit;">If you can, promote the article among other Haskell fans, or among those who would like to explore it by joining the project. </font><font style="vertical-align: inherit;">Collective development will require some adaptation of the project and tools. </font><font style="vertical-align: inherit;">I promise to approach the matter professionally.</font></font></div><p>Source: <a href="https://habr.com/ru/post/138884/">https://habr.com/ru/post/138884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138878/index.html">Expanding PHPMailer</a></li>
<li><a href="../138879/index.html">Concept UI for Windows 8</a></li>
<li><a href="../138880/index.html">Full-HD Voice Mobile Codec</a></li>
<li><a href="../138881/index.html">Dragon curves and bug</a></li>
<li><a href="../138883/index.html">Tips for PC buyers in the fall of 1995</a></li>
<li><a href="../138885/index.html">32 millisecond cursor delay on Mac OS X</a></li>
<li><a href="../138886/index.html">Linux 2.6, PHP 5.3 and PostgreSQL 9.1 recognized as open source software with high quality code</a></li>
<li><a href="../138887/index.html">A router based on a PC or laptop in a couple of minutes</a></li>
<li><a href="../138888/index.html">Font using dots instead of letters</a></li>
<li><a href="../138889/index.html">Use of IEEE 802.1x standard in data network</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>