<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using metaclasses in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some metaprogramming tools are not often used daily. 
 work, as usual in OOP classes or the same decorators. For understanding the same goals 
 introd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using metaclasses in Python</h1><div class="post__text post__text-html js-mediator-article">  Some metaprogramming tools are not often used daily. <br>  work, as usual in OOP classes or the same decorators.  For understanding the same goals <br>  introducing such tools into the language requires specific examples of industrial <br>  applications, some of which are listed below. <br><br><a name="habracut"></a><br><br><h4>  Introduction to Metaclasses </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, classical OOP implies the presence of only classes and objects. <br>  Class - template for the object;  when declaring a class, all the mechanics are indicated <br>  the work of each particular "incarnation": set the data encapsulated <br>  in the object, and methods for working with this data. <br><br><br>  Python expands the classical paradigm, and the classes themselves in it also become <br>  peer objects that can be changed, assigned to a variable and <br>  pass in functions.  But if a class is an object, which class does it correspond to? <br>  By default, this class (metaclass) is called type. <br><br>  You can inherit from metaclass by getting a new metaclass, which, in its <br>  queue can be used when defining new classes.  In this way, <br>  a new ‚Äúdimension‚Äù of inheritance appears, adding to the inheritance hierarchy <br>  classes: metaclass -&gt; class -&gt; object. <br><br><h4>  Simple example </h4><br><br>  Suppose we are tired of setting the attributes in the constructor __init __ (self, * args, <br>  ** kwargs)  I would like to speed up this process so that <br>  the ability to set attributes directly when creating a class object.  With the usual <br>  class this will not work: <br><br><pre>   &gt;&gt;&gt; class Man (object):
   &gt;&gt;&gt; pass
   &gt;&gt;&gt; me = Man (height = 180, weight = 80)
   Traceback (most recent call last):
   File "&lt;stdin&gt;", line 20, in &lt;module&gt;
       TypeError: object .__ new __ () takes no parameters
</pre><br><br>  The object is constructed by calling the class with the "()" operator.  Create inheritance from <br>  type metaclass to override this statement: <br><br><br><pre>   &gt;&gt;&gt; class AttributeInitType (type):
   &gt;&gt;&gt; def __call __ (self, * args, ** kwargs):
   &gt;&gt;&gt; "" "Calling a class creates a new object." ""
   &gt;&gt;&gt; # First of all we create the object itself ...
   &gt;&gt;&gt; obj = type .__ call __ (self, * args)
   &gt;&gt;&gt; # ... and add the arguments passed to it as attributes.
   &gt;&gt;&gt; for name in kwargs:
   &gt;&gt;&gt; setattr (obj, name, kwargs [name])
   &gt;&gt;&gt; # return the finished object
   &gt;&gt;&gt; return obj
</pre><br>  Now create a class using the new metaclass: <br><br><pre>   &gt;&gt;&gt; class Man (object):
   &gt;&gt;&gt; __metaclass__ = AttributeInitType
</pre><br>  Voila: <br><br><pre>   &gt;&gt;&gt; me = Man (height = 180, weigth = 80)
   &gt;&gt;&gt; print me.height
   180
</pre><br><br><h4>  Language extension (abstract classes) </h4><br>  The Python core is relatively small and simple, a set of built-in tools. <br>  small, allowing developers to quickly master the language. <br><br><br>  However, programmers involved in creating, for example, frameworks and <br>  related special sublanguages ‚Äã‚Äã(domain specific languages) are provided <br>  quite flexible tools. <br><br>  Abstract classes (or their slightly different form - interfaces) - common <br>  and popular among programmers method of determining the interface part <br>  class.  Usually such concepts are laid in the core of the language (as in Java or C ++), <br>  Python also allows you to gracefully and easily implement their own means, in <br>  Particulars - with the help of metaclasses and decorators. <br><br>  Consider the work of the abc library from the implementation proposal for the standard library. <br><br><h5>  abc </h5><br><br>  Using asbestos classes is very easy.  Create an abstract base class <br>  with a virtual method and try to create a class-successor without defining this method: <br><br><pre>
 &gt;&gt;&gt; from abc import ABCMeta, abstractmethod
 &gt;&gt;&gt; class A (object):
 &gt;&gt;&gt; __metaclass __ = ABCMeta
 &gt;&gt;&gt; @abstractmethod
 &gt;&gt;&gt; def foo (self): pass
 &gt;&gt;&gt; 
 &gt;&gt;&gt; A ()  
 Traceback (most recent call last):
   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
 TypeError: Can't instantiate
</pre><br>  Did not work.  Now we define the desired method: <br><br><pre>  
 &gt;&gt;&gt; class C (A):
 &gt;&gt;&gt; def foo (self): print (42)
 &gt;&gt;&gt; C
 &lt;class '__main __. C'&gt;
 &gt;&gt;&gt; a = C ()
 &gt;&gt;&gt; a.foo ()
 42
</pre><br>  We learn how this is implemented in the metaclass (omitting some other possibilities <br>  module abc) ABCMeta: <br><br><pre> &gt;&gt;&gt; class ABCMeta (type):
 &gt;&gt;&gt; def __new __ (mcls, name, bases, namespace):
 &gt;&gt;&gt; bases = _fix_bases (bases)
 &gt;&gt;&gt; cls = super (ABCMeta, mcls) .__ new __ (mcls, name, bases, namespace)
 &gt;&gt;&gt; # Find the set (set) of abstract method names among our own
 &gt;&gt;&gt; # methods and methods of ancestors
 &gt;&gt;&gt; abstracts = set (name
 &gt;&gt;&gt; for name, value in namespace.items ()
 &gt;&gt;&gt; if getattr (value, "__isabstractmethod__", False))
 &gt;&gt;&gt; for base in bases:
 &gt;&gt;&gt; for name in getattr (base, "__abstractmethods__", set ()):
 &gt;&gt;&gt; value = getattr (cls, name, None)
 &gt;&gt;&gt; if getattr (value, "__isabstractmethod__", False):
 &gt;&gt;&gt; abstracts.add (name)
 &gt;&gt;&gt; cls .__ abstractmethods__ = frozenset (abstracts)
 &gt;&gt;&gt; return cls
</pre><br>  The _fix_bases method adds the hidden class _Abstract to the number of ancestors <br>  abstract class.  _Abstract itself checks if anything is left <br>  set (set) __abstractmethods__;  if left, throws an exception. <br><br><pre> &gt;&gt;&gt; class _Abstract (object):
 &gt;&gt;&gt; def __new __ (cls, * args, ** kwds):
 &gt;&gt;&gt; am = cls .__ dict __. get ("__ abstractmethods__")
 &gt;&gt;&gt; if am:
 &gt;&gt;&gt; raise TypeError ("can't instantiate abstract class% s"
 &gt;&gt;&gt; "with abstract methods% s"%
 &gt;&gt;&gt; (cls .__ name__, "," .join (sorted (am))))
 &gt;&gt;&gt; return super (_Abstract, cls) .__ new __ (cls, * args, ** kwds)
 &gt;&gt;&gt;
 &gt;&gt;&gt; def _fix_bases (bases):
 &gt;&gt;&gt; for base in bases:
 &gt;&gt;&gt; if issubclass (base, _Abstract):
 &gt;&gt;&gt; # _Abstract is already among ancestors
 &gt;&gt;&gt; return bases
 &gt;&gt;&gt; if object in bases:
 &gt;&gt;&gt; # Replace object with _Abstract if the class is directly inherited from object
 &gt;&gt;&gt; # and not listed among other ancestors
 &gt;&gt;&gt; return tuple ([_ Abstract if base is object else base
 &gt;&gt;&gt; for base in bases])
 &gt;&gt;&gt; # Add _Abstract to the end otherwise
 &gt;&gt;&gt; return bases + (_Abstract,)
</pre><br>  In each abstract class is stored on the "frozen" set (frozenset) <br>  abstract methods;  that is, those methods (object functions) that have <br>  the __isabstractmethod__ attribute exposed by the corresponding decorator: <br><br><pre> &gt;&gt;&gt; def abstractmethod (funcobj):
 &gt;&gt;&gt; funcobj .__ isabstractmethod__ = True
 &gt;&gt;&gt; return funcobj
</pre><br>  So, the abstract method gets the __isabstractmethod__ attribute when it is assigned <br>  decorator.  Attributes after inheriting from an abstract class are collected in <br>  set "__abstractmethods__" of a heir class.  If the set is not empty, and <br>  the programmer tries to create a class object, then an exception will be thrown <br>  TypeError with a list of undefined methods. <br><br><h5>  Conclusion </h5><br>  Simply?  Simply.  Is the language expanded?  Expanded  Comments, as they say, are superfluous. <br><br><h4>  DSL in Django </h4><br>  One of the advanced examples of DSL is the Django ORM mechanism using the Model class as an example. <br>  metaclass modelbase.  Specifically, the connection with the database is not interesting here, it has <br>  It makes sense to concentrate on creating an instance of a class derived from Model. <br><br>  Most of the following subsection is a detailed code review. <br>  ModelBase.  Readers who do not need details, just read the output <br>  at the end of the "Django" section. <br><br><h5>  Analysis of ModelBase metaclass </h5><br>  All the mechanics of the ModelBase metaclass are concentrated in place. <br>  overriding the __new__ method called immediately before creation <br>  model class instance: <br><br><pre>   &gt;&gt;&gt; class ModelBase (type):
   &gt;&gt;&gt; "" "
   &gt;&gt;&gt; Metaclass for all models.
   &gt;&gt;&gt; "" "
   &gt;&gt;&gt; def __new __ (cls, name, bases, attrs):
   &gt;&gt;&gt; super_new = super (ModelBase, cls) .__ new__
   &gt;&gt;&gt; parents = [b for b in bases if isinstance (b, ModelBase)]
   &gt;&gt;&gt; if not parents:
   &gt;&gt;&gt; # If this isn't a subclass of Model, don't do anything special.
   &gt;&gt;&gt; return super_new (cls, name, bases, attrs)
</pre><br>  At the very beginning of the method an instance of the class is simply created and, if this class is not <br>  inherits from Model, just returns. <br><br>  All specific model class options are collected in the _meta class attribute, which <br>  can be created from scratch, inherited from an ancestor, or adjusted to <br>  Local class Meta: <br><br><pre>   &gt;&gt;&gt; #Class creation
   &gt;&gt;&gt; module = attrs.pop ('__ module__')
   &gt;&gt;&gt; new_class = super_new (cls, name, bases, {'__module__': module})
   &gt;&gt;&gt; attr_meta = attrs.pop ('Meta', None)
   &gt;&gt;&gt; abstract = getattr (attr_meta, 'abstract', False)
   &gt;&gt;&gt; if not attr_meta:
   &gt;&gt;&gt; meta = getattr (new_class, 'Meta', None)
   &gt;&gt;&gt; else:
   &gt;&gt;&gt; meta = attr_meta
   &gt;&gt;&gt; base_meta = getattr (new_class, '_meta', None)
</pre><br>  In addition, we see that a class can be abstract, not relevant <br>  any table in the database. <br><br>  The moment of truth in the process of creating a class of model comes with the introduction into it <br>  default settings: <br><br><pre>   &gt;&gt;&gt; new_class.add_to_class ('_ meta', Options (meta, ** kwargs))
</pre><br>  add_to_class either calls the argument‚Äôs method contribute_to_class or, if <br>  there is none, just adds the named attribute to the class. <br><br>  The Options class in its contribute_to_class makes the _meta attribute a reference to <br>  himself and collects in it various parameters, like the name of the base table <br>  data, model field list, model virtual field list, access rights, and <br>  others.  He also carries out tests of connections with other models for uniqueness. <br>  field names in the database. <br><br>  Next, in the __new__ method, the named class is added to the non-abstract class. <br>  exceptions: <br><br><pre>   &gt;&gt;&gt; if not abstract:
   &gt;&gt;&gt; new_class.add_to_class ('DoesNotExist',
   &gt;&gt;&gt; subclass_exception ('DoesNotExist', ObjectDoesNotExist, module))
   &gt;&gt;&gt; new_class.add_to_class ('MultipleObjectsReturned',
   &gt;&gt;&gt; subclass_exception ('MultipleObjectsReturned',
   &gt;&gt;&gt; MultipleObjectsReturned, module))
</pre><br>  If the parent class is not abstract, and the parameters are not set explicitly in the local <br>  class Meta, then inheriting ordering and get_latest_by parameters: <br><br><pre>   &gt;&gt;&gt; if base_meta and not base_meta.abstract: &gt;&gt;&gt; if not hasattr (meta, 'ordering'): &gt;&gt;&gt; new_class._meta.ordering = base_meta.ordering &gt;&gt;&gt; if not hasattr (meta, 'get_latest_by') : &gt;&gt;&gt; new_class._meta.get_latest_by = base_meta.get_latest_by </pre><br>  The default manager should be zero.  If such a model already exists, terminate processing by returning this model: <br><br><pre>   &gt;&gt;&gt; if getattr (new_class, '_default_manager', None):
   &gt;&gt;&gt; new_class._default_manager = None
   &gt;&gt;&gt;        
   &gt;&gt;&gt; m = get_model (new_class._meta.app_label, name, False)
   &gt;&gt;&gt; if m is not None:
   &gt;&gt;&gt; return m
</pre><br><br>  Nothing special, just adding attributes to the model class with which it was <br>  created by: <br><br><pre>   &gt;&gt;&gt; for obj_name, obj in attrs.items ():
   &gt;&gt;&gt; new_class.add_to_class (obj_name, obj)
</pre><br>  Now you need to go through the fields of the model and find one-to-one relationships, <br>  which will be used below: <br><br><pre>   &gt;&gt;&gt; # Do the appropriate setup for any model parents.
   &gt;&gt;&gt; o2o_map = dict ([(f.rel.to, f) for f in new_class._meta.local_fields
   &gt;&gt;&gt; if isinstance (f, OneToOneField)])
</pre><br>  Passing through the ancestors of the model for the inheritance of various fields, with discarding those <br>  that are not heirs to the Model.  Further comments are translated, which <br>  enough to understand what is happening: <br><br><pre>   &gt;&gt;&gt; for base in parents:
   &gt;&gt;&gt; if not hasattr (base, '_meta'):
   &gt;&gt;&gt; # Models without _meta are not active and do not represent interest
   &gt;&gt;&gt; continue
   &gt;&gt;&gt;
   &gt;&gt;&gt; # All fields of any type for this model
   &gt;&gt;&gt; new_fields = new_class._meta.local_fields + \
   &gt;&gt;&gt; new_class._meta.local_many_to_many + \
   &gt;&gt;&gt; new_class._meta.virtual_fields
   &gt;&gt;&gt; field_names = set ([f.name for f in new_fields])
   &gt;&gt;&gt;
   &gt;&gt;&gt; if not base._meta.abstract:
   &gt;&gt;&gt; # Processing "concrete" classes ...
   &gt;&gt;&gt; if base in o2o_map:
   &gt;&gt;&gt; field = o2o_map [base]
   &gt;&gt;&gt; field.primary_key = True
   &gt;&gt;&gt; new_class._meta.setup_pk (field)
   &gt;&gt;&gt; else:
   &gt;&gt;&gt; attr_name = '% s_ptr'% base._meta.module_name
   &gt;&gt;&gt; field = OneToOneField (base, name = attr_name,
   &gt;&gt;&gt; auto_created = True, parent_link = True)
   &gt;&gt;&gt; new_class.add_to_class (attr_name, field)
   &gt;&gt;&gt; new_class._meta.parents [base] = field
   &gt;&gt;&gt;
   &gt;&gt;&gt; else:
   &gt;&gt;&gt; # .. and abstract.
   &gt;&gt;&gt;
   &gt;&gt;&gt; # Check for name collisions between classes
   &gt;&gt;&gt; # declared in this class and in the abstract ancestor
   &gt;&gt;&gt; parent_fields = base._meta.local_fields + base._meta.local_many_to_many
   &gt;&gt;&gt; for field in parent_fields:
   &gt;&gt;&gt; if field.name in field_names:
   &gt;&gt;&gt; raise FieldError ('Local field% r in class% r clashes' \
   &gt;&gt;&gt; 'with field of similar name from' \
   &gt;&gt;&gt; 'abstract base class% r'% \
   &gt;&gt;&gt; (field.name, name, base .__ name__))
   &gt;&gt;&gt; new_class.add_to_class (field.name, copy.deepcopy (field))
   &gt;&gt;&gt;
   &gt;&gt;&gt; # All non-abstract parents are transferred to the heir.
   &gt;&gt;&gt; new_class._meta.parents.update (base._meta.parents)
   &gt;&gt;&gt;
   &gt;&gt;&gt; # Basic Managers inherit from abstract classes
   &gt;&gt;&gt; base_managers = base._meta.abstract_managers
   &gt;&gt;&gt; base_managers.sort ()
   &gt;&gt;&gt; for _, mgr_name, manager in base_managers:
   &gt;&gt;&gt; val = getattr (new_class, mgr_name, None)
   &gt;&gt;&gt; if not val or val is manager:
   &gt;&gt;&gt; new_manager = manager._copy_to_model (new_class)
   &gt;&gt;&gt; new_class.add_to_class (mgr_name, new_manager)
   &gt;&gt;&gt;
   &gt;&gt;&gt; # Virtual fields (like GenericForeignKey) are taken from the parent
   &gt;&gt;&gt; for field in base._meta.virtual_fields:
   &gt;&gt;&gt; if base._meta.abstract and field.name in field_names:
   &gt;&gt;&gt; raise FieldError ('Local field% r in class% r clashes' \
   &gt;&gt;&gt; 'with field of similar name from' \
   &gt;&gt;&gt; 'abstract base class% r'% \
   &gt;&gt;&gt; (field.name, name, base .__ name__))
   &gt;&gt;&gt; new_class.add_to_class (field.name, copy.deepcopy (field))
   &gt;&gt;&gt;
</pre><br>  Abstract classes of models are not registered anywhere: <br><br><pre>   &gt;&gt;&gt; if abstract:
   &gt;&gt;&gt; # Abstract models cannot be instantiated and do not appear
   &gt;&gt;&gt; # in the list of models for the application, therefore, they look a little different than
   &gt;&gt;&gt; # normal models
   &gt;&gt;&gt; attr_meta.abstract = False
   &gt;&gt;&gt; new_class.Meta = attr_meta
   &gt;&gt;&gt; return new_class
</pre><br>  Normal ones are registered and returned from the list of registered ones. <br>  classes of models: <br><br><pre>   &gt;&gt;&gt; new_class._prepare ()
   &gt;&gt;&gt; register_models (new_class._meta.app_label, new_class)
   &gt;&gt;&gt; return get_model (new_class._meta.app_label, name, False)
</pre><br><br><h5>  Conclusion </h5><br>  So let's summarize.  Why did you need metaclasses? <br><br>  1) The model class must have a set of required parameters (table name, name <br>  jango applications, list of fields, links to other models and many others) in <br>  the _meta attribute, which are defined when creating each class that inherits <br>  from Model. <br><br>  2) These parameters are inherited in a complex way from ordinary and abstract <br>  ancestral classes, which is ugly to lay in the class itself. <br><br>  3) It is possible to hide what is happening from the programmer using <br>  framework <br><br><h4>  Zamadanitsa </h4><br>  1) If you do not explicitly specify the class inheritance from object, then the class uses <br>  the metaclass specified in the global variable __metaclass__, which sometimes can <br>  to be comfortable with repeated use of your own metaclass within <br>  single module.  A simple example given at the beginning of a note can be redone. <br>  in the following way: <br><br><pre>   class AttributeInitType (type):
       def __call __ (self, * args, ** kwargs):
       obj = type .__ call __ (self, * args)
       for name in kwargs:
       setattr (obj, name, kwargs [name])
       return obj

   __metaclass__ = AttributeInitType

   class Man:
       pass

   me = Man (height = 180, weigth = 80)
   print me.height

   The standard stream will display:
   180
</pre><br>  2) There is a Python superguru, Tim Peters.  He very well said about <br>  the use of metaclasses and similar tools from the category of black magic of Python: <br><br><pre>     Metaclasses are more than 99% of users should ever worry
     about.  If you
     people who need it
     they do not need an explanation of why).
</pre><br>  In Russian it sounds like this: <br><br><pre>     Metaclasses are too much for most users.  If at all you are wondering
     the question is whether they are needed, they are definitely not needed.  They are used only by people
     who know exactly what they are doing and do not need explanations.
</pre><br>  The moral here is simple: do not be wise.  Metaclasses in most cases - too much.  The pythonist should be guided by the principle of least surprise; <br>  change the classic scheme of the PLO is not just for the sake of narcissism. <br><br><h4>  References based on </h4><br><br>  <a href="http://en.wikipedia.org/wiki/Metaclass">English Wikipedia</a> - a simple example is borrowed from here <br>  <a href="http://www.python.org/dev/peps/pep-3119/">PEP-3119</a> is here <br>  abstract classes are described in their full version. <br>  <a href="http://blog.tplus1.com/index.php/2009/07/27/video-from-my-metaclass-talk/">Roller</a> <a href="http://blog.tplus1.com/index.php/2009/07/27/video-from-my-metaclass-talk/"><br></a>  <a href="http://blog.tplus1.com/index.php/2009/07/27/video-from-my-metaclass-talk/">in English</a> , detailed talk about metaclasses in Python with examples <br>  of use.  There you can find links to the article itself with examples, very <br>  instructive. <br></div><p>Source: <a href="https://habr.com/ru/post/65625/">https://habr.com/ru/post/65625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../65619/index.html">Lack of memory on image processing hosting</a></li>
<li><a href="../65620/index.html">Record Keeping Service</a></li>
<li><a href="../65621/index.html">Down with censorship in advertising slogans</a></li>
<li><a href="../65622/index.html">Microsoft DreamSpark student for Ukrainian undergraduate and graduate students</a></li>
<li><a href="../65623/index.html">Information "for what is plus, and for what - minus"</a></li>
<li><a href="../65626/index.html">A lawsuit was filed for more than $ 50,000 for posting to Twitter</a></li>
<li><a href="../65627/index.html">Unmanned aerial vehicles</a></li>
<li><a href="../65629/index.html">launch java applications as exe files</a></li>
<li><a href="../65630/index.html">Google recursion - did you mean recursion?</a></li>
<li><a href="../65631/index.html">JavaFX Mobile 1.2 Early Access for Windows Mobile Devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>