<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32F405: flash 400kb in 10 seconds or a fast UART bootloader sharpened for USB-UART, less than 4 kilobytes in size</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With utility for PC and board - programmer, 
 using SPL, 
 with full command system and CRC32 verification, 
 with the guarantee of delivery and re-se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32F405: flash 400kb in 10 seconds or a fast UART bootloader sharpened for USB-UART, less than 4 kilobytes in size</h1><div class="post__text post__text-html js-mediator-article"><p>  With utility for PC and board - programmer, <br>  using SPL, <br>  with full command system and CRC32 verification, <br>  with the guarantee of delivery and re-sending of a failed or lost team, <br>  with error checking, debugging messages, and trimmed printf. <br>  Optimized for modern USB-UART converters and streaming. </p><br><img src="https://habrastorage.org/files/7ef/f33/9e0/7eff339e0aad42c7a7d8f10a66930055.png"><br><a name="habracut"></a><br><h1>  Table of contents </h1><br><p>  <a href="https://habr.com/ru/post/305800/">Prehistory</a> <br>  <a href="https://habr.com/ru/post/305800/">Analysis of the reasons for the low speed protocol AN3155</a> <br>  <a href="https://habr.com/ru/post/305800/">Requirements for my bootloader</a> <br>  <a href="https://habr.com/ru/post/305800/">Bootloader protocol description</a> <br>  <a href="https://habr.com/ru/post/305800/">PC Download Utility</a> <br>  <a href="https://habr.com/ru/post/305800/">UART Programmer based on CP2103</a> <br>  <a href="https://habr.com/ru/post/305800/">The implementation of the bootloader firmware</a> <br>  <a href="https://habr.com/ru/post/305800/">Size optimization</a> <br>  <a href="https://habr.com/ru/post/305800/">Outcome and Results</a> </p><br><a name="History"></a><br><h1>  Prehistory </h1><br><p>  We use STM32 in almost all our devices.  <a href="https://habrahabr.ru/post/262531/">For example in our gateways</a> . <br>  In many devices, there is an STM32F405 / 407 and there is a USB &lt;-&gt; UART bridge based on CP2103, but sometimes FTDI. <br>  According to <a href="https://www.google.de/webhp%3Fsourceid%3Dchrome-instant%26ion%3D1%26espv%3D2%26ie%3DUTF-8">AN3155,</a> all STM32 have a built-in UART bootloader and we use it at all stages: from development and production to technical support of our users. <br>  STM also offers PC utilities to use this protocol. <br>  The CP2103 has a regular GPIO, which can be used to reset the device to the main program or to the regular bootloader. <br>  Another good thing is that Windows does not touch these GPIOs when it searches for a Plug &amp; Play device on an RS232, and therefore the device is not reset when connected to a PC and does not ‚Äúfly away‚Äù into an incomprehensible mode for the user. </p><br><p>  It would seem that everything is fine, but this regular bootloader has a tangible problem: it hurts too long: about two minutes, especially when you are debugging the circuitry, and not your code. <br>  In this case, you usually make minimal edits and wait longer when done, have time to distract, and so on. <br>  And it's not a matter of losing more than four hours per day on the firmware of a product, even though sometimes development lasts more than one month. <br>  This problem of long firmware forced to look for the cause of the problem and begin to solve it. </p><br><p>  And the solution presented in this article is the second attempt. <br>  The first attempt was that I wrote my PC utility using AN3155 - "ARMkaProg". <br>  She came an order of magnitude more convenient and smarter than the standard, was able to use the GPIO at the CP2103 and other hardware amenities. <br>  But‚Ä¶ <br>  The standard utility and AN3155 did not recommend sewing at a speed above 115200 baud, <br>  My own program could sew even 1000k baud, but it gave an increase to the speed of just 2 times (compared to 115200). <br>  And not at 9, and as a result, the question of the speed of the firmware remained unresolved. </p><br><a name="Analiz"></a><br><h1>  Analysis of the reasons for the low speed protocol AN3155 </h1><br><p>  The low speed of the firmware stems from the specifics and simplicity of this protocol: </p><br><ol><li>  The recommended maximum speed is 115200, but many USB bridges support at least megabytes, but at speeds above 115200 the protocol is activated from the tenth to the hundredth attempt, and each attempt is at least 300 to 500ms. </li><li>  It is necessary to erase the entire flash, even if the firmware size is 10k from the available 1024k bytes - in some crystals there were bugs with partial erasure. </li><li>  The regular bootloader is universal and, therefore, terribly slow, it does not use external quartz and does not use PLL and high frequency, and also noted that the flash is erased more slowly at a low clock speed - this is done for battery use. </li><li>  Small team size.  A maximum of 1 time you can flash 256 bytes, and on some versions of chips no more than 128. </li><li>  A lot of extra gestures: you need to activate the bootloader, get lists of commands, for production you need to know the unique ChipID, it is not always possible to read it with one command and it is not always possible even from the bootloader. </li><li>  For security reasons, we always have any firmware locked, even temporary or debug.  Although the unlock in fact is erasing, but you must do the full-time erasing procedure, because  Nowhere does it say that the unlock is guaranteed to erase, but does not clog, for example, with garbage / zeros and so on.  Therefore, it turns out that it is necessary to wash twice, and this is almost a minute! </li><li>  It is necessary to verify the firmware, i.e.  Drive the firmware there twice: the first time to write, and the second time - read and check. </li><li>  The controller has a lot of RAM: 192k, but the bootloader does not use this, it is the same for all chips, including those that have very little RAM. </li><li>  Each team has three confirmations (ASC): the command code, the address and the data.  But USB works at 1ms intervals, as a result, 3ms is spent for each command even if you need to read or write 1 byte, and we can send no more than 333 commands of the already scanty data blocks. </li></ol><br><p>  Let's take a closer look at the record command from the datasheet on AN3155: </p><br><img src="https://habrastorage.org/files/e09/21b/80d/e0921b80d43943b2bf5f8657e54153ac.png"><br><p>  where red marks: (1) - confirmation of the command code, (2) - confirmation of the address, (3) - data block </p><br><p>  We look at the recording command with the oscilloscope (1000k baud rate) </p><br><img src="https://habrastorage.org/files/e51/7f5/63e/e517f563e28f4b51802cefa5c652bb00.png"><br><p><br>  and actually see these states of the ASC: (1), (2) and (3), and their noticeable delay from paragraph 9, <br>  We also see that the recording time is huge and more time is spent on firmware than on data transfer (see item 3). </p><br><p>  And if you look at a dozen write commands </p><br><img src="https://habrastorage.org/files/35e/15e/454/35e15e4546db4a00ab9a8d2edaaa3e0b.PNG"><br><p><br>  it can be seen that there are a lot of pauses and they take 2/3 of the time. </p><br><p>  Hmm, what if you don‚Äôt wait for each command with three ACKs and just send the data as a stream? <br>  But nothing good comes of it.  The loader is so simple that it loses data if it is not waiting for it, there is no reception via DMA or interruption in it, and there is no ROM memory either so that everything is perfect for every interface. </p><br><p>  From all these reasons logically follows: </p><br><a name="TZ"></a><br><h1>  Requirements for my bootloader </h1><br><ol><li>  Fixed UART speed at 921600 BOD: without a speed autodetection stage, which often fails. </li><li>  Partial deletion of selected pages. </li><li>  Work at the maximum clock frequency: use PLL and flash flash faster than new data arrives. </li><li>  Support commands with large data blocks, at least 2k bytes. </li><li>  There should not be any stages of activation type, you should immediately issue with one command everything you need: including ChipID and all options and versions. </li><li>  Ability to work in a locked chip, without unlocking it. </li><li>  Integrity check without reading to the host: for example, by sending and checking the CRC of the entire firmware. </li><li>  Using the entire RAM: while erasing is in progress, it is already possible to transfer at least as much as 100 kilobytes of firmware content. </li><li>  Do not require waiting for confirmation for each command.  The incoming stream from the host should not depend on or wait for the output from the loader.  The host can issue commands at maximum speed.  And the loader should only report that the last successfully addressed address is such - that.  And, in the event of a failure, the host could continue from this address.  For example, TCP works in a similar way. </li></ol><br><p>  These items eliminate the corresponding causes of low speed. </p><br><p>  But in practice we need more stuff: </p><br><ul><li>  <strong>The starting point of the firmware and the entry point should be different: the</strong> first pages are convenient for organizing a pseudo-EEPROM and therefore usually the firmware code and its interrupt vector are not put there.  And they start at offset 0x08010000 or further, i.e.  in those pages that are long and erased. </li><li>  <strong>We need a state monitor and error text messages:</strong> I don‚Äôt like when there are no debug and status messages, since  It's hard to debug the black box. </li><li> <strong>The loader should be as small as possible</strong> : our devices are different and with different peripherals, but with a common board and common firmware, including all the loaders, the client code and the self-diagnostic code ‚Äî all in one.  As well as my loaders in one image, too many, my version of AN3155 with encryption, GPRS, full-fledged FSK-modem, and all of them must be able to fit into one or two first pages of 16-32k bytes.  In the end, every byte counts. </li><li>  <strong>The loader must be reliable</strong> , in AN3155 command protection from failures and debris is weak - just the XOR of all bytes.  There were several cases when she was faltering. </li></ul><br><a name="Protocol"></a><br><h1>  Bootloader protocol description </h1><br><p>  I decided to make a more detailed description of my protocol in case anyone wants to port the PC boot program to other operating systems than Windows. </p><br><div class="spoiler">  <b class="spoiler_title">Expand Protocol Description</b> <div class="spoiler_text"><h2>  General principle </h2><br><ul><li>  Two participants: Host and Device. </li><li>  The host is flashing the device. </li><li>  Host host and initiate the exchange. </li><li>  The device is slave. </li><li>  The exchange is made by teams. </li><li>  Commands are packaged. </li><li>  Packet Byte Order: Little endian </li><li>  One package - one team. </li><li>  One team - one action or event. </li><li>  The device responds to Host commands with the same command code as the host. </li><li>  The device generates, without a request, only emergency reboot and timeout commands. </li><li>  Each packet begins with a 32-bit signature beginning of the packet. </li><li>  Signatures are different for directions to and from the Device. </li><li>  The rest of the format is the same for both directions. </li><li>  Each package is protected by a CRC32 at the end of the package. </li><li>  The packet size in bytes must be a multiple of four. </li><li>  Timeout for a general reset of the Device to 500ms, the Host is obliged to ensure that there will be no pause more than 500ms. </li><li>  In addition to the commands, debugging text messages in bare ASCII can be issued from the Device, they should not start or contain the signature of the beginning of the package and should be displayed outside the package body. </li></ul><br><h2>  Package structure: </h2><br><table><thead><tr><th>  address </th><th>  the size </th><th>  content </th></tr></thead><tbody><tr><td>  0 </td><td>  four </td><td>  The signature of the start of the command, for transfer to the device 0x817EA345, for receiving from the device 0x45A37E81 </td></tr><tr><td>  four </td><td>  one </td><td>  command code, sets the type of action or event </td></tr><tr><td>  five </td><td>  one </td><td>  bitwise inverse command code (for verification) </td></tr><tr><td>  6 </td><td>  2 </td><td>  N - size of additional information in bytes ( <strong>must be a multiple of 4</strong> ) </td></tr><tr><td>  eight </td><td>  N </td><td>  additional information - depends on the command code </td></tr><tr><td>  8 + N </td><td>  four </td><td>  embedded hardware in the STM32 CRC32 packet from address 4 to N (excluding the signature) </td></tr></tbody></table><br><p>  The signature of the beginning of the team for different directions is chosen different in order not to mistakenly perceive their own data, which came to him at the reception.  For example, when there is a short circuit on the legs of the RX and TX controller or a programmer / cable failure. </p><br><h2>  Error handling at the level of packets and timeouts </h2><br><ul><li>  If the command code does not match the verification inverse code, then the beginning of the packet is not counted, and the search for a new command begins with the next byte. </li><li>  If a packet with the size of the additional information is larger than the internal buffer, then the packet is ignored, and the search for a new command begins with the following bytes after the size. </li><li>  If the CRC32 received in the package body is not equal to the actual calculated one, then the contents of the package are ignored and the search for a new command begins with the next byte after CRC32. </li><li>  If bytes arrive, but the signature of the start of the packet is not detected.  Then these bytes should be considered debug text messages and accumulated to code 13 (line feed), and after this code should be output to the debug console. </li><li>  If more than 500 ms has passed since the last packet was received, the bootloader is reset to its original state.  A packet that did not have time to be taken to the end is ignored and is also discarded.  About timeout The device reports a packet with a special command code "timeout". </li><li>  When you start the bootloader, another package is generated with a special "reboot" code. </li></ul><br><h2>  The operation of the device </h2><br><ol><li>  We answer the command information, and when resetting or timeout we notify the host about it. </li><li>  The firmware is recorded sequentially from the beginning of the free range to the end of the firmware or free space. </li><li>  The device contains the address of the current block to be recorded. </li><li>  By default, the address of the current block is set to 0, which means that the erase was not performed and the record is invalid. </li><li>  Erase command: erase how many requested are rounded to fit the page and reporting on each erased page. </li><li>  At the end of erasing, the address of the current block is set to the beginning of the free range - you can start recording. </li><li>  Write command: if the address of the received block is equal to the address of the current block, then we write it down and update the current address. </li><li>  Write command: if the address of the received block is NOT equal to the address of the current block, then ignore the record. </li><li>  In both cases, 6 and 7 are reported to the host address of the current block for recording. </li><li>  At the end of the recording, the Host must issue the "Start" command with the CRC32 of the entire firmware, and if it is correct, the firmware will start. </li><li>  If no commands were received within 5 seconds, then run the main firmware if it is there. </li><li>  If the timeout is 500ms or a hardware reset, the address of the current block for recording is reset to 0. </li></ol><br><h2>  Hosting order </h2><br><ol><li>  We receive information from the device: flash size, ChipID, receive buffer size, start address, bootloader version and chip. </li><li>  We give the command to erase either the entire firmware, or part by specifying the size of the erased area. </li><li>  Upon completion of the erasing, we begin to continuously send writing commands in blocks one after another, checking that the current recorded position in the device is increasing. </li><li>  If the position has ceased to increase (accepted two responses to the "write" command with the same address), then correct the address on the Host, reset the send buffers and start transmitting from the new adjusted address. </li><li>  Upon completion of the recording, issue the "Start" command by transmitting the entire firmware CRC32, in response, the Device will report the actual CRC32. </li><li>  If the actual CRC32 is equal to the calculated one, then the download is successfully completed and the firmware is launched. </li></ol><br><h2>  Command Description </h2><br><p>  In the description of the teams I will sign only the additional parameters of the command that follow the code and size of the parameters. <br>  The command code is given in parentheses, then the constant in the source code and the name in Russian </p><br><div class="spoiler">  <b class="spoiler_title">(0x97) SFU_CMD_INFO Command: Request Information</b> <div class="spoiler_text"><p>  <strong>Additional parameters of the command from the Host:</strong> <br>  are missing. </p><br><p>  <strong>Device response:</strong> </p><br><table><thead><tr><th>  size in bytes </th><th>  Description </th></tr></thead><tbody><tr><td>  12 </td><td>  Unique ChipID </td></tr><tr><td>  four </td><td>  Model and chip revision, taken from DBGMCU-&gt; IDCODE </td></tr><tr><td>  2 </td><td>  Size of writeable flash loader in KiB (* 1024 bytes) </td></tr><tr><td>  2 </td><td>  Bootloader version 0x0100 </td></tr><tr><td>  four </td><td>  The size of the device receive buffer (for the -PreWrite option) </td></tr><tr><td>  four </td><td>  Recordable start address </td></tr><tr><td>  four </td><td>  Address of the interrupt vector table and the place from which the launch context is taken (stack + entry point) </td></tr></tbody></table><br><p>  example from logs: </p><br><img src="https://habrastorage.org/files/17e/6e5/496/17e6e549614b4057947db04563be14a7.jpg"></div></div><br><div class="spoiler">  <b class="spoiler_title">(0xC5) SFU_CMD_ERASE Command: Erasing Flash Memory</b> <div class="spoiler_text"><p>  <strong>Additional parameters of the command from the Host:</strong> <br>  4 bytes - size of erasable area in bytes </p><br><p>  <strong>Device response:</strong> issued at the end of erasing all pages, <br>  4 bytes: If successful, then the size of the erased area is equal to what the Host transmitted.  If a failure occurs, then 0. </p><br><p>  During erasing device: </p><br><ol><li>  Erases pages starting from # 1 and up to the required one, according to the size, rounded up. </li><li>  After erasing each page, it responds with the SFU_CMD_ERASE_PART command (‚Äúpage erased‚Äù). </li><li>  It accumulates incoming commands in the receive buffer, but does not respond to them and processes it only after completion of the erase. </li><li>  The erase time of the first three pages is about 300 ms, followed by about 2 seconds. </li></ol><br><p>  example from logs: </p><br><img src="https://habrastorage.org/files/490/b4f/839/490b4f8393bd4a4d9fd09c919e141ead.jpg"></div></div><br><div class="spoiler">  <b class="spoiler_title">(0xB3) SFU_CMD_ERASE_PART Message: page erased (for -PreWrite option)</b> <div class="spoiler_text"><p>  The host should not issue a command with this code ‚Äî it will be ignored. <br>  During erasure, the host can transmit data in advance for writing with the SFU_CMD_WRITE (‚Äúwrite‚Äù) commands - to speed up writing. <br>  But you can send commands no more than the size of the device receiving buffer, otherwise it will overflow and the first packets will be replaced with new ones, and the next ones will be ignored. </p><br><p>  <strong>Command parameters from Device:</strong> <br>  4 bytes: erased page number from # 1 to # 11. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">(0x38) SFU_CMD_WRITE Command: Write</b> <div class="spoiler_text"><p>  <strong>Additional parameters of the command from the Host:</strong> <br>  4 bytes - the address from which to write the contents. <br>  X * 4 bytes is the contents of the firmware, where X is the number of 32 bit words and should be: 1 ... 1023. </p><br><p>  The entry is ignored if the address specified by the Host is not equal to the current address of the entry in the device. <br>  The device responds always regardless of whether the recording was made or ignored. </p><br><p>  <strong>Device response:</strong> <br>  4 bytes: the address of the next block to be written is incremented if the record is successful, does not change if the command is ignored <br>  4 bytes: the amount of raw data in the device's receive buffer (for debugging and monitoring). </p><br><p>  An example of responses from several successful "Record" commands from logs: </p><br><img src="https://habrastorage.org/files/54c/811/a19/54c811a192b549d497bfa5bd4307f951.jpg"></div></div><br><div class="spoiler">  <b class="spoiler_title">(0x26) SFU_CMD_START Team: Start</b> <div class="spoiler_text"><p>  <strong>Additional parameters of the command from the Host:</strong> <br>  4 bytes: CRC32 of all recorded firmware, the beginning of the firmware is indicated in the "Information" command, the end - the last recorded device confirmed by the command with the "write" command is the address of the next block to be written (not inclusive). </p><br><p>  <strong>Device response:</strong> <br>  4 bytes: The start address of the firmware. <br>  4 bytes: The number of bytes written (Attention, not 32-bit words!) Is a multiple of four. <br>  4 bytes: CRC32 for verification by the Host, calculated from the "Address of the beginning of the firmware," the size of the "Number of recorded bytes." </p><br><p>  After this command, the Device checks the CRC32 and if it matches the one given by the Host, it launches the firmware by performing a full deinitialization of the equipment. </p><br><p>  An example of the logs: </p><br><img src="https://habrastorage.org/files/068/bee/ec1/068beeec14ba4039b67cc0ce773b45c3.jpg"></div></div><br><div class="spoiler">  <b class="spoiler_title">(0xAA) SFU_CMD_TIMEOUT Message: 500ms timeout</b> <div class="spoiler_text"><p>  More than 500 ms has passed since the last command was received and the timeout has expired, the device has been reset to its original state. </p><br><p>  Without parameters. <br>  The host should not respond to it. <br>  This alarm message is a command that only the device issues. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">(0x55) SFU_CMD_WRERROR Message: Error writing flash memory</b> <div class="spoiler_text"><p>  Writing to flash memory failed.  This happens if the power supply is insufficient or fake Chinese chips like GD32F4xx. </p><br><p>  Without parameters. <br>  The host should not respond to it. <br>  This alarm message is a command that only the device issues. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">(0x11) SFU_CMD_HWRESET Message: Hardware Loader Reset</b> <div class="spoiler_text"><p>  Hardware reset device.  The device HARDWARE reset to its original state - the bootloader restarted. </p><br><p>  Without parameters. <br>  The host should not respond to it. <br>  This alarm message is a command that only the device issues. </p></div></div></div></div><br><a name="PCutil"></a><br><h1>  PC Download Utility </h1><br><p>  Appearance: </p><br><img src="https://habrastorage.org/files/68a/1ed/ad7/68a1edad73804384aee96d62ca531ce1.png"><br><p><br>  Written for Windows on Delphi 6 (2001, the one that has 8 bit char type and not unicode).  Compiled on Delphi XE5 and tested performance.  Such an old Delphi was chosen because it was easier for me: since the beginning of the 2000s, there have been great developments in working with CP210x, COM ports, and so on. </p><br><p>  Work with the device at the byte level is allocated to a separate tCOMclient stream, independent of the delays of the visual interface.  The connection to this separate stream is made using the read and write queues of 65,536 bytes. <br>  The level of parsing with the design of commands and the logic level of working with commands is divided into two separate classes, tSFUcmd and tSFUboot. <br>  The firmware is updated at a speed of 921600 baud, no parity, 8 bits, one stop bit. </p><br><p>  Devices can be specified: <br>  By the name of the COM port, for example COM123. <br>  By serial number recorded in CP210x <br>  On the system path WinNT, for example \ ?? \ USB # VID_10C4 &amp; PID_EA60 # GM18_E_0010 # {a5dcbf10-6530-11d2-901f-00c04fb951ed} </p><br><p>  In any case, if the open device is CP2103, then the utility can try to reset it via GPIO1 (18 pin), setting it to 0-1-0. <br>  The kerchief programmer with its scheme is also attached and described below. </p><br><p>  If running without command line parameters, it restores at startup and saves upon completion of the configuration from a text file: FastTest.exe.config <br>  If command line parameters are present, the settings from this file are ignored and it is not changed.  Instead, the settings in the visual components are taken from the command line and the firmware is started if indicated. </p><br><p>  You can use the following command line parameters: </p><br><ul><li>  Firmware specified without perfixes </li><li>  <strong>-DEV: &lt;device_name&gt;</strong> The device name or COM port is specified in &lt;device_name&gt; </li><li>  <strong>-reset</strong> or <strong>-RST</strong> reset the device if the COM port goes through CP2103. </li><li>  <strong>-fast</strong> fast erase, erase only those pages in which the firmware will be placed </li><li>  <strong>-exit</strong> Close the program upon completion if the firmware was successful or the -no-Errors-Keep option is specified </li><li>  <strong>-no-Errors-Keep</strong> close program on completion anyway </li><li>  <strong>-no-Prewrite</strong> Do not send data to write while erasing </li><li>  <strong>-go</strong> or <strong>-run</strong> or <strong>-start</strong> Start the firmware immediately after launching the application, otherwise the settings are applied, but the launch is not performed. </li></ul><br><p>  You can download from here: <br>  <a href="https://github.com/Mirn/Boot_F4_fast_uart/tree/master/delphi/Release">https://github.com/Mirn/Boot_F4_fast_uart/tree/master/delphi/Release</a> </p><br><a name="MiniProg"></a><br><h1>  UART Programmer based on CP2103 </h1><br><p>  I post our small and simple programmer which: </p><br><ul><li>  Uses for firmware at CP2103 UART and GPIO, only five wires: GND, TX, RX, BOOT, RST. </li><li>  They can sew all kinds of STM32 UART, and use my bootloader from this article. </li><li>  It has protection against hot plugging, and for all the time it has been used it has never burned (for now, I hope ...). </li><li>  Contacts are signed with silk-screen printing, which is very convenient (do not forget to order silk-screen printing in the top layer) </li><li>  Small, slightly larger than the USB connector. </li><li>  Included is the ConfigProg \ CP2102_Enum.exe utility for configuring GPIO in CP2103: select a device and click "USB write". </li><li>  <strong>ATTENTION: it is not electrically isolated.</strong> </li></ul><br><p>  Settings should be as follows: </p><br><pre><code class="hljs pgsql">IO.Mode = <span class="hljs-number"><span class="hljs-number">1100001101010100</span></span> IO.<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> = <span class="hljs-number"><span class="hljs-number">0000110011111111</span></span> IO.Suspend = <span class="hljs-number"><span class="hljs-number">0000111111111111</span></span> IO.EnhFxn = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  The FastTest utility from the previous chapter was developed and debugged on this programmer. </p><br><div class="spoiler">  <b class="spoiler_title">Scheme</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/dbd/b5b/acd/dbdb5bacda1a4cc0b1f1e4a642bf3ea9.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Pay</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c9f/ea3/b6b/c9fea3b6bde14201aa9a12ec8f99ae8c.png"></div></div><br><p>  Source files on the programmer download from here: <br>  <a href="https://github.com/Mirn/ProgCP2103">https://github.com/Mirn/ProgCP2103</a> </p><br><a name="SRC"></a><br><h1>  The implementation of the bootloader firmware </h1><br><p>  Development Tools and Third-Party Libraries: </p><br><ul><li>  Wednesday: Eclipse Kepler Service Release 1 </li><li>  Compiler: GCC v5.4 2016q2, with settings: <br><pre> <code class="hljs matlab">-mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -Os -fmessage-<span class="hljs-built_in"><span class="hljs-built_in">length</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span> -ffunction-sections -fdata-sections -ffreestanding -fno-builtin -Wunused -Wuninitialized -Wall -Wextra -Wpointer-arith -Wshadow -Wlogical-op -Waggregate-<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Wfloat-equal -Wno-<span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>-compare</code> </pre> </li><li>  Link and link using the ld file of the script with sections. </li><li>  A project is built using the Makefile utility; you can build it without an environment using the command make all </li><li>  The startup and initialization code is taken from CooIDE version 1.6, because it is minimal and known to me. </li><li>  STM peripheral library: standard peripheral library (SPL V1.3.0) </li></ul><br><p>  Memory Usage Profile: </p><br><ul><li>  I placed the stack in a separate 65k CCM memory. </li><li>  The main ring buffer of reception from UART is 100 kilobytes located in a separate section at the beginning of the RAM </li><li>  All other buffers and variables located in .bss in the remaining 28k RAM. </li></ul><br><h3>  Usart_mini.c library </h3><br><p>  It is made as simple as possible: DMA is not used, the transmission is made by direct sending to the periphery without interruption using SPL functions.  But since the main purpose of speeding up the protocol is a continuous stream of commands with content for the firmware, the reception of data from the UART is done by interrupting the USART1_IRQHandler. </p><br><p>  Also in the UART, I implemented the control and accounting of errors and checking and correction of the buffer in case of data overflow, if they are written more than its size. </p><br><p>  When implementing UART reception in interrupts, a problem arose: <br>  By default, the code is in flash and during flash memory flashing, the flash bus is blocked and execution stops completely including interrupts.  And at speeds above 500k BOD, this leads to a loss of data received from the UART, since  pause time becomes longer byte reception time.  Therefore, the interrupt handling function was moved to RAM like this: </p><br><pre> <code class="hljs lisp">__attribute__ ((<span class="hljs-name"><span class="hljs-name">long_call</span></span>, section(<span class="hljs-string"><span class="hljs-string">".data"</span></span>))) void USART1_IRQHandler(<span class="hljs-name"><span class="hljs-name">void</span></span>)</code> </pre> <br><p>  at the same time there is an important subtlety that if a function lying in RAM causes other functions in the flash, we get an error of the form: </p><br><pre> <code class="hljs vhdl">usart_mini.c: relocation truncated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> fit: R_ARM_THM_CALL against symbol `demo' defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> .<span class="hljs-literal"><span class="hljs-literal">text</span></span>.demo section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./src/main.o</code> </pre> <br><p>  This is caused by the restriction of the ARM architecture of Thumb2 instructions to the maximum address distance between calls.  And in this case it is more than acceptable.  I fixed this by adding the <strong>long_call</strong> attribute modifier to all functions called from RAM. </p><br><h3>  Library packet_receiver.c </h3><br><p>  Accepts packets according to the protocol described in this article and checks their integrity.  At the same time, at all stages of parsing the package checks for errors and counts their number if they meet.  But errors are not silenced, but text messages are output and a line with all errors, both UART and packet level and 500 ms time-out, is output once per second.  This 500 ms timeout is controlled and generated by the same library. </p><br><h3>  Sfu_commands.s library </h3><br><p>  Handles command logic SFU_CMD_XXX as described above.  It erases and flushes the flash, while the function of the firmware of the word in the flash memory is also rendered in RAM, so that data on reception from the UART is not lost.  It also implements the launch of the main firmware, while checking that its context indicates the real flash memory and RAM memory.  Before launching the main firmware, all peripherals and clocks are fully deinitialized and reset. </p><br><p>  The performance of the firmware is tested on models: STM32F405RG, STM32F405VG, <br>  and at speeds from 115200 to 921600 baud. </p><br><p>  All firmware sources are available on my github under the link: <br>  <a href="https://github.com/Mirn/Boot_F4_fast_uart">https://github.com/Mirn/Boot_F4_fast_uart</a> </p><br><p>  Option for STM32F7xx: <br>  <a href="https://github.com/Mirn/Boot_F745_SFU">https://github.com/Mirn/Boot_F745_SFU</a> </p><br><a name="Optimize"></a><br><h1>  Size optimization </h1><br><p>  First and foremost, the size that affects the size is the overall architecture of the algorithm and the data used.  I tried to do everything as simple as possible and, even in some places, primitive.  At the same time I tried to shift the most difficult things in logic to Khost.  In short, order and brevity in code begins with order in the head of the developer. </p><br><p>  But you need to comply with the measure and do not forget about the amenities that help you better understand what is happening in the bootloader, and therefore there are debug messages, control and error counting and other trifles and amenities.  And also I did not sculpt everything into one function and put everything on the shelves, and broke it into modules.  Although this leads to an increase in the size of the firmware by a couple of hundred bytes, for many years I will have to maintain, develop and create new ones based on it.  Another small contribution to the increase in size made it necessary to place some of the functions in RAM. </p><br><p>  Also, do not forget how the compiler and its optimizer work.  I compiled naturally on -Os, but did not use any other special keys and did not even bother with it.  If you give more specifics, then the compiler will be able to better optimize: parameters to sign const where it is possible, local functions within one file as static, etc. </p><br><p>  It is also not worth shamanizing with trifles such as rearranging strings, licking ifahs with boolean optimization of the conditions in them - all compilers have been able to do this for a long time.  Trust them.  In which case, you can look at the map file, where it says which function, how long it takes, or just count the number of lines in the listing.  Without even knowing the ASMA, it will immediately show which function suddenly turned monstrously. </p><br><h3>  SPL optimization </h3><br><p>  The STM standard peripheral library has a very large downsizing potential.  It is written very simply - many functions transfer data from the completed structures transferred to them to the corresponding peripheral registers.  These functions do not contain internal static variables, do not access global variables, and usually do not require pointers to any state stores.  They very rarely refer to their other or other people's functions.  But they have a flaw: they contain a lot of duplicate code, for example GPIO_DeInit checks the equality of the transmitted GPIO to each port of the GPIOA, GPIOB ... GPIOI, and resets each port separately with a separate code.  Those.  there really is a bundle of ten if and twenty RCC_AHB1PeriphResetCmd.  And so the SPL consumes a lot of flash.  A bunch of UART and GPIO with RCC usually accounts for about 8 kilobytes. <br>  Therefore, I copied the code of the used SPL functions into a separate header, declared them as static inline and added a _inline suffix to each such function, for example GPIO_DeInit_inline.  Also zainlaynil all functions caused by them.  This immediately reduced the code at times. </p><br><h3>  Optimization of the .data and .ro_data sections </h3><br><p>  The <strong>.data</strong> section stores the starting values ‚Äã‚Äãof variables that are specified at the compilation stage.  They are placed in a flash, and there is a loop in the code that copies them when launched into RAM. <br>  I wrote the code so that there were no such variables at all, and I would not have to write code that manually sets the necessary parameters to them. </p><br><p>  The <strong>.ro_data</strong> section stores all constants, including text constants.  Here you just need to know the measure, and do not display poems in the terminal, limiting yourself to a minimally informative log of one or two words.  And also GCC has such a bug when the function is not used, but its constant variables in .ro_data and firmware still get.  Such cases, I also commented out or deleted. </p><br><h3>  Optimize printf and its shadows impure_data and impure_ptr </h3><br><p>  I took from CoIDE a ready implementation of the trimmed printf, much is simplified in it, and there is no support for a floating point at all.  But it implicitly uses the impure_data structure and the impure_ptr pointer.  They occupy hundreds of bytes and pull a lot more.  The gcc compiler, hidden from the programmer, places stderr and stdin in this structure, and they should not be used in the code. </p><br><p>  Initially, the printf example just contained stderr and stdout, I removed them to mention them, replacing them with more direct calls and commented out unnecessary printf options.  And removed unused options for output such as strings, signed integers, hexadecimal, and so on. </p><br><h3>  Optimization of the startup code and the removal of the re-code </h3><br><p>  From CoIDE, I took the most minimal that I found, the startup and initialization code.  It copies the .data from the flash to RAM, starts the quart and adjusts the frequencies, resets the .bss and sets up the processor: stack, floating point, CCM memory and so on. </p><br><p>  But some of these tasks have already been implemented in SPL and used by me.  I replaced them with a direct call to the corresponding non-inline SPL function. </p><br><p>  There were also many repetitions of the code, when, for example, floating commas are included in as many as three places. <br>  He nailed SystemCoreClock to the define and threw out the SystemCoreClockUpdate function. <br>  The startup code used constant tables for calculations that were stored in RAM as volatile (I wonder why?).  Transferred to the flash, and when optimizing, the compiler replaced some of them with a direct calculation (where there were powers of two, thirty-two words). </p><br><h3>  Reducing the interrupt table </h3><br><p>  The interrupt table contains in the first two 32-bit cells the execution context: the code address and the stack address.  And in the subsequent contains pointers to all possible interrupts.  And this is almost 500 bytes.  Since ‚ÄúOstap suffered‚Äù and I could no longer accept that the code is more than 4k (hi 4k demo scene!).  So I got rid of the table by sticking it down to the first two cells.  And in the startup code, I transferred the vector to the table in RAM, where I added only one UART processor with the following code handles: </p><br><pre> <code class="hljs cpp">__attribute__ ((section(<span class="hljs-string"><span class="hljs-string">".isr_vector_minimal"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StartVectors_minimal[])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;_estack, Reset_Handler, }; __attribute__ ((section(<span class="hljs-string"><span class="hljs-string">".isr_vector_RAM"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (* StartVectors_RAM_actual[<span class="hljs-number"><span class="hljs-number">128</span></span>])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Default_Reset_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... StartVectors_RAM_actual[<span class="hljs-number"><span class="hljs-number">0xD4</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>] = USART1_IRQHandler; SCB-&gt;VTOR = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)StartVectors_RAM_actual; main(); }</code> </pre> <br><p>  and corrected the ld file by writing it so that the section for the interrupt table in RAM is aligned as expected for 512 bytes </p><br><pre> <code class="hljs markdown"> .text : { KEEP(<span class="hljs-emphasis"><span class="hljs-emphasis">*(.isr_vector_minimal*</span></span>)) <span class="hljs-emphasis"><span class="hljs-emphasis">*(.text .text.*</span></span> .gnu.linkonce.t.<span class="hljs-emphasis"><span class="hljs-emphasis">*) *</span></span>(.rodata .rodata<span class="hljs-bullet"><span class="hljs-bullet">* .gnu.linkonce.r.*</span></span>) } &gt; rom .bss (NOLOAD) : { <span class="hljs-emphasis"><span class="hljs-emphasis">_sbss = . ; . = ALIGN(512); *(.isr_</span></span>vector<span class="hljs-emphasis"><span class="hljs-emphasis">_RAM*) *(.bss .bss.*) *(COMMON) . = ALIGN(4); _</span></span>ebss = . ; } &gt; ram</code> </pre><br><p>  Saving on the vector table was almost 400 bytes. </p><br><a name="Results"></a><br><h1>  Outcome and Results </h1><br><p>  The time of the firmware is 400 kilobytes. </p><br><p>  built-in bootloader on AN3155 with a speed of 256,000 AML: 95 seconds <br>  built-in bootloader on AN3155 with a speed of 500,000 BOD: 78 seconds <br>  built-in loader for AN3155 with a speed of 921600 BOD: 70 seconds <br>  in all cases with unlock and zalochkoy, with full erasing </p><br><p>  my bootloader with a speed of 921600 BOD: 9 seconds, <br>  which is 8 times faster. </p><br><p>  The video of the new bootloader (at the beginning), and the old one by AN3155, starts after the new one. </p><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/jDE-EykRkL8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhg7SVxL0ncteM56o3O0hwQS81LwCw" frameborder="0" allowfullscreen=""></iframe><br><p><br><br>  We check the oscilloscope for continuity of data flow and the absence of pauses on the UART </p><br><img src="https://habrastorage.org/files/efc/acc/1a4/efcacc1a428a488db68b4cdef89f6dc3.PNG"><br><p><br>  or more deployed one package: </p><br><img src="https://habrastorage.org/files/164/144/fa4/164144fa46cb4b8f801ca3f690106d99.png"><br><p><br>  There is no pause, the flow is continuous, the acceleration is 8 times received. <br>  It turned out all that was planned and aspired to. </p><br><p>  Once again the link to githab: <br>  <a href="https://github.com/Mirn/Boot_F4_fast_uart">https://github.com/Mirn/Boot_F4_fast_uart</a> </p><br><p>  This is my first project on a githaba and has been published for the purpose of studying it and entering the community. <br>  I decided to do not "hello world", but something really useful.  Github is for the community and it is silly to start with a project that is useless to everyone.  I remembered how my hands itched, but because of laziness they did not reach for many years.  And suddenly there was a reason: because of the crisis, I will soon have just a lot of free time, but something must be done now.  As a result, this turbo boot was born. </p><br><p>  Added by: <br>  The SFU version for STM32F7xx is made: <br>  <a href="https://github.com/Mirn/Boot_F745_SFU">https://github.com/Mirn/Boot_F745_SFU</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305800/">https://habr.com/ru/post/305800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305790/index.html">Google page speed insights 100 out of 100 on the platform for online store</a></li>
<li><a href="../305792/index.html">The digest of interesting materials for the mobile # 162 developer (July 11-17)</a></li>
<li><a href="../305794/index.html">Introduction to the concept of entropy and its many faces</a></li>
<li><a href="../305796/index.html">Learning OpenGL ES2 for Android Lesson ‚Ññ2. Creating triangles</a></li>
<li><a href="../305798/index.html">MVP on steroids: make the robot write the code for you</a></li>
<li><a href="../305802/index.html">Create a multilanguage blog using OctoberCMS</a></li>
<li><a href="../305808/index.html">PHP Digest number 88 - interesting news, materials and tools (June 13 - July 17, 2016)</a></li>
<li><a href="../305812/index.html">Honest MVC at React + Redux</a></li>
<li><a href="../305816/index.html">ITMO University Digest: Residents of our Accelerators</a></li>
<li><a href="../305818/index.html">Launch Angular2 with Visual Studio 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>