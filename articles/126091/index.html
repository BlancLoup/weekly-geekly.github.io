<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a binary tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I started learning ruby, I decided to implement a binary tree and some of its basic operations (insert, delete, walk, and search), in order to be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a binary tree</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/2bff0ecc/32730642/a02441ca/02a849b0.png" align="right">  When I started learning ruby, I decided to implement a binary tree and some of its basic operations (insert, delete, walk, and search), in order to better understand the language.  Binary trees, this is a good exercise to understand the features of the language, such as: conditional operators, cycles, classes.  At the same time, it is an opportunity to solve an interesting problem.  The binary tree algorithm is well described in many books and on the Internet. <br>  To complicate the task, I also implemented the binary tree drawing with html5 and Canvas.  This allows you to more clearly understand the work of a binary tree.  You can watch a demonstration on the <a href="http://binarytree.heroku.com/">web site</a> . <br>  Next, I briefly describe the implementation of the basic methods of building a binary tree. <br><a name="habracut"></a><br><h3>  Binary tree or binary search tree </h3><br>  The code itself, presented below, implements the Binary Search Tree (BST), which is a more specific version of binary trees.  In a binary tree, each node has no more than 2 children, one of them is called the ‚Äúleft subtree‚Äù and the other is the ‚Äúright subtree‚Äù, there is no sorting.  In a binary search tree, all nodes are stored in the order reflected in the following rule: <br><blockquote>  Suppose x is a node in a binary search tree, if y is a ‚Äúleft subtree‚Äù for x, then y.key ‚â§ x.key.  If y is a ‚Äúright subtree‚Äù for x, then y.key ‚â• x.key. </blockquote><br><br><h3>  Implementing a binary search tree </h3><br>  The class for working with the tree that I implemented can be used as follows: <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">"binarytree"</span></span> tree = BinaryTree.new(<span class="hljs-number"><span class="hljs-number">40</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">30</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">100</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">20</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">35</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">25</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">34</span></span>) puts <span class="hljs-string"><span class="hljs-string">"Tree nodes: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{tree.to_s}</span></span></span><span class="hljs-string">"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"20, 25, 30, 34, 35, 40, 100"</span></span></code> </pre> <br>  We can use this class with numbers, strings, or any proper types of ruby ‚Äã‚Äãthat support matching (i.e. &lt;=&gt;) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Adding nodes in a binary tree </h3><br>  The code for adding nodes to a binary tree is shown below.  This code first checks to see if we already have a root node, if not, then create a root node with a new value.  If we already have a root node, scan the tree nodes (using the rule specified above) until we reach the final node.  Once we have reached the final node we update it to point to the new node. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new_value)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @root == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> @root = Node.new(new_value) @total_nodes = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> current = @root <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_value &gt;= current.value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current.right == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> current.right = Node.new(new_value) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> current = current.right <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current.left == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> current.left = Node.new(new_value) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> current = current.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @total_nodes += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><h3>  Walking on a tree </h3><br>  One of the advantages of a binary search tree is that it is very easy to get the values ‚Äã‚Äãstored in it.  This process is called ‚Äúwalking through a sorted tree‚Äù.  For example, if we have a tree with the following values: 100, 50, 200, and 150, then the sorted tree will give us the values: 50, 100, 150, and 200. Walking around the tree can be implemented using a recursive function.  However, the recursive method, although elegant, is not very efficient if the tree is large.  The code I implemented does not use recursion, but instead uses an array as a stack to track the nodes it visits.  This solution is not as elegant as recursion, but it works well, even if there are thousands of nodes in the tree. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walk</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">==</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">node</span></span></span><span class="hljs-function"> = @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_left</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">false</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">while</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">#p "processing #{node.value.to_s}" if ignore_left #p "ignoring nodes to the left" ignore_left = false else if node.left != nil #p "moving to the left" stack &lt;&lt; node node = node.left next end end yield node if node.right != nil #p "moving to the right" node = node.right next end break if stack.length == 0 #p "popping from the stack" node = stack.pop ignore_left = true end end</span></span></code> </pre><br>  While I was implementing this method, I realized the beauty and simplicity of one of the best features of ruby: blocks.  When the algorithm finds the next node to be processed, it simply gives it to the caller.  This allows you to walk on a tree and be completely independent of the actions that we want to perform on each node.  For example, you can make the following code for each node: <br><br><pre> <code class="ruby hljs">tree.walk { <span class="hljs-params"><span class="hljs-params">|node|</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{node.value}</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  In this example, the block simply ‚Äúoutputs‚Äù the values, but we will see a more complex example when we consider the code for drawing a binary tree. <br><br><h3>  How to Draw a Binary Tree </h3><br>  The binary tree rendering algorithm is, to a large extent, similar to the tree walking algorithm, with the exception that we need to calculate the coordinates of where each node should be located and how we intersect the nodes.  The calculation of the coordinates was an interesting task. <br><br>  The main algorithm is as follows: <br><ul><li>  Draw the root node with the given coordinates </li><li>  Draw the left subtree from the left of the root node </li><li>  Draw the right subtree from the right of the root node </li></ul><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root, x, y, block)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> block.call(root, x, y, x, y) draw_left(root.left, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root.left != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> draw_right(root.right, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root.right != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  To calculate the coordinates of the left subtree, we calculate how many children are on the right side of the left subtree.  The resulting number, we use for a negative offset along the x axis.  Next we recursively call this method for the left and right subtree. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_left</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node, parent_x, parent_y, block)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> + children_count(node.right) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> x = parent_x - @x_distance - (count*@x_distance) y = parent_y + @y_distance block.call(node.value, x, y, parent_x, parent_y) draw_left(node.left, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.left != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> draw_right(node.right, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  For the right subtree, we do the same thing, but vice versa. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_right</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node, parent_x, parent_y, block)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.left != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> + children_count(node.left) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> x = parent_x + @x_distance + (count*@x_distance) y = parent_y + @y_distance block.call(node.value,x,y, parent_x, parent_y) draw_left(node.left, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.left != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> draw_right(node.right, x, y, block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Like the walk method, the rendering method doesn't actually draw anything, but only indicates the coordinates of the object display.  The following example shows the construction of a tree with coordinates in the console: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">"binarytree"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">"binarytreedrawer"</span></span> tree = BinaryTree.new tree.add(<span class="hljs-number"><span class="hljs-number">100</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">50</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">150</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">25</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">75</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">125</span></span>) tree.add(<span class="hljs-number"><span class="hljs-number">175</span></span>) drawer = BinaryTreeDrawer.new(tree) drawer.draw(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, Proc.new { <span class="hljs-params"><span class="hljs-params">|value, x, y, px, py|</span></span> puts <span class="hljs-string"><span class="hljs-string">"Value </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{value}</span></span></span><span class="hljs-string"> at (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{y}</span></span></span><span class="hljs-string">)"</span></span> }) =&gt; Value <span class="hljs-number"><span class="hljs-number">100</span></span> at (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">50</span></span> at (-<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">25</span></span> at (-<span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">75</span></span> at (-<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">150</span></span> at (<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">125</span></span> at (<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>) =&gt; Value <span class="hljs-number"><span class="hljs-number">175</span></span> at (<span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>)</code> </pre><br><h3>  A real example of drawing a binary tree on a webpage </h3><br>  Having coordinates, we can use any graphical program for drawing a tree.  In this web application, I will use <a href="http://diveintohtml5.org/canvas.html">HTML 5 Sanvas</a> as a drawing surface, and several JS methods.  Below is a simple example of how I generate JS calls to draw a tree: <br><br><pre> <code class="ruby hljs">drawer = BinaryTreeDrawer.new(@tree) drawer.draw(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Proc.new { <span class="hljs-params"><span class="hljs-params">|value, x, y, px, py|</span></span> circles &lt;&lt; <span class="hljs-string"><span class="hljs-string">"draw_circle(centerX + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{x}</span></span></span><span class="hljs-string">, offsetY + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{y}</span></span></span><span class="hljs-string">, 5);"</span></span> lines &lt;&lt; <span class="hljs-string"><span class="hljs-string">"draw_line(centerX + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{x}</span></span></span><span class="hljs-string">, offsetY + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{y}</span></span></span><span class="hljs-string">, centerX + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{px}</span></span></span><span class="hljs-string">, offsetY + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{py}</span></span></span><span class="hljs-string">);"</span></span> labels &lt;&lt; <span class="hljs-string"><span class="hljs-string">"draw_label(centerX + 7 + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{x}</span></span></span><span class="hljs-string">, offsetY+5+</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{y}</span></span></span><span class="hljs-string">, \"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{value}</span></span></span><span class="hljs-string">\");"</span></span> })</code> </pre><br>  Note that this code simply creates three arrays (circles, lines, shortcuts) with calls to JavaScript methods.  These arrays are later inserted into the web page and draw a tree on the client side. <br><br><h3>  Source Code and Demonstration </h3><br>  If you want to see a demo, you can visit <a href="http://binarytree.heroku.com/">http://binarytree.heroku.com</a> and generate several binary trees with random data or draw a binary tree with its own data set. <br><br>  All sources for the implementation of a binary tree, as well as a demo site, are posted on <a href="https://github.com/hectorcorrea/binarytree">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/126091/">https://habr.com/ru/post/126091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126085/index.html">Twitter messages will appear on the actions of other users.</a></li>
<li><a href="../126087/index.html">Unrest in England and Automatic Face Recognition</a></li>
<li><a href="../126088/index.html">iPad as a platform for developing web applications</a></li>
<li><a href="../126089/index.html">Build a Visual Studio project into a single file using ILMerge</a></li>
<li><a href="../126090/index.html">Hardware video decoding on AMD Radeon in Ubuntu (mplayer)</a></li>
<li><a href="../126092/index.html">BuildMyPinnedSite - the online site builder</a></li>
<li><a href="../126093/index.html">Under the hood: a review of the program StaffCop Standard</a></li>
<li><a href="../126095/index.html">Mobile programming: today and tomorrow</a></li>
<li><a href="../126096/index.html">At SIGGRAPH 2011, the HP Z800 Workstation simultaneously processed 12 Full HD video streams.</a></li>
<li><a href="../126097/index.html">Android application Sixaxis Controller allows you to play on your smartphone using Sixaxis or DualShock 3 controllers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>