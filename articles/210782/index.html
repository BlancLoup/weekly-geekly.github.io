<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Undocumented 8086 processor operating codes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, when I was studying the DOS boot sectors, I discovered a rather mysterious thing. DOS recognizes whether the boot sector is bootable, by sev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Undocumented 8086 processor operating codes</h1><div class="post__text post__text-html js-mediator-article">  Recently, when I was studying the DOS boot sectors, I discovered a rather mysterious thing.  DOS recognizes whether the boot sector is bootable, by several criteria, and one of them ( <i>odd, yes?</i> ) - is there a jump-instruction in the first two bytes, which indicates, respectively, somewhere behind BPB.  In the MSDISK.INC module from <a title="MS-DOS OAKs" href="http://www.os2museum.com/wp/%3Fp%3D1137">MS-DOS 3.21 OAK,</a> just such checks occur.  The module checks whether the BPB begins with a jump, and accepts EBh (short JMP), E9h (JMP), or 69h opcodes for the correct jump-instruction.  Stop.  69?  This is an IMUL! <br>  Nah, not IMUL.  A comment in the code states that this is a ‚Äúdirect jump‚Äù: <br><br><pre>  cmp byte ptr cs: [DiskSector], 069H;  Is it a direct jump?
    je Check_Signature;  don't need to find a nop
    cmp byte ptr cs: [DiskSector], 0E9H;  DOS 2.0 jump?
    je Check_Signature;  no need for NOP
    cmp byte ptr cs: [DiskSector], 0EBH;  How about a short jump.
    jne baddisk </pre><br>  Well, that's just nothing about 69h in the 8086 documentation!  Yes, in 8186 and further is the IMUL opcode, but the fact that 8086 can do IMUL is extremely unlikely.  Moreover, the comment clearly indicates that this is a jump. <br><br>  Maybe on the 8086 69h processors behaves like a jump?  The question is good, but there is almost no information on this. <a name="habracut"></a>  I thought that someone from an old hacker get-together for early PCs would surely find out exactly what undocumented instructions are doing, but I was mistaken - a rather deep search all over the Internet did not give any intelligible results, and even the book by Frank van Gilluwe "Undocumented PC ‚Äù, In which quite a lot was said about operational codes that are not described in the documentation, did not help much.  Surely, sometime, somewhere, someone has published something ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, it would be nice to note that starting from 80186, unlike 8086/8088, an attempt to execute an incorrect (undocumented) opcode will cause a corresponding exception (now denoted as #UD).  That is, now the opcode is either standard and executed, or #UD is triggered, and, accordingly, there is no point in trying to perform anything other than the instructions described in the documentation.  <i>Well, of course</i> there are exceptions: D6h and F1h - Intel has made it clear that standards do not care about it ... but let us return again to 8086 <br><br>  For 8086, it was not described how he should behave if they try to execute the wrong instruction on it.  Undefined behavior means that each, even an undescribed instruction, definitely does <em>something</em> , and that something can easily hang the processor.  At least it is not prohibited. <br><br>  There are several 8086 opcodes that are not described in the Intel documentation, but whose behavior <a title="The 86BUGS List" href="">has long been established</a> : <br><ul><li>  POP CS (0Fh).  Pretty easy to guess what he is doing.  See: 06h (push es) - 07h (pop es), 16h (push ss) - 17h (pop ss), 1Eh (push ds) - 1Fh (pop ds), 0Eh (push cs) - and, accordingly, 0Fh ( pop cs).  This instruction, although it works, is almost useless.  That is why it has never been documented, and, starting from 80286, another instruction corresponds to the 0Fh opcode. <br></li><li>  MOV CS (8Eh).  Same as with POP CS - pretty easy to guess, and again - useless. <br></li><li>  SETALC / SALC (D6h).  Does the same as SBB AL, AL, but does not touch the flags, that is, AL will either have FFh or 0 depending on CF.  This instruction is present in modern Intel CPUs, but it is still undocumented. </li></ul><br>  Three instructions are fine, but for 8086 60h - 6Fh (including our 69h), C0h - C1h, C8h - C9h, and F1h are also undefined.  There are also several spaces in opcode extensions (this is when the instruction is described not only by the first byte, but also by part of the bits in the next byte), especially the GRP4 group, <a title="Opcode card 8086" href="http://www.mlsite.net/8086/">here</a> . <br><br>  To clarify this matter, Ra√∫l Guti√©rrez Sanz took his Siemens 8086-2 (produced in 1990) and figured out what exactly is happening when executing opcodes that are not described in the official documentation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/442/9e3/7c34429e3e8fcd3024af0131c375887c.jpg"><br><br>  This processor is manufactured under the license of Intel, and, without any suspicion, it is not functionally different from the original Intel processors. <br><br><h2>  Solution </h2><br>  Unfortunately, the behavior of most undocumented opcodes is quite prosaic.  No magical secret instructions ‚Äî these instructions are merely aliases to other documented ones.  In other words, the 8086 processor, when decoding such instructions, simply ignores some bits of the word, and that's it :( <br><br>  The undocumented opcodes 60h - 6Fh correspond to the same instructions as the documented 70h - 7Fh - the processor ignores the fourth bit of the opcode, that is, 60h corresponds to 70h, 61h - 71h, ..., 6Eh - 7Eh, 6Fh - 7Fh, and they do exactly same.  Quite reasonable, especially - for the slow 8086 - no potentially dangerous behavior, and there is no need to write too much microcode.  On the other hand, these initially undocumented opcodes can then be assigned to other instructions in new generation processors, while maintaining backward compatibility (after all, it is assumed that none of the code will describe undescribed opcodes). <br><br>  Thus, in the C0h - CFh range, the CPU ignores the first bit of the word: C0h means C2h, C1h - C3h, C8h - CAh, and C9h - CBh. <br><br>  The behavior of the opcode F1h currently remains a mystery.  On the new processors, F1h is an undocumented ICEBP instruction, or INT1.  In the documentation of Intel, it is not described, although AMD is present. <br><br>  At 8088, F1h rather not even an instruction, but a prefix.  We determined this by following the sequence consisting of repeated F1h opcodes and some other documented one.  The microprocessor steps over the entire sequence, which actually proves that F1h is a kind of prefix. <br>  It seems that F1h is an alias to F0h - the prefix LOCK.  We somehow failed to prove or disprove this, because we need some piece of hardware capable of tracking the LOCK # signal on the bus. <br><br>  Back to the boot sector.  Could the boot sector start from 69h?  At 8088, this would probably work.  If opcode 69h is an alias to the JNS instruction, then if the sign flag is not set, then a short jump will be executed.  At least on the IBM PC, the state of the flags at the beginning of the boot sector execution is predictable, so 69h could work. <br>  But what's the point of putting 69h in the beginning of the boot sector and who would need it?  Good question.  At the moment I don‚Äôt know if there were any DOS boot sectors starting with opcode 69h.  For what it was necessary for someone to use undocumented instructions completely incomprehensible.  Maybe the incorrect implementation of the copy protection system ... but the fact is that DOS separately checks the beginning of the boot sector for the presence of the opcode 69h, and it absolutely proves that such boot sectors definitely existed.  Ideas? <br><br>  PS There are some more undocumented opcodes in the range of extended codes!  More on this next time ... <br></div><p>Source: <a href="https://habr.com/ru/post/210782/">https://habr.com/ru/post/210782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210762/index.html">As we were in Canadian accelerators filed and interviews were held</a></li>
<li><a href="../210764/index.html">Phpbrew PHP Version Manager. (+ install and use in Ubuntu 13.10)</a></li>
<li><a href="../210772/index.html">Theory and practice of source code parsing with ANTLR and Roslyn</a></li>
<li><a href="../210774/index.html">IBM plans to move to a new type of integrated circuit</a></li>
<li><a href="../210776/index.html">Google announced five games for Google Glass</a></li>
<li><a href="../210786/index.html">Linux distribution released ROSA Desktop Fresh GNOME R2</a></li>
<li><a href="../210788/index.html">Google sells Lenovo's Motorola Mobility</a></li>
<li><a href="../210790/index.html">Precedent: do digital TV providers block Rain TV channel ‚Äúfor lack of likes‚Äù and ‚Äúat the request of outraged penguins‚Äù?</a></li>
<li><a href="../210796/index.html">How I knocked out a Facebook interview</a></li>
<li><a href="../210800/index.html">DUMP-2014 will be held in Yekaterinburg on March 14</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>