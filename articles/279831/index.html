<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ferroelectric (ferroelectric) memory and electronic ink - the perfect combination for battery power</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When Texas Instruments equipped its well-known low-power MSP430 series with ferroelectric memory , it became even easier and more pleasant to work wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ferroelectric (ferroelectric) memory and electronic ink - the perfect combination for battery power</h1><div class="post__text post__text-html js-mediator-article">  When Texas Instruments equipped its well-known low-power MSP430 series with <a href="http://www.ti.com/ww/ru/mcu/fram_ultra_low_power_embedded_memory/">ferroelectric memory</a> , it became even easier and more pleasant to work with it, because such memory combines the advantages of flash and RAM.  A new pad with a segment indicator - just a ready platform for some sort of home automation.  And what if you need a graphic display?  Here electronic ink comes to the rescue, because they consume energy only when upgraded and are able to please for years with a beautiful contrast picture, feeding on one set of batteries.  If you are interested in the experience of programming such a device - welcome to Cat.  I will talk about what ferroelectric memory is and why it is needed, how to achieve the lowest possible power consumption and get a beautiful picture on e-paper and use the code written under arduino on Texas. <br><br><img src="https://habrastorage.org/files/ca6/8ad/ae5/ca68adae5b314152a476a75b3f6ed5df.jpg"><br><a name="habracut"></a><br><br>  I started the study of the MSP430 series with the first <a href="http://www.ti.com/ww/en/launchpad/launchpads-msp430-msp-exp430g2.html">MSP-EXP430G2</a> first 'popular' lapse <a href="http://www.ti.com/ww/en/launchpad/launchpads-msp430-msp-exp430g2.html">board</a> .  Therefore, when the <a href="http://www.ti.com/ww/en/launchpad/launchpads-msp430-msp-exp430fr4133.html">MSP-EXP430FR4133</a> and <a href="http://www.ti.com/tool/msp-exp430fr6989">MSP-EXP430FR6989 lunches</a> with <s>pearl buttons with</s> ferroelectric memory and segment LCD appeared on sale, and for almost the same price, I immediately got the idea to make some nice gadget on them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What is good ferroelectric memory </h4><br>  The ferroelectric memory is based on a special material - lead zirconate titanate (PZT).  It is a ferroelectric, that is, capable of spontaneous polarization.  In the structure of this material there are positively charged atoms, 'trapped' in the cell of a negatively charged crystal lattice, and capable of shifting relative to the center of this cell.  This displacement occurs under the action of an electric field and leads to an electric charge flowing in the external circuit.  After removal of the electric field, the cell remains polarized, which allows using this effect to store binary information. <br><br><img src="https://habrastorage.org/files/7c2/9d9/827/7c29d9827eea464da67ffc88613ef627.jpg"><br><br>  Zeros and ones are encoded by polarization PZT in opposite directions.  The only problem is that reading is possible only when the polarization direction is changed, since this is the only way to get a current pulse in an external circuit.  That is, reading is associated with erasing previously recorded information, and it must be immediately restored.  This disadvantage is compensated by the fact that it takes very little time to change the direction of polarization ‚Äî on the order of a nanosecond.  So the recording is much faster than in traditional flash memory, and does not require pre-erasing of blocks.  In fact, you can work with such memory in the same way as with operational memory, and at the same time it retains its contents after turning off the power.  Imagine that we need a buffer to store the settings or to fit an array of data that does not fit into the RAM.  We can implement it as follows: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> buff_holder[BUFF_SZ]; <span class="hljs-comment"><span class="hljs-comment">//    FRAM uint8_t* buff = (uint8_t*)buff_holder; //   buff       </span></span></code> </pre> <br>  Much more convenient than messing with erasing flash blocks is it? <br><br><h4>  Fighting gluttony </h4><br>  The first thing I did when I took the <a href="http://www.ti.com/tool/msp-exp430fr6989">MSP-EXP430FR6989</a> board into my hands was measuring the current consumed by it and was slightly surprised, since the current was about 80 microamps with the processor stopped.  I wrote a simple two-line program whose meaning comes down to stopping the processor: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WDTCTL = WDTPW | WDTHOLD; <span class="hljs-comment"><span class="hljs-comment">//    _bis_SR_register(LPM3_bits); //   }</span></span></code> </pre><br>  Of course, leaving the I / O ports uninitialized incorrectly. By default, they operate on input, and the floating potential of the input leads to the flow of through-current through the transistors of the input buffer.  It is necessary either to program the ports for output, or to connect pull-up resistors.  I implemented the second option, fearing for the peripherals connected to the processor: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WDTCTL = WDTPW | WDTHOLD; <span class="hljs-comment"><span class="hljs-comment">//    //      P1OUT = P2OUT = P3OUT = P4OUT = P5OUT = P6OUT = P7OUT = P8OUT = P9OUT = P10OUT = PJOUT = 0; P1REN = P2REN = P3REN = P4REN = P5REN = P6REN = P7REN = P8REN = P9REN = P10REN = PJREN = ~0; _bis_SR_register(LPM3_bits); //   }</span></span></code> </pre><br>  The current consumption has decreased to 40 microamperes, which is still 10 times more than the result, which was demonstrated by MSP430 processors of the previous generation.  What is the matter?  It turns out that in the new processors an advanced control circuit for the quality of the clock is implemented, which with particular predilection monitors the quartz oscillators.  It is the external crystal oscillator that is selected by default as the source of the low-frequency clock.  If it is not connected, or you have not configured the feet to which it is connected, the error flag of the low-frequency clock is set, after which the backup internal RC frequency generator 5MHz is started, this frequency is divided into 128 and used as a low-frequency clock.  It is this generator that consumes 40 microamps.  The paradox of this obsessive concern for the quality of the shred is that the low-frequency shred in this situation is not used at all! <br>  There are 2 ways to deal with this phenomenon.  First, you can use the internal RC low frequency clock generator.  The code for this case is shown below: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WDTCTL = WDTPW | WDTHOLD; <span class="hljs-comment"><span class="hljs-comment">//    //      P1OUT = P2OUT = P3OUT = P4OUT = P5OUT = P6OUT = P7OUT = P8OUT = P9OUT = P10OUT = PJOUT = 0; P1REN = P2REN = P3REN = P4REN = P5REN = P6REN = P7REN = P8REN = P9REN = P10REN = PJREN = ~0; CSCTL0_H = CSKEY &gt;&gt; 8; //     CSCTL2 = SELA__VLOCLK | SELS__DCOCLK | SELM__DCOCLK; //       _bis_SR_register(LPM3_bits); //   }</span></span></code> </pre><br>  If you care about the accuracy of the clock frequency (for example, for a clock), then this method is not suitable.  You really need a low-frequency crystal oscillator.  You can add a loop that will wait for the stabilization of the clock and clear the error flags, without having forgotten to pre-configure the feet to which the quartz is connected: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WDTCTL = WDTPW | WDTHOLD; <span class="hljs-comment"><span class="hljs-comment">//    //      P1OUT = P2OUT = P3OUT = P4OUT = P5OUT = P6OUT = P7OUT = P8OUT = P9OUT = P10OUT = PJOUT = 0; P1REN = P2REN = P3REN = P4REN = P5REN = P6REN = P7REN = P8REN = P9REN = P10REN = PJREN = ~0; PJSEL0 = BIT4 | BIT5; //    CSCTL0_H = CSKEY &gt;&gt; 8; //     CSCTL4 &amp;= ~LFXTOFF; //    do { CSCTL5 &amp;= ~LFXTOFFG; //      SFRIFG1 &amp;= ~OFIFG; //    } while (SFRIFG1 &amp; OFIFG); //    _bis_SR_register(LPM3_bits); //   }</span></span></code> </pre><br>  The problem with this decision is that if during the operation due to electromagnetic interference, for example, a low-frequency generator error occurs again, it is not processed in any way, as a result of which your clock will go wrong and will actively eat the battery.  An alternative option that always works is to handle errors in the interrupt: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WDTCTL = WDTPW | WDTHOLD; <span class="hljs-comment"><span class="hljs-comment">//    //      P1OUT = P2OUT = P3OUT = P4OUT = P5OUT = P6OUT = P7OUT = P8OUT = P9OUT = P10OUT = PJOUT = 0; P1REN = P2REN = P3REN = P4REN = P5REN = P6REN = P7REN = P8REN = P9REN = P10REN = PJREN = ~0; PJSEL0 = BIT4 | BIT5; //    CSCTL0_H = CSKEY &gt;&gt; 8; //     CSCTL4 &amp;= ~LFXTOFF; //    SFRIE1 = OFIE; //      for (;;) { _bis_SR_register(LPM3_bits + GIE); //  ,   } } #pragma vector=UNMI_VECTOR __interrupt void UNMI_ISR(void) { do { CSCTL5 &amp;= ~LFXTOFFG; //      SFRIFG1 &amp;= ~OFIFG; //    } while (SFRIFG1 &amp; OFIFG); //    }</span></span></code> </pre><br>  Now the board in the stop mode of the processor consumes 0.9 microamperes with a quartz oscillator and 0.6 without it, which is almost an order of magnitude better than the result of the previous generation MSP430! <br><br>  Managing the segmented LCD on board thanks to the libraries provided by TI is not a problem, but it also brought several surprises.  First, the LCD initialization code provided by TI initializes more segments than they really are.  As a result, an alternating voltage with an average value close to half the supply voltage was present on many of the expansion connector pins.  Secondly, LCD consumes unreasonably a lot - about 40 microamps.  But as you know, so that a cow eats less, it only needs to be fed less often.  Reducing the frequency of the LCD clock signal reduced the current consumption to 6.5 microamperes. <br><br><h4>  We connect the screen </h4><br><br>  An <a href="https://www.embeddedartists.com/products/displays/lcd_27_epaper.php">electronic ink</a> screen was chosen as a graphic display.  On the manufacturer's page you will find a lot of libraries, but as usual, not the ones you need.  Libraries provided by the screen maker generally make a heavy impression, since they are made with the expectation of ease of writing and are a multi-layered cake whose performance will be acceptable only on something very fast, like RaspberryPi.  There was, however, an adapted version of the Arduino, where the whole layer cake was tamped into one module.  It was decided to start with it in the absence of the best and unwillingness to reinvent the next bicycle.  At first, I just implemented access functions to ports like digitalWrite / digitalRead in the most general form.  When instead of the expected picture I saw, muddy divorces slowly appearing on the screen, my first desire was to send the screen back.  However, according to common sense, I decided that something was wrong here.  At first, I accelerated the process of developing turbid divorces, slightly optimizing the code - I made all the I / O functions inline.  At the same time, I simply relied on the fact that I would have all the necessary legs on one port, so that the Arduin‚Äôs leg number is the corresponding bit.  Working with SPI also became inline, the result can be seen <a href="">here</a> .  Along the way, I was surprised to learn that there can be only one port in the Arduin SPI - hence the last 2 lines in the file using the link above.  The optimized version of the painted divorce much faster, and they did not look as dirty as before.  Then I went even further and increased the processor clock speed to 8MHz - the picture became almost perfect.  Apparently the display controller has neither its own memory nor the clock generator, but simply uses the input signals to generate the voltages it needs.  Accordingly, if the data transfer is too slow, these supply voltages are less than needed for the update.  The update process is illustrated in the following video. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/FEn34-CsuMo%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhinm1pfFo1qnbqelUNNdAMheFE0fw" frameborder="0" allowfullscreen=""></iframe><br><br>  The last thing you need to do with the screen, if you are going to power it from the battery, is to remove the extra parts installed on the display controller board just in case as a bonus.  The temperature sensor U6 consumes 100 microamps.  This current can be reduced only by sending an off command to it, but we are not going to connect it to the I2C port just for the sake of it.  Much easier to cut the power cord.  U5 flash memory consumes another 5 microamperes, I coped with it, having completely soldered it.  Now the entire system with a working real-time clock consumes 10 microamps.  The screen when updating consumes 10 milliamps for 5 seconds.  With a battery capacity of 1 A * hour (typical value for AA format), it will last for 10 years, and once every hour and a half, the screen is updated for 5 years.  It remains only to draw something meaningful on it, but more on that next time. <br><br><h4>  Source </h4><br>  Lies <a href="https://github.com/olegv142/SmartEPDisplay">here</a> .  IAR Embedded Workbench for MSP430 version 6.40.1 was used for compilation.  No additional libraries required. </div><p>Source: <a href="https://habr.com/ru/post/279831/">https://habr.com/ru/post/279831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279815/index.html">Engineering Assessment: how to measure the technical condition of the project?</a></li>
<li><a href="../279817/index.html">Javascript: problems with click event when using requestAnimationFrame</a></li>
<li><a href="../279819/index.html">‚ÄúHalf of the scientific work on Concurrency is complete nonsense!‚Äù - an interview with Roman Elizarov from Devexperts</a></li>
<li><a href="../279821/index.html">Perl plugin version 1.4 released for IntelliJ IDEA</a></li>
<li><a href="../279829/index.html">And again about the $ _SERVER ['HTTP_HOST'] vulnerability</a></li>
<li><a href="../279833/index.html">1,000,000 residential buildings in Russia</a></li>
<li><a href="../279835/index.html">AES encryption and Android client</a></li>
<li><a href="../279839/index.html">RetroShare</a></li>
<li><a href="../279841/index.html">How to detect overflow of 32-bit variable in long cycles in a 64-bit program</a></li>
<li><a href="../279843/index.html">Laravel TestTools - recording tests for Laravel directly from the Chrome browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>