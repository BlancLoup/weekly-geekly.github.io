<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New Yandex.Disk sync algorithm: how not to choke 900,000 files</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yandex.Disk is one of the few Yandex services, of which desktop software is a part. And one of its most important components is the algorithm for sync...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New Yandex.Disk sync algorithm: how not to choke 900,000 files</h1><div class="post__text post__text-html js-mediator-article">  Yandex.Disk is one of the few Yandex services, of which desktop software is a part.  And one of its most important components is the algorithm for synchronizing local files with their copy in the cloud.  Recently, we had to completely change it.  If the old version hardly digested even several tens of thousands of files and, moreover, did not react quickly enough to some ‚Äúcomplex‚Äù user actions, then the new one, using the same resources, copes with hundreds of thousands of files. <br><br>  In this post, I‚Äôll tell you why it happened: what we couldn‚Äôt foresee when we thought out the first version of Yandex.Disk software, and how we created a new one. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/253171/"><img src="https://habrastorage.org/files/452/bdd/9aa/452bdd9aabcc4598a92dcdade1b56bb5.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, about the task of synchronization.  Technically speaking, it consists in having the same file set in the Yandex.Disk folder on the user's computer and in the cloud.  That is, such user actions as renaming, deleting, copying, adding and modifying files should be synchronized with the cloud automatically. <br><a name="habracut"></a><br><h3>  Why is it not as simple as it seems at first glance? </h3><br>  Theoretically, the task may seem simple enough, but in reality we are faced with various difficult situations.  For example, a person renamed a folder on his computer, we detected this and sent a command to the backend.  However, none of the users waits until the backend confirms the renaming success.  The person immediately opens his locally renamed folder, creates a subfolder in it, and, for example, transfers part of the files to it.  We are in a situation in which it is impossible to immediately perform all the necessary synchronization operations in the cloud.  First you need to wait for the completion of the first operation and only then you can continue. <br><br>  The situation may become even more difficult if several users work with the same account at the same time or they have a shared folder.  And this happens quite often in organizations that use Yandex.Disk.  Imagine that in the previous example, at the moment when we received confirmation of the first rename from the backend, another user takes and renames this folder again.  In this case, again, you cannot immediately perform the actions that the first user has already performed on his computer.  The folder in which he worked locally, on the backend at this time is already called differently. <br><br>  There are cases when a file on a user's computer cannot be called the same as it is called in the cloud.  This can happen if the name has a character that cannot be used by the local file system, or if the user is invited to a shared folder and has his own folder with that name.  In such cases, we have to use local pseudonyms and track their connection with objects in the cloud. <br><br><h3>  Past version of the algorithm </h3><br>  In the previous version of the Yandex.Disk desktop software, the tree comparison algorithm was used to search for changes.  Any other solution at that time did not allow for the search for displacements and renames, since the backend did not have unique object identifiers. <br><br>  In this version of the algorithm, we used three main trees: the local (Local Index), the cloud (Remote Index) and the last synchronized (Stable Index).  In addition, in order to prevent the repeated generation of already queued synchronization operations, two more auxiliary trees were used: the local expected and cloud expected (Expected Remote Index and Expected Local Index).  In these auxiliary trees, the expected state of the local file system and the cloud was stored, after performing all the synchronization operations that have already been queued. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/aff/c47/e76/affc47e76a87447d8cec882150c89f75.png"></div><br>  The procedure for comparing trees in the old algorithm was as follows: <br><br><ol><li>  If the local expected tree and the cloudy expected tree are empty, initialize them by copying the last synchronized tree; </li><li>  We compare the local tree with the cloud expected and, by comparing the individual nodes, we add synchronization operations in the cloud to the queue (creating collections, transferring files to the cloud, moving and deleting in the cloud); </li><li>  For all operations that are queued at the previous step, we fix their future effect in the expected cloud tree; </li><li>  We compare the cloud tree with the local expected one and, by comparing the individual nodes, we add synchronization operations with the local file system to the queue (creating directories, downloading files from the cloud, moving and deleting local files and directories); </li><li>  For all operations that are queued at the previous step, we fix their future effect in the expected local tree; </li><li>  If simultaneous operations with the same file or directory are in the queue (for example, transferring a file to the cloud and downloading the same file from the cloud), then we fix the conflict - the file has changed in two places; </li><li>  After the synchronization operation is performed in the cloud or with the local file system, we put its result in the last synchronized tree; </li><li>  When the queue of synchronization operations becomes empty, we delete the local expected and cloudy expected tree.  Synchronization is finished, and we will no longer need them. </li></ol><br><h3>  Why we had to invent a new algorithm </h3><br>  The main problems of the tree comparison algorithm are high memory consumption and the need to compare the entire tree even with small changes, which led to a heavy load on the processor.  During the processing of changes to even one file, the use of RAM increased by approximately 35%.  Suppose a user has 20,000 files.  Then, with a simple renaming of a single file of 10Kb in size, the memory consumption grew abruptly - from 116MB to 167MB. <br><br>  We also wanted to increase the maximum number of files with which the user can work without problems.  Several dozens and even hundreds of thousands of files may be, for example, a photographer who stores the results of photo shoots on Yandex.Disk.  This task has become especially urgent when people have the opportunity to buy additional space on Yandex.Disk. <br><br>  In the development, too, I wanted to change something.  Debugging of the old version caused difficulties, since the data on the states of one element were in different trees. <br><br>  By this time, id objects appeared on the backend, with the help of which it was possible to more effectively solve the problem of motion detection ‚Äî earlier we used paths. <br><br><h3>  New algorithm </h3><br>  We decided to change the data storage structure and replace the three trees (Local Index, Remote Index, Stable Index) with one, which should lead to a decrease in redundancy in the main data structure.  Due to the fact that the key in the tree is the path to the file system element, as a result of the merger, the amount of RAM used is significantly reduced. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/bd5/e2f/a20/bd5e2fa20b8a412ca82f826aa16d9411.png"></div><br>  We also refused to use auxiliary trees during synchronization, because each element of the tree in the new version stores all the necessary data.  This structure change greatly simplified debugging code. <br><br>  Since we understood that this was a major change, we created a prototype that confirmed the effectiveness of the new solution.  Consider the example of how to change the data in the tree during the synchronization of a new file. <br><br><ol><li>  After the user added a new file to the Disk folder, the program found it and added a new element to the tree.  This element has only one state known - local.  Since the stable and remote states are absent, no memory is allocated for them; </li><li>  The program performs the upload file.  A push comes from the cloud confirming the appearance of a new file, and the remote state is added to the tree; </li><li>  The local and remote states are compared.  Since they match, the stable state is added; </li><li>  The local and remote states are removed.  They are no longer needed, since all the information is in stable. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/834/7eb/66a/8347eb66a2574373a0c4be192f5fed09.png"></div><br>  This example shows that the new synchronization algorithm processes only those elements and events, data on changes in which were received from the file system or the cloud, and not the entire tree, as it was before.  If necessary, parent or child nodes will be processed (for example, in the case of moving a folder). <br><br><h3>  Other improvements </h3><br>  In the new version we have worked on other improvements that have affected the performance.  Saving the tree made incremental, which allows you to write to the file only the latest changes. <br><br>  Yandex.Disk uses <a href="https://en.wikipedia.org/wiki/SHA-2">sha256</a> and <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> digests to check the integrity of files, detect changed fragments and deduplicate files on the backend.  Since this task heavily loads the CPU, in the new version the implementation of the digest calculations has been significantly optimized.  The speed of the file digest is about doubled. <br><br><h3>  Numbers </h3><br>  Synchronization of unique 20,000 files of 10K <br><table><tbody><tr><th>  Software version </th><th>  Download to CPU. <br>  Calculation of digests </th><th>  CPU load <br>  upload <br></th><th>  RAM usage, MB </th></tr><tr><td>  Yandex.Disk 1.3.3 </td><td>  28% (1 core 100%) </td><td>  Approximately 1% </td><td>  102 </td></tr><tr><td>  Yandex.Disk 1.2.7 </td><td>  48% (2 cores 100%) </td><td>  Approximately 10% </td><td>  368 </td></tr></tbody></table><br>  Calculation of digests unique 20000 files of 10kb (indexing) <br><table><tbody><tr><th>  Software version </th><th>  CPU load </th><th>  Time, sec </th><th>  RAM usage, MB </th></tr><tr><td>  Yandex.Disk 1.3.3 </td><td>  25% (1 core 100%) </td><td>  190 </td><td>  82 </td></tr><tr><td>  Yandex.Disk 1.2.7 </td><td>  50% (2 cores 100%) </td><td>  200 </td><td>  245 </td></tr></tbody></table><br>  Run from 20,000 synchronized files at 10K <br><table><tbody><tr><th>  Software version </th><th>  CPU load </th><th>  Time, sec </th><th>  RAM usage, MB </th></tr><tr><td>  Yandex.Disk 1.3.3 </td><td>  25% (1 core 100%) </td><td>  ten </td><td>  55 </td></tr><tr><td>  Yandex.Disk 1.2.7 </td><td>  50% (2 cores 100%) </td><td>  22 </td><td>  125 </td></tr></tbody></table><br>  Upload 1Gb.  10 Mbps Wi-Fi connection <br><table><tbody><tr><th>  Software version </th><th>  CPU load </th><th>  Time, sec </th></tr><tr><td>  Yandex.Disk 1.3.3 </td><td>  five% </td><td>  1106 </td></tr><tr><td>  Yandex.Disk 1.2.7 </td><td>  five% </td><td>  2530 </td></tr></tbody></table><br><h3>  What happened </h3><br>  From the examples it is clear that the new version of Yandex.Disk software uses about 3 times less RAM and about 2 times less CPU load.  Handling minor changes does not increase the amount of memory used. <br><br>  As a result of the changes made, the number of files with which the program handles without problems has significantly increased.  In the Windows version - 300,000, and on Mac OS X - 900,000 files. </div><p>Source: <a href="https://habr.com/ru/post/253171/">https://habr.com/ru/post/253171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253157/index.html">Haskell Range Control Arithmetic with Type-Level Literals</a></li>
<li><a href="../253159/index.html">The history of participation in the competition "Flying robots". Part 1</a></li>
<li><a href="../253163/index.html">The tenth issue of the magazine TsODy.RF</a></li>
<li><a href="../253167/index.html">3D systems - a selection of great ways to mingle with content</a></li>
<li><a href="../253169/index.html">Open courses Android Study Jams now in Moscow</a></li>
<li><a href="../253175/index.html">Bluetooth voltmeter based on arduino</a></li>
<li><a href="../253177/index.html">Course "Combinatorics of words and its applications"</a></li>
<li><a href="../253179/index.html">Weekly io.js, March 13, 2015</a></li>
<li><a href="../253181/index.html">How to build an application on android in 15 minutes</a></li>
<li><a href="../253183/index.html">Rex Black at SQA Days-17: ‚ÄúDo not chase after empty fantasies, but focus on gaining experience‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>