<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust programming language overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust is a new experimental programming language developed by Mozilla. The language is compiled and multiparadigmatic, it is positioned as an alternati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust programming language overview</h1><div class="post__text post__text-html js-mediator-article">  <b>Rust</b> is a new experimental programming language developed by Mozilla.  The language is compiled and multiparadigmatic, it is positioned as an alternative to C / C ++, which in itself is interesting, since even there are not so many applicants for competition.  You can recall D Walter Bright or Go from Google. <br>  Rust supports function, parallel, procedural, and object-oriented programming, i.e.  almost the entire spectrum of paradigms actually used in application programming. <br><br>  I do not aim to translate the documentation (besides, it is very scarce and is constantly changing, since there has not been an official release of the language), instead I want to highlight the most interesting features of the language.  Information is collected both from official documentation and from very few references to the language on the Internet. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  First impression </h4><br>  The syntax of the language is built in the traditional C-like style (which can not but rejoice, since this is already the de facto standard).  Naturally, the well-known errors of C / C ++ design are taken into account. <br>  Traditional Hello World looks like this: <br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">use</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">std</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">fn</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">args</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[str]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::io::<span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"hello world from "</span></span> + args[0] + <span class="hljs-string"><span class="hljs-string">"!"</span></span>); }</code> </pre> <br><br>  An example is a little more complicated - the factorial calculation function: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fn</span></span> fac(n: int) -&gt; int { <span class="hljs-attribute"><span class="hljs-attribute">let</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span>, i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">while</span></span> i &lt;= n { <span class="hljs-attribute"><span class="hljs-attribute">result</span></span> *= i; <span class="hljs-attribute"><span class="hljs-attribute">i</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">ret</span></span> result; }</code> </pre> <br><br>  As you can see from the example, functions are declared in a ‚Äúfunctional‚Äù style (this style has some advantages over the traditional ‚Äúint fac (int n)‚Äù).  We see <b>automatic type inference</b> (the let keyword), the absence of round brackets in the while argument (similar to Go).  The compactness of keywords is also immediately apparent.  The creators of Rust really deliberately made all keywords as short as possible, and, to be honest, I like it. <br><br><h4>  Small but interesting syntactic features </h4><br><ul><li>  You can insert underscores in numeric constants.  Convenient thing, now this feature is added to many new languages. <br> <code>0xffff_ffff_ffff_ffff_ffff_ffff</code> <br> </li><li>  Binary constants.  Of course, a real programmer should convert bin to hex in the mind, but it‚Äôs more convenient! <code>0b1111_1111_1001_0000</code> </li><li>  The bodies of any operators (even consisting of a single expression) must necessarily be enclosed in braces.  For example, in C you could write <code>if(x&gt;0) foo();</code>  , in Rust it is necessary to put braces around foo () </li><li>  But the arguments of if, while, and similar statements do not need to be enclosed in parentheses. </li><li>  in many cases, code blocks can be considered expressions.  In particular, it is possible for example: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the_stars_align</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">something_else</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> </li><li>  the syntax of the function declaration is first the fn keyword, then the argument list, the type of the argument is indicated after the name, then, if the function returns a value, the arrow "-&gt;" and the type of the return value </li><li>  Variables are declared in the same way: the let keyword, the name of a variable; <br> <code>let count: int = 5;</code> </li> <li>  by default, all variables are immutable;  The mutable keyword is used to declare variable variables. </li><li>  the names of the basic types are the most compact of all that I have met: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64 </li><li>  as mentioned above, automatic type inference is supported. </li></ul><br>  In language, there are built-in debugging tools: <br>  The keyword <b>fail</b> completes the current process. <br>  The <b>log</b> keyword outputs any language expression to the log (for example, to stderr) <br>  The <b>assert</b> keyword validates the expression, and if it is false, terminates the current process. <br>  The keyword <b>note</b> allows you to display additional information in case of a process crash. <br><br><h4>  Data types </h4><br>  Rust, like Go, supports <b>structural typing</b> (although, according to the authors, languages ‚Äã‚Äãdeveloped independently, so this is the influence of their common predecessors - Alef, Limbo, etc.).  What is structural typing?  For example, you have a structure declared in some file (or, in Rust terminology, ‚Äúrecord‚Äù) <br>  type point = {x: float, y: float}; <br>  You can declare a bunch of variables and functions with ‚Äúpoint‚Äù argument types.  Then, somewhere else, you can declare some other structure, for example <br>  type MySuperPoint = {x: float, y: float}; <br>  and variables of this type will be fully compatible with variables of type point. <br><br>  In contrast, nominative typing adopted in C, C ++, C # and Java does not allow such constructions.  With nominative typing, each structure is a unique type, incompatible with other types by default. <br><br>  Structures in Rust are called ‚Äúrecords‚Äù.  There are also tuples - these are the same entries, but with nameless fields.  The elements of a tuple, unlike the elements of a record, cannot be mutable. <br><br>  There are vectors - in something similar to ordinary arrays, and in something - the type std :: vector from stl.  When initializing the list, square brackets are used, not curly ones as in C / C ++ <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myvec = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br><br>  A vector, however, a dynamic data structure, in particular, vectors support concatenation. <br><br><pre> <code class="hljs objectivec">let v: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; v += [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br><br>  There are patterns.  Their syntax is quite logical, without piles of ‚Äútemplate‚Äù from C ++.  Templates of functions and data types are supported. <br><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for_rev</span></span></span></span>&lt;T&gt;(v: [T], act: block(T)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = std::vec::len(v); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>u { i -= <span class="hljs-number"><span class="hljs-number">1</span></span>u; act(v[i]); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">circular_buf</span></span></span></span>&lt;T&gt; = {start: uint, end: uint, buf: [mutable T]};</code> </pre> <br><br>  Language supports so-called <b>tags</b> .  This is nothing more than a union from C, with an additional field ‚Äî the code of the variant used (that is, something in common between union and enumeration).  Or, from the point of view of the theory, an algebraic data type. <br><br><pre> <code class="hljs pgsql">tag shape { circle(<span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">float</span></span>); rectangle(<span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">point</span></span>); }</code> </pre><br><br>  In the simplest case, the tag is identical to the listing: <br><br><pre> <code class="hljs matlab">tag animal { dog; <span class="hljs-built_in"><span class="hljs-built_in">cat</span></span>; } let a: animal = dog; a = <span class="hljs-built_in"><span class="hljs-built_in">cat</span></span>;</code> </pre><br>  In more complex cases, each element of the ‚Äúenumeration‚Äù is an independent structure with its own ‚Äúconstructor‚Äù. <br>  Another interesting example is the recursive structure, with the help of which an object of the ‚Äúlist‚Äù type is defined: <br><pre> <code class="hljs cpp">tag <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;T&gt; { nil; cons(T, @<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;T&gt;); } let a: <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, @cons(<span class="hljs-number"><span class="hljs-number">12</span></span>, @nil));</code> </pre><br>  Tags can participate in pattern matching expressions, which can be quite complex. <br><pre> <code class="hljs kotlin">alt x { cons(a, <span class="hljs-meta"><span class="hljs-meta">@cons(b, _)</span></span>) { process_pair(a,b); } cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, _) { process_ten(); } _ { fail; } }</code> </pre> <br><br><h4>  Pattern matching </h4><br>  To begin with, you can consider the pattern matching as an improved switch.  The alt keyword is used, followed by the expression being analyzed, and then in the body of the operator, patterns and actions in case of coincidence with the patterns. <br><pre> <code class="hljs cpp">alt my_number { <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::io::println(<span class="hljs-string"><span class="hljs-string">"zero"</span></span>); } <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::io::println(<span class="hljs-string"><span class="hljs-string">"one or two"</span></span>); } <span class="hljs-number"><span class="hljs-number">3</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::io::println(<span class="hljs-string"><span class="hljs-string">"three to ten"</span></span>); } _ { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::io::println(<span class="hljs-string"><span class="hljs-string">"something else"</span></span>); } }</code> </pre><br>  Not only constants (as in C) can be used as ‚Äúpatterns‚Äù, but also more complex expressions ‚Äî variables, tuples, ranges, types, placeholders (placeholders, '_').  You can add additional conditions using the when clause immediately following the pattern.  There is a special variant of the operator for type matching.  This is possible because the language has a universal variant type <b>any</b> , whose objects can contain values ‚Äã‚Äãof any type. <br><br>  <b>Pointers.</b>  In addition to the usual "sishnyh" pointers, Rust supports special "smart" pointers with built-in reference counting - shared (Shared boxes) and unique (Unique boxes).  They are somewhat similar to shared_ptr and unique_ptr from C ++.  They have their own syntax: @ for shared and ~ for unique.  For unique pointers instead of copying there is a special operation - moving: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = ~<span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y &lt;- x;</code> </pre> <br>  after such a move, the pointer x is deinitialized. <br><br><h4>  Closures, partial applications, iterators </h4><br>  From this place begins functional programming.  Rust fully supports the concept of higher order functions ‚Äî that is, functions that can take as arguments and return other functions. <br><br>  1. The <b>lambda</b> keyword is used to declare a nested function or functional data type. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_plus_function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span></span> { lambda(y: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { x + y } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> plus_two = make_plus_function(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-function"><span class="hljs-function">assert </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus_two</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">)</span></span> == <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><br>  In this example, we have the function make_plus_function, which takes one argument ‚Äúx‚Äù of type int and returns a function of type ‚Äúint-&gt; int‚Äù (here lambda is a keyword).  This function is described in the function body.  The lack of the ‚Äúreturn‚Äù operator is a bit confusing, however, for FP it is a common thing. <br><br>  2. The <b>block</b> keyword is used to declare a functional type, a function argument, which can be substituted with something similar to a block of ordinary code. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_int</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f: block(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, vec: [</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">]) -&gt; [</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">]</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec { result += [f(i)]; } ret result; } map_int({|x| x + <span class="hljs-number"><span class="hljs-number">1</span></span> }, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br><br>  Here we have a function, the input of which is a block ‚Äî essentially a lambda function of the ‚Äúint-&gt; int‚Äù type, and an int type (on the syntax of the vectors below).  The ‚Äúblock‚Äù itself in the calling code is written using the somewhat unusual syntax {| x |  x + 1}.  Personally, I prefer lambdas in C #, the symbol |  stubbornly perceived as bitwise OR (which, by the way, is also in Rust, like all good old sish operations). <br><br>  3. Partial application is the creation of a function based on another function with a large number of arguments by specifying the values ‚Äã‚Äãof some arguments of this other function.  To do this, use the <b>bind</b> keyword and the filler character "_": <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> daynum = bind std::vec::position(_, [<span class="hljs-string"><span class="hljs-string">"mo"</span></span>, <span class="hljs-string"><span class="hljs-string">"tu"</span></span>, <span class="hljs-string"><span class="hljs-string">"we"</span></span>, <span class="hljs-string"><span class="hljs-string">"do"</span></span>, <span class="hljs-string"><span class="hljs-string">"fr"</span></span>, <span class="hljs-string"><span class="hljs-string">"sa"</span></span>, <span class="hljs-string"><span class="hljs-string">"su"</span></span>])</code> </pre> <br><br>  To make it clearer, I will say at once that this can be done on ordinary C by creating a simple wrapper, something like this: <br> <code>const char* daynum (int i) { const char *s ={"mo", "tu", "we", "do", "fr", "sa", "su"}; return s[i]; }</code> <br> <br>  But partial application is a functional style, not a procedural one (by the way, it is not clear from the above example how to make a partial application to get a function without arguments) <br><br>  Another example: the add function is declared with two arguments int, which returns an int.  Next, the single_param_fn functional type is declared, which has one argument, int, and returns int.  With bind, two functional objects add4 and add5 are declared, built on the basis of the add function, which has partial arguments. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span></span> { ret x + y; } type single_param_fn = fn(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> add4: single_param_fn = <span class="hljs-function"><span class="hljs-function">bind </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> add5: single_param_fn = <span class="hljs-function"><span class="hljs-function">bind </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><br>  Functional objects can be called as well as normal functions. <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) == add4(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) == add5(<span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre> <br><br>  4. Pure functions and predicates <br>  Pure functions are functions that have no side effects (including those that do not call any other functions except pure ones).  Such functions are extracted with the pure keyword. <br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">pure</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lt_42</span></span></span></span>(x: int) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { ret (x &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  Predicates are pure functions that return a bool type.  Such functions can be used in the typestate system (see further), that is, called at the compilation stage for various static checks. <br><br>  <b>Syntax macros</b> <br>  Planned feature, but very useful.  In Rust, it is still at the initial development stage. <br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::io::println(#fmt(<span class="hljs-string"><span class="hljs-string">"%s is %d"</span></span>, <span class="hljs-string"><span class="hljs-string">"the answer"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>));</code> </pre> <br>  An expression similar to printf, but executed at compile time (respectively, all argument errors are detected at the compilation stage).  Unfortunately, there are very few materials on syntax macros, and they themselves are still under development, but there is hope that something like <a href="">Nemerle macros</a> will turn out. <br>  By the way, unlike Nemerle, the decision to allocate macros syntactically using the # symbol is very literate: a macro is an entity that is very different from a function, and I consider it important to see at a glance where functions are called in code, and where macros. <br><br><h4>  Attributes </h4><br>  A concept similar to C # attributes (and even with similar syntax).  For this special thanks to the developers.  As you would expect, attributes add meta information to the entity they annotate, <br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[cfg(target_os = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"win32"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_win_service</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Another variant of the attribute syntax is invented - the same line, but with a semicolon at the end, annotates the current context.  That is, what corresponds to the nearest curly brackets covering such an attribute. <br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_win_service</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_os = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"win32"</span></span></span><span class="hljs-meta">)]</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><br><h4>  Parallel computing </h4><br>  Perhaps one of the most interesting parts of the language.  At the same time, the tutorial is not currently described at all :) <br>  The program on Rust consists of a "task tree".  Each task has an input function, its own stack, means of interaction with other tasks ‚Äî channels for outgoing information and ports for incoming ones, and owns some of the objects in the dynamic heap. <br>  Many Rust tasks can exist within a single operating system process.  Rust tasks are ‚Äúlightweight‚Äù: each task consumes less memory than the OS process, and switching between them is faster than switching between OS processes (here, probably, we mean all the ‚Äúthreads‚Äù). <br><br>  The task consists of at least one function without arguments.  The task is launched using the spawn function.  Each task can have channels through which it transfers information to other tasks.  A channel is a special chan type template that is parameterized by the data type of the channel.  For example, chan is a channel for transmitting unsigned bytes. <br>  For transmission to the channel, the send function is used, the first argument of which is the channel, and the second is the value to be transmitted.  In fact, this function places the value in the internal channel buffer. <br>  Ports are used to receive data.  A port is a template port type that is parameterized by the port data type: port is a port for receiving unsigned bytes. <br>  For reading from ports, the recv function is used, the argument of which is the port, and the return value is the data from the port.  Reading blocks the task, i.e.  if the port is empty, the task enters the waiting state until another task sends data to the port connected to the channel. <br>  Linking channels to ports is very simple ‚Äî by initializing a channel with a port using the chan keyword: <br> <code>let reqport = port(); <br> let reqchan = chan(reqport);</code> <br>  Multiple channels can be connected to one port, but not vice versa - one channel cannot be connected to several ports simultaneously. <br><br><h4>  Typestate </h4><br>  I did not find the generally accepted Russian translation of the notion of ‚Äútypestate‚Äù, so I will call this ‚Äútype states‚Äù.  The essence of this feature is that, in addition to the usual type control adopted in static typing, additional contextual checks are possible at the compilation stage. <br>  In one form or another, type states are familiar to all programmers ‚Äî according to the compiler's messages ‚Äúthe variable is used without initialization‚Äù.  The compiler determines where the variable in which there has never been a record is used for reading, and issues a warning.  In a more general form, this idea looks like this: every object has a set of states that it can accept.  In each state, valid and invalid operations are defined for this object.  And the compiler can perform checks on whether a specific operation on an object in a particular place of the program is permissible.  It is important that these checks are performed at compile time. <br><br>  For example, if we have an object of the type "file", then it may have a state of "closed" and "open."  And the read operation from the file is invalid if the file is closed.  In modern languages, the read function usually throws an exception or returns an error code.  A type state system could detect such an error at compile time ‚Äî just as the compiler determines that a variable read operation occurs before any possible write operation, it could determine that the ‚ÄúRead‚Äù method, valid in the file open state, is called to the ‚ÄúOpen‚Äù method that translates an object into this state. <br><br>  In Rust, there is the concept of ‚Äúpredicates‚Äù - special functions that have no side effects and return the bool type.  Such functions can be used by the compiler to call at compile time for the purpose of static checks of certain conditions. <br><br>  Constraints (constraints) are special checks that can be performed at the compilation stage.  To do this, use the keyword check. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">pure fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_less_than</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">) -&lt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span></span> { ret a &lt; b; } <span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-function">check </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_less_than</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Predicates can be "hung" on the input parameters of functions in this way: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_less_than</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre> <br><br>  Information on typestate is extremely small, so many points are not yet clear, but the concept is interesting anyway. <br><br>  That's all.  It is quite possible that I missed some interesting moments, but the article was already bloated.  If you wish, you can now compile the Rust compiler and try to play with various examples.  Information on the assembly is given on the <a href="http://www.rust-lang.org/">official website of the language</a> . </div><p>Source: <a href="https://habr.com/ru/post/135712/">https://habr.com/ru/post/135712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135703/index.html">OpenStreetMap-based group chat (MapChat)</a></li>
<li><a href="../135704/index.html">Programming for the PlayStation 2 - start</a></li>
<li><a href="../135706/index.html">Create apps for Windows Phone using Silverlight + XNA</a></li>
<li><a href="../135707/index.html">Siberian technology in Abu Dhabi</a></li>
<li><a href="../135709/index.html">Lego and Arduino mechanical display</a></li>
<li><a href="../135713/index.html">Free cloud-based PHP-MySQL hosting for a small site based on Amazon AWS</a></li>
<li><a href="../135717/index.html">Release MODx 2.2</a></li>
<li><a href="../135718/index.html">Contribute to ReactOS or CFI @ habrahabr</a></li>
<li><a href="../135719/index.html">Configure Synology Server: Web Server</a></li>
<li><a href="../135720/index.html">D programming language - continuation 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>