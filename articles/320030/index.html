<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel Software Guard Extensions tutorial. Part 5, development of the enclave</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the fifth installment of the Intel Software Guard Extensions (Intel SGX) tutorial series, we will complete the development of the Tutorial Password...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel Software Guard Extensions tutorial. Part 5, development of the enclave</h1><div class="post__text post__text-html js-mediator-article">  In the fifth installment of the <a href="https://software.intel.com/en-us/sgx">Intel Software Guard Extensions (Intel SGX)</a> tutorial series, we will complete the development of the Tutorial Password Manager enclave application.  In the <a href="https://habrahabr.ru/company/intel/blog/318628/">fourth part of</a> this series, we created a DLL library used as the interface level between the enclave bridge functions and the C ++ / CLI program core, and also defined the enclave interface.  These components are ready, so now you can go to the enclave itself. <br><a name="habracut"></a><br>  Along with this part of the series, the source code is provided: a finished application with an enclave.  In this version, the code branch is hardcoded using Intel SGX. <br><br><h2>  <font color="#0071c5">Enclave components</font> </h2><br>  To determine which components should be implemented inside the enclave, let's return to the class diagram of the application kernel, which we first described in the <a href="https://habrahabr.ru/company/intel/blog/318012/">third part</a> - it is shown in Figure.  1. As before, the objects in the enclave are shaded green, and the untrusted components are blue. <br><br><img src="https://habrastorage.org/files/80c/029/c9a/80c029c9a14c4fad82349c5fc75faafa.png"><br>  <i>Figure 1. Class diagram in Tutorial Password Manager with Intel Software Guard Extensions.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      According to this scheme, you can define four classes that should be transferred to the enclave: <br><br><ul><li>  Vault </li><li>  AccountRecord </li><li>  Crypto </li><li>  Drng </li></ul><br>  However, before starting work you will need to make a decision about the application device.  Our application should work on systems with both Intel SGX support and without Intel SGX.  This means that it is not possible to simply convert existing classes so that they work inside the enclave.  You need to create two versions of each class: one for use in enclaves, another for use in untrusted memory.  The question is how to implement this double support? <br><br><h3>  <font color="#0071c5">Option 1. Conditional compilation</font> </h3><br>  The first option is to implement the functionality for the enclave and for untrusted memory in the same source module and use preprocessing definitions and <i>#ifdef</i> instructions to compile the necessary code depending on the context.  The advantage of this approach is that for each class you need only one source code file, there is no need to apply each change in two places.  The disadvantage is that such code is less clear, especially if there are several or significant changes between versions.  In addition, the structure of the project is complicated.  The two Visual Studio * projects, <i>Enclave</i> and <i>PasswordManagerCore</i> , will have common source code files, and each will need to set a preprocessing symbol to ensure that the correct version of the source code is compiled. <br><br><h3>  <font color="#0071c5">Option 2. Separate classes</font> </h3><br>  The second option is to duplicate each source code file to be placed in the enclave.  The advantages of this approach are that the enclave will have its own copy of source code files that can be changed directly, thereby simplifying the structure of the project and viewing the code.  But there is a drawback: if you need to make changes to the classes, you will have to make these changes in two places, even if the changes are the same for the version in the enclave and for the version in the untrusted memory. <br><br><h3>  <font color="#0071c5">Option 3. Inheritance</font> </h3><br>  The third option involves the use of class inheritance, available in C ++.  Functions that are common to both versions of the class are implemented in the base class, and derived classes will implement methods related to each of the branches of the code.  An important advantage of this approach is that this is a very natural and elegant solution to the problem: we use the possibility of the language, designed specifically for such situations.  The disadvantage is the increased complexity of the project structure and the code itself. <br><br>  There are no hard and fast rules here; it is not necessary to use any decision made always and everywhere.  The general recommendation is this: option 1 is best suited for modules where there are few changes or where they can be easily identified;  Options 2 and 3 are better suited for cases where the changes are significant enough or the resulting source code is too complex in terms of reading and maintenance.  If, however, reduce the choice to the level of style and preferences, then any of the listed approaches is quite efficient. <br><br>  We will use the second option, since it provides an opportunity to compare versions of the source code files intended for the enclave and for untrusted memory.  In future releases of this series, we may move on to the third option to make the code more compact. <br><br><h2>  <font color="#0071c5">Enclave classes</font> </h2><br>  Each class has its own problems and difficulties in adapting to work in an enclave, but there is one general rule that applies to all classes: it is no longer necessary to fill the memory with zeros before it is released.  As you may remember from part three, this is the recommended action when processing secure data in untrusted memory.  The memory of the enclave is encrypted by the processor using an encryption key that is not available for any of the hardware levels, so the contents of the released memory will look like random data for other applications.  This means that you can delete all calls to <i>SecureZeroMemory</i> from within the enclave. <br><br><h3>  <font color="#0071c5">Vault class</font> </h3><br>  The Vault class is our interface to the password store.  All bridge functions operate through one or more methods in the <i>Vault</i> class.  His announcement from Vault.h is shown below. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PASSWORDMANAGERCORE_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vault</span></span></span><span class="hljs-class"> {</span></span> Crypto crypto; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_pw_salt[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_nonce[<span class="hljs-number"><span class="hljs-number">12</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_tag[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_enc[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_obs[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_xor[<span class="hljs-number"><span class="hljs-number">16</span></span>]; UINT16 db_version; UINT32 db_size; <span class="hljs-comment"><span class="hljs-comment">// Use get_db_size() to fetch this value so it gets updated as needed char db_data_nonce[12]; char db_data_tag[16]; char *db_data; UINT32 state; // Cache the number of defined accounts so that the GUI doesn't have to fetch // "empty" account info unnecessarily. UINT32 naccounts; AccountRecord accounts[MAX_ACCOUNTS]; void clear(); void clear_account_info(); void update_db_size(); void get_db_key(char key[16]); void set_db_key(const char key[16]); public: Vault(); ~Vault(); int initialize(); int initialize(const unsigned char *header, UINT16 size); int load_vault(const unsigned char *edata); int get_header(unsigned char *header, UINT16 *size); int get_vault(unsigned char *edata, UINT32 *size); UINT32 get_db_size(); void lock(); int unlock(const char *password); int set_master_password(const char *password); int change_master_password(const char *oldpass, const char *newpass); int accounts_get_count(UINT32 *count); int accounts_get_info_sizes(UINT32 idx, UINT16 *mbname_sz, UINT16 *mblogin_sz, UINT16 *mburl_sz); int accounts_get_info(UINT32 idx, char *mbname, UINT16 mbname_sz, char *mblogin, UINT16 mblogin_sz, char *mburl, UINT16 mburl_sz); int accounts_get_password_size(UINT32 idx, UINT16 *mbpass_sz); int accounts_get_password(UINT32 idx, char *mbpass, UINT16 mbpass_sz); int accounts_set_info(UINT32 idx, const char *mbname, UINT16 mbname_len, const char *mblogin, UINT16 mblogin_len, const char *mburl, UINT16 mburl_len); int accounts_set_password(UINT32 idx, const char *mbpass, UINT16 mbpass_len); int accounts_generate_password(UINT16 length, UINT16 pwflags, char *cpass); int is_valid() { return _VST_IS_VALID(state); } int is_locked() { return ((state&amp;_VST_LOCKED) == _VST_LOCKED) ? 1 : 0; } };</span></span></code> </pre> <br>  The declaration of the version of this class for the enclave, which we will call <i>E_Vault</i> for clarity, will be identical, with the exception of one important change. <br><br>  In the untrusted code branch, the <i>Vault</i> object must store the decrypted database key in memory.  Every time we make any change to the password store, we need to encrypt the updated store data and write it to disk.  This means that the key must be at our disposal.  Before us are four paths: <br><br><ol><li>  To prompt the user to enter the master password with each change in order to generate a database key on demand. </li><li>  Cache the user's master password to generate an on-demand database key without user intervention. </li><li>  Encrypt, encode or hide the database key in memory. </li><li>  Keep the key unencrypted. </li></ol><br>  None of these solutions is satisfactory.  The lack of more convenient solutions again underlines the relevance of technologies such as the Intel SGX.  The first solution can - with reservations - be considered more secure, but no user will want to use an application that will behave in a detailed manner.  The second solution is feasible with the .NET * <i>SecureString</i> class, but it will still be vulnerable to getting the key through a debugger.  In addition, for generating a key, certain computational resources will be required, due to which performance may decline to an unacceptable level for users.  The third option, in fact, is as unsafe as the second, but without sacrificing performance.  The fourth option is the worst of all. <br><br>  In our application, the Tutorial Password Manager uses the third option: the database key is encoded using XOR with a 128-bit value, which is formed arbitrarily when opening a storage file and stored in memory only in this form after processing with XOR.  This is, in fact, a scheme with a one-time encryption key.  The key is available to anyone who can run the debugger, but the time during which the database key is kept in memory in an unencrypted form is limited. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Vault::set_db_key(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { UINT i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) db_key_obs[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j] = db_key[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j] ^ db_key_xor[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j]; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Vault::get_db_key(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { UINT i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) db_key[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j] = db_key_obs[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j] ^ db_key_xor[<span class="hljs-number"><span class="hljs-number">4</span></span> * i + j]; }</code> </pre> <br>  This approach obviously belongs to the ‚Äúsecurity through obscurity‚Äù model, but since we publish the source code, there is no need to speak about any particular obscurity.  It would be possible to choose a better algorithm or make more efforts to hide the database key and one-time key (including ways of storing them in memory), but the method we chose will still be vulnerable to view using the debugger, and the algorithm for hiding everything equal will be published and available to all. <br><br>  However, inside the enclave, this problem disappears.  The memory is protected by hardware-based encryption, so even after decrypting the database key, it is not available for anyone to view, even for processes with extended rights.  Therefore, we no longer need the following members and methods of the class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_obs[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key_xor[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_db_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_db_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>;</code> </pre> <br>  You can replace them with just one member of the class: the char array to store the database key. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>];</code> </pre> <br><h3>  <font color="#0071c5">Class AccountInfo</font> </h3><br>  Account data is stored in a fixed-size array of <i>AccountInfo</i> objects as a member of a <i>Vault</i> object.  The <i>AccountInfo declaration is</i> also in Vault.h, shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PASSWORDMANAGERCORE_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountRecord</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> nonce[<span class="hljs-number"><span class="hljs-number">12</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tag[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Store these in their multibyte form. There's no sense in translating // them back to wchar_t since they have to be passed in and out as // char * anyway. char *name; char *login; char *url; char *epass; UINT16 epass_len; // Can't rely on NULL termination! It's an encrypted string. int set_field(char **field, const char *value, UINT16 len); void zero_free_field(char *field, UINT16 len); public: AccountRecord(); ~AccountRecord(); void set_nonce(const char *in) { memcpy(nonce, in, 12); } void set_tag(const char *in) { memcpy(tag, in, 16); } int set_enc_pass(const char *in, UINT16 len); int set_name(const char *in, UINT16 len) { return set_field(&amp;name, in, len); } int set_login(const char *in, UINT16 len) { return set_field(&amp;login, in, len); } int set_url(const char *in, UINT16 len) { return set_field(&amp;url, in, len); } const char *get_epass() { return (epass == NULL)? "" : (const char *)epass; } const char *get_name() { return (name == NULL) ? "" : (const char *)name; } const char *get_login() { return (login == NULL) ? "" : (const char *)login; } const char *get_url() { return (url == NULL) ? "" : (const char *)url; } const char *get_nonce() { return (const char *)nonce; } const char *get_tag() { return (const char *)tag; } UINT16 get_name_len() { return (name == NULL) ? 0 : (UINT16)strlen(name); } UINT16 get_login_len() { return (login == NULL) ? 0 : (UINT16)strlen(login); } UINT16 get_url_len() { return (url == NULL) ? 0 : (UINT16)strlen(url); } UINT16 get_epass_len() { return (epass == NULL) ? 0 : epass_len; } void clear(); };</span></span></code> </pre> <br>  For this class there is no need to do anything so that it can work inside the enclave.  It is enough to remove unnecessary calls to <i>SecureZeroFree</i> , and the work can be considered finished.  Nevertheless, we will change it anyway to demonstrate an important point: inside the enclave we gain additional flexibility that we did not have before. <br><br>  Let us return to the third part of this series: one of the rules for protecting data in an untrusted memory space concerned not using container classes that manage their own memory, in particular, the class <i>std :: string</i> from the standard template library.  Inside the enclave, this problem disappears.  For the very same reason that we do not need to fill the memory with zeros before it is released, we don‚Äôt need to worry about how the standard template library (STL) containers manage their memory.  The memory of the enclave is encrypted, so even if fragments of protected data remain there after container operations, this data will not be available for other processes. <br><br>  In addition, there is a strong argument in favor of using the class <i>std :: string</i> inside an enclave: the code for STL containers has been thoroughly studied by developers for several years, so it can be argued that this code is safer than our own high-level string functions (if you have a choice).  For simple code, such as in the class <i>AccountInfo</i> , this is not too important, but in more complex programs this can be a very useful advantage.  However, the size of the DLL library increases due to the additional STL code. <br><br>  The declaration of the new class, which we will call <i>E_AccountInfo</i> , is shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRY_ASSIGN(x) try{x.assign(in,len);} catch(...){return 0;} return 1 class E_AccountRecord { char nonce[12]; char tag[16]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Store these in their multibyte form. There's no sense in translating // them back to wchar_t since they have to be passed in and out as // char * anyway. string name, login, url, epass; public: E_AccountRecord(); ~E_AccountRecord(); void set_nonce(const char *in) { memcpy(nonce, in, 12); } void set_tag(const char *in) { memcpy(tag, in, 16); } int set_enc_pass(const char *in, uint16_t len) { TRY_ASSIGN(epass); } int set_name(const char *in, uint16_t len) { TRY_ASSIGN(name); } int set_login(const char *in, uint16_t len) { TRY_ASSIGN(login); } int set_url(const char *in, uint16_t len) { TRY_ASSIGN(url); } const char *get_epass() { return epass.c_str(); } const char *get_name() { return name.c_str(); } const char *get_login() { return login.c_str(); } const char *get_url() { return url.c_str(); } const char *get_nonce() { return (const char *)nonce; } const char *get_tag() { return (const char *)tag; } uint16_t get_name_len() { return (uint16_t) name.length(); } uint16_t get_login_len() { return (uint16_t) login.length(); } uint16_t get_url_len() { return (uint16_t) url.length(); } uint16_t get_epass_len() { return (uint16_t) epass.length(); } void clear(); };</span></span></span></span></code> </pre><br>  The <i>tag</i> and <i>nonce</i> members are still stored as char arrays.  The password is encrypted using the AES algorithm in GCM mode with a 128-bit key, a 96-bit random number and a 128-bit authentication tag.  Since the fixed size of the random number and tag is used, there is no need to store them in any structures more complex than simple arrays of char. <br><br>  Please note that this approach based on <i>std :: string</i> allows us to almost completely define the class in the header file. <br><br><h3>  <font color="#0071c5">Class crypto</font> </h3><br>  The <i>Crypto</i> class provides encryption functions.  This class declaration is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PASSWORDMANAGERCORE_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Crypto</span></span></span><span class="hljs-class"> {</span></span> DRNG drng; <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> aes_init (BCRYPT_ALG_HANDLE *halgo, LPCWSTR algo_id, PBYTE chaining_mode, DWORD chaining_mode_len, BCRYPT_KEY_HANDLE *hkey, PBYTE key, ULONG key_len); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aes_close</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BCRYPT_ALG_HANDLE *halgo, BCRYPT_KEY_HANDLE *hkey)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> aes_128_gcm_encrypt(PBYTE key, PBYTE nonce, ULONG nonce_len, PBYTE pt, DWORD pt_len, PBYTE ct, DWORD ct_sz, PBYTE tag, DWORD tag_len); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> aes_128_gcm_decrypt(PBYTE key, PBYTE nonce, ULONG nonce_len, PBYTE ct, DWORD ct_len, PBYTE pt, DWORD pt_sz, PBYTE tag, DWORD tag_len); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> sha256_multi (PBYTE *messages, ULONG *lengths, BYTE hash[<span class="hljs-number"><span class="hljs-number">32</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Crypto(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); ~Crypto(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> generate_database_key (BYTE key_out[<span class="hljs-number"><span class="hljs-number">16</span></span>], GenerateDatabaseKeyCallback callback); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> generate_salt (BYTE salt[<span class="hljs-number"><span class="hljs-number">8</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> generate_salt_ex (PBYTE salt, ULONG salt_len); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> generate_nonce_gcm (BYTE nonce[<span class="hljs-number"><span class="hljs-number">12</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> unlock_vault(PBYTE passphrase, ULONG passphrase_len, BYTE salt[<span class="hljs-number"><span class="hljs-number">8</span></span>], BYTE db_key_ct[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE db_key_tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_pt[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> derive_master_key (PBYTE passphrase, ULONG passphrase_len, BYTE salt[<span class="hljs-number"><span class="hljs-number">8</span></span>], BYTE mkey[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> derive_master_key_ex (PBYTE passphrase, ULONG passphrase_len, PBYTE salt, ULONG salt_len, ULONG iterations, BYTE mkey[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> validate_passphrase(PBYTE passphrase, ULONG passphrase_len, BYTE salt[<span class="hljs-number"><span class="hljs-number">8</span></span>], BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE db_tag[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> validate_passphrase_ex(PBYTE passphrase, ULONG passphrase_len, PBYTE salt, ULONG salt_len, ULONG iterations, BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE db_tag[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> encrypt_database_key (BYTE master_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_pt[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_ct[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], DWORD flags= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> decrypt_database_key (BYTE master_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_ct[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], BYTE db_key_pt[<span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> encrypt_account_password (BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE password_pt, ULONG password_len, PBYTE password_ct, BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], DWORD flags= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> decrypt_account_password (BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE password_ct, ULONG password_len, BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE password); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> encrypt_database (BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE db_serialized, ULONG db_size, PBYTE db_ct, BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], DWORD flags= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> decrypt_database (BYTE db_key[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE db_ct, ULONG db_size, BYTE iv[<span class="hljs-number"><span class="hljs-number">12</span></span>], BYTE tag[<span class="hljs-number"><span class="hljs-number">16</span></span>], PBYTE db_serialized); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> generate_password(PBYTE buffer, USHORT buffer_len, USHORT flags); };</code> </pre><br>  Public methods in this class are modified to perform various high-level operations with the storage: <i>unlock_vault</i> , <i>derive_master_key</i> , <i>validate_passphrase</i> , <i>encrypt_database</i> , etc. Each of these methods invokes one or more encryption algorithms to perform its task.  For example, the unlock_vault method gets the password phrase provided by the user, passes it through the key generation function based on the SHA-256 algorithm, then uses the received key to decrypt the database key using the AES-128 algorithm in GCM mode. <br><br>  However, these high-level methods do not cause encryption primitives directly.  They call the middle level at which each encryption algorithm is implemented as an independent function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6cc/8b5/22b/6cc8b522ba55488e873329aaaa502906.png"></div><br>  <i>Figure 2. Encryption library dependencies.</i> <br><br>  The private methods that make up our middle layer are built on the basis of encryption primitives and support the functions provided by the basic encryption library, as shown in Fig.  2. An implementation that does not use Intel SGX relies on the Microsoft Cryptography API: Next Generation (CNG), but the same library cannot be used inside the enclave, since the enclave cannot depend on external DLL libraries.  To create a version of this class for Intel SGX, you need to replace these basic functions with functions from the trusted encryption library that is distributed with the Intel SGX SDK.  (As you probably remember from the second part, we very carefully selected the encryption functions common to the CNG and to the trusted encryption library of the Intel SGX, for this very reason.) <br><br>  To create an <i>Crypto</i> class with enclave support, which we will call <i>E_Crypto</i> , you need to change the following private methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> aes_128_gcm_encrypt(PBYTE key, PBYTE nonce, ULONG nonce_len, PBYTE pt, DWORD pt_len, PBYTE ct, DWORD ct_sz, PBYTE tag, DWORD tag_len); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> aes_128_gcm_decrypt(PBYTE key, PBYTE nonce, ULONG nonce_len, PBYTE ct, DWORD ct_len, PBYTE pt, DWORD pt_sz, PBYTE tag, DWORD tag_len); <span class="hljs-keyword"><span class="hljs-keyword">crypto_status_t</span></span> sha256_multi (PBYTE *messages, ULONG *lengths, BYTE hash[<span class="hljs-number"><span class="hljs-number">32</span></span>]);</code> </pre> <br>  A description of each method, as well as the primitives and supporting functions of the CNG, on the basis of which they are built, is given in Table 1. <br><table><tbody><tr><th>  Method </th><th>  Algorithm </th><th>  CNG primitives and supporting functions </th></tr><tr><td>  aes_128_gcm_encrypt </td><td>  AES encryption in GCM mode: <br>  ‚Ä¢ 128-bit key <br>  ‚Ä¢ 128-bit authentication tag <br>  ‚Ä¢ No additional validated data (AAD) </td><td>  BCryptOpenAlgorithmProvider <br>  BCryptSetProperty <br>  BCryptGenerateSymmetricKey <br>  BCryptEncrypt <br>  BCryptCloseAlgorithmProvider <br>  BCryptDestroyKey </td></tr><tr><td>  aes_128_gcm_decrypt </td><td>  AES encryption in GCM mode: <br>  ‚Ä¢ 128-bit key <br>  ‚Ä¢ 128-bit authentication tag <br>  ‚Ä¢ Lack of AAD </td><td>  BCryptOpenAlgorithmProvider <br>  BCryptSetProperty <br>  BCryptGenerateSymmetricKey <br>  BCryptDecrypt <br>  BCryptCloseAlgorithmProvider <br>  BCryptDestroyKey </td></tr><tr><td>  sha256_multi </td><td>  Hash SHA-256 (extra) </td><td>  BCryptOpenAlgorithmProvider <br>  BCryptGetProperty <br>  BCryptCreateHash <br>  BCryptHashData <br>  BCryptFinishHash <br>  BCryptDestroyHash <br>  BCryptCloseAlgorithmProvider </td></tr></tbody></table>  <i>Table 1. Comparison of Crypto class methods with API Cryptography: Next Generation (CNG) functions.</i> <br><br>  CNG provides very precise control over encryption algorithms, as well as optimization options for improved performance.  Our class <i>Crypto</i> cannot boast of excessive efficiency: each time when calling one of these algorithms, it initializes the basic primitives from scratch, and then completely closes them.  This is not a serious problem for Password Manager, which works on the basis of the user interface and encrypts small amounts of data at the same time.  A more powerful server application, such as a web server or a database server, would require a more efficient approach. <br><br>  The API for the trusted encryption library distributed with the Intel SGX SDK looks more like our average level than the CNG.  At the same time, there is less support for precise control of basic primitives, but the creation of the <i>E_Crypto</i> class becomes much easier.  Table 2 shows the new mapping between the middle tier and the underlying provider. <br><table><tbody><tr><th>  Method </th><th>  Algorithm </th><th>  Primitives and supporting functions in the Intel SGX Trusted Cryptography Library </th></tr><tr><td>  aes_128_gcm_encrypt </td><td>  AES encryption in GCM mode: <br>  ‚Ä¢ 128-bit key <br>  ‚Ä¢ 128-bit authentication tag <br>  ‚Ä¢ No additional validated data (AAD) </td><td>  sgx_rijndael128GCM_encrypt </td></tr><tr><td>  aes_128_gcm_decrypt </td><td>  AES encryption in GCM mode: <br>  ‚Ä¢ 128-bit key <br>  ‚Ä¢ 128-bit authentication tag <br>  ‚Ä¢ Lack of AAD </td><td>  sgx_rijndael128GCM_decrypt </td></tr><tr><td>  sha256_multi </td><td>  Hash SHA-256 (extra) </td><td>  sgx_sha256_init <br>  sgx_sha256_update <br>  sgx_sha256_get_hash <br>  sgx_sha256_close </td></tr></tbody></table>  <i>Table 2. Comparison of Crypto class methods with Intel SGX Trusted Cryptography Library functions.</i> <br><br><h3>  <font color="#0071c5">DRNG class</font> </h3><br>  The <i>DRNG</i> class is an interface to a hardware digital random number generator, which is available thanks to support for Intel Secure Key technology.  For homogeneity with previous actions, the version of this class intended for the enclave will be called <i>E_DRNG</i> . <br><br>  We will make two changes in this class to adapt it to the enclave.  Both changes are internal to the methods of this class.  The class declaration remains the same. <br><br><h4>  <font color="#0071c5">CPUID instruction</font> </h4><br>  One of the requirements of our application is that the CPU must support Intel Secure Key Technology.  Intel SGX technology is newer than Secure Key, but there is no guarantee that all future generations of all possible CPUs with Intel SGX support will also support the Intel Secure Key.  Now it is difficult to foresee such a situation, but in practice it is better not to rely on the relationship between the components, one of which may not exist.  If a set of components has independent detection mechanisms, then you must assume that these components do not depend on each other, so you need to check their presence separately.  In practice, this means the following: however much we would like to hope that the CPU supporting Intel SGX will also support the Intel Secure Key, this should not be done in any way. <br><br>  The situation is further complicated by the fact that the Intel Secure Key consists of two separate components, the presence of each of them also needs to be checked separately.  Our application should determine support for RDRAND and RDSEED instructions.  For more information about Intel Secure Key Technology, see the Intel <a href="https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide/">Random Number Generation Software (DRNG) Implementation Guide</a> . <br><br>  The constructor in the <i>DRNG</i> class <i>is</i> responsible for the checks needed to locate the <i>RDRAND</i> and <i>RDSEED components</i> .  It makes the necessary calls to the CPUID instruction using the built-in compiler functions <i>__cpuid</i> and <i>__cpuidex</i> and sets a static global variable with the results. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _drng_support= DRNG_SUPPORT_UNKNOWN; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _drng_support= DRNG_SUPPORT_UNKNOWN; DRNG::DRNG(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> info[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_drng_support != DRNG_SUPPORT_UNKNOWN) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _drng_support= DRNG_SUPPORT_NONE; <span class="hljs-comment"><span class="hljs-comment">// Check our feature support __cpuid(info, 0); if ( memcmp(&amp;(info[1]), "Genu", 4) || memcmp(&amp;(info[3]), "ineI", 4) || memcmp(&amp;(info[2]), "ntel", 4) ) return; __cpuidex(info, 1, 0); if ( ((UINT) info[2]) &amp; (1&lt;&lt;30) ) _drng_support|= DRNG_SUPPORT_RDRAND; #ifdef COMPILER_HAS_RDSEED_SUPPORT __cpuidex(info, 7, 0); if ( ((UINT) info[1]) &amp; (1&lt;&lt;18) ) _drng_support|= DRNG_SUPPORT_RDSEED; #endif }</span></span></code> </pre> <br>  The problem for the <i>E_DRNG</i> class is that the CPUID is not a valid instruction inside the enclave.  To call the CPUID, you need to use <i>OCALL</i> to exit the enclave, and then call the CPUID in an untrusted code.  Fortunately, the developers of the Intel SGX SDK have created two convenient functions that greatly simplify this task: <i>sgx_cpuid</i> and <i>sgx_cpuidex</i> .  These functions automatically perform <i>OCALL</i> , and the creation of <i>OCALL</i> occurs automatically.  The only requirement is that the EDL file must import the sgx_tstdc.edl header: <br><br><pre> <code class="cpp hljs">enclave { <span class="hljs-comment"><span class="hljs-comment">/* Needed for the call to sgx_cpuidex */</span></span> from <span class="hljs-string"><span class="hljs-string">"sgx_tstdc.edl"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *; trusted { <span class="hljs-comment"><span class="hljs-comment">/* define ECALLs here. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_initialize</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_initialize_from_header</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([in, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Our other ECALLs have been omitted for brevity */</span></span> }; untrusted { }; };</code> </pre> <br>  The detection code for system components in the <i>E_DRNG</i> constructor becomes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _drng_support= DRNG_SUPPORT_UNKNOWN; E_DRNG::E_DRNG(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> info[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sgx_status_t</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_drng_support != DRNG_SUPPORT_UNKNOWN) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _drng_support = DRNG_SUPPORT_NONE; <span class="hljs-comment"><span class="hljs-comment">// Check our feature support status= sgx_cpuid(info, 0); if (status != SGX_SUCCESS) return; if (memcmp(&amp;(info[1]), "Genu", 4) || memcmp(&amp;(info[3]), "ineI", 4) || memcmp(&amp;(info[2]), "ntel", 4)) return; status= sgx_cpuidex(info, 1, 0); if (status != SGX_SUCCESS) return; if (info[2]) &amp; (1 &lt;&lt; 30)) _drng_support |= DRNG_SUPPORT_RDRAND; #ifdef COMPILER_HAS_RDSEED_SUPPORT status= __cpuidex(info, 7, 0); if (status != SGX_SUCCESS) return; if (info[1]) &amp; (1 &lt;&lt; 18)) _drng_support |= DRNG_SUPPORT_RDSEED; #endif }</span></span></code> </pre><br><table><tbody><tr><td width="50"><img src="https://habrastorage.org/files/8f4/5c8/ee6/8f45c8ee6ea748aa80f1db40147346f5.png"></td><td>  Since calls to the CPUID instruction are made in untrusted memory, the CPUID results cannot be trusted!  This warning is valid in all cases when you run the CPUID yourself or use SGX functions for this.  The Intel SGX SDK offers the following advice: ‚Äúthe code must check the results and evaluate the threat in order to determine the effect on the trusted code in case of fake results‚Äù. <br><br>  In our training password manager, there are three options: <br><br><ol><li>  The RDRAND and / or RDSEED instructions were not detected, but a positive result for one of them was tampered with.  This will lead to an error due to invalid instructions at runtime, the program will crash. </li><li>  The RDRAND instruction was found, but a negative result was forged.  This will result in a runtime error;  the program will shut down in a regular manner, since the required component was not found. </li><li>  The RDSEED instruction has been detected, but a negative result has been tampered with.  In this case, the program will return to using the RDRAND instruction to obtain initial random values, which will slightly affect performance.         . </li></ol><br>       ,       ,    ,         (). </td></tr></tbody></table><br><br><h4> <font color="#0071c5">     RDRAND</font> </h4><br>       RDSEED,       RDRAND     ,   ,        RDSEED (    ).  <a href="https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide/">        (DRNG)</a> Intel          RDRAND,     :   512  128-           CBC-MAC  AES    128-  .  ,     ,  . <br><br>      Intel SGX  <i>seed_from_rdrand</i>  CNG    .    Intel SGX     CNG,      ,     Intel SGX SDK.      3. <br><table><tbody><tr><th>  Algorithm </th><th>  CNG    </th><th>      Intel SGX Trusted Cryptography Library </th></tr><tr><td> aes-cmac </td><td> BCryptOpenAlgorithmProvider <br> BCryptGenerateSymmetricKey <br> BCryptSetProperty <br> BCryptEncrypt <br> BCryptDestroyKey <br> BCryptCloseAlgorithmProvider </td><td> sgx_cmac128_init <br> sgx_cmac128_update <br> sgx_cmac128_final <br> sgx_cmac128_close </td></tr></tbody></table> <i> 3.      seed_from_rdrand  E_DRNG.</i> <br><br>       <i>DRNG</i> ,      <i>Crypto</i>     ?  ,         .  <i>DRNG</i>     ,         <i>DRNG</i>  <i>Crypto</i> (  <i>Crypto</i>   <i>DRNG</i> ).  ,  <i>Crypto</i>   ,        ,       API   . <br><br><h4> <font color="#0071c5">    sgx_read_rand?</font> </h4><br>   Intel SGX SDK   <i>sgx_read_rand</i> ,      .       : <br><br><ol><li>    Intel SGX SDK,   ¬´         C  ,    ,   <i>rand</i> , <i>srand</i>  .,    ¬ª.  <i>sgx_read_rand</i>    RDRAND,    ,      ,       <i>srand</i>  <i>rand</i> ,     C.  ,   C,     .  ,    - ,  , ,     ,  CPUID,     ,      . </li><li>    Intel SGX SDK    RDSEED.  ,         .       RDRAND   <i>sgx_read_rand</i> ,               ,    . </li><li>      ,  <i>sgx_read_rand</i> ,          . </li></ol><br><h3>  <font color="#0071c5">Summarizing</font> </h3><br>          .   ,      ,     ,                . <br>  As mentioned above, this section provides sample code for download. <br><br> <a href="https://software.intel.com/protected-download/676750/698605"> </a>      Tutorial Password Manager,     -.      ,     ;    ,       Intel SGX. <br><br><h3>  <font color="#0071c5">In further releases</font> </h3><br>               ,           ,     Intel SGX.  Follow the news! <br><br>        <a href="https://software.intel.com/en-us/node/676750">Intel Software Guard Extensions Tutorial Series</a> . </div><p>Source: <a href="https://habr.com/ru/post/320030/">https://habr.com/ru/post/320030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320018/index.html">Customization in 1C</a></li>
<li><a href="../320020/index.html">Reception campaign 2017: Useful links and materials for future bachelors, masters and graduate students of ITMO University</a></li>
<li><a href="../320022/index.html">Flexbox First. Layout tables and text flexboxes</a></li>
<li><a href="../320024/index.html">Analyze it: how Skyeng chose a product analytics system for mobile apps</a></li>
<li><a href="../320026/index.html">"Friday format": where to grow technical specialists</a></li>
<li><a href="../320032/index.html">Hardware or software write blockers - which is more reliable?</a></li>
<li><a href="../320034/index.html">Is React Native good?</a></li>
<li><a href="../320036/index.html">Installation and basic configuration of nginx and php-fpm for developing projects locally in Ubuntu 16.04</a></li>
<li><a href="../320040/index.html">Firebase: farewell to illusions</a></li>
<li><a href="../320042/index.html">Grant Proposal course: how to find the right words to attract attention and money to your development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>