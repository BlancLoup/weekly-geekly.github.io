<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nasty questions about the life cycle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each developer has come across questions about the life cycle of an Activity: what a bind service is, how to maintain the interface state when the scr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nasty questions about the life cycle</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/iq/rl/ci/iqrlcirhwliuqufp0rlca6brqfk.jpeg"><br><br><p>  Each developer has come across questions about the life cycle of an Activity: what a bind service is, how to maintain the interface state when the screen is rotated, and how Fragment differs from Activity. <br>  We in FunCorp have accumulated a list of questions on similar topics, but with certain nuances.  Some of them I want to share with you. </p><a name="habracut"></a><br><p>  <strong>1.</strong> Everyone knows that if you open the second activation over the first one and rotate the screen, then the chain of life cycle calls will look like this: </p><br><div class="spoiler">  <b class="spoiler_title">Discovery Activity</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Turn</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Return back</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> </p></div></div><br><p>  And what will happen if the second activation is transparent? </p><br><p>  <strong>Decision</strong> </p><br><p>  In the case of a transparent top activation, from the point of view of logic, everything is a little different.  It is precisely because it is transparent that after turning it is necessary to restore the contents and the activation that is directly below it.  Therefore, the order of calls will be slightly different: </p><br><div class="spoiler">  <b class="spoiler_title">Opening activity</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Turn</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>FirstActivity: onResume</em> <em><br></em>  <em>FirstActivity: onPause</em> </p></div></div><br><p>  <strong>2.</strong> No application can do without dynamically adding a view, but sometimes you have to move the same view between different screens.  Can one and the same object be added simultaneously to two different activations?  What happens if I create it with the Application context and want to add to different activites at the same time? </p><br><p>  <strong>Why do you need it?</strong> <br>  There are ‚Äúnot very nice‚Äù libraries that hold important business logic inside custom view, and the re-creation of these views within each new activation is a bad decision, because  I want to have one set of data. </p><br><p><img src="https://habrastorage.org/webt/zs/-e/zk/zs-ezkaoyfadfd-xmrh-fhbm0pa.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/_r/yz/ie/_ryzienmkhodnc2lqx8mqiouj44.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/lz/y1/6g/lzy16g4ls7spgu9jqs8dqbpiaaa.jpeg" width="200" height="350"></p><br><p>  <strong>Decision</strong> </p><br><p>  Nothing prevents to create a view with the Application context.  It will simply apply default styles that are not related to any activations.  You can also move this view between different activations without any problems, but you need to make sure that it is added only to one parent. </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addViewInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, LayoutParams params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> preventRequestLayout)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child.getParent() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"The specified child already has a parent. "</span></span> + <span class="hljs-string"><span class="hljs-string">"You must call removeView() on the child's parent first."</span></span>); } ... }</code> </pre> <br><p>  You can, for example, subscribe to ActivityLifecycleCallbacks, delete onStop (removeView) from the current activation, add onStart to the next one opened (addView). </p><br><p>  <strong>3.</strong> Fragment can be added via add and replace.  And what is the difference between these two options in terms of the order of calling life-cycle methods?  What are the advantages of each of them? </p><br><p>  <strong>Decision</strong> </p><br><p>  Even if you add a fragment through replace, this does not mean that it is completely replaced.  This means that at this place in the container, I twist it with a twist, therefore, the current fragment will be called onDestroyView, and on returning back, onCreateView will be called again. </p><br><br><p>  This is quite a change in the rules of the game.  It is necessary to control all controllers and classes related to the UI in onDestroyView.  It is necessary to clearly separate the receipt of the data needed by the fragment and the filling of the view (lists, etc.), since the filling and destruction of the view will occur much more frequently than the receipt of data (reading some data from the database). </p><br><p>  Also, there are nuances with state recovery: for example, onSaveInstanceState sometimes comes after onDestroyView.  In addition, it should be borne in mind that if null came to onViewStateRestored, this means that there is no need to restore anything, and not to be reset to the default state. </p><br><p>  If we talk about convenience between add and replace, then replace is more economical from memory if you have deep navigation (we have user depth of navigation - one of the product KPIs).  It is also much more convenient with replace to manage the toolbar, since in onCreateView you can reinfluit it.  One of the advantages of add: fewer problems with the life cycle, when you go back, I do not recreate the view and you do not need to re-fill anything. </p><br><p>  <strong>4.</strong> Sometimes you still have to work directly with services and even with bind services.  An activity interacts with one of these services (only one activity).  It connects to the service and sends data to it.  When you rotate the screen, our activism collapses, and we must ottanditsya from this service.  But if there is not a single connection, then the service collapses, and after turning the bind will be to a completely different service.  How to make the service live when turning? </p><br><p>  <strong>Decision</strong> </p><br><p>  If you know a beautiful solution, then write in the comments.  Only something like this comes to mind: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); ThreadsUtils.postOnUiThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ unbindService(mConnection); } }); }</code> </pre> <br><p>  <strong>5.</strong> Recently we redesigned navigation within our application to Single Activity (using one of the available libraries).  Previously, each application screen was a separate activation, now navigation works on fragments.  The problem of returning to activation in the middle of the stack was solved by intent flags.  How can I go back to the fragment in the middle of the stack? </p><br><p>  <strong>Decision</strong> </p><br><p>  Yes, the solution out of the box FragmentManager does not provide.  Cicerone does something like this inside: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BackTo command)</span></span></span><span class="hljs-function"> </span></span>{ String key = command.getScreenKey(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { backToRoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = localStackCopy.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = localStackCopy.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size - index; i++) { localStackCopy.pop(); } fragmentManager.popBackStack(key, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { backToUnexisting(command.getScreenKey()); } } }</code> </pre> <br><p>  <strong>6.</strong> Also recently we got rid of such an inefficient and complex component as ViewPager, because the logic of interaction with it is very complex, and the behavior of the fragments is unpredictable in certain cases.  In some fragments we used inner fragments.  What happens when fragments are used inside RecycleView items? </p><br><p>  <strong>Decision</strong> </p><br><p>  In general, there will be nothing bad.  The fragment will be added without problems and will be displayed.  The only thing we have encountered is inconsistencies with its life cycle.  The implementation on the ViewPager controls the life cycle of the fragments via setUserVisibleHint, and RecycleView does everything head-on without thinking about the actual visibility and accessibility of the fragments. </p><br><p>  <strong>7.</strong> All the same reason for the transition from the ViewPager, we are faced with the problem of restoring the state.  In the case of fragments, this was implemented by the framework: in the right places, we simply redefined onSaveInstanceState and saved all the necessary data in the Bundle.  When the ViewPager was recreated, all the fragments were restored by the FragmentManager and returned to their state.  What to do with RecycleView and its ViewHolder? </p><br><p>  <strong>Decision</strong> </p><br><p>  ‚ÄúWe need to write everything into the database and read from it every time,‚Äù you will say.  Or the state preservation logic should be outside, and the list is just a display.  In an ideal world, it is.  But in our case, each element of the list is a complex screen with its own logic.  Therefore, I had to invent my bike in the style of ‚Äúlet's make the same logic as in the ViewPager and fragment‚Äù: </p><br><div class="spoiler">  <b class="spoiler_title">Adapter</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecycleViewGalleryAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclerView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Adapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryItemViewHolder</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String RV_STATE_KEY = <span class="hljs-string"><span class="hljs-string">"RV_STATE"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bundle mSavedState; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder.isAttached()) { holder.detach(); } holder.attach(createArgs(position, getItemViewType(position))); restoreItemState(holder); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Bundle adapterState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); saveItemsState(adapterState); bundle.putBundle(RV_STATE_KEY, adapterState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bundle == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mSavedState = bundle.getBundle(RV_STATE_KEY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mSavedState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } String stateKey = String.valueOf(holder.getGalleryItemId()); Bundle state = mSavedState.getBundle(stateKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mSavedState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } holder.restoreState(state); mSavedState.remove(stateKey); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemsState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ GalleryItemHolder holder = getCurrentGalleryViewItem(); saveItemState(outState, (GalleryItemViewHolder) holder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle, GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Bundle itemState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); holder.saveState(itemState); bundle.putBundle(String.valueOf(holder.getGalleryItemId()), itemState); } }</code> </pre> </div></div><br><p>  On Fragment.onSaveInstanceState, we read the state of the holders we need and put them in the Bundle.  When recreating the holders, we retrieve the saved Bundle and on onBindViewHolder we transfer the found states to the inside of the holders: </p><br><p>  <strong>8.</strong> How does this threaten us? </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity); ViewGroup root = findViewById(R.id.default_id); ViewGroup view1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view1.setId(R.id.default_id); root.addView(view1); ViewGroup view2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view2.setId(R.id.default_id); view1.addView(view2); ViewGroup view3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RelativeLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view3.setId(R.id.default_id); view2.addView(view3); }</code> </pre> <br><p>  <strong>Decision</strong> </p><br><p>  In fact, there is nothing wrong with that.  In the same RecycleView lists of elements with the same id are stored.  However, there is still a small nuance: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends View&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findViewTraversal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@IdRes </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == mID) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View[] where = mChildren; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = mChildrenCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { View v = where[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { v = v.findViewById(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) v; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  It is worth being careful if we have elements with the same id in the hierarchy, since  the first found element is always returned, and at different levels of the call to findViewById it can be different objects. </p><br><p>  <strong>9.</strong> You fall from TooLargeTransaction when you rotate the screen (yes, our ViewPager is still indirectly to blame).  How to find the culprit? </p><br><p>  <strong>Decision</strong> </p><br><p>  It's pretty simple: hang ActivityLifecycleCallbacks on Application, catch everything onActivitySaveInstanceState and parse everything inside the Bundle.  You can also get the status of all the views and all the fragments inside this activit. </p><br><p>  Below is an example of how we get the state of fragments from the Bundle: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Tries to find saved [FragmentState] in bundle using 'android:support:fragments' key. */</span></span> fun Bundle.getFragmentsStateList(): List&lt;FragmentBundle&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val fragmentManagerState: FragmentManagerState? = getParcelable(<span class="hljs-string"><span class="hljs-string">"android:support:fragments"</span></span>) val active = fragmentManagerState?.mActive ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active.filter { it.mSavedFragmentState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }.map { fragmentState -&gt; FragmentBundle(fragmentState.mClassName, fragmentState.mSavedFragmentState) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Assert.fail(throwable) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ application.registerActivityLifecycleCallbacks(object : SimpleActivityLifecycleCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivitySaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle?)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivitySaveInstanceState(activity, outState) outState?.let { ThreadsUtils.runOnMainThread { trackActivitySaveState(activity, outState) } } } }) } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackActivitySaveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle)</span></span></span><span class="hljs-function"> </span></span>{ val sizeInBytes = outState.getSizeInBytes() val fragmentsInfos = outState.getFragmentsStateList() ?.map { mapFragmentsSaveInstanceSaveInfo(it) } ... }</code> </pre> <br><p>  Next, we simply calculate the size of the Bundle and log it: </p><br><pre> <code class="java hljs"> fun Bundle.getSizeInBytes(): Int { val parcel = Parcel.obtain() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parcel.writeValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) parcel.dataSize() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { parcel.recycle() } }</code> </pre><br><p>  <strong>10.</strong> Suppose we have an activity and a set of dependencies on it.  Under certain conditions, we need to recreate a set of these dependencies (for example, on a click, run some experiment with another UI).  How do we do this? </p><br><p>  <strong>Decision</strong> </p><br><p>  Of course, you can tinker with the flags and make it some kind of ‚Äúcrutch‚Äù restart of the activation through the launch of the intent.  But in fact, everything is very simple - activity has a method to recreate. </p><br><p>  Most likely, a large part of this knowledge will not be useful to you, since you do not come to each of them from a good life.  However, some of them demonstrate well how a person can reason and propose his own solutions.  We use similar questions in interviews.  If you have interesting tasks that you were offered to solve at interviews, or you put them yourself, write them in the comments - it will be interesting to discuss! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426215/">https://habr.com/ru/post/426215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426205/index.html">With the release of Chrome 70 thousand sites protected by Symantec certificates will become untrusted</a></li>
<li><a href="../426207/index.html">Soon it will be cold: we get acquainted with the Pekatherm company and choose heated gloves</a></li>
<li><a href="../426209/index.html">PeerTube 1.0: video hosting without a data center and capital expenditures</a></li>
<li><a href="../426211/index.html">Go vs Javascript. What to write IoT projects</a></li>
<li><a href="../426213/index.html">A group of petrol station employees who, using software and electronics, corrected and organized 5% under-filling at petrol stations were detained</a></li>
<li><a href="../426217/index.html">How is the security of your Windows operating system organized?</a></li>
<li><a href="../426223/index.html">Android development and problem solving related to development</a></li>
<li><a href="../426227/index.html">How to farm Kaggle</a></li>
<li><a href="../426229/index.html">Code of Conduct: why Linux kernel developers threatened to delete their code - we understand the conflict</a></li>
<li><a href="../426231/index.html">Britain wants to regulate the Internet - what will affect the new laws</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>