<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Maximum flow minimum cost</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The transport problem (classical) is the problem of the optimal plan for the transport of goods from warehouses to consumption points in vehicles. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Maximum flow minimum cost</h1><div class="post__text post__text-html js-mediator-article"><img src="http://img41.imageshack.us/img41/9461/pic1truck.jpg" align="left">  <strong>The transport problem (classical)</strong> is the problem of the optimal plan for the transport of goods from warehouses to consumption points in vehicles. <br><br>  For a classical transport problem, two types of tasks are distinguished: the cost criterion (achieving a minimum of transportation costs) or distances and the time criterion (a minimum of time is spent on transportation). <br><br>  There <strong>is a</strong> lot of text under the cut, because  It tells one of the options for solving this problem ‚Äúin pictures‚Äù for those who have little knowledge of <strong>graphs</strong> .  Listing attached. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  On Habr√© somehow slipped an article where the question was raised, and whether the article about the basic algorithms.  I decided to respond to the requests and tell a little about the algorithms on the graphs and their practical application.  I did not know what level of knowledge to rely on, so I chose one relatively complex and theoretically practical algorithm, so that the article was at least partially applied.  At the same time I will try to tell you what is available even for those who are not particularly familiar with graphs. <br><br><img src="http://img41.imageshack.us/img41/8052/pic2map.jpg" align="left">  <strong>Problem (fairy tale):</strong> You are the owner of a factory producing the ‚ÄúProduct‚Äù, and recently you were lucky enough to conclude a contract with a large firm located in another city for the supply of goods to their retail network.  Since it is very far away (in Vladivostok), goods will have to be delivered by air.  During telephone conversations, the Partner asked, ‚Äú <em>but how much supply can we expect per day?</em>  ".  You thought ... You have your own trucks (truckers) engaged in transportation.  The airport is far away.  After reviewing the accumulated traffic statistics, you found out that there are some limitations in transportation in your own area: there are cargo inspection points, weight control points on the roads, and some roads are being repaired.  All this is called the " <em>bandwidth</em> " of the roads per day.  Based on these conditions, you need to know: how many boxes of ‚ÄúGoods‚Äù per day can you bring to the airport?  At the same time, you want to effectively conduct business and deliver the goods by the shortest routes, because  This is the wear of tires, mechanisms, depreciation costs in general. <br><br>  <strong>Total:</strong> how many boxes can you transport to the airport per day, taking into account the capacity of the roads, while keeping the total distance of the routes to be minimal? <br><br>  Task - the most that neither is on the graphs.  The solution will be built gradually. <br>  <em>There are no big problems, there are just a lot of little problems.</em>  (with) <br><br>  Algorithms will, if I may say so, <em>tell</em> , because  Online plenty of their descriptions. <br><br><h3>  Basic concepts.  Graph?  Baron? </h3><br>  The road map in our case is represented as a graph.  The vertices are intersections, and the edges of the graph are roads.  Ribs (roads) are attributed to their characteristics: the distance (to the next intersection), as well as throughput per day. <br><br>  In code, graphs are either in the form of adjacency lists or adjacency matrices.  For simplicity, we will use the adjacency matrix.  If in the <strong>adjacency matrix</strong> at the intersection of <font color="black">[u]</font> and <font color="black">[v]</font> vertices is ‚Äú1‚Äù, it means that these vertices (intersections) are connected by an edge (road).  It is not necessary to designate exactly ‚Äú1‚Äù; in a matrix it is very convenient to store other useful information attributed to an edge: for example, distance, and throughput (in a similar matrix). <br><br><div style="text-align:center;"><img src="http://img41.imageshack.us/img41/4760/pic3matrix.jpg"></div><br><br>  The figure shows a matrix that is symmetric about the main diagonal, i.e.  <font color="black">M [u] [v] = M [v] [u]</font> .  This means that we are given an <strong>undirected graph</strong> and we can pass along the edge in any direction (back and forth).  If in the matrix <font color="black">M [u] [v] = 1</font> , and in the opposite direction <font color="black">M [u] [v] = 0</font> , then the graph is <strong>directed</strong> and you can go along the edge only from the vertex <font color="black">[u]</font> to <font color="black">[v]</font> . <br><br>  The capacity of the roads we will be written in the matrix <font color="black">C [..] [..]</font> , which generally speaking, is a directed graph.  After all, the roads we need in order to drive from the "plant" in the direction of the "airport".  A directed graph with given capacities (plant and airport) is called a <em>network</em> . <br><br>  When for a graph it is necessary to calculate a certain characteristic, but not massively "from all-to-all", but let's say the distance from one vertex to the others, then it is much more convenient to use an array (less memory).  Those.  let's say in <font color="black">[u] the</font> cell of the <font color="black">dist [..]</font> array we will store the distance to <font color="black">[u] of the</font> vertex from the ‚Äúplant‚Äù.  Similarly, we will use arrays when traversing the graph in order to mark already visited vertices ( <font color="black">mark</font> ), record how many boxes were brought ( <font color="black">push</font> ), and from where we arrived at the vertex ( <font color="black">pred</font> ). <br><br>  <em>OK.</em>  Fine.  We know how to convert our map into a graph.  And how will we deliver the boxes to the airport?  We need to be able to find a way from the ‚Äúfactory‚Äù to the ‚Äúairport‚Äù.  For this we will use ... <br><br><h3>  Bread first search algorithm, BFS. </h3><br>  <strong>For now, we only consider: the</strong> adjacency (neighborhood) of the vertices of the graph, without considering the capacities and distances. <br><br>  <a title="Bfs" href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">BFS</a> is one of the most basic algorithms that form the basis of many others. <br>  A simple description (the figure will be below).  We are now standing at some starting (plant) top <font color="black">[s]</font> , from which only adjacent peaks are visible along the edges.  And we really need to get to the top <font color="black">[t]</font> , which is somewhere in this graph, as soon as possible.  Next we do this.  We look through the edges (namely, free roads) of our top of neighbors: are there <font color="black">[t]</font> among them?  If not, then we record all (first discovered) neighbors in the queue ‚Äúyou need to go there‚Äù.  When we looked through all the neighbors - we mark our peak - ‚Äúwe have already been here‚Äù.  We get the first unvisited top from the queue and go to it. <br><br>  We continue the search in the same way.  At the same time, those vertices that we once visited were ignored (not one step back).  If on the way you met <font color="black">[t]</font> - excellent, the goal is achieved! <br><br>  In order not to drive into the same intersections several times, we will mark them in the <font color="black">mark</font> array <font color="black">[..]</font> .  After inspecting the neighbors from <font color="black">[u]</font> tops, we put a mark <font color="black">mark [u] = 1</font> - it means that we ‚Äúhave already visited‚Äù at the <font color="black">[u]</font> -th intersection. <br><br>  <em>In the picture: at the vertices - ordinal numbers are written</em> <br><br><div style="text-align:center;"><img src="http://img81.imageshack.us/img81/8700/pic4bfs.jpg"></div><br><br>  After the completion of the algorithm, we obtain the following picture: <br><br><div style="text-align:center;"><img src="http://img81.imageshack.us/img81/5031/pic5radial.jpg"></div><br><br>  We note the main features: <ul><li>  we get to each vertex exactly (no more than) once </li><li>  put the vertices in the queue when they are first viewed </li><li>  from our plant, we radially (wave) find the remaining vertices in the graph </li><li>  "Radius of inspection" is constantly increasing </li><li>  when we find the "airport", then the number of edges (roads) between the "plant" and the "airport" will be minimal.  So  we will find the ‚Äúairport‚Äù as soon as possible. </li><li>  We look only on free roads, on which it is possible to transport boxes! </li><li>  <em>Ehhh ... as long as we do not take into account the real distance (mileage).</em> </li></ul><br>  Now we know how to find the way to transport our ‚ÄúGoods‚Äù boxes to the airport.  Well ... Let's take them on the road, and mark it on the map.  This mark - ‚Äúhow many boxes, on what road (edge) and in which direction we carry‚Äù we will call ‚Äú <strong>stream</strong> ‚Äù.  We will mark this in the matrix ( <font color="black">flow</font> ) <font color="black">F [..] [..]</font> .  Those.  on the way from <font color="black">[u]</font> to <font color="black">[v]</font> we carry <font color="black">F [u] [v]</font> boxes. <br><br>  <em>It's time to face the reality</em> - you have to reckon with the ‚Äúthroughput‚Äù, which is denoted by the matrix ( <font color="black">capacity</font> ) <font color="black">C [..] [..]</font> .  After all, on the way from <font color="black">[u]</font> to <font color="black">[v]</font> we can take no more than <font color="black">C [u] [v]</font> boxes.  That's a pity. <br><br><img src="http://img81.imageshack.us/img81/5426/pic6pred.jpg" align="left">  We arrived farsightedly.  While we were looking for ‚Äúairport‚Äù with BFS, while we noted ‚Äúvisited peaks‚Äù we also noted from which intersection we arrived - we recorded it in the <font color="black">pred</font> array <font color="black">[..]</font> .  Those.  we reached the vertex <font color="black">[v]</font> from the vertex <font color="black">pred [v]</font> .  And just in advance they added another useful array: <font color="black">push [v]</font> , i.e.  how much we could ‚Äúpush‚Äù the boxes into the intersection <font color="black">[v]</font> along some road <font color="black">[u] - [v]</font> . <br>  And kept it up to date: <font color="black">push [v] = min (push [u], C [u] [v] -F [u] [v]);</font> <br><br>  Due to this, until we have to ‚Äúunwind‚Äù the trajectory from the ‚Äúairport‚Äù to the ‚Äúplant‚Äù once more in the reverse order, in order to calculate how many boxes we can carry out along this route. <br><br>  <font color="black">Push [v] = push ["airport"] = flow</font> = here!  how many boxes were taken to the airport by the path found.  Once we unwind the route and along all edges (roads), and add ‚Äúflow‚Äù <font color="black">flow</font> to all edges of the path. <br><br>  But, even though the task deals with the natural quantities: the number of boxes, throughput and distances, you may still have to face a ‚Äú <em>minus</em> ‚Äù ... <br><br><h3>  Increase Flow (or Ford-Fulkerson Algorithm) </h3><br>  <strong>Now we take into account: the</strong> adjacency (neighborhood) of the vertices of the graph, the directed capacities of the edges, but we are not considering the distances yet. <br><br>  When we increase the flow (of the boxes) from the top <font color="black">[u]</font> to the top <font color="black">[v]</font> , we naturally perform the operation: <font color="black">F [u] [v] + = flow</font> , but in the opposite direction we reduce the flow <font color="black">F [v] [u] - = flow</font> ;  That's why.  Such a situation is possible: <br><br>  <em>In the picture: on edges ‚Äî signed (flow / throughput)</em> <br><br><div style="text-align:center;"><img src="http://img81.imageshack.us/img81/4856/pic7minus.jpg"></div><br><br>  For the first time, having carried the stream to 3 boxes to the vertex <font color="black">[i]</font> and found the edge <font color="black">[i] - [j]</font> : We moved <font color="black">min (push [i], C [i] [j] - F [i] [j]) = min (3, 3-0) = 3</font> boxes, and marked it as <font color="black">F [i] [j] + = 3</font> , and in the opposite direction we set: <font color="black">F [j] [i] - = 3</font> . <br><br>  The second time, being at the vertex <font color="black">[j]</font> , we are trying to push <font color="black">min (push [j], C [j] [i] -F [j] [i]) = min (6, 0 - (- 3)) = min (6, 3) = 3</font> to the vertex <font color="black">[i]</font> .  Against the flow of <font color="black">+3</font> , we pushed <font color="black">-3</font> boxes and received a compensation flow on this road.  But in the direction to the ‚Äúairport‚Äù in the next iteration, we additionally sent the remaining 3 boxes. <br><br>  Interpretation: from the warehouse <font color="black">[j]</font> we called the warehouse <font color="black">[i]</font> , and said: ‚ÄúLeave yourself your 3 drawers - find another use for them, we brought our 3 instead‚Äù.  Although the algorithm itself has kindly found their use. <br><br><h4>  We continue to look for the stream: </h4><br>  We agreed to persistently continue to look for ways to the "airport", while we succeed, and carry boxes through them.  Roughly speaking, this is called the <strong>maximum</strong> flow search algorithm, or the <a title="Ford-Fulkerson algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25A4%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0_%25E2%2580%2594_%25D0%25A4%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B5%25D1%2580%25D1%2581%25D0%25BE%25D0%25BD%25D0%25B0">Ford-Fulkerson algorithm</a> .  And since we use BFS to ‚Äúdiscover‚Äù new delivery routes, this is called the <a title="Edmonds-Karp algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25AD%25D0%25B4%25D0%25BC%25D0%25BE%25D0%25BD%25D0%25B4%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BF%25D0%25B0">Edmonds-Karp</a> algorithm. <br><br>  When we ‚Äúfill‚Äù the roads with the transportation of our boxes to the stop, we will answer the Partner with the question ‚ÄúHow many boxes per day can we take to the airport?‚Äù.  But it's time to think about their own depreciation costs ... Tires, gasoline, wear ... <br><br>  It has already become clear that when searching by BFS for a graph, we will have to deal with negative values, such as reverse flow (and it has consequences in ‚Äúfinancial terms‚Äù), even if we are talking about distances.  In general, it‚Äôs time to take into account additionally the distances ... <br><br><h3>  Distances  Hit the road, Jack! </h3><br>  <strong>It is time to finish this task entirely:</strong> adjacency (neighborhood) of the graph vertices, directed edge carrying capacities, distances. <br><br>  We continue to run BFS until we load the roads with our drawers ‚Äúall the way‚Äù: <br><br><div style="text-align:center;"><img src="http://img81.imageshack.us/img81/9146/pic8until.jpg"></div><br><br>  Now look at what happened.  We will check from the ‚Äúairport‚Äù: if a box reached us at a distance of 15 km, then if we refused, then we would save 15 km.  directions (ie, subtract 15), but if possible, try to find (attach) him another way of movement. <br><br>  Let's try to walk along the edges in direct (on free roads) and back (pushing back and saving) directions from the ‚Äúairport‚Äù: <br><br>  <em>In the picture: on the edges - signed (flow / throughput), and above - the distance</em> <br><br><div style="text-align:center;"><img src="http://img81.imageshack.us/img81/9968/pic9pushback.jpg"></div><br><br>  In the picture above, we found a ‚Äúnegative cycle‚Äù -6, still walking along accessible (free or pushing against the flow) ribs.  By making one revolution in it, we can reduce the distance for the vertices participating in it by -6.  This means that you can save on the delivery of crates transported in a cycle.  Just letting the boxes "on the cycle."  In the picture above, we will save 6 km.  of the way. <br><br>  Now we know how to solve the problem, but in order to detect these cycles ... Consider: <br><br><h3>  Bellman-Ford Algorithm </h3><br><img src="http://img269.imageshack.us/img269/1959/pic10dist.jpg" align="left">  <a title="Bellman-Ford Algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0-%25D0%25A4%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0">It</a> is used to find the shortest distance from the vertex <font color="black">[s]</font> to the other vertices.  But unlike BFS, the short path will not be in the sense of the number of edges of the graph on this path, but in the sense of the summed ‚Äúdistance‚Äù along the edges of the path. <br><br>  But we will need it not for this.  One of its key features that distinguishes it from <a title="Dijkstra's Algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra‚Äôs algorithm</a> is that it is capable of working on graphs, where the weight of the edges can be given by a negative number.  The algorithm can detect a side effect of such graphs ‚Äî negative-value cycles.  What we need! <br><br>  The algorithm is somewhat more complicated.  This implementation somewhat does not correlate with Cormen‚Äôs bible, but it also works fine.  It looks a bit like BFS, so I will try to explain, starting from it. <br><br>  Starting from a certain vertex, we scan adjacent vertices along the ‚Äúaccessible‚Äù edges, and try to improve the distance to them in the <font color="black">dist [..]</font> array and make it as small as possible.  This process is called ‚Äúrelaxation.‚Äù  If we ‚Äúfelt‚Äù (along the edges) such vertices, then we update them with the distances and put their vertices into the queue ‚Äútry to improve the graph from them‚Äù.  Very similar to BFS!  But we do not mark the vertices (‚Äúalready visited‚Äù) and if we have to go to the same vertex twice, we will do it. <br><br>  But the question is, are we ready for the fact that there will be ‚Äúnegative cycles‚Äù that you can always spin on, reducing the distance to the vertices?  The process will not end.  Therefore, the "inspection radius" of the vertices is limited by the number <font color="black">N</font> (the number of the vertices themselves).  This will be guaranteed enough to calculate the minimum distance to any vertex, and most importantly the algorithm will end in any case. <br><br>  To do this, we place the first vertex in the queue, and after it the ‚Äústub‚Äù, thus denoting that there are vertices in the queue in the ‚Äúinspection radius 0‚Äù.  When, taking out the next peak from the queue, we suddenly reach our ‚Äústub‚Äù - we will install a new one, denoting the next ‚Äúinspection radius‚Äù.  Here, in general, and all the logic of the algorithm.  =) <br><br>  The improvement of the distance to the vertices is verified by the following inequality: <br>  <font color="black">dist [v]&gt; dist [u] + edge_cost (u, v)</font> <br><br>  <em>In the picture: length on edges, and the shortest distance found at the moment in the tooltip.</em> <br><br><div style="text-align:center;"><img src="http://img269.imageshack.us/img269/6826/pic11bf.jpg"></div><br><br>  Note the main features (as opposed to BFS): <ul><li>  we can reach the top several times if the distance to it has been improved.  Going later to this peak, we will try to improve the distance already from it </li><li>  vertices are placed in a queue, to which the distance has been improved </li><li>  we radially (wavy) from our plant over distances (and not along edges) we find the remaining vertices </li><li>  We will look only on <strong>free</strong> roads, on which it is possible to transport (or push back) boxes.  Therefore, given the distances and throughput </li></ul><br>  Viewing the graph in "radius N (number of vertices)" ensures that for all vertices we have found the minimum distance.  And nothing else to reduce.  And if some of the vertices are ‚Äúdrawn‚Äù into a ‚Äúnegative cycle‚Äù, then it can be easily detected by checking for violation of equality.  Indeed, in a cycle, the distances infinitely decrease: <br>  <font color="black">dist [v]&gt; dist [u] + edge_cost (u, v)</font> <br><br>  Therefore, if for the vertex <font color="black">[v]</font> this inequality holds, it means that it participates in the negative cycle.  What is needed!  "Unwinding" from her the way in which we got into it, we will spin along (her) cycle. <br><br>  <em>All - cycle detected!</em>  It remains only to send a stream of boxes on it to "reverse", and thereby increase the efficiency of doing business. <br><br><h3>  Algorithm Maximum Flow minimum cost: </h3><br><ul><li>  Start finding the Edmonds-Karp Maximum Flow: <ul><li>  While BFS finds its way from the ‚Äúfactory‚Äù to the ‚Äúairport‚Äù <ul><li>  we transport boxes on it </li></ul></li></ul></li><li>  So far, the Bellman-Ford algorithm finds ‚Äúnegative cycles‚Äù: <ul><li>  We turn the flow in "negative cycles" back. </li></ul></li><li>  Got maximum flow minimum cost (distance) </li></ul><br><br>  <strong>Everything.</strong>  <em>We call the Partner and let us know how many goods per day we will be able to deliver to him.</em>  <em>And we think how to apply the money saved.</em>  =) <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> C[MAX_N][MAX_N]; <font color="#008000">//  " "</font> <br> <font color="#0000ff">int</font> F[MAX_N][MAX_N]; <font color="#008000">//  "   "</font> <br> <font color="#0000ff">int</font> P[MAX_N][MAX_N]; <font color="#008000">//  " ()"</font> <br> <font color="#0000ff">int</font> push[MAX_N]; <font color="#008000">//    [v]   </font> <br> <font color="#0000ff">int</font> mark[MAX_N]; <font color="#008000">//   ,   </font> <br> <font color="#0000ff">int</font> pred[MAX_N]; <font color="#008000">//     [v] ()</font> <br> <font color="#0000ff">int</font> dist[MAX_N]; <font color="#008000">//    [v]   </font> <br> <font color="#0000ff">int</font> N, M, s ,t; <font color="#008000">// - , ,    </font> <br> <font color="#0000ff">int</font> max_flow; <br> <font color="#0000ff">int</font> min_cost; <br> <br> <font color="#0000ff">void</font> file_read() <br> { <br> <font color="#0000ff">int</font> u, v, c, p; <br> <font color="#0000ff">in</font> &gt;&gt; N &gt;&gt; M &gt;&gt; s &gt;&gt; t; N++; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; M; i++) <br> { <br> <font color="#0000ff">in</font> &gt;&gt; u &gt;&gt; v &gt;&gt; c &gt;&gt; p; <br> C[u][v] = c; <br> P[u][v] = p; <br> P[v][u] = -p; <br> } <br> } <br> <br> <font color="#0000ff">int</font> edge_cost( <font color="#0000ff">int</font> u, <font color="#0000ff">int</font> v) <br> { <br> <font color="#0000ff">if</font> ( C[u][v] - F[u][v] &gt; 0 ) <font color="#0000ff">return</font> P[u][v]; <br> <font color="#0000ff">else</font> <font color="#0000ff">return</font> MAX_VAL; <br> } <br> <br> <font color="#0000ff">int</font> check_cycles() <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> u = 1; u &lt; N; u++) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> v = 1; v &lt; N; v++) <br> <font color="#0000ff">if</font> ( dist[v] &gt; dist[u] + edge_cost(u, v) ) <br> <font color="#0000ff">return</font> u; <br> <br> <font color="#0000ff">return</font> MAX_VAL; <br> } <br> <br> <font color="#0000ff">void</font> init() <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 1; i &lt; N; i++) <br> { <br> mark[i] = 0; <br> push[i] = 0; <br> pred[i] = 0; <br> dist[i] = MAX_VAL; <br> } <br> } <br> <br> <font color="#008000">//    </font> <br> <br> <font color="#0000ff">int</font> bf( <font color="#0000ff">int</font> s) <br> { <br> init(); <br> queue&lt; <font color="#0000ff">int</font> &gt; Q; <br> pred[s] = s; <br> dist[s] = 0; <br> <br> Q.push(s); <br> Q.push(MAX_N); <br> <br> <font color="#0000ff">int</font> u, series = 0; <br> <font color="#0000ff">while</font> ( !Q.empty() ) <br> { <br> <font color="#0000ff">while</font> ( Q.front() == MAX_N ) <br> { <br> Q.pop(); <br> <font color="#0000ff">if</font> ( ++series &gt; N ) <font color="#0000ff">return</font> check_cycles(); <br> <font color="#0000ff">else</font> Q.push(MAX_N); <br> } <br> <br> u = Q.front(); Q.pop(); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> v = 1; v &lt; N; v++) <br> <font color="#0000ff">if</font> ( dist[v] &gt; dist[u] + edge_cost(u, v) ) <br> { <br> dist[v] = dist[u] + edge_cost(u, v); <br> pred[v] = u; <br> Q.push(v); <br> } <br> } <br> } <br> <br> <font color="#008000">//  -</font> <br> <br> <font color="#0000ff">int</font> bfs( <font color="#0000ff">int</font> s, <font color="#0000ff">int</font> t) <br> { <br> init(); <br> queue&lt; <font color="#0000ff">int</font> &gt; Q; <br> mark[s] = 1; <br> pred[s] = s; <br> push[s] = MAX_VAL; <br> <br> Q.push(s); <br> <font color="#0000ff">while</font> ( !mark[t] &amp;&amp; !Q.empty() ) <br> { <br> <font color="#0000ff">int</font> u = Q.front(); Q.pop(); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> v = 1; v &lt; N; v++) <br> <font color="#0000ff">if</font> ( !mark[v] &amp;&amp; (C[u][v]-F[u][v] &gt; 0) ) <br> { <br> push[v] = min(push[u], C[u][v]-F[u][v]); <br> mark[v] = 1; <br> pred[v] = u; <br> Q.push(v); <br> } <br> } <br> <br> <font color="#0000ff">return</font> mark[t]; <br> } <br> <br> <font color="#008000">//  -</font> <br> <br> <font color="#0000ff">void</font> max_flow_ff() <br> { <br> <font color="#0000ff">int</font> u, v, flow = 0; <br> <br> <font color="#0000ff">while</font> ( bfs(s, t) ) <br> { <br> <font color="#0000ff">int</font> add = push[t]; <br> <br> v = t; u = pred[v]; <br> <font color="#0000ff">while</font> ( v != s ) <br> { <br> F[u][v] += add; <br> F[v][u] -= add; <br> v = u; u = pred[v]; <br> } <br> flow += add; <br> } <br> <br> max_flow = flow; <br> } <br> <br> <font color="#008000">//      </font> <br> <br> <font color="#0000ff">void</font> min_cost_flow() <br> { <br> max_flow_ff(); <br> <br> <font color="#0000ff">int</font> u, v, flow = 0; <br> <font color="#0000ff">int</font> add = MAX_VAL; <br> <font color="#0000ff">int</font> neg_cycle; <br> <br> neg_cycle = bf(t); <br> <font color="#0000ff">while</font> ( neg_cycle != MAX_VAL ) <br> { <br> v = neg_cycle; u = pred[v]; <br> <font color="#0000ff">do</font> <br> { <br> add = min(add, C[u][v]-F[u][v]); <br> v = u; u = pred[v]; <br> } <br> <font color="#0000ff">while</font> ( v != neg_cycle ); <br> <br> v = neg_cycle; u = pred[v]; <br> <font color="#0000ff">do</font> <br> { <br> F[u][v] += add; <br> F[v][u] -= add; <br> v = u; u = pred[v]; <br> } <br> <font color="#0000ff">while</font> ( v != neg_cycle ); <br> <br> neg_cycle = bf(t); <br> } <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> u = 1; u &lt; N; u++) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> v = 1; v &lt; N; v++) <br> <font color="#0000ff">if</font> ( F[u][v] &gt; 0 ) <br> min_cost += F[u][v] * P[u][v]; <br> } <br> <br> <font color="#0000ff">void</font> file_write() <br> { <br> <font color="#0000ff">out</font> &lt;&lt; max_flow &lt;&lt; endl; <br> <font color="#0000ff">out</font> &lt;&lt; min_cost &lt;&lt; endl; <br> } <br> <br> <font color="#0000ff">void</font> main() <br> { <br> file_read(); <br> min_cost_flow(); <br> file_write(); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  <strong>//</strong> And if we took the following conditions: vertices - intersections of streets, edges - roads, throughput - number of lanes (allowed speed, etc.) minus the current number of cars on these roads.  Let's find the maximum flow from the street ‚ÄúA‚Äù to the street ‚ÄúB‚Äù - why are there no roads in the city currently free?  Of course, you need to take into account much more parameters, but the basis is the graphs.  It is interesting.  =) <br><br><h3>  Total </h3><br>  Do not scold me much, please <br><br>  Starting a post about the graphs, I did not know what level of competence to count on: I decided not to tell just about, say, Dijkstra, because its accessible description is very easy to find on the <a title="Algorithm List" href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D0%25BE%25D0%25B2">network</a> .  Suddenly every second person writes it by heart.  But just remember that Habra-comrades were interested in precisely the practical side of these algorithms.  Therefore, he took the ‚Äúspherical‚Äù puzzle and in its terms tried to visually tell about the graphs. <br><br>  I hope that someone will be interested to read about the graphs and an example of their use.  Moreover, writing an article made me want to remind students (schoolchildren) or graduate students teaching them programming about one of the most famous <em>ACM ICPC</em> programming competitions!  Those who have not yet decided (did not dare) in the early courses of the university assemble a team, stay up late in computer classes, discuss the asymptotics of the algorithms, come up with solutions and counter examples for them.  Algorithms are interesting and a good reason to get together, and the experience of a team game is priceless.  Join now! <br></div><p>Source: <a href="https://habr.com/ru/post/61884/">https://habr.com/ru/post/61884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../61874/index.html">Fight for pixels or how to expand your Firefox workspace</a></li>
<li><a href="../61876/index.html">Blister Opener</a></li>
<li><a href="../61877/index.html">JavaOne 2009 conference</a></li>
<li><a href="../61879/index.html">Meeting of the System Administrators 2009. PING!</a></li>
<li><a href="../61880/index.html">DIY: do-it-yourself Wi-Fi radio</a></li>
<li><a href="../61885/index.html">Order in your iTunes library</a></li>
<li><a href="../61888/index.html">Computer simulation of water sounds</a></li>
<li><a href="../61889/index.html">Opera Software: Revolution is scheduled for Tuesday</a></li>
<li><a href="../61890/index.html">Last.fm founders leave resource</a></li>
<li><a href="../61892/index.html">Seven portraits of designers and creatives</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>