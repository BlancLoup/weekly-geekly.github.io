<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Skip Lists: A Probabilistic Alternative to Balanced Trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gap lists are a data structure that can be used in place of balanced trees. Due to the fact that the balancing algorithm is probabilistic and not stri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Skip Lists: A Probabilistic Alternative to Balanced Trees</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9af/6a1/be2/9af6a1be2bec90748b66c1f21cc92801.png" alt="image"><br><br>  <i>Gap lists are a data structure that can be used in place of balanced trees.</i>  <i>Due to the fact that the balancing algorithm is probabilistic and not strict, inserting and deleting an element in the lists with gaps is much easier and much faster than in balanced trees.</i> <br><br>  Skip lists are a probabilistic alternative to balanced trees.  They are balanced using a random number generator.  Despite the fact that the lists with gaps have poor performance in the worst case, there is no such sequence of operations in which this would occur all the time (just like in the quick sort algorithm with a random selection of the reference element).  It is very unlikely that this data structure will be significantly unbalanced (for example, for a dictionary larger than 250 elements, the probability that a search will take three times more than the expected time is less than one millionth). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Balancing a data structure is probably simpler than explicitly balancing.  For many tasks, skip lists are a more natural representation of data than trees.  Algorithms are simpler to implement and, in practice, faster than balanced trees.  In addition, lists with gaps use memory very efficiently.  They can be implemented in such a way that an average of approximately 1.33 pointer (or even less) falls on one element and does not require storage for each element of additional information about the balance or priority. <br><a name="habracut"></a><br><br>  To search for an element in a linked list, we must look at each of its nodes: <br><img src="https://habrastorage.org/getpro/habr/post_images/65d/0d5/b9c/65d0d5b9c234e6739351e873c7245df0.png" alt="image"><br><br>  If the list is kept sorted and every second node additionally contains a pointer to two nodes ahead, we need to look at no more than ‚åà <i>n</i> / 2‚åâ + 1 nodes (where <i>n</i> is the length of the list): <br><img src="https://habrastorage.org/getpro/habr/post_images/52e/5e0/d5e/52e5e0d5edeaf187f27971b1b1dc0950.png" alt="image"><br><br>  Similarly, if now every fourth node contains a pointer to four nodes forward, then you need to view no more than ‚åà <i>n</i> / 4‚åâ + 2 nodes: <br><img src="https://habrastorage.org/getpro/habr/post_images/32b/452/eaf/32b452eafe4e76e92ed6818d503c7234.png" alt="image"><br><br>  If every 2 <sup><i>i-</i></sup> th node contains a pointer to 2 <sup><i>i</i></sup> nodes ahead, then the number of nodes that need to be viewed will decrease to ‚åàlog <sub>2</sub> <i>n</i> ‚åâ, and the total number of pointers in the structure will only double: <br><img src="https://habrastorage.org/getpro/habr/post_images/122/c08/a40/122c08a40c486c21626c8e613b0897f5.png" alt="image"><br><br>  This data structure can be used for quick lookups, but inserting and deleting nodes will be slow. <br><br>  We call a node containing k pointers to the front elements, a node of <i>level <i>k</i></i> .  If every 2 <sup><i>i-</i></sup> th node contains a pointer to 2 <sup><i>i</i></sup> nodes ahead, then the levels are distributed as follows: 50% of the nodes - level 1, 25% - level 2, 12.5% ‚Äã‚Äã- level 3, etc.  But what happens if the levels of nodes are chosen randomly, in the same proportions?  For example: <br><img src="https://habrastorage.org/getpro/habr/post_images/647/f6b/a62/647f6ba621f97e52a0e387da1d81cb03.png" alt="image"><br><br>  Pointer number <i>i of</i> each node will refer to the next node of level <i>i</i> or more, and not exactly 2 <sup><i>i</i> -1</sup> nodes forward, as it was before.  Insertions and deletions will require only local changes;  the level of a node chosen randomly when it is inserted will never change.  In case of unsuccessful assignment of levels, performance may turn out to be low, but we will show that such situations are rare.  Due to the fact that these data structures are connected lists with additional pointers to skip intermediate nodes, I call them <i>lists with</i> gaps. <br><br><h2>  Operations </h2><br>  We describe the algorithms for searching, inserting and deleting elements in the dictionary, implemented on lists with gaps.  The <i>search</i> operation returns a value for the specified key or signals that the key was not found.  The <i>insert</i> operation associates the key with the new value (and creates the key if it was not there before).  The <i>delete</i> operation deletes the key.  Also in this data structure, you can easily add additional operations, such as ‚Äúfinding the minimum key‚Äù or ‚Äúfinding the next key‚Äù. <br><br>  Each element of the list is a node, the level of which was chosen randomly during its creation, regardless of the number of elements that were already there.  The node of level <i>i</i> contains <i>i</i> pointers to the various elements ahead, indexed from 1 to <i>i</i> .  We may not store the node level in the node itself.  The number of levels is limited by the pre-selected constant <i>MaxLevel</i> .  Let's call the <i>list level the</i> maximum level of a node in this list (if the list is empty, then the level is 1).  <i>The title of the</i> list (in the pictures on the left) contains pointers to levels 1 through <i>MaxLevel</i> .  If there are no elements of this level yet, then the pointer value is a special element of NIL. <br><br><h4>  Initialization </h4><br>  Create an NIL element, the key of which is larger than any key that may ever appear in the list.  The NIL element will complete all lists with gaps.  The list level is 1, and all pointers from the header refer to NIL. <br><br><h4>  Item Search </h4><br>  Starting with the highest level indicator, we move forward along the indexes until they refer to an element that does not exceed the desired one.  Then we go down one level below and again move by the same rule.  If we have reached level 1 and can‚Äôt go any further, then we are just before the element we are looking for (if there is one). <br><br>  <b>Search</b> (list, searchKey) <br>  x: = list ‚Üí header <br>  <i># loop invariant: x ‚Üí key &lt;searchKey</i> <br>  <b>for</b> i: = list ‚Üí level <b>downto</b> 1 <b>do</b> <br>  <b>while</b> x ‚Üí forward [i] ‚Üí key &lt;searchKey <b>do</b> <br>  x: = x ‚Üí forward [i] <br>  <i># x ‚Üí key &lt;searchKey ‚â§ x ‚Üí forward [1] ‚Üí key</i> <br>  x: = x ‚Üí forward [1] <br>  <b>if</b> x ‚Üí key = searchKey <b>then</b> <b>return</b> x ‚Üí value <br>  <b>else</b> <b>return</b> failure <br><br><h4>  Insert and delete item </h4><br>  To insert or delete a node, use the search algorithm to find all elements before the one being inserted (or deleted), then update the corresponding pointers: <br><img src="https://habrastorage.org/getpro/habr/post_images/a7e/b73/961/a7eb73961ad803b69f614612e3ae673f.png" alt="image"><br>  <i>In this example, we inserted a level 2 element.</i> <br><br>  <b>Insert</b> (list, searchKey, newValue) <br>  <b>local</b> update [1..MaxLevel] <br>  x: = list ‚Üí header <br>  <b>for</b> i: = list ‚Üí level <b>downto</b> 1 <b>do</b> <br>  <b>while</b> x ‚Üí forward [i] ‚Üí key &lt;searchKey <b>do</b> <br>  x: = x ‚Üí forward [i] <br>  <i># x ‚Üí key &lt;searchKey ‚â§ x ‚Üí forward [i] ‚Üí key</i> <br>  update [i]: = x <br>  x: = x ‚Üí forward [1] <br>  <b>if</b> x ‚Üí key = searchKey <b>then</b> x ‚Üí value: = newValue <br>  <b>else</b> <br>  lvl: = randomLevel () <br>  <b>if</b> lvl&gt; list ‚Üí level <b>then</b> <br>  <b>for</b> i: = list ‚Üí level + 1 <b>to</b> lvl <b>do</b> <br>  update [i]: = list ‚Üí header <br>  list ‚Üí level: = lvl <br>  x: = makeNode (lvl, searchKey, value) <br>  <b>for</b> i: = 1 <b>to</b> level <b>do</b> <br>  x ‚Üí forward [i]: = update [i] ‚Üí forward [i] <br>  update [i] ‚Üí forward [i]: = x <br><br>  <b>Delete</b> (list, searchKey) <br>  <b>local</b> update [1..MaxLevel] <br>  x: = list ‚Üí header <br>  <b>for</b> i: = list ‚Üí level <b>downto</b> 1 <b>do</b> <br>  <b>while</b> x ‚Üí forward [i] ‚Üí key &lt;searchKey <b>do</b> <br>  x: = x ‚Üí forward [i] <br>  update [i]: = x <br>  x: = x ‚Üí forward [1] <br>  <b>if</b> x ‚Üí key = searchKey <b>then</b> <br>  <b>for</b> i: = 1 <b>to</b> list ‚Üí level <b>do</b> <br>  <b>if</b> update [i] ‚Üí forward [i] <b>then</b> x <b>then</b> <b>break</b> <br>  update [i] ‚Üí forward [i]: = x ‚Üí forward [i] <br>  free (x) <br>  <b>while</b> list ‚Üí level&gt; 1 <b>and</b> list ‚Üí header ‚Üí forward [list ‚Üí level] = NIL <b>do</b> <br>  list ‚Üí level: = list ‚Üí level - 1 <br><br>  To memorize elements before being inserted (or deleted), the <i>update</i> array is used.  The <i>update [i]</i> element is a pointer to the rightmost node, level <i>i</i> or higher, from among those to the left of the update location. <br><br>  If a randomly selected level of the inserted node is greater than the level of the entire list (i.e. if there are no nodes with that level yet), increase the list level and initialize the corresponding elements of the <i>update</i> array with pointers to the header.  After each deletion, we check whether we deleted the node with the maximum level and, if so, reduce the list level. <br><br><h4>  Level number generation </h4><br>  Previously, we cited the distribution of node levels in the case where half of the nodes containing the level indicator <i>i</i> also contained a pointer to a node of level <i>i</i> +1.  To get rid of the magic constant 1/2, we denote by <i>p the</i> fraction of nodes of level <i>i</i> containing a pointer to nodes of level <i>i</i> + i.  The level number for the new vertex is generated randomly according to the following algorithm: <br><br>  <b>randomLevel</b> () <br>  lvl: = 1 <br>  <i># random () returns a random number in the half-interval [0 ... 1)</i> <br>  <b>while</b> random () &lt;p <b>and</b> lvl &lt;MaxLevel <b>do</b> <br>  lvl: = lvl + 1 <br>  <b>return</b> lvl <br><br>  As you can see, the number of elements in the list does not participate in the generation. <br><br><h4>  What level to start looking for?  Definition of <i>L (n)</i> </h4><br>  In the list with gaps of 16 elements generated at <i>p</i> = 1/2, it may turn out that it contains 9 elements of level 1, 3 elements of level 2, 3 elements of level 3 and 1 element of level 14 (this is unlikely, but possible) .  How to deal with this?  If we use the standard algorithm and search from level 14, we will do a lot of useless work. <br><br>  Where better to start the search?  Our research has shown that it is best to start the search from the <i>L</i> level, where we expect 1 / <i>p</i> nodes.  This will happen when <i>L</i> = log <sub>1 / <i>p</i></sub> <i>n</i> .  For convenience of further reasoning, we denote the function log <sub>1 / <i>p</i></sub> <i>n</i> as <i>L</i> ( <i>n</i> ). <br><br>  There are several ways to solve problems with nodes of unexpectedly large level: <br><ul><li>  <i>Do not bathe</i> (orig. Don't worry, be happy).  Just start the search from the largest level on the list.  As we will see later, the probability that the list level of <i>n</i> elements turns out to be much higher than <i>L (n)</i> is very small.  This solution adds only a small constant to the expected search time.  This approach is used in the algorithms given above. </li><li>  <i>Use less space than needed.</i>  Although an element can contain 14 pointers, we do not have to use all 14. We can use only <i>L (n)</i> of them.  There are several ways to implement this, but they all complicate the algorithm and do not lead to a noticeable increase in performance.  This method is not recommended for use. </li><li>  <i>Fix the cube.</i>  If a level is generated that is greater than the maximum node level in the list, then we simply assume that it is exactly 1 more. In theory, and it seems, in practice, this works well.  But with this approach, we completely lose the opportunity to analyze the complexity of the algorithms, since  the node level is no longer completely random.  Programmers are free to use this method, but it is better for theoreticians to avoid it. </li></ul><br><br><h4>  <i>MaxLevel</i> selection </h4><br>  Since the expected number of levels is L (n), it is best to choose <i>MaxLevel</i> = <i>L</i> ( <i>N</i> ), where <i>N</i> is the maximum number of items in the list with gaps.  For example, if <i>p</i> = 1/2, then <i>MaxLevel</i> = 16 is suitable for lists containing less than 2 <sup>16</sup> elements. <br><br><h2>  Algorithm Analysis </h2><br>  In the search, insert and delete operations, the most time is spent searching for a suitable element.  For the insertion and deletion, additional time is necessary proportional to the level of the node being inserted or removed.  The search time for an element is proportional to the number of nodes passed in the search process, which, in turn, depends on the distribution of their levels. <br><br><h4>  Probabilistic philosophy </h4><br>  The list structure with gaps is determined only by the number of elements in this list and the values ‚Äã‚Äãof the random number generator.  The sequence of operations with which the list is obtained is not important.  We assume that the user does not have access to the node levels, otherwise, he can make the algorithm work in the worst possible time by deleting all nodes whose level is different from 1. <br><br>  For sequential operations on the same data structure, their execution times are not independent random variables;  two consecutive searches for the same item will take exactly the same time. <br><br><h4>  Analysis of the expected search time </h4><br>  Consider the search path from the end, i.e.  let's move up and left.  Although the levels of nodes in the list are known and fixed at the time of the search, we assume that the node level is determined only when we met it when moving from the end. <br><br>  At any given point on the road we are in this situation: <br><img src="https://habrastorage.org/getpro/habr/post_images/9ab/a25/571/9aba25571b5c081d25903dd644c42bf4.png" alt="image"><br><br>  We look at the <i>i-</i> th pointer of the node <i>x</i> and do not know about the levels of the nodes to the left of <i>x</i> .  Also, we do not know the exact level of <i>x</i> , but it must be at least <i>i</i> .  Suppose that <i>x</i> is not a list header (this is equivalent to assuming that the list expands indefinitely to the left).  If level <i>x</i> is <i>i</i> , then we are in situation <i>b</i> .  If the level <i>x is</i> greater than <i>i</i> , then we are in a situation <i>c</i> .  The probability that we are in situation <i>c</i> is <i>p</i> .  Every time this happens, we go up one level.  Let <i>C</i> ( <i>k</i> ) be the expected length of the search return path, at which we moved up <i>k</i> times: <br>  <i>C</i> (0) = 0 <br>  <i>C</i> ( <i>k</i> ) = (1- <i>p</i> ) ( <i>path length in situation b</i> ) + <i>p</i> ( <i>path length in situation c</i> ) <br><br>  Simplify: <br>  <i>C</i> ( <i>k</i> ) = (1- <i>p</i> ) (1 + <i>C</i> ( <i>k</i> )) + <i>p</i> (1 + <i>C</i> ( <i>k</i> -1)) <br>  <i>C</i> ( <i>k</i> ) = 1 + <i>C</i> ( <i>k</i> ) - <i>p</i> ‚ãÖ <i>C</i> ( <i>k</i> ) + <i>p</i> ‚ãÖ <i>C</i> ( <i>k</i> -1) <br>  <i>C</i> ( <i>k</i> ) = 1 / <i>p</i> + <i>C</i> ( <i>k</i> - 1) <br>  <i>C</i> ( <i>k</i> ) = <i>k</i> / <i>p</i> <br><br>  Our suggestion that the list is endless is pessimistic.  When we reach the leftmost element, we simply move up all the time, not moving left.  This gives us the upper bound ( <i>L</i> ( <i>n</i> ) - 1) / <i>p of the</i> expected path length from the node with level 1 to the node with level <i>L</i> ( <i>n</i> ) in the list of <i>n</i> items. <br><br>  We use these reasonings to get to the node of level <i>L</i> ( <i>n</i> ), but other reasoning is used for the rest of the way.  The number of remaining moves to the left is limited by the number of nodes having a level of <i>L</i> ( <i>n</i> ), or higher in the entire list.  The most likely number of such nodes is 1 / <i>p</i> . <br><br>  We also move up from the <i>L</i> ( <i>n</i> ) level to the maximum level in the list.  The probability that the maximum list level is greater than <i>k</i> is 1- (1-p <sup>k</sup> ) <sup>n</sup> , which is not greater than np <sup>k</sup> .  We can calculate that the expected maximum level is not more than <i>L</i> ( <i>n</i> ) + 1 / (1- <i>p</i> ).  Putting it all together, we get that the expected length of the search path for a list of <i>n</i> items <br><br>  &lt;= <i>L</i> ( <i>n</i> ) / <i>p</i> + 1 / (1- <i>p</i> ), <br>  or <i>O</i> (log <i>n</i> ). <br><br><h4>  Number of comparisons </h4><br>  We have just calculated the length of the path traveled by the search.  The required number of comparisons per unit is greater than the length of the path (the comparison occurs at each step of the path). <br><br><h4>  Probabilistic analysis </h4><br>  We can consider the probability distribution of various search path lengths.  Probabilistic analysis is somewhat more complicated (it is at the very end of the original article).  With it, we can estimate from above the probability that the length of the search path will exceed the expected one more than by a specified number of times.  Analysis results: <br><img src="https://habrastorage.org/getpro/habr/post_images/aa4/775/a7f/aa4775a7f9d5bf7e4a112a22b80ae857.png" alt="image"><br>  <i>Here is a graph of the upper limit of the probability that the operation will take significantly longer than expected.</i>  <i>On the vertical axis, the probability is set aside that the length of the search path will be more than the expected path length by the number of times plotted on the horizontal axis.</i>  <i>For example, with p = 1/2 and n = 4096, the probability that the resulting path is three times longer than expected is less than 1/200 000 000.</i> <br><br><h4>  Choice p </h4><br>  The table shows the normalized search times and the amount of required memory for different values ‚Äã‚Äãof <i>p</i> : <br><table><tbody><tr><th>  <i>p</i> </th><th>  Normalized search time <br>  (i.e. normalized <i>L</i> ( <i>n</i> ) / <i>p</i> ) </th><th>  Average number of pointers per node <br>  (i.e. 1 / (1 - <i>p</i> )) </th></tr><tr><td>  1/2 </td><td>  one </td><td>  2 </td></tr><tr><td>  1 / e </td><td>  0.94 ... </td><td>  1.58 ... </td></tr><tr><td>  1/4 </td><td>  one </td><td>  1.33 ... </td></tr><tr><td>  1/8 </td><td>  1.33 ... </td><td>  1.14 ... </td></tr><tr><td>  1/16 </td><td>  2 </td><td>  1.07 ... </td></tr></tbody></table><br>  Decreasing <i>p</i> increases the spread of operation time.  If 1 / <i>p</i> is a power of two, then it is convenient to generate a level number from a stream of random bits (to generate on average, (log <sub>2</sub> 1 / <i>p</i> ) / (1- <i>p</i> ) random bits are required).  Since there are overheads related to <i>L</i> ( <i>n</i> ) (but not to <i>L</i> ( <i>n</i> ) / <i>p</i> ), the choice of <i>p</i> = 1/4 (instead of 1/2) slightly reduces the constant in the complexity of the algorithm.  We recommend choosing <i>p</i> = 1/4, but if the spread of the operation time is more important for you than the speed, then choose 1/2. <br><br><h4>  Multiple operations </h4><br>  The expected total time of the sequence of operations is equal to the sum of the expected times for each operation in the sequence.  Thus, the expected time for any sequence of <i>m</i> operations in the data structure of <i>n</i> elements is <i>O</i> ( <i>m</i> * log <i>n</i> ).  However, the pattern of search operations affects the distribution of the actual time of the entire sequence of operations. <br><br>  If we search for the same element in the same data structure, then both operations will take exactly the same time.  Thus, the variance (spread) of the total time will be four times the variance of a single search operation.  If the search times for two elements are independent random variables, then the variance of the total time is equal to the sum of the variances of the times of individual operations.  Finding the same element again and again maximizes variance. <br><br><h4>  Performance tests </h4><br>  Let's compare the performance of lists with gaps with other data structures.  All implementations have been optimized for maximum performance: <br><table><tbody><tr><th>  Data structure </th><th>  Search </th><th>  Insert </th><th>  Deletion </th></tr><tr><td>  lists with gaps </td><td>  0.051 ms (1.0) </td><td>  0.065 ms (1.0) </td><td>  0.059 ms (1.0) </td></tr><tr><td>  non-recursive AVL trees </td><td>  0.046 ms (0.91) </td><td>  0.10 ms (1.55) </td><td>  0.085 ms (1.46) </td></tr><tr><td>  recursive 2-3 trees </td><td>  0.054 ms (1.05) </td><td>  0.21 ms (3.2) </td><td>  0.21 ms (3.65) </td></tr><tr><td>  Self-regulating trees: </td></tr><tr><td>  top-down splaying </td><td>  0.15 ms (3.0) </td><td>  0.16 ms (2.5) </td><td>  0.18 ms (3.1) </td></tr><tr><td>  bottom-up splaying </td><td>  0.49 ms (9.6) </td><td>  0.51 ms (7.8) </td><td>  0.53 ms (9.0) </td></tr></tbody></table><br>  Tests were performed on a Sun-3/60 machine and were performed on data structures containing 2 <sup>16</sup> elements.  Values ‚Äã‚Äãin brackets - time, relative to lists with gaps (in times).  For tests of insertion and deletion of elements, the time spent on managing the memory was not taken into account (for example, for C-calls of malloc and free). <br><br>  Note that lists with gaps require more comparison operations than other data structures (the algorithms given above require on average <i>L</i> ( <i>n</i> ) / <i>p</i> + 1 / (1 + <i>p</i> ) operations).  When using real numbers as keys, operations in lists with gaps turned out to be a little slower than in the non-recursive implementation of the AVL tree, and searching in lists with gaps was a little slower than searching in 2-3 trees (however, inserting and deleting in the lists with gaps were faster than in the recursive implementation of 2-3 trees).  If the comparison operations are very expensive, you can modify the algorithm so that the key you are looking for will not be compared with the key of other nodes more than once per node.  When <i>p</i> = 1/2, the upper limit of the number of comparisons is 7/2 + 3/2 * log <sub>2</sub> <i>n</i> . <br><br><h4>  Uneven distribution of requests </h4><br>  Self-regulating trees can adapt to the uneven distribution of requests.  Since lists with gaps are faster than self-regulating trees a fairly large number of times, self-regulating trees are faster only with some very uneven distribution of requests.  We could try to develop self-regulating lists with gaps, however, we did not see any practical sense in this and did not want to spoil the simplicity and performance of the original implementation.  If the application expects non-uniform queries, then using self-regulating trees or adding caching will be preferable. <br><br><h2>  Conclusion </h2><br>  From a theoretical point of view, lists with gaps are not needed.  Balanced trees can do the same operations and have a good difficulty at worst (as opposed to lists with gaps).  However, the implementation of balanced trees is a difficult task and, as a result, they are rarely implemented in practice, except as lab work in universities. <br><br>  Gap lists are a simple data structure that can be used instead of balanced trees in most cases.  Algorithms are very easy to implement, extend and modify.  Regular implementations of operations on gaps with lists are about as fast as highly optimized implementations on balanced trees and are significantly faster than ordinary, non-highly optimized implementations. </div><p>Source: <a href="https://habr.com/ru/post/230413/">https://habr.com/ru/post/230413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230401/index.html">How much can one extra space cost?</a></li>
<li><a href="../230403/index.html">Where does Linus Torvalds work: a walking place, a 3d printer and many hard drives</a></li>
<li><a href="../230405/index.html">Some interesting and useful things for web developer # 23</a></li>
<li><a href="../230407/index.html">London is now available in 3D on Google Maps</a></li>
<li><a href="../230409/index.html">The United Arab Emirates announced the creation of its own space agency and a flight to Mars in 2021</a></li>
<li><a href="../230415/index.html">Hackathon FabLab: two days and consequences. How it was</a></li>
<li><a href="../230417/index.html">Using the principles of gestalt psychology to increase the conversion of sites. Part 3: Cost Benefit Analysis</a></li>
<li><a href="../230421/index.html">Writing your autocompletions for Shell. Part 1: zsh</a></li>
<li><a href="../230425/index.html">Writing your autocompletions for Shell. Part 2: bash</a></li>
<li><a href="../230427/index.html">Indie games are like indie games only.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>