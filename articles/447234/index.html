<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write polymorphic programs with Arrow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 My name is Artem Dobrovinsky, I work in the company Finch . I propose to read the article of one of the fathers of the functional program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write polymorphic programs with Arrow</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/va/-y/jh/va-yjhqxdrghleli7gqzgt553r0.png"><br><br>  Hi, Habr! <br><br>  My name is Artem Dobrovinsky, I work in the company <a href="https://www.facebook.com/FinchMoscow/">Finch</a> .  I propose to read the article of one of the fathers of the functional programming library <a href="https://arrow-kt.io/"><code>Arrow</code></a> on how to write polymorphic programs.  Often, people who are just starting to write in a functional style do not rush to part with old habits, and in fact write a little more elegant imperativeness, with DI-containers and inheritance.  The idea of ‚Äã‚Äãreusing functions, regardless of the types they use, can push many to think in the right direction. <br><p>  Enjoy! </p><a name="habracut"></a><br><h3>  *** </h3><br><p>  What if we could write applications without thinking about the data types that will be used in runtime, but just describe how this data will be processed? </p><br><p>  Imagine that we have an application that works with the <code>Observable</code> type from the RxJava library.  This type allows us to write chains of calls and data manipulations, but in the end, won't this <code>Observable</code> just a container with additional properties? </p><br><p>  Same story with types like <code>Flowable</code> , <code>Deferred</code> (cortutina), <code>Future</code> , <code>IO</code> , and many others. </p><br><p>  Conceptually, all these types represent an operation (already done or planned for future), which supports manipulations such as casting an internal value to another type ( <code>map</code> ), using <code>flatMap</code> to create a chain of operations of a similar type, combining with other instances of the same type ( <code>zip</code> ), etc. </p><br><p>  In order to write programs based on these behaviors, while preserving the declarativeness of the description, and also to make your programs independent of specific data types like <code>Observable</code> sufficient that the data types used correspond to specific contracts, such as <code>map</code> , <code>flatMap</code> , and others. . </p><br><p>  This approach may seem strange or overly complicated, but it has interesting advantages.  First, consider a simple example, and then talk about them. </p><cut></cut><br><h3 id="kanonicheskaya-problema">  Canonical problem </h3><br><p>  Imagine that we have an application with a to-do list, and we would like to retrieve from the local cache a list of objects of type <code>Task</code> .  If they are not found in the local storage, we will try to request them over the network.  We need a single contract for both data sources so that they both can get a list of <code>Task</code> objects for the appropriate <code>User</code> object, regardless of the source: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Here, for simplicity, we return <code>Observable</code> , but it can be <code>Single</code> , <code>Maybe</code> , <code>Flowable</code> , <code>Deferred</code> ‚Äî anything suitable for achieving the goal. </p><br><p>  Add a couple of implementations of data sources, one for <code></code> and one for <code></code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val localCache: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cachedUser = localCache[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(cachedUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInLocalStorage(user)) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val internetStorage: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> networkUser = internetStorage[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (networkUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(networkUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInRemoteStorage(user)) } } }</code> </pre> <br><p>  The implementations of both data sources are almost identical.  These are simply mocked versions of these sources, which ideally fetch data from local storage or the network API.  In both cases, <code>Map&lt;User, List&lt;Task&gt;&gt;</code> is stored in memory. </p><br><p>  Because  we have two data sources, we need to somehow coordinate them.  Create a repository: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = localDS.allTasksByUser(user) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .onErrorResumeNext { _: Throwable -&gt; remoteDS.allTasksByUser(user) } }</code> </pre> <br><p>  It simply tries to load the <code>List&lt;Task&gt;</code> from the <code>LocalDataSource</code> , and if that is not found, it tries to request them from the network using the <code>RemoteDataSource</code> . </p><br><p>  Let's create a simple module to provide dependencies without using any dependency injection framework (DI): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource = LocalDataSource() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource = RemoteDataSource() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository = TaskRepository(localDataSource, remoteDataSource) }</code> </pre> <br><p>  Finally, we need a simple test that runs the entire stack of operations: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependenciesModule = Module() dependenciesModule.run { repository.allTasksByUser(user1).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user2).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user3).subscribe({ println(it) }, { println(it) }) } } }</code> </pre> <br><p>  <a href="https://gist.github.com/JorgeCastilloPrz/05793f11497e0e31f207d2a3e6522bdb">All the above code can be found on a githaba</a> . </p><br><p>  This program composes a run chain for three users, then subscribes to the resulting <code>Observable</code> . </p><br><p>  The first two <code>User</code> objects are accessible; we are lucky with that.  <code>User1</code> is available in the local <code>DataSource</code> , and <code>User2</code> is available on the remote. </p><br><p>  But there is a problem with <code>User3</code> , because it is not available in the local storage.  The program will try to download it from a remote service - but there it is not there either.  The search will fail, and we will display an error message to the console. </p><br><p>  Here is what will be displayed in the console for all three cases: </p><br><pre> <code class="plaintext hljs">&gt; [Task(value=LocalTask assigned to user1)] &gt; [Task(value=Remote Task assigned to user2)] &gt; UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  We are done with an example.  Now we will try to program this logic in the style of <code> </code> . </p><br><h3 id="abstragirovanie-tipov-dannyh">  Data type abstraction </h3><br><p>  Now the contract for the <code>DataSource</code> interface will look like this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Everything seems to be similar, but there are two important differences: </p><br><ul><li>  There was a dependence on the generic type (generic) <code>F</code> </li><li>  The type returned by the function is now <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </li></ul><br><p>  <code>Kind</code> is how Arrow encodes what is commonly called the <code>  (higher kind)</code> . <br>  Let me explain this concept with a simple example. </p><br><p>  <code>Observable&lt;A&gt;</code> has 2 parts: </p><br><ul><li>  <code>Observable</code> : container, fixed type. </li><li>  <code>A</code> : generic type argument.  An abstraction to which other types can be transferred. </li></ul><br><p>  We are used to seeing generic types like <code>A</code> as an abstraction.  But not many know that we can also abstract container types like <code>Observable</code> .  For this and there are high types. </p><br><p>  The idea is that we can have a constructor like <code>F&lt;A&gt;</code> in which both <code>F</code> and <code>A</code> can be a generic type.  This syntax is not yet supported by the Kotlin compiler ( <a href="https://github.com/Kotlin/KEEP/pull/87">still?</a> ), So we mimic it with a similar approach. </p><br><p>  Arrow supports this by using the <code>Kind&lt;F, A&gt;</code> intermediate meta interface, which holds references to both types, and also generates converters in both directions during compilation so that you can follow the path from <code>Kind&lt;Observable, List&lt;Task&gt;&gt;</code> to <code>Observable&lt;List&lt;Task&gt;&gt;</code> and vice versa.  Not an ideal solution, but working. </p><br><p>  Therefore, we will again look at the interface of our repository: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  The <code>DataSource</code> function returns a high type: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  It is translated to <code>F&lt;List&lt;Task&gt;&gt;</code> , where <code>F</code> remains generic. </p><br><p>  We fix only the <code>List&lt;Task&gt;</code> in the signature.  In other words, we don‚Äôt care what type <code>F</code> container is used as long as it contains <code>List&lt;Task&gt;</code> .  We can pass different data containers to a function.  Already clearer?  Go ahead. </p><br><p>  Let's take a look at the <code>DataSource</code> implemented in this way, but this time for each separately.  First local: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  A lot of new things have been added, we will analyze everything step by step. </p><br><p>  This <code>DataSource</code> saves the generic type <code>F</code> because it implements the <code>DataSource&lt;F&gt;</code> .  We want to keep the possibility of transmission of this type from the outside. </p><br><p>  Now, let's forget about the possibly unfamiliar <code>ApplicativeError</code> in the constructor and focus on the <code>allTasksByUser()</code> function.  And we will come back to <code>ApplicativeError</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } )</code> </pre> <br><p>  It is seen that it returns <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  We still don‚Äôt care what the container <code>F</code> as long as it contains <code>List&lt;Task&gt;</code> . </p><br><p>  But there is a problem.  Depending on whether we can find a list of <code>Task</code> objects for the desired user in the local storage or not, we want to report an error ( <code>Task</code> not found) or return <code>Task</code> already wrapped in <code>F</code> ( <code>Task</code> found). </p><br><p>  And for both cases we need to return: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </p><br><p>  In other words: there is a type about which we know nothing ( <code>F</code> ), and we need a way to return an error wrapped in this type.  Plus, we need a way to create an instance of this type, in which the value obtained after the successful completion of the function will be wrapped.  Sounds like something impossible? </p><br><p>  Let's return to the class declaration and note that the <code>ApplicativeError</code> is passed to the constructor and then used as a delegate for the class ( <code>by A</code> ). </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  <a href="https://arrow-kt.io/docs/arrow/typeclasses/applicativeerror/"><code>ApplicativeError</code></a> inherited from <code>Applicative</code> ; they are both type classes. </p><br><p>  Type classes define behaviors (contracts).  They are encoded as interfaces that work with arguments as generic types, as in <a href="https://arrow-kt.io/docs/arrow/typeclasses/monad/"><code>Monad&lt;F&gt;</code></a> , <a href="https://arrow-kt.io/docs/arrow/typeclasses/functor/"><code>Functor&lt;F&gt;</code></a> and many others.  This <code>F</code> is a data type.  Thus we can transfer types like <code>Either</code> , <code>Option</code> , <code>IO</code> , <code>Observable</code> , <code>Flowable</code> and many others. </p><br><p>  So back to our two problems: </p><br><ul><li>  Wrap the value obtained after successfully completing the function in <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  For this we can use a class of type <code>Applicative</code> .  Because <code>ApplicativeError</code> inherits from it, we can delegate its properties. </p><br><p>  <code>Applicative</code> simply provides the <code>just(a)</code> function.  <code>just(a)</code> wraps the value in the context of any high type.  Thus, if we have <code>Applicative&lt;F&gt;</code> , it can call <code>just(a)</code> to wrap the value in container <code>F</code> , whatever that value is.  Suppose we use <code>Observable</code> , we will have <code>Applicative&lt;Observable&gt;</code> , which knows how to wrap <code>a</code> in <code>Observable</code> , to end up with <code>Observable.just(a)</code> . </p><br><ul><li>  Wrap error in instance <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  For this we can use <code>ApplicativeError</code> .  It provides a <code>raiseError(e)</code> function that wraps the error in a container of type <code>F</code>  For an example with <code>Observable</code> , the appearance of an error will create something like <code>Observable.error&lt;A&gt;(t)</code> , where <code>t</code> is <code>Throwable</code> , since we declared our type of error as a class of type <code>ApplicativeError&lt;F, Throwable&gt;</code> . </p><br><p>  Let's look at our abstract implementation of <code>LocalDataSource&lt;F&gt;</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  The <code>Map&lt;User, List&lt;Task&gt;&gt;</code> saved in memory remains the same, but now the function does a couple of things that may be new to you: </p><br><ul><li><p>  It tries to load the <code>Task</code> list from the local cache, and since the return value may be <code>null</code> ( <code>Task</code> may not be found), we model this by using <code>Option</code> .  If it is not clear how <a href="https://arrow-kt.io/docs/arrow/core/option/ru/"><code>Option</code></a> works, then it models the presence or absence of a value that is wrapped in it. </p><br></li><li><p>  After getting the optional value, we call <code>fold</code> on top of it.  This is equivalent to using a conditional expression <code>when</code> over an optional value.  If the value is missing, <code>Option</code> wraps the error in data type <code>F</code> (the first lambda transmitted).  And if the value is present, <code>Option</code> creates an instance wrapper for the data type <code>F</code> (second lambda).  In both cases, the <code>ApplicativeError</code> properties previously mentioned are used: <code>raiseError()</code> and <code>just()</code> . </p><br></li></ul><br><p>  Thus, we abstract the implementation of data sources using classes so that they do not know which container will be used for the type <code>F</code> . </p><br><p>  The implementation of the network <code>DataSource</code> looks similar: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) : DataSource&lt;F&gt;, Async&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> internetStorage: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) } }</code> </pre> <br><p>  But there is one small difference: instead of delegating to the <code>ApplicativeError</code> instance, we use another class of the type: <a href="https://arrow-kt.io/docs/effects/async/"><code>Async</code></a> . </p><br><p>  This is due to the fact that, by their nature, network calls are asynchronous.  We want to write code that will be executed asynchronously, it is logical to use a type class designed for this. </p><br><p>  <code>Async</code> used to simulate asynchronous operations.  He can simulate any operation based on callbacks.  Note that we still do not know the specific data types, we simply describe an operation asynchronous in nature. </p><br><p>  Consider the following function: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) }</code> </pre> <br><p>  We can use the <code>async {}</code> function, which is provided to us by a class of type <code>Async</code> to simulate the operation and create an instance of type <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> which will be created asynchronously. </p><br><p>  If we used a fixed data type like <code>Observable</code> , <code>Async.async {}</code> would be equivalent to <code>Observable.create()</code> , i.e.  creating an operation that can be called from a synchronous or asynchronous code, such as <code>Thread</code> or <code>AsyncTask</code> . </p><br><p>  The <code>callback</code> parameter is used to bundle the resulting callbacks into the context of container <code>F</code> , which is a high type. </p><br><p>  Thus, our <code>RemoteDataSource</code> abstracted and depends on a still unknown type <code>F</code> container. </p><br><p>  Let's rise on level of abstraction above and once again look at our repository.  If you remember, we first need to search for the <code>Task</code> objects in the <code>LocalDataSource</code> , and only then (if they were not found locally) request them from the <code>RemoteLocalDataSource</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource&lt;F&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource&lt;F&gt;, AE: ApplicativeError&lt;F, Throwable&gt;) : ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> AE { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } } }</code> </pre> <br><p>  <code>ApplicativeError&lt;F, Throwable&gt;</code> again with us!  It also provides the <code>handleErrorWith()</code> function, which runs on top of any high-type receiver. </p><br><p>  It looks like this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> Kind</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;F, A&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">E</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Kind&lt;F, A&gt;): Kind&lt;F, A&gt;</code> </pre> <br><p>  Because  <code>localDS.allTasksByUser(user)</code> returns <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> , which can be viewed as <code>F&lt;List&lt;Task&gt;&gt;</code> , where <code>F</code> remains a generic type, we can call <code>handleErrorWith()</code> on top of it. </p><br><p>  <code>handleErrorWith()</code> allows you to respond to errors using the passed lambda.  Consider the function closer: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } }</code> </pre> <br><p>  Thus, we get the result of the first operation, except when an exception was thrown.  The exception will be handled by lambda.  If the error is of type <code>UserNotInLocalStorage</code> , we will try to find <code>Tasks</code> objects in the remote <code>DataSource</code> .  In all other cases, we wrap an unknown error in a type <code>F</code> container. </p><br><p>  The dependency rendering module remains very similar to the previous version: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource&lt;F&gt; = LocalDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource&lt;F&gt; = RemoteDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository&lt;F&gt; = TaskRepository(localDataSource, remoteDataSource, A) }</code> </pre> <br><p>  The only difference is that it is now abstract and depends on <code>F</code> , which remains polymorphic.  I deliberately did not pay attention to this in order to reduce the noise level, but <code>Async</code> inherited from <code>ApplicativeError</code> , so it can be used as its instance at all levels of program execution. </p><br><h3 id="testiruya-polimorfizm">  Testing polymorphism </h3><br><p>  Finally, our application is completely abstracted from using specific data types for containers ( <code>F</code> ) and we can focus on testing polyformism in runtime.  We will test the same piece of code passing different data types for type <code>F</code> .  The scenario is the same as when we used <code>Observable</code> . </p><br><p>  The program is written in such a way that we have completely got rid of the boundaries of abstractions and can transfer implementation details as we like. </p><br><p>  To begin with, we will try to use as a container for <code>F</code> <code>Single</code> from RxJava. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> singleModule = Module(SingleK.async()) singleModule.run { repository.allTasksByUser(user1).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().single.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Compatibility for the sake of Arrow provides wrappers for known library data types.  For example, there is a convenient wrapper <code>SingleK</code> .  These wrappers allow you to use type classes in conjunction with data types as high types. </p><br><p>  The following will be displayed on the console: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  The same result will be if you use <code>Observable</code> . </p><br><p>  Now let's work with <code>Maybe</code> , for which the <code>MaybeK</code> wrapper is <code>MaybeK</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> maybeModule = Module(MaybeK.async()) maybeModule.run { repository.allTasksByUser(user1).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().maybe.subscribe(::println, ::println) } }</code> </pre> <br><p>  The same result will be output to the console, but now using a different data type: </p><br><pre> <code class="kotlin hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  What about <code>ObservableK</code> / <code>FlowableK</code> ? <br>  Let's try: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observableModule = Module(ObservableK.async()) observableModule.run { repository.allTasksByUser(user1).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().observable.subscribe(::println, ::println) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> flowableModule = Module(FlowableK.async()) flowableModule.run { repository.allTasksByUser(user1).fix().flowable.subscribe(::println) repository.allTasksByUser(user2).fix().flowable.subscribe(::println) repository.allTasksByUser(user3).fix().flowable.subscribe(::println, ::println) } } }</code> </pre> <br><p>  See in the console: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))) [Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Everything works as expected. </p><br><p>  Let's try to use <code>DeferredK</code> , a wrapper for the type <code>kotlinx.coroutines.Deferred</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModule = Module(DeferredK.async()) deferredModule.run { runBlocking { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { println(repository.allTasksByUser(user1).fix().deferred.await()) println(repository.allTasksByUser(user2).fix().deferred.await()) println(repository.allTasksByUser(user3).fix().deferred.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: UserNotInRemoteStorage) { println(e) } } } } }</code> </pre> <br><p>  As you know, exception handling when using corutin has to be explicitly prescribed.   ,        ,        . </p><br><p>   ‚Äî   : </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Arrow   API     <code>DeferredK</code> .     <code>runBlocking</code>     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModuleAlt = Module(DeferredK.async()) deferredModuleAlt.run { println(repository.allTasksByUser(user1).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user2).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user3).fix().unsafeAttemptSync()) } } }</code> </pre> <br><p>      [ <code>Try</code> ]({{ '/docs/arrow/core/try/ru' | relative_url }}) (..,   <code>Success</code>  <code>Failure</code> ). </p><br><pre> <code class="plaintext hljs">Success(value=[Task(value=LocalTask assigned to user1)]) Success(value=[Task(value=Remote Task assigned to user2)]) Failure(exception=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> ,          ,  <code>IO</code> . <br> <a href="https://arrow-kt.io/docs/effects/io/"><code>IO</code></a> ,   in/out ,      ,       . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ioModule = Module(IO.async()) ioModule.run { println(repository.allTasksByUser(user1).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user2).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user3).fix().attempt().unsafeRunSync()) } } }</code> </pre> <br><pre> <code class="plaintext hljs">Right(b=[Task(value=LocalTask assigned to user1)]) Right(b=[Task(value=Remote Task assigned to user2)]) Left(a=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> <code>IO</code> ‚Äî  .          <a href="https://arrow-kt.io/docs/arrow/core/either/ru/"><code>Either&lt;L,R&gt;</code></a> (   ).  , ""  <code>Either</code>    ,  ""    ,    .          <code>Right(...)</code> ,  ,  <code>Left(...)</code> . </p><br><p>      . </p><br><p> ,   .   ,         ,      ,           . </p><br><p> <a href="https://gist.github.com/JorgeCastilloPrz/c0a4604b9a5dedc89be82b13cfcc1315">       </a> . </p><br><h3 id="vsyo-eto-otlichno-zvuchitno-stoit-li-ono-togo">    ‚Ä¶     ? </h3><br><p>    ,    ,      .     . </p><br><ul><li><p>       : ,      (,  ),   ‚Äî .  ,     . </p><br></li><li><p>         ,    .         .        ()   (   )  ,   . </p><br></li><li><p>      (),   ,          ().         ,         <a href="https://medium.com/%40JorgeCastilloPr/kotlin-functional-programming-does-it-make-sense-36ad07e6bacf">    </a> . </p><br></li><li><p>   ,         . ,            (      ). </p><br></li><li><p>       ,      API     .       (        <code>map</code> , <code>flatMap</code> , <code>fold</code> ,        ). ,     ,       Kotlin,  Arrow ‚Äî   . </p><br></li><li><p>          DI ( ), ..,    DI " ".         ,         ,              .        DI, ..,     ,        . </p><br></li><li><p>   ,     ,     .      , ..,    ,         . </p><br></li></ul><br><h3 id="dopolnitelno">  Additionally </h3><br><p>       ,    <a href="https://arrow-kt.io/docs/typeclasses/intro/">   </a> . <br>   ,         ,   ,      ,   . </p><br><p>   ,    .     ‚Äî   Twitter: <a href="https://www.twitter.com/JorgeCastilloPR">@JorgeCastilloPR</a> . </p><br><p>     (,  )    : </p><br><ul><li> <a href="https://medium.com/%40JorgeCastilloPr/kotlin-functional-programming-does-it-make-sense-36ad07e6bacf">Kotlin Functional Programming: Does it make sense?</a>  <a href="https://www.twitter.com/JorgeCastilloPR">Jorge Castillo</a> </li><li> <a href="https://medium.com/%40JorgeCastilloPr/kotlin-purity-and-function-memoization-b12ab35d70a5">Kotlin purity and Function Memoization</a>  <a href="https://www.twitter.com/JorgeCastilloPR">Jorge Castillo</a> </li></ul><br><p>     <a href="https://youtu.be/sxudIMiOo68">FP to the max</a>  <a href="https://twitter.com/jdegoes">John De Goes</a>     <code>FpToTheMax.kt</code> ,    <code>arrow-examples</code> .          ,   ,          . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447234/">https://habr.com/ru/post/447234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447218/index.html">Parsing JPoint 2019 tasks</a></li>
<li><a href="../447220/index.html">Basics of JavaScript engines: common forms and inline caching. Part 2</a></li>
<li><a href="../447222/index.html">Linux Quest. Congratulations to the winners and tell about solutions</a></li>
<li><a href="../447226/index.html">Interview with the popularizer of science, the head of the only private school of astronomy in Russia, Pavel Skripnichenko</a></li>
<li><a href="../447232/index.html">Personal experience. How we connected international telephony: comparison of 6 virtual PBXs</a></li>
<li><a href="../447236/index.html">Creating a farm of Android devices using Open STF</a></li>
<li><a href="../447240/index.html">We study Adversarial Tactics, Techniques & Common Knowledge (ATT @ CK). Enterprise Tactics. Part 10</a></li>
<li><a href="../447242/index.html">Automation of SQL server in Jenkins: we return the result beautifully</a></li>
<li><a href="../447246/index.html">Prototype in 1 day instead of 2-3 weeks: 3D-printing in concern ‚ÄúOceanpribor‚Äù</a></li>
<li><a href="../447248/index.html">What is explored in the stratosphere?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>