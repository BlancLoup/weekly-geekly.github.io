<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory Management: A View from the Inside</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 
 I want to bring to your attention a translation of the article by Jonathan Bartlett , who is the technical director at New Medio . The art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory Management: A View from the Inside</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/478/186/863/47818686316a411db1b0fee443e6dbdd.jpg"><br>  Good day! <br>  I want to bring to your attention a translation of the article by <i>Jonathan Bartlett</i> , who is the technical director at <i>New Medio</i> .  The article was published on November 16, 2004 on <a href="http://www.ibm.com/">ibm.com</a> and is dedicated to memory management techniques.  Although the age of the article is quite high (by the standards of IT), the information in it is fundamental and describes the approaches to the distribution of memory, their strengths and weaknesses.  All this is accompanied by "self-made" implementations, for better absorption of the material. <br><br>  <b>Abstract from the author</b> <br>  <i>Solutions, trade-offs, and dynamic memory allocation implementations</i> <br>  Get an idea of ‚Äã‚Äãthe memory management methods available to Linux developers.  These methods are not limited to the C language, they are also used in other programming languages.  This article gives a detailed description of how memory is managed, with examples of a manual approach ( <i>manually</i> ), <i>semi-</i> manual using reference <i>referencing</i> or <i>pooling,</i> and automatic using <i>garbage collection</i> . <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Why is there a need for memory management</b> <br>  Memory management is one of the most fundamental areas in programming.  In a variety of scripting languages, you can not worry about memory management, but this does not make this mechanism less significant.  Knowledge of the capabilities of your memory manager <i>(memory manager</i> ) and the intricacies of his work, are the key to effective programming.  In most system languages, such as C / C ++, for example, the developer needs to keep track of the memory used.  The article is about manual, semi-automatic and automatic methods of memory management. <br><br>  There was a time when memory management was not a big problem.  As an example, we can recall the development time in assembler for Apple II.  Basically, the programs were launched not separately from the OS, but with it.  Any piece of memory could be used by both the system and the developer.  There was no need to calculate the total amount of memory, because  it was the same for all computers.  So the memory requirements were quite static - it was necessary to simply select a section of memory and use it. <br><br>  However, even in such a simple computer, you could grab problems, especially if you didn‚Äôt know how much memory you might need in a particular section of the program. <br>  If there are limitations associated with memory, then an approach is needed that will address such tasks as: <br><ul><li>  Determine if there is enough memory; </li><li>  Get section from available memory; </li><li>  Return the section back to the pool so that it can be used in other parts of the program or other programs. </li></ul><br>  ( <i>comment of the translator</i> : Let's designate this list as <i>Memory-Requirements</i> to refer to it further) <br>  The libraries that search / allocate / free memory are called allocator.  As the complexity of the program increases, the complexity of memory management increases and thereby the role of the allocator in the program increases.  Let's take a look at the various methods of memory management, consider their advantages and disadvantages, as well as the situations where they are most effective. <br><br>  <b>Allokatory (C-Style)</b> <br>  The <i>C</i> language supports two functions that solve tasks from Memory-Requirements: <br><ul><li>  <i><b>malloc</b></i> : Select the specified number of bytes and return a pointer to them.  If there is not enough memory, returns a pointer to a NULL ( <i>null pointer</i> ); </li><li>  <i><b>free</b></i> : Accepts a pointer to an area in memory allocated by <i>malloc</i> and returns it for further use in the program or operating system (in fact, some <i>malloc</i> return memory for later use only by the program, but not by the OS). </li></ul><br><br>  <b>Physical and virtual memory</b> <br>  To understand how allocation occurs within a program, you must have an idea how the OS allocates memory for the program.  ( <i>comment of the translator</i> : since the program runs under a specific OS, then it is she who decides how much memory to allocate for this or that program) Each running process considers that it has access to all the physical memory of the computer.  The fact is obvious that at the same time many processes work, and each of them cannot have access to all memory.  But what will happen if processes use virtual memory. <br><br>  As an example, let's say the program refers to the 629th memory location.  The <i>virtual memory system</i> does not guarantee that the data is stored in RAM at address 629. In fact, it may not even be RAM - the data could be transferred to disk if the RAM was all busy.  Those.  in virt.  memory can store addresses corresponding to the physical device.  The OS keeps a table of correspondence Wirth.  addresses to physical <i>(virtual address-to-physical address</i> ), so that the computer can properly respond to the request by address ( <i>address requests</i> ).  If RAM stores physical addresses, the OS will be forced to temporarily suspend the process, unload part of the data into a DISK (from RAM), load the necessary data for the operation of the WITH DISK process and restart the process.  Thus, each process gets its address space with which it can operate and can get even more memory than the OS allocated to it. <br><br>  In 32-bit applications ( <i>x86</i> architecture), each process can work with 4 gigabytes of memory.  At the moment, most users do not own this amount.  Even if <i><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D0%25BA%25D0%25B0%25D1%2587%25D0%25BA%25D0%25B0_%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586">swap is used</a></i> , it should still be less than 4 GB per process.  Thus, when a process is unloaded into memory, a certain space is allocated to it.  The end of this section of memory is referred to as a <i>system break</i> .  Behind this boundary is unpartitioned memory, i.e.  without projection on disk or ram.  Therefore, when a process runs out of memory (from the one that was allocated to it at boot), it must request a larger chunk of memory from the OS.  ( <i>Mapping</i> (from the English. <i>Mapping</i> - reflection, projection) is a mathematical term meaning one-to-one correspondence - that is, when another address (disk address) is stored at the virtual address, where real data is already stored) <br><br>  UNIX-based operating systems have two system calls for additional memory markup: <br><ul><li>  <i><b>brk</b></i> : brk () is a very simple system call.  <i>System break</i> is the extreme limit of the memory marked up for the process.  <i>brk ()</i> simply moves this boundary forward / backward to increase or decrease the amount of allocated memory.  ( <i>note of the translator</i> : imagine the scale of the scale in the same MS Word. <i>System break</i> is the maximum value that the slider can accept, and the slider itself is <i>Current break</i> ); </li><li>  <i><b>mmap</b></i> : mmap () (or ‚Äúmemory map‚Äù) is similar to <i>brk ()</i> , but is a more flexible tool.  First, it can allocate memory anywhere in the address space, and not just at the end of the process.  Secondly, it can not just mark up memory (virtual) as a projection to physical or swap, it can bind the memory to specific files so that reading and writing will operate directly on the file.  The antipode of <i>mmap ()</i> is <i>munmap ()</i> . </li></ul><br><br>  As you can see, simple calls to <i>brk ()</i> or <i>mmap ()</i> can be used to expand the process memory.  Further in the text will be used <i>brk ()</i> .  It is the simplest and most common tool. <br><br>  <b>Implementing a simple allocator</b> <br>  If you wrote programs in C, you probably used such functions as <i>malloc ()</i> and <i>free ()</i> .  Surely you did not even think about their implementation.  This section will demonstrate a simplified implementation of these functions and illustrate how they participate in memory allocation. <br>  For example, we need this <a href="http://www.ibm.com/developerworks/linux/library/l-memory/sidefile.html">listing</a> .  Copy and paste it into a file called <u>malloc.c</u> .  We will analyze it a bit later. <br>  Allocate memory in most operating systems tied to two simple functions: <br><ul><li>  void * <i>malloc</i> (long numbytes): <u>Allocates numbytes</u> bytes in memory and returns a pointer to the first one; </li><li>  void <i>free</i> (void * firstbyte): <u>firstbyte</u> - pointer obtained using <i>malloc ()</i> and the memory for which must be freed. </li></ul><br>  We declare the function <i>malloc_init</i> , which will initialize our allocator.  This implies three things: Mark allocator as initialized, find the last valid address in memory (that is, which could be used for allocation) and set a pointer to the beginning of this memory.  To do this, we declare three global variables: <br><br>  <b>Code Listing 1: <i>Global variables for our allocator</i></b> <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> has_initialized = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *managed_memory_start; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *last_valid_address;</code> </pre> <br><br>  As mentioned above, the "edge" of the marked memory (the last valid address) has several names - <i>System break</i> or <i>Current break</i> .  In most Unix-like systems, the <i>sbrk (0)</i> function is used to search for the <i>current system break</i> .  <i>sbrk</i> pushes the <i>current break</i> by n bytes (passed in the argument), after which the <i>current break</i> will take the new value.  Calling <i>sbrk (0)</i> simply returns the <i>current system</i> .  We write the code for our <i>malloc</i> , which will look for the <i>current break</i> and initialize the variables: <br>  <b>Code Listing 2: <i>Initializing the Allocator</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Include the sbrk function */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; void malloc_init() { /*  (  )    */ last_valid_address = sbrk(0); /*     ,      *     last_valid_address */ managed_memory_start = last_valid_address; /*  ,    */ has_initialized = 1; }</span></span></span></span></code> </pre><br>  For proper management, you need to monitor allocated and released memory.  It is necessary to mark the memory as ‚Äúunused‚Äù, after calling <i>free ()</i> for any part of the memory.  This is required to search for free memory when <i>malloc () is</i> called.  Thus, the beginning of each section of memory that <i>malloc ()</i> returns will have the following structure: <br>  <b>Code Listing 3: <i>Memory Control Block structure</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_control_block</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_available; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; };</code> </pre><br>  You can guess that this structure will interfere if you return a pointer to it (a call to the <i>malloc</i> function).  ( <i>comment of the translator</i> : meaning that if the pointer is set at the beginning of this structure, then when writing to this memory, we will lose information about how much memory has been allocated) Everything is solved quite simply - it must be hidden, namely return the pointer to memory which is located immediately behind this structure.  Those.  in fact, return a pointer to the area that does not store any information in itself and where you can ‚Äúwrite‚Äù your data.  When a <i>free ()</i> call occurs in which the pointer is passed, we simply rewind a certain number of bytes (and specifically <i>sizeof</i> (mem_control_block)) in order to use the data in this structure to search further. <br><br>  First, let's talk about freeing memory, because  This process is simpler than selection.  All that needs to be done to free up memory is to take the pointer passed as a parameter to the <i>free ()</i> function, move it to <i>sizeof</i> (struct mem_control_block) byte back, and mark the memory as free.  Here is the code: <br>  <b>Code Listing 4: <i>Freeing memory</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *firstbyte)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_control_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mcb</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*          * mem_control_block */</span></span> mcb = firstbyte - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct mem_control_block); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> mcb-&gt;is_available = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  ! */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  As you can see, in this example, the release takes place in constant time, because  has a very simple implementation.  With the selection is a little more difficult.  Consider the algorithm in general: <br>  <b>Code Listing 5: <i>Pseudocode for the allocator algorithm</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span>      ,   . <span class="hljs-number"><span class="hljs-number">2.</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct mem_control_block)    ; <span class="hljs-number"><span class="hljs-number">3.</span></span>   managed_memory_start. <span class="hljs-number"><span class="hljs-number">4.</span></span>      last_valid address? <span class="hljs-number"><span class="hljs-number">5.</span></span>  : A.                  . <span class="hljs-number"><span class="hljs-number">6.</span></span>  : A.    ?( mem_control_block-&gt;is_available == <span class="hljs-number"><span class="hljs-number">1</span></span>)? B.  : I) -    (mem_control_block-&gt;is_available &gt;=  )? II)  : a.     (mem_control_block-&gt;is_available = <span class="hljs-number"><span class="hljs-number">0</span></span>) b.    mem_control_block    III)   : a.   <span class="hljs-string"><span class="hljs-string">"size"</span></span>   b.    <span class="hljs-number"><span class="hljs-number">4</span></span> C.  : I)   <span class="hljs-string"><span class="hljs-string">"size"</span></span>   II)    <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  The whole point is in a kind of ‚Äúwalk‚Äù from memory to find free sites.  Take a look at the code: <br>  <b>Code Listing 6: <i>Implementing the algorithm</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numbytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *current_location; <span class="hljs-comment"><span class="hljs-comment">/*      * memory_control_block */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_control_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current_location_mcb</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       .       0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *memory_location; <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(! has_initialized) { malloc_init(); } <span class="hljs-comment"><span class="hljs-comment">/*     memory * control block,    malloc  *   .       */</span></span> numbytes = numbytes + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct mem_control_block); <span class="hljs-comment"><span class="hljs-comment">/*  memory_location 0      */</span></span> memory_location = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      ()  */</span></span> current_location = managed_memory_start; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(current_location != last_valid_address) { <span class="hljs-comment"><span class="hljs-comment">/*   current_location  current_location_mcb *  .  current_location_mcb *     ,  * current_location    t */</span></span> current_location_mcb = (struct mem_control_block *)current_location; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(current_location_mcb-&gt;is_available) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(current_location_mcb-&gt;size &gt;= numbytes) { <span class="hljs-comment"><span class="hljs-comment">/* !    ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,    -     */</span></span> current_location_mcb-&gt;is_available = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> memory_location = current_location; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*    ,         ,   */</span></span> current_location = current_location + current_location_mcb-&gt;size; } <span class="hljs-comment"><span class="hljs-comment">/*        ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(! memory_location) { <span class="hljs-comment"><span class="hljs-comment">/* Move the program break numbytes further */</span></span> sbrk(numbytes); <span class="hljs-comment"><span class="hljs-comment">/*  , last_valid_address   */</span></span> memory_location = last_valid_address; <span class="hljs-comment"><span class="hljs-comment">/*   last valid address  * numbytes  */</span></span> last_valid_address = last_valid_address + numbytes; <span class="hljs-comment"><span class="hljs-comment">/*   mem_control_block */</span></span> current_location_mcb = memory_location; current_location_mcb-&gt;is_available = <span class="hljs-number"><span class="hljs-number">0</span></span>; current_location_mcb-&gt;size = numbytes; } <span class="hljs-comment"><span class="hljs-comment">/*     (   ). *   memory_location     * mem_control_block */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     mem_control_block */</span></span> memory_location = memory_location + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct mem_control_block); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory_location; }</code> </pre><br>  This is our Memory Manager.  Now it is necessary to collect it, for use in its programs. <br>  To build our <i>malloc-like</i> allocator, you need to type the following command (we did not touch on such functions as <i>realloc ()</i> , but <i>malloc ()</i> and <i>free ()</i> are the most significant): <br>  <b>Code Listing 7: <i>Compiling</i></b> <br><pre> <code class="cpp hljs">gcc -shared -fpic <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>.c -o <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>.so</code> </pre><br>  At the output we get the file <u>malloc.so</u> , which is a library and contains our code. <br>  On Unix systems, you can use your allocator instead of the system one.  This is done like this: <br>  <b>Code Listing 8: <i>Replacing standard malloc</i></b> <br><pre> <code class="cpp hljs">LD_PRELOAD=/path/to/<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>.so <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> LD_PRELOAD</code> </pre><br>  LD_PRELOAD is an <i>environment variable</i> .  It is used by the dynamic linker ( <i>dynamic linker</i> ) to determine the characters that are contained in the library, before the library will be loaded by any application.  This underlines the importance of symbols in dynamic libraries.  Thus, applications that will be created in the current session will use <i>malloc ()</i> , which we have just written.  Some applications do not use <i>malloc ()</i> , but this is the exception rather than the rule.  Others that use <i>realloc ()</i> like allocators, or who have no idea about the malloc () internal behavior, are likely to fall.  <a href="https://ru.wikipedia.org/wiki/Almquist_shell">Ash</a> shell (ash is a command shell for UNIX-like systems) works great with our <i>malloc</i> allocator. <br><br>  If you want to make sure your <i>malloc () is being used</i> , you can add a <i>write ()</i> call to the top of your functions. <br><br>  In terms of functionality, our memory <i>manager</i> leaves much to be desired, but it is excellent as an example to demonstrate the work.  Of its shortcomings should be noted: <br><ul><li>  Since  it works with a <i>system break</i> (global variable), it cannot coexist with other allocators or with <i>mmap</i> ; </li><li>  In the allocation, the allocator, in the worst case, will have to go through the entire memory of the process, which among other things may also include data addresses that are stored on disk.  This will cause the OS to spend time moving data from disk to virtual.  memory and back; </li><li>  It does not have the best handling of errors associated with an <i>out-of-memory</i> error; </li><li>  It does not have many other functions, such as <i>realloc ()</i> ; </li><li>  Since  <i>sbrk ()</i> can allocate more memory than we requested, this will cause a memory leak at the end of the heap; </li><li>  is_available uses 4 bytes, although in fact only one bit is needed; </li><li>  The allocator does not have <i><i>thread-safety</i> ;</i> <br>  Cannot merge into larger blocks.  (comment of translator: let's say we request 32 bytes. There are two free blocks of 16 bytes in succession in the memory. The allocator will not take this into account.); </li><li>  Uses a non-trivial algorithm that potentially leads to memory fragmentation; </li><li>  Of course there are other problems.  But this is only an example! </li></ul><br>  <b>Other <i>malloc</i> implementations</b> <br>  There are many other implementations of <i>malloc ()</i> that have both strengths and weaknesses.  There are a number of criteria that should be considered when designing allocators: <br><ul><li>  <i>Allocation speed</i> ( <i>allocation speed</i> ); </li><li>  <i>Deallocation speed</i> ; </li><li>  Behavior in a multithreaded environment; </li><li>  Behavior when memory ends; </li><li>  Cache location; </li><li>  Accounting for additional memory costs; </li><li>  Behavior in virtual memory; </li><li>  Large and small objects; </li><li>  Stable work in real time. </li></ul><br>  For example, for our allocator, a plus would be a quick release of memory, a minus - a slow release.  Also, because of the primitive algorithm of working with Wirth.  memory, it works best with large objects. <br><br>  There are many varieties of allocators.  Here are some of them: <br><ul><li>  <b>Doug Lea malloc</b> : is a whole subset of allocators, including original <i>Doug Lea</i> allocators, <i>GNU libc</i> allocators and <i>ptmalloc</i> .  <i>Deug Lea</i> allocators have a similar structure as our allocator, but it has indices in its arsenal for faster search and can combine several unused blocks into one large one.  There is also caching support that speeds up the process of reusing recently released memory.  <i>ptmalloc</i> is the same <i>Deug Lea</i> that has been extended to support multithreading.  Description <i>Doug Lea's malloc is</i> available in the references at the end of the article. </li><li>  <b>BSD malloc</b> : <i>BSD Malloc</i> , an implementation that has been distributed in <a href="https://ru.wikipedia.org/wiki/BSD">BSD</a> since version 4.2 and is included in <a href="https://www.freebsd.org/ru/">FreeBSD</a> as an allocator that places objects from the pool with a known size in memory.  It has at its disposal the size of classes related to objects - the power of two minus constant.  So if you request a memory for an object, it will simply allocate the memory of any of the classes, the size of which will be appropriate.  This provides a simple implementation, but memory costs are possible.  A description is also available at the end of the article. </li><li>  <b>Hoard</b> : <i>Hoard</i> was written to work fast in a multithreaded environment.  Therefore, it is designed to work with locks that help to work with processes that await memory allocation. This can significantly speed up multi-threaded processes that constantly work with memory.  Description in the list of references. </li></ul><br>  These are the most famous of the many allocators.  If your application needs a special allocation of memory, then you can write a self-made (custom - <i>custom</i> ) allocator that will work based on your requirements.  Be that as it may, if you are not familiar with the concept of the work of the allocator, then self-written implementations will create more headaches than bring profit.  For a deeper introduction to the subject area, I advise you to read the following book: <a href="http://www.ozon.ru/context/detail/id/1335648/">Donald Knuth: The Art of Programming Volume 1: Basic Algorithms</a> - Section 2.5: Dynamic Memory Allocation.  Of course, the material is outdated; work with Wirth is not affected there.  environment memory, but the base of the algorithms has not changed. <br><br>  In C ++, you can implement your allocator for a class or template using the overload of the <i>new ()</i> operator.  Andrei Alexandrescu, in his book <a href="http://www.ozon.ru/context/detail/id/3829080/">Modern Programming in C ++,</a> described a small object allocator (Chapter 4: Placing in memory of small objects). <br><br>  <b>Disadvantages of distribution with <i>malloc ()</i></b> <br>  Not only our memory manager has flaws, they are also present in other implementations.  Managing with <i>malloc () is</i> quite a dangerous thing for programs that store data for a long time and that should be easily accessible.  Having many references to dynamically allocated memory, it is often difficult to know when it needs to be freed.  The manager, usually easily copes with his work, if the lifetime of a variable (or the time of working with a piece of memory) is limited to the scope of a function (local variables), but for global variables whose memory is used throughout the program, the task becomes more difficult.  Also, many APIs are described not very clearly and it becomes not clear who is responsible for managing the memory - on the program itself or on the called function. <br>  Due to similar problems, many programs work with memory according to their own rules.  Sometimes it can show that more operations ( <i>approx. Translator</i> : in the text ‚Äúmore code‚Äù) are spent on allocating and freeing memory than on the computational component.  Therefore, consider alternative ways to manage memory. <br><br>  <b>Semi-automatic ( <i>semi-automatic</i> ) approaches to memory management</b> <br><hr><br>  <b>Reference <i>counting</i></b> <br>  Reference <i>counting</i> is a semi-automatic method of working with memory, which requires additional code and which can be used to not keep track of when memory is no longer used.  <i>Reference-counting</i> does it for you. <br><br>  The mechanism of operation is the following - for each dynamically allocated memory there is a field that stores the number of references to it.  If a variable appears in the program that references this piece of memory, the counter is incremented.  And vice versa - while decreasing the variables referring to this memory, the counter decreases.  When decrementing the counter, a check occurs - if the number of links is 0, then the memory is freed. <br><br>  Each link that references this memory simply increases or decreases the counter.  This prevents memory cleaning situations when it is used.  In any case, you should not forget to use the functions responsible for counting references, if you work with this type of (‚Äúcounted‚Äù) structures.  Also, built-in functions and third-party libraries may not be able to work with <i>reference-counting</i> or have their own mechanism of operation. <br><br>  To implement this mechanism, you only need two functions.  The first will increase the reference count, the second will reduce and free up memory if it has reached zero. <br>  For example, the link counting function might look something like this: <br>  <b>Listing 9. <i>Reference-counting</i> principle</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* /  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      - Reference counter */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">refcountedstruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> refcount; } <span class="hljs-comment"><span class="hljs-comment">/*   (  ),  *       refcountedstruct */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">REF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">refcountedstruct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rstruct</span></span></span><span class="hljs-class">;</span></span> rstruct = (struct refcountedstruct *) data; rstruct-&gt;refcount++; } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNREF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">refcountedstruct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rstruct</span></span></span><span class="hljs-class">;</span></span> rstruct = (struct refcountedstruct *) data; rstruct-&gt;refcount--; <span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rstruct-&gt;refcount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(rstruct); } }</code> </pre><br>  <i>REF</i> and <i>UNREF</i> can be more difficult - it all depends on what goals you are pursuing.  For example, you want to add a lock for multi-threaded applications.  Then you will need to add a function pointer to the <i>refcounted struct</i> to free up memory (like a destructor in object-oriented languages ‚Äã‚Äã‚Äî this is necessary if your structure contains pointers) <br>  When using <i>REF</i> and <i>UNREF</i> , you must adhere to the following rules when assigning pointers: <br><ul><li>  UNREF - called before assignment </li><li>  REF - called after assignment </li></ul><br>  For functions that take <i>recounted</i> structures, the following rules are used: <br><ul><li>  REF - called the beginning of the function </li><li>  UNREF - called at the end of the function </li></ul><br>  Here is another small example: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* EXAMPLES OF USAGE */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    refcounted */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mydata</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> refcount; <span class="hljs-comment"><span class="hljs-comment">/*   refcountedstruct */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> datafield1; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> datafield2; <span class="hljs-comment"><span class="hljs-comment">/*  ,    */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mydata *data)</span></span></span><span class="hljs-function"> </span></span>{ REF(data); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> UNREF(data); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mydata</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">globalvar1</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     ,    * refcount ..    .  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storesomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mydata *data)</span></span></span><span class="hljs-function"> </span></span>{ REF(data); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> globalvar1 = data; REF(data); <span class="hljs-comment"><span class="hljs-comment">/* ref     */</span></span> UNREF(data); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }</code> </pre><br>  Since  <i>reference counting is</i> quite a trivial mechanism, then many developers implement it themselves, avoiding third-party libraries.  However, their implementation is still based on allocators like <i>malloc</i> and <i>free</i> , which are engaged in the allocation and release of memory.  <i>Reference counting</i> is also used in high-level languages, such as <a href="https://ru.wikipedia.org/wiki/Perl">Perl</a> .  These duties are assigned to the language itself, so you don‚Äôt need to worry about anything unless you want to expand it.  Of course, reference counting slightly reduces the speed of work, but adds a bit of security and simplicity to the development.  Consider the main benefits: <br><ul><li>  Simple implementation; </li><li>  Just use; </li><li>  An object reference is part of a structure that ensures good <i>cache locality</i> . </li></ul><br>  There are also disadvantages: <br><ul><li>  It is necessary to remember about calling the link counting function; </li><li>  You cannot free memory if the object is part of a ring structure; </li><li>  Slow down when assigning a pointer; </li><li>  Special care is required when handling exceptions ( <i>try</i> or <i>setjmp ()</i> / <i>longjmp ()</i> ); </li><li>  Additional memory is required when working with links; </li><li>  <i>Reference counter</i> is in first place in the structure, which gives quick access to most machines; </li><li>  Slow execution and additional difficulties when working in a multi-threaded environment. </li></ul><br>  C ++ can reduce the likelihood of error through smart pointers ( <i>smart pointers</i> ), which work with pointers as hard as <i>reference counting</i> .     legacy ,      <i>smart pointers</i> (, <i>linkage</i>   C)         ,          ,    .       C++ .      ,       ‚Äú ‚Äù  <a href="http://www.ozon.ru/context/detail/id/3829080/">   C++</a> (  ). <br><br> <b>Memory pools</b> <br> <i>Memory pools</i>    -  .     ,     / ( <i>stages</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) implementation, at each stage of which we know how much space the program will need. As an example, we can cite server processes where a lot of memory is allocated for connections - it has the maximum lifetime ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lifespan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) coincides with the connection lifetime. The same </font></font><a href="https://ru.wikipedia.org/wiki/Apache"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - each connection is a separate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which has its own </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memory pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . After the execution of the fragment, the memory is instantly released. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the ‚Äúpool‚Äù model of management, each allocation of memory refers to a specific pool, from which memory will be allocated. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(comment of the translator</font></font></i> :  ,   5    char. ..       ,   5  . ..      <i>stage</i>       ,            5 .       ‚Äú‚Äù           ,    .)  <i>pool</i>    .  apache, <i>pool</i>        ,  ,     .‚Ä¶ ,    ,       ,            ,    .  ,        ( <i>cleanup functions</i> ),             (-    ). <br><br>      ,      <i>obstack</i> ( <i>GNU</i> ‚Äî libc)  <a href="http:">Apache Protable Runtime</a> (Apache).  <i>obstack</i>  ,        Linux .  <a href="https://ru.wikipedia.org/wiki/Apache_Portable_Runtime">Apache Portable Runtime</a>      .      ,     . <br><br>  ‚Äú‚Äù    obstack: <br> <b> 11.    <i>obstack</i></b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;obstack.h&gt; #include &lt;stdlib.h&gt; /*   obstack  */ /*  obstack  (xmalloc *    malloc,    ,      (..   ) */ #define obstack_chunk_alloc xmalloc #define obstack_chunk_free free /* Pools */ /* Only permanent allocations should go in this pool */ struct obstack *global_pool; /*  pool   (per-connection) */ struct obstack *connection_pool; /*     (per-request) */ struct obstack *request_pool; void allocation_failed() { exit(1); } int main() { /*   */ global_pool = (struct obstack *) xmalloc (sizeof (struct obstack)); obstack_init(global_pool); connection_pool = (struct obstack *) xmalloc (sizeof (struct obstack)); obstack_init(connection_pool); request_pool = (struct obstack *) xmalloc (sizeof (struct obstack)); obstack_init(request_pool); /*    */ obstack_alloc_failed_handler = &amp;allocation_failed; /*   */ while(1) { wait_for_connection(); /*     */ while(more_requests_available()) { /*   */ handle_request(); /*       (request pool) */ obstack_free(request_pool, NULL); } /*    -    */ obstack_free(connection_pool, NULL); } } int handle_request() { /*  ,        (request pool) */ int bytes_i_need = 400; void *data1 = obstack_alloc(request_pool, bytes_i_need); /*     */ /*   */ return 0; }</span></span></span></span></code> </pre><br>  ,    <i>stage</i> -,     <i>obstack</i> .   ,       ,    <i>stage</i> ,         <i>obstack</i> ,          .  <i>obstack_free()</i>    <i>NULL</i> ,     <i>obstack</i> .      . <br>   : <br><ul><li>     ; </li><li>      , ..     .    <i>O(1)</i>        (   <i>O(n)</i> ,          <i>O(1)</i>   ); </li><li>      ,     ,   ; </li><li>   ,    . </li></ul><br>     : <br><ul><li>   ,        ( <i>stage</i> ); </li><li>      ; </li><li>    ,      ,       ( <i>memory management system</i> ); </li><li>   ,      .     ,      . </li></ul><br> <b>  ( <i>Garbage collection</i> )</b> <br> <i>Garbage collection</i> ‚Äî          .    ,      .  ,      ‚Äú‚Äù ,     ‚Äî   ( <i>stack</i> ),   ( <i>global variables</i> )   ( <i>registers</i> ).   ,     .       ,     ,          .     ,         ‚Äú‚Äù          ,   . <br> <b> </b> <br><ul><li> <b> ( <i>Coping</i> )</b> :               .        ‚Äú‚Äù  ,   ‚Äú‚Äù .  ,       ‚Äú‚Äù,     .      ,      .     <i>garbage collector</i>     . </li><li> <b> ( <i>Mark and sweep</i> )</b> :     .      ,   ‚Äú‚Äù   ‚Äú‚Äù ,    1  ,   ,        . </li><li> <b> ( <i>Incremental</i> )</b> :           .      ,        (   ).              . </li><li> <b> ( <i>Conservative</i> )</b> :         .    ,     .         ,     .     ,    ,     . ( <i>. </i> :       <i>int</i>    .      ,      .)            .    ,      . </li></ul><br>   <i> </i> ( <i>Hans Boehm</i> )       , ..         .          ( <i>malloc</i> / <i>free</i>   API)      <u>-enable-redirect-malloc</u> .       ( . <i>trick</i> ‚Äî , )  LD_PRELOAD,      ,            .         ,     ,     .          Mozila ‚Äî      .     Windows    Linux. <br>  : <br><ul><li>           ; </li><li> API     ,     . </li></ul><br>  Disadvantages: <br><ul><li>       ,    ; </li><li>     ,      ; </li><li> ,    ,  ; </li><li>    ,     NULL. </li></ul><br> <b></b> <br>   : ,   ,   ,   .      ‚Äî -     .         .      ,      ,        .          ,    . <br> <b> 1:     </b> <br><table><tbody><tr><th>  </th><th>   </th><th>   </th><th>   </th><th>    </th><th>  </th><th>    real time </th><th>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D1%2583%25D0%25BB%25D1%258C%25D1%2582%25D0%25B8%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">SMP</a>   </th></tr></tbody><tbody><tr><td> Custom allocator </td><td>    </td><td>    </td><td>    </td><td>   </td><td>   </td><td>    </td><td>    </td></tr><tr><td> Simple allocator </td><td>     </td><td>   </td><td>  Low </td><td>  </td><td>  </td><td>  Not </td><td>  Not </td></tr><tr><td> GNU <i>malloc</i> </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  Not </td><td>  </td></tr><tr><td> Hoard </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  Not </td><td>  Yes </td></tr><tr><td> Reference counting </td><td>  - </td><td>  - </td><td>  </td><td>  </td><td>  </td><td>  (   <i>malloc</i> ) </td><td>    </td></tr><tr><td> Pooling </td><td>  </td><td>   </td><td>  </td><td>  </td><td>  </td><td>  (   <i>malloc</i> ) </td><td>    </td></tr><tr><td> Garbage collection </td><td>  (   ) </td><td>  </td><td>  Low </td><td>  </td><td>  </td><td>  Not </td><td>   </td></tr><tr><td> Incremental garbage collection </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  Not </td><td>   </td></tr><tr><td> Incremental conservative garbage collection </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  Not </td><td>   </td></tr></tbody></table><br><div class="spoiler"> <b class="spoiler_title"> :</b> <div class="spoiler_text"><ul><li> <a href="http://www.gnu.org/software/libc/manual/html_node/Obstacks.html%3Fcm_mc_uid%3D47720967572814418047517%26amp%3Bcm_mc_sid_50200000%3D1446569732">The obstacks section of the GNU C Library manual</a> gives the programming interface for obstacks. </li><li> <a href="http://apr.apache.org/docs/apr/group__apr__pools.html%3Fcm_mc_uid%3D47720967572814418047517%26amp%3Bcm_mc_sid_50200000%3D1446569732">The Apache Portable Runtime documentation</a> describes the interface to their pooled allocator. </li><li> <a href="http://gee.cs.oswego.edu/dl/html/malloc.html%3Fcm_mc_uid%3D47720967572814418047517%26amp%3Bcm_mc_sid_50200000%3D1446569732">Doug Lea's Malloc</a> is one of the more popular memory allocators. </li><li> <a href="">BSD Malloc</a> is used in most BSD-based systems. </li><li> <a href="http://www.malloc.de/en/%3Fcm_mc_uid%3D47720967572814418047517%26amp%3Bcm_mc_sid_50200000%3D1446569732">ptmalloc</a> is derived from Doug Lea's malloc and is used in GLIBC. </li><li> <a href="">GNU Memory-Mapped Malloc (part of GDB)</a> is a <code>malloc</code> implementation that is based on <i>mmap()</i> . </li><li> <a href="http://www.gnu.org/software/libc/">GNU Obstacks</a> (part of GNU Libc) is the most widely installed pooled allocator, since it's on every glibc-based system. </li><li> <a href="http://apr.apache.org/">Apache's pooled allocator (in the Apache Portable Runtime)</a> is the most widely used pooled allocator. </li><li> <a href="">NetBSD</a> also has its own pooled allocator. </li><li> <a href="http://sourceforge.net/projects/loki-lib/">The Loki C++ Library</a> has a number of generic patterns implemented for C++, including smart pointers and a custom small-object allocator. </li><li> The <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Hahns Boehm Conservative Garbage Collector</a> is the most popular open source garbage collector, which can be used in regular C/C++ programs. </li><li> <a href="http://docs.freebsd.org/44doc/papers/newvm.html">A New Virtual Memory Implementation for Berkeley UNIX</a> by Marshall Kirk McKusick and Michael J. Karels discusses BSD's VM system. </li><li> <a href="http://www.skynet.ie/~mel/projects/vm/">Mel Gorman's Linux VM Documentation</a> discusses the Linux VM system. </li><li> <a href="http://docs.freebsd.org/44doc/papers/malloc.html">Malloc in Modern Virtual Memory Environments</a> by Poul-Henning Kamp talks about BSD's <i>malloc</i> and how it interacts with BSD virtual memory. </li><li> <a href="http://docs.freebsd.org/44doc/papers/kernmalloc.html">Design of a General Purpose Memory Allocator for the 4.3BSD UNIX Kernel</a> by Marshall Kirk McKusick and Michael J. Karels discusses kernel-level allocators. </li><li> <a href="http://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a> by Doug Lea gives an overview of the design and implementation of allocators, including design choices and tradeoffs. </li><li> <a href="http://www.cs.utexas.edu/ftp/pub/techreports/tr02-52.pdf">Memory Management for High-Performance Applications</a> by Emery D. Berger talks about custom memory management and how it affects high-performance applications. </li><li> <a href="">Some Storage Management Techniques for Container Classes</a> by Doug Lea describes writing custom allocators for C++ classes. </li><li> <a href="">The Measured Cost of Garbage Collection</a> by Benjamin Zorn presents hard data on garbage allocation and performance. </li><li> <a href="">Memory Allocation Myths and Half-Truths</a> by Hans-Juergen Boehm presents the myths surrounding garbage collection. </li><li> <a href="">Space Efficient Conservative Garbage Collection</a> by Hans-Juergen Boehm is a paper describing his garbage collector for C/C++. </li><li> <a href="http://www.memorymanagement.org/">The Memory Management Reference</a> contains numerous references and links to papers on memory management. </li><li> <a href="http://www.cs.utexas.edu/users/oops/papers.html">OOPS Group Papers on Memory Management and Memory Hierarchies</a> is a great set of technical papers on the subject. </li><li> <a href="http://www.cantrip.org/wave12.html">Memory Management in C++</a> discusses writing custom allocators for C++. </li><li> <a href="http://www.conman.org/projects/essays/memmgr.html">Programming Alternatives: Memory Management</a> discusses several choices programmers have for memory management. </li><li> <a href="http://www.cs.ukc.ac.uk/people/staff/rej/gcbib/gcbibG.html">Richard Jones's Garbage Collection Bibliography</a> has links to any paper you ever wanted about garbage collection. </li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/0471049980/freeeducation-20/"><em>C++ Pointers and Dynamic Memory Management</em></a> by Michael Daconta covers numerous techniques on memory management. </li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/0521520436"><em>Memory as a Programming Concept in C and C++</em></a> by Frantisek Franek discusses techniques and tools for developing effective memory use and gives the role of memory-related errors the prominence it deserves in computer programming. </li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/0471941484"><i>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</i></a> by Richard Jones and Rafael Lins describes the most common algorithms for garbage collection in use. </li><li> Section 2.5, ¬´Dynamic Storage Allocation¬ª from <a href="http://www.amazon.com/exec/obidos/ASIN/0201896834"><i>Fundamental Algorithms</i></a> , Volume 1 of <i>The Art of Computer Programming</i> by Donald Knuth describes several techniques for implementing basic allocators. </li><li> Section 2.3.5, ¬´Lists and Garbage Collection¬ª from <a href="http://www.amazon.com/exec/obidos/ASIN/0201896834"><i>Fundamental Algorithms</i></a> , volume 1 of <i>The Art of Computer Programming</i> by Donald Knuth discusses garbage collection algorithms for lists. </li><li> Chapter 4, ¬´Small Object Allocation¬ª from <a href="http://www.amazon.com/exec/obidos/ASIN/0201704315"><i>Modern C++ Design</i></a> by Andrei Alexandrescu describes a high-speed small-object allocator that is quite a bit more efficient than the C++ standard allocator. </li><li> Chapter 7, ¬´Smart Pointers¬ª from <a href="http://www.amazon.com/exec/obidos/ASIN/0201704315"><i>Modern C++ Design</i></a> by Andrei Alexandrescu describes the implementation of smart pointers in C++. </li><li> Jonathan's Chapter 8, ¬´Intermediate Memory Topics¬ª from <a href="http://www.amazon.com/exec/obidos/ASIN/0975283847/freeeducation-20/"><i>Programming from the Ground Up</i></a> contains an assembly-language version of the simple allocator used in this article. </li><li> <a href="http://www.ibm.com/developerworks/linux/library/wa-memmng/">Self-manage data buffer memory</a> (developerWorks, January 2004) outlines a pseudo-C implementation of a self-managing, abstract data buffer for managing memory. </li><li> <a href="http://www.ibm.com/developerworks/eserver/articles/framework.html">A framework for the user defined malloc replacement feature</a> (developerWorks, February 2002) shows how to take advantage of a facility in AIX that lets you replace the memory subsystem with one of your own design. </li><li> <a href="http://www.ibm.com/developerworks/linux/library/l-debug/index.html">Mastering Linux debugging techniques</a> (developerWorks, August 2002) describes debugging methods you can use in four different scenarios: segmentation faults, memory overruns, memory leaks, and hangs. </li><li> In <a href="http://www.ibm.com/developerworks/java/library/j-leaks/index.html">Handling memory leaks in Java programs</a> (developerWorks, February 2001), learn what causes Java memory leaks and when they should be of concern. </li><li> In the <a href="http://www.ibm.com/developerworks/linux/">developerWorks Linux zone</a> , find more resources for Linux developers, and scan our <a href="http://www.ibm.com/developerworks/linux/library/l-top-10.html">most popular articles and tutorials</a> . </li><li> See all <a href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp%3Ftopic_by%3DAll%2Btopics%2Band%2Brelated%2Bproducts%26amp%3Bsort_order%3Ddesc%26amp%3Blcl_sort_order%3Ddesc%26amp%3Bsearch_by%3Dlinux%2Btip%253A%26amp%3Bsearch_flag%3Dtrue%26amp%3Btype_by%3DAll%2BTypes%26amp%3Bshow_abstract%3Dtrue%26amp%3Bstart_no%3D1%26amp%3Bsort_by%3DDate%26amp%3Bend_no%3D100%26amp%3Bshow_all%3Dfalse">Linux tips</a> and <a href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp%3Ftopic_by%3DAll%2Btopics%2Band%2Brelated%2Bproducts%26amp%3Bsort_order%3Ddesc%26amp%3Blcl_sort_order%3Ddesc%26amp%3Bsearch_by%3D%26amp%3Bsearch_flag%3D%26amp%3Btype_by%3DTutorials%26amp%3Bshow_abstract%3Dtrue%26amp%3Bsort_by%3DDate%26amp%3Bend_no%3D100%26amp%3Bshow_all%3Dfalse">Linux tutorials</a> on developerWorks. </li><li> Stay current with <a href="http://www.ibm.com/developerworks/offers/techbriefings/">developerWorks technical events and Webcasts</a> . </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/270009/">https://habr.com/ru/post/270009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269997/index.html">October 31, 2015 - EOL applications for Kerio Control 7 for Windows (Post # 3 - free webinar (November 13, 2015)</a></li>
<li><a href="../269999/index.html">Riot vs. Virtual Machine</a></li>
<li><a href="../270001/index.html">Do good code: 8 good code rules</a></li>
<li><a href="../270003/index.html">JetBrains Toolbox came out with all updated desktop products</a></li>
<li><a href="../270005/index.html">Service Locator breaks encapsulation</a></li>
<li><a href="../270011/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ183 (October 26 - November 1, 2015)</a></li>
<li><a href="../270015/index.html">Enabling BitLocker on Exchange Servers</a></li>
<li><a href="../270017/index.html">Michael Stonebreaker - Hadoop at the Crossroads</a></li>
<li><a href="../270019/index.html">Vivaldi Beta 1.0 browser release</a></li>
<li><a href="../270023/index.html">Introduction to RxJava: Key Types</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>