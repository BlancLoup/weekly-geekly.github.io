<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IL2CPP: method calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fourth article in the series on IL2CPP. In it, we‚Äôll talk about how il2cpp.exe generates C ++ code for method calls in managed code. 



 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IL2CPP: method calls</h1><div class="post__text post__text-html js-mediator-article">  This is the fourth article in the series on IL2CPP.  In it, we‚Äôll talk about how il2cpp.exe generates C ++ code for method calls in managed code. <br><br><img src="https://habrastorage.org/files/50f/e10/b54/50fe10b546304038a74cd6cd84a95bea.jpg"><a name="habracut"></a><br><br>  In particular, we consider six types of calls: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  direct invocation of instance and static methods; </li><li>  calls through the compile time delegate; </li><li>  calls through a virtual method; </li><li>  calls through the interface method; </li><li>  calls through the runtime delegate; </li><li>  challenges through reflection. </li></ul><br>  We will focus on the actions of the generated C ++ code, as well as the costs associated with each type of call.  As I already spoke, the presented code for certain will change in the next versions of Unity.  But the basic principles will remain unchanged. <br><br>  Previous articles in the series: <br><br>  ¬ª <a href="https://habrahabr.ru/company/plarium/blog/276589/">Introduction to IL2CPP.</a> <br>  ¬ª <a href="https://habrahabr.ru/company/plarium/blog/280824/">IL2CPP: a tour of the generated code.</a> <br>  ¬ª <a href="https://habrahabr.ru/company/plarium/blog/281829/">IL2CPP: Tips for debugging generated code.</a> <br><br><h2>  Preparation for work </h2><br>  I will use the version of Unity 5.0.1p4 on Windows to build the project under WebGL.  At the same time, I will turn on the Development Player option and set the value to Full for Enable Exceptions.  To analyze the different types of method calls, I will use the modified script from the previous article, starting with the interface and the class definition: <br><br><pre><code class="cpp hljs">[csharp] interface Interface { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodOnInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> question)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Important</span></span></span><span class="hljs-class"> :</span></span> Interface { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> question)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodOnInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> question)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> question)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } [/csharp]</code> </pre> <br>  They are followed by a constant field and a delegate type: <br><br><pre> <code class="cpp hljs">[csharp] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> question = <span class="hljs-string"><span class="hljs-string">"What is the answer to the ultimate question of life, the universe, and everything?"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> delegate </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImportantMethodDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> question)</span></span></span></span>; [/csharp]</code> </pre><br>  Finally, we specify the methods we are interested in, as well as the obligatory Start method (empty in our case): <br><br><pre> <code class="cpp hljs">[csharp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallDirectly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var important = ImportantFactory(); important.Method(question); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethodDirectly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Important.StaticMethod(question); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallViaDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var important = ImportantFactory(); ImportantMethodDelegate indirect = important.Method; indirect(question); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallViaRuntimeDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var important = ImportantFactory(); var runtimeDelegate = Delegate.CreateDelegate(typeof (ImportantMethodDelegate), important, <span class="hljs-string"><span class="hljs-string">"Method"</span></span>); runtimeDelegate.DynamicInvoke(question); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallViaInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Interface importantViaInterface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Important(); importantViaInterface.MethodOnInterface(question); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallViaReflection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var important = ImportantFactory(); var methodInfo = typeof(Important).GetMethod(<span class="hljs-string"><span class="hljs-string">"Method"</span></span>); methodInfo.Invoke(important, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[] {question}); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Important </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImportantFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var important = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Important(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> important; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} [/csharp]</code> </pre><br>  So, everything is ready.  Note that while the editor is open, the generated C ++ code is located in the Temp \ StagingArea \ Data \ il2cppOutput directory.  And don't forget to generate a tag file with Ctags to make it easier to navigate through the code. <br><br><h2>  Direct calls </h2><br>  It is easier to call a method and, as you can see, the fastest is directly.  Here is the generated code for the CallDirectly method: <br><br><pre> <code class="cpp hljs">[cpp] Important_t1 * L_0 = HelloWorld_ImportantFactory_m15(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*static, unused*/</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*hidden argument*/</span></span>&amp;HelloWorld_ImportantFactory_m15_MethodInfo); V_0 = L_0; Important_t1 * L_1 = V_0; NullCheck(L_1); Important_Method_m1(L_1, (String_t*) &amp;_stringLiteral1, <span class="hljs-comment"><span class="hljs-comment">/*hidden argument*/</span></span>&amp;Important_Method_m1_MethodInfo); [/cpp]</code> </pre><br>  The last line is the method call.  Note that it just calls the free function specified in C ++ code.  As we said in the previous article, IL2CPP does not use member functions or virtual functions, but generates all methods as free C ++ functions.  Similarly, a direct call to the static method works.  Here is the generated code for the CallStaticMethodDirectly method: <br><br><pre> <code class="cpp hljs">[cpp] Important_StaticMethod_m3(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*static, unused*/</span></span>, (String_t*) &amp;_stringLiteral1, <span class="hljs-comment"><span class="hljs-comment">/*hidden argument*/</span></span>&amp;Important_StaticMethod_m3_MethodInfo); [/cpp]</code> </pre><br>  It can be said that it is less expensive to call a static method, since we do not need to create and initialize an object instance.  But the method call itself is the same.  The only difference is that for the first argument of static functions, IL2CPP always passes the value NULL.  Given that the difference between calls to static methods and instance methods is so small, in the framework of this article we will identify them. <br><br><h2>  Calls through the compile time delegate </h2><br>  An indirect call through a delegate has its own specifics.  First I will clarify what I mean by the delegate of the compile time - already at compile time we know which method is called from which instance of the object.  The code for this type is in the CallViaDelegate method.  In the generated code, it looks like this: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-comment"><span class="hljs-comment">// Get the object instance used to call the method. Important_t1 * L_0 = HelloWorld_ImportantFactory_m15(NULL /*static, unused*/, /*hidden argument*/&amp;HelloWorld_ImportantFactory_m15_MethodInfo); V_0 = L_0; Important_t1 * L_1 = V_0; // Create the delegate. IntPtr_t L_2 = { &amp;Important_Method_m1_MethodInfo }; ImportantMethodDelegate_t4 * L_3 = (ImportantMethodDelegate_t4 *)il2cpp_codegen_object_new (InitializedTypeInfo(&amp;ImportantMethodDelegate_t4_il2cpp_TypeInfo)); ImportantMethodDelegate__ctor_m4(L_3, L_1, L_2, /*hidden argument*/&amp;ImportantMethodDelegate__ctor_m4_MethodInfo); V_1 = L_3; ImportantMethodDelegate_t4 * L_4 = V_1; // Call the method NullCheck(L_4); VirtFuncInvoker1&lt; int32_t, String_t* &gt;::Invoke(&amp;ImportantMethodDelegate_Invoke_m5_MethodInfo, L_4, (String_t*) &amp;_stringLiteral1); [/cpp]</span></span></code> </pre><br>  Note that the method being called is not actually part of the generated code.  The VirtFuncInvoker1 &lt;int32_t, String_t *&gt; :: Invoke method is located in the GeneratedVirtualInvokers.h file generated by the il2cpp.exe utility based on using virtual functions that return a value (VirtFuncInvokerN) and do not return it (VirtActionInvokerN), where N is the number of arguments.  This is how the Invoke method looks like: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtFuncInvoker1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Func)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, T1, MethodInfo*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodInfo* method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* obj, T1 p1)</span></span></span><span class="hljs-function"> </span></span>{ VirtualInvokeData data = il2cpp::vm::Runtime::GetVirtualInvokeData (method, obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Func)data.methodInfo-&gt;method)(data.target, p1, data.methodInfo); } }; [/cpp]</code> </pre><br>  The call to GetVirtualInvokeData looks for a virtual method in the vtable table generated from the managed code, and then calls this method. <br><br>  <i>Why we did not use the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD">variable templates</a> C ++ 11 to implement the methods of VirtFuncInvokerN?</i>  <i>Everything indicates that in this case they would have come in handy.</i>  <i>However, to work with C ++ code generated by il2cpp.exe, we need C ++ compilers, which do not support all aspects of C ++ 11 yet. Therefore, we decided that creating a separate branch of the generated code for the compilers would only complicate the process and did not.</i> <br><br>  But why is this a virtual method call?  Don't we call the instance method in C # code?  Don't forget that we do this through the C # delegate.  Take another look at the generated code.  The called method is passed through the MethodInfo * argument (method metadata) - ImportantMethodDelegate_Invoke_m5_MethodInfo.  Find a method called ImportantMethodDelegate_Invoke_m5 in the generated code, and you will see that the call goes to the managed Invoke method of type ImportantMethodDelegate.  This is a virtual method, which means we have to make a virtual call: the ImportantMethodDelegate_Invoke_m5 function will call a method called Method in C # code. <br><br>  So, due to a small change in the C # code, we switched from a single call to a free C ++ function to several calls, including a table search.  However, calling a method through a delegate is much more expensive than directly.  By the way, in the process of reviewing this type of call, we also talked about how calls work through the virtual method. <br><br><h2>  Calls through the interface </h2><br>  You can also call a method in C # through the interface.  Il2cpp.exe makes such calls by analogy with calls to virtual methods: <br><br><pre> <code class="cpp hljs">[cpp] Important_t1 * L_0 = (Important_t1 *)il2cpp_codegen_object_new (InitializedTypeInfo(&amp;Important_t1_il2cpp_TypeInfo)); Important__ctor_m0(L_0, <span class="hljs-comment"><span class="hljs-comment">/*hidden argument*/</span></span>&amp;Important__ctor_m0_MethodInfo); V_0 = L_0; Object_t * L_1 = V_0; NullCheck(L_1); InterfaceFuncInvoker1&lt; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>, String_t* &gt;::Invoke(&amp;Interface_MethodOnInterface_m22_MethodInfo, L_1, (String_t*) &amp;_stringLiteral1); [/cpp]</code> </pre><br>  Note that the method is invoked via the InterfaceFuncInvoker1 :: Invoke function in the GeneratedInterfaceInvokers.h file.  Like VirtFuncInvoker1, the InterfaceFuncInvoker1 class searches the vtable table using the il2cpp :: vm :: Runtime :: GetInterfaceInvokeData function in libil2cpp. <br><br>  Why do calls via the interface method and calls via the virtual method use different APIs in libil2cpp?  The call to the InterfaceFuncInvoker1 :: Invoke function passes not only the method being called and its arguments, but also the interface (in this case, L_1).  For each type, a vtable table is stored so that the interface methods are fixed at offset.  Therefore, il2cpp.exe must provide an interface to determine which method to call.  In the end, we can say that calls through the virtual method and calls through the interface are equally expensive in IL2CPP. <br><br><h2>  Calls through the runtime delegate </h2><br>  You can also create a delegate at runtime using the Delegate.CreateDelegate method.  This is similar to creating a delegate at compile time, but requires calling another function.  The generated code looks like this: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-comment"><span class="hljs-comment">// Get the object instance used to call the method. Important_t1 * L_0 = HelloWorld_ImportantFactory_m15(NULL /*static, unused*/, /*hidden argument*/&amp;HelloWorld_ImportantFactory_m15_MethodInfo); V_0 = L_0; // Create the delegate. IL2CPP_RUNTIME_CLASS_INIT(InitializedTypeInfo(&amp;Type_t_il2cpp_TypeInfo)); Type_t * L_1 = Type_GetTypeFromHandle_m19(NULL /*static, unused*/, LoadTypeToken(&amp;ImportantMethodDelegate_t4_0_0_0), /*hidden argument*/&amp;Type_GetTypeFromHandle_m19_MethodInfo); Important_t1 * L_2 = V_0; Delegate_t12 * L_3 = Delegate_CreateDelegate_m20(NULL /*static, unused*/, L_1, L_2, (String_t*) &amp;_stringLiteral2, /*hidden argument*/&amp;Delegate_CreateDelegate_m20_MethodInfo); V_1 = L_3; Delegate_t12 * L_4 = V_1; // Call the method ObjectU5BU5D_t9* L_5 = ((ObjectU5BU5D_t9*)SZArrayNew(ObjectU5BU5D_t9_il2cpp_TypeInfo_var, 1)); NullCheck(L_5); IL2CPP_ARRAY_BOUNDS_CHECK(L_5, 0); ArrayElementTypeCheck (L_5, (String_t*) &amp;_stringLiteral1); *((Object_t **)(Object_t **)SZArrayLdElema(L_5, 0)) = (Object_t *)(String_t*) &amp;_stringLiteral1; NullCheck(L_4); Delegate_DynamicInvoke_m21(L_4, L_5, /*hidden argument*/&amp;Delegate_DynamicInvoke_m21_MethodInfo); [/cpp]</span></span></code> </pre><br>  Creating and initializing such a delegate requires a lot more code.  And the method call itself turns out to be more costly.  First, you need to create an array for the method arguments.  Then call the DynamicInvoke method from the Delegate instance.  Note that this method calls the function VirtFuncInvoker1 :: Invoke - just like the compile time delegate.  Thus, the runtime delegate requires not only one more function call, but also an additional search on the vtable table. <br><br><h2>  Challenges through reflection </h2><br>  It is not surprising that the most costly type of method call is through reflection.  Here is the generated code for the CallViaReflection method: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-comment"><span class="hljs-comment">// Get the object instance used to call the method. Important_t1 * L_0 = HelloWorld_ImportantFactory_m15(NULL /*static, unused*/, /*hidden argument*/&amp;HelloWorld_ImportantFactory_m15_MethodInfo); V_0 = L_0; // Get the method metadata from the type via reflection. IL2CPP_RUNTIME_CLASS_INIT(InitializedTypeInfo(&amp;Type_t_il2cpp_TypeInfo)); Type_t * L_1 = Type_GetTypeFromHandle_m19(NULL /*static, unused*/, LoadTypeToken(&amp;Important_t1_0_0_0), /*hidden argument*/&amp;Type_GetTypeFromHandle_m19_MethodInfo); NullCheck(L_1); MethodInfo_t * L_2 = (MethodInfo_t *)VirtFuncInvoker1&lt; MethodInfo_t *, String_t* &gt;::Invoke(&amp;Type_GetMethod_m23_MethodInfo, L_1, (String_t*) &amp;_stringLiteral2); V_1 = L_2; MethodInfo_t * L_3 = V_1; // Call the method. Important_t1 * L_4 = V_0; ObjectU5BU5D_t9* L_5 = ((ObjectU5BU5D_t9*)SZArrayNew(ObjectU5BU5D_t9_il2cpp_TypeInfo_var, 1)); NullCheck(L_5); IL2CPP_ARRAY_BOUNDS_CHECK(L_5, 0); ArrayElementTypeCheck (L_5, (String_t*) &amp;_stringLiteral1); *((Object_t **)(Object_t **)SZArrayLdElema(L_5, 0)) = (Object_t *)(String_t*) &amp;_stringLiteral1; NullCheck(L_3); VirtFuncInvoker2&lt; Object_t *, Object_t *, ObjectU5BU5D_t9* &gt;::Invoke(&amp;MethodBase_Invoke_m24_MethodInfo, L_3, L_4, L_5); [/cpp]</span></span></code> </pre><br>  As with the runtime delegate, we need to create an array for the method arguments.  Then we call the virtual method MethodBase :: Invoke - the MethodBase_Invoke_m24 function, which, in turn, calls another virtual function.  And only then the required method call is made. <br><br><h2>  Conclusion </h2><br>  Although it doesn‚Äôt compare to profiling, parsing the generated C ++ code allows you to better understand the costs associated with a particular method call.  For example, calling methods via the delegate of the execution time and through reflection is not worth it.  To improve performance, measure costs early on, preferably with profilers. <br><br>  We are continuing to work on optimizing the code generated by il2cpp.exe, so it is likely that in the next versions of Unity, the types of calls listed will look different.  In the next article we will talk about the implementation of universal methods and ways to reduce the size of the executable file and the generated code. </div><p>Source: <a href="https://habr.com/ru/post/310614/">https://habr.com/ru/post/310614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310602/index.html">SDN, NFV, DPDK, ONP, OPNFV and so on</a></li>
<li><a href="../310604/index.html">Checking Windows domain user passwords for resistance to a dictionary attack without password compromise</a></li>
<li><a href="../310606/index.html">Cluster Docker Swarm in 30 seconds</a></li>
<li><a href="../310608/index.html">Why is it profitable to create a payment business in Europe</a></li>
<li><a href="../310612/index.html">Finding out how to increase WiFi coverage</a></li>
<li><a href="../310616/index.html">Data Leaks in Health: The New Plague</a></li>
<li><a href="../310618/index.html">Masking Bitmaps on Android</a></li>
<li><a href="../310620/index.html">Comparison of analytical in-memory databases</a></li>
<li><a href="../310622/index.html">Using Google Cloud Speech API v2 in Asterisk to recognize Russian speech</a></li>
<li><a href="../310626/index.html">Little about energy technology and IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>