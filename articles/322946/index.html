<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How custom solutions helped save on network infrastructure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Building a CDN infrastructure is associated with a large number of technical issues: from choosing equipment and installing it in data centers to a us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How custom solutions helped save on network infrastructure</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f64/03e/2eb/f6403e2eb75c4ffe988941b610cc0305.png"><br><br>  Building a CDN infrastructure is associated with a large number of technical issues: from choosing equipment and installing it in data centers to a user interface for interacting with network capabilities.  We provide a translation of an article from the Fastly blog, where the team talks about very interesting custom solutions for working with the network (much of which was independently used in the <a href="https://xn--80aqc2a.xn--p1ai/">Airi</a> infrastructure). <br><br>  As a result of infrastructure optimization, we managed to achieve minimal downtime in case of failure of any node and large system scalability. <br><a name="habracut"></a><br><h2>  Scaling </h2><br>  Gradually developing a CDN is not easy, since the very essence of the service involves customers with an extensive geography of requests.  Therefore, Fastly initially focused on what was missing in the industry: maximum transparency and control over how content is delivered at the ‚Äúfrontier‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When we first started, our lack of experience in networking technologies had little effect on what.  Our typical point of presence (POP) consisted of two hosts directly connected to BGP (Border Gateway Protocol) providers.  By the beginning of 2013, we had grown so much that this number of hosts was not enough. <br><br>  Scale our topology by connecting even more caches directly to providers, as shown in fig.  1 (a) was impossible.  Providers do not want to work this way because of the cost of ports and the complexity of setting up additional BGP sessions. <br><br><img src="https://habrastorage.org/files/f64/03e/2eb/f6403e2eb75c4ffe988941b610cc0305.png"><br>  <em>Fig.</em>  <em>1. Impact of scalable network topology</em> <br><br>  An obvious solution could be a network device, as shown in Figure 2.  1 (b).  Although this could be a valid compromise, the nature of a CDN is such that it implies a constant increase in geographic coverage and traffic. <br><br>  Today, our smallest points of presence include two network devices, as shown in Fig.  1 ¬©.  How it works is shown in fig.  2. The router receives routes directly from providers via BGP and inserts them into the Forwarding Information Base (FIB).  A lookup table implemented by hardware is used to select a route.  Hosts direct traffic to the router, which redirects packets to the most appropriate next network segment, according to a search in the device FIB. <br><br><img src="https://habrastorage.org/files/aef/edd/c4a/aefeddc4a57a42fda3c74231f3fc77bc.png"><br>  Fig.  2. Network topology using a router <br><br>  The larger the FIB, the more routes the device can store.  Border routers should be able to store the routing table for the entire Internet, which now exceeds 600,000 entries.  The hardware that is required to store such a FIB forms the bulk of the cost of the router. <br><br><h2>  Routing without routers </h2><br>  In traditional cloud environments, the cost of border routers is quickly becoming insignificant amid the sheer volume of servers and switches they serve.  But CDNs should have a large number of advantageously located points from where they deliver content.  Therefore, network devices can account for a significant share of the cost of the CDN infrastructure. <br><br>  We didn‚Äôt like the idea of ‚Äã‚Äãspending several million dollars on a very expensive network hardware.  We would rather invest this money in regular servers, which are directly responsible for how effectively we deliver the content. <br><br>  We could use switches, but they have a very limited FIB ‚Äî on the order of tens of thousands of routes, which is much less than what we need.  By 2013, vendors such as Arista began to introduce functionality that would help us cope with this limitation.  Vendors began to let us run our own software on the switches. <br><br>  Instead of relying on the FIB in a network device, we could forward traffic to the hosts.  BGP sessions from our providers would still be terminated on the switches, but the routes would go to the hosts. <br><br><img src="https://habrastorage.org/files/6c1/0b7/70c/6c10b770c7904fed941c9e8589ac8acf.png"><br>  <em>Fig.</em>  <em>3. Reflection of BGP routes</em> <br><br>  External BGP sessions (eBGP) are terminated on a BGP daemon, such as BIRD, which is running on the switch.  The resulting routes are then sent through internal BGP sessions (iBGP) to BIRD running on the hosts, which then inserts the routes directly into the host core. <br><br>  This solves the problem of bypassing the FIB on the switch, but not the problem of how to send packets back to the Internet.  An entry in the FIB consists of the destination prefix and the address of the next network section.  To send a packet to the next leg, the device must know its physical address on the network.  This data is stored in the Address Resolution Protocol (ARP) protocol table. <br><br>  In fig.  Figure 3 shows that the switch has the correct ARP information for our providers, since it is connected directly to them.  The hosts do not possess it and therefore cannot determine the next network segment for what was sent to them via BGP. <br><br><img src="https://habrastorage.org/files/a8f/bcb/b7c/a8fbcbb7c3894f95b79239b6b6f1d81f.png"><br>  <em>Fig.</em>  <em>4. Spreading ARP with Silverton</em> <br><br><h2>  Silverton - Distributed Routing Agent </h2><br>  This has led to the emergence of Silverton, our own network controller that manages the routing at our points of presence.  We realized that we can simply launch a daemon on the switch, which learns about changes in the ARP table through the API on Arista devices.  Having learned about the change in the physical MAC address of the provider, Silverton then spreads this information through our network, and the clients on the hosts reconfigure our servers with information on how to directly reach the providers. <br><br>  Having the IP and MAC addresses of the provider, the first step for Silverton on the client side is to ‚Äútrick‚Äù the host so that it ‚Äúbelieves‚Äù that this IP address is directly accessible via the interface or local link.  This can be achieved by configuring the IP address of the provider as ‚Äúpeer‚Äù in the interface via iproute: <br><br><pre><code class="hljs cs">$ ip addr <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> &lt;localip&gt; peer <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> dev eth0</code> </pre> <br>  If the host considers the provider's IP address as a local link, it will look for its MAC address in the ARP table.  This can also be corrected: <br><br><pre> <code class="hljs sql">$ ip neigh <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> lladdr aa:aa:aa:aa:aa:aa nud <span class="hljs-keyword"><span class="hljs-keyword">permanent</span></span> dev eth0</code> </pre> <br>  Now every time the route search will return the next leg as 10.0.0.1, and the traffic will be sent to aa: aa: aa: aa: aa: aa directly. <br><br>  The switch receives data frames from the host to a physical MAC address, which is known to be connected directly.  The switch can determine which interface to send the frame to by viewing the local MAC address table, which indicates the corresponding MAC address of the destination and the outgoing interface. <br><br>  Although the described process may seem rather complicated, our first version of Silverton contained less than 200 lines of code.  And it saved us hundreds of thousands of dollars at every point of presence that we deployed.  Over time, Silverton ‚Äúgrew up‚Äù and began to provide the entire dynamic network configuration: from designating description fields to manipulating routing advertisements and emptying BGP sessions. <br><br>  In addition, Silverton provided a valuable level of abstraction.  He maintained the illusion that each host was directly connected to each provider, which was our starting point (Fig. 1 ‚Äî option A).  By maintaining multiple routing tables in the kernel and choosing which one to use for each package, we were able to create tools and applications on top of Silverton.  An example is the st-ping utility, which pings destinations for all connected providers. <br><br><img src="https://habrastorage.org/files/516/073/8c9/5160738c9a4f47e8984f45da684839df.png"><br>  <em>Fig.</em>  <em>5. Ping on all transit providers at the point of presence</em> <br><br><h2>  Prerequisites for Faild </h2><br>  Since we have already seen that by getting rid of traditional network devices, capital expenditures can be significantly reduced, we paid attention to load balancers. <br><br>  Traditionally, the load was distributed solely using balancers or ECMP routers.  Recently, the opposite approach began to gain momentum, in particular, services such as MagLev and GLB are balancing using software running on hosts. <br><br>  Our development Faild is a synthesis of two approaches, where we use hardware processing on traditional switches wherever possible, and transfer processing to the hosts where necessary.  The result of this approach was a distributed balancer. <br><br><h2>  Balancing client requests: walking on a tightrope </h2><br>  Imagine a set of servers that serves a number of clients, as shown in Figure 2.  6. From the client‚Äôs point of view, which server served his request is completely irrelevant as long as the response is received fairly quickly.  This gives flexibility in comparing which requests are processed by which resources.  This is called load balancing and is implemented at almost every level of the network stack.  Here we focus on balancing incoming client requests in the context of a CDN. <br><br><img src="https://habrastorage.org/files/8ee/cff/dfa/8eecffdfae054d089f78d05b1d5e643b.png"><br>  <em>Fig.</em>  <em>6. Balancing client requests with cache servers at the point of presence.</em> <br><br>  The main problem with balancing http requests is the inevitable limitation: if a packet from an established TCP connection is redirected to the wrong server, then the corresponding TCP stream will be dropped. <br><br><img src="https://habrastorage.org/files/bac/a7e/447/baca7e447375478ebc400248fb17baa8.png"><br>  <em>Fig.</em>  <em>7. Network topology using the balancer (a) and its corresponding packet stream (b)</em> <br><br>  Balancers usually work as proxies, terminate connections from clients and send traffic to the backend servers, as shown in fig.  7 (a) <br><br>  The balancer can monitor the status of the backend servers in order to decide where to send incoming flows.  When properly implemented, the distribution of requests across the backend servers is close to optimal, but it is very expensive.  The balancer monitors the status of each network connection, and this is a difficult task, for which specialized hardware is often used. <br><br>  However, maintaining connection status information is an added challenge.  As you know, the sender is easier to create connections than the recipient - to track them, and this asymmetry in TCP is regularly used during DOS attacks.  Most balancers contain additional means to prevent SYN flooding, but they are still the bottleneck of the network.  Even virtualized balancers that run on conventional hardware, such as Google MagLev, require monitoring the status of threads, and therefore DOS attacks are also dangerous for them. <br><br><h2>  DNS: Workaround </h2><br>  DNS turns names into addresses, and this can be used for load balancing between servers if only the IP addresses of normally functioning servers are returned. <br><br><img src="https://habrastorage.org/files/5f5/80f/1ba/5f580f1ba63048a1a0b94f4b6864e8ef.png"><br>  <em>Fig.</em>  <em>8. Architecture of server selection via DNS (a) and the corresponding packet stream (b)</em> <br><br>  This approach does not require monitoring the status of threads and therefore scales well.  However, it has a fundamental limitation in terms of failover.  The DNS response can be cached by the resolvers for minutes, and sometimes even hours.  The response caching period is transmitted via the TTL field in the response, but this is not always taken into account by resolvers.  Therefore, the propagation of the change may take a considerable amount of time during which the client will be connected to the idle server. <br><br>  Companies such as Spotify or Netflix can control both the end-user application and the servers at the border, and therefore can bypass this DNS problem by integrating server selection into their applications.  CDNs like Fastly cannot do this, since they have to work with a variety of options, from video streaming to API calls.  The only thing that is known for sure is that the request will be made over HTTP. <br><br><h2>  ECMP: "Lesser Evil" </h2><br>  Another known alternative is ECMP (Equal Cost Multi-Path).  ECMP maps to the same destination prefix several subsequent network sections, and the selection of such a section is determined by hashing the fields in the header of the packet being forwarded.  By calculating the hash of such fields that do not change during the life of the stream (source addresses, destinations, and ports), we can be sure that all packets of the stream are sent to the same next network segment. <br><br>  Servers can signal via BGP that they are available to a connected switch that hashes packets. <br><br><img src="https://habrastorage.org/files/fd5/939/8b3/fd59398b3d5d45d89734094ea11e8876.png"><br>  <em>Fig.</em>  <em>9: Balancing through the ECMP switch and the corresponding packet flow at the time of the re-cache.</em> <br><br>  The disadvantage of this approach is that, until recently, manufacturers did not maintain a consistent hash in ECMP.  When changing the route caused by the addition or exclusion of the server, the hash result could change, which is why packets could be sent to another server.  This situation is shown in Fig.  9 (b). <br><br>  Despite this, ECMP remains a popular approach in the CDN industry.  By discarding state tracking, ECMP works well with stable server operation, creating connection problems when changing states. <br><br><h2>  "Elastic" ECMP: first approximation </h2><br>  Rehashing happens when the information about the routes changes (the next sections of the network).  A possible alternative would be to use ARP tables as a workaround.  By specifying the following static network sections in the routing table, we can force the switch to search the ARP table.  We can also reconfigure the ARP table to affect packet forwarding. <br><br>  Two problems arise: <br><br><ol><li>  <strong>We can no longer use routing protocols, such as BGP or OSPF, to direct traffic to servers.</strong>  Conventional routing protocols provide accessibility by modifying the routing table, but our approach takes traffic management to the connection layer.  We need to write a controller that directly changes the ARP table on the switch, as shown in Figure 10. The controller communicates with agents running on the connected caches.  Each agent checks the state of the local Varnish entity, which processes http requests from end clients. <br><br><img src="https://habrastorage.org/files/4c0/efc/843/4c0efc8431dd4828b34a68ba5b93659e.png"><br>  <em>Fig.</em>  <em>10. Custom routing protocol based on changing the ARP-table.</em>  <em>The routing table remains constant, and the ARP table is modified to indicate available servers.</em> <br></li><li>  <strong>The depth of detail with which we can balance traffic is now directly related to the number of the following network segments in the routing table.</strong>  As shown in fig.  10, if we remove the server serving the traffic, we need to rewrite the ARP entry so that it points to the available server, potentially doubling the traffic to another server.  To avoid this, we can create several following network sections, as shown in Fig.  11. If we have two next virtual network sections for each server, then the available servers will have an equal number of ARP entries pointing to them when server B stops working. <br><br><img src="https://habrastorage.org/files/af2/0ec/93f/af20ec93fe574063958d12788db877b0.png"><br>  <em>Fig.</em>  <em>11. The following additional network sections ensure uniform traffic distribution when server B stops working.</em> </li></ol><br><h2>  Faild: bypass layer </h2><br>  ‚ÄúElastic‚Äù ECMR still cannot provide accurate server output from the number of workers.  Let's go back to pic.  11. If host B fails, it will cause traffic to go to all remaining servers.  All existing connections will be reset. <br><br>  It is believed that this is inevitable, and it is worthwhile to put up with it, because it is caused by rare phenomena of hardware failure or software problems.  However, in practice, servers are often derived from ‚Äúproduction‚Äù in order to upgrade software.  Dropping connections due to this causes not only a temporary traffic problem.  This makes it difficult to quickly introduce new software, since every upgrade will cause problems. <br><br>  Proper failover cannot be implemented only on the switch, since it does not ‚Äúknow‚Äù which threads are active at any given time.  Our solution was to distribute state tracking between the controller and the hosts.  For this we have developed our own solution Faild. <br><br>  The first step to tidying the server out of production is to signal that.  Although our previous examples assumed that the host interface has only one MAC address, in practice there is no such limitation.  We can add to the ARP table on the switch not only information about the previously running host, but also about the new one (Fig. 12). <br><br><img src="https://habrastorage.org/files/c7b/490/4f8/c7b4904f834f4ee19b4905b82178ac06.png"><br>  <em>Fig.</em>  <em>12. Coding of hosts to replace broken via MAC addresses</em> <br><br>  Now that we have transmitted the availability information to the switch, we can delegate the balancing decision to the servers.  This not only eliminates the need to monitor the status of flows in the network.  It also transfers the computational load to the servers, which are larger at the point of presence than the switches. <br><br>  This computational load is reduced through the implementation of processing on the receiving side as a separate kernel module.  It effectively processes incoming packets according to the destination MAC address (see Figure 13). <br><br><img src="https://habrastorage.org/files/880/d9d/f72/880d9df725b74305889f602024505036.png"><br>  <em>Fig.</em>  <em>13. An example of packet processing on the receiving side when traffic is transferred from host B to host A. Packets are filtered on host A and are only accepted if they belong to a new connection or match a local TCP socket.</em> <br><br>  The kernel module of the receiving host must first determine whether the previous destination matches this host.  If yes, then processing is transferred to the local network stack.  If not, you need to make sure that the packet belongs to the new connection (via the SYN flag in the TCP header - step 2), or to an existing connection, which can be done through a search in the socket table (step 3). <br><br>  If none of these conditions are met, the packet is redirected to the previous destination via rewriting the MAC header. <br><br>  Similar logic applies on host B (step 5).  In this case, the host specified as the previous destination corresponds to the host, so the packet is accepted. <br><br><img src="https://habrastorage.org/files/414/6c0/2f9/4146c02f966e4105a4c8806f62187369.png"><br>  <em>Fig.</em>  <em>14. Load graph (requests per second) on a cluster of servers during a sequential kernel upgrade.</em>  <em>Hosts leave and return to "production" without affecting the service.</em> <br><br>  The introduction of Faild over the past 3 years has affected not only the work with traffic.  By reducing the negative impact of the required work on the servers, Faild allowed us to deploy new software faster, without affecting customers, as well as speeding up our reaction to the detection of vulnerabilities. <br><br><h2>  Results </h2><br>  Fastly has reached a volume of millions of requests per second since the Faild solution was introduced in 2013.  <em>A significant contribution to this was made by ‚Äúelastic‚Äù balancing, which reduces the cost of reconfiguring the network without loss to users.</em> <br><br>  Through the combination of ECMP, rewriting of ARP and manipulation with the core, this growth was supported by custom solutions, without acquiring anything more complicated than ordinary switches. </div><p>Source: <a href="https://habr.com/ru/post/322946/">https://habr.com/ru/post/322946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322936/index.html">Four key Linux skills in 2017</a></li>
<li><a href="../322938/index.html">How IT professionals work. Alexander Kozlov, team leader of SimbirSoft</a></li>
<li><a href="../322940/index.html">SharePoint 2013/2016 Monitoring: Key Performance Counters</a></li>
<li><a href="../322942/index.html">Open online courses from ITMO University: March version</a></li>
<li><a href="../322944/index.html">Diagnostics servers FirstDEDIC</a></li>
<li><a href="../322950/index.html">So, we made a 150 GB JVM dump. What's next?</a></li>
<li><a href="../322952/index.html">Translation of an interview with Julian Dragos (Scala)</a></li>
<li><a href="../322954/index.html">Simple Python program for hyperbolic approximation of statistical data</a></li>
<li><a href="../322956/index.html">Exceptions in Windows x64. How it works. Part 2</a></li>
<li><a href="../322958/index.html">Material UI and A / B tests are outdated - the future is behind adaptive interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>