<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generalized copying of connected object graphs in C # and nuances of their serialization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The tasks of copying individual objects and connected graphs are often found in programming. There are several methods for solving them, depending on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generalized copying of connected object graphs in C # and nuances of their serialization</h1><div class="post__text post__text-html js-mediator-article">  The tasks of copying individual objects and connected graphs are often found in programming.  There are several methods for solving them, depending on the initial conditions and requirements.  The purpose of the article is to examine key types of solutions, identify the scope, highlight the advantages and disadvantages <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb4/bec/1cd/cb4bec1cde8e695b2b449a4dfb179668.png" alt="image"></div><a name="habracut"></a><br><h3>  Classification of approaches to copying </h3><br><h4>  1) by generalization: routine and generalized </h4><br>  Routine approaches imply the implementation of their own copying logic for each particular class, that is, the creation of a number of special utility methods responsible for copying certain entities.  These methods often contain boring and monotonous code in large volumes.  Manual writing of such methods is tedious and fraught with errors.  However, automatic code generators facilitate this task, although they often impose their own restrictions on objects and the structure of graphs.  The advantage of these techniques is their high performance with low memory consumption.  They are usually used in protobuf serializers. <br><br>  Generalized approaches, however, are spared the need to write additional logic of the same type due to a slight decrease in performance, and also apply to objects of various types that meet certain requirements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2) by the possibilities of serialization and deserialization: without support, with accurate and ultra-precise support </h4><br>  Serialization assumes the ability to save information about the state of an object graph into a string or an array of bytes, and deserialization means to restore the graph to its original state using this information, which, in turn, allows using these mechanisms for deep copying.  There are many alternative implementations of serializers for various formats, however, even being close to the destination, they are very different in nuances.  But one way or another, they can be divided into two classes: exact, which in certain cases bring their own distortions into the copy, and ultra-precise ones, which allow you to restore complex graphs without changes. <br><br>  Distortions are most often of the following nature: <br><br>  - violation of the reference structure of the graph <br>  [reasons: several references to one object, closed circular references] <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> role = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Role(); person.MainRole = role; <span class="hljs-comment"><span class="hljs-comment">// use the one 'role' instance before serialization person.Roles.Add(role); // but possible two separated instances after graph deserialization</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> role = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Role {Person = person}; person.Roles.Add(role); <span class="hljs-comment"><span class="hljs-comment">// may cause stack overflow exception</span></span></code> </pre> <br>  - loss of information about the types of objects <br>  [reasons: reference to object with type of base class is used] <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// may cause exception on deserialization [DataMember]public object SingleObject = new Person(); [DataMember]public object[] Array = new [] { new Person() };</span></span></code> </pre> <br>  - distortion of related primitive types <br>  [reasons: limitations of serialization formats] <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DataMember</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SingleObject = <span class="hljs-number"><span class="hljs-number">12345L</span></span>; <span class="hljs-comment"><span class="hljs-comment">// long may be deserialized like int, Guid like string [DataMember]public object[] Array = new [] { 123, 123L, Guid.New(), Guid.New().ToString() };</span></span></code> </pre> <br>  - loss of properties when serializing collection classes <br>  [reasons: limitations of serializers] <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CollectionDataContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomCollection</span></span>: <span class="hljs-title"><span class="hljs-title">List</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// property may be lost [DataMember]public string Name { get; set; } }</span></span></code> </pre> <br>  - individual limitations of serializers <br>  [reasons: for example, multidimensional arrays (object [,,,])] <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// may cause exception on serialization [DataMember]public int[,,] Multiarray = new {{{1,2,3}, {7,8,9}}};</span></span></code> </pre> <br>  <i>* the listed disadvantages are inherent even to the standard DataContractJsonSerializer</i> <br><br><h3>  Classification of generalized copying methods </h3><br><h4>  1) according to the structure of the graph: surface and deep </h4><br>  Shallow and deep copying is fundamentally different.  Let objects A and B be given, moreover, A contains a reference to B (column A =&gt; B).  At the surface copying of object A, object A 'will be created, which will also refer to B, that is, in the end, we get two columns A =&gt; B and A' =&gt; B.  They will have a common part B, so when changing object B in the first column, its state will automatically mutate in the second one.  Objects A and A 'will remain independent.  But the most interesting are the graphs with closed (cyclic) links.  Let A refer to B and B refer to A (A &lt;=&gt; B), when copying object A to A, we get a very unusual graph A '=&gt; B &lt;=&gt; A, that is, the original object got into the final graph subjected to cloning.  Deep copying involves the cloning of all objects included in the graph.  For our case, A &lt;=&gt; B is converted to A '&lt;=&gt; B', as a result, both graphs are completely isolated from each other.  In some cases, superficial copying is sufficient, but not always. <br><br><h4>  2) in terms of the state of the graph: full and partial </h4><br>  As for the state, when copying, it can be reproduced completely, that is, you get a completely identical clone, or partially, limited to only the essential data for solving the problem, for example, copy only public members or those marked with special attributes. <br><br><h3>  Overview of basic copying techniques </h3><br><h4>  1) MemberwiseClone coupled with reflection </h4><br>  To implement shallow copy [shallow copy] of an object in the .NET platform, a special protected [protected] method MemberwiseClone of the object class is provided, which creates a complete copy of the object by copying all its fields.  Using this method in combination with reflection, you can implement a recursive deep copy algorithm. <br><br>  Pros: <br>  - portable <br>  - works fast <br>  - does not need public and default constructors to create an object <br><br>  Minuses: <br>  - it is impossible to serialize and deserialize objects <br>  - copies all fields in a row without the possibility of filtering them <br><br><div class="spoiler">  <b class="spoiler_title">Implementing Deep Memberwise Cloning in the Replication Framework Library</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.CompilerServices; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Art.Comparers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReferenceComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IEqualityComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReferenceComparer&lt;T&gt; Default = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceComparer&lt;T&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span> =&gt; RuntimeHelpers.GetHashCode(obj); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T x, T y</span></span></span><span class="hljs-function">)</span></span> =&gt; ReferenceEquals(x, y); } }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Art.Comparers; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Art</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cloning</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Type&gt; LikeImmutableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Type&gt; {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Regex)}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T MemberwiseClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T origin, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> deepMode, IEqualityComparer&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; comparer = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) =&gt; deepMode ? (T) origin.GetDeepClone(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(comparer ?? ReferenceComparer&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;.Default)) : (T) MemberwiseCloneMethod.Invoke(origin, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MethodInfo MemberwiseCloneMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>).GetMethod(<span class="hljs-string"><span class="hljs-string">"MemberwiseClone"</span></span>, BindingFlags.NonPublic | BindingFlags.Instance); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;FieldInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumerateFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type type, BindingFlags bindingFlags</span></span></span><span class="hljs-function">)</span></span> =&gt; type.BaseType?.EnumerateFields(bindingFlags) .Concat(type.GetFields(bindingFlags | BindingFlags.DeclaredOnly)) ?? type.GetFields(bindingFlags); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsLikeImmutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type type</span></span></span><span class="hljs-function">)</span></span> =&gt; type.IsValueType || LikeImmutableTypes.Contains(type); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDeepClone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> origin, IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; originToClone</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (origin == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = origin.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.IsLikeImmutable()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> origin; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (originToClone.TryGetValue(origin, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clone)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clone; clone = MemberwiseCloneMethod.Invoke(origin, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); originToClone.Add(origin, clone); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.IsArray &amp;&amp; !type.GetElementType().IsLikeImmutable()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = (Array) clone; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[array.Rank]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dimensions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[array.Rank]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Rank; i++) dimensions[i] = array.GetLength(i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = indices.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; j--) { indices[j] = t % dimensions[j]; t /= dimensions[j]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deepClone = array.GetValue(indices).GetDeepClone(originToClone); array.SetValue(deepClone, indices); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = type.EnumerateFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fields.Where(f =&gt; !f.FieldType.IsLikeImmutable())) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deepClone = field.GetValue(origin).GetDeepClone(originToClone); field.SetValue(origin, deepClone); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clone; } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Application of this extension</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> role = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Role(); person.Roles.Add(role); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deepClone = person.MemberwiseClone(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br></div></div><br>  <i>* alternative but slightly non-optimal implementations of this technique are <a href="">one</a> and <a href="https://www.codeproject.com/Articles/38270/Deep-copy-of-objects-in-C">two</a></i> <br><br><h4>  2) Comparison of the functionality of some modern serialization libraries </h4><br><img src="https://habrastorage.org/web/076/366/888/076366888a7e4eaa9664779f128fd1da.png"><br><br>  In terms of functionality, a completely new library, the <a href="">Replication Framework</a> , about which a <a href="https://habrahabr.ru/post/330294/">review publication</a> on Habr√© appeared not very long ago, provides good expectations.  Although it is designed to solve a wider range of tasks, one of the key requirements for its development was the implementation of deep copying and ultra-precise [de] serialization of arbitrarily complex graphs. <br><br>  The licensed version of Replication Framework is free for non-commercial and educational use and is available <a href="http://makeman%40tut.by/">upon request.</a>  The trial version <a href="https://www.nuget.org/packages/Art.ReplicationFramework.Trial/">for nuget is</a> functional until September 2017. <br><br><div class="spoiler">  <b class="spoiler_title">Replication Framework performance note</b> <div class="spoiler_text">  It may be asked why Replication Framework allows copying objects faster than other serializers, but loses in speed in the serialization and deserialization processes themselves.  The point is that for copying the library uses snapshots of objects [Snapshots], and not arrays of bytes or strings, that is, no primitive values ‚Äã‚Äãare converted, due to which acceleration is achieved.  When serializing, a snapshot is first created, and after that it is converted to a json string.  It is because of this intermediate step that the speed of serialization and subsequent deserialization decreases (reading a snapshot and then recreating the graph on it). <br></div></div><br><br><h3>  Implementing C # Deep Copy Methods </h3><br><div class="spoiler">  <b class="spoiler_title">BinaryFormatter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); formatter.Serialize(ms, obj); ms.Position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) formatter.Deserialize(ms); } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">DataContractSerializer</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-comment"><span class="hljs-comment">// preserveObjectReferences==true to save valid reference structure of graph var serializer = new DataContractSerializer(typeof(T), null, int.MaxValue, false, true, null); serializer.WriteObject(ms, obj); ms.Position = 0; return (T) serializer.ReadObject(ms); } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">DataContractJsonSerializer</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataContractJsonSerializer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)); serializer.WriteObject(ms, obj); ms.Position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) serializer.ReadObject(ms); } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Newtonsoft.Json</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = JsonConvert.SerializeObject(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonConvert.DeserializeObject&lt;T&gt;(json); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Replication Framework via Memberwise Clone</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetShallowClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) =&gt; obj.MemberwiseClone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) =&gt; obj.MemberwiseClone(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Replication Framework via Snapshot</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetDeepClone&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snapshot = obj.CreateSnapshot(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapshot.ReplicateGraph&lt;T&gt;(); }</code> </pre> </div></div><br>  Everything! </div><p>Source: <a href="https://habr.com/ru/post/332516/">https://habr.com/ru/post/332516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332500/index.html">Core ML Testing and Review</a></li>
<li><a href="../332502/index.html">Linux log files in order</a></li>
<li><a href="../332504/index.html">Who owns the data generated by devices from the Internet of things?</a></li>
<li><a href="../332506/index.html">How to confuse the analyst. Part Three Verbs and numerals</a></li>
<li><a href="../332508/index.html">Automata programming. Part 2. State and transition diagrams</a></li>
<li><a href="../332518/index.html">InnoDB cluster - it works, and it seems to be exactly as promised</a></li>
<li><a href="../332520/index.html">Moneyball on the exchange: how new technologies change not only trading, but also the work of hedge funds</a></li>
<li><a href="../332522/index.html">Amazon, Apple, and Microsoft Shares Equal to Due to Technical Failure</a></li>
<li><a href="../332524/index.html">On the role of interfaces in the context of existentialism</a></li>
<li><a href="../332526/index.html">You are a big brother, or try yourself as an all-seeing eye.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>