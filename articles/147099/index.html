<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple multithreaded data access and atomic variables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Alexander Sandler , original article (December 23, 2008) 

 Introduction 
 In this article I would like to continue the topic begun in my prev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple multithreaded data access and atomic variables</h1><div class="post__text post__text-html js-mediator-article">  Author: <a href="http://www.alexonlinux.com/">Alexander Sandler</a> , <a href="http://www.alexonlinux.com/multithreaded-simple-data-type-access-and-atomic-variables">original article (December 23, 2008)</a> <br><br><h4>  Introduction </h4><br>  In this article I would like to continue the topic begun in my previous posts (see below - note of the translation).  A question that I will try to answer is what is the most effective and secure way to access variables of simple data type from two or more streams.  That is, how to change a variable from two threads at the same time without violating its value. <br><a name="habracut"></a><br>  In my first post ( <a href="http://www.alexandersandler.net/do-you-need-mutex-to-protect-int">‚ÄúDo I need a mutex to protect int‚Äù</a> ), I showed how easy it is to turn a variable's value into garbage, changing it from two or more threads.  In my second article ( <a href="http://www.alexandersandler.net/pthread-spinlocks">‚Äúspin-lock pthread‚Äù</a> ), I talked about spin-locks (spinlocks), the latest addition to the <i>pthread</i> library.  Spin-blocking can really help solve the problem.  However, they are more suitable for protecting small data structures than simple data types, such as <i>int</i> and <i>long</i> .  On the other hand, atomic variables are ideal for these tasks. <br><br>  The key point about atomic variables is that as soon as someone starts to read or write them, nothing can interrupt the process and happen in the middle.  That is, nothing can break the access to the atomic variable into two parts.  Therefore, they are called so. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the practical side, atomic variables are the best solution for the problem of simultaneous access to a simple variable of two or more threads. <br><br><h4>  How atomic variables work </h4><br>  In fact, very simple.  The architectures of the Intel x86 and x86_64 processors (as well as the vast majority of other modern processor architectures) have instructions for blocking the FSB during any memory access operation.  FSB stands for Front Side Bus ( <a href="http://ru.wikipedia.org/wiki/Front_Side_Bus">"front tire"</a> - approx. Lane.).  This is the bus that the processor uses to communicate with the RAM.  That is, blocking the FSB will prevent any other processor (core) and process running on this processor from gaining access to the RAM.  And this is exactly what we need to implement atomic variables. <br><br>  Atomic variables are widely used in the Linux kernel, but for some reason no one bothered to implement them for the human user mode.  Up to GCC 4.1.2. <br><br><h4>  Limiting the size of atomic variables </h4><br>  For practical reasons, gurus from Intel did not implement FSB locks with every possible memory access.  For example, to save time, Intel processors allow the memcpy () and memcmp () implementations to be implemented in the same processor instruction.  But locking the FSB when copying a large memory buffer may be too expensive. <br><br>  In practice, you can block the FSB by accessing integers of 1, 2, 4, and 8 bytes.  GCC allows you to do atomic operations almost transparently with <i>int</i> , <i>long,</i> and <i>long long</i> (and their unsigned equivalents). <br><br><h4>  Application options </h4><br>  Increasing a variable, knowing that no one else will damage its value is good, but not enough.  Consider the following pseudocode fragment. <br><br><pre><code class="cpp hljs">decrement_atomic_value(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_value() == <span class="hljs-number"><span class="hljs-number">0</span></span>) fire_a_gun();</code> </pre> <br>  Imagine that the value of an atomic variable is 1. What happens if two threads try to execute this part of the pseudo-C at the same time? <br><br>  Let's return to our modeling.  It is possible that flow 1 will execute line 1 and stop, while flow 2 will execute line 1 and continue execution of line 2. Later, flow 1 will wake up and execute line 2. <br><br><img src="https://habrastorage.org/storage2/1e2/67b/069/1e267b0697dc7909ad2b4b1784f10f05.png"><br><br>  When this happens, none of the threads start the <i>fire_a_gun ()</i> procedure (line 3).  Obviously, this is an incorrect behavior, and if we protected this part of the code with a mutex or spinlock, this would not have happened. <br><br><blockquote>  <i>In case you are wondering what the likelihood is that something like this happens, be sure - this is very likely.</i>  <i>When I first started working with multithreaded programming, I was amazed to learn that despite the fact that our intuition tells us that the scenario I described earlier is unlikely - it happens extremely often.</i> <i><br></i> </blockquote><br>  As I already said, we could solve this problem by rejecting atomic variables and using a spin lock or mutex instead.  Fortunately, we can still use atomic variables.  GCC developers thought about our needs and this particular problem and offered a solution.  Let's look at the actual procedures that operate on atomic variables. <br><br><h4>  In the reality... </h4><br>  There are some simple functions that make this work.  First of all, there are twelve (yes, twelve - 12) functions that make atomic addition, replacement, and logical atomic or, and, xor, and nand.  There are two functions for each operation.  One that returns the value of a variable before changing it, and another that returns the value of a variable after changing it. <br><br>  Here are the actual functions: <br><pre> <code class="cpp hljs">type __sync_fetch_and_add (type *ptr, type value); type __sync_fetch_and_sub (type *ptr, type value); type __sync_fetch_and_or (type *ptr, type value); type __sync_fetch_and_and (type *ptr, type value); type __sync_fetch_and_xor (type *ptr, type value); type __sync_fetch_and_nand (type *ptr, type value);</code> </pre><br>  These are functions that return the value of a variable before changing.  The following functions, on the other hand, return the value of a variable after changing it. <br><pre> <code class="cpp hljs">type __sync_add_and_fetch (type *ptr, type value); type __sync_sub_and_fetch (type *ptr, type value); type __sync_or_and_fetch (type *ptr, type value); type __sync_and_and_fetch (type *ptr, type value); type __sync_xor_and_fetch (type *ptr, type value); type __sync_nand_and_fetch (type *ptr, type value);</code> </pre><br>  <i>The type</i> in each of the expressions can be one of the following: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span></code> </pre><br>  These are called built-in functions, which means that you do not need to include any header files to use them. <br><br><h4>  It's time to see this in action. </h4><br>  Returning to the example that I started in the first post, which was mentioned earlier. <br>  Let me remind you that this is a small program that opens several threads.  The number of threads is equal to the number of processors in the computer.  Then it binds each of the threads to one of the processors.  Finally, each thread starts the loop and increments the global integer one million times. <br><br><div class="spoiler">  <b class="spoiler_title">Source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;sched.h&gt; #include &lt;linux/unistd.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;errno.h&gt; #define INC_TO 1000000 //  ... int global_int = 0; pid_t gettid( void ) { return syscall( __NR_gettid ); } void *thread_routine( void *arg ) { int i; int proc_num = (int)(long)arg; cpu_set_t set; CPU_ZERO( &amp;set ); CPU_SET( proc_num, &amp;set ); if (sched_setaffinity( gettid(), sizeof( cpu_set_t ), &amp;set )) { perror( "sched_setaffinity" ); return NULL; } for (i = 0; i &lt; INC_TO; i++) { // global_int++; __sync_fetch_and_add( &amp;global_int, 1 ); } return NULL; } int main() { int procs = 0; int i; pthread_t *thrs; //    procs = (int)sysconf( _SC_NPROCESSORS_ONLN ); if (procs &lt; 0) { perror( "sysconf" ); return -1; } thrs = malloc( sizeof( pthread_t ) * procs ); if (thrs == NULL) { perror( "malloc" ); return -1; } printf( "Starting %d threads...\n", procs ); for (i = 0; i &lt; procs; i++) { if (pthread_create( &amp;thrs[i], NULL, thread_routine, (void *)(long)i )) { perror( "pthread_create" ); procs = i; break; } } for (i = 0; i &lt; procs; i++) pthread_join( thrs[i], NULL ); free( thrs ); printf( "  ,  global_int value : %d\n", global_int ); printf( "  : %d\n", INC_TO * procs ); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Notice lines 36 and 37. Instead of simply increasing the variable, I use the built-in function <i>__ sync_fetch_and_add ()</i> .  Running this code obviously yields the expected results ‚Äî that is, the <i>global_int</i> value is 4,000,000, as expected (the number of processors in the machine multiplied by one million ‚Äî in my case, a quad-core machine).  Remember, <a href="http://www.alexonlinux.com/do-you-need-mutex-to-protect-int">when I launched this code snippet, leaving line 36 as it is</a> , the result was 1,908,090, not 4,000,000, as we expected. <br><br><h4>  Precautions </h4><br>  When using atomic variables, some additional precautions must be taken.  One of the serious problems with the implementation of the atomic variable in the GCC is that it allows you to perform atomic operations on ordinary variables.  That is, there is no clear distinction between atomic and ordinary variables.  Nothing prevents you from increasing the value of an atomic variable with <i>__ sync_fetch_and_add ()</i> , as I just demonstrated, and then in the code, do the same with the usual ++ operator. <br>  Obviously, this can be a serious problem.  Things tend to be forgotten and it is only a matter of time until someone from your project or even you yourself begin to change the value of a variable using ordinary operators instead of atomic functions provided by GCC. <br>  To solve this problem, I strongly recommend wrapping atomic functions and variables either using ADT (Abstract Data Type) in C, or using the C ++ class. <br><br><h4>  Conclusion </h4><br>  This article concludes a series of articles and posts where research and study of the latest technologies in the world of multi-threaded programming for Linux is conducted.  I hope you find these posts and posts helpful.  As usual, in case you have additional questions, please feel free to email me (specified in the original - approx. Lane) <br><br>  <i>Translator's Note</i> <i><br><br></i>  <i>This and other articles of the author do not pretend to be complete coverage of the material on the topic, but they have a good introductory style of presentation.</i> <i><br><br></i>  <i>I note that at the moment atomic variables:</i> <i><br></i> <ul><li>  <i>described in standards <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">C11 (clause 7.17)</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C ++ 11 (clause 29)</a> - their implementations are available in most cases (true, for C11, there are still problems);</i> </li><li>  <i>described and implemented for Boost as <a href="http://www.chaoticmind.net/~hcb/projects/boost.atomic/doc/index.html">Boost.Atomic</a> (however, this implementation was never <a href="http://lists.boost.org/Archives/boost/2012/05/193508.php">included</a> in boost 1.50);</i> </li><li>  <i>implemented in <a href="http://threadingbuildingblocks.org/">Intel Threading Building Blocks</a> .</i> </li></ul> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/147099/">https://habr.com/ru/post/147099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147093/index.html">User rating by several parameters</a></li>
<li><a href="../147095/index.html">A simple bash solution for sharing music and photos on Dropbox</a></li>
<li><a href="../147096/index.html">Fast integer division by constant</a></li>
<li><a href="../147097/index.html">How to make your life easier in Xcode. Shortcuts, tips & tricks</a></li>
<li><a href="../147098/index.html">11 "recipes for cooking" MySQL in Bitrix24</a></li>
<li><a href="../1471/index.html">Kaspersky Lab releases Spam Report for May 2006</a></li>
<li><a href="../14710/index.html">Microsoft publishes source files for most of the .Net Framework 3.5 libraries.</a></li>
<li><a href="../147100/index.html">Higgs Boson and Mass Transfer</a></li>
<li><a href="../147101/index.html">Stas Protasov from Parallels answered the questions of the habrasoobshchestva</a></li>
<li><a href="../147103/index.html">Runetology (154): Nikate Androsov, Head of Ingate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>