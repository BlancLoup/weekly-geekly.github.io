<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedurally Generated World Maps on Unity C #, Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second article in a series on procedurally generated maps using Unity and C # maps of the world. The cycle will consist of four articles. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedurally Generated World Maps on Unity C #, Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b0c/73f/8b4/b0c73f8b487c4da38778d99e99d9bdac.png" alt="image"><br><br>  This is the second article in a series on procedurally generated maps using Unity and C # maps of the world.  The cycle will consist of four articles. <br><a name="habracut"></a><br>  <b>Content</b> <br><br>  <a href="https://habrahabr.ru/post/276251/">Part 1</a> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Introduction <br>  Noise generation <br>  Beginning of work <br>  Generate elevation map <br><br>  Part 2 (this article): <br><br>  Map folding on one axis <br>  Map folding on both axes <br>  Neighbor Search <br>  Bit masks <br>  Fill <br><br>  <a href="https://habrahabr.ru/post/276533/">Part 3</a> : <br><br>  Heat map generation <br>  Humidity Map Generation <br>  River generation <br><br>  <a href="https://habrahabr.ru/post/276551/">Part 4</a> : <br><br>  Biome generation <br>  Spherical map generation <br><br>  <b>Map folding on one axis</b> <br><br>  <i>(From the translator: I am not sure that wrapping in the context of mathematical terminology translates as "folding." If someone knows a more appropriate term, write, correct.)</i> <br><br>  In the <a href="https://habrahabr.ru/post/276251/">first part of the</a> cycle, we set up a small framework that will help us create maps.  The height map we created earlier cannot be glued together. <br><br>  This happened because we created two-dimensional noise data that cannot provide what we need.  For the seamless folding of our world, we will add a new dimension to our noise generator. <br><br>  With the help of three-dimensional noise, we can create data in a circular arrangement, while the final two-dimensional data can be rolled along one axis.  The created data is like a cylinder in three-dimensional space. <br><br><img src="https://habrastorage.org/files/036/498/594/036498594a2541ca8fa648f49a78b345.png" alt="image"><br><br>  Imagine that we cut this cylinder and spread it on a plane.  That is what we are going to do.  The edges along which we cut the cylinder will not have a visible seam when gluing together. <br><br>  To do this, you need to change the GetData function in the Generator class. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImplicitModuleBase module, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MapData mapData</span></span></span><span class="hljs-function">)</span></span> { mapData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapData (Width, Height); <span class="hljs-comment"><span class="hljs-comment">//      x,y -    for (var x = 0; x &lt; Width; x++) { for (var y = 0; y &lt; Height; y++) { //  float x1 = 0, x2 = 1; float y1 = 0, y2 = 1; float dx = x2 - x1; float dy = y2 - y1; //     float s = x / (float)Width; float t = y / (float)Height; //    float nx = x1 + Mathf.Cos (s * 2 * Mathf.PI) * dx / (2 * Mathf.PI); float ny = x1 + Mathf.Sin (s * 2 * Mathf.PI) * dx / (2 * Mathf.PI); float nz = t; float heightValue = (float)HeightMap.Get (nx, ny, nz); //       if (heightValue &gt; mapData.Max) mapData.Max = heightValue; if (heightValue &lt; mapData.Min) mapData.Min = heightValue; mapData.Data [x, y] = heightValue; } } }</span></span></code> </pre> <br>  Running this code will give us a great texture that can roll on the X axis. <br><br><img src="https://habrastorage.org/files/72a/9df/d3d/72a9dfd3da114959873aee5dcf7682a8.png" alt="image"><br><br>  <b>Map folding on both axes</b> <br><br>  In order for our map to roll up on both axes, we need to create four-dimensional noise.  This concept is not so easy to understand, it is difficult for our brain to think in four-dimensional space, but it is rather similar to the example of three-dimensional noise. <br><br>  Instead of one cylinder, we will have two cylinders connected in four-dimensional space. <br><br>  It should be noted that the creation of four-dimensional data takes much more time than two-dimensional. <br><br>  The updated GetData () function will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImplicitModuleBase module, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MapData mapData</span></span></span><span class="hljs-function">)</span></span> { mapData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapData (Width, Height); <span class="hljs-comment"><span class="hljs-comment">//      x,y -    for (var x = 0; x &lt; Width; x++) { for (var y = 0; y &lt; Height; y++) { //   float x1 = 0, x2 = 2; float y1 = 0, y2 = 2; float dx = x2 - x1; float dy = y2 - y1; //      float s = x / (float)Width; float t = y / (float)Height; //    float nx = x1 + Mathf.Cos (s*2*Mathf.PI) * dx/(2*Mathf.PI); float ny = y1 + Mathf.Cos (t*2*Mathf.PI) * dy/(2*Mathf.PI); float nz = x1 + Mathf.Sin (s*2*Mathf.PI) * dx/(2*Mathf.PI); float nw = y1 + Mathf.Sin (t*2*Mathf.PI) * dy/(2*Mathf.PI); float heightValue = (float)HeightMap.Get (nx, ny, nz, nw); //       if (heightValue &gt; mapData.Max) mapData.Max = heightValue; if (heightValue &lt; mapData.Min) mapData.Min = heightValue; mapData.Data[x,y] = heightValue; } } }</span></span></code> </pre><br>  This code creates a seamless texture procedurally generated from four-dimensional noise. <br><br><img src="https://habrastorage.org/files/cbf/7c9/d57/cbf7c9d57e99498ab0f8a9bff1946b87.png" alt="image"><br><br>  If you want to know more about how this works, read <a href="http://ronvalstar.nl/creating-tileable-noise-maps">this</a> and <a href="http://www.gamedev.net/blog/33/entry-2138456-seamless-noise/">this</a> article. <br><br>  <b>Neighbor Search</b> <br><br>  Now we have a seamless elevation map, and we are starting to approach our goal.  Now we focus on the class Tile. <br><br>  It would be very useful if each Tile object had a pointer to each of the adjacent objects (top, bottom, right and left).  This is useful for tasks such as creating paths, bitmasks, and fills.  Later we will look at these aspects in the article. <br><br>  First we need to create variables in the Tile class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tile Left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tile Right; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tile Top; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tile Bottom;</code> </pre><br>  The next part is pretty simple.  We go through each tile, getting adjacent tiles to it.  First, we will create several functions inside the Generator class to make it easier to get the neighbors of the Tile object. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tiles [tX, MathHelper.Mod (tY - <span class="hljs-number"><span class="hljs-number">1</span></span>, Height)]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tiles [tX, MathHelper.Mod (tY + <span class="hljs-number"><span class="hljs-number">1</span></span>, Height)]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLeft</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tiles [MathHelper.Mod(tX - <span class="hljs-number"><span class="hljs-number">1</span></span>, Width), tY]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tiles [MathHelper.Mod (tX + <span class="hljs-number"><span class="hljs-number">1</span></span>, Width), tY]; }</code> </pre><br>  MathHelper.Mod () collapses the x and y values ‚Äã‚Äãbased on the width and height of the map.  In this way, we will never go beyond the map. <br><br>  Then we need to create a function that assigns neighbors. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNeighbors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; Width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; Height; y++) { Tile t = Tiles[x,y]; t.Top = GetTop(t); t.Bottom = GetBottom (t); t.Left = GetLeft (t); t.Right = GetRight (t); } } }</code> </pre><br>  Visually, she still does not so much.  However, now each Tile object ‚Äúknows‚Äù its neighbors, which is very important for further steps. <br><br>  <b>Bit masks</b> <br><br>  I decided to add this part to the article mainly for aesthetic reasons.  Creating a bitmask in this context is setting the value of each tile based on the values ‚Äã‚Äãof its neighbors.  Take a look at this illustration: <br><br><img src="https://habrastorage.org/files/363/83b/4eb/36383b4eb9be4040beb2eab8f609b690.png" alt="image"><br><br>  Based on the data of the tile neighbors, we increase the bit mask, as shown on the left in the illustration.  All options are shown on the right side.  Note that all values ‚Äã‚Äãare unique.  This allows you to quickly determine the configuration of the unit. <br><br>  The main advantage of a bitmask is the ability to assign a texture based on the value of the bitmask of each tile, which, with the right approach, makes the cards more beautiful and less grainy. <br><br>  Another convenience of the bitmask is that if the value of the tile's bitmask is not equal to 15, we know that it is not an extreme map tile. <br><br>  Add a function to the Tile class to perform the calculations.  We take into account only those neighbors that have the same type of height as the analyzed tile. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBitmask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Top.HeightType == HeightType) count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Right.HeightType == HeightType) count += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Bottom.HeightType == HeightType) count += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Left.HeightType == HeightType) count += <span class="hljs-number"><span class="hljs-number">8</span></span>; Bitmask = count; }</code> </pre><br>  Since we already have pointers to neighboring tiles, and also assigned a height type (HeightType), this calculation is rather trivial.  Now we will add a function to the Generator class to perform this calculation for all tiles: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBitmasks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; Width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; Height; y++) { Tiles [x, y].UpdateBitmask (); } } }</code> </pre><br>  Now if we change our TextureGenerator as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    if (tiles[x,y].Bitmask != 15) pixels[x + y * width] = Color.Lerp(pixels[x + y * width], Color.black, 0.4f);</span></span></code> </pre><br>  We will see a clear boundary between types of heights: <br><br><img src="https://habrastorage.org/files/b0c/73f/8b4/b0c73f8b487c4da38778d99e99d9bdac.png" alt="image"><br><br>  <b>Fill</b> <br><br>  It would be great to decide on the following questions: <br><br><ul><li>  where is the lake? </li><li>  Where are the oceans? </li><li>  where are the sushi arrays? </li><li>  what size is each of them? </li></ul><br><br>  We can answer this question with a simple fill algorithm. <br><br>  First we will create an object in which information about our tiles will be stored: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TileGroupType { Water, Land } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TileGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TileGroupType Type; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;Tile&gt; Tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TileGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Tile&gt; (); } }</code> </pre><br>  The TileGroup class will hold a pointer to a list of tiles.  He will also tell us whether a particular group is water or land. <br><br>  The principle is to divide the connected parts of land and water into TileGroup collections. <br><br>  We will also slightly modify the Tile class by adding two new variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Collidable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FloodFilled;</code> </pre><br>  Collidable is set in the LoadTiles () method.  Anything that is not a water tile will assign a ‚Äútrue‚Äù value to the variable Collidable.  The FloodFilled variable is used to track tiles that have already been processed by the fill algorithm. <br><br>  To add a fill algorithm to the Generator class, you first need a couple of TileGroup variables: <br><br><pre> <code class="cs hljs">List&lt;TileGroup&gt; Waters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TileGroup&gt; (); List&lt;TileGroup&gt; Lands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TileGroup&gt; ();</code> </pre><br>  Now we are ready to mark the land and water arrays on our map. <br><br>  Since the map can be very large, we cannot use a recursive fill because it quickly leads to the elimination of stack overflow.  Instead, we need to use a non-recursive approach to solving this problem: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloodFill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     Stack&lt;Tile&gt; stack = new Stack&lt;Tile&gt;(); for (int x = 0; x &lt; Width; x++) { for (int y = 0; y &lt; Height; y++) { Tile t = Tiles[x,y]; //  ,   if (t.FloodFilled) continue; //  if (t.Collidable) { TileGroup group = new TileGroup(); group.Type = TileGroupType.Land; stack.Push(t); while(stack.Count &gt; 0) { FloodFill(stack.Pop(), ref group, ref stack); } if (group.Tiles.Count &gt; 0) Lands.Add (group); } //  else { TileGroup group = new TileGroup(); group.Type = TileGroupType.Water; stack.Push(t); while(stack.Count &gt; 0) { FloodFill(stack.Pop(), ref group, ref stack); } if (group.Tiles.Count &gt; 0) Waters.Add (group); } } } } private void FloodFill(Tile tile, ref TileGroup tiles, ref Stack&lt;Tile&gt; stack) { //  if (tile.FloodFilled) return; if (tiles.Type == TileGroupType.Land &amp;&amp; !tile.Collidable) return; if (tiles.Type == TileGroupType.Water &amp;&amp; tile.Collidable) return; //   TileGroup tiles.Tiles.Add (tile); tile.FloodFilled = true; //   Tile t = GetTop (tile); if (!t.FloodFilled &amp;&amp; tile.Collidable == t.Collidable) stack.Push (t); t = GetBottom (tile); if (!t.FloodFilled &amp;&amp; tile.Collidable == t.Collidable) stack.Push (t); t = GetLeft (tile); if (!t.FloodFilled &amp;&amp; tile.Collidable == t.Collidable) stack.Push (t); t = GetRight (tile); if (!t.FloodFilled &amp;&amp; tile.Collidable == t.Collidable) stack.Push (t); }</span></span></code> </pre><br>  Using the above code, we separate the land and water arrays, and put them in TileGroups <br><br>  I generated a couple of textures to show how useful this data can be. <br><br><img src="https://habrastorage.org/files/d58/aa2/46c/d58aa246c01642c389341ac19ab8f778.png" alt="image"><img src="https://habrastorage.org/files/9bd/bcf/c92/9bdbcfc9275d4f758edc4f873df44a01.png" alt="image"><br><br>  On the left image, all sushi tiles are black.  Ocean tiles are blue, and lakes tiles are blue. <br><br>  On the right image all water tiles are blue.  Large land massifs have a dark green color, and the islands are light green. <br><br>  As you can see, we now have much more information about the generated map, and this information answers all the questions we raised. <br><br>  You can download the source code for the second part from github: <a href="https://github.com/jongallant/WorldGeneratorPart2">World Generator Part 2</a> . <br><br>  <a href="https://habrahabr.ru/post/276533/">Third part</a> </div><p>Source: <a href="https://habr.com/ru/post/276281/">https://habr.com/ru/post/276281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276269/index.html">Tor Browser 5.5 released</a></li>
<li><a href="../276271/index.html">Conceptual description of individuals</a></li>
<li><a href="../276273/index.html">XAML Developer Chips: Composite Converters</a></li>
<li><a href="../276275/index.html">Genemba - code generator for iOS development</a></li>
<li><a href="../276277/index.html">The Complete Guide to Using ASP.NET Core 1.0 (aka ASP.NET 5) Tag Helpers</a></li>
<li><a href="../276283/index.html">PHP Digest number 78 - interesting news, materials and tools (January 18 - 31, 2016)</a></li>
<li><a href="../276285/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ196 (January 25 - 31, 2016)</a></li>
<li><a href="../276289/index.html">Azure student offer adds support for SQL Azure and Mobile Apps</a></li>
<li><a href="../276291/index.html">Simplified single sign-on model for different cloud CRM configurations</a></li>
<li><a href="../276293/index.html">IT infrastructure, information security and telecom: Events in 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>