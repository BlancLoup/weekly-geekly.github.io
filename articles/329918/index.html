<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Native EcmaScript modules: new features and differences from webpack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article Native ECMAScript modules - the first review I told the history of JavaScript modules and the current state of affairs of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Native EcmaScript modules: new features and differences from webpack</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/477/efc/32e/477efc32e4624306acb9a5bb1f903570.png" alt="image"></p><br><p>  In the previous article <a href="https://habrahabr.ru/company/tuturu/blog/326716/">Native ECMAScript modules - the first review</a> I told the history of JavaScript modules and the current state of affairs of the implementation of native EcmaScript modules. </p><br><p>  Two implementations are now available, which we will try to compare with the bundler modules. </p><a name="habracut"></a><br><p>  Main thoughts: </p><br><ol><li>  execute a script or load an external file and execute as a module using &lt;script type = "module"&gt;; </li><li> <code>.js</code> extension cannot be omitted in the <code>import</code> directive (the full path must be specified); </li><li>  module scopes should not be global and <code>this</code> should not refer to anything; </li><li>  native modules in strict mode by default (you no longer need to use the <code>use strict</code> directive); </li><li>  modules by default work as deferred scripts (the same as for <code>&lt;script type="text/javascript" defer /&gt;</code> ). </li></ol><br><p>  In the article we will learn about the differences of bundles, ways of interacting with modules, learn how to rewrite webpack modules into native ES and other tips and tricks. </p><br><h1 id="put-modulya">  Module path </h1><br><p>  We already know that we need to write the <code>.js</code> extension when we use the <code>import "FILE.js"</code> directive <code>import "FILE.js"</code> . </p><br><p>  But there are other rules that apply to the <code>import</code> directive. </p><br><p>  Let's analyze the error that will appear if you try to <a href="https://plnkr.co/edit/1KzsCn%3Fp%3Dpreview">load a nonexistent script</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'non-existing.js'</span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/web/e5e/598/245/e5e59824570a4ea5a76400e2b8857529.png" alt="image"></p><br><p>  Cool, but what about the gaps? </p><br><p>  As in classic scripts, any number of spaces at the beginning or at the end of the path are removed in <code>&lt;script src&gt;</code> and <code>import</code> ( <a href="https://plnkr.co/edit/8iZ1FS%3Fp%3Dpreview">demo</a> ): </p><br><pre> <code class="javascript hljs">&lt;!--WORKS--&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">async</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">" ./entry.js "</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// WORKS import utils from " https://blog.hospodarets.com/demos/native-javascript-modules/js/utils.js ";</span></span></code> </pre> <br><p>  You can find more examples by reading part of the HTML specification <a href="https://html.spec.whatwg.org/multipage/webappapis.html">resolve a module specifier</a> .  Here are examples of valid specifiers from there: </p><br><ul><li>  <a href="">https://example.com/apples.js</a> ; </li><li>  http: example.com \ pears.mjs (will be <a href="">http://example.com/pears.mjs</a> , analyzes without base URL); </li><li>  //example.com/bananas; </li><li>  ./strawberries.js.cgi; </li><li>  ../lychees; </li><li>  /limes.jsx; </li><li>  data: text / javascript, export default 'grapes'; </li><li>  blob: <a href="https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f">https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f</a> . </li></ul><br><p>  <strong>Total about the module path:</strong> </p><br><ul><li>  <strong>it can begin and end with spaces;</strong> </li><li>  <strong>it must be an absolute URL or:</strong> </li><li>  <strong>it must begin with ‚Äú/‚Äù, ‚Äú./‚Äù, or ‚Äú../‚Äù.</strong> </li></ul><br><p>  Once we are talking about absolute URLs, let's check how we can use them. </p><br><h1 id="absolyutnye-url-i-cors-cross-origin-resource-sharing">  Absolute URLs and CORS (Cross-Origin Resource Sharing) </h1><br><p>  Another difference from bundles is the ability to download files from other domains (for example, loading modules from a CDN). <br>  Let's create a <a href="https://plnkr.co/edit/YrqP8N%3Fp%3Dpreview">demo</a> where we load the main-bundled.js module, which in turn imports and uses <a href="">blog.hospodarets.com/‚Ä¶/utils.js</a> from another domain. </p><br><pre> <code class="javascript hljs">&lt;!-- https:<span class="hljs-comment"><span class="hljs-comment">//plnkr.co/‚Ä¶.html --&gt; &lt;script type="module" async src="./main-bundled.js"&gt;&lt;/script&gt; // https://plnkr.co/‚Ä¶.main-bundled.js // DOES allow CORS (Cross Origin Resource Sharing) import utils from "https://blog.hospodarets.com/demos/native-javascript-modules/js/utils.js"; utils.alert(` JavaScript modules work in this browser: https://blog.whatwg.org/js-modules `); // https://blog.hospodarets.com/.../utils.js export default { alert: (msg) =&gt; { alert(msg); } };</span></span></code> </pre> <br><p>  The demo will work in the same way as if you downloaded scripts from your domain.  It is good that there is support for absolute URLs and it works just like classic scripts that can be downloaded from any source. </p><br><p>  Of course, such requests follow the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> rules.  For example, in the previous example we loaded the script from <a href="">https://blog.hospodarets.com/demos/native-javascript-modules/js/utils.js</a> , which allowed us to make CORS requests.  This can be easily determined by looking at the response headers: </p><br><p><img src="https://habrastorage.org/web/fe3/b47/436/fe3b4743604742ee8ade72ba6c17f05b.png" alt="image"></p><br><p>  We can see the access-control-allow-origin: <code>*</code> header. </p><br><p>  This <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">Access-Control-Allow-Origin</a> header: |  <code>*</code> defines the URI that can access the resource.  The special symbol <code>*</code> allows any request to access the resource, so our demo works. <br></p><p>  But let's change the main-bundled.js, we will load utils.js from another place ( <a href="https://plnkr.co/edit/yutRmC%3Fp%3Dpreview">demo</a> ) </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// https://plnkr.co/‚Ä¶.main-bundled.js // DOESN'T allow CORS (Cross Origin Resource Sharing) import utils from "https://hospodarets.com/developments/demos/native-javascript-modules/js/utils.js"; utils.alert(` JavaScript modules work in this browser: https://blog.whatwg.org/js-modules `);</span></span></code> </pre> <br><p>  And the demo stops working.  Despite this, you can open <br>  <a href="">hospodarets.com/‚Ä¶/native-javascript-modules/js/utils.js</a> <br>  in your browser and make sure its content matches the <br>  <a href="">blog.hospodarets.com/‚Ä¶/utils.js</a> . </p><br><p>  The difference is that the second utils.js does not provide access to the resource at the header level <code>access-control-allow-origin</code> : </p><br><p><img src="https://habrastorage.org/web/0a5/06b/78a/0a506b78a7404c32b81835f49b11a8e1.png" alt="image"></p><br><p>  which is interpreted by the browser as a rejection of any other source ( <a href="https://plnkr.co/">https://plnkr.co</a> in our case) to access the resource, so the demo stops working with the following error: </p><br><p><img src="https://habrastorage.org/web/b8e/a7a/852/b8ea7a8525ef43c08022f99e85cfb48c.png" alt="image"></p><br><p>  There are some other limitations that apply to native modules, classic scripts and resources.  For example, you will not be able to import the HTTP module into your HTTPS site ( <a href="https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content">Mixed Content</a> , <a href="https://plnkr.co/edit/2lY24i%3Fp%3Dpreview">demo</a> ) </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// https://plnkr.co/‚Ä¶.main-bundled.js // HTTP insecure import under the app served via HTTPS import utils from "http://blog.hospodarets.com/demos/native-javascript-modules/js/utils</span></span></code> </pre> <br><p><img src="https://habrastorage.org/web/95d/df1/64f/95ddf164f1bd4c0697dbb02a569c9f84.png" alt="image"></p><br><p>  <strong>Total:</strong> </p><br><ul><li>  <strong>You can use absolute URLs for scripts type = ‚Äùmodule‚Äù and for import directives;</strong> </li><li>  <strong>CORS rules apply to modules loaded from other sources;</strong> </li><li>  <strong>The mixed content (HTTP / HTTPS) rule also applies to modules.</strong> </li></ul><br><h2 id="atributy-script">  Script Attributes </h2><br><p>  As in classic scripts, there are many <a href="https://developer.mozilla.org/en/docs/Web/HTML/Element/script">attributes that can be used in script type = ‚Äùmodule‚Äù</a> . </p><br><ul><li>  The <code>type</code> attribute is used to set the type of <code>"module"</code> . </li><li>  <code>src</code> we use to load a file with a specific URI. </li><li>  <code>defer</code> not needed for ‚Äúmodule‚Äù type scripts, as this is the default behavior. </li><li>  If you use the <code>async</code> attribute, the module will be executed as soon as it is available, without defer default behavior, when scripts are executed in order after analyzing the document, but before the <a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded">DOMContentLoaded</a> event. </li><li>  <a href="https://html.spec.whatwg.org/">integrity</a> can still be used to make sure that the selected files (for example, from cdn) have not been replaced by something else. </li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes">The crossorigin attribute makes</a> it possible to control the exchange of data that is sent using CORS requests. </li><li>  <a href="https://html.spec.whatwg.org/">nonce</a> is a randomly generated hash that is added to the header on the server and added to the script tag. </li></ul><br><p>  <strong>Total:</strong> </p><br><ul><li>  <strong>basically all attributes can be used with native modules (except for integrity)</strong> </li></ul><br><h2 id="kak-opredelit-chto-skript-zagruzhaetsya-ili-ne-mozhet-byt-vypolnen-iz-za-oshibki">  How to determine if the script is loading or cannot be executed due to an error </h2><br><p>  As soon as I started using ES modules, the main question I had was how to determine if the script was loaded or an error occurred? </p><br><p>  According to the specification, if any of the descendants did not load, the loading of the script stops with an error and the script is not executed.  I prepared a demo where I intentionally missed the <code>.js</code> extension for the imported file, which is required (you may notice an error in the devtools console). </p><br><p><img src="https://habrastorage.org/web/416/d8e/423/416d8e423d464ee8b0158a56a443aed3.png" alt="image"></p><br><p>  We already know that native modules behave like deferred default scripts.  On the other hand, they can stop execution if, for example, a script graph cannot be executed / loaded. </p><br><p>  For these two cases, we must somehow detect the fact that the script did not load or an error occurred. </p><br><p>  Let's try using the classic way to connect scripts by changing a bit of code.  Create a method that will take parameters and execute a script with them: </p><br><ul><li>  native or classic module; </li><li>  with / without <code>async</code> attribute; </li><li>  with / without <code>defer</code> attribute. </li></ul><br><p>  The method returns a Promise, which allows you to determine whether the script was loaded or there was an error while loading: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utils.js function insertJs({src, isModule, async, defer}) { const script = document.createElement('script'); if(isModule){ script.type = 'module'; } else{ script.type = 'application/javascript'; } if(async){ script.setAttribute('async', ''); } if(defer){ script.setAttribute('defer', ''); } document.head.appendChild(script); return new Promise((success, error) =&gt; { script.onload = success; script.onerror = error; script.src = src;// start loading the script }); } export {insertJs};   : import {insertJs} from './utils.js' // The inserted node will be: // &lt;script type="module" src="js/module-to-be-inserted.js"&gt;&lt;/script&gt; const src = './module-to-be-inserted.js'; insertJs({ src, isModule: true, async: true }) .then( () =&gt; { alert(`Script "${src}" is successfully executed`); }, (err) =&gt; { alert(`An error occured during the script "${src}" loading: ${err}`); } ); // module-to-be-inserted.js alert('I\'m executed');</span></span></code> </pre> <br><p>  But the <a href="https://plnkr.co/edit/4TX8D4%3Fp%3Dpreview">demo</a> where the script is successfully executed.  In this example, the script will run and our success callback will be executed.  Now we will make the module have an error ( <a href="https://plnkr.co/edit/QssLh8%3Fp%3Dpreview">demo</a> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// module-to-be-inserted.js import 'non-existing.js'; alert('I\'m executed');</span></span></code> </pre> <br><p>  In this case, we have an error that can be seen in the console: </p><br><p><img src="https://habrastorage.org/web/e5e/598/245/e5e59824570a4ea5a76400e2b8857529.png" alt="image"></p><br><p>  Therefore, our reject callback is executed.  You will also see an error message if you try to use import \ export in other modules ( <a href="https://plnkr.co/edit/PqfS09%3Fp%3Dpreview">demo</a> ): </p><br><p><img src="https://habrastorage.org/web/91d/9e7/847/91d9e7847db14987bbf9bb2d2bcaf8d1.png" alt="image"></p><br><p>  Now we have the ability to connect scripts and be sure that the scripts can / cannot load. </p><br><p>  <strong>Total:</strong> </p><br><ul><li>  <strong>use the onload and onerror events of the script element to detect whether the module can be successfully executed or cannot be loaded;</strong> </li><li>  <strong>import \ export cannot be used in classic scripts.</strong> </li></ul><br><h2 id="osobennosti-nativnyh-moduley">  Features of native modules </h2><br><h3 id="nativnye-moduli--singleton">  Native modules - singleton </h3><br><p>  According to the specification, no matter how many times you will import the same module.  All modules are singleton.  Example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.counter){ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.counter++; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.counter = <span class="hljs-number"><span class="hljs-number">1</span></span>; } alert(<span class="hljs-string"><span class="hljs-string">`increment.js- window.counter: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">window</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.counter}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.counter; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> {counter};</code> </pre> <br><p>  You can import this module as many times as you want.  It will be executed only once, window.counter and the exported counter will be 1 ( <a href="https://plnkr.co/edit/DgZIdm%3Fp%3Dpreview">demo</a> ) </p><br><h3 id="importy-vsplyvayut">  Imports ‚Äúfloat‚Äù </h3><br><p>  Like functions in javascript, <code>imports</code> ‚Äúhoisted‚Äù.  This behavior is important to know.  You can apply the same rules to the writing of imports as to the declaration of variables - always write them at the beginning of the file.  This is why the <a href="https://plnkr.co/edit/ZZblF1%3Fp%3Dpreview">following code works</a> : </p><br><pre> <code class="javascript hljs">alert(<span class="hljs-string"><span class="hljs-string">`main-bundled.js- counter: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counter}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {counter} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./increment.js'</span></span>;</code> </pre> <br><p>  The order of execution of the code below ( <a href="https://plnkr.co/edit/IsZDRT%3Fp%3Dpreview">demo</a> ): </p><br><ul><li>  module1 </li><li>  module2 </li><li>  module3 </li><li>  code1 </li><li>  code2 </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./module1.js'</span></span>; alert(<span class="hljs-string"><span class="hljs-string">'code1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./module2.js'</span></span>; alert(<span class="hljs-string"><span class="hljs-string">'code2'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./module3.js'</span></span>;</code> </pre> <br><h3 id="importy-i-eksporty-ne-mogut-byt-vlozheny-v-bloki">  Imports and exports cannot be nested in blocks </h3><br><p>  Due to the fact that the structure of ES modules is static, they cannot be imported / exported inside conditional blocks.  It is widely used to optimize code loading.  You also cannot wrap them in a try {} catch () {} block or something like that. </p><br><p>  Here is a <a href="https://plnkr.co/edit/XEe2y4%3Fp%3Dpreview">demo</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()&gt;<span class="hljs-number"><span class="hljs-number">0.5</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./module1.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: Unexpected keyword 'import' } const import2 = (import './main2.js'); // SyntaxError try{ import './module3.js'; // SyntaxError: Unexpected keyword 'import' }catch(err){ console.error(err); } const moduleNumber = 4; import module4 from `module${moduleNumber}`; // SyntaxError: Unexpected token</span></span></code> </pre> <br><p>  <strong>Total:</strong> </p><br><ul><li>  <strong>modules - singletons;</strong> </li><li>  <strong>modules rise (hoisted);</strong> </li><li>  <strong>import and export cannot be performed inside blocks;</strong> </li><li>  <strong>imports are static (you cannot control module loading dynamically).</strong> </li></ul><br><h2 id="kak-opredelit-chto-est-podderzhka-moduley">  How to determine if modules are supported </h2><br><p>  Browsers started adding ES modules, and we need a way to find that the browser supports them.  First thoughts on how to define module support: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesSupported = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> exports !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesSupported2 = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>;</code> </pre> <br><p>  This option does not work, since import / export is intended for use only for functional modules.  These examples are executed with the ‚ÄúSyntax errors‚Äù error.  Even worse, import / export should not be loaded as a classic script.  Therefore, we need another way. </p><br><h3 id="opredelenie-podderzhki-es-moduley-v-brauzerah">  Determining support for ES modules in browsers </h3><br><p>  We have the ability to determine the loading of regular scripts by listening to <code>onload/onerror</code> .  We also know that if the <code>type</code> attribute is not supported, it will simply be ignored by the browser.  This means we can connect the <code>script type="module"</code> and know that if it is loaded, the browser supports the system of modules. </p><br><p>  It is unlikely that you would like to create a separate script in the project for such a check.  For this, we have the <a href="https://developer.mozilla.org/en/docs/Web/API/Blob">Blob ()</a> API to create an empty script and provide the correct MIME type for it.  In order to get the URL representation of the script, which we can assign to the src attribute, you need to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL">URL.createObjectURL ()</a> method </p><br><p>  Another problem is that the browser simply ignores the <code>type="module"</code> scripts if the browser does not support them in the browser, without any onload / onerror triggering event.  Let's just give up our Promise after the timeout. </p><br><p>  And finally, after our successful Promise, we have to tidy up a bit: remove the script from the DOM and remove unnecessary URL objects from the memory. </p><br><p>  And now we will combine all this in the <a href="https://plnkr.co/edit/s4GWHIVDOzIr8O8Q1Fas%3Fp%3Dpreview">example</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkJsModulesSupport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// create an empty ES module const scriptAsBlob = new Blob([''], { type: 'application/javascript' }); const srcObjectURL = URL.createObjectURL(scriptAsBlob); // insert the ES module and listen events on it const script = document.createElement('script'); script.type = 'module'; document.head.appendChild(script); // return the loading script Promise return new Promise((resolve, reject) =&gt; { // HELPERS let isFulfilled = false; function triggerResolve() { if (isFulfilled) return; isFulfilled = true; resolve(); onFulfill(); } function triggerReject() { if (isFulfilled) return; isFulfilled = true; reject(); onFulfill(); } function onFulfill() { // cleaning URL.revokeObjectURL(srcObjectURL); script.parentNode.removeChild(script) } // EVENTS script.onload = triggerResolve; script.onerror = triggerReject; setTimeout(triggerReject, 100); // reject on timeout // start loading the script script.src = srcObjectURL; }); }; checkJsModulesSupport().then( () =&gt; { console.log('ES modules ARE supported'); }, () =&gt; { console.log('ES modules are NOT supported'); } );</span></span></code> </pre> <br><h3 id="kak-opredelit-chto-skript-vypolnilsya-kak-nativnyy-modul">  How to determine that the script was executed as a native module </h3><br><p>  Cool, now we can understand whether the browser supports native modules.  But what if we want to know in which mode the loaded script runs? </p><br><p>  In the document object there is a property <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript">document.currentScript</a> that contains a link to the current script.  Therefore, you can check the <code>type</code> attribute: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isModuleScript = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.currentScript.type === <span class="hljs-string"><span class="hljs-string">'module'</span></span>;</code> </pre> <br><p>  but currentScript is not supported in modules ( <a href="https://plnkr.co/edit/dKElmtRwMmHXynoF0CFF%3Fp%3Dpreview">demo</a> ). </p><br><p>  We can clarify whether the script is a module by checking the context reference (in other words, a link).  If this refers to a global object, it will be clear that the script is not a native module. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isNotModuleScript = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>;</code> </pre> <br><p>  But we must bear in mind that this method can give false data, for example, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">bound</a> . </p><br><h2 id="perehod-s-webpack-na-nativnye-es-moduli">  Switch from Webpack to native ES modules </h2><br><p>  It's time to rewrite some Webpack modules to native ones, compare the syntax and make sure that everything still works.  Let's take a simple example that uses the popular <a href="https://lodash.com/">lodash</a> library. </p><br><p>  So, we use aliases and Webpack features to simplify the <code>import</code> syntax.  For example, we will do: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>;</code> </pre> <br><p>  Webpack will look in our <code>node_modules</code> folder, find <code>lodash</code> will automatically import the <code>index.js</code> file.  Which, in turn, requires downloading <code>lodash.js</code> , where all the code of the library.  In addition, you can import specific functions as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> map <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/map'</span></span>;</code> </pre> <br><p>  Webpack will find <code>node_modules/lodash/map.js</code> and import the file.  Convenient and fast, agree?  Let's try the following example: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main-bundled.js import _ from 'lodash'; console.log('lodash version:', _.VERSION); // eg 4.17.4 import map from 'lodash/map'; console.log( _.map([ { 'user': 'barney' }, { 'user': 'fred' } ], 'user') ); // ['barney', 'fred']</span></span></code> </pre> <br><p>  First of all, <code>lodash</code> just doesn't work with ES modules.  If you look at the source code, you will see that the commonjs approach is used: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// lodash/map.js var arrayMap = require('./_arrayMap'); //... module.exports = map;</span></span></code> </pre> <br><p>  After some searching, it turned out that the authors of lodash created a special project for this - <a href="https://github.com/lodash/lodash/tree/es">lodash-es</a> - which contains the library modules of lodash in the form of ES modules. </p><br><p>  If we check the code, we will see that these are ES modules: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// lodash-es/map.js import arrayMap from './_arrayMap.js'; //... export default map;</span></span></code> </pre> <br><p>  Here is the usual structure of our application (which we will port): </p><br><p><img src="https://habrastorage.org/web/f3a/294/254/f3a294254fd042f5b505e6d79f4f592d.png" alt="image"></p><br><p>  I intentionally placed <code>lodash-es</code> in the <code>dist_node_modules</code> folder instead of <code>node_modules</code> .  In most projects, the <code>node_modules</code> folder is outside of GIT-a and is not part of the distribution of the code.  You can find the <a href="https://github.com/malyw/malyw.github.io/tree/master/demos/native-ecmascript-modules-aliases">code on Github</a> . </p><br><p>  The <code>main-bundle.js</code> is assembled by <code>Webpack2</code> into the <code>dist/app.bundle.js</code> , on the other hand, <code>js/main-native.js</code> ES module and must be loaded by the browser along with the dependencies. </p><br><p>  We already know that we cannot help writing the file extension for native modules, so first of all we need to add them. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1) main-native.js DOESN'T WORK import lodash from 'lodash-es.js'; import map from 'lodash-es/map.js';</span></span></code> </pre> <br><p>  Secondly, the URLs of native modules must be absolute or must begin with ‚Äú/‚Äù, ‚Äú./‚Äù, or ‚Äú../‚Äù.  Oh, this is the hardest.  For our structure, we must do the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 2) main-native.js WORKS, USES RELATIVE URLS import _ from '../dist_node_modules/lodash-es/lodash.js'; import map from '../dist_node_modules/lodash-es/map.js';</span></span></code> </pre> <br><p>  And after a while we can start with a more complex structure of the organization of the modules.  We can have many relative and very long urls, so you can easily replace all files with the following option: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 2) main-native.js WORKS, CAN BE REUSED/COPIED IN ANY ES MODULE IN THE PROJECT import _ from '/dist_node_modules/lodash-es/lodash.js'; import map from '/dist_node_modules/lodash-es/map.js';</span></span></code> </pre> <br><p>  Usually the directory root points to the location of index.html, so the tag <a href="https://developer.mozilla.org/en/docs/Web/HTML/Element/base">does not affect the behavior of the imported modules.</a> <br></p><p>  Here is the demo and code </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'----- Native JavaScript modules -----'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/demos/native-ecmascript-modules-aliases/dist_node_modules/lodash-es/lodash.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`lodash version: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${_.VERSION}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// eg 4.17.4 import map from '/demos/native-ecmascript-modules-aliases/dist_node_modules/lodash-es/map.js'; console.log( map([ {'user': 'barney'}, {'user': 'fred'} ], 'user') ); // ['barney', 'fred']</span></span></code> </pre> <br><p>  <a href="https://blog.hospodarets.com/demos/native-ecmascript-modules-aliases/">Demo</a> </p><br><p>  At the end of this chapter, I note that for importing scripts, modules and dependencies, the browser makes requests (as well as for other resources).  In our case, the browser loads all the lodash dependencies, resulting in about 600 files getting into the browser: </p><br><p><img src="https://habrastorage.org/web/44d/568/4cc/44d5684cc59448ea98ecdbfb862cf749.png" alt="image"></p><br><p>  As you can guess, it‚Äôs a very bad idea to upload so many files, especially if you don‚Äôt have <a href="https://en.wikipedia.org/wiki/HTTP/2">HTTP / 2</a> support on the site. </p><br><p>  Now you know that you can switch from a Webpack to native modules, and even know about the existence of lodash-es. </p><br><p>  <strong>Total:</strong> </p><br><ul><li>  <strong>collected modules can be rewritten to native ES modules, plus popular libraries have already begun to provide compatible versions;</strong> </li><li>  <strong>with ES modules it is preferable to use HTTPS / 2.</strong> </li></ul><br><h2 id="ispolzovanie-es-modules-s-fallback-om">  Using ES modules with fallback </h2><br><p>  Let's use all our knowledge to create a useful script and apply it, for example, in our <a href="https://blog.hospodarets.com/demos/native-ecmascript-modules-aliases/index.html">lodash demo</a> . </p><br><p>  We will check if the browser supports ES modules (using checkJsModulesSupport ()) and, depending on this, decide what to connect to the user.  If modules are supported, we will load the main-native.js file for them.  Otherwise, we will connect the assembled JS file to the Webpack (using insertJS ()). </p><br><p>  In order for the example to work for all browsers, let's provide an API with which you can set attributes for scripts that will indicate in what way we want to load them. </p><br><p>  Something like that: </p><br><p><img src="https://habrastorage.org/web/658/31d/f0e/65831df0e2d7435f88f90f3f6df64f50.png" alt="image"></p><br><p>  And here's the code that will make it all work, using the previous examples discussed earlier: </p><br><pre> <code class="javascript hljs">checkJsModulesSupport().then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// insert module script insertJs({ src: currentScript.getAttribute('es'), isModule: true }); // global class if (isAddGlobalClassSet) { document.documentElement.classList.add(esModulesSupportedClass); } }, () =&gt; { // insert classic script insertJs({ src: currentScript.getAttribute('js') }); // global class if (isAddGlobalClassSet) { document.documentElement.classList.add(esModulesNotSupportedClass); } } );</span></span></code> </pre> <br><p>  I posted this <a href="https://github.com/malyw/es-modules-utils">es-modules-utils</a> script <a href="https://github.com/malyw/es-modules-utils">on Github</a> . </p><br><p>  Currently, there is a discussion about the possibility of adding native attributes of a nomodule or nosupport to the script, which will provide better compatibility for the fallback (thanks to <a href="https://twitter.com/rauschma">@rauschma</a> , who suggested this). </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  We have seen in practice the distinction between ES modules and classic scripts.  We learned how to determine if the module was loaded or an error occurred.  Now we know how to use ES modules with third-party libraries. </p><br><p>  In addition, we have a useful <a href="https://github.com/malyw/es-modules-utils">es-modules-utils</a> script <a href="https://github.com/malyw/es-modules-utils">on Github</a> that can provide backward compatibility for browsers that do not support ES modules. </p><br><p>  PS You can also read my article about the ability to dynamically load scripts using dynamic import () statement: <a href="https://blog.hospodarets.com/native-ecmascript-modules-dynamic-import">Native ECMAScript modules: dynamic import ()</a> . </p><br><h2 id="ot-perevodchika">  From translator </h2><br><p>  I work in Avia team <a href="http://avia.tutu.ru/">Tutu.ru</a> front-end developer.  Native modules are developing very much and I follow this.  All modern browsers already support them.  At the moment, we have almost the full opportunity to use this part of the language specification right now.  The future is coming :) </p><p></p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329918/">https://habr.com/ru/post/329918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329906/index.html">I want to break free. What and how to learn to escape from 1C</a></li>
<li><a href="../329908/index.html">Visual Studio Mobile Center: Deploy mobile software using Microsoft devops pipeline</a></li>
<li><a href="../329910/index.html">Analysis of changes in the game</a></li>
<li><a href="../329914/index.html">How do i make backups. DBMS FireBird</a></li>
<li><a href="../329916/index.html">5 sources about algorithmic design, if you just started to be interested in them</a></li>
<li><a href="../329920/index.html">Multistage backup storage for the smallest</a></li>
<li><a href="../329922/index.html">The science of neural networks. Live</a></li>
<li><a href="../329924/index.html">Hibernate + jsp with servlet support</a></li>
<li><a href="../329926/index.html">[updated] How the load testing of the processing cost us ‚Ç¨ 157,000 and why nobody was fired</a></li>
<li><a href="../329928/index.html">Lectures Technopark. Databases (Spring 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>