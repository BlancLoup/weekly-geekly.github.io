<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Just about Hindley Milner</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 If you have ever been interested in not too popular languages, then you must have heard of Hindley Milner. This type inference algorith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Just about Hindley Milner</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/storage1/d911287a/5bcb28a6/4c72fa65/8285c0fa.gif" alt="Robert milner" align="right">  If you have ever been interested in not too popular languages, then you must have heard of Hindley Milner.  This type inference algorithm is used in F # and Haskell and OCaml, as in their predecessor ML.  Some researchers even try to use <abbr title="Hindley Milner">HM</abbr> to optimize dynamic languages ‚Äã‚Äãlike Ruby, JavaScript and Clojure. <br><br>  And despite its prevalence, until now there has not been a simple and understandable explanation of what it is.  How does this magic work?  Are output types always correct?  Or is Hindley Milner better, say, Java?  And while those who really know what <abbr title="Hindley Milner">XM</abbr> will recover from another mental overstrain, we will try to figure it out for ourselves. <br><a name="habracut"></a><br><h4>  First step </h4><br>  Essentially, Hindley-Milner (or "Damas-Milner") is an algorithm for outputting value types based on how they are used.  Literally, it formalizes the intuitive notion that a type can be inferred from the operations it supports.  Consider the following code on pseudo-Scala <sup><a href="https://habr.com/ru/post/125250/">[4]</a></sup> : <br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">String</span></span>) = s.length <span class="hljs-comment"><span class="hljs-comment">// :    def bar(x, y) = foo(x) + y</span></span></code> </pre> <br>  Just by looking at the definition of the function <code>bar</code> , we can say that its type <i>should</i> be <code>(String, Int)=&gt;Int</code> .  It is not difficult to withdraw.  We simply look at the function body and see two ways to use the <code>x</code> and <code>y</code> parameters.  <code>x</code> is passed to <code>foo</code> , which expects a <code>String</code> .  Therefore, <code>x</code> must be of type <code>String</code> in order for this code to be compiled.  Moreover, <code>foo</code> returns an <code>Int</code> .  Method <code>+</code> class <code>Int</code> expects a parameter, also <code>Int</code> , therefore <code>y</code> must be of type <code>Int</code> .  Finally, we know that <code>+</code> returns <code>Int</code> , which means this is the type returned by <code>bar</code> . <br><br>  And this is exactly what Hindley-Milner does: by looking at the definition of a function, it calculates the <i>many constraints</i> imposed by how value is used.  And that is exactly what we did when we noticed that <code>foo</code> accepts a parameter of type <code>String</code> .  Once many constraints have been created, the algorithm completes type recovery using the <i>unification of</i> these constraints.  If the expression is well-typed, then ultimately the constraints will result in an unambiguous type.  Otherwise, one (or several) constraints will be mutually exclusive or intractable with a given set of types. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Informal algorithm </h4><br><h5>  Simple example </h5><br>  In order to make it easier to understand the algorithm, we will execute every step of it manually.  First, you need to bring a lot of restrictions.  We start by assigning each variable ( <code>x</code> and <code>y</code> ) a <i>new</i> type (that is, ‚Äúnot existing‚Äù).  If we recorded <code>bar</code> with these types, it would have been something like <sup><a href="https://habr.com/ru/post/125250/">[1]</a></sup> : <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">X</span></span>, y: <span class="hljs-type"><span class="hljs-type">Y</span></span>) = foo(x) + y</code> </pre><br>  No matter what the types are called, the main thing is that they do not overlap with the ‚Äúreal‚Äù types.  They are needed so that the algorithm can explicitly refer to the yet unknown type of each value.  Without which it is impossible to create a lot of restrictions. <br><br>  Next, we dive into the function body in the search for operations that impose some type constraints.  And so, the first operation is to call the <code>foo</code> method.  <sup><a href="https://habr.com/ru/post/125250/">[2]</a></sup> We know that type <code>foo</code> is <code>String=&gt;Int</code> and this allows us to write the constraint: <br><br> <code><i>X</i> ‚Ü¶ String <br></code> <br>  The next operation will be <code>+</code> associated with the value of <code>y</code> .  Scala represents all operators as a method call, so  this expression actually means " <code>foo(x).+(y)</code> ".  We already know that <code>foo(x)</code> is an expression of type <code>Int</code> (from the type returned by <code>foo</code> ), as well as the fact that <code>+</code> defined as a method of class <code>Int</code> with type <code>Int=&gt;Int</code> (of course, it is not entirely correct to use magic inherent only in Scala) .  That allows you to add one more constraint to our set: <br><br> <code><i>X</i> ‚Ü¶ String <br> <i>Y</i> ‚Ü¶ Int <br></code> <br>  The last step of type recovery is the <i>unification of</i> all these restrictions in order to obtain real types, which we substitute for the variables <code><i>X</i></code> and <code><i>Y</i></code>  Unification, literally, is the process of going through all the restrictions in an attempt to find the only type that suits them all.  For example, imagine that you were given the following facts: <br><ul><li>  Masha is tall </li><li>  Vasya is tall </li><li>  Masha loves red </li><li>  Vasya loves blue </li></ul>  Now, look at these limitations: <br><ul><li>  Someone tall </li><li>  Someone likes red </li></ul>  Hmm, who could anyone be?  This process of combining a set of constraints together with a set of facts can be mathematically formalized in the form of unification.  In the case of type recovery, it is enough to rename ‚Äútypes‚Äù into ‚Äúfacts‚Äù. <br><br>  In this example, unifying the set of constraints is trivial.  We had only one restriction for each value ( <code>x</code> and <code>y</code> ) and both of them are mapped to real types.  The only thing required was to substitute " <code>String</code> " instead of " <code><i>X</i></code> " and " <code>Int</code> " instead of " <code><i>Y</i></code> ". <br><br><h5>  Difficult example </h5><br>  To feel the power of unification, consider the example more difficult.  Suppose we have the following function <sup><a href="https://habr.com/ru/post/125250/">[3]</a></sup> : <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span></span>(a, b) = a(b) :: b</code> </pre><br>  Here, the <code>baz</code> function is declared, which takes a function from the parameters and something else, calling the function from the second parameter passed to it and then attaching the result to it itself.  It is easy to derive many restrictions for this function.  As before, we will start by creating new types for each value. <br>  Notice that in this case we annotate not only the parameters, but also the return value. <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">X</span></span>, b: <span class="hljs-type"><span class="hljs-type">Y</span></span>): <span class="hljs-type"><span class="hljs-type">Z</span></span> = a(b) :: b</code> </pre><br>  The first constraint that we derive is that the parameter <code>a</code> must be a function, that takes a value of type <code><i>Y</i></code> and returns the value of a new type of <code><i>Y'</i></code> .  Moreover, we know that <code>::</code> is a function on the <code>List[A]</code> class, which takes a new element <code>A</code> and returns a new <code>List[A]</code> .  Thus, we know that <code><i>Y</i></code> and <code><i>Z</i></code> must be of type <code>List[ <i>Y'</i> ]</code> .  Restrictions written in the formal form: <br><br> <code><i>X</i> ‚Ü¶ ( <i>Y</i> =&gt; <i>Y'</i> ) <br> <i>Y</i> ‚Ü¶ List[ <i>Y'</i> ] <br> <i>Z</i> ‚Ü¶ List[ <i>Y'</i> ]</code> <br> <br>  Now unification is not so trivial.  It is important that the variable <code><i>X</i></code> depends on <code><i>Y</i></code> , that is, at least one more additional step is required: <br><br> <code><i>X</i> ‚Ü¶ (List[ <i>Y'</i> ]=&gt; <i>Y'</i> ) <br> <i>Y</i> ‚Ü¶ List[ <i>Y'</i> ] <br> <i>Z</i> ‚Ü¶ List[ <i>Y'</i> ]</code> <br> <br>  This is the same set of constraints, only this time we substituted the well-known mapping for <code><i>Y</i></code> into the mapping for <code><i>X</i></code>  Using this substitution, we got rid of <code><i>X</i></code> , <code><i>Y</i></code> and <code><i>Z</i></code> from the types we derived, getting the following, typed <code>baz</code> function: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Y</span></span>`]=&gt;<span class="hljs-type"><span class="hljs-type">Y</span></span>`, b: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Y</span></span>`]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Y</span></span>`] = a(b) :: b</code> </pre><br>  Of course, this is still not the end result.  Even if the name of the type <code><i>Y'</i></code> would be syntactically correct, then the error would be the absence of this type.  This happens quite often when working with the Hindley-Milner type recovery algorithm.  Somehow, after the derivation of all constraints and unification, we have ‚Äúresiduals‚Äù of variable types for which there are no longer constraints. <br>  The solution can be considered unlimited variables like <acronym>type parameters</acronym> .  In the end, if the parameter is not limited by anything, then we can simply substitute any type, including the generic.  And so, the final version of the <code>baz</code> function, where we added an unlimited parameter of type " <code>A</code> " and replaced it with all occurrences of <code><i>Y'</i></code> in the inferred types: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](a: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]=&gt;<span class="hljs-type"><span class="hljs-type">A</span></span>, b: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = a(b) :: b</code> </pre><br><h4>  Conclusion </h4><br>  And it's all!  Hindley Milner is no more difficult than what we have described here.  Just imagine how this algorithm can be used to restore the types of expressions that are much more complex than we considered. <br><br>  I hope this article has helped you better understand how the Hindley-Milner algorithm works.  This type of type inference can be very useful, reducing the amount of code needed for static typing to the minimum necessary.  The " <code>bar</code> " example was specifically cited in a Ruby-like syntax to show that this information is still sufficient for type checking.  This can be useful the next time someone says that all statically typed languages ‚Äã‚Äãare too expressive. <br><br><h4>  Footnotes and comments </h4><br><ol><li><a name="comm1"></a>  The return type is omitted for ease of reading.  Technically, types are always derived for the expression as a whole. </li><li><a name="comm2"></a>  This is a depth-first search on <abbr title="Abstract syntax tree">ASD</abbr> , which means that we primarily look at operations with high priority.  Although the traversal order is technically not important, it is thus easier to think about the algorithm. </li><li><a name="comm3"></a>  " <code>::</code> " is the so-called <code>cons</code> operator in Scala.  He is responsible for attaching the left element to the right list. </li><li><a name="comm4"></a>  <a href="https://habr.com/ru/post/125250/">About the correct use of Scala for code samples</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/125250/">https://habr.com/ru/post/125250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125243/index.html">QNX RTOS: A Bit of the Microkernel, Threads and Processes</a></li>
<li><a href="../125245/index.html">SharePoint Workflow or why BPMS is needed</a></li>
<li><a href="../125246/index.html">IT Jam 2011 Meet & Mix - very soon in Odessa!</a></li>
<li><a href="../125247/index.html">How to make one website for all devices (Responsive Web Design)</a></li>
<li><a href="../125248/index.html">Popular password managers in comparison</a></li>
<li><a href="../125253/index.html">USB to AVR. Introduction</a></li>
<li><a href="../125254/index.html">kedDroid - S04E03. Video review software for Android</a></li>
<li><a href="../125256/index.html">Run Internet Explorer 6 on Windows 7</a></li>
<li><a href="../125258/index.html">Our security auditor is an idiot</a></li>
<li><a href="../125259/index.html">Iconified Preferences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>