<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cellular Automatics on Dart</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The implementation of the classic cellular automaton - Conway's ‚ÄúLife‚Äù - is the same task for a novice programmer as for radio engineering - to solder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cellular Automatics on Dart</h1><div class="post__text post__text-html js-mediator-article">  The implementation of the classic cellular automaton - Conway's ‚ÄúLife‚Äù - is the same task for a novice programmer as for radio engineering - to solder a simple radio receiver.  For those who do not know what Life is, read this article: <a href="http://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Wikipedia: Life (game)</a> . <br><br>  Let me remind the rules: the action takes place in the cellular field.  Each cell has 8 neighbors - cells adjacent to it with sides or corners.  At the beginning of the game, some cells are filled, forming the initial organism, the rest are empty.  Evolution happens like this: in the next generation, all filled cells that have less than 2 or more than 3 neighbors are cleaned and empty ones that have exactly 3 neighbors are filled. <br><br>  After playing with interesting configurations, it gets a bit boring.  In fact, for 40 years, everything that can be described is chewed on hundreds of pages of various articles and books.  Finding something new and interesting is difficult.  Then there is a desire to change the rules - and suddenly new organisms will behave quite differently? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb4/73c/c6e/cb473cc6ec409404d1cd3eec8333ff47.png"></div><br>  <a href="http://mattmerkulov.github.io/extlife/index.html">Here</a> you can see the demo right away. <a name="habracut"></a><br><br>  For a start, you can change the number of cells at which old ones die and new ones appear.  Only 2 <sup>8</sup> options (does a cell appear at N = 1..8 neighbors?) For the birth of cells and 2 <sup>9</sup> for death, in total we have 2 <sup>17</sup> , a good amount.  However, the majority of such configurations are of no interest (quickly die out or spread indefinitely).  John Conway himself wrote that he experimented with the rules, selecting values ‚Äã‚Äãso that evolution was interesting: poorly predictable, relatively long, leaving behind various isolated configurations, and also not simple unlimitedly growing configurations.  And in the end came to the only one that is now most popular. <br><br>  Now let's try to generalize the rules.  We have a cell that can be filled or empty, as well as a group of cells - neighbors.  Total 2 groups - from one cell and from 8 cells. <br><br>  We need a list of pairs of increments of coordinates, which determines the position of the cells of the group relative to the processed one.  For the first group (central cell) it will be the only pair (+0, +0).  For the second (neighboring cells) - eight pairs (-1, -1), (-1, +0), ..., (+1, +0), (+1, +1). <br><br>  To set the rules, we use a two-dimensional array of Boolean type.  The dimension is determined by the number of possible states of the groups: for the first - two (the cell in the center is empty or filled), for the second - nine (from 0 neighbors to the maximum count - 8). <br><br>  The index of the array element determines the number of filled cells in each of the groups, and the element value determines the state of the cell after processing: empty (false) or filled (true).  Thus, to find out what to do with a filled cell with 4 neighbors, we need to refer to the element with the index (1, 4).  If the value is false, we clear the cell, if true, leave it unchanged.  And the contents of the array will be like this: elements with indices (0, 3), (1, 2) and (1, 3) are true, the rest are false. <br><br>  Summarizing the rules for N groups: the coordinate array will contain N lists of pairs of integer values, and the rulebook will be represented by an N-dimensional array, the n-th dimension of which will be equal to 1 + the number of lists of pairs of increments for the n-th group. <br><br>  With such a structure of rules, the number of options is limited only by fantasy, although the possibility of expanding the rules is still there.  Now about the nuances of implementation. <br><br>  The implementation of the array with the number of measurements programmatically specified in all the languages ‚Äã‚ÄãI know is missing, so I have to write my own.  We do this through a one-dimensional array as follows: suppose we need to create an n-dimensional array e [Q <sub>1</sub> , Q <sub>2</sub> , ..., Q <sub>n</sub> ] with a range of indices [0 ... Q <sub>n</sub> - 1] for the n-th dimension.  Create a one-dimensional array e 'with dimension Q <sub>1</sub> * Q <sub>2</sub> * ... * Q <sub>n</sub> and assign each element e [i <sub>1</sub> , i <sub>2</sub> , ..., i <sub>n</sub> ] to each element e' [i <sub>1</sub> * k <sub>1</sub> + i <sub>2</sub> * k <sub>2</sub> + ... + i <sub>n</sub> * k <sub>n</sub> ], where k <sub>m</sub> = 1 * Q <sub>1</sub> * Q <sub>2</sub> * ... * Q <sub>m - 1</sub> .  That is, k <sub>1</sub> = 1, k <sub>2</sub> = Q <sub>1</sub> , k <sub>3</sub> = Q <sub>1</sub> * Q <sub>2</sub> , etc. This is a one-to-one correspondence, in other words, different elements of array e will correspond to different elements of array e '. <br><br>  For speed and simplicity, I will implement a limited looped field.  The algorithm for looping the whole X coordinate in the range [0 ... K - 1] is as follows: if, when changing the coordinate, it is out of this range, then we will increase or decrease it by K units (depending on whether it is left or right of our range) until the coordinate returns to the specified limits.  Then, when the coordinates ‚Äúexit‚Äù beyond the right edge of the range, it will ‚Äúenter‚Äù through the left border and vice versa. <br><br>  The algorithm is implemented by the formula X = X - floor (X / K) * K, but if K is a power of two, then it is better to use a faster and simpler formula X = X &amp; K. <br><br>  The field will thus be a two-dimensional array of N x N cells that can be represented as one-dimensional with the help of the already familiar correspondence e (X, Y) =&gt; e '(X + Y * N). <br><br>  <b>Now a little about optimization:</b> <br><br>  Do not redraw the entire field at each step of evolution.  Of course, in the beginning you will have to draw all the cells of the initial configuration, but then for each generation it is enough to redraw only the changed cells. <br><br>  Instead of processing all the filled cells and neighboring unfilled with checking the number of neighbors for each cell, it is better to process only the change in the cell fill, storing the number of its neighbors in each cell: when the cell is filled, it ‚Äúscatters‚Äù units in the cells whose neighbor it is by increasing the number of neighbors for these cells.  Conversely, when cleansing the cell, it ‚Äútakes‚Äù these units. <br><br>  Since we have several groups, it turns out that for each cell we must store a list of the number of neighbors for each group.  But, instead of this list, it will be faster to use the corresponding integer by the correspondence principle, which is similar to the address conversion during the transition from a multidimensional array to a one-dimensional one, which we have considered earlier: <sub>1</sub> * K <sub>2</sub> + Q <sub>1</sub> * Q <sub>2</sub> * K <sub>3</sub> + ... + Q <sub>1</sub> * ... * Q <sub>n-1</sub> * K <sub>n</sub> ]. <br><br>  Thus, the generation cycle will look like this: <br><ul><li>  Before the first cycle, all cells of the initial configuration are processed.  In the list of cells to be processed, they are entered and those cells whose neighbors they are. </li><li>  All cells from cells are checked for change (that is, if their state and state from the rulebook, corresponding to the number of their neighbors at the moment, are not equal).  If according to the rules the state should change, this cell is entered in the list of changed cells togglingCells. </li><li>  The list of cells is cleared. </li><li>  All cells from togglingCells change their state by ‚Äúscattering‚Äù or ‚Äútaking‚Äù their neighborhood from the cells of which they are neighbors.  All cells with the changed number of neighbors are entered into the cells. </li><li>  The togglingCells are rendered. </li><li>  togglingCells cleared. </li></ul><br><br>  I wrote the program in the language of Google Dart, you can see it <a href="">here</a> .  Run the program compiled into Javascript <a href="http://mattmerkulov.github.io/extlife/index.html">here</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/417/5cc/4ee4175ccade071de245f4212c2615ac.png"></div><br><br>  Now about the interesting sets of rules that I managed to find: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/779/6af/4317796af26bdabe64210ccd36865e52.png"></div><br><br><h4>  Horizontal-Vertical-Diagonal Breakdown </h4><br><h5>  SandGV (SandyLifeHV) </h5><br><ul><li>  Survival <br><ul><li>  1 or 2 diagonal + 1 or 2 vertical / horizontal </li></ul></li><li>  Birth <br><ul><li>  2 diagonal + 0 vertical / horizontal </li><li>  0 diagonal + 2 vertical / horizontal </li><li>  1 diagonally + 2 vertical / horizontal </li></ul></li></ul><br>  This version of the rules is characterized by the evolution of quicksands.  A randomly filled field stabilizes over several hundred generations.  At the same time, many stable configurations are formed, such as blocks and diagonal stripes, and the simplest pulsating configurations with a period of 2 generations ‚Äî a diagonal row of 2 cells and a vertical row of 3 cells.  Also often there is a pulsating cross with a period of 3 generations.  ‚ÄúShockers‚Äù are also encountered - stable configurations with several pulsating cells, as well as ‚Äúbutterflies‚Äù - pulsating configurations with a long period, similar to insects flapping their wings.  Moving configurations I have not met. <br><br><h5>  Sandy D (SandyLifeD) </h5><br>  The rules are similar to the previous ones, but instead of birth with 1 neighbor diagonally and 2 vertically / horizontally, the birth rule is used with 2 neighbors diagonally and 1 vertically / horizontally. <br><br>  Also quicksand, but they stabilize faster - after 100-200 generations, and other configurations arise.  There are almost no stable configurations (mostly 2x2 blocks), but the pulsing ones are a whole zoo.  The popular ‚Äúbracket‚Äù configuration, squares with flashing edges, a cross from the previous rules, ‚Äúcandy‚Äù, pulsating debris and a rather complicated and large ‚Äúbat‚Äù with a long pulse period can be noted.  Sometimes, the configuration is launched by fighter jets flying vertically / horizontally. <br><br><h5>  Amoeba (AmoebaLife) </h5><br><ul><li>  Survival <br><ul><li>  2 diagonal + 0-2 vertical / horizontal </li><li>  0-2 diagonal + 2 vertical / horizontal </li></ul></li><li>  Birth <ul><li>  2 diagonal + 0-2 vertical / horizontal </li></ul></li></ul><br>  Random configuration with these rules quickly acquires a rhombus-like shape.  She is extremely not inclined to split into several pulsating areas and likes to pick up the stable and pulsating blocks left behind.  It is extremely reluctant to grow and shrink, but at small sizes it often disappears, leaving behind small stable or pulsating configurations. <br><br><h5>  Electronics (ElectronicLife) </h5><br><ul><li>  Survival <br><ul><li>  2-3 diagonal + 2 vertical / horizontal </li><li>  0-1 diagonally + 2-3 vertically / horizontally </li></ul></li><li>  Birth <ul><li>  1-2 diagonally + 1-2 vertically / horizontally </li></ul></li></ul><br>  These rules lead to the fact that the configuration of the rectangular-diagonal shapes, similar to the tracks of the printed circuit board.  After about a thousand generations, pulsating rectangular configurations usually remain on the field. <br><br><h4>  Puffed up breakdown </h4><br><h5>  Liquid (LiquidLife) </h5><br><ul><li> Cell appearance / survival <ul><li>  0-1 upper + 1-3 central + 2-3 lower </li><li>  1-2 upper + 2-3 central + 0-1 lower </li><li>  2-3 upper + 1-3 central + 1-2 lower </li></ul></li></ul><br>  The configuration quickly takes the form of ‚Äúboiling water with steam‚Äù in triangular ‚Äúglasses‚Äù.  It usually ‚Äúcalms down‚Äù after several thousand generations, after which the system of these ‚Äúglasses‚Äù with pulsating ‚Äúwater‚Äù in them remains. <br><br><h5>  Armada (ArmadaLife) </h5><br><ul><li>  Cell appearance / survival <br><ul><li>  0-1 upper + 1-2 central + 2-3 lower </li><li>  1-3 upper + 1-2 central + 1-3 lower </li><li>  2-3 upper + 1-2 central + 0-1 lower </li></ul></li></ul><br>  An array of cells that exists initially begins to grow rapidly left and right, which is ensured by the rapid formation of ‚Äúlocomotives‚Äù, that is, moving configurations, leaving behind a pulsating wake.  Since the field is looped around, the ‚Äúarmada of ships‚Äù collide, as a result of which its parts can both be destroyed and transformed into ships flying in the opposite direction, and also leave pulsating configurations behind them.  Of noteworthy configurations - the minimum moving unit is a scout (reminiscent of the Shofixti ship from Star Control), there are also some larger ‚Äúsailboats‚Äù that generate ‚Äúscouts‚Äù ‚Äúbomber‚Äù, breeding in a geometric progression ‚Äúdisk‚Äù, as well as stable configurations ‚Äúslash‚Äù , ‚ÄúApplause‚Äù and ‚Äújumping arc‚Äù, which in some cases can turn the ships in the opposite direction. <br><br><h4>  Side breakdown </h4><br><h5>  Wire (WireLife) </h5><br><ul><li>  Survival <ul><li>  1-3 horizontal + 1-2 vertical </li></ul></li><li>  Birth <ul><li>  2 horizontal + 2-3 vertical </li></ul></li></ul><br>  This configuration tends to retreat and advance in jerks, slowly expanding in the end and leaving diagonal ‚Äúwire‚Äù pieces curved at a right angle.  Also often remains a ‚Äúvital‚Äù stone and a hive, a rotating ‚Äúcolon‚Äù.  From the pulsating configurations, one can distinguish ‚Äúfour points‚Äù, a ‚Äúknob‚Äù of two stones and a ‚Äúsmile‚Äù with a long period of pulsation.  Often, as a result of the development of a small separate configuration, a stable ‚Äúlozenge‚Äù is formed. <br><br><h5>  Twirls (TwirlLife) </h5><br><ul><li>  Survival <ul><li>  1-3 horizontal + 1-3 vertical </li></ul></li><li>  Birth <ul><li>  2 horizontal + 2 vertical </li></ul></li></ul><br>  Here, instead of ‚Äúwire‚Äù pieces, stable heaps of ‚Äústones‚Äù and ‚Äúcurls‚Äù of different complexity are formed.  There is one common diagonally moving ‚Äúspot‚Äù configuration. <br><br><h4>  Staple breakdown </h4><br><h5>  Snakes </h5><br><ul><li>  Survival <ul><li>  2-3 cells in one of the brackets, 0 in the other </li></ul></li><li>  Birth <ul><li>  1-2 cells in each of the brackets </li></ul></li></ul><br>  With such rules, even the smallest configurations often turn into intricate ‚Äúlocomotives‚Äù.  We can distinguish a vertical ‚Äúsnake‚Äù with the possible generation of an array of two-cell ‚Äúdice‚Äù, a growing striped triangle, a growing diagonal row, generating pulsating debris.  Also, some configurations can transmit unicellular ‚Äúsignals‚Äù along the diagonal row that can be canceled by other configurations.  There is a simple vertically moving configuration - the ‚Äúcart‚Äù, which can leave behind a disappearing ‚Äúsmoke‚Äù, as well as a pulsating ‚Äúspider‚Äù, which is often the stabilizer of the diagonal row. <br><br>  In the program you will find more sets of rules, each of which has an interesting feature. </div><p>Source: <a href="https://habr.com/ru/post/207830/">https://habr.com/ru/post/207830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207816/index.html">Financing increases your risk</a></li>
<li><a href="../207818/index.html">Automator service that uploads images to Yandex. Photos</a></li>
<li><a href="../207820/index.html">Asterisk: DND mode on the BLF key</a></li>
<li><a href="../207822/index.html">We calculate what year is now from the Big Bang on Python</a></li>
<li><a href="../207824/index.html">What color is the moon?</a></li>
<li><a href="../207832/index.html">Intel Inside: disassemble the latest Digma devices on the Intel platform and wonder about the progress of Chinese engineering</a></li>
<li><a href="../207834/index.html">Our experience in optimizing nginx to distribute video content</a></li>
<li><a href="../207838/index.html">For improving the search for information on Habr√©</a></li>
<li><a href="../207840/index.html">Dokku: the smallest PaaS</a></li>
<li><a href="../207842/index.html">Smart pointers and RAII in the service of a programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>