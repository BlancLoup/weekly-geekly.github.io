<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Theory of Correct Scripts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the difference between the script and the program? Not at all used by the language or the presence of the interface. 

 The main difference is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Theory of Correct Scripts</h1><div class="post__text post__text-html js-mediator-article">  What is the difference between the script and the program?  Not at all used by the language or the presence of the interface. <br><br>  The main difference is that the program has a vast shell that is not bound by the "contents" of the program.  Depending on the platform, these may be manual pages, support for several languages, availability of installation / uninstallation functions, execution of interface agreements (command line, or other means of interaction), interfaces in the common registry, etc. ... The program should be able to work in any documented environment, to provide for different situations (the coolest with this is for unix programs that use ./configure to determine, in fact, where they are, what is possible and what is not on this (next) platform). <br><br>  The script, in the strictly opposite sense: it is designed to solve a specific problem "here and now."  No one expects a script that sends statistics to be able to do it simultaneously on solaris, freeBSD, and windows embedded standard with cygwin on board. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are no differences between math and program ideas, between administration scripts and programs.  They work on the same principles, generally speaking, they perform almost the same thing. <br><br>  The difference between the script and the program is <em>administrative</em> . <br><a name="habracut"></a><br><br>  Almost any program has in itself THREE important components: <br><ul><li>  Nontrivial algorithm. </li><li>  Technical support, best practices of use, typical implementation schemes and ready-made configurations. </li><li>  Proper integration into the work environment in any permitted (documented) configuration. </li></ul><br><br>  Let's learn more about these components ... <br><br>  1) Algorithm.  Any program has, firstly, a certain idea (what the program actually does), and secondly, binding.  Reading configs, output to syslog, notification by mail and another thousand operations not related to the main task.  But the program is used not for the sake of reading configs and writing to the log, but for the sake of what it DOES.  Accordingly, usually the idea is to perform some actions on some algorithm.  Nontrivial idea.  In the actual code, this may be less than reading the xml-config, but it is the working algorithm that is the essence of the program.  It can be either ‚Äúprocessing the data‚Äù (like SQL), or mathematical (like md5sum), or working with the specific features of a particular piece of hardware (file format) - but it always requires high qualifications in the subject area to adequately understand the principles of operation.  It is clear that any programmer can read the OpenSSL code.  It is clear that the algorithm of the OpenSSL can only understand a good mathematician. <br><br>  But we are not writing about programs - about scripts.  So, the script should not implement non-trivial algorithms.  If you write a base64 analog in your script, this is a bad script.  If you write in your script sending messages on smtp using the ‚Äúopen socket, write‚Äù method, this is a disgusting script.  If you are in your script, catch the data from the com-port and write the answer there (to manage the UPS) - this is a scribe, and not a script. <br><br>  The script MUST NOT contain an algorithm in terms of the "domain".  The script does not have a subject area, the script is a binding around programs that already work with subject areas.  In some cases, the scripting language can provide all the tools: <br><pre> if md5.md5sum (open. ($ check) .read ())! = url.openurl ($ control) .read ():
      smtp.sendmail ($ from, $ to, "data check failed", "md5sum of $ check does not match control sum form $ contol.").
</pre><br>  This is a script.  Just a script.  Despite the fact that it implements an awesome amount of work.  But if you have md5 - the class declared in the script 5 lines above with the implementation of md5 (or url, or open, or smtp, etc) - this is an attempt at the program.  But the program is much more complicated than the algorithm that makes it up - and the like should not be implemented in scripts.  NEVER. <br><br>  2) Any program must have known behavior.  Mathematicians suggest describing program behavior in comprehensive terms;  Practice says that, besides the algorithm, the program still contains bugs and features that influence its behavior, to which it is necessary to adapt.  Adapting to them is much easier when there is some practice of using the program. <br><br>  ‚ÄúKDC has been valid once but invalid now‚Äù - if this is a message from a script - that‚Äôs all, bury it.  Right here, on the spot.  The program is quite a reasonable message by which you can google and find out exactly what is wrong.  This is a direct consequence of the presence in the program of some substantive logic, which is specific and requires users not to study it through, but to accept behihiristicheski.  I mean as a set of statements about the behavior of the program.  "This version of the program does not understand files larger than 2 GB in size."  It does not fit into the algorithm (and if it fits - it will take this way with the volume of discrete mathematics) - but this needs to be known in a practical sense.  ‚ÄúThis program behaves badly under the conditions of symmetrical load on the apload / download, it is better to run two copies, each of which will work in its own direction symmetrically‚Äù - understanding _SUCH_ will require titanic efforts, it is easier to take it for granted.  The more complex the algorithm, the more life you need to spend on its research, adaptation and in-depth study.  There is not enough life for everything, it is easier to accept as given and concentrate on the important. <br><br>  The script, on the contrary, should be crystal clear for everyone who looks at it (with amendments to the knowledge of the scripting language).  No <code>(if every in self.__datarange__ is not in any map(__systable__.lang, __localtable__.map, lambda (a,b):[a in b or b in a for every __sys__.pair(a,b)])) raise "Missed i18n constitution".</code> <br><br>  3) The script solves the problem _ HERE_NOWN.  The program solves the problem _TAM_I_EVERGDA_ (adjusted for operating experience from item 2).  When you write a script, you make it work on your system.  It is not suitable for free use in other systems (although it may be EASY (see Clause 1) adapted).  The program must be adaptable to a heap of applications, the implementation of this adaptation in the script leads to the loss of its simplicity and its transformation into a program.  In addition (alas and ah), but knowledge of how to write a program correctly is not equivalent to writing the correct algorithm.  You can write an amazing library, but if you can't run it on a machine that has Monday, the first day of the week (or the second, as lucky as anyone), then your library is worthless.  The need to think about it - this is already writing programs - the script is valid (although not desirable). <br><br>  Well, another important difference between scripts and programs.  Programs (in the form of libraries) can "layered" on each other.  This program needs libYYY, which uses libZZZ and libAAA, with libAAA using libZZZ and libc.  This is normal. <br><br>  Scripts MUST NOT DEPEND FRIEND FROM A FRIEND.  The situation when the script depends on the services of another script that depends on the third is abnormal. <br><br>  Note that we are talking about addiction.  It is quite possible to imagine a script that calls other scripts and produces a generalized result on them, but this is a side.  Slightly more difficult (for example, ‚Äúrun the script And if the script B did not work‚Äù) - already beyond the limits of a foul.  Not good.  And if the script A did not work, but did not report it?  Or he worked a little bit, but then he fell off so that script B could not be completed (and we, as the authors of script A, could not have thought of such a thing)? <br><br>  So what should a good script do?  Splicing multiple programs into a specific system.  You can consider the program for the details of the designer.  And the designer himself - for the script.  You should NOT cut the screw thread on the spindle - take the threaded spindle.  You should not make an elliptical roller out of this elastic - it will still work poorly.  If you do not have a square plate in the constructor with holes at the edges, then this is a problem of lack of details.  You can try to make a square plate of a pair of rectangular, but you should not make it and hundreds of long strips. <br><br>  It so happens that the scripts are reborn into programs.  Suddenly, a certain logic (algorithm) appears in the script, which becomes nontrivial (and useful).  At this point, you need to catch it - and do not be lazy to spend three times more time, but make it a program.  Provide it with "meat", which distinguishes the program from the script.  Add a hundred condition checks, replace all constants with configurable variables, prepare it to work in ‚Äúunusual‚Äù conditions.  It is desirable to make it public (then the practice of using it can be gained). <br><br>  An ordinary pipe is almost an ideal tool for constructing simple programs: <br><pre> lssomething |  grep "bla-bla" | sendmail root@host.ru -s "bla-bal for something".
</pre><br><br>  The edge in which the script ends is difficult to find.  Let's just say, the cycle is still tolerable.  Check condition - normal.  But checking conditions in a cycle (more than exiting the cycle) is already bad.  If you have a cycle in which a cycle is launched to check the conditions, this is a 100% program.  If it does not have all the things that a program should have, then it‚Äôs just a <em>very bad program</em> .  But not a script. <br><br>  When I look at the ‚Äúuseful scripts‚Äù collections ( <a href="http://forum.sysadmins.ru/topic79925.html">here</a> (forum.sysadmins.ru), for example), I understand that these are programs.  Terrible programs without supporting documentation, installation procedures, without checking the conditions ... It‚Äôs impossible. <br><br>  The use of such scripts is a sign of extreme cutsti working environment.  I once tried to get along with them, but came to the conclusion that this was a mistake.  It is much more correct to have a set of toolkits (i.e., full-fledged programs that implement specific things completely and well) than a set of similar scripts (I repeat once again - the program can be written in the same scripting language - the difference between the script and the program in a non-program binding: documentation and adaptability to life in a wide range of systems). <br><br>  The use of copy-pasted scripts is a kind of early-dos copying on diskettes of useful programm programs.  Works - rejoice, does not work - do not care, broke everything - get angry.  In terms of the choice between a copy-and-paste script and a program (and minimal binding), programs should be chosen.  Even if the implementation of the program will require additional efforts to study, build, etc.  Having adjusted the program, you will receive the program.  Having debugged the script, you will only get a crutch, the strength and durability of which even the author does not know. <br><br>  Every time a similar situation arises: make a script or search for a program, you should start by searching for a program.  Because programming is fascinating (yes, nagios are for us, we ourselves will write a bunch of monitoring scripts), and studying someone else is tiring (well, why the hell does it not work as I expect?).  But the consequences of ‚Äúunderprogramming‚Äù are the lack of documentation for the ‚Äúchimney‚Äù you made.  And the consequence of the implemented solution is a system that can work by itself. </div><p>Source: <a href="https://habr.com/ru/post/92590/">https://habr.com/ru/post/92590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../92579/index.html">66% Web video in H.264 format</a></li>
<li><a href="../92581/index.html">Entertaining BitTorrent Infographics</a></li>
<li><a href="../92583/index.html">Android 2.1 on HTC Hero - personal experience</a></li>
<li><a href="../92586/index.html">Asus EEE PC 1005 PE Netbook Review</a></li>
<li><a href="../92589/index.html">H.264 High Profile Level 5.1 Support in ATI Catalyst 10.4</a></li>
<li><a href="../92591/index.html">Quad search</a></li>
<li><a href="../92592/index.html">Full Root</a></li>
<li><a href="../92593/index.html">With a flick of the wrist, the UITabBarController turns into a UISplitViewController</a></li>
<li><a href="../92595/index.html">LinCut is an easy and convenient way to save your favorite websites.</a></li>
<li><a href="../92596/index.html">Easy way to get a lot of valid email addresses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>