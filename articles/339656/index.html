<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About choosing data structures for beginners</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. Linear structures 
 Array 
 When you need one object, you create one object. When you need several objects, then there are several options to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About choosing data structures for beginners</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/948/434/0ce9484348934e68fcb4368a05c979bc.jpg" alt="image"><br><br><h2>  Part 1. Linear structures </h2><br><h1>  Array </h1><br>  When you need one object, you create one object.  When you need several objects, then there are several options to choose from.  I have seen many newbies in the code write something like this: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   int score1 = 0; int score2 = 0; int score3 = 0; int score4 = 0; int score5 = 0;</span></span></code> </pre> <br>  This gives us the value of five records.  This method works well, until you need fifty or one hundred objects.  Instead of creating individual objects, you can use an array. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   const int NUM_HIGH_SCORES = 5; int highScore[NUM_HIGH_SCORES] = {0};</span></span></code> </pre> <br>  A buffer of 5 elements will be created, like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/d45/a35/36cd45a35c9e5b07b7720c77d8e641eb.png"></div><br><br>  Notice that the array index starts at zero.  If there are five elements in the array, then they will have indices from zero to four. <br><a name="habracut"></a><br><h2>  Disadvantages of a simple array </h2><br>  If you need a constant number of objects, then the array is quite suitable.  But let's say you need to add another element to the array.  In a simple array, this is not possible.  Suppose you need to remove an element from an array.  In a simple array, this is also impossible.  You are tied to the same number of items.  We need an array whose size can be changed.  Therefore, we had better choose ... <br><br><h1>  Dynamic array </h1><br>  A dynamic array is an array that can change its size.  The main programming languages ‚Äã‚Äãin their standard libraries support dynamic arrays.  In C ++, this is a <i>vector</i> .  In Java, this is an <i>ArrayList</i> .  In C #, this is a <i>list</i> .  All of them are dynamic arrays.  In its essence, a dynamic array is a simple array, but having two additional data blocks.  They store the actual size of a simple array and the amount of data that can actually be stored in a simple array.  A dynamic array might look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      sometype *internalArray; unsigned int currentLength; unsigned int maxCapacity;</span></span></code> </pre> <br>  The <i>internalArray</i> element points to a dynamically allocated buffer.  The actual buffer array is stored in <i>maxCapacity</i> .  The number of elements used is set by <i>currentLength</i> . <br><br><h2>  Adding to the dynamic array </h2><br>  When adding an object to a dynamic array, several actions occur.  The array class checks if there is enough space in it.  If <i>currentLength &lt;maxCapacity</i> , then there is room in the array to add.  If there is not enough space, then a larger internal array is placed, and everything is copied to the new internal array.  The maxCapacity value is increased to the new extended value.  If there is enough space, a new item is added.  Each element after the insertion point must be copied to a neighboring place in the internal array, and after copying is completed, the void is filled with a new object, and the value of <i>currentLength is</i> increased by one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35e/00b/83b/35e00b83bcc3ac4bbab505418164e77b.png"></div><br><br>  Since it is necessary to move each object after the insertion point, the best case would be to add an element to the end.  At the same time, it is necessary to move zero elements (however, the internal array still requires expansion).  A dynamic array works best when adding an element to the end rather than to the middle. <br><br><blockquote>  When adding an object to a dynamic array, each object can move in memory.  In languages ‚Äã‚Äãsuch as C and C ++, adding to a dynamic array means that ALL pointers to array objects become invalid. </blockquote><br><h2>  Remove from dynamic array </h2><br>  Deleting objects requires less work than adding.  First, the object itself is destroyed.  Secondly, each object after this point is shifted by one element.  Finally, currentLength is decremented by one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d26/380/8d2/d263808d2b691210e43a4c371d87403b.png"></div><br><br>  As with adding to the end of the array, deleting from the end of the array is the best case, because you need to move zero objects.  It is also worth noting that we do not need to resize the internal array to make it smaller.  The selected place can remain the same, in case we add objects later. <br><br><blockquote>  Deleting an object from a dynamic array results in a shift in the memory after the deleted item.  In languages ‚Äã‚Äãsuch as C and C ++, deleting from a dynamic array means that pointers to everything after the remote array become invalid. </blockquote><br><h2>  Disadvantages of dynamic arrays </h2><br>  Suppose the array is very large, and you need to add and delete objects frequently.  In this case, objects can often be copied to other places, and many pointers become invalid.  If you need to make frequent changes in the middle of a dynamic array, then for this there is a more suitable type of linear data structure ... <br><br><h1>  Linked lists </h1><br>  An array is a continuous block of memory, and each element of it is located after the other.  A linked list is a chain of objects.  Related lists are also present in the standard libraries of the main programming languages.  In C ++, they are called <i>list</i> .  In Java and C #, this is <i>LinkedList</i> .  A linked list consists of a series of nodes.  Each node looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    sometype data; Node* next;</span></span></code> </pre> <br>  It creates a structure of this type: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/407/26b/ff740726ba91033fbbae0965367ae565.png"></div><br><br>  Each node is connected to the following. <br><br><h2>  Add to linked list </h2><br>  Adding an object to a linked list begins with the creation of a new node.  Data is copied inside the node.  Then there is an insertion point.  The pointer of the new node to the next object is changed to point to the next node after it.  Finally, the node in front of the new node changes its pointer to point to the new node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec5/3bb/bda/ec53bbbdabd50a9597f6923ad297e618.png"></div><br><br><h2>  Remove from linked list </h2><br>  When removing an object from a linked list, there is a node in front of the node to be deleted.  It is changed to indicate the next node after the deleted object.  After that, the deleted object can be safely erased. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/689/6d6/1ef/6896d61efbfbb6b77000a4d515f9d452.png"></div><br><br><h2>  Benefits of the linked list </h2><br>  The biggest advantage of a linked list is the addition and removal of objects from the list.  Making changes to the middle of the list is very fast.  Remember that a dynamic array could theoretically cause the displacement of each element, and the linked list keeps every other object in its place. <br><br><h2>  Disadvantages of a linked list </h2><br>  Recall that a dynamic array is a continuous block of memory. <br><br>  If you need to get the five hundredth element of the array, then simply look at the 500 "places" ahead.  In the linked list, the memory is chained.  If you need to find the five hundredth element, you will have to start from the beginning of the chain and follow its pointer to the next element, then to the next element, and so on, repeating five hundred times. <br><br>  Random access to the linked list is very slow. <br><br>  Another serious drawback of the linked list is not very obvious.  Each node needs a small extra space.  How much space does he need?  You might think that only the pointer size is needed for it, but this is not quite so.  When dynamically creating an object, there is always a small margin.  Some programming languages, such as C ++, work with memory pages.  Usually the page takes 4 kilobytes.  When using add and remove statements, a whole page of memory is allocated, even if you only need to use one byte. <br><br>  In Java and C #, everything is arranged a little differently, they have special rules for small objects.  These languages ‚Äã‚Äãdo not require the entire 4-kilobyte page of memory, but they still have a small margin.  If you use standard libraries, then you don‚Äôt need to worry about the second one.  They are written in such a way as to minimize wasted space. <br><br><h1>  Conclusion </h1><br>  These three types (array, dynamic array, and linked list) provide the foundation for almost all more complex data containers.  When studying in college, one of the first tasks in the study of data structures is the own implementation of the classes of a dynamic array and a linked list. <br><br>  These structures are fundamental to programming.  No matter what language you will learn, you will use them to work with the data. <br><br><h2>  Part 2. Linear data structures with endpoints </h2><br><h1>  Stack </h1><br>  Imagine that you have a bunch of sheets of paper. <br><br>  We put one sheet in a pile.  Now we can access only the top sheet. <br><br>  We put another sheet in a pile.  The previous sheet is now hidden and access to it is impossible, we can use the top sheet.  When we finish with the top sheet, we can remove it from the pile, opening access to the underlying one. <br><br>  This is the idea behind the stack.  A stack is a LIFO structure.  This stands for Last In First Out (‚Äúlast entered, first out‚Äù).  When added and removed from the stack, the last item added will be the first to be removed. <br><br>  For the stack you need only three operations: Push, Pop and Top. <br><br>  Push adds an object to the stack.  Pop removes an object from the stack.  Top gives the most recent object on the stack.  These containers in most languages ‚Äã‚Äãare part of the standard libraries.  In C ++, they are called <i>stack</i> .  In Java and C # this is a <i>stack</i> .  (Yes, the only difference in the name is with a capital letter.) Inside the stack is often implemented as a dynamic array.  As you remember from this data structure, the fastest operations on dynamic arrays are adding and removing elements from the end.  Since the stack always adds and deletes from the end, usually push and pop of objects in the stack is incredibly fast. <br><br><h1>  Turn </h1><br>  Imagine you are standing in line for something. <br><br>  The first person in the queue is served, after which he leaves.  Then served and goes second in line.  Other people come to the line and stand at its end.  This is the idea of ‚Äã‚Äãthe ‚Äúqueue‚Äù data structure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f3/fcf/1df/9f3fcf1df111ee9147d5a605a454f440.jpg"></div><br><br>  The queue is a FIFO structure (First In First Out, ‚Äúfirst went in, first out‚Äù). <br><br>  When adding and removing from the queue, the first element to be added will be the first to be retrieved.  Queues only need a few operations: Push_Back, Pop_Front, Front and Back.  Push_Back adds an item to the end of the queue.  Pop_Front removes an item from the front of the queue.  Front and Back allow access to the two ends of the queue. <br><br>  Programmers often need to add or remove items from both ends of the queue.  Such a structure is called a double ended queue (deque).  In this case, a couple more operations are added: Push_Front and Pop_Back.  These containers are also included in most major languages.  In C ++, these are <i>queue</i> and <i>deque</i> .  Java defines interfaces for a queue and a two-way queue, and then implements them via <i>LinkedList</i> .  In C #, there is a <i>Queue</i> class, but there is no Deque class. <br><br>  Inside the queue and double-sided queue can be arranged quite difficult.  Since objects can arrive and be retrieved from either end, the inner container must be able to grow and shorten the queue from the beginning and from the end.  Many implementations use multiple memory pages.  When either end grows beyond the current page, an extra page is added.  If the page is no longer needed, then it is deleted.  Java uses the following method: for the linked list, some additional memory is needed, not for pages of memory, but for this language this implementation works fine. <br><br><h1>  Priority queue </h1><br>  This is a very common variation of the queue.  The priority queue is very similar to the normal queue. <br><br>  The program adds elements from the end and extracts elements from the beginning.  The difference is that you can set priorities for certain elements of the queue.  All the most important elements are processed in the FIFO order.  Then, in order of FIFO, items with lower priority are processed.  And this is repeated until the elements with the lowest priority are processed in the FIFO order. <br><br>  When you add a new item with a higher priority than the rest of the queue, it immediately moves to the top of the queue.  In C ++, this structure is called <i>priority_queue</i> .  In Java, this is <i>PriorityQueue</i> .  There is no priority queue in the standard C # library.  Priority queues are not only useful for getting first in line to an organization‚Äôs printer.  They can be used for convenient implementation of algorithms, for example, the search procedure A *.  The most probable results can be given a higher priority, less likely - a lower priority.  You can create your own system for sorting and organizing A * search, but it is much easier to use the built-in queue with priority. <br><br><h1>  Conclusion </h1><br>  Stacks, queues, double-sided queues and priority queues can be implemented based on other data structures.  These are not fundamental data structures, but they are often used.  They are very effective when you need to work only with finite data elements, and the middle elements are not important. <br><br><h2>  Part 3. Trees and heaps. </h2><br><h1>  Data structures "trees" </h1><br>  Data trees are very useful in many cases.  In the development of video games, tree structures are used to subdivide the space, allowing the developer to quickly find nearby objects without having to check every object in the game world.  Even though tree structures are fundamental in computer science, in practice most standard libraries do not have direct implementation of tree-based containers.  I will tell you in detail about the reasons for this. <br><br><h1>  Simple tree </h1><br>  A tree is ... a tree.  A real tree has a root, branches, and at the ends of the branches there are leaves. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/be9/5ae/b98be95aebd7da7df7c8ade8ae03ef46.png"></div><br><br>  The tree data structure starts with the root node.  Each node can branch into child nodes.  If a node has no children, then it is called a leaf node.  When there are several trees, it is called a forest.  Here is an example of a tree.  Unlike real trees, they grow from top to bottom: the root node is usually drawn from above, and the leaves - below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/429/093/095429093f096a1487d02b6d5995c1df.png"></div><br><br>  One of the first questions arises: how many nodes can each child have? <br><br>  Many trees have no more than two child nodes.  They are called binary trees.  The example above shows a binary tree.  Children are usually called left and right children nodes.  Another common tree type in games is a tree with four children.  In the quadtree tree, which can be used to cover the grid, the child nodes are usually named after the direction they close: NorthWest or NW, NorthEast or NE, SouthWest or SW and SouthEast (Southeast) or SE. <br><br>  Trees are used in many algorithms (I already mentioned binary trees).  There are balanced and unbalanced trees.  There are red-black trees, AVL-trees, and many others. <br><br>  Although tree theory is convenient, it suffers from serious flaws: storage space and access speed.  What is the best way to store a tree?  The easiest way is to build a linked list, it turns out to be the worst.  Suppose we need to build a balanced binary tree.  We start with the following data structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   Node* left; Node* right; sometype data;</span></span></code> </pre> <br>  Simple enough.  Now imagine that you need to store 1024 elements in it.  Then for 1024 nodes you have to store 2048 pointers. <br><br>  This is normal, the pointers are small and you can get away with a little space. <br><br>  You may remember that each time you place an object, it takes up a small portion of the additional resources.  The exact amount of additional resources depends on the library of the language you are using.  Many popular compilers and tools can use a variety of options - from just a few bytes to store data to a few kilobytes, to simplify debugging.  I worked with systems in which the placement takes at least 4 KB of memory.  In this case, 1024 items will require about 4 MB of memory.  Usually the situation is not so bad, but the additional costs of storing many small objects grow very quickly. <br><br>  The second problem is speed.  Processors "like" when objects are in memory next to each other.  Modern processors have a lot of very fast memory ‚Äî a cache ‚Äî that copes very well with most of the data.  When a program needs one piece of data, the cache loads this item, as well as the items next to it.  When data is not loaded into very fast memory (this is called a ‚Äúcache miss‚Äù), the program pauses its work and waits for data to load.  In the most obvious format, when each element of the tree is stored in its own section of memory, none of them is next to the other.  Each time a tree is traversed, the program is suspended. <br><br>  If creating a tree is directly related to such problems, then you should choose a data structure that works like a tree, but does not have its drawbacks.  And this structure is called ... <br><br><h1>  A pile </h1><br>  To confuse you, I will say that there are two kinds of heaps. <br><br>  The first is a bunch in memory.  This is a large block of memory in which objects are stored.  But I will talk about another heap. <br><br>  The heap data structure is essentially the same as a tree.  It has a root node, each node has children, and so on.  The heap adds restrictions, its sorting should always be performed in a certain order.  A sorting function is required ‚Äî usually a ‚Äúless than‚Äù operator. <br><br>  When adding or removing objects from a heap, the structure sorts itself to become a ‚Äúfull‚Äù tree, in which each level of the tree is filled, except perhaps for the last row, where everything should be shifted to one side.  This makes it very efficient to provide storage space and search by heap. <br><br>  Heaps can be stored in a simple or dynamic array, that is, little space is spent on its placement.  In C ++, there are functions such as push_heap () and pop_heap () that allow heaps to be implemented in the developer‚Äôs own container.  In standard libraries Java and C # there is no similar functionality.  Here is a tree and a bunch with the same information: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1d/cee/0cd/b1dcee0cd5239e977cfec59b20a7507b.png"></div><br><br><h1>  Why they are not in standard libraries </h1><br>  These are simple, fundamental, and very useful data structures.  Many people think that they should be present in standard libraries.  Within seconds, you can find thousands of tree implementations in a search engine. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that although trees are very useful and fundamental, there are better containers. There are more complex data structures that have the advantages of a tree (stability and shape) and the advantages of a heap (space and speed). More advanced data structures are usually a combination of data tables with lookup tables. Two tables in combination provide fast access, fast change, and manifest themselves well in dense and non-tight situations. They do not require the transfer of elements when adding and deleting elements, do not consume excessive memory and do not fragment the memory for extended use.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to know about the data structures "tree", because in the work you often have to use them. </font><font style="vertical-align: inherit;">It is also important to know that these data structures, when directly implemented, have disadvantages. </font><font style="vertical-align: inherit;">You can implement your own tree structures, just know that more compact types exist. </font><font style="vertical-align: inherit;">Why did I talk about them if they are not really used in standard libraries? </font><font style="vertical-align: inherit;">They are used as internal structures in our next topic:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 4. Nonlinear data structures. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These data structures are different from arrays and lists. </font><font style="vertical-align: inherit;">Arrays are sequential containers. </font><font style="vertical-align: inherit;">Elements in them are arranged in order. </font><font style="vertical-align: inherit;">When you add multiple items in a specific order, they remain in that order. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonlinear data structures do not necessarily remain in the order in which they are added. </font><font style="vertical-align: inherit;">When adding or removing items, the order of other items may change. </font><font style="vertical-align: inherit;">Inside they consist of trees and heaps, discussed in the previous section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many variations of such data structures. </font><font style="vertical-align: inherit;">The most basic are the data dictionary, as well as ordered and unordered sets.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data dictionary </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An ordinary dictionary consists of a set of words (key) and definition (value). Since the keys are in alphabetical order, any element can be found very quickly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the dictionaries were not sorted, then the search for words in them was incredibly difficult. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two main ways to sort items in a dictionary: a comparison or hash. Traditional ordering by comparison is usually more intuitive. It is similar to the order of a paper dictionary, where everything is sorted alphabetically or by numbers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When sorting items in this way, a comparison function may be required. Typically, this default function is a ‚Äúless than‚Äù operator, for example, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second way to sort items is to use hash. A hash is simply a way to convert a data block to a single number. For example, the string ‚Äúblue‚Äù may have hash 0xa66b370d, the string ‚Äúred‚Äù - hash 0x3a72d292. When a data dictionary uses a hash, it is usually considered as unassorted. In fact, it is still sorted by hash, rather than by human-friendly criteria. The data dictionary works in the same way. There is a slight difference in speed between using dictionaries with traditional sorting and sorting by hash. The differences are so small that they can be ignored. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++, there is a family of containers, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutimap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unordered_map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unordered_multimap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In Java, the family is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HashMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TreeMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinkedHashMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In C #, this is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dictionary</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SortedDictionary</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Each of them has its own implementation features, for example, sorting by hash or by comparison, assumption of duplicates, but in general the concept is the same. Note that in each of the standard libraries there is an ordered version (in which a comparison is specified) and an unordered version (where the hash function is used). After adding items to the data dictionary, you can change the values, but not the key.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us return to the analogy with the paper dictionary: you can change the definition of a word without moving the word in the book; </font><font style="vertical-align: inherit;">if you change the spelling of the word, you will have to delete the first spelling and re-insert the word with the new spelling. </font><font style="vertical-align: inherit;">Details of the work you can find in the textbooks. </font><font style="vertical-align: inherit;">It is enough to know that dictionaries are very fast when searching for data, and can be very slow when adding or removing values.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordered and unordered set </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An ordered set is almost the same as a dictionary. Instead of a key and a value, there is only a key in it. Instead of a traditional vocabulary with words and definitions, there are only words. Sets are useful when you need to store only words without additional data. In C ++, the family of structures is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unordered_set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unordered_multiset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In Java, this is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HashSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TreeSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinkedHashSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In C #, they are called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HashSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SortedSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As is the case with dictionaries, there are ordered versions (where a comparison is given) and unordered versions (where a hash function is used). After adding the key, it also can not be changed. Instead, you need to delete the old object and insert a new one. Often they are implemented in the same way as a data dictionary, they just store only the value. Since they are implemented in the same way, they have the same characteristics. The sets look up and find the values ‚Äã‚Äãvery quickly, but they work slowly when adding and removing items.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The container classes of data dictionaries, ordered and unordered sets are very useful for quick data retrieval. </font><font style="vertical-align: inherit;">Often they are implemented as trees or hash tables, which are very effective in this regard. </font><font style="vertical-align: inherit;">Use them when you need to create data once and often refer to it. </font><font style="vertical-align: inherit;">They are not as effective at adding and removing items. </font><font style="vertical-align: inherit;">Making changes to a container may cause an offset or reordering inside it. </font><font style="vertical-align: inherit;">If you need to follow this usage pattern, it is best to choose an ordered linked list.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 5. The right choice of data structures. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous sections, we listed the most frequently used data structures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly repeat them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are linear structures: an array, a dynamic array, and a bound array. They are linear because they remain in the order in which they are located. Arrays are very fast with random access and have relatively good performance when added and removed from the end. The linked list is very good at frequent additions and deletions from the middle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are linear data structures with endpoints: a family of stacks and queues. Both work about the same as their counterparts in the real world. In a stack, for example, in a stack of plates or in a data stack, you can push something up, you can get access to the top element, and you can pop this element. The queue, as well as the queue of people, works by adding to the end of the line and removing from the beginning of the line.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then there are non-linear data structures: a data dictionary, an ordered and unordered set. </font><font style="vertical-align: inherit;">They are all internally non-linear, the order in which you add them, in essence, is not related to the order in which you get them back. </font><font style="vertical-align: inherit;">The data dictionary works much like a real paper dictionary. </font><font style="vertical-align: inherit;">It has a key (the word we are looking for) and a value (definition of the word). </font><font style="vertical-align: inherit;">An ordered set is exactly the same as a data dictionary containing keys, but not values, and sorted. </font><font style="vertical-align: inherit;">An unordered set is just a ‚Äúbag‚Äù with objects. </font><font style="vertical-align: inherit;">The name is a bit confusing, because in fact they are ordered, just the way of ordering is inconvenient for a person. </font><font style="vertical-align: inherit;">All of these structures are ideal for quick searches.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The effect of the right choice </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the time, programmers have to iteratively process datasets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually we do not care about the order in which the set is located, we simply start from the beginning and visit each element. In this very common situation, the choice of data structure is not really important. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If in doubt, the best choice is usually a dynamic array. It can grow to any volume, while it is relatively neutral, which makes it quite easy to replace it later with another data structure. But sometimes the structure is very important.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the most frequent tasks in games is finding a path: you need to find a route from point A to point B. One of the most common algorithms for finding a path is A *. In the A * algorithm, there is a data structure containing partial paths. The structure is sorted so that the most likely partial path is in front of the container. This path is estimated, and if it is not complete, the algorithm turns this partial path into several partial paths of a larger size, and then adds them to the container.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using a dynamic array as this container will be a bad choice for several reasons. </font><font style="vertical-align: inherit;">First, removing elements from the beginning of a dynamic array is one of the slowest operations we can perform. </font><font style="vertical-align: inherit;">Secondly, re-sorting the dynamic array after each addition can also be slow. </font><font style="vertical-align: inherit;">As you can remember from the above, there is a data structure optimized for this type of access. </font><font style="vertical-align: inherit;">We remove from the beginning and add from the end, and automatic sorting is performed based on which path is the best. </font><font style="vertical-align: inherit;">The ideal choice for container A * paths is the priority queue, it is built into the language and fully debugs.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The choice of patterns </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The choice of data structure mainly depends on the usage pattern. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic array - the default selection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If in doubt, use a dynamic array. </font><font style="vertical-align: inherit;">In C ++, this is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In Java, it is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArrayList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In C #, this is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In general, a dynamic array is what you need. </font><font style="vertical-align: inherit;">It has good speed for most operations, and good speed for everyone else. </font><font style="vertical-align: inherit;">If you find out that you need another data structure, then it will be the easiest to switch from it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stack - only one end </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you use add and remove from one end only, then select the stack. This </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C ++, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Java and C #. There are many algorithms using a stack data structure. The first that comes to my mind is a two-stack calculator. Numerical problems, such as the Towers of Hanoi, can be solved using the stack. But, probably, you will not use these algorithms in your game. However, gaming tools often perform data parsing, and parsers actively use stack data structures to ensure the right combination of pairs of elements. If you work with a wide range of AI types, then the stack data structure will be incredibly useful for a family of machines called pushdown automaton.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Queue family - first entered, first out. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you add and remove only from both ends, then use either a queue or a two-way queue. </font><font style="vertical-align: inherit;">In C ++, this is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In Java, you can use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deque interfaces</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , both of which are implemented using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinkedList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In C #, there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, but there is no built-in Deque. </font><font style="vertical-align: inherit;">If you need important events to happen first, but otherwise everything happened in order, then select a priority queue. </font><font style="vertical-align: inherit;">In C ++, this is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priority_queue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in Java it is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PriorityQueue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In C #, you need to implement it yourself.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nonlinear structures - quick search. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you create a stable group of elements, and basically perform an arbitrary search, then you should choose one of the nonlinear structures. </font><font style="vertical-align: inherit;">Some of them store pairs of data, others contain separate data. </font><font style="vertical-align: inherit;">Some of them are sorted in a useful way, others are ordered in a computer-friendly manner. </font><font style="vertical-align: inherit;">If you try to create a list of all their combinations, you will have to write a separate article (or you can re-read the previous part).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linked list - frequent changes while maintaining order </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you often change the middle of the container, and you only need to bypass the list sequentially, then use the linked list. In C ++, it is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In Java and C #, this is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinkedList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A linked list is a great container for cases where the data is just coming in and must be kept in order, or when you need to periodically sort and move items.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choosing the right data structure can greatly affect the speed of the algorithms. </font><font style="vertical-align: inherit;">Understanding the basic data structures, their advantages and disadvantages, will help you in using the most efficient structure for any task. </font><font style="vertical-align: inherit;">I recommend that you end up exploring them in detail. </font><font style="vertical-align: inherit;">A complete study of these data structures in college in the specialty "Computer Science" usually takes several weeks. </font><font style="vertical-align: inherit;">I hope you understand the basic data structures and will be able to choose the right one without a long college degree. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This concludes the article. </font><font style="vertical-align: inherit;">Thanks for reading.</font></font></div><p>Source: <a href="https://habr.com/ru/post/339656/">https://habr.com/ru/post/339656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339644/index.html">How to choose a data center for an IT project in Russia: uptime, money and overall adequacy</a></li>
<li><a href="../339646/index.html">Trillion Markets: Example One - eSports</a></li>
<li><a href="../339648/index.html">How to get a free SSL certificate from Amazon and move to HTTPS on Amazon S3</a></li>
<li><a href="../339650/index.html">How to connect WebRTC to Zoom and call 2 times cheaper</a></li>
<li><a href="../339654/index.html">How to make the number 100 from any other six-digit number</a></li>
<li><a href="../339658/index.html">From the garage on the courage: success stories of the largest IT-businesses, starting from scratch</a></li>
<li><a href="../339660/index.html">Creating a Tinkoff Design System. UI Kit, versioning and showcase components</a></li>
<li><a href="../339662/index.html">How to dismiss an employee and stay with this person</a></li>
<li><a href="../339664/index.html">Kakao - how to make UI testing great again</a></li>
<li><a href="../339666/index.html">We attack DHCP part 4. DHCP + ARP + Apple = MiTM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>