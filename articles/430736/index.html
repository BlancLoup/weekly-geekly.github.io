<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We develop your browser from scratch. Part One: HTML</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 


 We continue the cycle of articles on the development of the browser engine. 


 In this article I will tell you how to create the fastest H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We develop your browser from scratch. Part One: HTML</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Hello! </p><br><p>  We continue the cycle of articles on the development of the browser engine. </p><br><p>  In this article I will tell you how to create the fastest HTML parser with DOM.  We will look at the HTML specification and how it is bad about performance and resource consumption when parsing HTML. </p><br><p>  With this topic I reported on the last HighLoad ++.  Not everyone can attend the conference, plus the article contains more details. </p><br><p>  I assume that the reader has basic knowledge about HTML: tags, nodes, elements, namespace. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  HTML specification </h2><br><p>  Before you begin to somehow affect the implementation of the HTML parser, you need to understand what HTML specifications to believe. </p><br><p>  There are two HTML specifications: </p><br><ol><li>  <a href="https://html.spec.whatwg.org/multipage/">WHATWG</a> <br><ul><li>  Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://www.w3.org/TR/html/">W3C</a> <br><ul><li>  Big list of companies </li></ul></li></ol><br><p> Naturally, the choice fell on industry leaders - <strong><code>WHATWG</code></strong> .  Living standard, large companies, each of which has its own browser / browser engine. </p><br><p>  UPDATE: Unfortunately, the above references to the specifications do not open from Russia.  Apparently, the "echo of the war" with telegrams. </p><br><h2 id="process-parsinga-html">  HTML parsing process </h2><br><p>  The process of building an HTML tree can be divided into four parts: </p><br><ol><li>  Decoder </li><li>  Preliminary processing </li><li>  Tokenizer </li><li>  Building a tree </li></ol><br><p>  Consider each stage separately. </p><br><h3 id="dekoder">  Decoder </h3><br><p>  The tokenizer accepts code points for unicode input.  Accordingly, we need to convert the current byte stream into unicode characters.  To do this, use the <a href="https://encoding.spec.whatwg.org/">Encoding</a> specification. </p><br><p>  If we have HTML with an unknown encoding (no HTTP header), then we need to define it before decoding.  To do this, we use the <a href="https://html.spec.whatwg.org/multipage/parsing.html">encoding sniffing algorithm</a> . </p><br><p>  If very briefly, the essence of the algorithm comes down to the fact that we are waiting for <strong><code>500</code></strong> or the first <strong><code>1024 </code></strong> from the byte stream and run the algorithm that tries to find the <strong><code>&lt;meta&gt;</code></strong> with the attributes <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> or <strong><code>charset</code></strong> and tries understand what encoding the HTML developer specified. </p><br><p>  The <strong><code>Encoding</code></strong> specification specifies the minimum set of supported encodings by the browser engine (21 total): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows -1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE and x-user -defined. </p><br><h3 id="predvaritelnaya-obrabotka">  Preliminary processing </h3><br><p>  After we decoded the bytes into unicode characters, we need to perform a "sweep".  Namely, replace all carriage returns ( <strong><code>\r</code></strong> ) followed by a line feed ( <strong><code>\n</code></strong> ) with a carriage return ( <strong><code>\r</code></strong> ).  Then, replace all carriage returns with a line feed ( <strong><code>\n</code></strong> ). </p><br><p>  This is described in the specification.  That is, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  But, in fact, no one does.  Make it easier: </p><br><p>  If the carriage return character ( <strong><code>\r</code></strong> ) is caught, then we see if there is a newline character ( <strong><code>\n</code></strong> ).  If there is, then we change both characters for a newline character ( <strong><code>\n</code></strong> ), if not, we only change the first character ( <strong><code>\r</code></strong> ) for a newline ( <strong><code>\n</code></strong> ). </p><br><p>  At this preliminary data processing is completed.  Yes, all you need to do is get rid of the carriage return symbols so that they do not fall into the tokenizer.  The tokenizer does not expect and does not know what to do with the carriage return symbol. </p><br><h3 id="oshibki-parsinga">  Parsing errors </h3><br><p>  So that no further questions arise, you should immediately tell what a <strong><code>parse error</code></strong> . </p><br><p>  In fact, nothing terrible.  It sounds menacing, but in fact it is only a warning that we were expecting one thing, but we have another. </p><br><p>  A parsing error will not stop data processing or tree building.  This is a message that signals that we do not have valid HTML. </p><br><p>  Parsig error can be obtained for surrogate pairs, <code>\0</code> , wrong tag location, invalid <strong><code>&lt;!DOCTYPE&gt;</code></strong> and more. </p><br><p>  By the way, some parsing errors lead to consequences.  For example, if you specify "bad" <strong><code>&lt;!DOCTYPE&gt;</code></strong> then the HTML tree will be marked as <strong><code>QUIRKS</code></strong> and the logic of some DOM functions will change. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  As mentioned earlier, the tokenizer accepts unicode characters as input.  This is a state machine that has <strong><code>80</code></strong> states.  In each state, conditions for unicode characters.  Depending on the incoming character, the tokenizer may: </p><br><ol><li>  Change your state </li><li>  To form a token and change the state </li><li>  Do nothing, wait for the next character. </li></ol><br><p>  The tokenizer creates six kinds of tokens: DOCTYPE, Start Tag, End Tag, Comment, Character, End-Of-File.  Which come to the stage of building a tree. </p><br><p>  It is noteworthy that the tokenizer does not know about all its states, but where about 40% (taken from the ceiling, for example).  "Why the rest?"  - you ask.  About the remaining 60% knows the stage of building a tree. </p><br><p>  This is done in order to properly parse tags such as <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> and so on.  That is, usually those tags in which we do not expect other tags, but only closing ourselves. </p><br><p>  For example, the <strong><code>&lt;title&gt;</code></strong> cannot contain other tags.  Any tags in <strong><code>&lt;title&gt;</code></strong> will be perceived as text until it meets the closing tag for itself <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  Why is this done?  After all, it was possible to simply indicate to the tokenizer that if we encounter a <strong><code>&lt;title&gt;</code></strong> then we go along the ‚Äúpath we need‚Äù.  And that would be true if not namespaces!  Yes, the name space affects the behavior of the tree building stage, which in turn changes the behavior of the tokenizer. </p><br><p>  For example, consider the behavior of the <strong><code>&lt;title&gt;</code></strong> in the HTML and SVG namespace: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Result of building a tree: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Result of building a tree: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  We see that in the first case (HTML namespace) the <strong><code>&lt;span&gt;</code></strong> is text, the <strong><code>span</code></strong> element was not created.  In the second case (SVG namespace), an element was created based on the <strong><code>&lt;span&gt;</code></strong> tag.  That is, depending on the namespace, tags behave differently. </p><br><p>  But that is not all.  The cake on this "celebration of life" is the fact that the tokenizer itself needs to know what namespace the tree building stage is in.  And this is necessary solely in order to properly handle <strong><code>CDATA</code></strong> . </p><br><p>  Consider two examples from <strong><code>CDATA</code></strong> , two namespaces: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Result of building a tree: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Result of building a tree: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  In the first case (HTML namespace), the tokenizer took <strong><code>CDATA</code></strong> for comment.  In the second case, the tokenizer disassembled the <strong><code>CDATA</code></strong> structure and obtained data from it.  In general, the rule is this: if we meet <strong><code>CDATA</code></strong> not in the HTML namespace, then parse it, otherwise we consider it as a comment. </p><br><p>  This is the result of a hard link between the tokenizer and the construction of the tree.  The tokenizer should know in which namespace the tree building stage is now, and the tree building stage can change the states of the tokenizer. </p><br><h3 id="tokeny">  Tokens </h3><br><p>  Below, all six types of tokens created by a tokenizer will be considered.  It is worth noting that all tokens have prepared data, that is, already processed and "ready to use."  This means that all named character references, like <strong><code>&amp;copy</code></strong> , will be converted to Unicode characters. </p><br><h3 id="doctype-token">  Doctype token </h3><br><p>  The DOCTYPE token has its own structure unlike other tags.  Token contains: </p><br><ol><li>  Name </li><li>  Public identifier </li><li>  System identifier </li></ol><br><p>  In modern HTML, the only valid / valid DOCTYPE should look like this: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  All other <strong><code>&lt;!DOCTYPE&gt;</code></strong> will be considered a parsing error. </p><br><h3 id="start-tag-token">  Start tag token </h3><br><p>  The opening tag can contain: </p><br><ol><li>  Tag name </li><li>  Attributes </li><li>  Flags </li></ol><br><p>  For example, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  The opening tag may contain the <strong><code>self-closing</code></strong> flag.  This flag does not affect the closure of the tag in any way, but it may cause a parsing error for non- <a href="https://html.spec.whatwg.org/multipage/syntax.html">void</a> elements. </p><br><h3 id="end-tag-token">  End tag token </h3><br><p>  Closing tag  It has all the properties of the token of the opening tag, but has a slash <strong><code>/</code></strong> before the tag name. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  The closing tag may contain a <strong><code>self-closing</code></strong> flag which will cause a parsing error.  Also, a parsing error will cause the attributes of the closing tag.  They will be parsed correctly, but thrown out at the stage of building a tree. </p><br><h3 id="comment-token">  Comment Token </h3><br><p>  The comment token contains all the text of the comment.  That is, it is completely copied from the stream to the token. </p><br><p>  Example, </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Character token </h3><br><p>  Perhaps the most interesting token.  Unicode token character.  It may contain one (only one) character. </p><br><p>  For each character in HTML, a token will be created and sent to the tree building stage.  It is very expensive. <br>  Let's take a look at how this works. </p><br><p>  Take HTML data: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  How do you think how many tokens will be created for the given example?  Answer: 22. </p><br><p>  Consider the list of generated tokens: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  Not comforting, right?  But, of course, many creators of HTML parsers actually have only one token in the process.  Running it around and rubbing it with new data each time. </p><br><p>  Let's go ahead and answer the question: why is this done?  Why not take this text in one piece?  The answer lies in the stage of building a tree. </p><br><p>  Tokenizer is useless without the stage of building an HTML tree.  It is at the stage of building a tree that text is glued together with different conditions. </p><br><p>  Conditions, approximately, such: </p><br><ol><li>  If a character token with <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ) arrived, then we cause a parsing error and ignore the token. </li><li>  If one of the <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> ), or <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) character tokens arrived, then call the algorithm to <a href="https://html.spec.whatwg.org/multipage/parsing.html">restore the active formatting elements</a> and insert a token into a tree. </li></ol><br><p>  The symbol token is added to the tree according to the algorithm: </p><br><ol><li>  If the current insertion position is not a text node, then create a text node, insert it into the tree and add data from the token to it. </li><li>  Otherwise add the data from the token to the existing text node. </li></ol><br><p>  This behavior creates many problems.  The need for each character to create a token and send for analysis in the stage of building a tree.  We do not know the size of the text node and we have to either allocate a lot of memory in advance or do realoki.  All this is extremely expensive in memory or in time. </p><br><h3 id="end-of-file-token">  End-of-file token </h3><br><p>  Simple and clear token.  The data is over - we will report on this stage of building a tree. </p><br><h3 id="postroenie-dereva">  Building a tree </h3><br><p>  Tree building is a state machine with <strong><code>23</code></strong> states with a variety of conditions for tokens (tags, text).  The tree construction stage is the largest, occupies a significant part of the specification, and is also capable of causing lethargic sleep and irritation. </p><br><p>  Everything is very simple.  Tokens are accepted at the input and the tree building state is switched depending on the token.  At the exit, we have a real DOM. </p><br><h2 id="problemy">  Problems? </h2><br><p>  The following problems look quite obvious: </p><br><p>  <strong>Character copying</strong> </p><br><p>  At the input, each state of the tokenizer takes one character each which it copies / converts in cases of need: tag names, attributes, comments, symbols. </p><br><p>  It is very wasteful both in memory and in time.  We are forced to pre-allocate an unknown amount of memory for each attribute, tag name, comment, and so on.  And this, respectively, leads to reals, and realokes lead to lost time. </p><br><p>  And if we imagine that HTML contains 1000 tags, and each tag has at least one attribute, then we get a hellishly slow parser. </p><br><p>  <strong>Character token</strong> </p><br><p>  The second problem is the character token.  It turns out that we create a token for each character and give it to the construction of a tree.  Building a tree does not know how many of these tokens we will have and cannot immediately allocate memory for the required number of characters.  Accordingly, here all the same revocals + constant checks for the presence of a text node in the current state of the tree. </p><br><p>  <strong>Monolithic system</strong> </p><br><p>  The big problem is the dependence of everything on everything.  That is, the tokenizer depends on the state of building the tree, and the tree building can control the tokenizer.  And the namespaces are to blame. </p><br><h2 id="kak-budem-reshat-problemy">  How will we solve problems? </h2><br><p>  Next, I will describe the implementation of the HTML parser in my <a href="https://lexbor.com/">Lexbor</a> project, as well as solving all the voiced problems. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Preliminary processing </h3><br><p>  We remove the preliminary data processing.  We will teach the tokenizer to understand carriage return ( <strong><code>\r</code></strong> ) as a space character.  Thus, it will be thrown into the stage of building a tree where we will deal with it. </p><br><h3 id="tokeny-1">  Tokens </h3><br><p>  With a flick of the wrist, we unify all tokens.  We will have one token for everything.  In general, there will be only one token in the entire parsing process. </p><br><p>  Our unified token will contain the following fields: </p><br><ol><li>  Tag ID </li><li>  Begin </li><li>  End </li><li>  Attributes </li><li>  Flags </li></ol><br><h4 id="tag-id">  Tag ID </h4><br><p>  We will not work with the textual representation of the tag name.  We translate everything into numbers.  The numbers are easy to compare, easier to work with. </p><br><p>  Create a static hash table of all known tags.  Create an enumeration (enum) from all known tags.  That is, we need to rigidly assign an identifier to each tag.  Accordingly, in the hash table the key will be the name of the tag, and the value written from the enumeration. </p><br><p>  For example: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  From the example you can see that we created tags for the <strong>END-OF-FILE</strong> token, for the text, the document.  All this for the sake of further convenience.  Opening the curtain, I‚Äôll say that we will have a <strong><code>Tag ID</code></strong> in the <strong><code>DOM Node Interface</code></strong> .  This is done in order not to make two comparisons: on the type of the node and on the element.  That is, if we need a <strong><code>DIV</code></strong> element, then we do one check in the node: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  But, you can certainly do this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  The two underscores in <strong><code>LXB_TAG__</code></strong> are needed to separate common tags from system tags.  In other words, the user can create a tag with the name <strong><code>text</code></strong> or <strong><code>end-of-file</code></strong> and if we then search by the tag name, no errors will occur.  All system tags start with <strong><code>#</code></strong> . </p><br><p>  But still, the node can store a textual representation of the tag name.  For 98.99999% node this parameter will be <strong><code>NULL</code></strong> .  In some namespaces, we need to prefix or the name of a tag with a fixed register.  For example, <strong><code>baseProfile</code></strong> in SVG namespace. </p><br><p>  The logic of work is simple.  If we have a tag with a clearly specified register then: </p><br><ol><li>  Add it to the common database of tags in lower case.  We get the tag ID. </li><li>  Add the tag ID and the original tag name in the text view to the node. </li></ol><br><p>  <strong>Custom tags (custom elements)</strong> </p><br><p>  Developer can create any tags in HTML.  So, as we have in the static hash table only those tags we know about, and the user can create any, we need a dynamic hash table. </p><br><p>  Everything looks very simple.  When the tag comes to us we will see if it is in a static hash table.  If there is no tag, then we will look at the dynamic one; if there is no tag either, we increase the counter of identifiers by one and add the tag to the dynamic table. </p><br><p>  Everything described happens at the tokenizer stage.  Inside the tokenizer and after all comparisons go by <strong><code>Tag ID</code></strong> (with rare exceptions). </p><br><h4 id="begin-and-end">  Begin and end </h4><br><p>  Now in the tokenizer we will not have data processing.  We will not copy and convert anything.  We simply take pointers to the beginning and end of the data. </p><br><p>  All data processing, such as symbolic links, will take place at the tree building stage. <br>  Thus, we will know the size of the data for subsequent memory allocation. </p><br><h4 id="attributes">  Attributes </h4><br><p>  It's still as simple as that.  We do not copy anything, but simply store pointers to the beginning / end of the name and attribute values.  All transformations occur at the time of building the tree. </p><br><h4 id="flags">  Flags </h4><br><p>  Since we have unified tokens, we need to somehow inform the construction of the tree about the type of token.  To do this, use the bitmap field Flags. </p><br><p>  The field can contain the following values: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  In addition to the type of token, opening or closing, there are values ‚Äã‚Äãfor the data converter.  Only the tokenizer knows how to properly convert the data.  Accordingly, the tokenizer marks in the token how the data should be processed. </p><br><h4 id="character-token-1">  Character token </h4><br><p>  From the previously described, we can conclude that the symbolic token has disappeared.  Yes, now we have a new type of token: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Now we create a token for all the text between the tags, marking how it should be further processed. </p><br><p>  Because of this, we will have to change the conditions in the construction of the tree.  We need to teach him to work not with character tokens, but with textual ones: convert, delete unnecessary characters, skip spaces, and so on. </p><br><p>  But there is nothing complicated.  At the stage of building a tree changes will be minimal.  But now the tokenizer does not correspond to the specification from the word at all.  But, we do not need it, this is normal.  Our task is to get the HTML / DOM tree that fully meets the specifications. </p><br><h3 id="stadii-tokenizatora">  Stage Tokenizer </h3><br><p>  To ensure high processing speed in the tokenizer, we will add an iterator to each stage.  According to the specification, each stage in our country takes one symbol and, depending on the incoming symbol, makes decisions.  But the truth is that it is very expensive. </p><br><p>  For example, to go from the <strong><code>ATTRIBUTE_NAME</code></strong> stage to the <strong><code>ATTRIBUTE_VALUE</code></strong> stage <strong><code>ATTRIBUTE_VALUE</code></strong> we need to find a whitespace in the attribute name, which will indicate its completion.  According to the specification, we must feed the symbol to the <strong><code>ATTRIBUTE_NAME</code></strong> stage until the whitespace character is encountered, and this stage will not switch to another.  This is very expensive, usually it is implemented through a function call on each character or callback like "tkz-&gt; next_code_point ()". </p><br><p>  We add a cycle to the <strong><code>ATTRIBUTE_NAME</code></strong> stage and pass the incoming buffer entirely.  In the cycle, we look for the symbols we need to switch and continue to work in the next stage.  Here we get a lot of gain, even optimization of the compiler. </p><br><p>  But!  The worst thing is that we thereby broke the support of the chunks out of the box.  Thanks to character processing in each stage of the tokenizer, we had support for chunks, and now we have broken it. </p><br><p>  How to fix?  How to implement chunks support ?!  It's simple, we introduce the concept of incoming buffers (Incoming Buffer). </p><br><h3 id="incoming-buffer">  Incoming buffer </h3><br><p>  Often html parsit chunks.  For example, if we receive data over the network.  In order not to stand idle while waiting for the remaining data, we can send already received data for processing / parsing.  Naturally, data can be "torn" anywhere.  For example, we have two buffers: </p><br><p>  <strong>The first</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Second</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Since we do not copy anything at the tokenization stage, we only take pointers to the beginning and end of the data, then we have a problem.  Pointers to different user buffers.  And given the fact that developers often use the same buffer for data, we are dealing with a pointer to the beginning of non-existent data. </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>  Here's what it looks like: </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p>  HTML  (   )    <strong><code>sarcasm</code></strong> .            . </p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p>   . </p></div></div><br><h2 id="itog">  Total </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ÃÜ :  ,  N+  </li><li> ÃÜ     </li><li>      </li><li>    Ãà </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  Sources </h2><br><p>      HTML    <a href="https://lexbor.com/docs/lexbor/html/">Lexbor HTML</a> . </p><br><h2 id="ps">  PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p>    .  ,        . <br>      (      ).    . </p></div></div><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430736/">https://habr.com/ru/post/430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430724/index.html">Conference DEFCON 21. DNS can be dangerous for your health. Part 1</a></li>
<li><a href="../430728/index.html">Teach me to give feedback</a></li>
<li><a href="../430730/index.html">What do they do in the R & D department of ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../430732/index.html">On the issue of division and TI</a></li>
<li><a href="../430734/index.html">Smart updates against smart contracts</a></li>
<li><a href="../430738/index.html">Be a security ninja: secret level</a></li>
<li><a href="../430740/index.html">How to milk cows with robots and make an industrial startup on this. R-sept history</a></li>
<li><a href="../430742/index.html">Student Olympiad "I am a professional": the direction of "Programming and Information Technology"</a></li>
<li><a href="../430748/index.html">Fight for resources, part 6: cpuset or Sharing is not always right</a></li>
<li><a href="../430750/index.html">Quantum Checkers - make checkers great again</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>