<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Animations in the world of states</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have already learned how to build clean interfaces and write ‚Äúundo-redo‚Äù in a few lines. But what about the animations? They are often bypassed, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Animations in the world of states</h1><div class="post__text post__text-html js-mediator-article">  Many have already learned how to build clean interfaces and write ‚Äúundo-redo‚Äù in a few lines.  But what about the animations?  They are often bypassed, and they do not always fit into the (state) DOM approach.  There are great solutions like React Motion, but what if you need to do complex animations or work with Canvas using a physics engine? <br><br>  Our text describes how to work with animations in React-applications, and compares several approaches (D3, React-Motion, ‚Äúdirty components‚Äù).  And also about how to "run" animations in Redux-applications.  The material is based on the decoding of the report by Alexey Taktarov from our December conference HolyJS 2017 Moscow.  We attach at the same time the video of this report: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Ug_dwJa07Os" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Careful traffic: under the cut a lot of pictures and gifs (you know, the material about the animation). <br><a name="habracut"></a><br><hr><br>  I would like to start with a story.  If you were in ancient Rome about the first century BC, you could meet Vitruvius. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/3c8/92f/374/3c892f374357f9ac7cf55583dc686508.jpg"><br><br>  Vitruvius is one of the most famous architects of the time.  He wrote 10 volumes on architecture.  His works were inspired by many.  But the most interesting thing is that in one of the books he brought out three main qualities that good architecture should have: strength, usefulness and beauty. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33b/ef3/fa6/33bef3fa65fb037fe30adb1179bcffb2.png"><br><br>  It seems to me that this triad can also be found in the design of the things we use.  Why all this?  We - the developers - write applications, sites.  We do things that people use.  Therefore, we, too, I think, should take a look at the rules that were derived two thousand years ago.  After all, the applications that we do should solve specific tasks of people. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dff/1ea/263/dff1ea263fcda0ba42f7337f8d8dcf9f.png"><br><br>  I think the whole point is in the feedback.  This is the key point.  And to some extent the feedback is animation, transitions between states. <br><br>  Further I will talk about animation in stateful applications using React as an example. <br><br><h2>  Animation patterns on the example of a demo from real projects </h2><br>  Before we talk about React, let's think about how animations work in browsers in general, and what it is. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/a52/920/d45a52920307cc9e6c562ee454f541b1.png"><br><br>  In the ideal world, animations should work smoothly.  It would be naive to believe that they can be done, for example, using setinterval or settimeout.  And here there are two misconceptions. <br><br><h2>  Misconception number 1 </h2><br>  <b>We are wrong</b> .  Because we cannot use setTimeout for animation.  After all, setTimeout will not guarantee that your function will actually work in the specified period of time.  This can lead to effects such as frame blending.  That is, you will think that your animation will come in 16 milliseconds, which roughly corresponds to 60 frames per second, but in fact it will work more, and this debt will accumulate and accumulate. <br><br>  Fortunately, there is a function that allows you to deal with this problem - requestAnimationFrame.  It guarantees that the callback will work at a convenient time for the browser scheduler.  At the same time I want to note that it can also work at irregular intervals.  If you want to use requestAnimationFrame, I highly recommend looking at which browsers you are targeting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1a/4cd/758/e1a4cd758f3582db5c3470e1954d195c.png"><br><br>  If you want to use requestAnimationFrame in your projects, then you will use something like this pattern.  That is, you declare a function that will be triggered at the moment when the animation should occur.  Then you call requestAnimationFrame - this will mean that we will execute our function at the right time. <br><br>  Next interesting point.  In principle, at the end of the function, we could call the planning of the next frame, but such a pattern is calling the requestAnimationFrame for the next frame at the very beginning.  Since no one knows what can happen during the execution of a function.  Maybe she, for example, will throw an exception.  Therefore, it is better to immediately plan the next frame at the very beginning. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Or use a polyfill: // import requestAnimationFrame from 'raf' const { requestAnimationFrame } = window const animate = () =&gt; { requestAnimationFrame(animate) // Perform an animation step x += velocity } // Fire it up requestAnimationFrame(animate)</span></span></code> </pre> <br>  requestAnimationFrame is an indispensable tool for browser animations. <br><br>  Next, you want to animate some property over time, for example, take the coordinate of some object and increase it by some constant, which is essentially speed.  And here we are faced with delusion number 2. <br><br><h2>  Misconception number 2 </h2><br>  The speed is constant! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/a46/4d8/89ca464d8db2a3286ea2bd23d6408c9d.png"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  Since the function is called at different intervals, this can happen if some other computations occur at the same time in the system, and you get another trajectory that will not satisfy you.  Therefore, it is important to adapt how requestAnimationFrame works, based on the time difference.  And requestAnimationFrame, as the first parameter, gives the timestamp, which is a certain timestamp since the browser was opened.  In some browsers, this label will be a high accuracy label. <br><br><pre> <code class="javascript hljs">requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timestamp</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// DOMHighResTimeStamp // timestamp ~&gt; 30485.84100000153 })</span></span></code> </pre><br>  The rAF transmits a timestamp to the callback with an accuracy of five microseconds. <br><br>  In general, you can expect that it will be some kind of double (if you use a polyfil, it is unlikely), which contains milliseconds to the comma, and microseconds - after. <br><br>  We can use this label to calculate the difference between this and the previous function call. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> animate = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timestamp</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delta = timestamp - prevTimestamp <span class="hljs-comment"><span class="hljs-comment">// Note, it's a function now! x += velocity(delta) requestAnimationFrame(animate) }</span></span></code> </pre><br>  It is important to count the time difference between calls and animate the value in proportion to the delta! <br><br>  Therefore, we can enter a certain delta, which is the difference between the current label and the previous one for the call, and further we animate our variable, but only then it becomes a function.  Now that delta, which we got, we pass into the function.  And we consider speed proportional. <br><br>  Let's see what happens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e46/6be/65e/e466be65e6475903478c476a3b483d42.png"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  On the left - perfect animation, on the right - with our adaptive algorithm.  You may notice that the calls still do not occur at regular intervals.  And the animation on the right may not be as smooth as on the left - but it also has the same shape.  That is, we guarantee that it will look the same.  This is called frame skipping.  Performing animation at a specified time interval is not normal, but skipping frames in the animation is completely normal.  Therefore, using the delta approach, you can make high-performance animation. <br><br><h2>  Small example </h2><br>  In the video, it starts at <a href="https://youtu.be/Ug_dwJa07Os%3Ft%3D13m9s">13:09</a> . <br><br>  requestAnimationFrame is a great tool for arbitrary browser animations.  Because on it you can do any logic for animation. <br><br><img src="https://habrastorage.org/webt/ea/a4/z7/eaa4z7wmoz6_nj79ss6rzw9hypw.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  In the example, I derived particles that move according to some law.  This is a simulation of the movement of birds during the flight.  How would you make such an example in the browser?  Most likely, you would get the function tick, which would be called at the moment of animation rendering.  She would do two things: consider physics and then redraw. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redraw = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { points.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// make sure `will-change: transform` is set point.element.style.transform = ` translate3d(${point.x}px, ${point.y}px, 0.0px) rotate(${point.angle}rad)` }) } const tick = ts =&gt; { _lastRaf = requestAnimationFrame(tick) physicsStep(delta) redraw(delta) }</span></span></code> </pre><br>  About redrawing is very interesting, because if you use divs, as I am in the example, then in order to animate them quickly in browsers, you need to use transform.  But if you used margin, padding, or absolute positioning, then nothing would work for you, and if it worked, it would be very slow. <br><br>  It is very important that these elements have the property 'will-change: transform'.  This will ensure that the squares will be immediately in a separate layer of the browser and then composted into one common.  So it will be possible to achieve maximum performance.  Then we go over all points and expose what the turn and position of the point on the screen will be. <br><br>  Now, about stateful applications. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07f/560/5bb/07f5605bbd2e1a656a1ac6f612ea555b.png"><br><br>  I‚Äôm sure that many work with stateful applications without even knowing it.  And, most likely, they use an approach called Immutable UI. <br><br>  What is Immutable UI?  This is when you have a certain state, and you uniquely translate it into elements on the page.  This is usually just a render.  That is, you call the render function, after which the data that you have is translated into elements, and you get the status on the page.  Everything is great!  But then you start to perform some actions on the page, drive with a mouse or press keys on the keyboard, thereby creating events. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/019/632/6e6/0196326e6d7202fd1fd60e84549eb9c4.png"><br><br>  These events in your application cause states to change, as well as elements on the page.  That is, in fact, our application is a chain of states and the corresponding states of elements on the page.  But the problem is that if you work in react or in angular, then most likely for you, as a developer, this is hidden, because when you update the state, you see a redrawn new state on the screen.  Therefore, the question arises as to what to do with animations in this case. <br><br>  It should be noted that such an approach Immutable UI has many advantages, because you can easily test it and do absolutely crazy things. <br><br>  In the example under the spoiler, I made a semblance to do sheet (from <a href="https://youtu.be/Ug_dwJa07Os%3Ft%3D18m55s">6:55 pm</a> , insert the spoiler). <br>  I changed the states of his items, then brought them all at the same time and could travel back in time with respect to my actions.  All this is very cool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/ce1/c87/ea9ce1c87cca273309186b86898e45f9.png"><br><br><h2>  The easiest way to animate in Immutable applications </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/851/7d9/e60/8517d9e6087a551adc29bb320248afeb.png"><br><br>  Let's now take a look at the easiest way to create animation in Immutable applications.  These are css transitions. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">CSS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">property</span></span> // <span class="hljs-selector-tag"><span class="hljs-selector-tag">transition</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">transform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease</span></span>; // <span class="hljs-selector-tag"><span class="hljs-selector-tag">Conditional</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">state</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">change</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">className</span></span> ={isVisible ? 'is-visible' : 'is-hidden'} /&gt; // <span class="hljs-selector-tag"><span class="hljs-selector-tag">Direct</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">manipulation</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span>={{ <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: `<span class="hljs-built_in"><span class="hljs-built_in">translate</span></span>(${scale})` }} /&gt;</code> </pre><br>  CSS animations in React work out of the box.  Property transition + state change = animation. <br><br>  They are good because they are suitable for almost all the tasks that you have.  They work in the same way as our state-based applications.  We define a property, say how we want to animate it, how it should go from one state to another.  In addition, there are patterns for working with animation in React and other libraries. <br><br>  One of the patterns is replacing one class with another.  Well, you can manually change the styles on the element.  This is all clear. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"transform: translate(42.00px, 165.00px)"</span></span></span><span class="hljs-tag"> /&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/dw/2l/xt/dw2lxtm7c_hlms9-b5n_zai36yw.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  I made an example to demonstrate how CSS transitions work in React applications.  We have a set of points, according to a certain law, I translate them into coordinates and draw them.  This is just an array of elements with different properties.  If I completely change all the data, the image will change instantly, and the browser will finish the transition itself. <br><br>  In some cases, CSS transitions do not behave very naturally.  For example, if you run one animation and at the same time another one, then nothing will break, because the browser knows how to stop and go to a new state.  But real programs should not work that way. <br><br>  Fortunately, in the case of React there is a React-Motion library.  And on it I made the second demo ( <a href="https://youtu.be/Ug_dwJa07Os%3Ft%3D21m25s">21:25</a> ).  We took the same example: there is an array of points, we change their state, but we get a wrapper called Motion.  Everything happens the same way, and the library itself makes the transitions manually. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Motion</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{{x:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spring</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">42.00</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spring</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">165.00</span></span></span><span class="hljs-tag">))}}&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"transform: translate(42.00px, 165.00px)"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Motion</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/webt/z1/0p/in/z10pinv34qr3lfhaasbicwchcfk.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  React-Motion uses something similar to a physics engine.  That is, if you overlay the animation on each other, you will notice that the movements have become spring-loaded, and in general it looks nice. <br><br>  In React, it looks like this. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Motion</span></span></span><span class="hljs-tag">&gt;</span></span> {interpolated =&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">opacity:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interpolated.x</span></span></span><span class="hljs-tag"> }} /&gt;</span></span> } <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Motion</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  React-Motion uses an excellent function-as-a-prop pattern.  If you have any component and it has a body, its children, then these children need not be elements.  They can be any type of data, including a function that takes a state and returns items.  Such a recording scares newbies a little, but it works very well.  You may think that React-Motion climbs into the DOM, changes some properties.  In fact, it is not. <br><br>  This is the same requestAnimationFrame, about which we spoke at the very beginning, and at each animation step we simply update their state.  That is, each frame is a new state, a new render.  Surprisingly, it works. <br><br><img src="https://habrastorage.org/webt/aq/wf/zk/aqwfzknbmvtzoa9tfpkyhj5qmn8.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  One tip - do not use React-Motion everywhere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abb/508/453/abb508453eafc1c50661e9b8b488fa20.png"><br><br>  Unfortunately, it is not suitable for all cases.  Spring animations are not limited in time, that is, you need to make an animation that will run and run for 10 seconds, then React-Motion is not an assistant here. <br><br>  It is also difficult to work with complex animations, where one element is first animated, and then the second.  In principle, this can be done by the library, but it will not be very convenient. <br><br>  And finally, performance.  Anyway, nothing can compare with manual animation, that is.  when we climb into an element and change its transform.  Therefore, in some cases, React-Motion behaves ‚Äúgluttonously‚Äù, although it works well. <br><br><h2>  "Dirty" animations </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/851/bfe/53d/851bfe53db79c4e0472dab356d147469.png"><br><br>  Dirty animations - animations in which not always everything can be built on states. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dialog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>{ componentDidMount(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node = findDOMNode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Or $.animate, anime.js, GSAP, D3 ... Velocity(node, {scale: 1.5}, {duration: 1000}) } render(){ ... } }</span></span></code> </pre><br>  The ‚Äúanimation on input‚Äù pattern works through the componentDidMount hook and direct access to the element. <br><br>  Let's take a look at this using a dialog box.  You probably met this when you needed to show or hide the dialog box.  Most often, this was done using the componentDidMount pattern, that is, there is a hook in React that is called after the component has been added to the DOM.  But there is a problem: the dialog box may leave the DOM before the animation ends.  Therefore, this also needs to be monitored. <br><br>  If you are working with dirty input animations, that is, you are animating something at the input, the best advice is to save the animation handle and then cancel it if the component leaves the DOM ahead of time.  This feature is available when using the Velocity or jQuery animate libraries. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dialog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>{ componentDidMount(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node = findDOMNode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-comment"><span class="hljs-comment">// animate returns a cancellable // promise-like object this._anim = animate(node, { ... }) } componentWillUnmount(){ this._anim &amp;&amp; this._anim.cancel() } }</span></span></code> </pre><br>  That is, you can extract the component before the animation ends. <br><br><img src="https://habrastorage.org/webt/-j/qu/th/-jquthfku1kugabtix42_bd6uyu.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  In our example, the dialog box disappears immediately, and in principle we cannot animate the output.  Usually you get a certain flag that is responsible for showing the window or not, and you optionally render this component.  And here it will not be possible to make the output animation, because as soon as the component leaves the DOM, it will not be possible to animate it.  And with this you need to do something. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {this.state.showDialog &amp;&amp; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dialog</span></span></span><span class="hljs-tag"> /&gt;</span></span>} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  So let's write a wrapper that will work similarly and allow us to do output animation.  In our case, I called it Animated. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Animated</span></span></span><span class="hljs-tag">&gt;</span></span> {this.state.showDialog &amp;&amp; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dialog</span></span></span><span class="hljs-tag"> /&gt;</span></span>} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Animated</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  When the child elements appear inside, we start the input animation, and as soon as they disappear, we make the output animation and look at the edge cases. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7f/efd/e79/a7fefde794c9f17424f5c55ed58cda9a.png"><br><br>  If we imagine how the component could work, then we get just such a map.  We have four states in which a component can be at a certain moment: when it is animated, when on the screen, when it goes out and when it is already released.  With the first two states, everything is clear (entering, entered), but the question is what to do with the state (exitting) when the component goes out?  We no longer have these children who have been given to us.  We have to draw something.  Therefore, you can use such a trick, which is called ghostChildren, that is, leave it on the elements and components until the animation works. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Dialog</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"medium"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // =&gt; { type: Dialog, props: { size: 'medium' }, ... } const element = React.createElement(Dialog, { size: 'medium'})</span></span></code> </pre><br>  What is behind JSX? <br><br>  When we need to make an exit animation, we take the children, save, add to the state and make an exit animation.  In general, the code is not very pleasant. <br><br>  When we get new children, we can see that they have changed.  In this function, we look at what state we want to go to and what additional options we take.  The most important thing is that, using the link to the component, we can call its exit animation function and make the right transition. <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps){ <span class="hljs-comment"><span class="hljs-comment">// Exit transition if(this.props.children &amp;&amp; !nextProps.children){ return this.transitionState(st.EXITING, {children: this.props.children}) } } transitionState(transitionTo, opt = {}){ // .. FSM logic .. // Wait for `this._content.animateExit()` }</span></span></code> </pre><br>  Animated helper component with support for animated output. <br><br>  Let's see what happened (in the video from <a href="https://www.youtube.com/watch%3Fv%3DUg_dwJa07Os%26feature%3Dyoutu.be%26t%3D31m33s">31:33</a> ). <br><br><img src="https://habrastorage.org/webt/8h/it/q3/8hitq3gwmlxtpoolpm7rvgi55wm.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  Interestingly, if you change states too quickly, the animation will behave correctly.  Transitions will not be animated to the end and on time to leave the screen. <br><br>  But if you are writing to React, you will not have to do everything that we are doing now, because you can use the react-transition-group library.  It used to be a React addon.  I like the fact that the new version has a convenient helper called transition.  In general, this is a low-level component that emulates roughly the same thing that we just did. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transition <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-transition-group/Transition'</span></span> <span class="hljs-comment"><span class="hljs-comment">// `state` is 'entered', 'entering', 'exited' etc. &lt;Transition in={isVisible} timeout={duration}&gt; {state =&gt; &lt;ModalDialog animationState={state} /&gt;} &lt;/Transition&gt;</span></span></code> </pre><br>  React-transition-group@2.0 is a declarative component for entry / exit animations. <br><br>  Using the so-called dirty components, you can make complex components in which state changes occur. <br><br><img src="https://habrastorage.org/webt/ph/vb/he/phvbheagrq5j_mlxwru6ginpry4.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  In the next example (in the video from <a href="https://www.youtube.com/watch%3Fv%3DUg_dwJa07Os%26feature%3Dyoutu.be%26t%3D32m57s">32:57</a> ) I made a histogram on which the values ‚Äã‚Äãchanged.  In essence, this is a large component that automatically receives states from the network and from websockets.  It is necessary that the animation itself was executed, so my component looks like a normal one, but inside it animates states with the help of dirty animations.  In this case, I used D3. <br><br>  Sometimes it is impossible to access the element and you need to use the Web API, the so-called dirty components - this is Canvas and so on. In this case, you can apply the pattern - taking over responsibility. <br><br><pre> <code class="javascript hljs">render(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> } // Render only once! shouldComponentUpdate() { return false } componentWillReceiveProps(nextProps){ if(this.props.color != nextProps.color){ // Animate on canvas... } }</span></span></code> </pre><br>  With the help of hooks, you can completely take over the responsibility for rendering.  For example, to work with Canvas, WebGL, WebAudio and so on. <br><br>  So, you render once.  Then you say that you will not render this component, since you take responsibility and return false in a special function.  Next in the componentWillReceiveProps hook, you see which properties came in, if they changed, and perform the desired animation.  It sounds simple, but in practice it turns out that it is not always convenient to animate.  Let's see why. <br><br>  I made this component on WebGL.  This is an icosahedron.  I pass through two properties to it from above, = how to turn it vertically and horizontally.  And inside the componentWillReceiveProps function, I compare the cast and do the necessary transformations. <br><br><img src="https://habrastorage.org/webt/as/_6/lw/as_6lwz8r70xfkhculvevhs14tu.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  This rotation is not entirely natural, it looks rough and is accompanied by jerks.  But there is a trick called a controller that allows you to make a smooth animation. <br><br><img src="https://habrastorage.org/webt/1m/x1/dl/1mx1dl7npadgcs7uktgwietqhiw.gif"><br><br>  What is the difference?  In the fact that earlier we looked at what came from above and renewed the internal state, therefore, the turn was instantaneous.  And the controller works a little differently.  The controller is a concept from control theory.  In our case, this is a P-controller, a special case of a PID controller.  This is the area that controls the hands of the robot. <br><br>  In our case, this is a simple controller, and its actions are based on the following effect. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Limit delta to avoid divergence const delta = Math.min(100.0, ts - prevTs) const P = 0.001 + delta this.x = P + (this.target - x)</span></span></code> </pre><br>  P-controller is convenient for smooth unlimited time animations. <br><br>  We have a string, there is a value (this.x) and we need to translate it into the target.  We look how far we are from the right place, multiply by the coefficient and move to this point.  In general, the formula is the same as for Hooke's law, and for the springs.  I want to note that if you use requestAnimationFrame and controllers in animation, it is best if you add a delta.  The one you received between calls requestAnimationFrame.  And in this case, I have limited it, because if you switch to another tab of the browser, and then come back, you will have a very large delta.  This will cause you to have very large values, and the spring will break.  Therefore, we limit it, multiply by some constant and use. <br><br>  Using the pattern of "interception of responsibility", you can work with physics. <br><br><img src="https://habrastorage.org/webt/g0/mg/fs/g0mgfs-um4b7mj8audggu-oi44c.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3d/c60/3a2/c3dc603a2a63ccf00d973a207e21e594.png"><br><br>  If you make dirty components, then you must ensure that: <br><br><ol><li>  Your components had a clean interface. <br></li><li>  Side effects were hidden <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/134/ac8/08b/134ac808b9dbbbdb445854bbf4e48c54.png"><br><br>  In principle, these rules work in the opposite direction.  For example, you are working in a stateful application and you need to run animations.  Then you need to set some trigger (for example, a state change), monitor this change inside the component and start the animation. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Actuator, actuate } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-actuator'</span></span> <span class="hljs-comment"><span class="hljs-comment">// Inside the component &lt;Actuator on={{ animateBadge: this.animateBadge }} /&gt; // Where the business logic is store.dispatch(actuate('animateBadge')) store.dispatch(actuate('highlighUser', { id: 1 }))</span></span></code> </pre><br>  It is convenient to use the pattern in Redux-applications, where the global state is the only way to communicate. <br><br>  We often work with Redux, and in order to make an animation, sometimes we have to do so that the application animates all things independent of our current module. <br><br>  I published a small open-source utility - redux-actuator.  There is such an actuator that allows you to trigger events inside the components. <br><br><img src="https://habrastorage.org/webt/6p/xy/xb/6pxyxbvinc0h3mxhev7c6oezmj0.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br><br>  How it looks, you can look at the video from <a href="https://www.youtube.com/watch%3Fv%3DUg_dwJa07Os%26feature%3Dyoutu.be%26t%3D40m27s">40:27</a> .  The fact is that we take a key in our state and change it to another.  That is, we need to make sure that the state really changes.  In the case of an actuator, I do the following: I take some event id and make it out of the current time and counter in order to avoid collisions.  And so you can trigger an animation. <br><br><img src="https://habrastorage.org/webt/b6/5z/up/b65zupbkxegjlk9umh7zomlxwyw.gif"><br>  <sup><a href="http://molefrog.com/stateful-animations/">View demo</a></sup> <br>  You may have a question about how to make complex animations (for example, see the video from <a href="https://www.youtube.com/watch%3Fv%3DUg_dwJa07Os%26feature%3Dyoutu.be%26t%3D41m27s">41:27</a> ).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will say this, the animations in the code will almost always look ugly. The main thing is to make the right decomposition. We know how to do exit animations, so the trick is to properly share responsibility. In this case, we take the layer that goes away, that is, the one in which the item's are located. We leave it on the screen while the animation is on, and then we apply a technique called FLIP. In my example, not quite FLIP, but the principle is the same. FLIP is when you take an element, immediately draw what you want to get, as if you instantly go into the route with a preview. You make the first route transparent, and you position the second one, put it in the DOM, start the animation. Then, when the animation worked and this element appears under another, you simply replace it and remove it from the DOM. But, unfortunately, in React now there is no simple utility in orderto do it, but it is possible. The main thing is to make the right decomposition.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/287/d6a/166/287d6a16640465b7c2772df95505def2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we have considered several approaches to animation. </font><font style="vertical-align: inherit;">We mainly worked under one component. </font><font style="vertical-align: inherit;">We first looked at pure animations. </font><font style="vertical-align: inherit;">They are called like that because they fully work on states. </font><font style="vertical-align: inherit;">Next come the dirty animations: they basically look clean, but inside they use access to the DOM. </font><font style="vertical-align: inherit;">Finally, there is a third type of component that completely intercepts the render. </font><font style="vertical-align: inherit;">When you need to work with Canvas, WebGL, you use a render capture approach. </font><font style="vertical-align: inherit;">Plus complex cases that are solved by proper decomposition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to advise reports on the topic of animation, which can be viewed.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ee/414/92b/3ee41492be1c92ed0f7cafe7569723af.png"><br><br><h3>  Links </h3><br><ul><li> <a href="https://github.com/molefrog/stateful-animations/tree/2dcbacdae2b0a3c83dc55cc93113f768830fb05f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommit presentation in Russian</font></font></a> </li><li> <a href="http://molefrog.com/stateful-animations/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web presentation in English with demo</font></font></a> </li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additions to the original report: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In React, starting from version 16.3, the componentWillReceiveProps method becomes deprecated, since The new renderer will not be able to support it. Usually this hook was used to set the state based on the props that are passed to the component. Now the React team advises to smoothly move away from componentWillReceiveProps towards getDerivedStateFromProps. But the problem is that the method is now static, so if it still works to transform props into a state, then there is definitely no responsibility for intercepting responsibility. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read more </font></font><a href="https://medium.com/%40baphemot/whats-new-in-react-16-3-d2c9b7b6193b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now there is no official solution for this case, but its support should appear very soon, as there are enough packets in npm that use interception of responsibility. For example, react-canvas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an official way to launch high-performant animations in React Native. I learned about this API after the report. It is called &lt;Animated /&gt;, as a component of the examples in the report. At the same time, these are components completely different in principle of operation. The meaning is the following: to make productive animations in RN, the trick with setState and redrawing each frame as in react-native will not work - this is too hard for smartphones, given that RN applications work through so-called. "bridge".</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS and render are performed in a separate thread, and the result is then synchronized with the native View (in iOS) in other threads. Therefore, the developers have provided such a tunnel for low-level animations. You wrap your component in &lt;Animated /&gt;, say which styles should be animated, and connect with the properties being animated. Moreover, the properties may depend on each other, it is possible to make spring dependencies, sequences, etc. This approach has many limitations, the main one is that we cannot influence the method of calculating properties from JS, their dependencies are completely declarative, since the dependency tree must be serialized (in order to be sent to the lower levels). There are even components for setting animation algebra: </font></font><a href="https://github.com/motiz88/animated.macro"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/motiz88/animated.macro</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any case, this is a very interesting designed API, the implementation of which on the web would solve the issues from the report. </font><font style="vertical-align: inherit;">For example, canceling an animation when a component exits. </font><font style="vertical-align: inherit;">Or it would be possible to describe complex cases, like ‚Äúgrabbed-pulled-animation‚Äù. </font><font style="vertical-align: inherit;">The future of web animations in React is exactly here somewhere.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We hope you find the experience of Alexey useful. </font><font style="vertical-align: inherit;">And if you like to savor the details of the development on JS just as we do, you will probably be interested in these reports at our </font></font><a href="https://holyjs-piter.ru/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS 2018 Piter</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference </font><font style="vertical-align: inherit;">, which was only a couple of weeks from now:</font></font><br><br><ul><li> <a href="https://holyjs-piter.ru/talks/2tmryuscgwykqms0ouqees/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mining crypto in browser: GPU, WebAssembly, JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Denis Radin, Evolution Gaming)</font></font><br></li><li>  <a href="https://holyjs-piter.ru/talks/4vxicrybq84iyqiwkigyko/">JavaScript debugging using Chrome DevTools</a> (Alexey Kozyatinsky, Google) <br></li><li> <a href="https://holyjs-piter.ru/talks/2qmbjzjpl2iki2imckwsqc/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offline VS Online client speed metrics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Alexey Kalmakov, Yandex)</font></font><br></li><li> <a href="https://holyjs-piter.ru/talks/3wy7ejpjymg6cqu0igqywa/">React Native Deep Inside</a> ( , Lowl.io) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/354550/">https://habr.com/ru/post/354550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354540/index.html">Survey: more than half of e-banking systems contain critical vulnerabilities</a></li>
<li><a href="../354542/index.html">How to make sure my site is not blocked by RKN</a></li>
<li><a href="../354544/index.html">Great content with small forces</a></li>
<li><a href="../354546/index.html">DevConf: from shawarma to symfony or legacy migration</a></li>
<li><a href="../354548/index.html">Introduction to complex numbers</a></li>
<li><a href="../354552/index.html">Accelerating Angular Applications</a></li>
<li><a href="../354554/index.html">2nd generation Infortrend EonStor DS2024 storage system review and testing</a></li>
<li><a href="../354558/index.html">Can I trust my Chrome and Firefox synchronization passwords?</a></li>
<li><a href="../354560/index.html">Conference BLACK HAT USA. ‚ÄúHow the feds caught the Russian mega-carder Roman Seleznev‚Äù</a></li>
<li><a href="../354562/index.html">Forms should be simple and declarative.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>