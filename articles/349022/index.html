<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study and implement the algorithm of the correct observer pattern for react components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, we continue to develop the observer-pattern. In the previous article from the old and very simple "observer" pattern, in small steps we came to mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study and implement the algorithm of the correct observer pattern for react components</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/q1/sa/pw/q1sapwaljlzlnmjvhltyernqtzi.png"></p><br><p>  So, we continue to develop the observer-pattern.  In the <a href="https://habrahabr.ru/post/348960/">previous</a> article from the old and very simple "observer" pattern, in small steps we came to mobx and wrote its mini-version.  In this article, we will write a full-fledged version of mobx that implements the algorithm for updating dependencies in the correct order to avoid unnecessary calculations.  I must say that attempts to describe this algorithm in Habr√© have been made earlier in the articles of Comrade <a href="https://habrahabr.ru/users/vintage/" class="user_link">vintage</a> about atoms <a href="https://habrahabr.ru/post/235121">here</a> , <a href="https://habrahabr.ru/post/240773">here</a> , and <a href="https://habrahabr.ru/post/317360">here,</a> but the last ‚Äúcorrect‚Äù update procedure is not fully described there and this will be discussed in this article. </p><a name="habracut"></a><br><p>  So in the last article, in order for the components of the reactor to automatically subscribe to the data that they render and when changing, the rerender of only the necessary components was called, we came to this modification of the observer pattern </p><br><pre><code class="hljs kotlin">let CurrentObservables = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class"> </span></span>{ listeners = new Set(); <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurrentObservables) CurrentObservables.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(newValue !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.notify(); } } subscribe(listener){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.add(listener) } unsubscribe(listener){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.delete(listener) } notify(){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners){ listener(); } } } function connect(target){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span></span>(React.Component.isPrototypeOf(target) ? target : React.Component) { stores = new Set(); listener = ()=&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({}) render(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores.forEach(store=&gt;store.unsubscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores.clear(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prevObservables = CurrentObservables; CurrentObservables = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores; cosnt rendered = target instanceof React.Component ? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.render() : target(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores = CurrentObservables; CurrentObservables = prevObservables; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores.forEach(store=&gt;store.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rendered; } componentWillUnmount(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stores.forEach(store=&gt;store.unsubscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener)); } } }</code> </pre> <br><p>  Let's reconsider a bit - let's take the logic of installing a global array inside the observer itself.  This can be represented as, for example, a table cell in Google-Dox - there is a cell that simply stores the value and there is a cell that stores not only the value (which will be cached), but also the formula (function) for its recalculation.  And at the same time, in addition to the formula for the recalculation function, we will add another function parameter to perform side effects, such as calling setState ({}) on the component when the value changes.  As a result, we get the following Cell class. </p><br><pre> <code class="hljs kotlin">let CurrentObserver = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ reactions = new Set(); dependencies = new Set(); tracked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value, fn = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, reactionFn = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = fn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn = reactionFn } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tracked) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentObserver) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.add(CurrentObserver); CurrentObserver.dependencies.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = newValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reaction of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions) { reaction.run(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } run() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentObserver = CurrentObserver; CurrentObserver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldDependencies = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies = new Set(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn(); CurrentObserver = currentObserver; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep of oldDependencies){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies.has(dep)){ dep.reactions.delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tracked &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentObserver = CurrentObserver; CurrentObserver = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn(); CurrentObserver = currentObserver; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tracked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } unsubscribe(){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies){ dep.reactions.delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tracked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } function connect(target){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span></span>(React.Component.isPrototypeOf(target) ? target : React.Component) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cell = new Cell(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.Component.isPrototypeOf(target) ? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.render() : target(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props); }, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); <span class="hljs-comment"><span class="hljs-comment">//  setState({})  forceUpdate()           }); } render(){ return this._cell.get(); } componentWillUnmount(){ this._cell.unsubscribe(); } } }</span></span></code> </pre> <br><p>  Now find out the update modes of our observer.  In the example above, we still have all the observers active - after the first time <code>.get</code> he subscribed to his dependencies and will be called every time a dependency changes its value.  This mode is convenient for components that need to be updated every time the data on which they are subscribed changes, but there are so-called "cached" or "memoized" functions for which this behavior is undesirable.  For example, there is an observatory <code>const fullName = new Cell(()=&gt;firstName.get() + lastName.get())</code> which should calculate the full name when either the first name or the last name changes.  But what if after it is calculated to the fullName in the application, under some conditions, it is not necessary to apply?  We will get an extra calculation and to avoid this, we can make it so that the component is not calculated immediately, but only when it is not addressed to it - when calling <code>.get()</code> . </p><br><p>  The extra calculations are generally the key point when comparing libraries based on the model of "cells and formulas in a table".  Unnecessary calculations may appear if the algorithm for determining which dependencies need to be called after the value has changed in the case of the rhomboid dependency diagram (when there are cycles in the dependency graph), which is wrong (as in our example above) </p><br><p>  Let's consider this situation - there are four cells - <code>firstName</code> , <code>lastName</code> , <code>fullName</code> (which calculates the full name) and <code>label</code> (which displays either the name if it is long, otherwise the full name) </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-string"><span class="hljs-string">"fff"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-string"><span class="hljs-string">"lll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-string"><span class="hljs-string">""</span></span>, ()=&gt;firstName.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-string"><span class="hljs-string">""</span></span>, ()=&gt;firstName.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().length &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? fullName.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() : firstName.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()))</code> </pre> <br><p>  Here, the simplest version of diamond-shaped dependencies is on <code>fullName</code> , the <code>label</code> depends on <code>fullName</code> , but the <code>label</code> also depends on <code>firstName</code> and it turns out like a cycle. <br>  It is necessary to clarify that in the process we are interested in recalculating only the values ‚Äã‚Äãof the <code>label</code> cell (for example, you need to render in the component), so if you suddenly need to calculate the <code>fullName</code> value for the <code>label</code> , then you don‚Äôt need to calculate it. </p><br><p>  And here is the first bug - when changing <code>firstName</code> - in our <code>Cell</code> implementation, when we cycle, we call subscribers the <code>label</code> component will be calculated twice - the first time the <code>firstName</code> will call the <code>label</code> because it is signed directly, and the second time the <code>label</code> calculated when <code>fullName</code> changes its value.  The first <code>label</code> calculation is not necessary because it contains temporary data - the new name and the old <code>fullName</code> .  Accordingly, we need to get rid of unnecessary calculations and we can only do this by calling the subscribers in the correct order - first <code>fullName</code> and then <code>label</code> . </p><br><p>  How can we do this?  If you think that there are a couple of options. </p><br><p>  One option is the "dirty-clean" method, which is described by the mobx author in his report on the mobx device ( <a href="https://www.youtube.com/watch%3Fv%3DTfxfRkNCnmk">https://www.youtube.com/watch?v=TfxfRkNCnmk</a> ) (funny that the author actually lied because mobx doesn‚Äôt implement this is a more correct algorithm but more on that later). <br><br><img src="https://habrastorage.org/webt/9n/ul/gs/9nulgssatr2nogrbpqwlrnba8hc.png"><br><br>  In short, the algorithm consists of a method of distributing a function call according to a dependency graph and identifying the value of the "depth" of each dependency through the increment-decrement of the counter and then calling them in the order of increasing depth.  Suppose that when a name is changed, the <code>firstName</code> cell will not immediately call subscribers in the loop, but set the value 1 to each of the listeners and call them so that each set the value of its subscribers to 1 more than that of itself.  And so recursively.  The <code>fullName</code> cell will receive the values ‚Äã‚Äã1 and the <code>label</code> cell will receive the value 2 because the counter is first labeled <code>firstName</code> cell and then the <code>fullName</code> cell.  Now, after the recursive call has ended, the <code>fistName</code> cell calls the reverse procedure - reducing the counter recursively at its subscribers.  And now the moment - after the counter reduction code has been called up, it is necessary to check if the value has returned to zero, then only then the cell should be recalculated.  So, the <code>label</code> counter decreases from 2 to 1 (but is not calculated because it is not 0) then the <code>fullName</code> counter decreases from 1 to 0 and calculates <code>fullName</code> and only then the <code>label</code> itself is calculated because <code>fullName</code> after calculation causes the <code>label</code> counter to decrease from 1 to 0. </p><br><p>  Thus, we obtained <code>label</code> calculation only once after all dependent cells update themselves and are of current importance. </p><br><p>  Another option (which in fact is an optimized version of the first) would be the idea to call subscribers in order of increasing depth.  Under the cell depth, we take the maximum depth of our dependent cells + 1 and a cell without a formula that has no dependencies will have a depth of 0. We get that <code>firstName</code> and <code>lastName</code> will have a value of 0, <code>fullName</code> will have a value of 1 and the <code>label</code> will have a value of 2 because the maximum value for subscribers ( <code>fullName</code> and <code>firstName</code> ) is 1, we get +1 and we get 2. </p><br><p>  Now when the <code>fistName</code> cell updates its value, it should call its subscribers in increasing depth order ‚Äî first <code>fullName</code> and then <code>label</code> .  An array can be sorted each time it is called, or it can be optimized and inserted into a sorted array at the moment of adding a new dependency. </p><br><p>  The depth value also needs to be updated each time a new subscriber is added by comparing its value with the current cell value. </p><br><p>  In this way, we will get a call to subscribers in the correct order and avoid unnecessary calculations.  Nearly... </p><br><p>  In both cases, there is one very inconspicuous bug.  The <code>label</code> cell formula does not just depend on <code>firstName</code> and <code>fullName</code> ‚Äî it depends on them under certain conditions.  If the value is <code>firstName.get().length &lt;= 3</code> then we output <code>fullName</code> but if the value is greater than 3, then we depend only on <code>firstName</code> .  Now let's think about what happens when the <code>firstName</code> value changes from 4 to 3. The <code>firstName</code> cell updates its value and should call subscribers in depth order ‚Äî there will be a <code>fullName</code> call that calculates its value and then a <code>label</code> call that calculates its value already having the <code>fullName</code> actual value.  At first glance, everything seems to be correct.  But if you think that the calculation of <code>fullName</code> is not really necessary here - because the value of <code>fistName</code> will be 3, which means that when the <code>label</code> last called, it will not need to call <code>fullName.get()</code> because the if branch will simply not be executed.  Moreover, the next time when you need to call <code>fullName</code> its value will be irrelevant because between its call the lastName can be updated as many times as you like.  Here you have a bug with the extra calculation.  As a result, our algorithm with calling subscribers in the order of their depth does not work in the general case. </p><br><p>  So, there is the ‚Äúright‚Äù algorithm, which under no circumstances and tricky dependencies will not cause a double cell calculation.  To begin with, I‚Äôll give you a code that, in combination, is almost a full-fledged version of mobx (with the exception of an array and decorators) just 85 lines </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ reactions = new Set(); dependencies = new Set(); runned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value, fn = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, reactionFn = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, active = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = fn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn = reactionFn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = fn ? <span class="hljs-string"><span class="hljs-string">"dirty"</span></span> : <span class="hljs-string"><span class="hljs-string">"actual"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state !== <span class="hljs-string"><span class="hljs-string">"actual"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actualize(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentObserver) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.add(CurrentObserver); CurrentObserver.dependencies.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = newValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reaction of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions) { reaction.mark(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } runPendingCells() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } mark(dirty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = dirty ? <span class="hljs-string"><span class="hljs-string">"dirty"</span></span> : <span class="hljs-string"><span class="hljs-string">"check"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reaction of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reaction.state === <span class="hljs-string"><span class="hljs-string">"actual"</span></span>) reaction.mark(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.active) PendingCells.push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } actualize() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state === <span class="hljs-string"><span class="hljs-string">"check"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state === <span class="hljs-string"><span class="hljs-string">"dirty"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; dep.actualize(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state === <span class="hljs-string"><span class="hljs-string">"dirty"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = <span class="hljs-string"><span class="hljs-string">"actual"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state === <span class="hljs-string"><span class="hljs-string">"dirty"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run(); } } run() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentObserver = CurrentObserver; CurrentObserver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldDependencies = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies = new Set(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn(); CurrentObserver = currentObserver; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep of oldDependencies) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies.has(dep)) dep.reactions.delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = <span class="hljs-string"><span class="hljs-string">"actual"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentObserver = CurrentObserver; CurrentObserver = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runned); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runned) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runned = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CurrentObserver = currentObserver; } } unsubscribe() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies) { dep.reactions.delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dep.reactions.size === <span class="hljs-number"><span class="hljs-number">0</span></span>) dep.unsubscribe(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = <span class="hljs-string"><span class="hljs-string">"dirty"</span></span>; } } function runPendingCells() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cell of PendingCells) { cell.actualize(); } }</code> </pre> <br><p>  And now the description: <br>  Let the cell have three states - "actual" (which means that the value of the formula is relevant), "dirty" (which will mean that as soon as <code>get()</code> called, the cell should be recalculated) and "check".  Now, as soon as the cell changes its value, it will not immediately trigger the calculation of subscribers in any order, but will mark its subscribers as "dirty".  And those, in turn, will also mark their subscribers, but only with the value "check" and those, in turn, will also mark their subscribers with the value "check", and so on recursively to the end.  That is, only subscribers of the cells that have changed will have the value "dirty" and all the rest until the end of the tree - the value of "check", and so that we do not get stuck in a recursive call, we need to cause recursion only for those cells that have not been marked ( actual ") </p><br><p>  Further, when reaching the end of the tree - that is, the cell that has no more subscribers and is ‚Äúactive‚Äù, you must add such a cell to some global array of <code>PendingCells</code> .  An "active" is a cell that represents not some kind of memosized function (the value of which may not be needed right now), but a reaction (for example, a component of the reactor) that should be launched each time any of the dependent cells changes its value. </p><br><p>  As a result, when the cell has changed its value and caused this recursive process for its subscribers, we will have in the global array <code>PendingCells</code> some root cells that have no dependencies but which can directly or indirectly depend and appropriately or be recalculated (if all of the intermediate cells in the chain will change their value) or will not (if someone in this chain does not change its value when recomputing) </p><br><p>  Now go to the second stage.  A cell that has changed and caused a recursive process for its subscribers, calls a certain global function <code>flush()</code> which takes the cells that have accumulated in the global array <code>PendingCells</code> and will call their <code>actualize()</code> function.  This function will be recursive and will do this ‚Äî if the cell value is "dirty", it will recalculate its formula (and we remember that the value of "dirty" will be only cells that are direct subscribers to the cell that has changed, and all the rest will be set to "check").  If the value is "check", the cell will ask its dependent cells to be updated (call the <code>actualize()</code> method) and then check its value again and if it is equal to "check", then we change the value to "actual" and do not call recalculation if if it is "dirty", then we must respectively recalculate.  At the same time, checking for "dirty" is necessary after calling "actualize ()" on each dependent cell, because if the cell is set to "dirty" it makes no sense to call for updating other cells and you can immediately interrupt the cycle and recalculate.  And the fact that the other cells are not updated, it does not matter, because if the cell is accessed to get the value of the formula in the <code>.get()</code> method, the cell should check its value and if it is "check", then it should call this <code>actualize()</code> method and if "dirty" then recalculate appropriately.  That's all, the end of the algorithm. </p><br><p>  So, at first glance, the algorithm may seem complicated, but it is quite simple - when a cell changes its value, we have only 2 stages - the first stage is a recursive descent to mark as dirty (for the first level) and check for everyone else and the second stage is a recursive ascent which is the actualization of values. </p><br><p>  Now I will clarify some unobvious moments. </p><br><p>  The first is how does one avoid that bug with extra recalculation?  This is because we do not have a hard condition to cause a recomputation of dependent cells in a cell that has changed.  Dependent cells will be marked as dirty, and that‚Äôs all - they are calculated only when you need to know their value somewhere.  That is, in the bug example, the <code>fullName</code> cell will simply be marked as "dirty" and then its value will not be computed since the <code>label</code> fulfills the condition <code>firstName.get().length === 3</code> and the <code>label</code> will no longer depend on <code>fullName</code> . </p><br><p>  The second is why such a strange action ‚Äî inside the <code>actualize()</code> method ‚Äî to check ‚Äî if the value is "check", then call <code>actualize()</code> on the dependent cells both in the process and again after the cycle, re-check the value and if "dirty" then interrupt the cycle and cause recalculation and if "check" then reset after the cycle to "actual" and do nothing?  The thing is that in the process of calling <code>actualize()</code> on dependent cells, some of them may have the value "dirty" and as we know they need to recalculate.  And in the calculation there is a condition - if the cell has changed its value, then it should mark its listeners as "dirty".  And so the cell that was previously ‚Äúcheck‚Äù can, after updating its dependent cells, change the value itself when any of them change and, accordingly, need to check the condition again.  But only in this case, if no dependent cells have changed their value, it means that the cell itself doesn‚Äôt have a meaning to be calculated and we change the value from "check" to "actual" </p><br><p>  Well, now we can check the effect of this algorithm on our bug example.  The <code>firstName</code> changes, the <code>label</code> and <code>fullName</code> cells are marked as "dirty" and only the <code>label</code> goes into the global array <code>PendingCells</code> because <code>fullName</code> not an "active" cell as a <code>label</code> but simply memorates its value and will be updated only when it is accessed and not immediately.  Further, the <code>label</code> because "dirty" will immediately recalculate, but since <code>firstName.get().length === 3</code> we do not need the <code>fullName</code> value and we will thus avoid unnecessary recalculation. </p><br><p>  Honestly, the description of the algorithm takes up much more space than its implementation.  This typescript code as well as the example with the reactant and the test for the calculation bug are in the repository ( <a href="https://github.com/bgnx/xmob">https://github.com/bgnx/xmob</a> ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349022/">https://habr.com/ru/post/349022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349010/index.html">Technical support: a technological approach to solving technical problems</a></li>
<li><a href="../349012/index.html">Why your application looks better in Sketch</a></li>
<li><a href="../349014/index.html">Learning KTX for Android</a></li>
<li><a href="../349016/index.html">Deep Learning in Natural Language Processing</a></li>
<li><a href="../349020/index.html">Hackathon live. Accelerate mobile sites</a></li>
<li><a href="../349024/index.html">OpenJDK Release Candidate 10ÔºÅ</a></li>
<li><a href="../349028/index.html">HTTP Codes in Valentine's Day Comics</a></li>
<li><a href="../349030/index.html">How to: Properly call class property methods</a></li>
<li><a href="../349032/index.html">Manage IAX channels with a lot of Asterisk</a></li>
<li><a href="../349034/index.html">Debug Embox on STM32</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>