<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to protect against stack overflow (on Cortex M)?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are programming on a ‚Äúbig‚Äù computer, then you most likely do not have such a question. Stack a lot to overfill, you need to try. In the worst c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to protect against stack overflow (on Cortex M)?</h1><div class="post__text post__text-html js-mediator-article">  If you are programming on a ‚Äúbig‚Äù computer, then you most likely do not have such a question.  Stack a lot to overfill, you need to try.  In the worst case, you click OK on a window like this and go to figure out what's wrong. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/c2c/358/b12c2c358fa3a040589578b71521957b.png" alt="image"></div><br>  But if you program microcontrollers, the problem looks a little different.  First you need to <i>note</i> that the stack is full. <br><br>  In this article I will talk about my own research on this topic.  Since I program mainly under STM32 and under Milander 1986 - I focused on them. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Imagine the simplest case - we are writing a simple single-threaded code without any operating systems, i.e.  we have only one stack.  And if you, like me, are programming in uVision Keil, then the memory is distributed like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/er/tb/to/ertbtohh-xf2meqxvzekrxlmwoe.png"><br><br>  And if you, like me, consider the dynamic memory on microcontrollers evil, then like this: <br><br><img src="https://habrastorage.org/webt/op/bu/el/opbuelnjpcvre-9jjpm_qnrlqcw.png"><br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  If you want to prohibit the use of heaps, you can do this: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> import(__use_no_heap_region)</span></span></code> </pre> <br>  Details <a href="http://www.keil.com/support/man/docs/armlib/armlib_chr1358938927854.htm">here</a> <br></div></div><br>  Okay, what's the problem?  The problem is that Keil places the stack <b>right</b> behind the static data area.  A stack in Cortex-M is growing in the direction of decreasing addresses.  And when it overflows, it simply climbs out of its allotted piece of memory.  And overwrites any static or global variables. <br><br>  It is especially great if the stack overflows only when entering an interrupt.  Or, even better, in a nested interrupt!  And quietly spoils some variable that is used in a completely different part of the code.  And the program falls on the aspert.  If you are lucky.  Spherical heisenbag, so you can search for a whole week with a lantern. <br><br>  Immediately, I‚Äôll make a reservation that if you use a bunch, then the problem doesn‚Äôt go anywhere, just a bunch of global variables spoil instead of global variables.  Not much better. <br><br>  Okay, the problem is clear.  What to do? <br><br><h2>  MPU </h2><br>  The simplest and most obvious is to use MPU (that is, Memory Protection Unit).  Allows you to assign different attributes to different pieces of memory;  in particular, you can surround the stack with read-only regions and catch MemFault when writing there. <br><br>  For example, in stm32f407 MPU is.  Unfortunately, in many other "younger" stm it is not.  And in Milandrovsky 19861 it is not there either. <br><br>  Those.  The solution is good, but not always affordable. <br><br><h2>  Manual control </h2><br>  When compiling, Keil can generate (and does this by default) an html report with a call graph (the linker option "--info = stack").  And this report provides information about the stack used.  Gcc can do this too (option -fstack-usage).  Accordingly, you can sometimes glance at this report (or write a script that does this for you, and call it before each build). <br><br>  And at the very beginning of the report a path was written leading to the maximum use of the stack: <br><br><img src="https://habrastorage.org/webt/eb/mh/ao/ebmhaouyrjjvnmziubxybt3zyg0.png"><br><br>  The problem is that if your code has function calls by pointers or virtual methods (and I have them), then this report can greatly underestimate the maximum stack depth.  Well, interrupts, of course, are not counted.  Not a very reliable way. <br><br><h2>  Tricky stack placement </h2><br>  I learned about this method from <a href="http://blog.japaric.io/stack-overflow-protection/">this article</a> .  An article about rust, but the basic idea is this: <br><br><img src="https://habrastorage.org/webt/i3/pz/yb/i3pzyb-ewbtxaei_oaz5mrhthda.png"><br><br>  With gcc, this can be done using <a href="https://stackoverflow.com/questions/18647590/linker-script-placing-a-section-at-the-end-of-a-memory-region/39477543">double linking</a> . <br><br>  And in Keil, you can change the location of areas using your linker script (Keil's scatter file).  To do this, open the project options and uncheck "Use memory layout from target dialog".  Then the default file will appear in the ‚ÄúScatter file‚Äù field.  It looks like this: <br><br><pre> <code class="cpp hljs">; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load region size_region ER_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 <span class="hljs-number"><span class="hljs-number">0x20000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00005000</span></span> { ; RW data .ANY (+RW +ZI) } }</code> </pre> <br>  What to do next?  Possible options.  <a href="http://www.keil.com/support/man/docs/ARMLINK/ARMLINK_pge1362065977713.htm">Official documentation</a> suggests defining sections with reserved names - ARM_LIB_HEAP and ARM_LIB_STACK.  But this entails unpleasant consequences, at least for me - the stack and heap sizes will have to be set in the scatter file. <br><br>  In all the projects I use, the stack and heap size is set in an assembler startup file (which Keil generates when creating the project).  I do not really want to change it.  I just want to include a new scatter file in the project, and everything will be fine.  So I went a little different way: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#! armcc -E ; with that we can use C preprocessor <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_BEGIN 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_SIZE_BYTES (4*1024) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BEGIN 0x8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_SIZE_BYTES (32*1024) ; This scatter file places stack before .bss region, so on stack overflow ; we get HardFault exception immediately LR_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load region size_region ER_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } ; Stack region growing down REGION_STACK RAM_BEGIN { *(STACK) } ; We have to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> heap region, even </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we don</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'t actually use heap REGION_HEAP ImageLimit(REGION_STACK) { *(HEAP) } ; this will place .bss region above the stack and heap and allocate RAM that is left for it RW_IRAM1 ImageLimit(REGION_HEAP) (RAM_SIZE_BYTES - ImageLength(REGION_STACK) - ImageLength(REGION_HEAP)) { *(+RW +ZI) } }</span></span></span></span></code> </pre> <br></div></div><br>  Here I said that all objects named STACK should be located in the REGION_STACK region, and all HEAP objects should be located in the REGION_HEAP region.  And everything else - in the region RW_IRAM1.  And I arranged the regions in this order - the beginning of the operatives, the stack, the heap, everything else.  The assumption is that in an assembler startup file, the stack and the heap are set using this code (ie, as arrays with the names STACK and HEAP): <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="hljs dos">Stack_Size <span class="hljs-keyword"><span class="hljs-keyword">EQU</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=<span class="hljs-number"><span class="hljs-number">3</span></span> Stack_Mem SPACE Stack_Size __initial_sp Heap_Size <span class="hljs-keyword"><span class="hljs-keyword">EQU</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=<span class="hljs-number"><span class="hljs-number">3</span></span> __heap_base Heap_Mem SPACE Heap_Size __heap_limit PRESERVE8 THUMB</code> </pre> <br></div></div><br>  Ok, maybe you ask, but what does it give us?  And that's what.  Now, when going beyond the stack, the processor tries to write (or read) a memory that does not exist.  And on STM32, an interrupt occurs on the exception - HardFault. <br><br>  This is not as convenient as MemFault because of the MPU, because HardFault may occur due to a variety of reasons, but at least the error is loud, not quiet.  Those.  it occurs immediately, and not after an unknown period of time, as it was before. <br><br>  What is the best thing, we did not pay for it, no lead overhead!  Great.  But there is one problem. <br><br>  <i>It does not work on Milandra.</i> <br><br>  Yes.  Of course, in Milandra (I'm mainly interested in 19861 and BE91) the memory card looks different.  Before STM32, there is nothing before the start of the operative, and on Milandra, before the operative, there is an area of ‚Äã‚Äãthe external bus. <br><br>  But even if you do not use an external bus, you will not get any HardFault.  And maybe get it.  Or maybe get it, but not immediately.  I could not find any information on this subject (which is not surprising for Milandra), and the experiments did not give any clear results.  HardFault <i>sometimes</i> arose if the stack size was a multiple of 256. Sometimes HardFault arose if the stack went very far into non-existent memory. <br><br>  But it doesn't even matter.  If HardFault does not occur every time, then simply moving the stack to the beginning of the RAM does not save us.  And if it‚Äôs really fair, the STM is also not obliged to generate an exception, the core specification of the Cortex-M seems to say nothing concrete about this. <br><br>  So even on STM it‚Äôs rather a hack, just not very dirty. <br><br>  So you need to look for some other way. <br><br><h2>  Access breakpoint to write </h2><br>  If we move the stack to the beginning of the RAM, then the stack limit will always be the same - 0x20000000.  And we can just put a breakpoint on the entry in this cell.  You can do this with a command and even register it in autorun using a .ini file: <br><br><pre> <code class="hljs pgsql">// breakpoint <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stackoverflow BS <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span> <span class="hljs-number"><span class="hljs-number">0x20000000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  But this is not a very reliable way.  This breakpoint will be triggered every time the stack is initialized.  It is easy to accidentally beat it by clicking "Kill all breakpoints".  And he will protect you only in the presence of a debugger.  No good. <br><br><h2>  Dynamic overflow protection </h2><br>  A quick search on this account led me to Keil's "--protect_stack" and "--protect_stack_all" options.  Options that are useful, unfortunately, they do not protect from overflowing the entire stack, but from getting another function into the stack frame.  For example, if your code goes beyond the bounds of an array or fails with a variable number of parameters.  Gcc, of course, also knows how to (-fstack-protector). <br><br>  The essence of this option is as follows: ‚Äúguard variable‚Äù, that is, a guard number, is added to each stack frame.  If this number has changed after exiting the function, the error handler function is called.  Details <a href="http://www.keil.com/support/man/docs/armcc/armcc_chr1359124940593.htm">here</a> . <br><br>  Useful thing, but not quite what I need.  I need a much simpler check - so that when entering each function, the value of the SP register (Stack Pointer) is reconciled with the previously known minimum value.  But do not write this test hands on entering each function? <br><br><h2>  SP Dynamic Control </h2><br>  Fortunately, gcc has a wonderful "-finstrument-functions" option that allows you to call a user-defined function when entering each function and when exiting each function.  This is usually used to display debug information, but what's the difference? <br><br>  Even more fortunately, Keil quite consciously copies the gcc functionality, and there the same option is available under the name "--gnu_instrument" ( <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0491h/CHDCEBEE.html">details</a> ). <br><br>  After that, you just need to write this code: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //   ,         scatter- extern unsigned int Image$$REGION_STACK$$RW$$Base; //    ,   static const uint32_t stack_lower_address = (uint32_t) &amp;( Image$$REGION_STACK$$RW$$Base ); //         extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_enter( void * current_func, void * callsite ) { (void)current_func; (void)callsite; ASSERT( __current_sp() &gt;= stack_lower_address ); } //   -   extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_exit( void * current_func, void * callsite ) { (void)current_func; (void)callsite; }</span></span></code> </pre> <br></div></div><br>  And voila!  Now, upon entering each function (including interrupt handlers), a stack overflow check will be performed.  And if the stack overflows - will be assert. <br><br><div class="spoiler">  <b class="spoiler_title">Small explanations:</b> <div class="spoiler_text"><ul><li>  Yes, of course, you need to check for overflow with a certain margin, otherwise there is a risk of ‚Äújumping over‚Äù the beginning of the stack. </li><li>  Image $$ REGION_STACK $$ RW $$ Base is the special magic of getting information about the memory area using the constants generated by the linker.  Details (although not very intelligible in places) <a href="http://www.keil.com/support/man/docs/armlink/armlink_pge1362065957713.htm">here</a> . </li></ul><br></div></div><br>  Is the solution ideal?  Of course not. <br><br>  Firstly, this check is far from free, the code from it swells up by 10 percent. Well, the code will work slower (although I did not measure it).  Whether this is critical or not is up to you;  In my opinion, this is a reasonable price for security. <br><br>  Secondly, it most likely will not work when using precompiled libraries (but since I don‚Äôt use them at all, I didn‚Äôt check them). <br><br>  But this solution is potentially suitable for multi-threaded programs, since we do the checking ourselves.  But I have not really thought of this idea yet, so for now I will hold it. <br><br><h2>  Let's sum up </h2><br>  It turned out to find working solutions for stm32 and for Milandr, although for the latter one had to pay with some overhead projector. <br><br>  For me, the most important thing was a small paradigm shift in thinking.  Prior to the <a href="http://blog.japaric.io/stack-overflow-protection/">aforementioned article,</a> I did not think at all that you could somehow protect against a stack overflow.  I did not perceive this as a problem that needs to be solved, but rather as a kind of spontaneous phenomenon - sometimes it rains, and sometimes the stack overflows, well, there's nothing you can do, you have to bite the bullet and suffer. <br><br>  And in general, I often notice for myself (and for other people) that - instead of spending 5 minutes in Google and finding a trivial solution - I have been living with my problems for years. <br><br>  I have it all.  I understand that I didn‚Äôt discover anything fundamentally new, but I didn‚Äôt come up with any ready-made articles (at least, Joseph Yu himself doesn‚Äôt offer this in an <a href="https://community.arm.com/processors/b/blog/posts/how-much-stack-memory-do-i-need-for-my-arm-cortex--m-applications">article</a> on this topic).  I hope in the comments I will be prompted, I am right or not, and what are the pitfalls of this approach. </div><p>Source: <a href="https://habr.com/ru/post/425071/">https://habr.com/ru/post/425071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425057/index.html">Preferential education loan for all GeekUniversity programs from GeekBrains and Alfa-Bank</a></li>
<li><a href="../425059/index.html">Hackathon number 1 in Tinkoff.ru</a></li>
<li><a href="../425061/index.html">CodeRainbow: interactive study and documenting code</a></li>
<li><a href="../425063/index.html">Migrating a non-downgrade database schema for postgresql using the example of django</a></li>
<li><a href="../425069/index.html">Testing presenter using PromiseKit</a></li>
<li><a href="../425073/index.html">Easy creation of a git repository on OneDrive</a></li>
<li><a href="../425075/index.html">Machine vision: installing, configuring and using Google Cloud Vision in PHP</a></li>
<li><a href="../425077/index.html">Kotlin under the hood - look decompiled bytecode</a></li>
<li><a href="../425079/index.html">Difficult IPSec with Linux</a></li>
<li><a href="../425081/index.html">The state does not know how much it spends on IT. Proving by numbers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>