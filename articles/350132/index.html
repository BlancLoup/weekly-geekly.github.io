<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GObject: Inheritance and Interfaces</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In comments to the previous article, it was often suggested that the GObject system is not needed due to the presence of C ++ and other high-level lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GObject: Inheritance and Interfaces</h1><div class="post__text post__text-html js-mediator-article">  In comments to the <a href="https://habrahabr.ru/post/348204/">previous article, it was</a> often suggested that the GObject system is not needed due to the presence of C ++ and other high-level languages.  In addition to purely technical points, which have already been discussed in the comments, I would like to touch on another aspect.  Probably the majority of commentators see the rationale for the existence of the GLib object system in the stubborn unwillingness of sichnik-retrogrades to enjoy the benefits of civilization and to accept the inexorable step of progress.  Probably the way it was at the dawn of Glib / GTK, originating in the world of UNIX systems, GNU, open-source, Stallman's ideas, etc. Most of that generation of hackers really preferred C, while C ++ was relatively young and undeveloped and the benefits of using it seemed not so obvious. <br><br>  Today, of course, for new projects, most of us would prefer using more convenient, concise and safe languages, even if we are familiar with all the nuances of using GObject.  However, one should not lose sight of the fact that in the more than 20 years of the existence of GLib / GTK, thousands of applications and libraries have been created with their use, many of which are being actively developed today by thousands of programmers from around the world.  They add new functionality, catch bugs, adapt them to modern technologies like HiDPI screens, Wayland, Vulkan, etc. In order to read (add, correct) the code of such projects, you need to have basic knowledge of object-oriented extensions for C, which we are talking about. <br><br>  I beg your mercy under cat.  We train, as usual, on cats :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/rg/a5/vd/rga5vdhjm3i1dfy0qi1k4alx6x0.jpeg"><br><a name="habracut"></a><br><h4>  All cycle about GObject: </h4><br>  <a href="https://habr.com/post/348204/">GObject Basics</a> <br>  GObject: Inheritance and Interfaces <br>  <a href="https://habr.com/post/418443/">GObject: encapsulation, instantiation, introspection</a> <br><br><h3>  Inheritance from the descendants of GObject </h3><br>  In general, GObject implies only single inheritance.  For multiple inheritance, it is proposed to use Java-like interfaces, which we will discuss in the second part of the article. <br><br>  Create the Tiger type, which will inherit from Cat, which we described in the last article.  This time we will make it a final-object and, thus, we will assume that there will be no further inheritance from it. <br><br>  Create animaltiger.h: <br><br><pre><code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#ifndef _ANIMAL_TIGER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ANIMAL_TIGER_H_ #include "animalcat.h" G_BEGIN_DECLS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ANIMAL_TYPE_TIGER animal_tiger_get_type() G_DECLARE_FINAL_TYPE (AnimalTiger, animal_tiger, ANIMAL, TIGER, AnimalCat)</span></span></code> </pre> <br>  Notice that we used the G_DECLARE_FINAL_TYPE macro instead of the G_DECLARE_DERIVABLE_TYPE macro to describe the object of the final type, and also that the last argument of the macro was the ‚Äúparent‚Äù AnimalCat. <br><br>  If we assumed a further inheritance chain with a derivable-object, we would need to describe the class and create an instance of the parent class as the first field in it;  in this case, we are not necessary. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* struct _AnimalTigerClass { AnimalCatClass parent_class; }; */</span></span></code> </pre> <br>  Let's declare a function that returns a new instance of our tiger: <br><br><pre> <code class="cs hljs">AnimalTiger* animal_tiger_new(); G_END_DECLS <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> /* _ANIMAL_TIGER_H_ */</span></span></code> </pre> <br>  Here it would be possible to declare other methods specific to the tiger object, but for simplicity, we limit ourselves to what it got from the parent - say_meow.  This is a virtual function, which we will give a specific implementation of our type.  After that close the macro G_END_DECLS.  In principle, there is no need to frame the header file with the G_BEGIN_DECLS / G_END_DECLS macros, they are decomposed into the banal extern "C" {} and are needed for compatibility with C ++ compilers.  These are just good form rules adopted in the GLib / GTK + development environment. <br><br>  Let's start the file with the source code of animaltiger.c: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include &lt;stdio.h&gt; #include "animaltiger.h" struct _AnimalTiger { AnimalCat parent; };</span></span></code> </pre> <br>  We connect the header and standard I / O and describe the structure-basis of our object.  In this case, since we are dealing with a final-object, we did not create a class-structure, but the main structure, an instance-structure, must be described explicitly. <br><br><pre> <code class="cs hljs">G_DEFINE_TYPE (AnimalTiger, animal_tiger, ANIMAL_TYPE_CAT)</code> </pre> <br>  In the initial macro, the last parameter is a macro that returns information about the type of the parent.  If you remember, we have defined this macro in the header file animalcat.h. <br><br>  Create a function animal_cat_real_say_meow (): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_real_say_meow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalTiger* self</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"Tiger say: ARRRRGH!!!\n"</span></span>); }</code> </pre> <br>  And two main functions: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_class_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalTigerClass* self</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"First instance of AnimalTiger was created.\n"</span></span>); AnimalCatClass* parent_class = ANIMAL_CAT_CLASS (self); parent_class-&gt;say_meow = animal_tiger_real_say_meow; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalTiger* self</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"Tiger cub was born.\n"</span></span>); }</code> </pre><br>  In the animal_tiger_class_init function, which will be called when creating the first instance of our object, we get a pointer to the parent class using the ANIMAL_CAT_CLASS macro.  This macro, like a number of others, is created when macros are expanded in header files, such as G_DECLARE_FINAL_TYPE.  Next, we simply redefine the function to the one we created a few lines above.  In our "constructor" animal_tiger_init () is nothing special, just let us know about the creation of our object. <br><br>  In the animal_tiger_new () function, everything is arranged similarly to the parent class: <br><br><pre> <code class="cs hljs">AnimalTiger* animal_tiger_new() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g_object_new(ANIMAL_TYPE_TIGER, NULL); }</code> </pre> <br>  Let's check how our new type works: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* main.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#include "animaltiger.h" int main(int argc, char** argv) { AnimalTiger* tiger = animal_tiger_new(); animal_cat_say_meow(tiger); return 0; }</span></span></code> </pre> <br>  Let's add our Makefile from the previous article with new files, build and run: <br><br><pre> <code class="bash hljs">First instance of AnimalCat was created. First instance of AnimalTiger was created. Little cat was born. Tiger cub was born. Tiger say: ARRRRGH!!!</code> </pre> <br>  As we see, at first, functions of the form _class_init are worked out, then the constructors of individual instances _init.  When we call the method of the parent object and pass a pointer to the child instance as a parameter, the overridden function of the child is processed. <br><br><h3>  Interfaces </h3><br>  In addition to direct inheritance, GObject has the concept of interface inheritance.  Interfaces are non-instantiable types, similar to the purely abstract C ++ classes or Java interfaces. <br><br>  Let our tiger acquire the properties of a predator - it will implement the AnimalPredator interface (of course, all cats are predators, but we will not go into zoological details).  Create the file animalpredator.h: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#ifndef _ANIMAL_PREDATOR_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ANIMAL_PREDATOR_H_ #include &lt;glib-object.h&gt; G_BEGIN_DECLS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ANIMAL_TYPE_PREDATOR animal_predator_get_type() G_DECLARE_INTERFACE (AnimalPredator, animal_predator, ANIMAL, PREDATOR, GObject) struct _AnimalPredatorInterface { GTypeInterface parent; void (*hunt)(AnimalPredator*); void (*eat_meat)(AnimalPredator*, int); }; void animal_predator_hunt(AnimalPredator* self); void animal_predator_eat_meat(AnimalPredator* self, int quantity); G_END_DECLS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> /* _ANIMAL_PREDATOR_H_ */</span></span></code> </pre> <br>  As you can see, here everything looks like the heading of the usual GObject derivable-successor.  Pay attention to a few points: <br><br><ul><li>  the main macro here is G_DECLARE_INTERFACE instead of G_DECLARE_DERIVABLE_TYPE (and the last ‚Äúargument‚Äù in this macro is still GObject); </li><li>  the class structure has a name like _AnimalPredatorInterface, not _AnimalPredatorClass; </li><li>  the first field in it is reserved for the GTypeInterface type, and not for the GObjectClass. </li></ul><br>  Also in the structure, we create two pointers for virtual functions that will be implemented by specific instantiated types.  Finally, we declare two wrapper functions for these pointers ‚Äî animal_predator_hunt and animal_predator_eat_meat. <br><br>  Now we will create an auxiliary file, animalpredator.c, which should not be confused with the implementation of this interface - the resulting object module only starts specific implementations. <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include &lt;stdio.h&gt; #include "animalpredator.h" G_DEFINE_INTERFACE (AnimalPredator, animal_predator, G_TYPE_OBJECT) static void animal_predator_default_init(AnimalPredatorInterface* iface) { printf("The first instance of the object that implements AnimalPredator interface was created\n"); } void animal_predator_hunt(AnimalPredator* self) { AnimalPredatorInterface* iface = ANIMAL_PREDATOR_GET_IFACE (self); iface-&gt;hunt(self); } void animal_predator_eat_meat(AnimalPredator* self, int quantity) { AnimalPredatorInterface* iface = ANIMAL_PREDATOR_GET_IFACE (self); iface-&gt;eat_meat(self, quantity); }</span></span></code> </pre><br>  Everything is simple: the initial macro G_DEFINE_INTERFACE, similar to G_DEFINE_TYPE, which we used at the beginning of animalcat.c and animaltiger.c, the constructor function animal_predator_default_init, into which you can put arbitrary code that runs when creating the first instance of an object that implements our interface and functions wrappers that launch specific implementations of the virtual interface functions.  The ANIMAL_PREDATOR_GET_IFACE macro returns the class structure of the interface, just as the ANIMAL_CAT_CLASS macro returned the structure of the parent class. <br><br>  We proceed to the implementation of our interface.  Let's add our animaltiger.c: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include "animalpredator.h" static void animal_tiger_predator_interface_init(AnimalPredatorInterface *iface);</span></span></code> </pre> <br>  The animal_tiger_predator_interface_init function must be declared at the beginning of the file, as it will be needed for the next macro. <br><br>  Replace the macro G_DEFINE_TYPE with a similar one, but with more features.  As you can see, a new ‚Äúargument‚Äù has been added here, which may contain a number of macros that expand into arbitrary code.  In this case, we put the macro G_IMPLEMENT_INTERFACE there. <br><br><pre> <code class="cs hljs">G_DEFINE_TYPE_WITH_CODE (AnimalTiger, animal_tiger, ANIMAL_TYPE_CAT, G_IMPLEMENT_INTERFACE (ANIMAL_TYPE_PREDATOR, animal_tiger_predator_interface_init))</code> </pre> <br>  Add two functions that implement the "prototypes" of the class structure of the interface: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_predator_hunt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalTiger* self</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"Tiger hunts. Beware!\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_predator_eat_meat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalTiger* self, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> quantity</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"Tiger eats %d kg of meat.\n"</span></span>, quantity); }</code> </pre> <br>  Finally, we will create a constructor function implementing our interface, where we assign specific values ‚Äã‚Äãto the pointers from the interface structure defined above: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal_tiger_predator_interface_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnimalPredatorInterface* iface</span></span></span><span class="hljs-function">)</span></span> { iface-&gt;hunt = animal_tiger_predator_hunt; iface-&gt;eat_meat = animal_tiger_predator_eat_meat; }</code> </pre> <br>  Let's see how it works: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include "animaltiger.h" #include "animalpredator.h" int main(int argc, char** argv) { AnimalTiger* tiger = animal_tiger_new(); animal_predator_hunt(tiger); animal_predator_eat_meat(tiger, 100500); }</span></span></code> </pre> <br>  We collect, we start: <br><br><pre> <code class="bash hljs">First instance of AnimalCat was created. The first instance of the object that implements AnimalPredator interface was created First instance of AnimalTiger was created. Little cat was born. Tiger cub was born. Tiger hunts. Beware! Tiger eats 100500 kg of meat.</code> </pre> <br>  Is it possible to implement multiple interfaces at once?  Yes of course.  Here is the real code from GIO, where the object implements three interfaces at once: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initable_iface_init</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GInitableIface *initable_iface</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_initable_iface_init</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GAsyncInitableIface *async_initable_iface</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbus_object_manager_interface_init</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GDBusObjectManagerIface *iface</span></span></span><span class="hljs-function">)</span></span>; G_DEFINE_TYPE_WITH_CODE (GDBusObjectManagerClient, g_dbus_object_manager_client, G_TYPE_OBJECT, G_ADD_PRIVATE (GDBusObjectManagerClient) G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE, initable_iface_init) G_IMPLEMENT_INTERFACE (G_TYPE_ASYNC_INITABLE, async_initable_iface_init) G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT_MANAGER, dbus_object_manager_interface_init))</code> </pre> <br>  In this case, you need three separate _interface_init functions.  Note that the last three macros are not separated by commas, this is one ‚Äúargument‚Äù. <br><br>  And what about the inheritance of interfaces?  Here, the principle is also similar to that used in Java: this task is solved by the mechanism of prerequisites - type and object dependencies among themselves.  For example, in order to implement the AnimalPredator interface, you will also need to implement the Eater interface or be inherited from an object, say, Mammal.  However, consideration of these nuances threatens to dramatically increase the volume of the article, so we leave it outside the scope of this text. </div><p>Source: <a href="https://habr.com/ru/post/350132/">https://habr.com/ru/post/350132/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350120/index.html">Object classification in real time</a></li>
<li><a href="../350124/index.html">Online shooter on Unreal Engine 4 for 90 hours (video creation + source)</a></li>
<li><a href="../350126/index.html">Compiler bug? Linker? No, Windows kernel bug</a></li>
<li><a href="../350128/index.html">Instruction: what to do if you do not have time to deadline</a></li>
<li><a href="../350130/index.html">Open Data Day in Moscow 2018</a></li>
<li><a href="../350134/index.html">DoctrineSolrBundle - Search by Solct-based Doctrine entity on Symfony2 / 3</a></li>
<li><a href="../350136/index.html">Random evolutionary strategies in machine learning</a></li>
<li><a href="../350138/index.html">How to whale eat java application and not choke</a></li>
<li><a href="../350140/index.html">Asynchronous work with PostgreSQL in C</a></li>
<li><a href="../350142/index.html">Development of an external battery on four LiFePO4 batteries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>