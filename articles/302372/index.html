<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic non-uniform tightly packed container</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Definition 1 . A homogeneous container is such a container in which objects of exactly one type are stored. 


 Definition 2 . A heterogeneous contain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic non-uniform tightly packed container</h1><div class="post__text post__text-html js-mediator-article"><p>  <strong>Definition 1</strong> .  <em>A homogeneous</em> container is such a container in which objects of exactly one type are stored. </p><br><p>  <strong>Definition 2</strong> .  <em>A heterogeneous</em> container is a container in which objects of different types can be stored. </p><br><p>  <strong>Definition 3</strong> .  <em>A static</em> container is a container whose composition is completely determined at the compilation stage. </p><br><blockquote>  The <em>composition</em> in this case refers to the number of elements and their types, but not the values ‚Äã‚Äãof these elements themselves.  Indeed, there are containers in which even the values ‚Äã‚Äãof elements are determined at the compilation stage, but in this model such containers are not considered. </blockquote><p>  <strong>Definition 4</strong> .  <em>A dynamic</em> container is a container whose composition is partially or completely determined at the execution stage. </p><br><p>  According to this classification, obviously, there are four types of containers: </p><br><ol><li><p>  Static homogeneous </p><br><div class="spoiler">  <b class="spoiler_title">Can you think of an example?</b> <div class="spoiler_text"><p> A regular array is <code>int[n]</code> . </p></div></div><br></li><li><p>  Static heterogeneous </p><br><div class="spoiler">  <b class="spoiler_title">Examples?</b> <div class="spoiler_text"><p>  The most striking example of such a container is a tuple.  In C ++, it is implemented by the class <code>std::tuple&lt;...&gt;</code> . </p></div></div><br></li><li><p>  Dynamic homogeneous </p><br><div class="spoiler">  <b class="spoiler_title">Guess?</b> <div class="spoiler_text"><p>  That's right, <code>std::vector&lt;int&gt;</code> . </p></div></div><br></li><li><p>  Dynamic inhomogeneous </p><br><p>  That's about this type of container and will be discussed in this article. </p><br></li></ol><a name="habracut"></a><br><a name="contents"></a><br><h2>  Content </h2><br><ol><li>  <a href="https://habr.com/ru/post/302372/">Dynamic inhomogeneous containers</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Dynamic tuple</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Data storage</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Handlers</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Data access</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Exception Life and Safety</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Other problems</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Performance measurements</a> </li><li>  <a href="https://habr.com/ru/post/302372/">Links</a> </li></ol><br><a name="dynamic-heteroheneous-containers"></a><br><h2 id="dinamicheskie-neodnorodnye-konteynerycontents">  <a href="https://habr.com/ru/post/302372/">Dynamic inhomogeneous containers</a> </h2><br><p>  There are several <abbr title="I call them technicians because the resulting container is formally dynamic homogeneous. However, they mimic the desired effect.">techniques</abbr> for obtaining a dynamic inhomogeneous container.  Here are the three, perhaps the most common ones: </p><br><ol><li><p>  Array of pointers to the polymorphic class </p><br><p>  Selection <del>  Trusabalbesa </del>  experienced fieldman. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">derived</span></span></span><span class="hljs-class">:</span></span> base { ... }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base&gt;&gt; v;</code> </pre> <br></li><li><p>  Array of associations </p><br><p>  The union can be understood as a language possibility of the <code>union</code> , as well as a library class of type <code>boost::variant</code> ( <code>std::variant</code> will appear in C ++ 17). </p><br></li><li><p>  Array of arbitrary objects using erase type </p><br><p>  For example, <code>boost::any</code> ( <code>std::any</code> will appear in C ++ 17) into which you can put anything. </p><br></li></ol><br><p>  Each of these techniques has its advantages and disadvantages, and we will definitely consider them. <br>  And now it's time to highlight the point, which until this moment remained in the shadow, despite the fact that it is part of the title (and essence) of the article. </p><br><p>  <strong>Definition 5</strong> .  <em>A tightly packed</em> container is a container whose elements lie in a continuous area of ‚Äã‚Äãmemory, and there are no gaps between them (with alignment accuracy). </p><br><div class="spoiler">  <b class="spoiler_title">For example?</b>  <b class="spoiler_title">Guess</b> <div class="spoiler_text"><p>  <code>int[n]</code> , <code>std::vector&lt;int&gt;</code> , <code>std::tuple&lt;...&gt;</code> . </p></div></div><br><p>  Unfortunately, not every tightly packed container is dynamic inhomogeneous.  And we need just such. </p><br><p>  But back to the advantages and disadvantages of the above techniques for obtaining dynamic inhomogeneous containers. </p><br><h4 id="massiv-ukazateley-na-polimorfnyy-klass">  Array of pointers to the polymorphic class </h4><br><p>  Benefits: </p><br><ol><li><p>  Relative ease of implementation </p><br><p>  Inheritance, polymorphism, everything.  Even a beginner knows these things (fortunately or unfortunately?). </p><br></li><li><p>  Easy to introduce new entities. </p><br><p>  No additional actions are required in order to be able to insert a new object into the array.  You only need to create a new heir to the base class. </p><br><p>  And there is no need to recompile the code depending on the array of pointers. </p><br></li></ol><br><p>  Disadvantages: </p><br><ol><li><p>  Hierarchy dependency </p><br><p>  Only objects inherited from a certain base class can be added to an array. </p><br></li><li><p>  Code redundancy </p><br><p>  For each new element, you need to create a new class in the hierarchy.  That is, if I want to put two types of numbers into a container - integers and buoys - then I will have to get the base class "number" and its two corresponding heirs. </p><br></li><li><p>  Loose packaging </p><br><p>  In the array are only pointers, and the objects themselves are scattered in memory.  This, in general, will adversely affect the operation of the cache. </p><br></li></ol><br><h4 id="massiv-obedineniy">  Array of associations </h4><br><p>  Benefits: </p><br><ol><li><p>  Hierarchy independence </p><br><p>  In the array, you can put any type specified in the union. </p><br></li><li><p>  Objects lie in a continuous memory area. </p><br><p>  The array does not store the pointer, but the object itself. </p><br></li></ol><br><p>  Disadvantages: </p><br><ol><li><p>  Dependence on the set of objects included in the union </p><br><p>  When adding a new object to the union, you need to recompile all the code, which obviously depends on our array of associations. </p><br></li><li><p>  Loose packaging </p><br><p>  Yes, objects lie in a continuous area of ‚Äã‚Äãmemory.  But we would like to get a tight package, and for this it is necessary that there are no voids between the objects.  And voids can be. </p><br><p>  The point is that the size of the union is equal to the size of the largest type of this union.  For example, if the union includes two types - <code>X</code> and <code>char</code> , with <code>sizeof(X) = 32</code> , then each <code>char</code> will occupy 32 bytes, although one would be quite enough. </p><br></li></ol><br><h4 id="massiv-proizvolnyh-obektov-s-ispolzovaniem-stiraniya-tipa">  Array of arbitrary objects using erase type </h4><br><p>  Benefits: </p><br><ol><li><p>  Complete independence </p><br><p>  At any time in such an array, you can put any type, and you do not have to recompile anything that depends on this array. </p><br></li></ol><br><p>  Disadvantages: </p><br><ol><li><p>  Loose packaging </p><br><p>  As in the case of an array of pointers, the objects of such an array are scattered in memory (in general, this is not the case, because <abbr title="An object whose size does not exceed the size of the pointer can be stored in the same memory area as the pointer itself."><em>optimization of small objects</em></abbr> can be used, but for large enough objects this is always true). </p><br></li></ol><br><a name="dynamic-tuple"></a><br><h2 id="dinamicheskiy-kortezhcontents">  <a href="https://habr.com/ru/post/302372/">Dynamic tuple</a> </h2><br><p>  So, none of the above approaches implies a tight pack.  Therefore, we need to develop another approach to creating a dynamic inhomogeneous container, which, among other things, will provide the coveted tight packaging. </p><br><p>  In order to do this, you first need to get a better look at <code>any</code> .  Working with him happens like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       . auto a = any(1); assert(any_cast&lt;int&gt;(a) == 1); //   . any_cast&lt;int&gt;(a) = 42; assert(any_cast&lt;int&gt;(a) == 42); //       . a = std::string(u8"!"); assert(any_cast&lt;std::string&gt;(a) == std::string(u8"!")); }</span></span></code> </pre> <br><p>  How it works? </p><br><div class="spoiler">  <b class="spoiler_title">That's how</b> <div class="spoiler_text"><p>  Do not take this code too close to your heart; this is a schematic implementation.  Behind this implementation should refer to a <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%252B%252B-v3/include/experimental/any">more authoritative source</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cassert&gt; #include &lt;utility&gt; enum struct operation_t { clone, destroy }; using manager_t = void (*) (operation_t, const void *, void *&amp;); //         `any`   ,   //       . template &lt;typename T&gt; void manage (operation_t todo, const void * source, void *&amp; destination) { switch (todo) { case operation_t::clone: { destination = new T(*static_cast&lt;const T *&gt;(source)); break; } case operation_t::destroy: { assert(source == nullptr); static_cast&lt;T *&gt;(destination)-&gt;~T(); break; } } } class any { public: any (): m_data(nullptr), m_manager(nullptr) { } any (const any &amp; that): m_manager(that.m_manager) { m_manager(operation_t::clone, that.m_data, this-&gt;m_data); } any &amp; operator = (const any &amp; that) { any(that).swap(*this); return *this; } any (any &amp;&amp; that): m_data(that.m_data), m_manager(that.m_manager) { that.m_manager = nullptr; } any &amp; operator = (any &amp;&amp; that) { any(std::move(that)).swap(*this); return *this; } ~any () { clear(); } //     "" . //      "",         // . ,   ,     // ,   "" :    . template &lt;typename T&gt; any (T object): m_data(new T(std::move(object))), m_manager(&amp;manage&lt;T&gt;) { } template &lt;typename T&gt; any &amp; operator = (T &amp;&amp; object) { any(std::forward&lt;T&gt;(object)).swap(*this); return *this; } template &lt;typename T&gt; friend const T &amp; any_cast (const any &amp; a); template &lt;typename T&gt; friend T &amp; any_cast (any &amp; a); void clear () { if (not empty()) { m_manager(operation_t::destroy, nullptr, m_data); m_manager = nullptr; } } void swap (any &amp; that) { std::swap(this-&gt;m_data, that.m_data); std::swap(this-&gt;m_manager, that.m_manager); } bool empty () const { return m_manager == nullptr; } private: void * m_data; manager_t m_manager; }; //  ,   ,     . // : // // `any_cast&lt;int&gt;(a) = 4;` // template &lt;typename T&gt; const T &amp; any_cast (const any &amp; a) { return *static_cast&lt;const T *&gt;(a.m_data); } template &lt;typename T&gt; T &amp; any_cast (any &amp; a) { return *static_cast&lt;T *&gt;(a.m_data); }</span></span></span></span></code> </pre> </div></div><br><p>  As you already understood, the <em>dynamic tuple</em> (DC) will be the development of an idea with <code>any</code> .  Namely: </p><br><ol><li>  As in the case of <code>any</code> , an erase type technique will be applied: the object types will be "forgotten", and for each object a "manager" will be set up, who will know how to work with this object. </li><li>  The objects themselves will be stacked one after another (taking into account alignment) into a continuous memory area. </li></ol><br><p>  It will work in a manner similar to <code>any</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . auto t = dynamic_tuple(42, true, 'q'); //  . assert(t.size() == 3); //     . assert(t.get&lt;int&gt;(0) == 42); ... //    . t.push_back(3.14); t.push_back(std::string("qwe")); ... //   . t.get&lt;int&gt;(0) = 17;</span></span></code> </pre> <br><h2>  Need more code </h2><br><p>  Well, <abbr title="It is high time!">let's get down to the most interesting</abbr> . </p><br><a name="data-structure"></a><br><h2 id="hranenie-dannyhcontents">  <a href="https://habr.com/ru/post/302372/">Data storage</a> </h2><br><p>  As follows from the definition of a dense package, all objects are stored in a single continuous piece of memory.  This means that for each of them, in addition to the handlers, you need to keep its indent from the beginning of this piece of memory. </p><br><p>  Great, let's get a special structure for this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_info_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">manager_t</span></span> manage; };</code> </pre> <br><p>  Further, it will be necessary to store the piece of memory itself, its size, and also separately it will be necessary to remember the total volume occupied by the objects. </p><br><p>  We get: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dynamic_tuple</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> object_info_container_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">object_info_t</span></span>&gt;; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_capacity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>[]&gt; m_data; object_info_container_type m_objects; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_volume = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><a name="manager"></a><br><h2 id="obrabotchikicontents">  <a href="https://habr.com/ru/post/302372/">Handlers</a> </h2><br><p>  So far, the type of the <code>manager_t</code> handler remains undefined. </p><br><p>  There are two main options: </p><br><ol><li><p>  Structure with "methods" </p><br><p>  As we already know from <code>any</code> , several operations are needed to control an object.  In the case of DC, this is, at a minimum, copying, transfer and destruction.  For each of them, you need to create a field in the structure: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">manager_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> copier_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> mover_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> destroyer_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); copier_type copy; mover_type move; destroyer_type destroy; };</code> </pre> <br></li><li><p>  Pointer to generic handler </p><br><p>  You can store only one pointer to a generic handler.  In this case, you need to make an enumeration that is responsible for the selection of the required operation, and also lead to a single type of signature of all possible actions on the object: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operation_t</span></span></span><span class="hljs-class"> {</span></span> copy, move, destroy }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">operation_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *);</code> </pre> <br></li></ol><br><p>  The disadvantage of the first option is that each action requires the introduction of a new field.  Accordingly, the memory occupied by handlers will swell if new handlers are added. </p><br><p>  The disadvantage of the second option is that the signatures of different handlers are different, so you have to adjust all handlers to a single signature, while depending on the requested operation, some arguments may remain unnecessary, and sometimes - oh gods - even have to call <code>const_cast</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Take the children and pregnant away from the screens</b> <div class="spoiler_text"><p>  In fact, there is a third option: polymorphic handlers-classes.  But this option mercilessly dismisses as the most inhibited. </p></div></div><br><p>  Accordingly, the disadvantages of one of the options are the advantages of the other. </p><br><p>  According to the results of <abbr title="Peeped in standard library">long reflections and weighing the advantages and disadvantages</abbr> , the disadvantages of the first option outweigh, and the choice falls on the lesser evil - a generic handler. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// .  "    ". template &lt;typename T&gt; void move (void * source, void * destination) { new (destination) T(std::move(*static_cast&lt;T *&gt;(source))); } template &lt;typename T&gt; void destroy (void * object) { static_cast&lt;T *&gt;(object)-&gt;~T(); } template &lt;typename T&gt; void manage (operation_t todo, const void * source, void * destination) { switch (todo) { case operation_t::copy: { copy&lt;T&gt;(source, destination); break; } case operation_t::move: { move&lt;T&gt;(const_cast&lt;void *&gt;(source), destination); break; } case operation_t::destroy: { assert(source == nullptr); destroy&lt;T&gt;(destination); break; } } }</span></span></code> </pre> <br><a name="access"></a><br><h2 id="dostup-k-dannymcontents">  <a href="https://habr.com/ru/post/302372/">Data access</a> </h2><br><p>  The easiest thing to say about DC. <br>  The type of the requested data is known at the compilation stage, the index is known at the execution stage, therefore the object access interface suggests itself: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_type index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T *&gt;(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *&gt;(data() + offset_of(index))); } <span class="hljs-function"><span class="hljs-function">size_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_of</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_type index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_objects[index].offset; }</code> </pre> <br><p>  Also, for greater efficiency (see access performance graphs at the end of the article), you can define access to an object by indent: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_by_offset</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_type offset)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T *&gt;(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *&gt;(data() + offset)); }</code> </pre> <br><p>  Well, indicators, by analogy with standard containers: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">size_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_objects.size(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_capacity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_objects.empty(); }</code> </pre> <br><p>  The only thing that needs to be said separately is a special indicator indicating the <em>volume of the</em> container. <br>  Under the volume is understood the total amount of memory occupied by objects located in the DC. </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> volume () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_volume; }</code> </pre> <br><a name="safety"></a><br><h2 id="vremya-zhizni-i-bezopasnost-isklyucheniycontents">  <a href="https://habr.com/ru/post/302372/">Exception Life and Safety</a> </h2><br><p>  The most important tasks are tracking the life of objects and ensuring the safety of exceptions. </p><br><p>  Since objects are constructed "manually" with the help of the host <code>new</code> , they, naturally, are destroyed "manually" - by explicitly calling the destructor. <br>  This creates certain difficulties with copying and transferring objects during relocation.  Therefore, it is necessary to implement relatively complex structures for copying and transferring: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ForwardIterator&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ForwardIterator first, ForwardIterator last, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * source, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * destination)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> current = first; current != last; ++current) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       . current-&gt;manage(operation_t::move, source + current-&gt;offset, destination + current-&gt;offset); } catch (...) { //   ,   ,    . destroy(first, current, destination); throw; } } destroy(first, last, source); } template &lt;typename ForwardIterator&gt; void copy (ForwardIterator first, ForwardIterator last, const std::int8_t * source, std::int8_t * destination) { for (auto current = first; current != last; ++current) { try { //       . current-&gt;manage(operation_t::copy, source + current-&gt;offset, destination + current-&gt;offset); } catch (...) { //  -   ,   ,    . destroy(first, current, destination); throw; } } }</span></span></code> </pre> <br><a name="problebs"></a><br><h2 id="prochie-problemycontents">  <a href="https://habr.com/ru/post/302372/">Other problems</a> </h2><br><p>  One of the biggest problems was copying.  And, although I figured it out with her, doubts still arise from time to time. </p><br><p>  I will explain. </p><br><p>  Suppose we put an uncopyable object (say, <code>std::unique_ptr</code> ) in <code>std::vector</code> .  We can do this with the help of the transfer.  But if we try to copy a vector, the compiler will swear, because its internal elements are uncopyable. </p><br><p>  In the case of DC, everything is somewhat different: </p><br><ol><li>  At the time of laying the item in the DC you need to create a copy handler.  If the object is not copied, then the handler cannot be created (compile error).  At the same time, it is not yet known whether we are going to ever copy our DC. </li><li>  At the time of the actual copying of the DC, the information about the copyability of the type ‚Äî due to the erasing of the type ‚Äî is no longer available. </li></ol><br><p>  The following solution is currently selected: </p><br><ol><li>  If the object is copied, then a regular copy handler is created for it. </li><li>  If the object is not copied, then a special handler is created for it, which throws an exception when trying to copy. </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * destination)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::enable_if_t &lt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::is_copy_constructible&lt;T&gt;::value &gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (destination) T(*<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T *&gt;(source)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::enable_if_t &lt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">not</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::is_copy_constructible&lt;T&gt;::value &gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type_name = boost::typeindex::ctti_type_index::type_id&lt;T&gt;().pretty_name(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">u8"  "</span></span> + type_name + <span class="hljs-string"><span class="hljs-string">u8" "</span></span>); }</code> </pre> <br><p>  An even more difficult problem arises when comparing two DCs for equality.  One could do in the same way, but, in addition to the case of a compiler error when trying to compare the incomparable, there are still cases where the compiler generates a warning rather than an error ‚Äî for example, when invoking the equality operator for floating-point numbers.  Here, on the one hand, it is impossible to throw an exception, because the user could be aware of his actions and make a comparison intentionally.  On the other hand, I would like to somehow inform the user about the unsafe operation. <br>  This problem is still open. </p><br><a name="benchmark"></a><br><h2 id="zamery-proizvoditelnosticontents">  <a href="https://habr.com/ru/post/302372/">Performance measurements</a> </h2><br><p>  Since the main goal was to create a precisely <em>packed</em> container in order to have an optimal access time to its elements, in the performance measurements the access speed to the DC was compared with the access speed to the array of pointers to the ‚Äúscattered‚Äù objects in memory. </p><br><p>  Two scattered patterns were used: </p><br><ol><li><p>  Sparseness </p><br><p>  Let <code>N</code> be the size of the array to be measured, <code>S</code> be the spreading index. <br>  Then an array of pointers of size <code>N * S</code> generated, and then it is thinned out so that only elements with numbers <code>N * i</code> , <code>i = 0, 1, 2, ...</code> remain. </p><br></li><li><p>  Stirring </p><br><p>  Let <code>N</code> be the size of the array to be measured, <code>S</code> be the spreading index. <br>  Then an array of the size <code>N * S</code> generated, mixed randomly, and then the first <code>N</code> elements are selected from it, and the rest are discarded. </p><br></li></ol><br><p>  And <code>std::vector</code> was taken as a reference point for access time. </p><br><div class="spoiler">  <b class="spoiler_title">Size 10 Containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/1c1/fa0/ad7/1c1fa0ad70234a508cb77229ebcf70cb.png" alt="ten"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Size 50 Containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/bf4/616/220/bf461622057f49319e654e31cdef5227.png" alt="50"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Size 100 containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/8a0/1fd/a95/8a01fda957204debb34508e9e3ee5170.png" alt="100"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">200 size containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/8d6/43d/eb0/8d643deb05f440578b74163834181574.png" alt="200"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">500 size containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/a4c/f73/0b4/a4cf730b42a7480c90ac19a50b9d4dfa.png" alt="500"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">1000 size containers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/788/d77/2f0/788d772f03ae4f31be5e29526abbc628.png" alt="1000"></p></div></div><br><p>  The graphs confirm the obvious: </p><br><ol><li>  The speed of access to the elements of the DC is identical to the speed of access to the elements of the class <code>std::vector</code> (one addition of pointers and one dereference). </li><li>  Access to array elements is slower.  This is especially evident on large arrays with a scatter of <code>S &gt; 1</code> , when the data no longer fit into the cache. </li></ol><br><hr><br><a name="links"></a><br><p>  All source codes are available <a href="">on my github</a> . </p><br><p>  <a href="https://habr.com/ru/post/302372/">To the content</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302372/">https://habr.com/ru/post/302372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302356/index.html">We play sound on DualShock4 from the computer</a></li>
<li><a href="../302360/index.html">Errors and problems of the Big Three servers: part two. HP</a></li>
<li><a href="../302364/index.html">How to win the interview. Some very helpful tips for developers.</a></li>
<li><a href="../302366/index.html">6 Tips for Choosing VPS Hosting</a></li>
<li><a href="../302368/index.html">Integration of the Vutlan SC8100 monitoring system with NMS Cacti</a></li>
<li><a href="../302374/index.html">More comfort in front-end development with TARS</a></li>
<li><a href="../302378/index.html">Why customers do not want to talk to you? Efforts, part 1</a></li>
<li><a href="../302382/index.html">Button thinking against a holistic IT product</a></li>
<li><a href="../302384/index.html">Charter of the young freelance web designer</a></li>
<li><a href="../302388/index.html">2 methods of testing a landing page and 15 steps to successfully test it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>