<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What to collect and how to build a C ++ project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asking this question, I, first of all, formulated the requirements: hard and optional (but desirable) for the build system and the graphical developme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What to collect and how to build a C ++ project</h1><div class="post__text post__text-html js-mediator-article">  Asking this question, I, first of all, formulated the requirements: hard and optional (but desirable) for the build system and the graphical development environment. <br>  At once I want to note that we are talking about writing C ++ code not for some specific platform such as Android or a framework, for example Qt, - where everything is already ready, both with the construction and editing the code, and about generic code not tied to a specific platform or framework <br><a name="habracut"></a><br><h3>  Are common: </h3><br><ul><li>  Free. </li><li>  Cross platform (at least Windows and Linux). </li></ul><br><h3>  Assembly system: </h3><br><ul><li>  A single team to build on different platforms. </li><li>  Incremental build with correct consideration of all dependencies: header files and third-party components used for assembly. </li><li>  The build script should contain only the required minimum configuration specific to a particular project.  The general logic of the build should not roam from the script to the script, but resides in the build system or its plugins. </li><li>  Built-in parallel assembly. </li><li>  Support for various toolchains (at least gcc, Visual C ++, CLang). </li><li>  Ability to change toolchain with minimal cost, without rewriting the entire build script. </li><li>  Easily switchable build options: Debug and Release. </li><li>  Dependencies on some additional low-level make tools are completely undesirable.  In short, the assembly system must be self-sufficient. </li><li>  Integration of the build system with repositories of third-party components like pkg-config or as Maven Central for the JVM is highly desirable. </li><li>  The build system must be extensible plugins, because  The assembly procedure for each specific project may be more complicated than a typical construction concept (generating code, for example, or building some non-standard image). </li><li>  Conveniently, the build script is some kind of high-level programming language, or better yet, DSL.  This will allow not particularly costly and expressively change the behavior of the construction directly in the script. </li><li>  When setting up the compiler and linker from the build script, it‚Äôs very convenient when the build system provides at least basic abstractions: for example, I want to add a macro - why think which command line parameter of the compiler is responsible for this?  / D on MSVC or -D on gcc - let the assembly system resolve these irrelevant parts by itself. </li><li>  Good integration with graphical development environments (IDE). </li></ul><br><h3>  IDE: </h3><br><ul><li>  The IDE's ability to correctly "understand" C ++ code.  The IDE should be able to index all project files, as well as all third-party and system header files and definitions (defines, macro). </li><li>  The IDE should provide the ability to customize commands for building a project, as well as where to look for header files and definitions. </li><li>  It should effectively help in typing code, i.e.  suggest the most appropriate completion options, warn about syntax errors, etc. </li><li>  Navigating a large project should be easy to use, and finding usage is quick and easy. </li><li>  Provide opportunities for refactoring: renaming, etc. </li><li>  You also need the ability to generate a template code ‚Äî creating a framework of a new class, header file, and implementation file.  Generation of getters / setters, method definitions, overloading of virtual methods, implementation patterns of pure virtual classes (interfaces), etc. </li><li>  Highlighting and tag support for documenting code such as Doxygen. </li></ul><br>  In the light of these "hotelok" I reviewed several build systems and graphical development environments.  This small review does not in any way pretend to be complete and contains my subjective assessments, but perhaps it will seem useful to someone as an initial stage. <br><br>  <b>Make</b> - <i>[antiquity]</i> mastodon and honored veteran of the assembly systems, which everyone still does not want to let go of retirement, and forced to carry on himself more and more new projects.  This is a very low-level tool with its own specific language, where, for a space instead of a tab, you are immediately threatened with execution on the spot.  With make, you can do anything you want - a build of any complexity, but you have to pay for it with your efforts to write the script and keep it up to date.  Transferring the build logic from project to project will also be expensive.  There are some modern "substitutes" make-a: like ninja and jam, but essentially they do not change - this is a very low-level tools.  Just as in the assembler, you can write anything you like, but is it worth it? <br><br>  <b>CMake</b> - <i>[Middle Ages] the</i> first attempt to get away from the low-level details of the make.  But, unfortunately, it was not possible to go far - the engine here is the same make for which CMake generates huge make-files based on another text file with a more high-level description of the build.  Qmake works in a similar way.  This approach reminds me of the beautiful facade of an old wooden house, which we carefully lined up with fresh plastic.  CMake is a stable and well-proven system, there is even built-in integration with Eclipse, but, unfortunately, it did not work for me because it contradicts some of the requirements outlined at the beginning of the article.  Everything seems to be fine under Linux, but if you need to build the same project under Windows using MSVC - and I prefer the native MinGW compiler, the files for NMake will be generated.  Those.  dependencies on another tool and different build commands for another platform.  And all this is a consequence of a bit of crooked architecture, when the main part of the work is done by other ‚Äúhelpers‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Ant</b> - <i>[Renaissance] is a</i> peculiar clone of make for Java.  Frankly, I spent quite a bit of time checking Ant (as well as Maven) as a build system for C ++.  And I immediately had the feeling that C ++ support here is purely ‚Äúfor show‚Äù and insufficiently developed.  In addition, even in Java projects, Ant is rarely used.  As the script language (as well as for Maven), XML is chosen here - this vile bird language :).  This fact of optimism did not add to me at all for further immersion in the topic. <br><br>  <b>SCons</b> - <i>[new times]</i> self-sufficient, cross-platform build system written in Python.  SCons works equally well with both Java and C ++ builds.  The dependencies of the drivers for the incremental build are processed correctly (as far as I understood, a certain database is created with the build metadata), and on Windows ‚Äúwithout a tambourine‚Äù MSVC works.  The build script language is Python.  A very worthy system, and I even wanted to finish my research on it, but as you know, there is no limit to perfection, and on a more detailed examination, some drawbacks were revealed in the light of the above requirements. <br><br>  There are no abstract settings for the compiler, so if, for example, it becomes necessary to change the toolchain, you may need to look for places in the build script to make changes.  The same macros will have to be registered with nested conditions - if this is Windows, then do this, if this is GCC, do this, etc. <br><br>  There is no support for remote artifacts and high-level dependency of one build to another. <br><br>  The overall architecture is built so that the so-called user defined builders exist almost in isolation and there is no possibility to use the existing build logic to supplement it with your own through an uncomplicated plugin.  But in general, it is a worthy choice for small projects. <br><br>  <b>Gradle</b> <i>[modernity]</i> - I already had a positive experience of using Gradle for Java and Kotlin projects and I had high hopes for it. <br><br>  For JVM languages ‚Äã‚Äãin Gradle is a very convenient concept of working with libraries necessary for building a project (build dependencies): <br><br><ul><li>  The script contains the addresses of repositories with artifacts: maven or ivy - for example.  It can also be a repository of any other type / format - as long as there is a plugin for it.  This could be a remote repository, some kind of Maven Central or your personal hosting somewhere on the network or just a local rep on a file system. </li><li>  Also, in the special section of the script, the dependencies for building are indicated directly - a list of necessary binary artifacts with the indication of versions. </li><li>  Before starting to build, Gradle tries to kill all the dependencies and looks for artifacts with the given versions in all repositories.  Binary files are loaded into the cache and automatically added to the build.  This is very convenient and I hoped that for C ++, you might have done something similar. </li></ul><br>  At first I checked out the ‚Äúold‚Äù plugin for C ++ support - `cpp` - and I was disappointed - the script structure is not intuitive: model, component, nativespec - and some kind of jumble of different types of binaries: and executables and libraries all in one script.  It is not clear where to place unit tests.  This structure was very different from what I used for Java. <br><br>  But it turned out that there are also ‚Äúnew‚Äù plugins for C ++ support: `cpp-application` for applications,` cpp-library` for libraries: static and dynamic, and finally `cpp-unit-test` for unit testing.  And that was what I was looking for!  :) <br><br>  The project folder structure by default is similar to the project for Java: <br><br><ul><li>  <i>src / main / cpp</i> - root folder for the main <i>* .cpp</i> files of the project. </li><li>  <i>src / main / headers</i> - folder for internal header files. </li><li>  <i>src / main / public</i> - folder for exported headers - for libraries. </li><li>  <i>src / test / cpp</i> - folder for files <i>* .cpp</i> unit of the test. </li></ul><br>  Such a structure is not rigid - it can always be changed in the script, but still you should not do this without special need, it is quite reasonable. <br><br>  By the way, the build script is usually <i>build.gradle</i> , this is a Groovy or Kotlin DSL ( <i>build.gradle.kts</i> ) <i>language</i> to choose from.  Inside the script, the Gradle API and the API of the plug-ins added to the script are always available. <br><br>  For libraries, you can choose the type: static or dynamic (or collect both options). <br>  By default, two build options are configured: Debug ( <i>gradle assemble</i> ) and Release ( <i>gradle assembleRelease</i> ). <br><br>  The principle of launching a unit of testing is the same as in Java: gradle test will do the main component building, then the tests, if they are in the <i>src / test / cpp</i> folder, and then run the test application. <br><br>  The notorious defaults can be defined abstractly - Gradle itself will generate the necessary compiler parameters.  There are some more abstract settings like optimization, debug information, etc. <br><br>  Out of the box are supported GCC, Microsoft Visual C ++, CLang. <br><br>  The system of plug-ins is very developed, and the architecture of extensions is conveniently arranged - you can take ready-made logic and decorate / expand it.  Plug-ins come in two forms: dynamic, which are written directly to Groovy and embedded in a script or written in Java (or in another language with JVM) and compiled into binary artifacts.  For plug-ins, there is a free Gradle-artifactories, in which anyone can place their plug-in, which will be available to all.  What was successful and the author of this article did :) but more on that later. <br>  I would like to dwell in more detail on the system of working with binary components in Gradle for C ++: it is almost the same as in Java!  Build dependencies work in almost the same way as I described above. <br><br>  Take for example the composite build: <br><br><ul><li>  utils - folder with library </li><li>  app is the folder with the application that uses utils. </li><li>  settings.gradle - Gradle file for merging these two components into a composite build. </li></ul><br>  In the file <i>build.gradle</i> from the app folder, it is enough to register such a dependency: <br><br><pre><code class="java hljs">dependencies { <span class="hljs-function"><span class="hljs-function">implementation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br>  And everything else will do Gradle!  Add a path to the compiler to search for utils header files and prints the library's binary. <br><br>  And all this works equally well both under Linux GCC, and under Windows MSVC. <br>  The incremental build, of course, also works great, and if you change the drivers in utils, the app will be rebuilt. <br><br>  As it turned out, Gradle went ahead and implemented the ability to upload C ++ artifacts in the Maven Repository!  To do this, use the standard `maven-publish` plugin. <br><br>  In the script you need to specify the repository where you want to put your artifact and make a gradle publish (or gradle publishToMavenLocal for local publishing).  Gradle will build a project and <br>  lay out in a special format - taking into account the version, platform, architecture and version of the build. <br><br>  The binary library files themselves and the public header files are laid out - from the <i>src / main / public</i> folder. <br><br>  It is clear that you can not put a C ++ artifact on Maven Cental - it will not pass the mandatory system checks.  But to raise the Maven repository on the network is not difficult at all, but for the local repository you don‚Äôt need to do anything at all - it‚Äôs just a folder on the disk. <br><br>  Now, if you want to use someone‚Äôs library in your project, you can write something like this in the build script: <br><br><pre> <code class="java hljs"> repositories { maven { url = <span class="hljs-string"><span class="hljs-string">'https://akornilov.bitbucket.io/maven'</span></span> } } unitTest { dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.tools:gtest:1.8.1'</span></span> } }</code> </pre><br>  It says that for unit testing you need to use the gtest version 1.8.1 artifact from the <a href="https://akornilov.bitbucket.io/maven">Maven repository</a> . <br><br>  By the way, this is a very real repository in which my build of Google Test v1.8.1 is laid out, built using Gradle for Windows and Linux x86_64. <br><br>  Naturally, all the low-level work on configuring the compiler and linker to work with the external component Gradle takes over.  It is enough for you to declare your intentions to use such and such a library with such a version from such and such repository. <br><br>  To integrate with IDE, Gradle has two built-in plug-ins for Visual Studio and Xcode.  They work well, except that the Visual Studio plugin ignores the unit test code from the <i>src / test / cpp</i> folder and generates a project for the main code only. <br><br><h3>  Now it's time to talk about IDE and how to make them friends with Gradle. </h3><br>  <b>Eclipse CDT (2018-12R)</b> is a mature and high-quality product.  If he was able to successfully parse your project, then you are lucky - it will be comfortable to edit.  Most likely, he will even ‚Äúunderstand‚Äù the most confused auto types.  But if not ... Then he will furiously emphasize with a red dotted line everything and swear in bad words.  For example, it does not digest the standard MSVC and Windows SDK header files.  Even a completely innocuous printf is underlined in red dotted line and is not perceived as meaningful.  There was also std :: string.  Under Linux with his gcc family everything is fine.  But even when trying to get him to index the project from a related Android Native, problems started.  In the bionic headers, he refused to see the definition of size_t, and at the same time all the functions that used it.  Probably, under Windows, you can correct the situation if instead of heading Microsoft files, slip him, for example, Cygwin or MinGW SDK, but such tricks are not very interesting to me, I would still like to have software of this level ‚Äúeat what they give‚Äù, and not just what does he like". <br>  Navigation, refactoring, and generating template code are wonderful, but here are some questions to the letter-case assistant: let's say we type a few characters from some long name, why not suggest completion options?  No, the assistant waits patiently until the user gets to.  or -&gt; or ::.  You have to constantly press Ctrl + Space - annoying.  In Java, this annoying flaw could be fixed by selecting the entire alphabet in the CDT as the trigger, but I did not find a simple solution. <br><br><img src="https://habrastorage.org/webt/1t/bx/ue/1tbxue1gaib5bhyo7xbofdxrapq.png"><br><br><img src="https://habrastorage.org/webt/yh/zi/vp/yhzivpjrupaijmjbfzz7qwefmaq.png"><br><br>  <b>NetBeans 8.1 / 10.0</b> - I used it to use this IDE for Java, I remembered as a good and lightweight software with all the necessary functionality.  For C ++, it has a plugin developed not by the community, but directly by NetBeans.  For C ++ projects, there is a pretty hard dependency on make and gcc.  The code editor is leisurely.  I didn‚Äôt find a very simple thing in the generator of the template code: add a new method in the class header file - you need to generate the method body in the cpp file - it doesn‚Äôt know how.  The degree of ‚Äúunderstanding‚Äù of the code is average, it seems like something is in progress, but something is not.  For example, it is already quite difficult for it to iterate on a map with an auto-iterator.  On macros from Google Test swears.  Zakastomizirovat team build is problematic - on Linux with gcc and make available (this is despite the fact that another build system is being used) will work, on Windows it will require MinGW, but even if it is present it will refuse to build.  In general, working in NetBeans with C ++ is possible, but I would not call it comfortable, I probably need to love this environment very much so as not to notice its various sores. <br><br><img src="https://habrastorage.org/webt/bi/dh/h4/bidhh4mda-r7cqkqd6q9vnu4t4o.png"><br><br><img src="https://habrastorage.org/webt/ze/yp/j1/zeypj1bdofeuljkgfp9wyfdxebc.png"><br><br>  <b>KDevelop 5.3.1</b> - was once conceived as a developer tool for KDE (Linux), but now there is a version for Windows.  It has a fast and nice code editor with beautiful syntax highlighting (based on Kate).  Zakostomizirovat left build system will not work - for him the main build system CMake.  It is tolerant of MSVC and Windows SDK headers, in any case printf and std :: string do not exactly stupor it like Eclipse CDT.  Very smart code writing assistant - good completion options are offered almost immediately while typing.  It has an interesting opportunity to generate template code: you can write your template and put it online.  When creating from a template, you can connect to the database of ready-made templates and download the one you like.  The only thing that upset: the built-in template for creating a new class works crookedly both under Windows and under Linux.  The class creation wizard has several windows in which you can customize a lot of things: which constructors are needed, which class members, etc.  But at the final stage under Windows, some error pops up to catch the text of which is impossible and two files h and cpp of 1 byte size are created.  In Linux, for some reason, designers cannot be selected - the tab is empty, and only the header file is correctly generated at the output.  In general, childhood diseases for such a mature product look somehow frivolous. <br><br><img src="https://habrastorage.org/webt/gb/e_/dt/gbe_dtwtphcqqvxpankzo5k8oqy.png"><br><br><img src="https://habrastorage.org/webt/kp/ap/hf/kpaphf1yrtwflj68xusgqlh2ppa.png"><br><br>  <b>QtCreator 4.8.1 (open source edition)</b> - probably, having heard this name, you are wondering how this monster sharpened for Qt with a distribution kit in gigabyte with hooks started to work here.  But this is a ‚Äúlight‚Äù version of the environment for generic projects.  Its distribution kit weighs only about 150 MB and does not carry Qt-specific things with it: <a href="https://download.qt.io/official_releases/qtcreator/4.8/">download.qt.io/official_releases/qtcreator/4.8</a> . <br>  Actually, he knows how to do almost everything I wrote about in my requirements, quickly and correctly.  It parses the standard headers of both Windows and Linux, customizes for any build system, prompts completion options, conveniently generates new classes, body methods, allows you to refactor and navigate through the code.  If you just want to work comfortably without thinking constantly about how to overcome this or that problem, it makes sense to look at QtCreator. <br><br><img src="https://habrastorage.org/webt/w-/6j/ei/w-6jeizzjkklvumkpdjl5oe_mou.png"><br><br><img src="https://habrastorage.org/webt/au/zb/ot/auzbot8u_iam14q88qjedkdmzvu.png"><br><br>  Actually, it remains to talk about what I lacked in Gradle for full-fledged work: integration with IDE.  In order for the build system to generate the project files for the IDE itself, which would already contain commands for building the project, all the source files are listed, paths are needed to search for header files and definitions. <br><br>  For this purpose, I wrote a <a href="https://plugins.gradle.org/plugin/org.bitbucket.akornilov.cpp-ide-generator">plugin for the Gradle `cpp-ide-generator`</a> and published it on the Gradle Plugin Portal. <br><br>  The plugin can only be used in conjunction with `cpp-application`,` cpp-library` and `cpp-unit-test`. <br>  Here is an example of its use in <i>build.gradle</i> : <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-ide-generator'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.3'</span></span> } library { <span class="hljs-comment"><span class="hljs-comment">// Library specific parameters } // Configuration block of plugin: ide { autoGenerate = false eclipse = true qtCreator = true netBeans = true kdevelop = true }</span></span></code> </pre><br>  The plugin supports integration with all of the above graphical development environments, but you can disable support for unnecessary IDEs in the plugin configuration block ide. <br><br><pre> <code class="java hljs"> kdevelop = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  If the <i>autoGenerate</i> parameter <i>is</i> set to true, project files for all allowed IDEs will be automatically generated directly during the build.  Also in the mode of automatic generation, project files will be deleted when the build is cleared: <i>gradle clean</i> . <br><br>  Incremental generation is supported, i.e.  only those files that require a real update will be updated. <br><br>  Here is a list of goals that the plugin adds: <br><br><ul><li>  generateIde - generate project files for all allowed IDEs. </li><li>  cleanIde - remove project files for all allowed IDEs. </li><li>  generateIde [name] - generate project files for the IDE with the specified name (IDE must be enabled), for example generateIdeQtCreator. </li><li>  Available names: Eclipse, NetBeans, QtCreator, KDevelop. </li><li>  cleanIde [name] - delete project files for the IDE with the specified name, for example, cleanIdeQtCreator. </li></ul><br>  During generation, the plugin ‚Äúsniffs‚Äù the build and extracts all the necessary information from it to create project files.  After the project is opened, the IDE should see all the source files, specify the paths to all the headers, as well as set up the basic build commands - build / clean. <br><br>  The second plugin I‚Äôve done is called <a href="https://plugins.gradle.org/plugin/org.bitbucket.akornilov.cpp-build-tuner">`cpp-build-tuner`</a> and it also works in conjunction with cpp-application`,` cpp-library` and `cpp-unit-test`. <br><br>  The plugin has no settings, it is enough to simply zaplap: <br><br><pre> <code class="java hljs"> plugins { id <span class="hljs-string"><span class="hljs-string">'cpp-library'</span></span> id <span class="hljs-string"><span class="hljs-string">'maven-publish'</span></span> id <span class="hljs-string"><span class="hljs-string">'cpp-unit-test'</span></span> id <span class="hljs-string"><span class="hljs-string">'org.bitbucket.akornilov.cpp-build-tuner'</span></span> version <span class="hljs-string"><span class="hljs-string">'0.5'</span></span> }</code> </pre><br>  The plugin performs small manipulations with the settings of the toolchains (compiler and linker) for different build options - Debug and Release.  MSVC, gcc, CLang are supported. <br><br>  This is especially true for MSVC, because by default, as a result of the release build, you will get a ‚Äúfat‚Äù non-aesthetic binary with debug information and a statically linked standard library.  Part of the settings for MSVC, I "spied" in Visual Studio itself, which by default it adds to its C ++ projects.  For both gcc / CLang and MSVC, the release profile includes link time optmizations. <br><br>  <i>Note: Plugins were tested with the latest version of Gradle v5.2.1 and have not been tested for compatibility with previous versions.</i> <br><br>  Source codes of plug-ins, as well as simple examples of using Gradle for libraries: static and dynamic, as well as applications that use them can be viewed: <a href="https://bitbucket.org/akornilov/tools">bitbucket.org/akornilov/tools</a> further gradle / cpp. <br><br>  The examples also show how to use Google Test for unit testing libraries. <br><br>  <a href="https://akornilov.bitbucket.io/maven">Maven Repository with Google Test v1.8.1 built in Gradle (without mock).</a> </div><p>Source: <a href="https://habr.com/ru/post/442682/">https://habr.com/ru/post/442682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442672/index.html">How to give feedback: 9 rules</a></li>
<li><a href="../442674/index.html">Information security instances on attackdefense.com platform</a></li>
<li><a href="../442676/index.html">Where dreams lead: Underground</a></li>
<li><a href="../442678/index.html">The largest project in stereolithography: a 3D mammoth skeleton printed on a 3D printer</a></li>
<li><a href="../442680/index.html">Sensory replacement technologies will allow you to see the world with the help of sounds: how the neuroplasticity of the human brain works</a></li>
<li><a href="../442686/index.html">DataPower Training Course</a></li>
<li><a href="../442688/index.html">Is data analysis on Scala a harsh necessity or a pleasant opportunity?</a></li>
<li><a href="../442690/index.html">Moon mission "Bereshit" - selfie against the backdrop of the Earth</a></li>
<li><a href="../442692/index.html">Blockchain without intermediaries: how we sent securities to a distributed registry</a></li>
<li><a href="../442694/index.html">One of the streaming giants launched in India and attracted a million users in a week.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>