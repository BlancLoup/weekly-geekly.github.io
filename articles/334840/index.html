<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Red Architecture - red help button for complex and intricate systems - part 3 (multi-threading to help)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The final part of the description of the Red Architecture is devoted to multithreading. For the sake of justice, it is worth saying that the initial v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Red Architecture - red help button for complex and intricate systems - part 3 (multi-threading to help)</h1><div class="post__text post__text-html js-mediator-article">  The final part of the description of the <b>Red Architecture is</b> devoted to multithreading.  For the sake of justice, it is worth saying that the <a href="https://habrahabr.ru/post/333870/">initial version of the</a> class v cannot be considered optimal, since there is nothing in it to solve one of the main problems to which the developers of real world applications inevitably arrive.  To fully understand the current article, you need to become familiar with the concept of Red Architecture <a href="https://habrahabr.ru/post/333870/">here</a> <br><br><img src="https://habrastorage.org/web/e20/b7a/567/e20b7a5674cc4abfad5f507f51733956.png" alt="Red architecture"><br><br>  Looking ahead to say that we will be able to solve all the problems of multithreading without going beyond the limits of class v.  And the changes will be much less than it might seem, and as a result, the code of class v with completely solved problems of multithreading will consist of a little more than 50 lines!  Moreover, these 50 with a few lines will be more optimal than the variant of class v, described in the <a href="https://habrahabr.ru/post/333870/">first part</a> .  In this case, the specific code that solves the problem of synchronization of threads will take only 20 lines! <br><a name="habracut"></a><br>  <i>In the course of the text, we will analyze the individual lines from the listing of completed classes v and Tests, which are given at the end of this article.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Where can I apply the Red Architecture? </h4><br>  I want to emphasize that the examples given here, as well as the entire <b>Red Architecture</b> concept <b>, are proposed for use in all possible languages ‚Äã‚Äãand platforms</b> .  With # / Xamarin and the .NET platform selected to demonstrate the Red Architecture based on my personal preferences, nothing more. <br><br><h4>  Two options for class v </h4><br>  We will have two options for class v.  The second option, identical in functionality and use to the first, will be somewhat more complicated.  But it can be used not only in the ‚Äústandard‚Äù C # .NET environment, but also in the PCL environment Xamarin, which means for mobile development right under three platforms: iOS, Android, Windows 10 Mobile.  The fact is that in the PCL environment of the Xamarin framework, thread safe collections are not available, so the class v variant for Xamarin / PCL will contain more code for synchronizing threads.  This is what we will look at in this article, since a simplified version of the class v (also included at the end of this article) is less valuable in terms of understanding multithreading problems and how to solve them. <br><br><h4>  A little bit of optimization </h4><br>  First of all, we get rid of the base class and make the class v self-sufficient.  We do not need a base class notification mechanism that we used until now.  The inherited mechanism does not allow solving problems of multithreading in the optimal way.  Therefore, we now ‚Äúourselves‚Äù will send events to handler functions: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;k, HashSet&lt;NotifyCollectionChangedEventHandler&gt;&gt; handlersMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;k, HashSet&lt;NotifyCollectionChangedEventHandler&gt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... foreach (var handlr in new List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) lock(handlr) try { handlr.Invoke(key, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, new List&lt;KeyValuePair&lt;k, object&gt;&gt;(){ new KeyValuePair&lt;k, object&gt;(key, o) }));</span></span></code> </pre> <br>  In the <i>Add ()</i> method in the <i>foreach loop,</i> we copy the elements from <i>HashSet</i> 'a into the <i>List</i> and the iteration is already on the list, not the hashset.  We need to do this, because the value returned by the expression handlersMap [key] is a global variable accessible from public class-mutated state methods such as m () and h (), therefore, it is possible that the HashMap returned by the expression handlersMap [key] will be modified by another thread during the iteration on it in the Add () method, and this will cause runtime because the iteration on the collection inside the foreach is not finished yet, its (collection) modification is prohibited.  That is why we ‚Äúsubstitute‚Äù for iteration not a global variable, but a List into which elements of the global HashSet are copied. <br><br>  But this protection is not enough.  In terms of <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])</code> </pre> <br>  The value (hash set) of handlersMap [key] implicitly applies the copy operation.  This will definitely cause problems if, during the period between the beginning and the end of the copy operation, some other stream tries to add or delete an item in the hashset being copied.  Therefore, we put a lock (Monitor.Enter (handlersMap [key])) on this hashset just before the start of foreach <br><br><pre> <code class="cs hljs">Monitor.Enter(handlersMap[key]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) { <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre><br>  and ‚Äúrelease‚Äù (Monitor.Exit (handlersMap [key])) right after entering the foreach loop <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Monitor.IsEntered(handlersMap[key])) { Monitor.PulseAll(handlersMap[key]); Monitor.Exit(handlersMap[key]); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre><br>  According to the rules of the Monitor object, the number of calls to Enter () must correspond to the number of calls to Exit (), so we have an if check (Monitor.IsEntered (handlersMap [key])) that ensures that if the lock has been installed, then we will exit only one times, at the beginning of the first iteration of the foreach loop.  Immediately after the Monitor.Exit line (handlersMap [key]), the handlersMap [key] hashset will again be available for use by other threads.  Thus, we limit the hashset blocking to the minimum possible time, it can be said that in this case, the hashset will be blocked for just a moment. <br><br>  Immediately after the foreach loop, we see a repetition of the lock code. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (Monitor.IsEntered(handlersMap[key])) { Monitor.PulseAll(handlersMap[key]); Monitor.Exit(handlersMap[key]); } // ...</span></span></code> </pre><br>  This code is necessary in case there has not been a single iteration in the foreach, which is possible when for one of the keys there is not a single handler in the corresponding hashset. <br><br>  The following code requires a detailed explanation: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(handlr) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre><br>  The fact is that in the Red Architecture concept, the only objects created outside the class v and requiring synchronization of threads are handler functions.  If we couldn‚Äôt manage the code that call handlers to our functions, we would have to ‚Äúfence‚Äù something like <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, NotifyCollectionChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(OnEvent); <span class="hljs-comment"><span class="hljs-comment">//    unlock(OnEvent); }</span></span></code> </pre><br>  Notice the lock () unlock () lines between which the useful method code is located.  If inside the handler data is modified that is external to it, then lock () and unlock () would be necessary to add.  Because simultaneously the flows entering into this function will change values ‚Äã‚Äãof external variables in the chaotic order. <br><br>  But instead, we added just one line to the whole program - lock (handlr), and did it inside the class v without touching anything outside of it!  Now we can write as many handler functions as possible without thinking about their thread safety, since the implementation of class v guarantees that only one thread can enter this particular handler, other threads will ‚Äústand‚Äù on lock (handlr) and wait for the work to be completed in this the handler of the previous thread that entered it. <br><br><h4>  foreach, for (;;) and multithreading </h4><br>  In the Tests listing (at the end of the article), there is a foreachTest (string [] a) method that checks the for (;;) loop operation while simultaneously entering this method and, therefore, into the for (;;) loop of two threads.  The following is a possible part of the output of this method: <br><br>  // ... <br>  <i>~: string20</i> <i><br></i>  <i>~: string21</i> <i><br></i>  <i>~: string22</i> <i><br></i>  <i>~: astring38</i> <i><br></i>  <i>~: astring39</i> <i><br></i>  <i>~: string23</i> <i><br></i>  <i>~: string24</i> <i><br></i>  <i>~: astring40</i> <i><br></i>  <i>~: astring41</i> <i><br></i>  <i>~: string25</i> <i><br></i>  <i>~: astring42</i> <i><br></i>  <i>~: string26</i> <i><br></i>  <i>~: astring43</i> <i><br></i>  <i>~: astring44</i> <i><br></i>  <i>~: string27</i> <i><br></i>  <i>~: astring45</i> <i><br></i>  <i>~: string28</i> <i><br></i>  <i>// ...</i> <i><br></i> <br>  We see that despite the mixed output of the strings ‚Äústring‚Äù and ‚Äúastring‚Äù, the numeric suffix of each of the strings goes in order, i.e.  To output each of the lines, the local variable i is taken to be correct.  Such a conclusion suggests that the simultaneous input of two streams to for (;;) is safe.  Probably, all variables declared within the framework of the for (;;) construction, for example, the variable int i, are created on the stack of the thread entered in for (;;).  That is why access to variables created inside for (;;) does not need ‚Äúmanual‚Äù synchronization, since they are already available only to the thread in whose stack they were created.  This is the case on C # and the .NET platform.  In other languages, although unlikely, there may be a different behavior, so such a test would not be superfluous. <br><br><h4>  try ... catch is the norm, not an exception </h4><br>  try ... catch At first glance, this construction does not seem necessary, but it is important.  It is designed to protect us from a situation where at the time of the call to handlr.Invoke () the object in which the defined handlr was destroyed.  An object can be destroyed by another thread or by the garbage collector at any time between the lines. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key]))</code> </pre><br>  and <br><br><pre> <code class="cs hljs">handlr.Invoke();</code> </pre><br>  In exception handling - the catch block, we check if the handler refers to a zero (remote) object, we simply remove it from the list of handlers. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (handlr) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { handlr.Invoke(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;(){ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(key, o) })); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> __tests__ /* check modification of global collection of handlers for a key while iteration through its copy */ handlersMap[key].Add((object sender, NotifyCollectionChangedEventArgs e) =&gt; { }); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } catch (Exception e) { // because exception can be thrown inside handlr.Invoke(), but before handler was destroyied. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ReferenceEquals(null,handlr) &amp;&amp; e is NullReferenceException) // handler invalid, remove it m(handlr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> // exception in handler's body throw e; }</span></span></code> </pre><br><h4>  Class v initialization </h4><br>  The static constructor is one of the distinguishing features of C #.  It can not be called directly.  It is called automatically only once, before creating the first object of this class.  We use it to initialize handlersMap ‚Äî for all keys from k, we prepare for use empty HashSets intended for storing handler functions of each of the keys.  In the absence of a static constructor in other languages, any method that initializes an object will do. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (ke <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enum.GetValues(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(k))) handlersMap[e] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NotifyCollectionChangedEventHandler&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tests().run(); }</code> </pre><br><h4>  How to deal with thread unsafe collection? </h4><br>  The C # HashSet class does not provide synchronization when modifying from multiple threads (not thread safe), so we need to synchronize the modification of this object, namely the deletion and addition of elements.  In our case, it‚Äôs enough to add one lock (handlersMap [key]) line just before the operation of deleting / adding an element in the methods m (), h () of class v.  In this case, the object blocking the thread will be the HashMap object associated with this particular key key.  This will make it possible to modify this particular hashset with only one stream. <br><br><h4>  "Side effects" multithreading </h4><br>  Some of the "side effects" of multi-threading are worth mentioning.  In particular, the code of handler functions must be prepared for the fact that in some cases it will be called after the "unsubscribe" of the handler function from receiving events.  That is, after calling m (key, handler), the handler can still be called for some time (probably a few fractions of a second).  This is possible because at the time the handlersMap [key] .Remove (handler) in the m () method is called, this handler may already be copied by another thread in the foreach line (var handlr in new List (handlersMap [key])) , and will be called in the Add () method of the class v after its deletion in the m () method. <br><br><h4>  Simple rules for solving complex problems. </h4><br>  Finally, I want to draw attention to the fact that we, being diligent developers, do not violate agreements on the use of locks.  In particular, such agreements are listed on this page in the Remarks <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement">docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement</a> section.  They are common to all languages, not just C #.  The essence of these agreements is as follows: <br><br><ul><li>  Do not use public types as an object for a locale. </li></ul><br>  We use 2 types of objects for locks and both are private.  The first type is a HashSet object, which is private for class v.  The second type is an object of the handler function type.  Functions handlers are declared private in all objects that they declare and use to receive events.  In the case of the Red Architecture, only the class v should call the function handlers directly, and nothing else. <br><br><h4>  Listings </h4><br>  Below is the complete code for the classes v and Tests.  In C #, you can use them directly by copying from here.  ‚ÄúTranslation‚Äù of this code into other languages ‚Äã‚Äãwill be a small and entertaining task for you. <br><br>  Below is the code of the ‚Äúuniversal‚Äù class v, which can also be used in mobile application projects on the Xamarin / C # platform. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Specialized; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Common</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> k {OnMessageEdit, MessageEdit, MessageReply, Unused, MessageSendProgress, OnMessageSendProgress, OnIsTyping, IsTyping, MessageSend, JoinRoom, OnMessageReceived, OnlineStatus, OnUpdateUserOnlineStatus } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">v</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;k, HashSet&lt;NotifyCollectionChangedEventHandler&gt;&gt; handlersMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;k, HashSet&lt;NotifyCollectionChangedEventHandler&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k[] keys, NotifyCollectionChangedEventHandler handler</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys) <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(handlersMap[key]) handlersMap[key].Add(handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NotifyCollectionChangedEventHandler handler</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (k key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enum.GetValues(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(k))) <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(handlersMap[key]) handlersMap[key].Remove(handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { Monitor.Enter(handlersMap[key]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Monitor.IsEntered(handlersMap[key])) { Monitor.PulseAll(handlersMap[key]); Monitor.Exit(handlersMap[key]); } <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (handlr) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { handlr.Invoke(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;(){ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(key, o) })); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> __tests__ /* check modification of global collection of handlers for a key while iteration through its copy */ handlersMap[key].Add((object sender, NotifyCollectionChangedEventArgs e) =&gt; { }); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } catch (Exception e) { // because exception can be thrown inside handlr.Invoke(), but before handler was destroyied. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ReferenceEquals(null,handlr) &amp;&amp; e is NullReferenceException) // handler invalid, remove it m(handlr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> // exception in handler's body throw e; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Monitor.IsEntered(handlersMap[key])) { Monitor.PulseAll(handlersMap[key]); Monitor.Exit(handlersMap[key]); } } static v() { foreach (ke in Enum.GetValues(typeof(k))) handlersMap[e] = new HashSet&lt;NotifyCollectionChangedEventHandler&gt;(); new Tests().run(); } } }</span></span></code> </pre><br>  Below is the code of the ‚Äúsimplified‚Äù class v, which can be used on the ‚Äústandard‚Äù C # .NET platform.  Its only difference from the ‚Äúuniversal‚Äù counterpart is the use of the ConcurrentBag collection instead of HashMap, which provides out-of-the-box synchronization of streams when accessing itself.  Using ConcurrentBag instead of HashSet allowed to remove most of the synchronization code streams from the class v. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Specialized; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Concurrent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Common</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> k { OnMessageEdit, MessageEdit, MessageReply, Unused, MessageSendProgress, OnMessageSendProgress, OnIsTyping, IsTyping, MessageSend, JoinRoom, OnMessageReceived, OnlineStatus, OnUpdateUserOnlineStatus } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">v</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;k, ConcurrentBag&lt;NotifyCollectionChangedEventHandler&gt;&gt; handlersMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;k, ConcurrentBag&lt;NotifyCollectionChangedEventHandler&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k[] keys, NotifyCollectionChangedEventHandler handler</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys) handlersMap[key].Add(handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NotifyCollectionChangedEventHandler handler</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (k key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enum.GetValues(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(k))) handlersMap[key].Remove(handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (handlr) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { handlr.Invoke(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;(){ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(key, o) })); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> __tests__ /* check modification of global collection of handlers for a key while iteration through its copy */ handlersMap[key].Add((object sender, NotifyCollectionChangedEventArgs e) =&gt; { }); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } catch (Exception e) { // because exception can be thrown inside handlr.Invoke(), but before handler was destroyied. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ReferenceEquals(null,handlr) &amp;&amp; e is NullReferenceException) // handler invalid, remove it m(handlr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> // exception in handler's body throw e; } } } static v() { foreach (ke in Enum.GetValues(typeof(k))) handlersMap[e] = new ConcurrentBag&lt;NotifyCollectionChangedEventHandler&gt;(); new Tests().run(); } } }</span></span></code> </pre><br>  Below is the code for the Tests class that tests the multithreaded use of the v class, as well as handler functions.  Pay attention to the comments.  They have a lot of useful information about how the testing and test code works. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Specialized; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Diagnostics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ChatClient.Core.Common</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeadObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, NotifyCollectionChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newItem = (KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;)e.NewItems[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Debug.WriteLine(String.Format(<span class="hljs-string"><span class="hljs-string">"~ OnEvent() of dead object: key: {0} value: {1}"</span></span>, newItem.Key.ToString(), newItem.Value)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { vh(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> k[] { k.OnlineStatus }, OnEvent); } ~DeadObject() { <span class="hljs-comment"><span class="hljs-comment">// Accidentally we forgot to call vm(OnEvent) here, and now v.handlersMap contains reference to "dead" handler } } public class Tests { void OnEvent(object sender, NotifyCollectionChangedEventArgs e) { var newItem = (KeyValuePair&lt;k, object&gt;)e.NewItems[0]; Debug.WriteLine(String.Format("~ OnEvent(): key: {0} value: {1}", newItem.Key.ToString(), newItem.Value)); if (newItem.Key == k.Unused) { // v.Add(k.Unused, "stack overflow crash"); // reentrant call in current thread causes stack overflow crash. Deadlock doesn't happen, because lock mechanism allows reentrancy for a thread that already has a lock on a particular object // Task.Run(() =&gt; v.Add(k.Unused, "deadlock")); // the same call in a separate thread don't overflow, but causes infinite recursive loop } } void OnEvent2(object sender, NotifyCollectionChangedEventArgs e) { var newItem = (KeyValuePair&lt;k, object&gt;)e.NewItems[0]; Debug.WriteLine(String.Format("~ OnEvent2(): key: {0} value: {1}", newItem.Key.ToString(), newItem.Value)); } void foreachTest(string[] a) { for (int i = 0; i &lt; a.Length; i++) { Debug.WriteLine(String.Format("~ : {0}{1}", a[i], i)); } } async void HandlersLockTester1(object sender, NotifyCollectionChangedEventArgs e) { var newItem = (KeyValuePair&lt;k, object&gt;)e.NewItems[0]; Debug.WriteLine(String.Format("~ HandlersLockTester1(): key: {0} value: {1}", newItem.Key.ToString(), newItem.Value)); await Task.Delay(300); } async void HandlersLockTester2(object sender, NotifyCollectionChangedEventArgs e) { var newItem = (KeyValuePair&lt;k, object&gt;)e.NewItems[0]; Debug.WriteLine(String.Format("~ HandlersLockTester2(): key: {0} value: {1}", newItem.Key.ToString(), newItem.Value)); } public async void run() { // Direct call for garbage collector - should be called for testing purposes only, not recommended for a business logic of an application GC.Collect(); /* * == test v.Add()::foreach (var handlr in new List&lt;NotifyCollectionChangedEventHandler&gt;(handlersMap[key])) * for two threads entering the foreach loop at the same time and iterating handlers only of its key */ Task t1 = Task.Run(() =&gt; { v.Add(k.OnMessageReceived, "this key"); }); Task t2 = Task.Run(() =&gt; { v.Add(k.MessageEdit, "that key"); }); // wait for both threads to complete before executing next test await Task.WhenAll(new Task[] { t1, t2 }); /* For now DeadObject may be already destroyed, so we may test catch block in v class */ v.Add(k.OnlineStatus, "for dead object"); /* test reentrant calls - causes stack overflow or infinite loop, depending on code at OnEvent::if(newItem.Key == k.Unused) clause */ v.Add(k.Unused, 'a'); /* testing foreach loop entering multiple threads */ var s = Enumerable.Repeat("string", 200).ToArray(); var n = Enumerable.Repeat("astring", 200).ToArray(); t1 = Task.Run(() =&gt; { foreachTest(s); }); t2 = Task.Run(() =&gt; { foreachTest(n); }); // wait for both threads to complete before executing next test await Task.WhenAll(new Task[] { t1, t2 }); /* testing lock(handlr) in Add() method of class v */ vh(new k[] { k.IsTyping }, HandlersLockTester1); vh(new k[] { k.JoinRoom }, HandlersLockTester2); // line 1 Task.Run(() =&gt; { v.Add(k.IsTyping, "first thread for the same handler"); }); // line 2 Task.Run(() =&gt; { v.Add(k.IsTyping, "second thread for the same handler"); }); // line below will MOST OF THE TIMES complete executing before the line 2 above, because line 2 will wait completion of line 1 // since both previous lines 1 and 2 are calling the same handler, access to which is synchronized by lock(handlr) in Add() method of class v Task.Run(() =&gt; { v.Add(k.JoinRoom, "third thread for other handler"); }); } public Tests() { // add OnEvent for each key vh(new k[] { k.OnMessageReceived, k.MessageEdit, k.Unused }, OnEvent); // add OnEvent2 for each key vh(new k[] { k.Unused, k.OnMessageReceived, k.MessageEdit }, OnEvent2); /* == test try catch blocks in v class, when handler is destroyed before handlr.Invoke() called */ var ddo = new DeadObject(); // then try to delete object, setting its value to null. We are in a managed environment, so we can't directly manage life cicle of an object. ddo = null; } } }</span></span></code> </pre><br>  The code that registers the handler function as well as the handler function itself for such a class v could look like this: <br><br>  handler function registration code <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// add OnEvent for each key vh(new k[] { k.OnMessageReceived, k.MessageEdit, k.Unused }, OnEvent);</span></span></code> </pre><br>  handler function code <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, NotifyCollectionChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newItem = (KeyValuePair&lt;k, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;)e.NewItems[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Debug.Write(<span class="hljs-string"><span class="hljs-string">"~ OnEvent(): key {0} value {1}"</span></span>, newItem.Key.ToString(), newItem.Value); }</code> </pre><br>  A general description of the <b>Red Architecture</b> is <a href="https://habrahabr.ru/post/333870/">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/334840/">https://habr.com/ru/post/334840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334826/index.html">ERP: project initiation. Alternative customer perspective</a></li>
<li><a href="../334828/index.html">Rethinking PID 1. Part 1</a></li>
<li><a href="../334832/index.html">Favorites: reverse engineering links</a></li>
<li><a href="../334836/index.html">Analytical systems for mobile applications: test and selection criteria</a></li>
<li><a href="../334838/index.html">AppCode 2017.2: Extract Method and Auto-Complete Improvements for Swift, Objective-C __ auto-type support and much more</a></li>
<li><a href="../334842/index.html">How to learn good design in 6 steps</a></li>
<li><a href="../334844/index.html">Redmine recurring tasks</a></li>
<li><a href="../334846/index.html">Kubernetes on bare gland in 10 minutes</a></li>
<li><a href="../334848/index.html">Geometry in computer games</a></li>
<li><a href="../334850/index.html">When localization is needed: why is it so hard to find a good translator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>