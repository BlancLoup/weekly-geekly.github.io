<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the world of USB-devices on the example of microcontrollers from Silicon Laboratories</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Devices from Silicon Laboratories are not widely popular in amateur circles, they are far from such flagships like Atmel. However, they have both quit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the world of USB-devices on the example of microcontrollers from Silicon Laboratories</h1><div class="post__text post__text-html js-mediator-article">  Devices from Silicon Laboratories are not widely popular in amateur circles, they are far from such flagships like Atmel.  However, they have both quite accessible to the mere mortal microcontrollers of the main lines in the TQFP package, and the USB ToolStick starter kits (which was recently <a href="http://habrahabr.ru/blogs/controllers/112791">mentioned in the Habr√©</a> ).  I myself began my acquaintance with microprocessor technology, working with the Silbses, and quite successfully. <br>  In this article, I will tell you how to connect a computer with a PC using a USB interface, and how Silabs tried to make it easy for the developer. <br>  As a test, we will use the C8051F320DK board, with a microcontroller, respectively, of the F32x series, which supports USB hardware, and Keil's uVision4 development environment. <br><br><a name="habracut"></a>  Before you start digging towards USB communication, you need to decide on some basic aspects of the protocol: what place does the device occupy in the topology (host or slave device) and what character will the information transmitted via the interface. <br><br>  The USB architecture allows four basic types of data transfer: <br><ul><li>  Control <i>transfers</i> are used to configure devices during their connection and to control devices during operation.  The protocol provides guaranteed data delivery. </li><li>  <i>Bulk data transfers are bulk</i> transfers without any obligation to delay delivery and transfer speeds.  Array transfers can occupy the entire bus bandwidth that is free from other types of transfers.  The priority of these programs is the lowest, they can be suspended with a large load of the bus.  Delivery guaranteed - with a random error is repeated.  Array transfers are appropriate for exchanging data with printers, scanners, storage devices, and so on. </li><li>  Interrupt <i>transfers</i> are short transfers that are spontaneous in nature and must be serviced no slower than the device requires. <br>  The service time limit is set in the range of 10-255 ms for <br>  low, 1-255 ms for full speed, 125 Œºs can be ordered at high speed.  In case of random exchange errors, a repetition is performed.  Interrupts are used, for example, when entering characters from the keyboard or to send a message about moving the mouse. </li><li>  Isochronous transfers ( <i>isochronous transfers</i> ) - continuous transmission in real time, occupying a pre-agreed part of the bandwidth of the bus with a guaranteed delivery delay time.  They allow to organize at full speed a channel with a band of 1.023 MB / s (or two of 0.5 MB / s each), occupying 70% of the available band (the rest can be filled with less capacious channels).  At high speed, the endpoint can receive a channel up to 24 MB / s (192 Mbit / s).  If an error is detected, the isochronous data is not repeated - invalid packets are ignored.  Isochronous transfers are needed for streaming devices: video cameras, digital audio devices (USB speakers, microphone), devices for playing and recording audio and video data (CD and DVD). </li></ul><br>  In the case of connecting the MC to the computer, the controller will obviously be a slave device. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Creating a USB compatible HID device such as a joystick </h4><br>  The most common and simply implemented type of USB device is HID (Human Interface Devices).  The type of transmission used for such devices is interrupts.  Typical representatives of this class are USB keyboards, mice, joysticks, monitor setting panels, barcode readers, card readers, and the like. <br>  The advantages of HID devices are: <br><ul><li>  ease of implementation; </li><li>  compact code; </li><li>  Windows support (no additional drivers needed). </li></ul><br>  So, we realize the simplest <b>joystick manipulator</b> .  For example, we will need a gas handle with two (or more) buttons for combat fur (!), Which we collect in the garage.  On the demoboard C8051F320DK there is one variable resistor and 2 buttons - for a minimum it is enough. <br><br>  Silabovtsy provide an example of microcontroller firmware, which emulates a USB mouse with a HID interface.  This example is enough for the eyes for a quick and painless implementation of most human interaction interfaces.  As a result, in the example taken as a basis, it is necessary to recycle: <br><ol><li>  HID device handle configuration; </li><li>  data transfer procedures; </li><li>  HID device name descriptor. </li></ol><br><h6>  Starting with a device descriptor </h6><br>  We need the handle in the following form: <br> <code>code const hid_report_descriptor HIDREPORTDESC = <br> { <br> 0x05, 0x01, // USAGE_PAGE (Generic Desktop) <br> 0x15, 0x00, // LOGICAL_MINIMUM (0) <br> 0x09, 0x04, // USAGE (Joystick) <br> 0xa1, 0x01, // COLLECTION (Application) <br> 0x05, 0x02, // USAGE_PAGE (Simulation Controls) <br> 0x09, 0xbb, // USAGE (Throttle) <br> 0x15, 0x00, // LOGICAL_MINIMUM (0) <br> 0x26, 0xff, 0x00, // LOGICAL_MAXIMUM (255) <br> 0x75, 0x08, // REPORT_SIZE (8) <br> 0x95, 0x01, // REPORT_COUNT (1) <br> 0x81, 0x02, // INPUT (Data,Var,Abs) <br> 0x05, 0x09, // USAGE_PAGE (Button) <br> 0x19, 0x01, // USAGE_MINIMUM (Button 1) <br> 0x29, 0x02, // USAGE_MAXIMUM (Button 2) <br> 0x15, 0x00, // LOGICAL_MINIMUM (0) <br> 0x25, 0x01, // LOGICAL_MAXIMUM (1) <br> 0x75, 0x01, // REPORT_SIZE (1) <br> 0x95, 0x08, // REPORT_COUNT (8) <br> 0x55, 0x00, // UNIT_EXPONENT (0) <br> 0x65, 0x00, // UNIT (None) <br> 0x81, 0x02, // INPUT (Data,Var,Abs) <br> 0xc0 // END_COLLECTION <br> }</code> <br>  Now we will analyze in detail what is what.  The most important part in describing a future device is data types.  It is necessary to describe the <i>Simulation Controls</i> section (simulation of the control body), in which there is just a <i>Throttle</i> (gas knob), for this we indicate: <br><ul><li>  the range of values ‚Äã‚Äãin which <i>Throttle</i> will be LOGICAL_MINIMUM (0) and LOGICAL_MAXIMUM (255), </li><li>  set the size of this range (one byte) - REPORT_SIZE (8) and </li><li>  The number of controls of this type is REPORT_COUNT (1). </li></ul><br>  Buttons with a similar story (USAGE_PAGE ( <i>Button</i> )): <br><ul><li>  value range - LOGICAL_MINIMUM (0) and LOGICAL_MAXIMUM (1); </li><li>  range size (one bit) - REPORT_SIZE (1); </li><li>  the number of buttons is more than one, so here it is already necessary to use a field of byte length, which means REPORT_COUNT (8); </li></ul><br>  All this is necessary for the operating system, now it will know how to handle the 2 bytes it receives from the controller, using the descriptor as the key to decryption. <br>  Yes, and also, there are such lines in .h, right before the hid_report_descriptor declaration: <br> <code>#define HID_REPORT_DESCRIPTOR_SIZE 0x002C <br> #define HID_REPORT_DESCRIPTOR_SIZE_LE 0x2C00 //LITTLE ENDIAN <br></code> <br>  Here it is important that the size of the descriptor is set after the creation of the descriptor itself, and it must be specified so that the controller is recognized by the computer. <br><br>  To simplify the task of writing a descriptor, you can use the program on the <a href="http://www.usb.org/">www.usb.org</a> ( <a href="">HID Descriptor Tool</a> ).  Included with the program are examples of the configurations of some HID-devices, which can be adjusted for your task or create your own HID-device. <br>  This is the end of the description of the joystick and you need to prepare the data for transfer to the PC. <br><br><h6>  Data transfer procedures </h6><br>  We find in the example the following code: <br> <code>void IN_Report(void){ <br> <br> IN_PACKET[0] = VECTOR; <br> IN_PACKET[1] = BUTTONS; <br> <br> // point IN_BUFFER pointer to data packet and set <br> // IN_BUFFER length to transmit correct report size <br> IN_BUFFER.Ptr = IN_PACKET; <br> IN_BUFFER.Length = 2; <br> } <br></code> <br>  In this procedure, we are compiling a sending packet, which afterwards through a cunning pointer (in fact, it is just a structure from the pointer and its length) and is transmitted by our device.  The main thing is to make a package carefully, which the comment hints at, and then we will do everything with it without our participation. <br>  Now I‚Äôll tell you how and from where we take the VECTOR and BUTTONS variables (both, by the way, are of type unsigned char byte size). <br>  The global variable VECTOR is assigned values ‚Äã‚Äãfrom the ADC when an interrupt occurs: <br> <code>void ADC_Conver_ISR(void) interrupt 10 <br> { <br> AD0INT = 0; <br> <br> //    <br> if( VECTOR != ADC0H) <br> LED = 1; <br> else <br> LED = 0; <br> <br> VECTOR = ADC0H; <br> } <br></code> <br>  The BUTTONS global variable likewise changes the value depending on the button presses.  Buttons are interrogated on interruption from the timer.  Adjust the timer according to your personal preferences. <br> <code>void Timer2_ISR (void) interrupt 5 <br> { <br> P2 &amp;= ~Led_2; <br> <br> if ((P2 &amp; Sw1)==0) //    #1 <br> { <br> // pressed <br> BUTTONS = BUTTONS | (1&lt;&lt;0); <br> LED2 = 1; <br> } <br> else <br> { <br> // not pressed <br> BUTTONS = BUTTONS &amp; 0xFE; <br> } <br> <br> if ((P2 &amp; Sw2)==0) //    #2 <br> { <br> // pressed <br> BUTTONS = BUTTONS | (1&lt;&lt;1); <br> LED2 = 1; <br> } <br> else <br> { <br> // not pressed <br> BUTTONS = BUTTONS &amp; 0xFD; <br> } <br> TF2H = 0; //    Timer2 <br> } <br></code> <br><br><h6>  HID device name descriptor </h6><br>  Finally, we can adjust the string data so that the device has the name we want (in my example, ‚ÄúJOYSTICK-HABR‚Äù). <br>  We are looking for a string descriptor <i>String2Desc</i> , rewritten <br> <code>#define STR2LEN sizeof ("JOYSTICK-HABR") * 2 <br> <br> code const unsigned char String2Desc [STR2LEN] = <br> { <br> STR2LEN, 0x03, <br> 'J', 0, <br> 'O', 0, <br> 'Y', 0, <br> 'S', 0, <br> 'T', 0, <br> 'I', 0, <br> 'C', 0, <br> 'K', 0, <br> '-', 0, <br> 'H', 0, <br> 'A', 0, <br> 'B', 0, <br> 'R', 0, <br> }; <br></code> <br><br><h5>  HID Device Identification </h5><br>  After compiling the project and programming the microcontroller, you can connect the device to the USB port.  The host determines that the device belongs to the HID class and transfers control of the device to the appropriate driver. <br><img src="http://habrastorage.org/storage/habraeffect/38/2c/382c8cc5d0ce0633bb20b7bb2ed138a8.jpg" alt="image"><br>  Now in Windows, go to Control Panel-&gt; Game Devices and see our passenger there.  We look at the properties and check the functionality. <br><img src="http://habrastorage.org/storage/habraeffect/ed/aa/edaa0b10e49d1388b4cd19e7c809f7af.jpg" alt="image"><br>  Low transmission speed is the main limitation of the HID-version of the device.  The maximum possible data transfer rate for such an exchange is 64 kbps.  This figure compared to 12 Mbit / s of full-speed USB-bus looks like a minus of HID-technology in the matter of choosing a specific USB-implementation.  However, for many communication tasks of the specified speed, the HID-architecture, as a specialized tool, occupies a worthy place among the ways of organizing data exchange. <br><br>  Generally speaking, HID devices are easy to implement on almost any MK with USB support.  As a rule, one working example from the developers is enough, correcting which you can get any required functionality. <br><br><h4>  Creating a complete USB device using Silabs USBXpress </h4><br>  But here comes the moment when you need to use your own protocol for working with the device on the MC.  In this case, I would like to transfer a lot of data at high speed, and do it all with the help of my laptop, in which there is a lot of USB and not a single COM, and even your device should be no more than a matchbox, and sculpt on a USB-UART board on a chip FT232RL there is no possibility. <br>  It was then that the guys from Silabs decided to make life easier for everyone and show ‚Äúthe way to the future‚Äù, without hard breaking their teeth about writing their own firewood and firmware. <br>  <u>The USBXpress Development Kit</u> is a complete solution for the MK and host (PC), providing simple operation with the USB protocol using the high-level API for both parties.  No special knowledge is required of either the USB protocol itself or the writing of drivers.  That is how silibovtsy write in their guide. <br><img src="http://habrastorage.org/storage/habraeffect/ee/ca/eeca3992fae5bc3b0b883d42f1146d2d.jpg" alt="image"><br>  Speaking of <a href="http://www.silabs.com/public/documents/tpub_doc/anote/Microcontrollers/USB/en/an169.pdf">Programmer's Guid</a> : occupying only 30 pages, it is extremely simple and easy to understand.  I personally don‚Äôt like examples, often there are very crooked places, programs for PCs are generally better not to watch, they are extremely unreadable. <br>  USBXpress DK is provided for the C8051F32x, C8051F34x microcontrollers and the CP210x (USB-to-UART Bridge Controller).  The USBXpress library includes a lower level library, USB drivers for PCs and a DLL for developing applications at the top level.  And, of course, a set of documentation and examples. <br>  The library provides data transfer only in the BULK mode.  When using all the functions of the library, their implementation will take only 3 KB of flash memory of the microcontroller. <br><br><h5>  Firmware </h5><br>  Let us analyze one more or less simple and clear example, similar in functionality to the previous example in HID.  In the PC application we will not climb, with it everything will be crystal clear after we finish the firmware for the MK. <br>  So, the essence of the example TestPanel: we take from the microcontroller the readings of the ADC (Potentiometer) and the built-in thermometer ( <i>Temperature</i> ), as well as by pressing the buttons ( <i>Switch1State</i> and <i>Switch2State</i> ), and we can flash LEDs ( <i>Led1</i> and <i>Led2</i> ). <br>  Now the required steps and subtle points that we will consider: <br><ol><li>  Writing USB descriptor; </li><li>  Initialization of the device and USB on board; </li><li>  Processing of incoming data and the formation of the outgoing packet; </li><li>  Interrupt handling </li></ol><br>  But first, when creating a project, do not forget to include the USB_API.h <b>header</b> file and the <b>USBX_F320_1.lib</b> library <b>into it</b> . <br><br><h6>  Writing USB descriptor </h6><br>  Unlike HID with its cunningly formalized structure, everything is simple <br> <code>code const UINT USB_VID = 0x10C4; <br> code const UINT USB_PID = 0xEA61; <br> code const BYTE USB_MfrStr[] = {0x1A,0x03,'S',0,'i',0,'l',0,'a,0,'b,0,'s,0}; <br> code const BYTE USB_ProductStr[] = {0x10,0x03,'U',0,'S',0,'B',0,'X',0,'_',0,'A',0,'P',0}; <br> code const BYTE USB_SerialStr[] = {0x0A,0x03,'H',0,'A',0,'B',0,'R',0}; <br> code const BYTE USB_MaxPower = 15; <br> code const BYTE USB_PwAttributes = 0x80; <br> code const UINT USB_bcdDevice = 0x0100; <br></code> <br>  With VID, PID and names, I think everything is clear, plus you can also set the maximum current with the MaxPower parameter (max current = _MaxPower * 2), PwAttributes ‚Äî the parameter responsible for the remote wake-up of the host, and bcdDevice ‚Äî the device release number. <br><br><h6>  Nuance of device initialization and USB on board </h6><br>  Now we will begin the main function itself, in which the MC will tirelessly perform the reception and transmission of data. <br> <code>void main(void) <br> { <br> PCA0MD &amp;= ~0x40; // Disable Watchdog timer <br> USB_Clock_Start(); // Init USB clock *before* calling USB_Init <br> USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcdDevice); <br> <br> Initialize(); <br> USB_Int_Enable(); <br> ... <br></code> <br>  Here, as the comment requires, first of all it is necessary to initialize the clock generator for USB before its initialization, only then carry out the rest of the starting operations for MC - Initialize ();  - which configures ports, timer and ADC;  then enable USB interrupts. <br><br><h6>  Processing of incoming data and the formation of the outgoing packet </h6><br>  That got to the most important thing <br> <code>//...  main <br> while (1) <br> { <br> if (Out_Packet[0] == 1) Led1 = 1; <br> else Led1 = 0; <br> if (Out_Packet[1] == 1) Led2 = 1; <br> else Led2 = 0; <br> <br> In_Packet[0] = Switch1State; <br> In_Packet[1] = Switch2State; <br> In_Packet[2] = Potentiometer; <br> In_Packet[3] = Temperature; <br> } <br> //  main <br> } <br></code> <br>  Out_Packet - packet received from the host; <br>  In_Packet - package sent to the host; <br>  The essence is clear, MK constantly updates the sent packet and reads the status of the received. <br><br><h6>  Interrupt handling </h6><br>  Now in 2 words about where we get the values ‚Äã‚Äãin the package being sent.  As in the example with HID, the state of the buttons is obtained by interrupts from the timer, and the values ‚Äã‚Äãof the ADC and thermometer - by interrupts from the ADC. <br>  Here is one subtle point - during the initialization of the ADC, we adjust it so that the conversion of values ‚Äã‚Äãtakes place on the overflow of the timer (the same one that we use for the buttons), and the very same interrupt from the ADC occurs upon the completion of the conversion.  And here, in addition to receiving the values ‚Äã‚Äãof the converter, we call the API function at the end of the procedure. <br>  Block_Write (In_Packet, 8) <br>  which sends the collected data to the computer. <br>  Receiving commands from the computer occurs in the procedure for handling interrupts from USB: <br> <code>void USB_API_TEST_ISR(void) interrupt 16 <br> { <br> BYTE INTVAL = Get_Interrupt_Source(); <br> <br> if (INTVAL &amp; RX_COMPLETE) <br> { <br> Block_Read(Out_Packet, 8); <br> } <br> <br> if (INTVAL &amp; DEV_SUSPEND) <br> { <br> Suspend_Device(); <br> } <br> <br> if (INTVAL &amp; DEV_CONFIGURED) <br> { <br> Initialize(); <br> } <br> } <br></code> <br>  This moment is detailed in the Programmer's Guid.  The bottom line is that the Get_Interrupt_Source () API function is called, which returns the code for causing the interrupt API.  Next, the code is analyzed and the necessary action is performed. <br><br><h5>  Programs on PC </h5><br>  I will not analyze the program for the computer.  Silabovtsy provided examples in Visual Basic and C, but, even without looking at the source code, you shouldn‚Äôt connect the library in the development environment you use and read a couple of pages about the functions. <br>  Therefore, I will use the already compiled program from the example. <br><br>  So, we compile the project for MK, sew up, install universal drivers for USBXpress and connect a debugging board.  The system will detect the new device and install drivers for it. <br>  We'll see after the installation what is happening in the device manager of Windows: <br><img src="http://habrastorage.org/storage/habraeffect/d9/c9/d9c9717a803fa55f4759761e78b6a051.jpg" alt="image"><br>  Now run the program: <br><img src="http://habrastorage.org/storage/habraeffect/b4/c2/b4c2c2d900d50cf8222fb634aafb53eb.jpg" alt="image"><br>  We see that she correctly found the device. <br><img src="http://habrastorage.org/storage/habraeffect/1a/69/1a692c73bba9a3ac6b482268046b8ac1.jpg" alt="image"><br>  That's all, now you can poke buttons here, blink diodes, warm MK with your hands, see how the temperature grows. <br><br><h4>  Conclusion </h4><br>  In general, the creation of USB devices using USBXpress libraries turned out to be faster and more transparent than using the HID architecture.  And the speed will be definitely higher.  The thinnest place is that the library is closed, and it is impossible to know how reliable this solution is, besides only BULK data transfer mode is available. <br><br><h5>  Used and useful sources: </h5><br><ol><li>  Guk M., PC hardware interfaces.  Encyclopedia.  - SPb .: Peter, 2002. - 528 p. </li><li>  Kurilin A.I.  Silicon Labs microcontrollers with USB interface.  Magazine "Electronic Components" ‚Ññ5, 2007 </li><li>  <a href="http://www.microchip.com.ru/Support/USB%2520apps.html">Practical use of the USB interface in PIC controllers</a> </li><li>  <a href="http://www.etheus.net/SiUSBXp_Linux_Driver">SiUSBXpress Linux Driver</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/116709/">https://habr.com/ru/post/116709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116701/index.html">April 1st on the Internet</a></li>
<li><a href="../116702/index.html">Popular: Site RSS + Facebook Statistics</a></li>
<li><a href="../116703/index.html">Statistics of musical preferences of Habr's readers</a></li>
<li><a href="../116705/index.html">Thoughts on free accounting software</a></li>
<li><a href="../116708/index.html">Sync open tabs via Dropbox</a></li>
<li><a href="../116710/index.html">Medvedev delighted with the presented iPad 2</a></li>
<li><a href="../116711/index.html">Novice authors</a></li>
<li><a href="../116712/index.html">Choosing a domestic cloud hosting provider</a></li>
<li><a href="../116713/index.html">Class plugging</a></li>
<li><a href="../116714/index.html">The world is crazy or OpenSource just do not advertise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>