<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FastCGI application in Perl. Part two.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The FastCGI application written in the previous article is chained to the same terminal from which it was launched. The application will run smoothly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FastCGI application in Perl. Part two.</h1><div class="post__text post__text-html js-mediator-article">  The FastCGI application written in the <a href="http://ivanych.habrahabr.ru/blog/52980/">previous article</a> is chained to the same terminal from which it was launched.  The application will run smoothly as long as the terminal is open.  As soon as you close the terminal, the application will be killed immediately. <br><br>  The reason is that any program launched from the terminal becomes a descendant of this terminal, and the terminal, respectively, the parent of this program.  The existence of descendants without parents is not allowed.  Accordingly, when a parent terminal is closed, all its descendants dependent on it, and in particular our FastCGI application, are immediately closed. <br><br>  In order for the FastCGI application to no longer depend on the parent terminal, it must be converted from a simple script into a daemon. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What the hell is this? <br><a name="habracut"></a><br>  <a href="http://www.freebsd.org/ru/copyright/daemon.html">A daemon</a> is a program that runs in the background without direct user interaction.  The parent of any daemon is init - the very first program that starts when the operating system boots and starts all other programs.  init works from boot up to shutter, so the demons (unless kill intervenes, of course) also work without sleep and rest. <br><br>  In order to become a demon, an application must perform a series of actions, the main of which is to get rid of parental care at all costs. <br><br>  Take the script from the previous article and add to it a block of code that executes daemonization: <br><br><pre> #! / usr / bin / perl

 # To heighten the order
 use strict;
 use warnings;

 # This module implements the FastCGI protocol
 use FCGI;

 # Demonization {
     # This module is for talking with concepts on the operating system :)
     use POSIX;
   
     # Fork
     # getting rid of the parent
     fork_proc () &amp;&amp; exit 0;
   
     # Start a new session
     # our demon will be the ancestor of the new session
     POSIX :: setsid () or die "Can't set sid: $!";
   
     # Go to root directory
     # so as not to interfere with unmounting a file system
     chdir '/' or die "Can't chdir: $!";
   
     # Change user to nobody
     # we are paranoid, huh?
     POSIX :: setuid (65534) or die "Can't set uid: $!";

     # Reopen standard handles on / dev / null
     # no longer talk to user
     reopen_std ();
 #}

 # Open the socket
 # our demon will listen to port 9000
 # query queue length - 5 pieces
 my $ socket = FCGI :: OpenSocket (": 9000", 5);

 # Getting to listen
 # daemon will intercept standard handles
 my $ request = FCGI :: Request (\ * STDIN, \ * STDOUT, \ * STDERR, \% ENV, $ socket);

 my $ count = 1;

 # Endless cycle
 # for each accepted request, one cycle is performed.
 while ($ request-&gt; Accept ()&gt; = 0) {
     # Inside the loop, all the required actions are performed
     print "Content-Type: text / plain \ r \ n \ r \ n";
     print $ count ++;
 };

 # Fork
 sub fork_proc {
     my $ pid;
   
     FORK: {
         if (defined ($ pid = fork)) {
             return $ pid;
         }
         elsif ($! = ~ / No more process /) {
             sleep 5;
             redo FORK;
         }
         else {
             die "Can't fork: $!";
         };
     };
 };

 # Reopen standard handles on / dev / null
 sub reopen_std {   
     open (STDIN, "+&gt; / dev / null") or die "Can't open STDIN: $!";
     open (STDOUT, "+&gt; &amp; STDIN") or die "Can't open STDOUT: $!";
     open (STDERR, "+&gt; &amp; STDIN") or die "Can't open STDERR: $!";
 };
</pre><br>  Those who are in the subject may have a question - why did I manually demonize instead of using the ready-made module <a href="">Proc :: Daemon</a> ? <br><br>  The fact is that the sequence of commands required for demonization is minimized in the Proc :: Daemon module into one function.  Later, when we are going to thread paralleling to the daemon, this can play a cruel joke with us.  We will need to divide the process of demonization into two stages and it will be done only manually. <br><br>  The demonization itself, in general, does not contain any particular differences from the example from the kookbook, and the implementation of the fork_proc function is taken almost one to one from the kemebook. <br><br>  Separately, it is worth noting the change of user to nobody. <br><br>  The user nobody is a special user who does not have any privileges in the system.  Running the daemon on behalf of the user nobody provides additional protection in case some attacker can gain control of the daemon.  In this case, running the daemon on behalf of nobody will not allow the attacker to gain access to the rest of the system‚Äôs resources. <br><br>  The number 65534 in the setuid function is the uid of the user nobody.  You can specify the uid using the special command: <br><br>  <b>$ id nobody</b> <br><br>  Yes, pay attention - only root can change uid, therefore it must also be root to start the daemon. <br><br>  Particularly corrosive may have another question - why did I not provide signal handlers for correct completion? <br><br>  The fact is that in our particular case, signal handlers are not required.  Rather, handlers will be implemented by themselves, so to speak, in a magical way, when screwing parallelization. <br><br>  Run the demon.  If there are no errors, the daemon will start silently, output nothing and unhook from the console.  Now you can close the terminal, the demon will not pay any attention to this and continue to work. <br><br>  Open the browser test.host/fcgi-bin/ - the daemon responds as before.  Now you can shut it up only with the kill command. <br><br>  In the next part - parallelization, we teach the daemon to respond to several requests simultaneously. <br><br>  ( <a href="http://m-ivanov.livejournal.com/4831.html">original article</a> ) </div><p>Source: <a href="https://habr.com/ru/post/53206/">https://habr.com/ru/post/53206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../53192/index.html">Darwinism and web programming</a></li>
<li><a href="../53193/index.html">Invites to dcdnet.ru</a></li>
<li><a href="../53201/index.html">Update the working draft on the server.</a></li>
<li><a href="../53203/index.html">Domestic SOHO devices, is it real?</a></li>
<li><a href="../53204/index.html">Universal Tripod</a></li>
<li><a href="../53209/index.html">usb + usb. link laptops</a></li>
<li><a href="../53210/index.html">PHP - getting the amount in words</a></li>
<li><a href="../53211/index.html">sidboxes</a></li>
<li><a href="../53212/index.html">Soul is burning, I can not hold on anymore</a></li>
<li><a href="../53214/index.html">Ruby familiarity with Thread</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>