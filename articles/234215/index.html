<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A little research on the use of functors in the standard library STL C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is for beginners. The use of simple functors in algorithms is considered. It is told about the copying designer. The main goal is to stud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A little research on the use of functors in the standard library STL C ++</h1><div class="post__text post__text-html js-mediator-article">  This article is for beginners.  The use of simple functors in algorithms is considered.  It is told about the copying designer.  The main goal is to study the number of objects created by functors and simple methods of how this can be done.  The sample program is sequentially complicated.  Some steps may seem wrong and unnecessary, but this is a typical process of research and debugging.  This approach is deliberately chosen.  The usual way, when only reasonable steps are taken, is far from reality.  And to intrigue, I will say that at the end of the article we get a very unexpected result. <br><a name="habracut"></a><br>  So, let's begin. <br>  For simplicity, we assume that the std namespace is added: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>;</code> </pre> <br>  Suppose we have a container with objects.  In our case, this is a vector with inta. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mas; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; k++ ) { mas.push_back(k*<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  And we want to print it.  You can do this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = <span class="hljs-number"><span class="hljs-number">0</span></span>; curr &lt; mas.size(); curr++ ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value="</span></span>&lt;&lt;mas[curr]&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  or better with iterators: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator iter = mas.begin(); iter != mas.end(); iter++ ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value="</span></span>&lt;&lt;*iter&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  more correctly, but longer. <br><br>  But it is better not to use the usual for loop, but to take the for_each algorithm, which itself goes through the elements of the container and calls the specified function for each.  This will allow you to write more visual code.  The for_each algorithm takes the beginning and end of the range and a function as input. <br>  As such a function we will use a functor that will draw a conclusion.  A functor is an object that is used as a function.  It sounds scary, but really simple.  In this case, the functor is a class in which the operator of the bracket operator () is implemented. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Print</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value="</span></span>&lt;&lt;value&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  The operator will accept an object for processing as a parameter.  Now the algorithm can be called as follows: <br><pre> <code class="cpp hljs">for_each( mas.begin(), mas.end(), Print() );</code> </pre><br>  Beautiful and neat.  What happens when this happens?  We create a nameless Print object, which is passed to the for_each function, which iterates through the elements from the first to the last and passes them to the operator () function. <br>  The whole program will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; class Print { public: void operator() (int value) { cout&lt;&lt;"value="&lt;&lt;value&lt;&lt;endl; } }; int main() { vector&lt;int&gt; mas; for( int k = 1; k &lt; 10; k++ ) { mas.push_back(k*10); } for_each( mas.begin(), mas.end(), Print() ); return 0; }</span></span></span></span></code> </pre><br>  It's simple.  And now the question is, how many objects of the class Print will be created?  It can be assumed that one, when creating an unnamed object with the command Print (). <br>  Add a constructor, destructor and debug output to see the process of creating and deleting objects.  Now the class will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Print</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Print() { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Print::Print()"</span></span>&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ~Print() { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Print::~Print()"</span></span>&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"value="</span></span>&lt;&lt;value&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Run: <br><pre>  Print :: Print ()
 value = 10
 value = 20
 value = 30
 value = 40
 value = 50
 value = 60
 value = 70
 value = 80
 value = 90
 Print :: ~ Print ()
 Print :: ~ Print () </pre><br>  How interesting.  One constructor, and two destructors.  How can this be?  If you call a destructor for an object that has already been deleted, there will be unpredictable behavior.  It can not be.  Let's try to figure it out.  And here we must remember that an object can be created not only in the usual way, but also using a copy constructor.  This is the constructor that creates the new object, as a copy of the transferred. <br><pre> <code class="cpp hljs">Print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Print&amp; print) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Print::Print(const Print&amp; )"</span></span>&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  In this case, our object does not contain any data, so we do not copy anything.  But we must remember that if we replace our standard copy constructor with our own, then all responsibility falls on us. <br>  All code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; class Print { public: Print() { cout&lt;&lt;"Print::Print()"&lt;&lt;endl; } Print(const Print&amp; print) { cout&lt;&lt;"Print::Print(const Print&amp; )"&lt;&lt;endl; } ~Print() { cout&lt;&lt;"Print::~Print()"&lt;&lt;endl; } void operator() (int value) { cout&lt;&lt;"value="&lt;&lt;value&lt;&lt;endl; } }; int main() { vector&lt;int&gt; mas; for( int k = 1; k &lt; 10; k++ ) { mas.push_back(k*10); } for_each( mas.begin(), mas.end(), Print() ); return 0; }</span></span></span></span></code> </pre><br>  Conclusion: <br><pre>  Print :: Print ()
 value = 10
 value = 20
 value = 30
 value = 40
 value = 50
 value = 60
 value = 70
 value = 80
 value = 90
 Print :: Print (const Print &amp;)
 Print :: ~ Print ()
 Print :: ~ Print () </pre><br>  Well, it became better, two constructors, two destructors.  But why are there two objects?  About the first object is clear, it is created in our code.  In the second one, it is created even after the entire output is processed.  What for? <br>  Let's look at the description of the for_each function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for_each</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIterator first, InputIterator last, Function fn)</span></span></span></span>;</code> </pre><br>  Here, the function returns a functor that we never used.  Add the result. <br><pre> <code class="cpp hljs">Print p = for_each( mas.begin(), mas.end(), Print() );</code> </pre><br><br>  We start. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>  Print :: Print ()
 value = 10
 value = 20
 value = 30
 value = 40
 value = 50
 value = 60
 value = 70
 value = 80
 value = 90
 Print :: Print (const Print &amp;)
 Print :: ~ Print ()
 Print :: ~ Print () </pre><br>  The conclusion has not changed at all.  That is, it was an invisible variable that was passed to us, but we ignored it. <br>  Let's do something similar, but with the transform algorithm.  This algorithm iterates over the elements of one container, converts them, and places them in another container.  We multiply by 10 and put the result back into the original container. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; class Mul { public: Mul() { cout&lt;&lt;"Mul::Mul()"&lt;&lt;endl; } Mul(const Mul&amp; muk) { cout&lt;&lt;"Mul::Mul(const Mul&amp; )"&lt;&lt;endl; } ~Mul() { cout&lt;&lt;"Mul::~Mul()"&lt;&lt;endl; } int operator() (int value) { cout&lt;&lt;"value="&lt;&lt;value&lt;&lt;endl; return value*10; } }; int main() { vector&lt;int&gt; mas; for( int k = 1; k &lt; 10; k++ ) { mas.push_back(k); } transform( mas.begin(), mas.end(), mas.begin(), Mul() ); return 0; }</span></span></span></span></code> </pre><br>  Conclusion: <br><br><pre>  Mul :: Mul ()
 value = 1
 value = 2
 value = 3
 value = 4
 value = 5
 value = 6
 value = 7
 value = 8
 value = 9
 Mul :: ~ Mul () </pre><br>  Well, everything is clear, transform does not return any functors, so only one temporary object is created. <br>  And now the most interesting: <br>  Sort algorithm <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span></span></span>;</code> </pre><br>  The question is how many objects of type Compare will be created?  One?  And no.  Make a vector of three elements and sort.  We will need to create a functor that compares two objects, this operator is less than operator &lt;, which takes two objects as input and returns true if the first is considered less than the second. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; class Compare { public: Compare() { cout&lt;&lt;"Compare::Compare()"&lt;&lt;endl; } Compare(const Compare&amp; compare) { cout&lt;&lt;"Compare::Compare(const Compare&amp; )"&lt;&lt;endl; } ~Compare() { cout&lt;&lt;"Compare::~Compare()"&lt;&lt;endl; } bool operator() (int v1, int v2) { cout&lt;&lt;"compare "&lt;&lt;v1&lt;&lt;" "&lt;&lt;v2&lt;&lt;endl; return v1 &lt; v2; } }; int main() { vector&lt;int&gt; mas; for( int k = 1; k &lt;= 3; k++ ) { mas.push_back( rand() ); } sort( mas.begin(), mas.end(), Compare() ); return 0; }</span></span></span></span></code> </pre><br><br>  Conclusion: <br><pre>  Compare :: Compare ()
 Compare :: Compare (const Compare &amp;)
 Compare :: ~ Compare ()
 Compare :: Compare (const Compare &amp;)
 Compare :: Compare (const Compare &amp;)
 compare 18467 41
 Compare :: Compare (const Compare &amp;)
 compare 18467 41
 Compare :: ~ Compare ()
 compare 6334 41
 Compare :: Compare (const Compare &amp;)
 compare 6334 18467
 compare 6334 41
 Compare :: ~ Compare ()
 Compare :: ~ Compare ()
 Compare :: ~ Compare ()
 Compare :: ~ Compare () </pre><br>  This is a surprise, five comparisons and six functors! <br>  Well, our one when calling a function, and the rest uses sorting.  Why are they there?  Most likely due to the recursiveness of the sorting algorithm, where each recursive call creates a new copy that must be passed to the function. <br>  And now let's calculate how many such objects will be on average when sorting large arrays.  Add a counter and remove the entire output.  The counter is implemented as a static member of the class, which will be one for all created instances. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; class Compare { public: static int num; Compare() { num++; } Compare(const Compare&amp; compare) { num++; } ~Compare() { } bool operator() (int v1, int v2) { return v1 &lt; v2; } }; int Compare::num = 0; int main() { vector&lt;int&gt; mas; int size = 10000; for( int k = 1; k &lt;= size; k++ ) { mas.push_back( rand() ); } sort( mas.begin(), mas.end(), Compare() ); float rate = (float)Compare::num/(float)size; cout&lt;&lt;"rate="&lt;&lt;rate&lt;&lt;endl; return 0; }</span></span></span></span></code> </pre><br>  The output of the program: <br><br><pre>  rate = 1.4582 </pre><br>  For arrays of a million elements, the value is about the same.  Honestly, for me it was a big surprise.  That is, on average, one and a half of the functor is created for each element of the sorting array!  It‚Äôs good that the complexity is linear and it doesn‚Äôt affect the total running time of the algorithm so much.  What are the conclusions?  If your functor contains a lot of data and has a complex copy constructor, then this can lead to a loss of performance. <br><br>  Literature: <br>  1. Coat of arms of Sutter, Andrei Alexandrescu.  C ++ Programming Standards: Trans.  from English  - M .: Izd.  Williams House, 2005. <br>  2. <a href="http://www.cplusplus.com/">www.cplusplus.com</a> </div><p>Source: <a href="https://habr.com/ru/post/234215/">https://habr.com/ru/post/234215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234197/index.html">Microsoft has built Bing search engine in the context menu of Skype</a></li>
<li><a href="../234201/index.html">Increase disk subsystem performance in the next release of the XenServer hypervisor</a></li>
<li><a href="../234203/index.html">How does the camera rotate in 3D games or what is a rotation matrix</a></li>
<li><a href="../234211/index.html">Personal cloud on Raspberry Pi and development of uninterruptible power supply for it</a></li>
<li><a href="../234213/index.html">Acceptance test planning for a cloud site</a></li>
<li><a href="../234219/index.html">Medical anatomical illustration - the history of the study of the human body in the atlases of 5 centuries. Part 2</a></li>
<li><a href="../234221/index.html">Biased notes about Russian CAD developers</a></li>
<li><a href="../234223/index.html">Skyforge load testing. One year later</a></li>
<li><a href="../234225/index.html">Roscosmos plans to build a device for cleaning the orbit of space debris</a></li>
<li><a href="../234227/index.html">Software Project Management Conference: Why it is important not to miss the main conference on IT project management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>