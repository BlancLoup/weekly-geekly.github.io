<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prospects for the development of central processing units</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seventy years ago, in 1941, the first programmable computer was created. Since then, much water has flowed, and now computers surround us everywhere. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prospects for the development of central processing units</h1><div class="post__text post__text-html js-mediator-article">  Seventy years ago, in 1941, the first programmable computer was created.  Since then, much water has flowed, and now computers surround us everywhere.  Many aspects of the device computers have evolved greatly, many, by contrast, have not changed in essence.  In particular, the very principle of operation of the central <nobr>processors ‚Äî the</nobr> algorithmic model <nobr>‚Äî</nobr> has never changed and probably will never change.  The physical limitations of this model are well understood, and accordingly, the limit of development of central processors in the sense of their speed is clearly visible.  Technologically, this ceiling is still quite far: several decades of development and several orders of speed.  But this should not prevent us from seriously thinking about what kind of processors will be at the threshold of their speedy development. <br><a name="habracut"></a><br>  It is possible to make predictions in this area that the possible paths of development are strictly dictated by fundamental physical limitations: the finite speed of light, the laws of thermodynamics, and the restriction on the minimum size of the <nobr>elements ‚Äî</nobr> they cannot be smaller than a molecule. <br><br><h3>  Part 1. Principles of computing machines today and in the future </h3>  In the first decades of its existence, computers were used only for calculations.  The original meaning of the word ‚Äúcomputer‚Äù is translated into Russian as ‚Äúautomated computer‚Äù (AVM).  A little later, computers also began to be used as control elements of other devices, and the word ‚Äúcomputer‚Äù acquired its modern meaning: <acronym>‚Äúgeneral-purpose software performing software‚Äù</acronym> .  Today AVMs are highly specialized (used in computer centers) devices, and a computer as a control element, on the contrary, is used in almost all automated <nobr>devices,</nobr> from microwaves to robotic production lines and from mobile phones to spacecraft.  In particular, it is the controlling role that he plays in laptops, desktop workstations, and game consoles ‚Äî devices called consumer computers. <br><br>  There are several essentially different models of computation, so the future AVMs may be arranged in a completely unforeseen way.  However, the computer as a control device in any case must contain an executive unit (central processor), and the device of this unit is rigidly fixed by its functions: it must be able to <br>  - issue successive instructions to other devices and <br>  - to make a choice of a further program of action depending on the prevailing conditions. <br>  These two requirements automatically assume a device model called ‚Äúrelaxed sequential execution‚Äù in English or ‚Äúalgorithmic model‚Äù in the Russian-language tradition.  This model, unlike many others, has no quantum analogue, since quantum computations are fundamentally reversible, and making a choice is fundamentally irreversible.  It is about this model that will be discussed in the following two parts of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the sake of completeness, here is a list of all scalable hardware models of calculations known for this moment: <br>  - an algorithmic model, that is, (conditionally) step-by-step execution of instructions (‚Äúconditionally‚Äù means that parallel execution of independent instructions is allowed); <br>  - stream vector calculations and their natural <nobr>generalization -</nobr> quantum pipelines; <br>  - cellular / network automata and their natural <nobr>generalization -</nobr> quantum automata. <br><br>  Currently, in practice, with the exception of the sequential execution model, only streaming vector calculations are used: on consumer computers in specialized coprocessors for three-dimensional graphics (GPU), as well as in their high-power counterparts (GPGPU) on computing stations for numerical simulations and processing large data arrays .  The central processor delegates some specific tasks to the streaming processor, however, only he himself performs the controlling functions.  With the development of quantum computing, this state of affairs is unlikely to change: quantum conveyors and automata will only be additions to the central processor, but not its replacement. <br><br><h3>  Part 2. The element base of processors today and in the future. </h3> At the elementary level, processors consist of two types of elements: switches and tracks connecting them.  The task of the tracks is to carry the signal, and the task of the switches is to transform this signal.  There are many different implementations of switches and tracks. <br><br>  In digital electronics around us, transistors are used as switches, and tracks are made of conductors. <br><br>  <b>¬ß 2.1.</b>  <b>Signal transmission</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/50b/74f/c2a/50b74fc2ae539d7d1b224dbb4fbc43d5.jpg" align="right">  Binary digital electronics uses voltage to encode the signal.  A track carries a ‚Äúzero‚Äù signal, if a potential is applied to it <nobr>(U <sub>0</sub> ¬± Œµ)</nobr> , and if a potential is applied to it <nobr>(U <sub>1</sub> ¬± Œµ)</nobr> , then it carries a ‚Äúone‚Äù signal.  The base levels U <sub>0</sub> and U <sub>1</sub> are chosen so that (U <sub>0</sub> + Œµ) &lt;(U <sub>1</sub> - Œµ), where <nobr>Œµ is</nobr> an error that <nobr>is</nobr> unavoidable for technical reasons.  The transition from one state <nobr>to another is</nobr> a stop or, on the contrary, the acceleration of a huge number of electrons in a conductor.  Both of these processes take a lot of time and are inevitably associated with large energy losses. <br><br>  There are alternatives to digital electronics devoid of this drawback: a constant stream of electrons (so-called spintronics) or photons (so-called photon logic) can be started along the tracks, and the signal can be encoded using the polarization of this stream.  Both electrons and photons moving along a one-dimensional waveguide can exist in exactly two orthogonal polarization states, one of which is declared zero, and the other one.  What is better - photon logic or spintronics, is not yet clear: <br>  - in both cases, the flow of particles flows with inevitable heat losses, however, these losses can be arbitrarily small; <br>  - in both cases, the flow velocity is lower than the speed of light, however, it can be as close as possible to it; <br>  - in both cases, complex techniques are required so that pickups, thermal noise and background radiation (random particles passing by) do not distort the signal. <br>  In other words, the known physical limitations of both technologies are the same.  Apparently, the best results will be given by combined technologies: transportation of photons wins at long distances and loses at short distances;  however, working prototypes of adapters (in both directions) between the polarization of the photon and electron flux have already been developed.  The ideal material for spintronic tracks is graphene: it provides excellent speed with very low heat loss.  In addition, working prototypes of the following elements already exist: <br>  - tracks, reliably preserving the polarization of the current at short and medium distances; <br>  - memory cells capable of maintaining polarization and then forming a stream of stored polarization. <br><br>  Information on graphene tracks: <br>  2010-06: <a href="http://www.physorg.com/news195395438.html">Mass fabrication of graphene nanowires.</a>  Georgia Institute of Technology. <br>  2011-01: <a href="http://www.physorg.com/news/2011-01-graphene-spintronics-combo.html">Researchers managed to generate a spin current in Graphene.</a>  City University of Hong Kong. <br>  2011-02: <a href="http://www.physorg.com/news/2011-02-pure-current-graphene.html">Creating a pure spin current in graphene.</a>  City University of Hong Kong. <br>  2011-02: <a href="http://www.physorg.com/news/2011-02-narrow-free-defects-soluble-graphene.html">Mass production-ready bottom-up of defect-free graphene nanoribbons.</a>  Max Planck Institute for Polymer Research in Mainz. <br><br>  <b>¬ß 2.2.</b>  <b>Switches</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/4b1/440/2cb/4b14402cbd0bfd6e130c8ab7e0bd24ff.jpg" align="right">  Used in digital electronics, the transistor is a device with three contacts, working as follows: <br>  - if a high potential is applied to the middle contact, then the extreme contacts are connected, the switch is in the ‚Äúconductor‚Äù position; <br>  - if a low potential is applied to the middle one, then the extreme contacts are open, the switch is in the ‚Äúisolator‚Äù position. <br>  At the moment, transistors consisting of one molecule have been successfully created and tested.  Their speed and compactness almost reach the theoretical limit, but so far there are no technologies that would allow them to be mass produced and used.  All modern digital electronics are made on the basis of metal oxide field-effect transistors (MOSFET).  For several decades, manufacturers of microcircuits have only reduced the linear dimensions and power consumption of such transistors, however, industrial tests of some types of multi-current and non-transition transistors (BDT, JNT) have already been carried out.  Such transistors will be able to provide an increase in performance of <nobr>4-6</nobr> times.  This transition will not require major changes in the process and is expected in the next <nobr>5‚Äì10</nobr> years. <br><br>  For fundamental thermodynamic reasons, transistor-type switches cannot work effectively: effective must be conservative and reversible as a logical element.  These conditions are satisfied by a symmetric switch, also called Fredkin's valve. <img src="https://habrastorage.org/getpro/geektimes/post_images/fd1/edd/d27/fd1eddd274c509176abd79a38dfb9403.png" align="right">  This device has two inputs In <sub>1</sub> , In <sub>2</sub> , two outputs Out <sub>1</sub> , Out <sub>2</sub> and <nobr>pass</nobr> -through track <nobr>C (Control)</nobr> .  If C is in the ‚Äú0‚Äù position, the inputs and outputs are connected directly: In <sub>1</sub> to Out <sub>1</sub> , In <sub>2</sub> to Out <sub>2</sub> ;  if C is in the ‚Äú1‚Äù position, the inputs and outputs are cross-connected: In <sub>1</sub> with Out <sub>2</sub> , In <sub>2</sub> with Out <sub>1</sub> .  Most likely, the spin symmetric switches can be implemented in a single-molecular version, combining maximum compactness, speed and efficiency. <br><br>  Both transistors and symmetric switches can be used to make logic circuits of any complexity, but symmetric switches are much more economical.  For example, to clone a signal and the logical operations ‚Äúnot‚Äù, ‚Äúand‚Äù, ‚Äúor‚Äù, ‚Äúand not‚Äù and ‚Äúshould‚Äù, only one symmetric switch is required, ‚Äúexclusive or‚Äù, ‚Äúnot or‚Äù and ‚Äúnot and‚Äù require two switches.  To implement these operations on transistors, from 4 to 6 transistors are required: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/0bd/ef9/31a/0bdef931a084447c16bf9dc30869310a.png"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/0e5/30a/397/0e530a3974f9724299d35d78d49e7ae9.png" align="right">  A fast one-digit adder (half adder) uses four symmetric switches (instead of 12 transistors) and ideally provides a significantly higher speed of operation than a transistor analog: its operating time is only 2œÑ, where œÑ is the signal passing time of one switch and one track.  On more complex circuits, the compactness and speed gain of symmetric switches are even more pronounced.  The multi-bit adder link (full adder) consists of dozens of transistors, while the implementation on symmetric switches requires from 4 (the most compact version) to 7 (the fastest option) switches: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/53e/77b/9f5/53e77b9f52e562fa8e36e5ce77c8842d.png"><img src="https://habrastorage.org/getpro/geektimes/post_images/955/a54/d32/955a54d3244948187be575a01dc17686.png"><br><br>  A unique feature of symmetric switches is that they help to achieve maximum compactness and speed of operation of multiplexers and demultiplexers, which are very common constituent elements of processors.  Unfortunately, symmetric switches become attractive only when using spintronics or photon logic.  Electronics is doomed to use conventional transistors. <br><br>  * The paragraph used materials and images from articles by <em>Bruce, Thornton et al.</em>  , <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.20.6518">‚ÄúEfficient Adder Circuits Based on a Conservative Reversible Logic‚Äù</a> (Mississippi State University, Proc. IEEE Symposium on VLSI, 2002);  <em>Rentergem, de Vos</em> , <a href="http://research.cs.queensu.ca/home/akl/cisc879/papers/PAPERS_FROM_UNCONVENTIONAL_COMPUTING/VOLUME_1_Issue_4/RENTERGEM.pdf">‚ÄúOptimal Design of A Reversible Full Adder‚Äù</a> (Universiteit Gent, International Journal of Unconventional Computing, 2005), as well as private correspondence.  The image of the unmolecular transistor is taken from the corresponding press release on the website of Yale University. <br><br>  <b>¬ß 2.3.</b>  <b>Conclusion</b> <br>  So, in the limit, the central processor of the future is likely to be a huge web, where the threads are made of graphene tape, conducting a polarized electron flow, and in the nodes there are miniature symmetric switches.  At long distances, the signal will be recoded to light, delivered by photons and recoded back to the destination.  A number of special tasks (in particular, search and sorting) will be performed by quantum conveyors and automata. <br><br><h3>  Part 3. The architecture of central processing units today and in the future. </h3>  All central processors common today are the Von Neumann architecture registered machines: <br>  - the processor contains a certain number (for example, 16) of numbered memory cells (for example, 64 bits each), which are called operational registers; <br>  - the processor is to process the contents of the registers in accordance with the program; <br>  - the program is a sequence of instructions, for example: <br>  - take values ‚Äã‚Äãfrom registers No. 2 and No. 5 and record their sum in register No. 8; <br>  - read in register No. 4 the value from the external memory cell with the address from register No. 6; <br>  - send the number from register No. 12 to the external device NNN; <br>  - the data and the programs themselves are stored in RAM, while the instructions of the programs are encoded with numbers and recorded in successive memory cells; <br>  - the number of the cell, the instruction from which is being executed at the moment, is stored in a special register called the Instruction Pointer, which at the end of the execution is moved to the next memory cell. <br><br>  For more than half a century since the emergence of this architecture, dozens of alternative arivetekture organizations for sequential execution have been proposed, but all of them are inferior to it in the performance ceiling.  The performance ceiling is determined (due to the finiteness of the speed of light) by the linear dimensions of the critical part of the structure, and it is the classical register architecture that ensures the maximum locality of the computation from all the currently proposed sequential execution architectures.  Accordingly, it is precisely this architecture that will preserve, apparently, in the <nobr>future -</nobr> at least a few more decades. <br><br>  <b>¬ß 3.1.</b>  <b>Functional logical units</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/3db/fb7/48e/3dbfb748e803fad4f5e3fcf5539c751b.gif" align="right">  The switches and tracks described in the first part are the ‚Äúraw materials‚Äù for the production of functional logical units, such as an adder, multiplier, multiplexer and demultiplexer.  Multiplexers and demultiplexers are devices that are similar to the sorting stations on the railway (see the illustration to the right).  The input of the multiplexer receives <i>n</i> numbers ( <i>a</i> <sub>1</sub> .. <i>a <sub>n</sub></i> ) and the control number <i>m</i> .  The output is a number <i>a <sub>m</sub></i> , that is, the <nobr><i>m</i> -th</nobr> of <i>n</i> <nobr>input</nobr> numbers.  The demultiplexer is a mirror analogue of the multiplexer: it transmits the incoming signal to the <nobr><i>m</i> -th</nobr> out of <i>n</i> outputs. <br><img src="https://habrastorage.org/getpro/habr/post_images/27f/0dc/7b4/27f0dc7b4e014912e04bc545c5508014.jpg"><br><br>  The task of the adder is to add the numbers supplied to it.  The input of the <nobr><i>n-</i> bit</nobr> adder receives two numbers <i>a</i> and <i>b</i> for <i>n</i> bits plus a one-bit number <i>c</i> (0 or 1).  The adder adds the incoming numbers and gives the result <nobr>( <i>a</i> + <i>b</i> + <i>s</i> )</nobr> .  This is an <nobr>( <i>n</i> + 1) -bit</nobr> number. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/bbe/0b8/b68/bbe0b8b68e88d7e6c2a25bcd921d3e1d.jpg"><br><br>  Functional-logical units do not immediately respond to changes in the arguments: the signal needs to go all the way from the beginning of the circuit to its end, taking into account the delays caused by passing through the switches and possible cycles in the circuit.  For each functional logical unit in the design time is calculated.  An extensive theory of designing functional-logical units with a minimum operation time has been developed.  So, the simplest multi-digit adder that performs addition according to the image and similarity of addition to a column on paper requires for the operation time that grows linearly with the digit capacity.  In the 1960s, accelerated transfer schemes were developed, reducing growth to logarithmic.  The adder using them on symmetric switches is guaranteed to calculate the result for ‚åà3 + log <sub>2</sub> (digit capacity) ¬∑ œÑ, which is the theoretical speed limit.  In the case of a 64-bit adder, a 15-fold acceleration is achieved, compared to a naive implementation.  And the ingenious optimization of multiplication, division, calculation of trigonometric functions makes it possible sometimes to achieve acceleration hundreds of times. <br><br>  <b>¬ß 3.2.</b>  <b>Operating units</b> <br>  An operation <nobr>unit is</nobr> a device that can perform instructions of a single <nobr>type ‚Äî</nobr> for example, addition and subtraction.  The basic element of the operating <nobr>unit is a</nobr> memory cell (the so-called instruction register) into which the instruction to be executed is written.  Upon execution of the instruction, the unit clears this cell.  The rest of the operational unit consists of a set of interconnected logical-unit instructions with each other and with the register.  For example, consider an operating unit capable of performing instructions of the form ‚Äúadd up values ‚Äã‚Äãfrom registers <nobr>No. 2</nobr> and <nobr>No. 5</nobr> and write the amount into register <nobr>No. 8.</nobr> " <br>  We will need: <br>  - the instruction register in which the summation operation code and the numbers of the operand registers are stored (2, 5 and 8 in the above command); <br>  - adder; <br>  - two multiplexers connected to the block of registers on the one hand and the inputs of the adder on the other: they select from the registers those two whose numbers are stored in the register instructions ( <nobr>No. 2</nobr> and <nobr>No. 5</nobr> ) and serves the contents to the inputs of the adder; <br>  - one demultiplexer that supplies the output of the adder to the inputs of the register in which it should be saved. <br><br>  In modern processors, operating units can perform more than one action.  For example, a block may contain, in addition to an adder, a multiplier.  For technical implementation, it is enough to put a multiplier, framed by a demultiplexer and a multiplexer, in parallel with the adder, which choose to carry the signal through an adder or multiplier depending on the operation code stored in the instruction register. <br><br>  <b>¬ß 3.2.1.</b>  <b>Organization of the operating cycle: synchronization, superscalarity, pipelining</b> <br>  The work of the processor is a repetition of the next cycle, during which information passes in a circle ‚Äú <nobr>registers ‚Üí</nobr> operating <nobr>units ‚Üí</nobr> registers‚Äù: <br>  - load the instructions to be executed into the operating units; <br>  - wait for the results; <br>  - save results to registers. <br><br>  There are two approaches to the organization of the processor cycle: synchronous and asynchronous.  In synchronous processors there is a signal conductor.  When it changes (‚Äúthe conductor wavers his wand‚Äù), the values ‚Äã‚Äãissued by the operating units are saved to the registers, and the following instructions are given to the operating units.  In asynchronous processors, there is no common signal conductor, and the operational units themselves report the readiness of the result.  From the moment the task and the operands are ready, the block starts tracking the readiness of the result.  At the end of the calculation, the block gives a go-ahead for saving the result and asks for the next task. <br><br>  Synchronous processors have a fixed clock <nobr>frequency - the</nobr> number of "sweeps of a conductor's stick" per second.  The time between ‚Äúsweeps‚Äù has to be chosen on the basis of the most pessimistic scenario.  However, in practice, in the overwhelming majority of cases, the operation takes several times less time.  Three factors affect the execution speed: <br>  - the initial state of the operational block: if the instruction or part of the arguments is loaded in advance, part of the block comes to the desired state in advance; <br>  - operand values: for example, multiplying short numbers takes a lot less time than multiplying long ones; <br>  - background noise level: at a processor temperature of <nobr>20 ¬∞ C,</nobr> all operations proceed much faster than at a temperature of <nobr>90 ¬∞ C.</nobr> <br><br>  The synchronous approach cannot take into account all these factors;  In addition, the dependence of the noise level on temperature is determined by the concentration of crystal <nobr>defects ‚Äî a</nobr> value that varies from instance to instance and increases as the processor ages.  When calculating the processor clock frequency, one should proceed from the worst, that is, from a worn mediocre specimen operating at a temperature of <nobr>85‚Äì90 ¬∞ C.</nobr>  This fact is used by people who perform the so-called processor overclocking (‚Äúoverclocking‚Äù): successful instances with sufficient cooling continue to work stably with a significant excess of the clock frequency set by the manufacturer. <br><br>  Asynchronous processors begin the next operation as soon as the results of the previous one are ready.  They have no such thing as a clock frequency, and their speed is always the maximum for these conditions: if you put hot coffee on an asynchronous processor, it slows down, if you pour it with liquid <nobr>nitrogen, it</nobr> accelerates.  However, asynchronous circuitry due to its complexity is used today only in a small number of experimental asynchronous processors (starting with <nobr>ILLIAC I</nobr> in 1951 and ending with GA144 in 2010).  In the future, it will probably be used more and more, since there is no other optimization area left. <br><br>  For more than a decade several processors of each type have been installed in processors.  Such processors are called superscalar.  They can perform independent <nobr>actions</nobr> in parallel <nobr>-</nobr> for example, they can follow the instructions <nobr>‚Äúc = a + b‚Äù</nobr> and <nobr>‚Äúd = a ¬∑ b‚Äù</nobr> in parallel.  Another widely used optimization technique is the so-called ‚Äúpipelining‚Äù: the instruction task is written into the operational blocks before the operands are ready, while the multiplexers and demultiplexers have time to arrive in the right state in advance, and the operation time is dramatically reduced.  However, the maximum benefit from the use of pipelining can only be obtained on an asynchronous processor, since synchronous processors provide for the execution of each instruction in advance a fixed number of ‚Äúwands of a conductor's stick‚Äù, and the benefits from the proactive loading of instructions into blocks are relatively small.  If, in addition, separately monitor the readiness of each operand, on an asynchronous processor, you can get a gain in time not only by preloading instructions, but also by earlier readiness of one of the operands.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes the instruction can work in general before all </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operands</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are ready </font><nobr><font style="vertical-align: inherit;">-</font></nobr><font style="vertical-align: inherit;"> for example, if one of the operands is equal to zero, the multiplication will produce zero, without waiting for the second operand to be ready. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only effective way to separately control the availability of </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operands is</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-time use of registers. This term means that during the work of each subprogram, writing to each register occurs only once (the values ‚Äã‚Äãare never overwritten). At the end of the procedure, all used registers are reset back to the empty state. This ensures simplicity of operand readiness check: the operand is ready as soon as the register containing it is non-empty. A straightforward implementation of separate readiness control requires a huge number of registers, but in practice this is not required: you can emulate a large number of logical registers, in fact, bypassing a small number of hardware registers. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ß 3.3. Control blocks and interrupt block</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The distribution of tasks by operational blocks in accordance with the program recorded in the RAM is handled by the control unit. It loads the program's commands from RAM, decodes them, and, in decoded form, sends free operational blocks to the registers. In addition, it executes transition and branching instructions, that is, it selects one of the program branches depending on the value of some operational register. There can be several control blocks in the processor, which allows you to execute several programs in parallel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUs not only execute programs, but also respond to hardware requests. Hardware </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">request -</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a signal supplied by external devices to dedicated processor inputs. For example, when you click on the mouse button, the processor is asked to handle this event. The processing of hardware requests is done by the interrupt block. When a request arrives, the interrupt block searches for a free control block and sends an order to execute the handler program. If there are no free blocks, he selects one of the blocks and temporarily interrupts the program running in it, redirecting the block to the processing of a hardware request. At the end of processing, the execution of the interrupted program resumes. The interrupt block owes its name to the fact that most of its work consists precisely in the interruption and resumption of program execution. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ß 3.3.1. Control instructions: transitions, calls, branching and loops</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The program is a set of coded instructions located in successive memory cells. If for one reason or another it is not possible to arrange consecutive instructions in consecutive cells, the transition instruction is usually used. Reading this instruction, the control unit writes the address specified in the instruction to the Instruction Pointer. In traditional architectures, the state of the other registers does not change during the transition.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historically, the main use of transition instructions is to call subroutines, but now for this purpose separate call and return instructions are used. The call instruction masks or clears all registers (dumping their values ‚Äã‚Äãinto a dedicated storage) with the exception of the range of registers in which the arguments are located so that the called subroutine runs "from scratch." (Masking works faster than moving values ‚Äã‚Äãto the storage, but can only be implemented on processors using dynamic register renaming.) Subroutines finish their execution with a return instruction that clears the registers used by the subroutine and unmasks or restores the registers removed during the call except for the range in which they are stored subprogram execution results.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A special case is the so-called tail call, that is, a situation where a certain subroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ends with a pair of instructions like "call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and return the result of its execution to a higher level." In this case, when calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g, you</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do not need to save or mask the current registers and the </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> point </font><nobr><font style="vertical-align: inherit;">‚Äî</font></nobr><font style="vertical-align: inherit;"> instead, you can pass to the called subroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that the result should not be returned in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and immediately to a higher level. The tail call differs from the transition described at the very beginning of this paragraph only in that it clearly indicates which registers should be kept and which ones should be discarded during the transition. In the future, the ‚Äútail-call‚Äù transition will replace the traditional transition (without changing the values ‚Äã‚Äãof the operating registers), since the traditional transition interferes with asynchronous execution and one-time use of registers, and the transition- ‚Äútail call‚Äù does not. (Actually, the return instruction is a special case of the ‚Äútail-call‚Äù transition, but the discussion of this beautiful concept is beyond the scope of this text.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to calls and transitions, control blocks execute branch instructions, that is, choices of a program branch depending on the value of one of the operational registers. Traditionally, branching is performed using conditional branch instructions, but on asynchronous processors, instead of the traditional transition operation, it is much better to use conditional call instructions or conditional tail calls. An instruction of this kind indicates the table in which it is written, which subroutine to call depending on the value of one of the operational registers. With the help of conditional (tail) call instructions, you can effectively implement constructions of the form </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-then-else</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">match-case</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, conditional recursion and, accordingly, all possible types of cycles. No additional execution control is required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequently, there is a lot of free computing resources on the approach to the branch point and most of the arguments for the called subroutines are ready, but the value that determines which of the subroutines should eventually be called is not ready. In this case, one can speculatively start performing one or several of the most probable procedures, avoiding only operations that affect the ‚Äúoutside world‚Äù: storing any values ‚Äã‚Äãin the shared RAM, accessing external devices and returning from the procedure. This optimization technique in many situations can provide more than a twofold increase in productivity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example branching:</font></font><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (a &lt;&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: { print <span class="hljs-string"><span class="hljs-string">"a and b are equal"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: { print <span class="hljs-string"><span class="hljs-string">"a is greater than b"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: { print <span class="hljs-string"><span class="hljs-string">"b is greater than a"</span></span> } }</code> </pre>  The most frequent special case of <nobr>branching is</nobr> binary <nobr>if-then-else</nobr> branching: <pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { do_this } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { do_that }</code> </pre>  ‚â° <pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (condition) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span>: { do_this } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span>: { do that } }</code> </pre>  Recursion example: <pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcd</span></span></span></span>(a, b) = { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gcd(b, a % b) <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br><br>  <b>¬ß 3.4.</b>  <b>Conclusion</b> <br>  Apparently, the architecture of the central processors will remain von Neumann.  Increased productivity will be provided by better parallelization of instructions and switching to asynchronous circuitry.  To ensure the best parallelizability, you will need to switch to more advanced <nobr>instruction</nobr> sets <nobr>‚Äî</nobr> in particular, one-time-use registers. <br><br>  Modern processors use from 1 to 16 control units and from 4 to 64 operation units.  In the transition to asynchronous circuitry, it will be justified to use several dozen control units and several hundred operating units.  Such a transition, together with a corresponding increase in the number of blocks, will provide an increase in peak performance of more than two orders of magnitude and an average performance of more than an order of magnitude. <br><br><h3>  Part 4. ‚ÜÅ‚Ö†‚Ö© wanted! </h3>  In 1962, Donald Knuth began writing the famous book series The Art of Programming, which describes efficient algorithms and analyzes their speed.  To preserve the ability to describe low-level algorithms and accurately estimate the time of their execution, he decided not to use high-level programming languages, but to write in assembler.  However, architectures and assemblers of real processors are filled with bizarre technical features that distract from the <nobr>essence -</nobr> at that time they were the results of the necessary engineering compromises and technical tricks; today their main source is the requirement of backward compatibility with older models.  In order not to overload the reader with unnecessary and quickly obsolete details and to preserve the universality of the presentation, Knut decided to develop his own computer architecture designed specifically for learning.  This architecture is called MIX. <br><br>  Over the next three decades, major changes have occurred in the field of computer technology, and MIX is largely outdated.  In order for ‚ÄúThe Art of Programming‚Äù to remain an up-to-date source, the author decided to develop, together with leading industrial developers of <nobr>MMIX</nobr> processors <nobr>, a</nobr> new fictional computer that is an idealized and improved analogue of computers from the second half of the 1990s.  MMIX is a deeply thought-out architecture, suitable for immediate hardware implementation and noticeably more advanced than all the processor architectures that are widely used today. <br><br>  The desire to make a machine that can be effectively implemented ‚Äúin hardware‚Äù by the tools of the late 1990s prevented us from making sufficient groundwork for the <nobr>future -</nobr> unfortunately, the MMIX instruction set is practically unsuitable for realizing the potential of asynchronous superscalar processors.  The fact is that the organization of calls in MMIX is based on the use of traditional transitions and requires register rewriting.  For practical research of promising programming techniques, it is necessary to rework this set of instructions in accordance with the inevitable trends in the development of central <nobr>processing units</nobr> described above <nobr>-</nobr> fortunately, this is not such a difficult task. </div><p>Source: <a href="https://habr.com/ru/post/114579/">https://habr.com/ru/post/114579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114573/index.html">My view of trees in PHP</a></li>
<li><a href="../114574/index.html">Yandex.Money: direct payment from the card</a></li>
<li><a href="../114576/index.html">Notes on the Python object system part 1</a></li>
<li><a href="../114577/index.html">Facebook announced an "interactive" security policy</a></li>
<li><a href="../114578/index.html">American 2.5 years to pay bills defunct Internet girlfriend</a></li>
<li><a href="../114580/index.html">A simple click of a button</a></li>
<li><a href="../114581/index.html">STOR.E ART4: with USB 3.0 and beyond</a></li>
<li><a href="../114582/index.html">Desire HD, Desire Z, Desire and Incredible S will get Gingerbread in the second quarter</a></li>
<li><a href="../114583/index.html">Microsoft has allowed employees to make money on applications for Windows Phone 7</a></li>
<li><a href="../114585/index.html">Notes on the Python object system part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>