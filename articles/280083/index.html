<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices. How to do and when to apply?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author: Vyacheslav Mikhailov 

 Monolithic applications and their problems 



 Everyone knows what a monolithic application is: we all did such t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservices. How to do and when to apply?</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/5b4/9ff/abe/5b49ffabe6294acf8dba34d3a41fb15a.png"></p><br><br><p>  <em>The author: Vyacheslav Mikhailov</em> </p><br><br><h2>  Monolithic applications and their problems </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  Everyone knows what a monolithic application is: we all did such two- or three-layer applications with a classical architecture: </p><br><br><p><img src="https://habrastorage.org/files/ed6/51f/d2b/ed651fd2b3d44ec0a30afe3d5785c77b.png"></p><br><br><p>  For small and simple applications, this architecture works fine, but, let's say, you want to improve the application by adding new services and logic to it.  Perhaps you even have another application that works with the same data (for example, a mobile client), then the architecture of the application will change a bit: </p><br><br><p><img src="https://habrastorage.org/files/caf/20e/42d/caf20e42d2da4794885959a3693418a5.png"></p><br><br><p>  Anyway, as your application grows and grows, you encounter problems with monolithic architectures: </p><br><br><ul><li>  the complexity of the system is constantly growing; </li><li>  support it more and more difficult; </li><li>  It is difficult to understand it - especially if the system passed from generation to generation, the logic was forgotten, people left and came, but there were no comments and tests); </li><li>  many errors; </li><li>  few tests - the monolith cannot be disassembled or tested, so usually there are only UI tests whose support usually takes a lot of time; </li><li>  expensive to make changes; </li><li>  getting stuck on technologies (for example, I worked in a company where, since 2003, technologies have not changed yet). </li></ul><br><br><p>  Sooner or later you realize that you can no longer do anything with your monolithic system.  The customer, of course, is disappointed: he does not understand why adding the simplest function requires several weeks of development, and then stabilization, testing, etc. Surely, many are familiar with these problems. </p><br><a name="habracut"></a><br><br><h2>  System development </h2><br><br><p>  Suppose that you somehow managed to avoid the above problems and still cope with your system, but you probably need to develop and scale it, especially if it brings serious money to the company.  How to do it? </p><br><br><h3>  Three scaling dimensions </h3><br><br><p>  In the book ‚ÄúThe Art of Scalability‚Äù there is a concept ‚Äúscale cube‚Äù - from the book ‚ÄúThe Art of Scalability‚Äù.  For this cube, we see that there are three orthogonal ways to increase application performance: sharding, mirrorring, and microservices. </p><br><br><p><img src="https://habrastorage.org/files/718/b27/e0b/718b27e0b5bd473b98066496471c36ae.png"></p><br><br><ol><li>  <strong>Sharding</strong> ("sharding", "splitting") - the location of the same type, but different data on different nodes.  Those who have worked with NoSQL databases know what it is.  You have a sharding key, by which you determine that, for example, the data on A and B is stored on one node, on C and D on another node, etc. Thus, using an intelligent load balancer, you can distribute it across your system and achieve better performance. </li><li>  <strong>Mirroring</strong> - horizontal duplication or cloning of all data when you put absolutely identical hosts nearby.  So you completely copy the data.  It is necessary, first of all, for the system to respond to requests with any expected response time. </li><li>  <strong>Microservices</strong> (microservices) - you break down functionality by business task.  Each service will perform specific tasks.  This is the microservice approach, which we will analyze here. </li></ol><br><br><h3>  CAP theorem </h3><br><br><p>  Generally speaking, if we want to develop the system, we will have to solve the following questions: </p><br><br><ul><li>  How to make the system accessible from different regions? </li><li>  Assuming the system is distributed, how to ensure data consistency? </li><li>  And how can this also speed up the system N times? </li></ul><br><br><p>  These questions lead us to the CAP theorem formulated by Brewer in 2000. </p><br><br><p><img src="https://habrastorage.org/files/70d/c65/846/70dc65846e3144e5a51ed776ed79633c.png"></p><br><br><p>  The theorem is that, theoretically, you cannot provide the system with <strong>both</strong> consistency (availability), and availability (partitioning).  Therefore, one has to sacrifice one of the three properties in favor of the other two.  Just as when choosing from ‚Äúfast, cheap and high quality‚Äù you have to choose only two options.  Now consider the various options that we have according to the CAP theorem. </p><br><br><p>  <strong>CA - consistency + availability</strong> </p><br><br><p>  In this situation, the data in all nodes we have agreed and available.  Availability here means that you guarantee a response for a predictable time.  This time is not necessarily short (it may be a minute or more), but we guarantee it.  Alas, while we sacrifice the division into sections - we can not deploy 300 such hosts and distribute all users to these hosts.  So the system will not work, because there will be no transaction consistency. </p><br><br><p>  A striking example of CA is ACID transactions that are present in classic monoliths. </p><br><br><p>  <strong>CP - consistency + partitioning</strong> </p><br><br><p>  The next option is when data in all nodes are matched and distributed into independent sections.  At the same time, we are ready to sacrifice the time required to coordinate all transactions - the response will be very long.  This means that if two users consistently request the same data, it is not known how long the data for the second user will be consistent. </p><br><br><p>  This behavior is typical for those monoliths that had to scale, despite the antiquity. </p><br><br><p>  <strong>AP - availability + partitioning</strong> </p><br><br><p>  The last option is when the system is available with a predictable response time and is distributed.  At the same time, we will have to abandon the integrity of the result - our data is no longer consistent at any given time, and outdated ones (from microseconds to days) appear among them.  But, in fact, we always operate on old data.  Even if you have a three-tier monolithic architecture with a web application, when the web server gave you a packet with the data that you displayed to the user, they are already out of date.  After all, you in no way know if someone else came at that moment and did not change this data.  So that the data we have agreed upon (ultimately consistent) is normal.  ‚ÄúAgreed in the long run‚Äù means that if an external influence ceases to influence the system, it will come to an agreed state. </p><br><br><p>  A vivid example is classic DNS systems that are synchronized with a delay of up to days (at least, earlier). </p><br><br><p>  Now, having familiarized with the theory of CAP, we understand how we can develop the system so that it is fast, accessible and distributed.  No way!  You have to choose only two of the three properties. </p><br><br><h2>  Microservice architecture </h2><br><br><p>  What to choose?  To make the right choice, you need, first of all, to think about why all this is needed - you need to clearly understand the business objectives.  After all, the decision in favor of microservices is a very crucial step.  The fact is that in microservices everything is much more complicated than usual, that is, we can face the following situation: </p><br><br><p>  You can't just take and cut everything into some pieces and say that these are now microservices.  Otherwise, you will have a very hard time. </p><br><br><h3>  Microservices &amp; SOA </h3><br><br><p>  And now let's talk a little more about theory.  You all know perfectly well what SOA is - a service-oriented architecture.  And then you probably have a question, how does SOA relate to microservice architecture?  After all, it would seem, SOA is the same, but it is not quite so.  In fact, microservice architecture is a special case of SOA: </p><br><br><p><img src="https://habrastorage.org/files/5a1/edb/4ed/5a1edb4ed4234bff8826ba92b4540369.png"></p><br><br><p>  In other words, microservice architecture is just a set of more stringent rules and agreements on how to write all the same SOA services. </p><br><br><h3>  What are microservices? </h3><br><br><p>  This is an architectural template in which services: </p><br><br><ol><li>  small </li><li>  focused </li><li>  loosely coupled </li><li>  highly coordinated (highly cohesive). </li></ol><br><br><p>  Now we will analyze these concepts separately. </p><br><br><p>  What does ‚Äú <strong>small</strong> ‚Äù service mean?  This means that a service in the microservice architecture cannot be developed by more than one team.  Usually one team develops about 5 - 6 services.  In this case, each service solves one business problem, and one person is able to understand it.  If not able, the time to cut the service.  Because if one person is able to support the entire business logic of one service, he will build a really effective solution.  After all, it happens that often, when making decisions in the process of writing code, people simply do not understand what they are doing - they do not know how the system behaves in general.  And if the service is small, everything is much easier.  By the way, we can use this approach separately, even without following the microservice architecture as a whole. </p><br><br><p>  What does ‚Äú <strong>focused</strong> ‚Äù service mean?  This means that the service solves only one business problem, and solves it well.  Such a service makes sense apart from other services.  In other words, you can put it on the Internet by adding a security wrapper, and it will be useful for people. </p><br><br><p>  What is a ‚Äú <strong>loosely coupled</strong> ‚Äù service?  This is when changing one service does not require changes in another.  You are connected via interfaces, you have a solution through DI and IoC - this is now a standard practice, which must be applied.  Usually, developers know why :) </p><br><br><p>  What is a ‚Äú <strong>highly consistent</strong> ‚Äù service?  This means that a class or component contains all the necessary methods for solving the problem.  However, the question often arises here, how does high cohesion differ from SRP?  Suppose we have a class in charge of kitchen management.  In the case of SRP, this class only works with the kitchen and nothing else, but it may not contain all the methods for managing the kitchen.  In the case of high consistency, all methods for kitchen management are contained only in this class, and nowhere else.  This is an important distinction. </p><br><br><h3>  Characteristics of microservices </h3><br><br><ul><li>  Division into components (services). </li><li>  Grouping by business tasks. </li><li>  Services have business meaning. </li><li>  Smart services and simple communications. </li><li>  Decentralized management. </li><li>  Decentralized data management. </li><li>  Automate deployment and monitoring. </li><li>  Design for failure (Chaos Monkey). </li></ul><br><br><h4>  Division into components (services) </h4><br><br><p>  Components are of two kinds: libraries and services that interact over a network.  Martin Fowler defines components as independently replaceable and independently deployable.  That is, if you can take something and calmly replace it with a new version, this is a component.  And if something is connected with another and cannot be independently replaced (contracts, assemblies, versions ... must be taken into account) - together they form one component.  If something cannot be deployed independently, and logic is needed from somewhere else, this is also not a component. </p><br><br><h4>  Grouping by business tasks (services have business meaning) </h4><br><br><p>  Here is the standard monolith layout: </p><br><br><p><img src="https://habrastorage.org/files/01d/c95/df2/01dc95df272440099ba1c5f1882ddb23.png"></p><br><br><p> To increase the efficiency of development, you also often have to divide the teams and teams: there is a team that deals with the UI, there is a team that deals with the core, and there is a team that understands the database. </p><br><br><p>  If you go to the microservice architecture, services and teams are divided by business objectives: </p><br><br><p><img src="https://habrastorage.org/files/5a0/779/69c/5a077969c3e34c0a92355b395e2d112a.png"></p><br><br><p>  For example, there may be a group that deals with order management - it can process transactions, make reports on them, etc. Such a group will deal with the corresponding databases and the corresponding logic, and maybe even the UI.  However, in my experience, UI could not be sawn yet - it had to be left monolithic.  Maybe we can do this in the future, then be sure to tell the others how you achieved it.  Be that as it may, even if the UI remains monolithic, it is still much better when the rest is broken down into components.  Nevertheless, I repeat, it is very important to understand WHY you do it - otherwise one day you will have to redo everything back. </p><br><br><h4>  Smart services and simple communications </h4><br><br><p>  There are different options for the interaction of services.  It happens that they take a very smart bus that knows about routing, and about business rules (for example, some BizTalk), and ready-made objects arrive at the services.  Then it turns out a very smart middleware and stupid endpoints.  This is, in fact, anti-pattern.  As time has shown (by the example of the same Internet), we have a very simple and unpretentious data transmission environment - she absolutely does not care what you transmit, she does not know anything about your business.  All the brains are sitting in the services.  It is important to understand.  If you put everything in the transmission medium, you will have a smart monolith and stupid database wrapper services. </p><br><br><h4>  Decentralized storage </h4><br><br><p>  From the point of view of service-oriented architectures and, in particular, microservices, decentralized storage is a very important point.  Decentralized storage means that each service has its own and only its own database.  The only case where different services can use the same repository is if these services are exact copies of each other.  Databases do not interact with each other: </p><br><br><p><img src="https://habrastorage.org/files/152/de5/708/152de5708aaf4a22bb2416d73a128d06.png"></p><br><br><p>  The only interaction option is networking between services: </p><br><br><p><img src="https://habrastorage.org/files/bb9/397/309/bb939730945d42cb87cea5235db3ffc5.png"></p><br><br><p>  Middleware here may be different - we'll talk more about this.  The discovery of services and the interaction between them can occur simply directly, through an RPC call, and maybe through some ESB. </p><br><br><h4>  Automate deployment and monitoring </h4><br><br><p>  Automation of deployment and monitoring is something without which the microservice architecture is better not even fit.  T. h. You must be willing to invest in this and hire a DevOps engineer.  You will definitely need automatic deployment, continuous integration and delivery.  Also, you will need continuous monitoring, otherwise you just can not keep track of all the numerous services, and everything will turn into some kind of hell.  It is useful to use all sorts of useful things that help centralize logging - you can not write them, because there are good ready-made solutions like ELK or Amazon CloudWatch. </p><br><br><h4>  Design for Failure (Chaos Monkey) </h4><br><br><p>  From the very first stage, starting to build a microservice architecture, you should proceed from the assumption that your services do not work.  In other words, your service should understand that it can never be answered if it expects some data.  Thus, you should immediately start from the situation that something may not work for you. </p><br><br><p>  For example, for this, Netflix developed Chaos Monkey, a tool that breaks services, randomly turns them off and tears up connections.  This one needs to evaluate the reliability of the system. </p><br><br><h3>  How will services interact with each other? </h3><br><br><p>  Take the example of a simple application.  The pictures below, I took from <a href="https://www.nginx.com/blog/author/crichardson/">Chris Richardson</a> 's <a href="https://www.nginx.com/blog/author/crichardson/">blog</a> on NGINX - it tells in detail what microservices are. </p><br><br><p>  So, let's say we have some kind of client (not necessarily even a UI th), which, in order to provide someone with the necessary data, interacts with a set of other services. </p><br><br><p><img src="https://habrastorage.org/files/a4d/fc0/45a/a4dfc045aef64a40a4f0a24b55444460.png"></p><br><br><p>  It would seem that everything is simple - the client can apply to all these services.  But in reality, this translates into the fact that the client configuration becomes very large.  Therefore, there is a very simple Gateway API template: </p><br><br><p><img src="https://habrastorage.org/files/c1c/25b/aaa/c1c25baaab0747f998e656b74f5b3c70.png"></p><br><br><p>  API Gateway is the first thing to consider when you are doing a microservice architecture.  If you have a number of services in the backend, set a simple service for them, whose task is to collect business calls to the target services.  Then you will be able to implement a mapping of transport (transport will not necessarily be a REST API, as in the picture, but in any way).  API Gateway provides data in the form in which it is needed specifically for this type of users.  For example, if there is a web and mobile application, you will have two API Gateway, which will collect data from the services and provide them a little differently.  In no case should API Gateway contain any serious business logic, otherwise this logic would be duplicated everywhere, and it would be difficult to maintain.  API Gateway only transfers data, that's all. </p><br><br><h3>  Different types of microservice architecture </h3><br><br><p>  So, let's say we have a UI, API Gateway and a dozen services behind it, but this is not enough - you can't build a normal application.  After all, usually services are somehow interconnected.  I see three ways to link services: </p><br><br><ul><li>  Service Discovery (RPC Style) - services know about each other and communicate directly. </li><li>  Message Bus (Event-driven) - if you use the ‚Äúpublisher-subscriber‚Äù template and neither the ‚Äúsubscriber‚Äù knows those who subscribe to it, nor the ‚Äúpublisher‚Äù does not know where the content comes from.  They are only interested in content of a certain type - they subscribe to messages.  This is called a message-driven or event-driven architecture. </li><li>  Hybrid - a mixed version, when for some cases we use RPC, and for others - the message bus. </li></ul><br><br><h3>  Service Discovery </h3><br><br><h4>  Service Discovery (RPC Style) </h4><br><br><p>  Here is the simplest version of Service Discovery: </p><br><br><p><img src="https://habrastorage.org/files/7c3/c4b/5af/7c3c4b5afde543e98ff27605df56113e.png"></p><br><br><p>  Here we have a customer who accesses various services.  However, if the address of a particular service is sewn up in the client's configuration, we will be tied hand and foot, because we may want to redefine everything, or there may be another instance of the service.  And here Server-Side Service Discovery will help us. </p><br><br><h4>  Server-Side Service Discovery </h4><br><br><p>  With Server-Side Service Discovery, your client does not interact directly with a specific service, but with a load balancer (load balancer): </p><br><br><p><img src="https://habrastorage.org/files/985/411/f79/985411f799904eed96b78b70ac850120.png"></p><br><br><p>  There is a lot of load balancer: Amazon, Azure, etc. have it. Based on its own rules, Load balancer decides who to give the call to if there are more than one service and it is not clear where the service is located. </p><br><br><p>  There is another additional service, the service registry, which also comes in different types, depending on who registers, how and where.  You can make the service registry register all types of services.  Load balancer takes all the data from the service registry.  Thus, the load balancer task is simply to take the location of services from the service registry and scatter requests to them.  And the task of the service registry is to store the registration data of the services, and he does it differently: he can interrogate services himself, take data from an external config, etc. The space for maneuvers here seems very broad. </p><br><br><h4>  Client-Side Service Discovery </h4><br><br><p>  Client-Side Service Discovery is another, radically different way to interact. </p><br><br><p><img src="https://habrastorage.org/files/42c/2ef/ad4/42c2efad48c3479b8fb57b67a1861036.png"></p><br><br><p>  There is no load balancer, and the service refers directly to the service registry, from where the service address is taken.  What is better?  The fact that one request less - so everything works faster.  This approach is better than the previous one - but provided that you have a trust system in which the client is internal and will not use the information that it takes from services, to the detriment (for example, for DDoS). </p><br><br><p>  In general, in Service Discovery, everything is quite simple - quite known technologies are used.  However, here comes the difficulty - how to implement a more or less serious business process?  Still, services with this approach are too closely connected, although we solve the problem from the point of view of deployment and scaling.  Service instance A knows that you need to go to the service instance B for data, and if tomorrow you change half of the application and the service instance B function is performed by another service, you will have to rewrite a lot. </p><br><br><p>  In addition, when a transactional situation arises and you need to coordinate the actions of several services, you will need a broker (additional service), which should coordinate everything. </p><br><br><h3>  Message bus </h3><br><br><p>  Message Bus needs to be able to cook and really need to know what it is.  Message Bus is used for well-defined tasks, for example, do not need to make request ‚Äì reply requests by Message Bus or transfer large amounts of data.  The Message Bus (and, in principle, the Publish / Subscribe pattern) breaks suppliers and consumers of information: suppliers do not know who needs information, and consumers do not know where it comes from - one information could theoretically have different suppliers and consumers. </p><br><br><p>  And, no matter how hard you try, in such a system you should have an additional network call - to the broker who collects messages, and another call when these messages need to be delivered.  In my experience, transferring large amounts of data (for example, megabytes) via the Message Bus is not worth it.  Message Bus - command pattern;  it is needed so that one service can inform the other that something has changed in it so that other services can react to it. </p><br><br><p>  In such a situation, a hybrid architecture would help us a lot.  Then you take and throw a message on the Message Bus that some data has changed.  After that, the subscribers respond to this data, go to the registry, pick up the sender's place where they need to go for the data, and go directly.  So you save a lot and unload your tire. </p><br><br><h3>  Message Bus: Pros and Cons </h3><br><br><p><img src="https://habrastorage.org/files/e44/786/5df/e447865df03542e5a457f82a57479f72.png"></p><br><br><p>  Advantages of Message Bus: </p><br><br><ul><li>  Message Bus determines what your architecture will be. </li><li>  It allows you to easily add services, because some services do not know about others. </li><li>  Message Bus was originally designed so that all systems can be mapped. </li><li>  When you come to the client and say that you will have an ESB, it just sounds cool. </li><li>  There are ready-made solutions that were not written by you ‚Äî such code should not be maintained, and it works well. </li></ul><br><br><p>  Disadvantages of Message Bus: </p><br><br><ul><li>  Since the Message Bus dictates the architecture, it also dictates the contracts: you must describe the message contracts that you will use.  Therefore, contracts are difficult to change, they need to be versioned.  You can use various extensible contract mechanisms like ProtoBuf, which allows you to do this conveniently ‚Äî extended messages are read by previous versions at the expense of a convenient format. </li><li>  Usually asynchronous interactions.  To work with them correctly, </li><li>  need to have good qualifications. </li><li>  You add another element to the deployment infrastructure ‚Äî another risk zone appears.  Here you need special knowledge from DevOps-engineer. </li></ul><br><br><h2>  Event Driven Architecture - Event Driven Architecture </h2><br><br><p>  When our services interact in the RPC style, everything is clear: we have a service that connects all business logic, collects data from other services and returns them, but what about the event-driven architecture?  We do not know where to go - we only have messages. </p><br><br><p>  Due to the fact that services work only with their own repositories, we often have a situation when changes in one service require changes in another.  For example, we have an order, and we need to check the limits stored in another service (customer service): </p><br><br><p><img src="https://habrastorage.org/files/600/d17/1c1/600d171c17204b918227787e40b3b16e.png"></p><br><br><p>  This problem has two solutions. </p><br><br><h3>  Solution 1 </h3><br><br><p>  When you initiate the order creation process, send an entity creation message to the bus: </p><br><br><p><img src="https://habrastorage.org/files/8f9/acb/c13/8f9acbc13b8142318257626ea7bfacc4.png"></p><br><br><p>  A service that is interested in these events subscribes to them and gets an identification: </p><br><br><p><img src="https://habrastorage.org/files/372/468/653/3724686539d14c73a08fbe2975a0a233.png"></p><br><br><p>  Then he performs some kind of internal action and returns the answer, which then arrives in the service of orders, to the bus: </p><br><br><p><img src="https://habrastorage.org/files/6f0/ce5/314/6f0ce5314d7744f6a626b8d1ffe1cbad.png"></p><br><br><p>  All this is called eventual consistency.  This is not happening atomically, but due to the technology of guaranteed delivery of the Message Bus.  At the same time, the interaction of services with the bus is transactional, and the bus ensures the delivery of all messages.  Therefore, we can be sure that in the end everything will fly to our services (unless, of course, we decide to clear the broker‚Äôs messages via the administration console). </p><br><br><p>  If the standard model is called ACID, such a transactional model is called <strong>BASE -</strong> Basically Available, Soft state, Eventual consistency, which can be interpreted like this: the state you end up with is called ‚Äúsoft state‚Äù because you are not completely sure that condition is really relevant. </p><br><br><h3>  Solution 2 </h3><br><br><p>  There is a second way.  It may turn out that you do not want to make decisions in this system (or you cannot, due to some requirements) send a message to another service each time, because the response time here will be great.  In such a situation, a service that owns certain information ‚Äî on a credit limit, as in our example ‚Äî at the time of changing the credit limit notifies all concerned that the information on this client has changed.  The service that needs to check the credit limit is checked and retained by itself the projection of the necessary data, that is, only those fields that it needs.  Of course, this will be a duplicate of data, but will allow the service not to go anywhere when the order is received. </p><br><br><p>  Here final consistency works again: you can get an order, check its credit limit and consider it as completed.  But since at this moment the credit limit could have changed, it may turn out that it does not correspond to the order, and you will have to build compensation blocks - write additional code that will react to such abnormal situations.  This is the whole complexity of service architectures - you need to understand in advance that the data with which you operate may be outdated, which can lead to incorrect actions. </p><br><br><p>  There is also a third, very serious approach - <strong>Event Sourcing</strong> .  This is a big topic that requires a separate discussion.  In Event Sourcing, you do not store the state of objects - you build them in real time, but only store changes of objects (in fact, users' intentions to change something).  Suppose something is happening in the UI, for example, a user wants to place an order.  Then you save not a change in the order, not a new state, but separately save external requests: from the user, from other services and from anywhere.  Why do you need it?  This is necessary for the situation of compensation - then you can roll back the state of the system and act differently. </p><br><br><p>  In general, the Message Bus is a very big topic, within which a lot can be said about the coordination of events.  For example, we can mention Saga - a small workflow, which is now being implemented, at least, by NServiceBus and MassTransit.  Saga is essentially a state machine that responds to external changes, thanks to which you know what is happening with the system.  In this case, from any state you can make a compensation block.  T. h. Saga is a good tool for implementing ultimate consistency. </p><br><br><h2>  Transition from monolith to microservices </h2><br><br><p>  Now I want to talk about how to move from a monolith to microservices, if you decide that this is really what you need.  So, you have a big monolith.  How now to divide it into parts? </p><br><br><p>  You take out something limited by business logic (what is called a limited context in DDD).  Of course, this will have to understand the monolith.  For example, a good candidate for a separate service is a part of a monolith, which requires frequent changes.  Thanks to this, you get an immediate benefit from the service allocation - you don't have to test the monolith often.  It is also good to single out in a separate service what delivers the most problems and does not work well. </p><br><br><p>  When you divide a monolith into services, pay attention to how your teams are structured.  After all, there is the Conway's law of empirical law, which says that the structure of your application repeats the structure of your organization.  If your organization is built on technological hierarchies, it will be very difficult to build a microservice architecture.  Therefore, you need to select feature-teams that will have all the necessary skills to write the necessary logic from beginning to end. </p><br><br><p>  In fact, it rarely happens that we have a clean microservice architecture.  Most often we have a cross between a monolith and microservices.  Usually there is some big historical code, and we gradually try to untangle it and separate parts from it. </p><br><br><p>  If we are doing a project from scratch, you need to choose - a monolith or microservices? </p><br><br><p>  Monolith is better to choose in the following cases: </p><br><br><ol><li>  If you have a new domain and / or no knowledge in this domain .. </li><li>  If you make a prototype or a quick solution. </li><li>  If the team is not very qualified (all beginners, for example). </li><li>  If you just need to write code and forget about it. </li><li>  If there is not enough money for the project, microservices will be expensive. </li></ol><br><br><p>  It is better to choose microservices if: </p><br><br><ol><li>  Accurately need linear scaling. </li><li>  You understand the business domain, you can highlight a limited context, and you can ensure consistency at the business level. </li><li>  The team is highly qualified, there is experience and a pair of ruined projects with microservices in the past (all the same, microservices do not work out the first time). </li><li>  Long-term cooperation with the customer. </li><li>  Enough funds to invest in infrastructure. </li></ol><br><br><h3>  Microservices: ‚Äúfor‚Äù and ‚Äúagainst‚Äù </h3><br><br><p>  Benefits: </p><br><br><p>  The microservice approach can be applied even if you do not use the Message Bus, and microservices will be logical.  Indeed, from the point of view of deployment, diversity is possible here.     .NET,          .       ,       .    ,       . </p><br><br><ol><li> <strong>  </strong> .     ‚Äî     ,   ,       .       . </li><li> <strong> </strong> .      ‚Äî      . </li><li> <strong> </strong> ,     . ,     ,    ,           .        - ,       , . .     . </li><li> <strong> </strong> -   :    ,     . </li></ol><br><br><p>  Disadvantages: </p><br><br><ol><li> <strong> .</strong> </li><li> <strong> </strong> ‚Äî         .      .     ‚Äî  ,       . -      ,        ‚Äî        . </li><li> <strong>  </strong> ‚Äî   DevOps-,     .       . </li></ol><br><br><h2>        </h2><br><br><p>  ,         , , ZooKeeper,      .      Logstash, Kibana, Elastic, Serilog, Amazon Cloud Watch.      . </p><br><br><p>    ?     .    ,   - -.   ‚Äî   -.  ,    ‚Äî ,   ,     .  ‚Äî   .   ‚Äî  ,  ,       .         ,  .   ‚Äî   ,  ,    .      Swagger,    . </p><br><br><h2>    (Amazon CEO) </h2><br><br><p>          ‚Äî Amazon. </p><br><br><p>    ,   2000 .  ,  Amazon,        : </p><br><br><ul><li> All teams will henceforth expose their data and functionality through service interfaces. </li><li> Teams must communicate with each other through these interfaces. <br><ul><li> no direct linking </li><li> no direct reads of another team's data store </li><li> no shared-memory model </li><li> no back-doors whatsoever. </li></ul><br></li><li> The only communication allowed is via service interface calls over the network. </li><li> It doesn't matter what technology they use. </li><li> All service interfaces, without exception, must be designed from the ground up to be externalizable. </li><li> No exceptions. </li></ul><br><br><p> ,   : ¬´       .  (   ‚Äî    )     :     ,     . . ‚Äî       . </p><br><br><p>  ,      ,      .    ,      .     .  ,        ‚Äî    Amazon       AWS. </p><br><br><p>  Sources </p><br><ul><li> <a href="https://www.nginx.com/blog/">https://www.nginx.com/blog/</a> </li><li> <a href="https://www.nginx.com/blog/introduction-to-microservices/">https://www.nginx.com/blog/introduction-to-microservices/</a> </li><li> <a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">https://www.nginx.com/blog/building-microservices-inter-process-communication/</a> </li><li> <a href="http://plainoldobjects.com/presentations/decomposing-applications-for-deployability-and-scalability/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://plainoldobjects.com/presentations/decomposing-applications-for-deployability-and-scalability/</font></font></a> </li><li> <a href="http://highscalability.com/blog/2016/2/10/how-to-build-your-property-management-system-integration-usi.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://highscalability.com/blog/2016/2/10/how-to-build-your-property-management-system-integration-usi.html</font></font></a> </li><li> <a href="https://lostechies.com/gabrielschenker/2016/01/27/service-discovery/%26nbsp%3B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://lostechies.com/gabrielschenker/2016/01/27/service-discovery/</font></font></a> </li><li> <a href="http://microservices.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://microservices.io/</font></font></a> </li><li> <a href="http://martinfowler.com/articles/microservices.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://martinfowler.com/articles/microservices.html</font></font></a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/280083/">https://habr.com/ru/post/280083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280073/index.html">Damn! Cloud computers! Choosing a thin client for Parallels VDI</a></li>
<li><a href="../280075/index.html">Java "var" keyword: please, not this</a></li>
<li><a href="../280077/index.html">Oracle SPARC T7 and M7 Servers - A New Platform for Secure Computing</a></li>
<li><a href="../280079/index.html">Time to learn: Digest of free educational materials from Mail.Ru Group</a></li>
<li><a href="../280081/index.html">Sorting tables in Cach√© DBMS</a></li>
<li><a href="../280085/index.html">Windows Trojan specializes in stealing data from isolated air-gapped computers</a></li>
<li><a href="../280087/index.html">Superscalar stack processor: details</a></li>
<li><a href="../280089/index.html">Conference DUMP-2016: Review of the Web-design section</a></li>
<li><a href="../280091/index.html">Who are the most famous hackers in history?</a></li>
<li><a href="../280093/index.html">25 questions asked during an interview with Linux system administrators</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>