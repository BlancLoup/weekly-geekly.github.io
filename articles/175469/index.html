<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Firefox: private tabs, various APIs and extensions that do not require restarting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I‚Äôll talk about my expansion of Private Tab for Firefox and SeaMonkey: some implementation details - and specifically this, and extensions that do not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Firefox: private tabs, various APIs and extensions that do not require restarting</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/57d/ce3/0ab/57dce30ab72d70a39a5eb11d7577f0e0.png" alt="Private tab extension"><br>  I‚Äôll talk about my expansion of <a href="https://addons.mozilla.org/addon/private-tab/">Private Tab</a> for Firefox and SeaMonkey: some implementation details - and specifically this, and extensions that do not require restarting (aka <a href="https://addons.mozilla.org/tag/restartless">restartless</a> ), in general. <br><br>  The extension adds private tabs for which history will not be saved and a separate set of cookies will be used. <br><br>  Unfortunately, attempts to write in a simple way lead to numerous distractions from the main topic, so that the output was a kind of hodgepodge on the subject of writing extensions.  On the other hand, completely without distractions it will be clear only to those for whom all this is no longer necessary. <br>  Somewhat messy, but in a logical order.  I hope so clearer. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perhaps, we should start with the fact that the extension is just an add-on above the windowed window added to Gecko 20 (or how can we translate per-window?) Private mode. <br>  Without these internal changes, nothing would have happened. <br>  And there were a lot of changes: ‚Äú <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D463027" title="(PBnGen) Implement per-window Private Browsing">Bug 463027</a> <a href="https://bugzilla.mozilla.org/showdependencytree.cgi%3Fid%3D463027%26hide_resolved%3D0">depends on 1646 bugs</a> ‚Äù. <br>  Fortunately, although we received only private windows, a lot of things were done inside based on the possibility of changing not only the entire window‚Äôs privacy, but also individual tabs (well, the contents of the individual tabs). <br><br>  This is if you understand the person.  In general, if you can not describe something in your own words, you should question the understanding.  So, although the entrails were promised (blood, guts, and so on), but I will start with something simple and (hopefully) accessible. <br><br>  A simple and understandable thing is that the <a href="">nsILoadContext</a> interface (undocumented, hehe - in the sense that there is only source code with comments) is associated with each window *, which now has the property usePrivateBrowsing.  And, most importantly, all other code takes into account the value of this property.  So all the dirty work was done for us (honestly, unfortunately, not all). <br>  * Windows are actually more than it seems: in this case, the <a href="https://developer.mozilla.org/en-US/docs/DOM/window">window</a> object is in mind, well known to all JavaScript programmers.  Each browser window has such an object, inside of which there is at least an equally well-known <a href="https://developer.mozilla.org/en-US/docs/DOM/document">document</a> with a real DOM tree.  And then with each tab is associated <a href="https://developer.mozilla.org/en-US/docs/XUL/browser">XUL browser</a> , very similar to HTML iframe with its own window, document and DOM-tree. <br>  In general, it‚Äôs better to see it once: you can look at this whole structure live using the <a href="https://addons.mozilla.org/addon/dom-inspector-6622/">DOM Inspector</a> 'a (here <a href="https://developer.mozilla.org/en-US/docs/DOM_Inspector/Introduction_to_DOM_Inspector">is some instruction</a> in the pictures, or you can put <a href="https://addons.mozilla.org/addon/custom-buttons/">Custom Buttons</a> and my <a href="https://github.com/Infocatcher/Custom_Buttons/tree/master/Attributes_Inspector">Attributes Inspector</a> button, only for Gecko 20 you need an <a href="http://custombuttons.mozdev.org/devbuilds.html">experimental version of</a> Custom Buttons ). <br>  For example, the XUL browser: <br><img src="https://habrastorage.org/storage2/ce4/52f/e6b/ce452fe6ba4cf0355e8831181aa3316d.png" alt="DOM Inspector"><br><br>  That is, our task is to solicit the nsILoadContext interface from something related to &lt;browser&gt; 'in the tab and switch usePrivateBrowsing to false. <br><br>  Two other interfaces are responsible for begging: <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsISupports">nsISupports.QueryInterface ()</a> and <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIInterfaceRequestor">nsIInterfaceRequestor.getInterface ()</a> . <br>  But in this case, we have already been taken care of, and there is a helpful article <a href="https://developer.mozilla.org/en-US/docs/Supporting_per-window_private_browsing">Supporting per-window private browsing</a> , from which you can learn about the ready-made <a href="">resource</a> <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Using">module</a> <a href="">: //gre/modules/PrivateBrowsingUtils.jsm</a> , in which the method we need is already implemented: <br><pre><code class="javascript hljs">privacyContextFromWindow: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pbu_privacyContextFromWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">aWindow</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aWindow.QueryInterface(Ci.nsIInterfaceRequestor) .getInterface(Ci.nsIWebNavigation) .QueryInterface(Ci.nsILoadContext); },</code> </pre> <br><br>  There is, however, another subtlety: when the value of the usePrivateBrowsing property changes, it writes to the error console <br><blockquote>  Warning: Only use the passwordPrivateBrowsing attribute <br></blockquote><br>  This is <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D800193">Bug 800193 - Make the nsILoadContext.usePrivateBrowsing property read-only</a> .  Fortunately, as a result, so far the matter is limited to this warning. <br><br>  So now we need to get the window object bound to the tab. <br>  Generally, there is <a href="https://developer.mozilla.org/en-US/docs/XUL/tabbrowser">gBrowser.getBrowserForTab (tab)</a> , but we <del>  not looking for easy ways </del>  we want to make a full-fledged restartless extension (there is still a simplified version: connecting a script to each window that will be executed for each window again, it‚Äôs easier as a first approximation to port ‚Äútraditional‚Äù extensions, but it will require more memory), so tab.ownerDocument .defaultView.gBrowser.getBrowserForTab (tab) looks somehow scary.  Moreover, in the view-source: chrome: //browser/content/tabbrowser.xml (this link is such, it opens, of course, only in Firefox) there is only <br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">method</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"getBrowserForTab"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aTab"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> &lt;![CDATA[ return aTab.linkedBrowser; ]]&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">method</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Moreover, this approach is used a lot where, although it seems to be not documented. <br><br>  So now we have (honestly, we don‚Äôt have a tab yet, but more on that later) a link to the <a href="https://developer.mozilla.org/en-US/docs/XUL/browser">XUL browser</a> tab, which, in turn, has a <a href="https://developer.mozilla.org/en-US/docs/XUL/browser">contentWindow</a> property that refers to the DOM window we need in the browser . <br><br>  So it turns out something like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tab = ... <span class="hljs-comment"><span class="hljs-comment">//  ,       Components.utils.import("resource://gre/modules/PrivateBrowsingUtils.jsm"); var privacyContext = PrivateBrowsingUtils.privacyContextFromWindow(tab.linkedBrowser.contentWindow); privacyContext.usePrivateBrowsing = true; //   </span></span></code> </pre><br><br>  Now, when we can find out if a private tab or not and switch the privacy mode for it, let's look at the tabs. <br><br>  To begin, open the private tab. <br>  To open tabs, there is <a href="https://developer.mozilla.org/en-US/docs/XUL/tabbrowser">gBrowser.addTab ()</a> , but there is a subtlety: if you open a tab first and then enable private mode for it, the browser in the tab will have time to be initialized, and although the link will not be saved in your browsing history, cookies will not be used privately. <br>  To understand why this happens, you need to look at the source code: <br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">method</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addTab"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aURI"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aReferrerURI"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aCharset"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aPostData"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aOwner"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parameter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aAllowThirdPartyFixup"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> &lt;![CDATA[ ... // Dispatch a new tab notification. We do this once we're // entirely done, so that things are in a consistent state // even if the event listener opens or closes tabs. var evt = document.createEvent("Events"); evt.initEvent("TabOpen", true, false); t.dispatchEvent(evt); if (uriIsNotAboutBlank) { ... try { b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData); } catch (ex) { Cu.reportError(ex); } }</code> </pre><br>  Fortunately, not only the reason is visible (start of loading by b.loadURIWithFlags ()), but also the solution: you can use the generated <a href="https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/TabOpen">TabOpen</a> event - the notification comes just before the start of the download. <br>  And here the code is not as transparent as we would like.  The basic idea is: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"TabOpen"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForTab</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.removeEventListener(e.type, waitForTab, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tab = e.originalTarget; <span class="hljs-comment"><span class="hljs-comment">// e.target     SeaMonkey makeTabPrivate(tab); }, false); gBrowser.selectedTab = gBrowser.addTab(); //    </span></span></code> </pre><br>  At the same time, <a href="https://developer.mozilla.org/en-US/docs/DOM/event.originalTarget">event.originalTarget</a> differs from <a href="https://developer.mozilla.org/en-US/docs/DOM/event.target">event.target</a> only in that, unlike the latter, it can refer to anonymous nodes created using <a href="https://developer.mozilla.org/en-US/docs/XBL">XBL</a> (and in SeaMonkey it‚Äôs just its own <a href="https://developer.mozilla.org/en-US/docs/XUL/tabbrowser">&lt;tabbrowser&gt;</a> implementation). <br><br>  Well, now we have a lonely private tab. <br>  It needs to be visually separated from others.  To do this, I add the tab attribute privateTab-isPrivate = "true" and change its appearance styles. <br>  It is important to note here that potential collisions with other extensions should be avoided - all you need to do is to add to all classes, attributes and other entities a distinctive prefix, in this case ‚ÄúprivateTab-‚Äù. <br>  In order not to be distracted, briefly about styles: use <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIStyleSheetService">nsIStyleSheetService.loadAndRegisterSheet ()</a> .  At the same time, styles are applied to all windows in general, so it is better to limit them using <a href="https://developer.mozilla.org/en-US/docs/CSS/%40document">@ -moz-document</a> . <br><br>  But from the private tab, you can open a new tab or even a window.  These new tabs and windows should remain private! <br><br>  There are two ways. <br>  The first is to redefine all or some of the functions that open tabs in one way or another.  You can make a wrapper (a good way), and you can apply an eval-patch (there are much more possibilities, but it is more difficult to roll it back later, and this method is not recommended). <br>  In general, with the abolition of patches and wrappers, everything is not so simple: another extension may impose a patch between our switching on and off (we are restartless!).  And if this extension makes an eval-patch, then our wrapper will break it - the code has changed. <br>  Here you can go to the trick: override the toString () and toSource () methods of the wrapper function (that is, to make the wrapper look like a modified original function), then the third-party patch will most likely work fine.  But now we are disconnected and we must return everything as it was.  And it was without a patch!  And, rolling back on the memorized value of the function, we will break all the extensions that have applied their patches after us. <br>  But even here you can cheat: when modifying a function, add to our code a call to our global (relative to the window that owns the function requiring modification) function, then when detecting third-party edits, you can arrange <del>  memory leak </del>  change our global function, which was engaged in modifications, to do nothing.  This is better than breaking the unsuspecting user‚Äôs extensions. <br>  Here is an intricate shamanism with patches.  It sounds incomprehensible, and the <a href="">code is</a> no better. <br>  In the simplest case, it turns out this: <br>  The main code (remembering the original and overriding toString () / toSource () is omitted to demonstrate the essence): <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orig = someObject.someMethod; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> patch = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"privateTabMod::someObject.someMethod"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   -  }; someObject.someMethod = function wrapped() { if(patch.apply(this, arguments)) return undefined; return orig.apply(this, arguments); };</span></span></code> </pre><br>  And yes, it is also important to create global properties in the window with names that can be used elsewhere. <br>  At the same time, toString () / toSource () are redefined and return this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapped</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"privateTabMod::someObject.someMethod"</span></span>].apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  Then, when we need to roll back our patch, we compare the stored modified function with the current value of someObject.someMethod.  If they match, we simply change someObject.someMethod to the memorized original function, and if they differ, we change the window ["privateTabMod :: someObject.someMethod"] to an empty function. <br><br>  Such a long retreat. <br>  And yes, there is nothing fundamentally bad in eval-patches, sometimes there is simply no other way. <br>  But we must understand that when you can do with a wrapper, you need to do with a wrapper.  This is also better optimized by the interpreter, and only third-party code making eval-patches can break it. <br>  Here, of course, it's time to grab your head and run away, waving your arms, but it is better to wait and read this first: <br>  Wladimir Palant <br>  <a href="http://piro.sakura.ne.jp/latest/blosxom/mozilla/xul/2010-02-08_eval-en.htm">Some reasons why I</a> <a href="http://piro.sakura.ne.jp/latest/blosxom/mozilla/extension/2010-04-06_amo-review-and-eval.htm">‚Äôm</a> <a href="http://piro.sakura.ne.jp/latest/blosxom/mozilla/xul/2010-02-08_eval-en.htm">not really dangerous than other hacks</a> and <a href="http://piro.sakura.ne.jp/latest/blosxom/mozilla/xul/2010-02-08_eval-en.htm">why I</a> <a href="http://piro.sakura.ne.jp/latest/blosxom/mozilla/extension/2010-04-06_amo-review-and-eval.htm">‚Äôm using eval () instead of others?</a>  by <a href="https://addons.mozilla.org/user/piro-piro_or/">YUKI "Piro" Hiroshi</a> <br>  In short, wrappers break eval patches (which sometimes can‚Äôt be done without), and neat eval patches do not break either other patches or wrappers.  Yes, it is potentially much more dangerous, but dangerous is not unacceptable at all. <br><br>  And when you can do without patches in general, you must choose this path - it is the least conflicting. <br>  If, of course, there is no desire to then deal with compatibility with a bunch of different extensions.  And after all, not all extensions are equally "straight." <br>  In this case, there is a very simple way, albeit with some not quite logical effects: earlier we already used the listener of the ‚ÄúTabOpen‚Äù event to get the not-yet-initialized tab.  Here you can do the same: when opening a tab, check the privacy of the <a href="https://developer.mozilla.org/en-US/docs/XUL/tabbrowser">current</a> tab, and if it is private, then make a new tab also private. <br><br>  With windows, in general, it is similar (only you need to manually get a replacement for window.opener, because after opening a link in a new window, the opener property is not set) and check the privacy of the active tab of the parent window. <br>  But we still have an extension about tabs, so we can do without details, especially since a couple of words will be said about tracking opening windows in restartless extensions. <br><br>  So, we can already open a private tab and everything that opens from it is also private. <br>  The main work is over, and the pleasant little things begin, from which usability is built.  And sometimes these little things are much more than the main code. <br>  Firstly, there is saving sessions and other restarts.  Tabs should remain private. <br>  For this, there is an <a href="https://developer.mozilla.org/en-US/docs/Mozilla_event_reference/SSTabRestoring">SSTabRestoring</a> event to track the moment of recovery and the <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsISessionStore">nsISStationStore</a> interface, for which we will need the <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsISessionStore">persistTabAttribute ()</a> method. <br>  And then everything is simple: when you restore the tab, you need to check for the presence of the previously installed privateTab-isPrivate attribute.  If it is, make the tab private. <br><br>  This, of course, is far from everything - ‚Äúeverything‚Äù has already stretched over 2100 lines, and there are more trifles than it seems - both changing the title of the window and changing the application button (which is red, App button) if the menu is hidden (the button, however , it changes Firefox itself for the presence of the privatebrowsingmode attribute at the root node of the DOM tree of the main window), and adding items to different menus, handling shortcuts (and the built-in <a href="https://developer.mozilla.org/en-US/docs/XUL/key">XUL key</a> is never restartless), and dragging (you can also pull the link from private tab!), and the impossibility of dragging tabs between the private and  ordinary windows (and here are the patches!), and ... just do not remember. <br>  But we value our time, the time of our readers. <del>  and healthy sleep </del>  .  :) No, we also appreciate the dream, but it does not always remain what to appreciate. <br><br>  Now that we‚Äôve dealt with the tabs (and this can be done without creating an extension using the Custom Buttons extension already mentioned, or using built-in tools, setting <em>devtools.chrome.enabled</em> = true to about: config and launching Web Development ‚Äî Simple JavaScript Editor aka Scratchpad, Shift + F4 - Surroundings - Browser), it's time to thrust the developments into the extension. <br>  But 2100 lines is a bad example.  And because it could be cut into modules (maybe cut, but for now it turns out that cutting leads to a bunch of additional code), and because the minimum of lines needed to just run something simple is lost. <br><br>  So let's take a simpler example: <a href="">Tree Style Tab Tweaker</a> (just in case the link leads to a specific version, otherwise it will also swell over time). <br>  In general, ‚ÄúTweaker‚Äù is too loud.  This is a <a href="https://addons.mozilla.org/addon/tree-style-tab/">Tree Style Tab</a> thing that implements <a href="https://github.com/piroor/treestyletab/issues/384">this</a> ‚Äúfix‚Äù (slightly improved) for <a href="https://github.com/piroor/treestyletab/issues/384">issues # 384</a> .  The bottom line is that when you close parental tabs, the closed tab will be replaced with a dummy tab to save the tab hierarchy. <br><br>  Anyway, it's easier to keep track of the main points. <br>  First, you need the classic <a href="https://developer.mozilla.org/en-US/docs/Install_Manifests">install.rdf</a> , without which nothing will work out, but with the <a href="https://developer.mozilla.org/en-US/docs/Extensions/Bootstrapped_extensions">flag</a> " <a href="">&lt;em: bootstrap&gt; true &lt;/ em: bootstrap&gt;</a> ". <br>  And the <a href="">bootstrap.js</a> file next to install.rdf. <br>  Further, all this is packaged in a regular ZIP-archive, but with the extension xpi.  And that's it!  Well, all is when the necessary code is already written. <br><br>  The bootstrap.js file must necessarily define <a href="https://developer.mozilla.org/en-US/docs/Extensions/Bootstrapped_extensions">special functions</a> that the add-ons manager will invoke when it is turned on, turned off, started up, and so on. <br>  And then the expansion should do everything itself: it should catch windows, and do something with them, and clean up after itself, too. <br>  This, by the way, is very sad, because there is no API for simplifying these manipulations (not yet, I hope). <br><br>  Here, however, a reservation is needed: there is still <a href="https://developer.mozilla.org/en-US/docs/Jetpack">Jetpack aka Add-on SDK</a> .  Why not him?  Personally, it's easier for me.  It‚Äôs much clearer to mess around with more or less familiar interfaces and other APIs than to learn new ones (and, obviously, more limited ones).  There is also a lot of abstractions in the source code, so that you can work normally only through documentation (and sometimes it is late, it's open source).  In addition, something not to see complex extensions on the Jetpack, which also suggests.  But if there is no experience with writing extensions, it‚Äôs probably easier to start with the Add-on SDK. <br><br>  But back to the manipulation. <br>  We will only use the <a href="">startup ()</a> and <a href="">shutdown ()</a> functions. <br>  As you might guess from the name, startup () is called when the extension is launched ‚Äî whether it is launching the browser or setting / enabling, the reason is passed by the second argument. <br><br>  When enabled, there may be already open windows that should be processed.  For this there is <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIWindowMediator">nsIWindowMediator.getEnumerator ()</a> , there is also an <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIWindowMediator">example of use</a> . <br>  <a href="">The result</a> is simple: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//         : Components.utils.import("resource://gre/modules/Services.jsm"); // ... var ws = Services.wm.getEnumerator("navigator:browser"); while(ws.hasMoreElements()) this.initWindow(ws.getNext(), reason);</span></span></code> </pre><br>  The ‚Äúnavigator: browser‚Äù is the value of the <a href="https://developer.mozilla.org/en-US/docs/XUL/window">windowtype</a> attribute of the root node ( <a href="https://developer.mozilla.org/en-US/docs/XUL/window">XUL window</a> ) of the main browser window.  You can see it with the help of the same DOM Inspector. <br>  Accordingly, initWindow () receives a link to the window and the reason for the inclusion. <br><br>  But these are only already open windows - you also need to keep track of the creation of new windows and the closure of existing ones (in order to clean up after themselves and not arrange a flood). <br>  To do this, we use the <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIWindowWatcher">nsIWindowWatcher.registerNotification ()</a> method. <br>  In this case, both the function and the object implementing the <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIObserver">nsIObserver</a> interface can <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIObserver">receive alerts</a> .  The latter is more convenient: we get the correct this, referring to our object-namespace. <br>  Again, use the Services.jsm module: <br><pre> <code class="javascript hljs">Services.ww.registerNotification(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre><br>  Now the <a href="">observe (subject, topic, data)</a> method of our object will receive notifications about opening (‚Äúdomwindowopened‚Äù in the topic) and closing (‚Äúdomwindowclosed‚Äù) windows. <br><br>  However, at the time of receiving the ‚Äúdomwindowopened‚Äù alert, it is impossible to know what kind of window it is - in window.location.href will be about: blank, so you need to wait for the window to load: <br><pre> <code class="javascript hljs">observe: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subject, topic, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(topic == <span class="hljs-string"><span class="hljs-string">"domwindowopened"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// subject -    subject.addEventListener("load", this, false); ...</span></span></code> </pre><br>  Here we will also use the trick to pass the correct this: event listener can be an object that implements the <a href="https://developer.mozilla.org/en-US/docs/DOM/EventListener">EventListener</a> interface, so that when an event occurs, the <a href="">handleEvent (event)</a> method of the transferred object will be called. <br><br>  And you can already find out from the booted window both the location and the same windowtype that we used to go through only the necessary windows. <br><br>  Thus, we handle the <a href="">opening</a> and <a href="">closing of</a> windows with the required windowtype. <br><br>  And then you just need to make the inclusion when opening and cleaning when closing. <br>  In this case, we only need to <a href="">add a</a> listener to the <a href="https://developer.mozilla.org/en-US/docs/Mozilla_event_reference/TabClose">TabClose</a> event: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"TabClose"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  When an event occurs, handleEvent () -&gt; <a href="">tabCloseHandler () will work</a> , but with the tabs we have already worked. <br><br>  Further, when shutting down, deleting, updating or closing the browser, the shutdown () function will be called, and <a href="">windowsObserver.destroy ()</a> will work, with the already familiar to us enumeration of all open windows and disabling alerts. <br><br>  So it's pretty simple.  Difficulties begin when a strange desire arises.  For example, there is also no API for adding custom buttons, so regular <a href="">cycling</a> in each restartless extension is obtained. <br>  The main, perhaps, complexity is that a global object is not a window at all, so either we need to create a window handler (everything is not as bad as it seems at first glance: there are prototypes), or, as done in Private Tab , get the window from the object of the event being processed. <br><br>  Here, perhaps, that's all.  Hopefully this thread without headers can be read.  But the headlines, alas, did not want to be placed in any way, I had to provide the text to myself. </div><p>Source: <a href="https://habr.com/ru/post/175469/">https://habr.com/ru/post/175469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175457/index.html">Admin in 10 minutes</a></li>
<li><a href="../175459/index.html">Data migration from MySQL to PostgreSQL</a></li>
<li><a href="../175461/index.html">How it works: CAPTCHA</a></li>
<li><a href="../175465/index.html">M in MVC: why models are misunderstood and undervalued (translation)</a></li>
<li><a href="../175467/index.html">Intel plans for the release of new processors in 2013</a></li>
<li><a href="../175475/index.html">ActionScript - Yes / No Future?</a></li>
<li><a href="../175479/index.html">How we increase the loyalty of users Surfingbird</a></li>
<li><a href="../175481/index.html">Restrict access to packaged applications</a></li>
<li><a href="../175483/index.html">Codeacademy Announces PHP Learning Course</a></li>
<li><a href="../175485/index.html">Unpredictable but adequate bot in games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>