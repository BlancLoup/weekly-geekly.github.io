<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to update the kernel in the system without restarting the services (step-by-step instruction)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How do you think how realistic it is to log in to ssh, upgrade the system, load the new kernel and still remain in the same ssh session. Now there is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to update the kernel in the system without restarting the services (step-by-step instruction)</h1><div class="post__text post__text-html js-mediator-article">  How do you think how realistic it is to log in to ssh, upgrade the system, load the new kernel and still remain in the same ssh session.  Now there is a trendy movement to update the kernel on the fly (ksplice, KernelCare, ReadyKernel, etc), but this method has many limitations.  First, it does not allow changes to be applied that change the structure of the data.  Secondly, objects in memory may already contain incorrect data, which can cause problems in the future.  A more ‚Äúhonest" way to upgrade the kernel will be described here.  In fact, the method itself has long been known <a href="https://habrahabr.ru/post/160201/">[1]</a> , and the value of this article is that we analyze everything in detail using a real example, understand how simple or difficult it is, and what to expect from such experiments. <br><a name="habracut"></a><br>  <a href="https://travis-ci.org/">Travis CI</a> is one of the popular continuous integration systems that works well with Github.  The service is developing rapidly and if several years ago it provided only containers with not very fresh distributions, then today there is a choice between containers and vmocks, there is support not only for Linux systems and much more. <br><br>  We started using Travis-CI in our <a href="https://criu.org/">CRIU</a> project (checkpoint / restrore in userspace) several years ago and always took the most from the service.  We started with a compilation check on x86_64, and today Travis-CI runs our tests, checks the compilation on all architectures, with different compilers, and even tests compatibility with new kernels, including the most unstable and advanced Linux-Next branch. <br><br>  And the most important thing here is that any of the developers can take advantage of all this for their own purposes and he does not need to tune, crouch, or bounce anything locally. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  And now to the point, gentlemen ... </h2><br>  But today I want to tell at all not about how we test CRIU, but about one interesting variant of its use.  Imagine that at the entrance we have a virtual machine in which a process is started via ssh.  How do we load our core so that the process doesn't notice?  This is exactly the situation that we have in Travis-CI. <br><br>  We do not have external access to the virtual machine, and if the Travis process for some reason dies (ends), the service completes the task and deletes the VM.  Agree, the problem, frankly, not easy.  We even made a vote at the bottom - beep, whether you immediately made a decision or not. <br><br>  But we did the following: we take the CRIU, dump the Travis ssh session, load the new kernel, restore the processes and run on.  Something like this I thought when I decided to have some fun after dinner and show how it all takes off. <br><br>  I must say that the task is by no means abstract.  She has several real uses.  One of them is the desire of some users to download Ubuntu 16.04 ( <a href="https://github.com/travis-ci/travis-ci/issues/5821">https://github.com/travis-ci/travis-ci/issues/5821</a> ).  Travis developers are not going to solve this problem yet, and we can try to do it without their help.  The idea here is the same, we take the initial system 14.04, update it and reboot into a new environment. <br><br><h2>  Decision </h2><br>  Upgrading the system is the lesser of troubles, solved by a couple of commands: <br><br><pre><code class="bash hljs">sed -i -e <span class="hljs-string"><span class="hljs-string">"s/trusty/xenial/g"</span></span> /etc/apt/sources.list apt-get update &amp;&amp; apt-get dist-upgrade -y</code> </pre> <br>  But then it becomes much more fun.  First, a survey arises: where to start dumping?  Secondly, how will we recover?  If something goes wrong, how do we know what exactly?  There‚Äôs no need to wait for help from frozen Travis. <br><br>  So we start to understand on their own.  We look at the process tree and understand that dumping should start with the SSHD process, which handles our SSH session. <br><br>  Process Tree: <br><br><pre> <code class="hljs tex">12253 ?        Ss     0:03 /usr/sbin/sshd -D 32443 ?        Ss     0:00  <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_</span></span></span></span> sshd: root@pts/0 32539 pts/0    Ss     0:00  |   <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_</span></span></span></span> -bash</code> </pre><br>  We go to all parents, starting with ourselves, and take the second sshd process from init: <br><br><pre> <code class="bash hljs">ppid=<span class="hljs-string"><span class="hljs-string">""</span></span> pid=$$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> :; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   p=$(awk <span class="hljs-string"><span class="hljs-string">'/^PPid:/ { print $2 }'</span></span> /proc/<span class="hljs-variable"><span class="hljs-variable">$pid</span></span>/status)   <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ‚Äú<span class="hljs-variable"><span class="hljs-variable">$p</span></span>‚Äù -eq 1 &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>   ppid=<span class="hljs-variable"><span class="hljs-variable">$pid</span></span>   pid=<span class="hljs-variable"><span class="hljs-variable">$p</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$pid</span></span></code> </pre><br>  Now we know who to dump and need to decide who will do this.  It is worth considering that CRIU does not allow ‚Äúsawing the branch on which it sits,‚Äù so it is necessary to create a third-party process: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">setsid</span></span> bash -c <span class="hljs-string"><span class="hljs-string">"setsid ./scripts/travis/kexec-dump.sh </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ppid</span></span></span><span class="hljs-string"> &lt; /dev/null &amp;&gt; /travis.log &amp;"</span></span></code> </pre> <br>  It's time to write a command for the dump.  If you think that it is not difficult, then you are greatly mistaken.  There are so many options in CRIU that not all developers can figure them out right away.  But in fact, everything is not so bad, if you look.  The line of code was quite short. <br><br><pre> <code class="bash hljs">./criu/criu dump -D /imgs -o dump.log -t <span class="hljs-variable"><span class="hljs-variable">$pid</span></span> --tcp-established --ext-unix-sk -v4 --file-locks ‚Äîlink-remap</code> </pre><br>  If you translate it into Russian, this command sounds like this: ‚ÄúCRIU, make us a subtree dump starting from the $ pid process, put all the data in the / imgs directory, save the logs in the dump.log file, tell in detail about everything you do, and We also allow you to save tcp sockets, unix sockets connected to the outside world, file locks and descriptors for remote files. ‚Äù <br><br>  It seems that everything is clear, except for deleted files - where will they come from?  But it suffices to recall that we installed a major update on the system, which means that almost everything has been updated, including the library and the files that are launched.  At the same time, our process was not restarted and still uses the old versions of these files.  It is for them that we specify the option --link-remap. <br><br>  Immediately there is another problem.  Between saving and restoring processes, network traffic must be blocked, otherwise there is no guarantee that TCP connections will survive this operation.  CRIU adds a couple of iptables rules for this, and our task is to restore these rules after booting the new kernel, but before the network is configured.  Here I had to google a bit, but in general, the task was also solved not too difficult. <br><br><pre> <code class="bash hljs">cat &gt; /etc/network/<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>-pre-up.d/iptablesload &lt;&lt; EOF <span class="hljs-comment"><span class="hljs-comment">#!/bin/sh iptables-restore &lt; /etc/iptables.rules unlink /etc/network/if-pre-up.d/iptablesload unlink /etc/iptables.rules exit 0 EOF chmod +x /etc/network/if-pre-up.d/iptablesload iptables-save -c &gt; /etc/iptables.rules</span></span></code> </pre> <br><h2>  Recovery </h2><br>  So, the processes are saved, and it's time to prepare the one who will restore them.  Here we have to write a small service. <br><br><pre> <code class="bash hljs">cat &gt; /lib/systemd/system/crtr.service &lt;&lt; EOF [Unit] Description=Restore a Travis process [Service] Type=idle ExecStart=/root/criu/scripts/travis/kexec-restore.sh <span class="hljs-variable"><span class="hljs-variable">$d</span></span> <span class="hljs-variable"><span class="hljs-variable">$f</span></span> [Install] WantedBy=multi-user.target EOF</code> </pre><br>  Everything seems ready and you can take off.  The key to start. <br><br><pre> <code class="bash hljs">kernel=$(ls /boot/vmlinuz* | tail -n 1 | sed <span class="hljs-string"><span class="hljs-string">'s/.*vmlinuz-\(.*\)/\1/'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$kernel</span></span> kexec -l /boot/vmlinuz-<span class="hljs-variable"><span class="hljs-variable">$kernel</span></span> --initrd=/boot/initrd.img-<span class="hljs-variable"><span class="hljs-variable">$kernel</span></span> --reuse-cmdline</code> </pre><br><h2>  Fly! </h2><br><pre> <code class="bash hljs">kexec -e</code> </pre><br>  So we took off, but, like SpaceX, we could not sit down the first time.  But we could not, because the landing platform was already occupied by someone.  But seriously, the problem is that CRIU allows you to restore processes only with the same identifiers that they had at the time of the dump.  We rebooted into the new system, where the systemd (!!!) and the processes became a bit more.  This problem has long been studied by science, and here we will be helped by containers, more precisely, only their small part, called the process namespace (pid namespace). <br><br><pre> <code class="bash hljs">unshare -pfm --mount-proc --propagation=private ./criu/criu restore \ -D /imgs -o restore.log -j --tcp-established --ext-unix-sk \ -v4 -l --link-remap &amp;</code> </pre><br>  Let's try to take off, and again our ship does not get in touch.  This time there are no ideas about problems, and we need to somehow get logs.  It was decided not to think for a long time, but to take it and pour it on one of the popular storages of various wastes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python2 import dropbox, sys, os access_token = os.getenv("DROPBOX_TOKEN") client = dropbox.client.DropboxClient(access_token) f = open(sys.argv[1]) fname = os.path.basename(sys.argv[1]) response = client.put_file(fname, f) print 'uploaded: ', response print "=====================" print client.share(fname)['url'] print "====================="</span></span></code> </pre><br>  Under the sight of cameras, we lose another ship and we understand that the jokes are over.  This time, a DBus socket is complaining to us, that is, it is a connection whose state is inaccessible to us, because it is owned only by a DBus demon.  On the other hand, why does sshd need this socket?  Surely he wants to monitor the status of the network and other nonsense.  We are not going to do anything like this (or rather, we have already done everything), so let's just restore this socket sometime and go further. <br><br><pre> <code class="diff hljs">diff --git a/criu/sk-unix.cb/criu/sk-unix.c index 5cbe07a..f856552 100644 --- a/criu/sk-unix.c +++ b/criu/sk-unix.c @@ -708,5 +708,4 @@ static int dump_external_sockets(struct unix_sk_desc *peer)                               if (peer-&gt;type != SOCK_DGRAM) {                                       show_one_unix("Ext stream not supported", peer);                                       pr_err("Can't dump half of stream unix connection.\n"); -                                       return -1;                               }</code> </pre><br>  In fact, we made our own CRIU patch.  This could be solved more elegantly with the help of plug-ins, but it was faster this way.  Fill in our changes again and wait for the next drop.  This time there is a problem with pseudo terminals: the numbers we need are already being used by someone.  We could mount devpts with newinstance, but this option has not worked recently. <br><br><blockquote>  - The newinstance mount <br>  Ignored.  // Eric W. Biederman <br></blockquote><br>  It looks like it's time to get into the images of the processes and tweak them a bit with a file.  Let's change the pseudo-terminal numbers in them and add the prefix 1. There was a terminal with the number 1, it would become with the number 11. For this, it is possible in CRIU to reformat the image in Json format and back.  It looks like this: <br><br><pre> <code class="bash hljs">./crit/crit show /imgs/tty-info.img  | \   sed <span class="hljs-string"><span class="hljs-string">'s/"index": \([0-9]*\)/"index": 1\1/'</span></span> | \   ./crit/crit encode &gt; /imgs/tty-info.img.new ./crit/crit show /imgs/reg-files.img  | \   sed <span class="hljs-string"><span class="hljs-string">'s|/dev/pts/\([0-9]*\)|/dev/pts/1\1|'</span></span> | \   ./crit/crit encode &gt; /imgs/reg-files.img.new</code> </pre><br>  Run again and wait.  The time is already long after noon, and this whole undertaking is clearly very much delayed.  Usually we get an error - this time that some fifo files from / run / systemd / sessions cannot be restored.  To understand what kind of files there is, there is no desire, so before restoring, simply create them and run further. <br><br><pre> <code class="bash hljs">f=$(lsof -p <span class="hljs-variable"><span class="hljs-variable">$1</span></span> | grep /run/systemd/sessions | awk <span class="hljs-string"><span class="hljs-string">'{ print $9 }'</span></span>) ... criu dump kexec mkfifo <span class="hljs-variable"><span class="hljs-variable">$f</span></span> criu restore</code> </pre><br>  Again we fall, and this time it seems that we are raiding a bug in CRIU.  We see that sys_prctl (PR_SET_MM, PR_SET_MM_MAP, ...) returns EACCES, crawls into the kernel, and we find that the cause is the restoration of the link to the launched file.  The kernel sees that we are passing a link to a file that does not have a corresponding bit.  You remember that we have updated the entire system, and now this link from the process points to the deleted file.  It turns out that before deleting the file, dpkg removed the right to run it. <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta"># strace -e chmod,link,unlink -f apt-get install --reinstall sudo ... 3331  link(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/bin/sudo"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/bin/sudo.dpkg-tmp"</span></span></span><span class="hljs-meta">) = 0 3331  chmod(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/bin/sudo.dpkg-tmp"</span></span></span><span class="hljs-meta">, 0600) = 0 3331  unlink(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/bin/sudo.dpkg-tmp"</span></span></span><span class="hljs-meta">)  = 0 ...</span></span></code> </pre><br>  It seems to be enough to make another patch to the CRIU, and the golden key will be in our pocket. <br><br><pre> <code class="diff hljs">diff --git a/criu/cr-restore.cb/criu/cr-restore.c index 12f13ae..39277cf 100644 --- a/criu/cr-restore.c +++ b/criu/cr-restore.c @@ -2278,6 +2278,23 @@ static int prepare_mm(pid_t pid, struct task_restore_args *args)       if (exe_fd &lt; 0)               goto out; +       { +               struct stat st; + +               if (fstat(exe_fd, &amp;st)) { +                       pr_perror("Unable to stat a file"); +                       return -1; +               } + +               if (!(st.st_mode &amp; (S_IXUSR | S_IXGRP | S_IXOTH))) { +                       pr_debug("Add the execution bit for %d (st_mode %o)\n", exe_fd, st.st_mode); +                       if (fchmod(exe_fd, st.st_mode | S_IXUSR)) { +                               pr_perror("Unable to add the execution bit"); +                               return -1; +                       } +               } +       } +       args-&gt;fd_exe_link = exe_fd;       ret = 0; out:</code> </pre><br><h2>  Conclusion </h2><br>  Hooray!  Everything works <a href="https://travis-ci.org/avagin/criu/builds/181822758">https://travis-ci.org/avagin/criu/builds/181822758</a> .  In fact, this is a very brief retelling of the whole story.  I had to run this task in Travis 33 times before it was first successful. <br><br>  What have we proved by this?  First, they solved a couple of applied tasks, and second, they showed that CRIU is a very low-level tool and even a simple task may require in-depth knowledge of the system.  But the efforts are compensated by power, flexibility and opportunities.  Although no one guarantees that you do not have to fight with bugs. <br><br>  Good luck on the cosmic expanses! </div><p>Source: <a href="https://habr.com/ru/post/318522/">https://habr.com/ru/post/318522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318510/index.html">Code review in distributed team</a></li>
<li><a href="../318512/index.html">Do sites fall on holidays more often than usual? Myths, reality and how to protect yourself</a></li>
<li><a href="../318514/index.html">Radiant Chinese machine and painting machine to them. Frankenstein</a></li>
<li><a href="../318518/index.html">Kaggle: Allstate Claims Severity</a></li>
<li><a href="../318520/index.html">How I learned not to worry and fell in love with microservices, part 1: The effects of bad code</a></li>
<li><a href="../318524/index.html">Experience in using self-hosted continuous integration systems</a></li>
<li><a href="../318526/index.html">Machine learning as a new business analysis tool</a></li>
<li><a href="../318528/index.html">How the new design of the PVS-Studio code analyzer developers' website viva64.com was made</a></li>
<li><a href="../318530/index.html">Indecent simple maze generation algorithm</a></li>
<li><a href="../318532/index.html">As my fingers turned out, and I collected a bike for deployment, which saved more than 2 thousand working hours per project.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>