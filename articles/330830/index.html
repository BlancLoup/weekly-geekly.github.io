<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android Architecture Components in conjunction with Data Binding</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago for Android developers, Google introduced a new library - Android Architecture Components. It helps to implement an MVx pattern-based ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android Architecture Components in conjunction with Data Binding</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/1d6/8b1/94b/1d68b194b1af4048b9771c37c5ffe204.jpg"></p><br><p>  Not so long ago for Android developers, Google introduced a new library - Android Architecture Components.  It helps to implement an MVx pattern-based architecture (MVP, MVVM etc.) in the application.  In addition, another Google library, the Data Binding Library, has long been released.  It allows you to link the mapping of UI controls directly to the markup with the values ‚Äã‚Äãcontained in the objects.  This is an important feature of the MVVM pattern - to associate the View layer with the ViewModel layer. </p><br><p>  Both libraries are aimed at building the architecture of Android applications in MVVM style. <br>  I'll tell you how you can use them together to create a project with an MVVM-based architecture. </p><br><a name="habracut"></a><br><h2 id="nemnogo-ob-mvvm">  A bit about MVVM </h2><br><p>  The MVVM pattern assumes separation of the application architecture into 3 layers: </p><br><ul><li>  Model is a data layer.  It contains all the business logic of the application, access to the file system, database, system resources and other external services; </li><li>  View - the display layer.  Everything that the user sees and with what can interact.  This layer displays what is presented in the ViewModel layer.  It also sends commands (for example, user actions) for execution to the ViewModel layer; </li><li>  ViewModel - view layer.  It is associated with the View by banding.  Contains the data that is displayed on the View layer.  It is associated with the Model layer and receives data for display from there.  It also handles commands coming from the View layer, thereby changing the Model layer. </li></ul><br><p><img src="https://habrastorage.org/web/95b/e3a/5cd/95be3a5cd27b40ca92589f58967bebde.png" alt="MVVM"><br>  The main interest in the article will be chained to binding.  These are the links for displaying specific View parameters (for example, ‚Äútext‚Äù in a TextView) with specific fields of the ViewModel (for example, the ‚Äúuser name‚Äù field).  They are set in the markup View (in layout), and not in the code.  The ViewModel, in turn, should represent the data in such a way that it can be easily linked with View. </p><br><h2 id="zachem-nam-eto-vse-nado">  Why do we need all this? </h2><br><p>  By itself, the MVVM pattern, like MVP and MVC, allows the code to be divided into independent layers.  The main difference MVVM - in the banding.  That is, in the possibility directly in the markup to link the display of what is visible to the user - the View layer, with the state of the application - the Model layer.  In general, the advantage of MVVM is not to write extra code to associate a view with a display ‚Äî bindings do it for you. </p><br><p>  Google is moving toward supporting the MVVM pattern-based architecture.  Libraries Android Architecture Components (hereinafter AAC) and Data Binding are a direct confirmation of this.  In the future, most likely, this pattern will be used on most Android projects. </p><br><p>  At the moment, the problem is that neither AAC nor Data Binding provides an opportunity to fully implement the MVVM pattern.  AAC implements the ViewModel layer, but banding must be configured manually in code.  Data Binding, in turn, provides the ability to write bindings in the markup and bind them to the code, but the ViewModel layer must be implemented manually in order to propagate the update of the application state through the binding to the View. </p><br><p>  In the end, everything seems to be ready, but divided into two libraries, and in order to make it really look like MVVM, you just need to take and combine them. </p><br><p>  In general, what should be done for this: </p><br><ul><li>  implement the View layer on banding; </li><li>  implement the ViewModel layer based on the LiveData and ViewModel classes from AAC; </li><li>  to connect these two layers with a minimum amount of code; </li><li>  arrange it so that it can be reused in projects. </li></ul><br><p>  We will try to do this on the example of a simple user profile screen. </p><br><h2 id="opisanie-primera">  Example Description </h2><br><p>  There will be three elements on the screen: </p><br><ul><li>  enter / exit button.  The text depends on whether the user is authorized or not; </li><li>  login field.  Shows when the user is not authorized; </li><li>  label with login.  Shows login of authorized user. </li></ul><br><p>  Login will be stored in SharedPreferences.  A user is considered authorized if a login is entered into SharedPreferences. </p><br><p>  For simplicity, third-party frameworks, network requests, and error mapping will not be used. </p><br><h2 id="sloy-view">  View layer </h2><br><p>  I will start with the View layer so that it is clear what the user will see on the screen.  Immediately mark the bindings I need without reference to a specific ViewModel.  How it will all work - it will become clear later. </p><br><p>  Actually, layout: </p><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">import</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"touchin.aacplusdbtest.R"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">import</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.view.View"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  ViewModel  ,      --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">variable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"profileViewModel"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"touchin.aacplusdbtest.ProfileViewModel"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">LinearLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:orientation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"vertical"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--     .  ,     userLogin.  visibility   isUserLoggedIn,        . --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.userLogin}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:visibility</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.isUserLoggedIn ? View.VISIBLE : View.GONE}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   .   ,     inputLogin,   ,     inputLogin  ViewModel     View,   -           inputLogin.  visibility   isUserLoggedIn,         . --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">touchin.aacplusdbtest.views.SafeEditText</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:addTextChangedListener</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.inputLogin}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.inputLogin}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:visibility</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.isUserLoggedIn ? View.GONE : View.VISIBLE}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  /.     isUserLoggedIn:   "",   ,  "" -   .             isUserLoggedIn:   logout  login. --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"wrap_content"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{profileViewModel.isUserLoggedIn ? R.string.logout : R.string.login}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{(v)-&gt; profileViewModel.loginOrLogout()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">LinearLayout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="klass-livedata">  Class livedata </h2><br><p>  Before implementing the Model layer, you need to deal with the LiveData class from AAC.  We need it to notify the ViewModel layer about changes to the Model layer. </p><br><p>  <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html">LiveData</a> is a class whose objects deliver data and update it to subscribers.  It is an implementation of the Observer pattern.  You can subscribe to LiveData, and LiveData itself implements internally how it will calculate and update data for subscribers. </p><br><p>  The feature of LiveData is that it can be tied to a lifecycle object and activated only when such an object is in the started state.  This is convenient for updating the View layer: as long as the activation or fragment is in the started state, this means that they have initialized the entire UI and need the actual data.  LiveData responds to this and is activated - it calculates the current value and notifies subscribers about the updated data. </p><br><h2 id="sloy-model">  Layer Model </h2><br><p>  From the Model layer, we need the following functionality: the login (String login), logout () methods and the ability to track the current login of an authorized user based on LiveData. </p><br><p>  Add the ProfileRepository class, which will be responsible for the user authorization logic: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ProfileRepository(context: Context) { private val loginKey = "login" private val preferences = context.getSharedPreferences("prefs", Context.MODE_PRIVATE) // LiveData,     //      private val innerLoggedInUser = LoggedInUserLiveData() val loggedInUser: LiveData&lt;String?&gt; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = innerLoggedInUser fun <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>: String) { preferences.edit().putString(loginKey, <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>).apply() notifyAboutUpdate(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>) } fun logout() { preferences.edit().putString(loginKey, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>).apply() notifyAboutUpdate(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) } private fun notifyAboutUpdate(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>: String?) { innerLoggedInUser.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>) } private <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> LoggedInUserLiveData : LiveData&lt;String?&gt;() { //      ,      //     onActive.     init { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = preferences.getString(loginKey, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) } // postValue    UI- // ,     ,       //     UI-    setValue fun <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>: String?) { postValue(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>) } } }</code> </pre> <br><p>  Place this object in Application to make it easier to access it, having Context: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AacPlusDbTestApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> profileRepository: ProfileRepository <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() profileRepository = ProfileRepository(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre> <br><h2 id="klass-viewmodel">  ViewModel class </h2><br><p>  Before implementing the ViewModel layer, you need to deal with the main class from AAC, which is used for this. </p><br><p>  <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a> is a class representing objects of the ViewModel layer.  An object of this type can be created from anywhere in the application.  In this class there should always be either a default constructor ( <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a> class), or a constructor with a parameter of type Application ( <a href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html">AndroidViewModel</a> class). </p><br><p>  To request a ViewModel by type, call: </p><br><pre> <code class="hljs pgsql"> mvm = ViewModelProviders.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(fragmentOrActivity).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(MyViewModel::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java)</code> </pre> <br><p>  Or by key: </p><br><pre> <code class="hljs pgsql"> mvm1 = ViewModelProviders.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(fragmentOrActivity).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("keyVM1", MyViewModel::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java) mvm2 = ViewModelProviders.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(fragmentOrActivity).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("keyVM2", MyViewModel::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java)</code> </pre> <br><p>  ViewModel is stored separately for each activation and for each fragment.  The first request, they are created and placed for storage in the activation or fragment.  Upon repeated request, the already created ViewModel is returned.  The uniqueness of a specific ViewModel is its type or string key + where it is stored. </p><br><p>  ViewModel and AndroidViewModel are created by default through reflection - the corresponding constructor is called.  So, when adding your constructors, in the ViewModelProviders.of (...) method you need to explicitly specify the factory for creating such objects. </p><br><h2 id="sloy-viewmodel">  ViewModel Layer </h2><br><p>  From ProfileViewModel we need the following: </p><br><ul><li>  the loginOrLogout method, which will represent the user's login or logout command, depending on whether the user is authorized; </li><li>  a variable isUserLoggedIn value that will represent the state whether the user is authorized; </li><li>  variable value loggedInUser, which will represent the login of the current authorized user; </li><li>  variable value inputLogin, which will represent what the user entered on the screen in the login field. </li></ul><br><p>  Create a ProfileViewModel and associate it with the ProfileRepository: </p><br><pre> <code class="hljs pgsql">//   AndroidViewModel,    ProfileRepository  Application <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ProfileViewModel(application: Application) : AndroidViewModel(application) { private val profileRepository: ProfileRepository = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AacPlusDbTestApp).profileRepository //  Transformations ‚Äî  -    //  map,         -     String?  <span class="hljs-type"><span class="hljs-type">boolean</span></span> val isUserLoggedInLiveData = Transformations.map(profileRepository.loggedInUser) { <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } // LiveData      val loggedInUserLiveData = profileRepository.loggedInUser //  ,     // TextField -  ObservableField,   TextWatcher //  ,      <span class="hljs-type"><span class="hljs-type">text</span></span>  addTextChangedListener, //     . //     EditText  ViewModel,   ViewModel ‚Äî  EditText. val inputLogin = TextField() fun loginOrLogout() { //     -      ,   isUserLoggedInLiveData.observeForever(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Observer&lt;<span class="hljs-type"><span class="hljs-type">Boolean</span></span>&gt; { override fun onChanged(loggedIn: <span class="hljs-type"><span class="hljs-type">Boolean</span></span>?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loggedIn!!) { profileRepository.logout() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inputLogin.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //      -     profileRepository.<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>(inputLogin.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //  ,     " " } //       isUserLoggedInLiveData.removeObserver(this) } }) } }</code> </pre> <br><p>  Now, when calling the loginOrLogout method in ProfileRepository, LoginLiveData will be updated and these updates can be displayed on the View layer by subscribing to LiveData from ProfileViewModel. </p><br><p>  But LiveData and ViewModel are not yet adapted for binding, so this code cannot be used yet. </p><br><h2 id="adaptaciya-viewmodel-pod-data-binding">  Adapt ViewModel to Data Binding </h2><br><p>  With access to the ViewModel from the markup, there are no special problems.  We declare it in the markup: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">variable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"profileViewModel"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"touchin.test.ProfileViewModel"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  And set in activit or fragment: </p><br><pre> <code class="hljs pgsql">//   LifecycleActivity,       LiveData. // LiveData  ,       started. <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ProfileActivity : LifecycleActivity() { lateinit private var binding: ActivityProfileBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //   binding = DataBindingUtil.setContentView&lt;ActivityProfileBinding&gt;(this, R.layout.activity_profile) //  ViewModel   binding.profileViewModel = ViewModelProviders.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(this).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(ProfileViewModel::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java) } }</code> </pre> <br><h2 id="adaptaciya-livedata-pod-data-binding">  Adapt LiveData to Data Binding </h2><br><p>  I decided to adapt LiveData based on the <a href="https://developer.android.com/reference/android/databinding/ObservableField.html">ObservableField</a> class.  It allows you to bind a changing value of an arbitrary type to a specific view property. </p><br><p>  In my example, it will be necessary to add visibility of the view to whether the user is authorized or not.  As well as the text property to the user login. </p><br><p>  ObservableField has two methods - addOnPropertyChangedCallback and removeOnPropertyChangedCallback.  These methods are called when binding is added and removed from the view. <br>  In essence, these methods are those moments when you need to subscribe and unsubscribe from LiveData: </p><br><pre> <code class="hljs pgsql">//   ObservableField //  Observer (  LiveData)    LiveData  ObservableField <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> LiveDataField&lt;T&gt;(val source: LiveData&lt;T?&gt;) : ObservableField&lt;T&gt;(), Observer&lt;T?&gt; { //      ObservableField private var observersCount: AtomicInteger = AtomicInteger(<span class="hljs-number"><span class="hljs-number">0</span></span>) override fun addOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) { super.addOnPropertyChangedCallback(callback) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (observersCount.incrementAndGet() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { //   LiveData,   ObservableField   <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> source.observeForever(this) } } override fun onChanged(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T?) = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) override fun removeOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) { super.removeOnPropertyChangedCallback(callback) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (observersCount.decrementAndGet() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //   LiveData,   <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>   ObservableField source.removeObserver(this) } } }</code> </pre> <br><p>  To subscribe to LiveData, I used the observeForever method.  It does not transmit a lifecycle object and activates LiveData regardless of the state in which the activity is or the fragment on which the view is located. </p><br><p>  In principle, from the OnPropertyChangedCallback object, you can get a view, from view - context, context lead to LifecycleActivity and bind LiveData to this activity.  Then it will be possible to use the observe (lifecycleObject, observer) method.  Then LiveData will be activated only when the activation on which the view is located is in the started state. </p><br><p>  This hack will look like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleLiveDataField</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: LiveData&lt;T?&gt;) : ObservableField&lt;T&gt;(), Observer&lt;T?&gt; { ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnPropertyChangedCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnPropertyChangedCallback</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.addOnPropertyChangedCallback(callback) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  , -  val callbackListenerField = callback.javaClass.getDeclaredField("mListener") callbackListenerField.setAccessible(true) val callbackListener = callbackListenerField.get(callback) as WeakReference&lt;ViewDataBinding&gt; val activity = callbackListener.get()!!.root!!.context as LifecycleActivity if (observersCount.incrementAndGet() == 1) { source.observe(activity, this) } } catch (bindingThrowable: Throwable) { Log.e("BINDING", bindingThrowable.message) } } ... }</span></span></code> </pre> <br><p>  Now we change the ProfileViewModel so that it can be easily reached: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProfileViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">application</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AndroidViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">application</span></span></span><span class="hljs-class">) { ... //      null val userLogin = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LifecycleLiveDataField</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loggedInUserLiveData</span></span></span><span class="hljs-class">) //     val isUserLoggedIn = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LifecycleLiveDataField</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isUserLoggedInLiveData</span></span></span><span class="hljs-class">) ... }</span></span></code> </pre> <br><p>  <strong>Important!</strong>  During testing, there was one unpleasant flaw in the Data Binding library - the attached views do not call the removeOnPropertyChangedCallback method even when the activation dies.  This causes the Model layer to hold references to objects on the View layer through the ViewModel layer.  In general, a memory leak from LiveDataField objects. </p><br><p>  To avoid this, you can use another hack and manually reset all banding on onDestroy activations: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LifecycleActivity</span></span></span></span>() { ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() <span class="hljs-comment"><span class="hljs-comment">//   profileViewModel binding.profileViewModel = null //     , //         onDestroy :( binding.executePendingBindings() } }</span></span></code> </pre> <br><p>  In addition, attentive readers might notice in the markup class SafeEditText.  In general, it was needed, because of the bug in the Data Binding Library.  The bottom line is that it adds text to the listener via addTextChangedListener even if this listener is null. <br>  Since at the onDestroy stage I nullify the model, first the null-listener is added to EditText, and then the text is updated, which also becomes null.  As a result, NPE crash occurred on onDestroy when trying to inform the null listener that the text had become null. </p><br><p>  In general, when using Data Binding, be prepared for such bugs - there are quite a few of them. </p><br><h2 id="ne-idealno-no-poluchilos">  Not perfect, but it worked </h2><br><p>  In general, with some difficulties, hacks and some disappointments, but it turned out to link AAC and Data Binding.  Most likely, in the near future (year 2?) Google will add some features to link them - the same analogue of my LiveDataField.  So far, AAC is in alpha, so much there can still change. </p><br><p>  The main problems at the moment, in my opinion, are related to the Data Binding library - it is not adapted to work with the ViewModel and there are unpleasant bugs in it.  This is clearly seen from the hacks that had to be used in the article. </p><br><p>  First, when bundling, it is difficult to get an activation or fragment to get the LifecycleObject required for LiveData.  This problem can be solved: either we take it out through reflection, or we simply observeforever, which will keep the subscription to LiveData, until we manually reset the baydings to onDestroy. </p><br><p>  Secondly, Data Binding assumes that ObservableField and other Observable objects live in the same life cycle as the view.  In fact, these objects are part of the ViewModel layer, which has a different life cycle.  For example, in AAC, this layer is going through activations coups, and Data Binding does not update the banding after a coup of activations - all views for it have died, which means that all Observable objects also died and there is no point in updating anything.  This problem can be solved by zeroing manually on the onDestroy.  But this requires unnecessary code and the need to ensure that all bandings are reset to zero. </p><br><p>  Thirdly, there is a problem with the objects of the View layer without an explicit life cycle, for example, the ViewHolder adapter for RecyclerView.  They do not have a clear call onDestroy, as they are reused.  At what point it is hard to say unambiguously zeroing the binding in the ViewHolder. </p><br><p>  I would not say that at the moment a bunch of these libraries look good, although you can use it.  Should you use this approach in view of the shortcomings described above - you decide. </p><br><p>  An example from the article can be found <a href="https://github.com/TouchInstinct/Android-Architecture-Components-Data-Binding">on the Touch Instinct githab</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330830/">https://habr.com/ru/post/330830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330820/index.html">Support for Deep Learning Researchers</a></li>
<li><a href="../330822/index.html">RESTForms - REST API for your InterSystems Cach√© classes</a></li>
<li><a href="../330824/index.html">Understanding the jungle of programming, or why was Mowgli friends with Python?</a></li>
<li><a href="../330826/index.html">Dark patterns - how malicious interfaces try to attack and deceive</a></li>
<li><a href="../330828/index.html">Adaptation of Xamarin.Forms to the development of corporate and B2E applications</a></li>
<li><a href="../330832/index.html">Two years with Dart: how we write in a language that is ‚Äúburied‚Äù every year (part 1)</a></li>
<li><a href="../330834/index.html">Design as a world language of the 21st century</a></li>
<li><a href="../330836/index.html">Technology and non-IT: how and why S / 4HANA is used in wholesale</a></li>
<li><a href="../330838/index.html">Attention, Habrahabr: IBM opens free access to a large number of its resources</a></li>
<li><a href="../330840/index.html">SQL Server Integration Services (SSIS) for Beginners - Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>