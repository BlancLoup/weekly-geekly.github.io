<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>VR application from scratch on libgdx: part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtual reality is rapidly gaining popularity among users, but still remains inaccessible to many developers. The reason is trivial - many people writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>VR application from scratch on libgdx: part 1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/96a/166/968/96a16696860d4ac7a72452c672c5add2.png"></div><br>  Virtual reality is rapidly gaining popularity among users, but still remains inaccessible to many developers.  The reason is trivial - many people write games in frameworks to which the Cardboard SDK cannot be screwed, and learning to work in another framework is not possible or just lazy.  The same is with Libgdx, where, despite <a href="https://github.com/yangweigbh/Libgdx-CardBoard-Extension">attempts to cross already with a hedgehog</a> , it is still not possible to create VR games and applications.  A couple of months ago I had a burning desire to create my own VR toy, and since I know Libgdx well and have been working with him for a long time, I have only one way to go: explore everything myself and implement my own VR <s>bike</s> engine within Libgdx.  The eyes are afraid - the hands are doing, and after a month of nightly gatherings the game was ready.  Literally a couple of days after the publication, they began to flood me with requests to share the code or at least explain how it works.  I'm not greedy, so I decided to stir up a couple of articles with examples of applications, and in this part I will talk about how to get the orientation of the sensors of the smartphone (the so-called head tracking), as well as display the stereo pair. <a name="habracut"></a><br><br><h2>  Disclaimer </h2><br>  Despite the fact that Libgdx is positioned as a cross-platform framework, this article provides an example of an application that is designed only for Android.  There are two reasons for switching to a platform-dependent code: <br><br>  <b>1)</b> The standard Gdx.input from Libgdx does not provide the ability to obtain "raw" data from the magnetometer (compass) of a smartphone.  What was the problem to add 3 methods by analogy with the gyroscope and accelerometer I am not aware of, but this is what caused the output of all the work with the sensors in the android-module. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>2)</b> <a href="https://github.com/libgdx/libgdx/wiki/Gyroscope">The wiki says</a> that Libgdx does not support a gyroscope on iOS, as far as this information is relevant at the moment I am not up to date. <br><br><hr><br><br><h2>  Sensors </h2><br>  So, we have a smartphone equipped with three sensors (ideally).  You need to convert and filter this data to get a quaternion to rotate the camera in OpenGL.  What is a quaternion, and how it is useful is well described <a href="https://habrahabr.ru/post/183908/">here</a> .  I propose for a start to briefly review each type of sensor separately, in order to understand what we are dealing with. <br><br><h3>  Gyroscope </h3><br>  A gyroscope is a device that can react to changes in the orientation angles of the body to which it is attached.  Mechanical gyroscopes are very well known for a long time, they are mainly used in various inertial systems for course stabilization and navigation. <br><div style="text-align:center;"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Gyroscope_operation.gif/200px-Gyroscope_operation.gif" alt="image"></div><br>  Modern smartphones use MEMS gyros, which provide angular rotational speeds along three axes in the form of a vector. <img src="https://habrastorage.org/files/7f3/8fd/9d5/7f38fd9d5e914636849a91f747dc98d1.png">  . <br><div style="text-align:center;"><img src="https://habrastorage.org/files/582/707/c13/582707c13f8649cdb55168043092b1b2.png"></div><br>  For us, it does not matter in what units of measurement the data comes in (radians or degrees), the only important thing is that they are directly proportional to the angular speeds of rotation of the device.  Obviously, an ideal gyro at rest should produce zeros: <img src="https://habrastorage.org/files/30e/10a/b28/30e10ab28cbd4d78b18cb06e48501e07.png">  but this is not the case with the MEMS gyroscope.  In general, MEMS gyroscopes are the cheapest and most inaccurate of all those that exist; at rest, they have a strong zero drift.  When integrating these angular velocities skipping around zero into orientation angles, the error begins to accumulate, resulting in a so-called gyro drift, which is well known to many fans to play VR toys.  To reduce the zero drift, special signal filters and threshold values ‚Äã‚Äãof angular velocities are used, but this is not a panacea, because firstly, this is a reason for so-called deterioration.  VR experience (picture inertia and jerks appear), and secondly, it will not be possible to completely eradicate the drift.  In this case, the other two sensors of the smartphone come to the rescue, with their help you can almost completely eliminate drift, while maintaining the VR experience. <br><br><h3>  Accelerometer </h3><br>  An accelerometer is a device that responds to accelerations of the body to which it is attached.  The accelerometer of the smartphone gives the vector of accelerations along the axes <img src="https://habrastorage.org/files/cbf/9c2/a26/cbf9c2a26fd449a79bdd2953b7e9cac6.png">  , the unit of measurement is most often m / s, but for us this is also not critical.  At rest, the accelerometer provides the direction of the gravity vector, we can use this feature to stabilize the horizon (Tilt correction).  The accelerometer also has flaws.  If the gyroscope is noisy mainly at rest, then the accelerometer on the contrary lays more in motion, so the combination of data from these two sensors must be approached wisely.  In various INS for quadcopters, the Kalman filter is used, but I believe that in the case of VR, you can do with the usual complement, here and so there is something to load the processor of the smartphone. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/991/750/e93/991750e93fbd487a8be1aeee9b8bac54.png"></div><br><br>  As a result, a bunch of gyroscope + accelerometer allows us to create games already, the same Cardboard SDK works this way.  But there remains a drift around the vertical axis, which can be removed using a magnetometer.  In the Cardboard SDK, the magnetometer is given to work with a magnetic button, therefore all drifting course is always present in all Cardboard games. <br><br><h3>  Magnetometer </h3><br>  Magnetometer - a device that reacts to magnetic fields.  At rest, in the absence of electromagnetic and magnetic interference, the smartphone's magnetometer provides the direction of the magnetic induction field of the Earth <img src="https://habrastorage.org/files/4c4/bb9/f49/4c4bb9f49fb74d438151297ce1077be5.png">  , values ‚Äã‚Äãare usually in microtesla (ŒºT). <br><div style="text-align:center;"><img src="https://habrastorage.org/files/cca/968/da3/cca968da3ec147e9b9644a7af727a61a.png"></div><br>  This invisible support in the form of the magnetic field of the planet allows us to eliminate arbitrary rotation around the vertical axis, thereby completely eliminating all drift.  It is worth noting that magnetic drift correction does not always and everywhere work the way we want it.  First, any external slightest fields from the magnets in the case of a smartphone or in a VR helmet cover will lead to unpredictable results.  Secondly, the magnetic field strength is different in different parts of the planet, as is the direction of the magnetic induction vector.  This means that the correction of the drift using a magnetometer will not work near the poles, because there the magnetic field lines are almost perpendicular to the earth's surface and do not carry any useful information about the orientation of the cardinal points.  I hope there are no polar explorers among us? <br><br><hr><br><h2>  Theory </h2><br>  To obtain the current quaternion of the phone, we need to cyclically obtain information from all sensors and perform operations on the basis of the quaternion obtained at the previous time instant.  Let be <img src="https://habrastorage.org/files/a68/4eb/3e0/a684eb3e0fa444639ad845b153baaab1.png">  - the required orientation quaternion, before the start of the cycle we assign it an initial value <img src="https://habrastorage.org/files/1bf/81f/35d/1bf81f35d4bc46aaaece7aab208b1cbe.png">  . <br><br><h3>  1. Integrating gyro readings </h3><br>  As I said, the gyroscope provides an angular velocity vector.  To get the angular coordinates from the angular velocities, we need to integrate them.  This is done as follows: <br><br>  <b>1.1.</b>  Declare Quaternion <img src="https://habrastorage.org/files/7df/d74/de3/7dfd74de32bb4d169866a670cb7cf4ab.png">  and set it as: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a89/ba0/9b5/a89ba09b528c4590a7e10b924d7ee6f8.png"></div><br>  Where <img src="https://habrastorage.org/files/b48/56b/0ed/b4856b0edc35477eb7fa44e3bf97abbb.png">  - time elapsed from the previous iteration of the cycle; <br>  <b>1.2.</b>  We update <i>q</i> using the received <img src="https://habrastorage.org/files/7df/d74/de3/7dfd74de32bb4d169866a670cb7cf4ab.png">  : <img src="https://habrastorage.org/files/772/05a/628/77205a6289f041f78a526fcf92953e73.png">  . <br><br>  As a result of the described actions, the quaternion <i>q</i> can already be used for rotation, however, due to the very low accuracy of the smartphone gyro, it is awfully floating on all three axes. <br><br><h3>  2. Align the horizon plane (Tilt Correction) </h3><br>  This will help us accelerometer.  In short, for this we need to find a corrective quaternion and multiply it by the one obtained in the previous step.  The correction quaternion, in turn, is formed using a vector-axis of rotation and angle of rotation. <br><br>  <b>2.1.</b>  Take the vector accelerometer as a quaternion: <img src="https://habrastorage.org/files/234/355/430/2343554309444371b64e892bd426515a.png"><br>  <b>2.2.</b>  Turn this accelerometer quaternion with our gyroscope quaternion: <img src="https://habrastorage.org/files/28b/b41/86d/28bb4186d0fb4a45b8c53f5171fcc9ea.png"><br>  <b>2.3.</b>  Take the normalized vector part of the quaternion <img src="https://habrastorage.org/files/2ea/0b2/716/2ea0b271604645049964a6a529d45693.png">  : <img src="https://habrastorage.org/files/ab5/df9/615/ab5df9615f1e48b28c3d955498f1f9ea.png"><br>  <b>2.4.</b>  With its help we find the vector defining the axis of rotation: <img src="https://habrastorage.org/files/45f/fb8/282/45ffb82822604fad86c2a983ec84e906.png"><br>  <b>2.5.</b>  It now remains to find the angle: <img src="https://habrastorage.org/files/770/4fe/7ef/7704fe7ef93b438fbaf17deb1f685602.png"><br>  <b>2.6.</b>  And adjust the quaternion from the gyroscope: <img src="https://habrastorage.org/files/666/4ec/a53/6664eca53a644f5b8c4dc20c029cc307.png">  where <img src="https://habrastorage.org/files/823/8da/d15/8238dad15fa241d1bd59dbc5df185218.png">  - the smoothing factor, the smaller it is - the smoother and longer the horizon will stabilize, the optimal value in most cases is 0.1. <br><br>  Everything, now <i>q</i> will not turn the camera upside down, only a small drift around the Y axis is possible. <br><br><h3>  3. We remove the drift around the Y axis using a magnetometer (Yaw Correction) </h3><br>  The compass of the smartphone is a rather capricious thing, it must be calibrated after each reboot, when brought up to massive glands or magnets.  Loss of calibration in the case of VR leads to an unpredictable camera response to head rotation.  In 99% of cases, the average user‚Äôs compass is not calibrated, so I strongly recommend keeping the default drift correction feature turned off, otherwise you can pick up negative reviews.  In addition, it would be nice to display a warning about the need for calibration every time the application is started with correction enabled.  Android itself takes over the calibration itself, to call it, you need to draw the number ‚Äú8‚Äù or ‚Äú‚àû‚Äù in the air several times with your smartphone. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/db5/a7f/22a/db5a7f22a5a14db390886b58f0ccf3e4.png"></div><br>  It is a pity that Android does not provide any way to check the status of the compass calibration and to give a message like ‚Äúeverything is enough to wave‚Äù, here you have to rely on the intellectual abilities of the user.  In principle, it is possible to be confused and consider strokes with an accelerometer, but of course we will not do this.  Let us turn to the algorithm, which is not much different from the horizon correction with the accelerometer: <br><br>  <b>3.1.</b>  We also design the vector of the compass in the form of a quaternion: <img src="https://habrastorage.org/files/d99/023/e15/d99023e159d74b469e215b9013f545a7.png"><br>  <b>3.2.</b>  And turn: <img src="https://habrastorage.org/files/d12/26a/f45/d1226af452774de697265bc363a77dea.png"><br>  <b>3.3.</b>  The rotation axis in this case is Y (0, 1, 0), so we only need the angle: <img src="https://habrastorage.org/files/eb6/fe1/afc/eb6fe1afc9294ce2aa1afd10b2ef06b4.png"><br>  <b>3.4.</b>  Adjust: <img src="https://habrastorage.org/files/32f/a5b/7fe/32fa5b7fe8c64e7fb03a51e3d69e1c5d.png">  where <img src="https://habrastorage.org/files/f31/150/8eb/f311508ebe84402eb45ccd693119faa4.png">  - the same smoothing factor as <img src="https://habrastorage.org/files/823/8da/d15/8238dad15fa241d1bd59dbc5df185218.png">  above <br><br>  Now the drift will be completely absent if the magnetometer is normally calibrated and the user is not geographically too close to the poles of the Earth.  It is worth noting that my method is somewhat different from the method <a href="https://developer3.oculus.com/blog/magnetometer/">used in the Oculus Rift</a> .  There the essence is as follows: for the last several iterations of the cycle, the rotation quaternion and the corresponding readings of the magnetometer are memorized (so-called reference points are created);  We look further: if the readings of the magnetometer do not change, and the quaternion ‚Äúgoes‚Äù in this case, then the drift angle is calculated, and the quaternion turns in the opposite direction.  This approach works well on the Oculus, but is not applicable on smartphones due to the too low accuracy of their magnetometers.  I tried to implement the method from the article - on smartphones he jerks the camera and doesn‚Äôt really remove the drift at the same time. <br><br><hr><br><h2>  Implementation </h2><br>  First, create an empty android project using <a href="">gdx-setup.jar</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e59/54b/b7a/e5954bb7a98044068aa75bab3c2dbd4c.png"></div><br>  The typical android libgdx project is divided into two modules: android and core.  The first module contains a platform-dependent code, while the second usually contains the logic of the game and draws.  The interaction between the core module and android is carried out through interfaces, based on this we need to create 3 files: <br><br><ol><li>  <b>VRSensorManager</b> - touch manager interface </li><li>  <b>VRSensorManagerAndroid</b> - its implementation </li><li>  <b>VRCamera</b> - a simple camera for drawing </li></ol><br>  And make changes to 2 project files: <br><br><ol><li>  <b>AndroidLauncher</b> - starter class android project </li><li>  <b>GdxVR</b> - the main class of the application </li></ol><br>  I <a href="https://github.com/SinuXVR/GdxVR-Sample-1">uploaded the</a> project <a href="https://github.com/SinuXVR/GdxVR-Sample-1">source to the githaba repository</a> , I tried to document the code as much as possible, so I‚Äôll only explain the main points in the article. <br><br><h3>  VRSensorManager </h3><br>  I brought all the work with the sensors and the calculation of the quaternion into the android module, to get the quaternion in the core module we use this interface. <br><br><div class="spoiler">  <b class="spoiler_title">VRSensorManager.java</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sinuxvr.sample; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Quaternion; <span class="hljs-comment"><span class="hljs-comment">/**     -  */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VRSensorManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGyroAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMagAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startTracking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endTracking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** -     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> use - true - , false -  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useDriftCorrection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> use)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/**      * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">     */</span></span> <span class="hljs-function"><span class="hljs-function">Quaternion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeadQuaternion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br></div></div><br>  All methods here are intuitive, I think no one had any questions.  The methods isGyroAvailable and isMagAvailable are not used anywhere in the example, but they can be useful to someone, I use them in my game. <br><br><h3>  VRSensorManagerAndroid </h3><br>  Theoretically, in the android module, you can only get the values ‚Äã‚Äãfrom the sensors, and calculate the quaternion from them already in the core.  I decided to combine everything in one place, so that the code could be more easily ported to other frameworks. <br><br><div class="spoiler">  <b class="spoiler_title">VRSensorManagerAndroid.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sinuxvr.sample; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.Sensor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorEvent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorEventListener; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.Gdx; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.MathUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Quaternion; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Vector2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Vector3; <span class="hljs-comment"><span class="hljs-comment">/**     Android.      *             . *  : ,  + ,  + , *  +  +  */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VRSensorManagerAndroid</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VRSensorManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/**         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VRControlMode { ACC_ONLY, ACC_GYRO, ACC_MAG, ACC_GYRO_MAG } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SensorManager sensorManager; <span class="hljs-comment"><span class="hljs-comment">//   private SensorEventListener accelerometerListener; //   private SensorEventListener gyroscopeListener; //   private SensorEventListener compassListener; //   private Context context; //   /**     */ private final float[] accelerometerValues = new float[3]; //  private final float[] gyroscopeValues = new float[3]; //  private final float[] magneticFieldValues = new float[3]; //  private final boolean gyroAvailable; //    private final boolean magAvailable; //    private volatile boolean useDC; //    /**      ,    headOrientation */ private final Quaternion gyroQuaternion; private final Quaternion deltaQuaternion; private final Vector3 accInVector; private final Vector3 accInVectorTilt; private final Vector3 magInVector; private final Quaternion headQuaternion; private VRControlMode vrControlMode; /**  */ VRSensorManagerAndroid(Context context) { this.context = context; //    sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); //    (   100%, ) magAvailable = (sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null); gyroAvailable = (sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE) != null); useDC = false; //         vrControlMode = VRControlMode.ACC_ONLY; if (gyroAvailable) vrControlMode = VRControlMode.ACC_GYRO; if (magAvailable) vrControlMode = VRControlMode.ACC_MAG; if (gyroAvailable &amp;&amp; magAvailable) vrControlMode = VRControlMode.ACC_GYRO_MAG; //   gyroQuaternion = new Quaternion(0, 0, 0, 1); deltaQuaternion = new Quaternion(0, 0, 0, 1); accInVector = new Vector3(0, 10, 0); accInVectorTilt = new Vector3(0, 0, 0); magInVector = new Vector3(1, 0, 0); headQuaternion = new Quaternion(0, 0, 0, 1); //   startTracking(); } /**    */ @Override public boolean isGyroAvailable() { return gyroAvailable; } /**    */ @Override public boolean isMagAvailable() { return magAvailable; } /**   -   */ @Override public void startTracking() { //      sensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE); Sensor accelerometer = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0); accelerometerListener = new SensorListener(this.accelerometerValues, this.magneticFieldValues, this.gyroscopeValues); sensorManager.registerListener(accelerometerListener, accelerometer, SensorManager.SENSOR_DELAY_GAME); //  if (magAvailable) { sensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE); Sensor compass = sensorManager.getSensorList(Sensor.TYPE_MAGNETIC_FIELD).get(0); compassListener = new SensorListener(this.accelerometerValues, this.magneticFieldValues, this.gyroscopeValues); sensorManager.registerListener(compassListener, compass, SensorManager.SENSOR_DELAY_GAME); } //  if (gyroAvailable) { sensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE); Sensor gyroscope = sensorManager.getSensorList(Sensor.TYPE_GYROSCOPE).get(0); gyroscopeListener = new SensorListener(this.gyroscopeValues, this.magneticFieldValues, this.gyroscopeValues); sensorManager.registerListener(gyroscopeListener, gyroscope, SensorManager.SENSOR_DELAY_GAME); } } /**   -   */ @Override public void endTracking() { if (sensorManager != null) { if (accelerometerListener != null) { sensorManager.unregisterListener(accelerometerListener); accelerometerListener = null; } if (gyroscopeListener != null) { sensorManager.unregisterListener(gyroscopeListener); gyroscopeListener = null; } if (compassListener != null) { sensorManager.unregisterListener(compassListener); compassListener = null; } sensorManager = null; } } /** -     */ @Override public void useDriftCorrection(boolean useDC) { //     ,      this.useDC = useDC; } /**      */ @Override public synchronized Quaternion getHeadQuaternion() { //         switch (vrControlMode) { //    case ACC_ONLY: updateAccData(0.1f); //   Yaw       (   ) headQuaternion.setFromAxisRad(0, 1, 0, -MathUtils.sin(accelerometerValues[0] / 200f)).mul(gyroQuaternion).nor(); gyroQuaternion.set(headQuaternion); break; //  +  (     ,    //     ,    ) case ACC_MAG: updateAccData(0.2f); if (!useDC) { headQuaternion.setFromAxisRad(0, 1, 0, -MathUtils.sin(accelerometerValues[0] / 200f)).mul(gyroQuaternion).nor(); gyroQuaternion.set(headQuaternion); } else updateMagData(1f, 0.05f); break; //  +  case ACC_GYRO: updateGyroData(0.1f); updateAccData(0.02f); break; //    - must have,      case ACC_GYRO_MAG: float dQLen = updateGyroData(0.1f); updateAccData(0.02f); if (useDC) updateMagData(dQLen, 0.005f); } return headQuaternion; } /**    *      * @param driftThreshold -      * @return -   deltaQuaternion */ private synchronized float updateGyroData(float driftThreshold) { float wX = gyroscopeValues[0]; float wY = gyroscopeValues[1]; float wZ = gyroscopeValues[2]; //    float l = Vector3.len(wX, wY, wZ); float dtl2 = Gdx.graphics.getDeltaTime() * l * 0.5f; if (l &gt; driftThreshold) { float sinVal = MathUtils.sin(dtl2) / l; deltaQuaternion.set(sinVal * wX, sinVal * wY, sinVal * wZ, MathUtils.cos(dtl2)); } else deltaQuaternion.set(0, 0, 0, 1); gyroQuaternion.mul(deltaQuaternion); return l; } /**  Tilt    * @param filterAlpha -   */ private synchronized void updateAccData(float filterAlpha) { //       accInVector.set(accelerometerValues[0], accelerometerValues[1], accelerometerValues[2]); gyroQuaternion.transform(accInVector); accInVector.nor(); //      accInVector  UP(0, 1, 0) float xzLen = 1f / Vector2.len(accInVector.x, accInVector.z); accInVectorTilt.set(-accInVector.z * xzLen, 0, accInVector.x * xzLen); //     accInVector  UP(0, 1, 0) float fi = (float)Math.acos(accInVector.y); //  Tilt-     headQuaternion.setFromAxisRad(accInVectorTilt, filterAlpha * fi).mul(gyroQuaternion).nor(); gyroQuaternion.set(headQuaternion); } /**    Yaw  * @param dQLen -   deltaQuaternion * @param filterAlpha -   *      */ private synchronized void updateMagData(float dQLen, float filterAlpha) { //   deltaQuaternion      if (dQLen &lt; 0.1f) return; //       magInVector.set(magneticFieldValues[0], magneticFieldValues[1], magneticFieldValues[2]); gyroQuaternion.transform(magInVector); //   Yaw    float theta = MathUtils.atan2(magInVector.z, magInVector.x); //   headQuaternion.setFromAxisRad(0, 1, 0, filterAlpha * theta).mul(gyroQuaternion).nor(); gyroQuaternion.set(headQuaternion); } /**      (  AndroidInput) */ private class SensorListener implements SensorEventListener { final float[] accelerometerValues; final float[] magneticFieldValues; final float[] gyroscopeValues; SensorListener (float[] accelerometerValues, float[] magneticFieldValues, float[] gyroscopeValues) { this.accelerometerValues = accelerometerValues; this.magneticFieldValues = magneticFieldValues; this.gyroscopeValues = gyroscopeValues; } //   (  ) @Override public void onAccuracyChanged (Sensor arg0, int arg1) { } //     @Override public synchronized void onSensorChanged (SensorEvent event) { if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) { accelerometerValues[0] = -event.values[1]; accelerometerValues[1] = event.values[0]; accelerometerValues[2] = event.values[2]; } if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) { magneticFieldValues[0] = -event.values[1]; magneticFieldValues[1] = event.values[0]; magneticFieldValues[2] = event.values[2]; } if (event.sensor.getType() == Sensor.TYPE_GYROSCOPE) { gyroscopeValues[0] = -event.values[1]; gyroscopeValues[1] = event.values[0]; gyroscopeValues[2] = event.values[2]; } } } }</span></span></code> </pre> <br></div></div><br>  Here, perhaps, I will make a couple of explanations.  Sensor data is obtained using ordinary listeners, on this account on the Internet is full of manuals.  I divided my work with quaternion into 3 methods in accordance with the theoretical part: <br><br><ol><li>  <b>updateGyroData</b> - integration of gyro angular velocities </li><li>  <b>updateAccData</b> - stabilization horizon accelerometer </li><li>  <b>updateMagData</b> - compass drift correction </li></ol><br>  If we assume that there is always an accelerometer on the phone, there are only 4 possible sensor combinations, all of which are defined in the VRControlMode enumeration: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VRControlMode { ACC_ONLY, ACC_GYRO, ACC_MAG, ACC_GYRO_MAG }</code> </pre> <br>  The combination of sensors of a device is determined in the constructor, then when you call the getHeadQuaternion method, depending on it, a quaternion is formed in one way or another.  The beauty of this approach is that it allows you to combine calls to the updateGyroData / updateAccData / updateMagData methods depending on the available sensors and to ensure that the application works even if the phone has only one accelerometer.  Even better, if there is a compass in addition to the accelerometer in the phone, then this bundle can behave almost like a gyroscope, allowing you to rotate your head through 360 ¬∞.  Although there can be no normal VR experience in this case, it‚Äôs still better than the heartless inscription ‚ÄúYour phone doesn't have a gyroscope‚Äù, is it?  The useDriftCorrection method is also interesting, it allows you to enable / disable the use of a magnetometer on the fly without affecting the listeners (technically, it simply stops calling updateMagData). <br><br><h3>  Vrcamera </h3><br>  To display the image in the form of a stereo pair, we need 2 cameras separated by some distance from each other, called the parallax base.  Therefore, VRCamera contains 2 instances of PerspectiveCamera.  In general, in this class, only work with cameras is performed (by turning the quaternion and moving), I directly placed the stereo pair in the main GdxVR class. <br><br><div class="spoiler">  <b class="spoiler_title">Vrcamera.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sinuxvr.sample; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.Gdx; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.graphics.PerspectiveCamera; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Matrix4; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Quaternion; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.math.Vector3; <span class="hljs-comment"><span class="hljs-comment">/**  VR  *      VRSensorManager   update() */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VRCamera</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PerspectiveCamera leftCam; <span class="hljs-comment"><span class="hljs-comment">//   private PerspectiveCamera rightCam; //   private Vector3 position; //  VR  private float parallax; //    private Vector3 direction; //   VR  private Vector3 up; //  UP VR  private Vector3 upDirCross; //   up  direction (   2,   ) /**  */ VRCamera(float fov, float parallax, float near, float far) { this.parallax = parallax; leftCam = new PerspectiveCamera(fov, Gdx.graphics.getWidth() / 2, Gdx.graphics.getHeight()); leftCam.near = near; leftCam.far = far; leftCam.update(); rightCam = new PerspectiveCamera(fov, Gdx.graphics.getWidth() / 2, Gdx.graphics.getHeight()); rightCam.near = near; rightCam.far = far; rightCam.update(); position = new Vector3(0, 0, 0); direction = new Vector3(0, 0, 1); up = new Vector3(0, 1, 0); upDirCross = new Vector3().set(direction).crs(up).nor(); } /**    */ void update() { Quaternion headQuaternion = GdxVR.vrSensorManager.getHeadQuaternion(); // -        //       direction.set(0, 0, 1); headQuaternion.transform(direction); up.set(0, 1, 0); headQuaternion.transform(up); upDirCross.set(direction); upDirCross.crs(up).nor(); //       float angle = 2 * (float)Math.acos(headQuaternion.w); float s = 1f / (float)Math.sqrt(1 - headQuaternion.w * headQuaternion.w); float vx = headQuaternion.x * s; float vy = headQuaternion.y * s; float vz = headQuaternion.z * s; //    leftCam.view.idt(); //    leftCam.view.translate(parallax, 0, 0); //     + parallax  X leftCam.view.rotateRad(vx, vy, vz, -angle); //   leftCam.view.translate(-position.x, -position.y, -position.z); //   position leftCam.combined.set(leftCam.projection); Matrix4.mul(leftCam.combined.val, leftCam.view.val); //    rightCam.view.idt(); //    rightCam.view.translate(-parallax, 0, 0); //     + parallax  X rightCam.view.rotateRad(vx, vy, vz, -angle); //   rightCam.view.translate(-position.x, -position.y, -position.z); //   position rightCam.combined.set(rightCam.projection); Matrix4.mul(rightCam.combined.val, rightCam.view.val); } /**    */ void setPosition(float x, float y, float z) { position.set(x, y, z); } /**    */ PerspectiveCamera getLeftCam() { return leftCam; } /**    */ PerspectiveCamera getRightCam() { return rightCam; } /**  ,    UP ,      */ public Vector3 getPosition() { return position; } public Vector3 getDirection() { return direction; } public Vector3 getUp() { return up; } public Vector3 getUpDirCross() { return upDirCross; } }</span></span></code> </pre> <br></div></div><br>  The most interesting methods here are the constructor and update.  The designer accepts the field of view angle (fov), the distance between the cameras (parallax), and the distance to the near and far clipping planes (near, far): <br><br><pre> <code class="java hljs">VRCamera(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fov, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> parallax, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> near, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> far)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the update method, we take the quaternion from the VRSensorManager, move the cameras to (¬± parallax, 0, 0), rotate them, and then move them back to their original position. </font><font style="vertical-align: inherit;">With this approach, there will always be a predetermined parallax base between the cameras, and the user will see the stereoscopic image for any orientation of the head. </font><font style="vertical-align: inherit;">Please note that we directly work with view matrixes of cameras, which means that the direction and up vectors of cameras are not updated. </font><font style="vertical-align: inherit;">Therefore, its 2 vectors are entered into VRCamera, and their values ‚Äã‚Äãare calculated using quaternion.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AndroidLauncher </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the starter class, when you initialize the application, you need to create an instance of VRSensorManagerAndroid and transfer it to the main class of the game (in my case GdxVR): </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); AndroidApplicationConfiguration config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AndroidApplicationConfiguration(); config.useWakelock = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; config.useAccelerometer = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; config.useGyroscope = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; config.useCompass = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; vrSensorManagerAndroid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VRSensorManagerAndroid(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getContext()); initialize(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GdxVR(vrSensorManagerAndroid), config); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also, do not forget to disable / register listeners when hiding / expanding the application: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vrSensorManagerAndroid.endTracking(); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume(); vrSensorManagerAndroid.startTracking(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Full starter class code: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AndroidLauncher.java</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sinuxvr.sample; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.backends.android.AndroidApplication; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.backends.android.AndroidApplicationConfiguration; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidLauncher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> VRSensorManagerAndroid vrSensorManagerAndroid; <span class="hljs-comment"><span class="hljs-comment">//   /**   */ @Override protected void onCreate (Bundle savedInstanceState) { super.onCreate(savedInstanceState); AndroidApplicationConfiguration config = new AndroidApplicationConfiguration(); //         libgdx config.useWakelock = true; config.useAccelerometer = false; config.useGyroscope = false; config.useCompass = false; config.numSamples = 2; //       ( useAccelerometer  ..  ) vrSensorManagerAndroid = new VRSensorManagerAndroid(this.getContext()); initialize(new GdxVR(vrSensorManagerAndroid), config); } /**    -    */ @Override public void onPause() { vrSensorManagerAndroid.endTracking(); super.onPause(); } /**   -     */ @Override public void onResume() { super.onResume(); vrSensorManagerAndroid.startTracking(); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to put the room.g3db model file and texture.png file in the assets folder, they will be useful to us in the next step. </font><font style="vertical-align: inherit;">You can download them </font></font><a href="https://github.com/SinuXVR/GdxVR-Sample-1/tree/master/android/assets"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Any other model of any scene will do, I decided not to bother much and I took the finished model from the level of my own game, the 3D effect is well felt in it due to the presence of many small details.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gdxvr </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we come to the main class. </font><font style="vertical-align: inherit;">First we need to declare in it our VRSensorManager and a constructor that receives a link to an instance of this class from AndroidLauncher:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> VRSensorManager vrSensorManager; GdxVR(VRSensorManager vrSensorManager) { GdxVR.vrSensorManager = vrSensorManager; }</code> </pre><br>  Complete code: <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GdxVR.java</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sinuxvr.sample; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.ApplicationAdapter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.Gdx; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.assets.AssetManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.graphics.GL20; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.graphics.g3d.Model; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.graphics.g3d.ModelBatch; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.badlogic.gdx.graphics.g3d.ModelInstance; <span class="hljs-comment"><span class="hljs-comment">/**   ,    ,     */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GdxVR</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> VRSensorManager vrSensorManager; <span class="hljs-comment"><span class="hljs-comment">//       private int scrHeight, scrHalfWidth; //    viewport private AssetManager assets; //   private ModelBatch modelBatch; //    private ModelInstance roomInstance; //    private VRCamera vrCamera; // VR  /**  */ GdxVR(VRSensorManager vrSensorManager) { GdxVR.vrSensorManager = vrSensorManager; } /**     */ @Override public void create () { //   scrHalfWidth = Gdx.graphics.getWidth() / 2; scrHeight = Gdx.graphics.getHeight(); //     modelBatch = new ModelBatch(); assets = new AssetManager(); assets.load("room.g3db", Model.class); assets.finishLoading(); Model roomModel = assets.get("room.g3db"); roomInstance = new ModelInstance(roomModel); //   (fov, parallax, near, far)    vrCamera = new VRCamera(90, 0.4f, 0.1f, 30f); vrCamera.setPosition(-1.7f, 3f, 3f); //       vrSensorManager.useDriftCorrection(true); } /**       viewport- */ @Override public void render () { //   Gdx.gl.glClearColor(0f, 0f, 0f, 1f); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT); //    vrCamera.update(); //      Gdx.gl.glViewport(0, 0, scrHalfWidth, scrHeight); modelBatch.begin(vrCamera.getLeftCam()); modelBatch.render(roomInstance); modelBatch.end(); //      Gdx.gl.glViewport(scrHalfWidth, 0, scrHalfWidth, scrHeight); modelBatch.begin(vrCamera.getRightCam()); modelBatch.render(roomInstance); modelBatch.end(); } /**   */ @Override public void dispose () { modelBatch.dispose(); assets.dispose(); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the create method, we know the screen sizes (width divided by 2, you know why), load the scene model, and then create and position the camera: </font></font><br><br><pre> <code class="java hljs">vrCamera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VRCamera(<span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">30f</span></span>); vrCamera.setPosition(-<span class="hljs-number"><span class="hljs-number">1.7f</span></span>, <span class="hljs-number"><span class="hljs-number">3f</span></span>, <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Even in the example, I turned on the drift correction, if someone after the launch has problems with the camera - look for the reason in compass calibration: </font></font><br><br><pre> <code class="java hljs">vrSensorManager.useDriftCorrection(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the render method, before all rendering, you must call the camera update: </font></font><br><br><pre> <code class="java hljs">vrCamera.update();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stereo pair is implemented using a standard viewport. </font><font style="vertical-align: inherit;">Adjust the viewport to the left half of the screen and draw a picture for the left eye:</font></font><br><br><pre> <code class="java hljs">Gdx.gl.glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scrHalfWidth, scrHeight); modelBatch.begin(vrCamera.getLeftCam()); modelBatch.render(roomInstance); modelBatch.end();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then in the same way for the right: </font></font><br><br><pre> <code class="java hljs">Gdx.gl.glViewport(scrHalfWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>, scrHalfWidth, scrHeight); modelBatch.begin(vrCamera.getRightCam()); modelBatch.render(roomInstance); modelBatch.end();</code> </pre><br><br><hr><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If everything was done correctly, then you can insert the smartphone into VR glasses and dive into the virtual world that you just created with your own hands: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9fc/77c/ffb/9fc77cffbf9e47e5b35c6856177ed8b6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welcome to the new reality! </font><font style="vertical-align: inherit;">I will tell you about the work with sounds in the second part, and today I have everything. </font><font style="vertical-align: inherit;">Thank you for your attention, if you have any questions - I will try to answer them in the comments.</font></font><br><br><hr><br><h2>  Sources </h2><br><ol><li> <a href="http://stanford.edu/class/ee267/lectures/lecture10.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quaternions &amp; IMU Sensor Fusion with Complementary Filtering</font></font></a> </li><li> <a href="https://developer3.oculus.com/blog/magnetometer/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Help! </font><font style="vertical-align: inherit;">My Cockpit Is Drifting Away</font></font></a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/318278/">https://habr.com/ru/post/318278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318266/index.html">Idiom ranges</a></li>
<li><a href="../318268/index.html">Optimize redux storage for more productive changes.</a></li>
<li><a href="../318272/index.html">Financial Telegram-bot in 30 minutes with Market Data API</a></li>
<li><a href="../318274/index.html">Slow evolution of interfaces or the saga of the fourth button</a></li>
<li><a href="../318276/index.html">Anonymous Father Frost 2016-2017: post boasting New Year's gifts</a></li>
<li><a href="../318282/index.html">The truth about traditional JavaScript benchmarks</a></li>
<li><a href="../318284/index.html">Netdata: real-time monitoring</a></li>
<li><a href="../318286/index.html">Personal experience: How we automated work with DNS records in the hosting panel</a></li>
<li><a href="../318288/index.html">Is the client always right?</a></li>
<li><a href="../318290/index.html">Magic hosting in the Netherlands, excluding consumed server resources, is updated and cheaper than anywhere else.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>