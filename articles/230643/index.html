<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 8: Subscribers, Contacts and Friends</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the eighth article in the series where I describe my experience of writing a Python web application using the Flask mic framework. 

 The purp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 8: Subscribers, Contacts and Friends</h1><div class="post__text post__text-html js-mediator-article">  This is the eighth article in the series where I describe my experience of writing a Python web application using the Flask mic framework. <br><br>  The purpose of this guide is to develop a fairly functional microblog application, which I decided to call microblog, in the absence of originality. <br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/193242/">Part 1: Hello, World!</a> <br>  <a href="http://habrahabr.ru/post/193260/">Part 2: Templates</a> <br>  <a href="http://habrahabr.ru/post/194062/">Part 3: Forms</a> <br>  <a href="http://habrahabr.ru/post/196810/">Part 4: Database</a> <br>  <a href="http://habrahabr.ru/post/222983/">Part 5: User Login</a> <br>  <a href="http://habrahabr.ru/post/223375/">Part 6: Profile Page and Avatars</a> <br>  <a href="http://habrahabr.ru/post/223783/">Part 7: Unit Testing</a> <br>  <a href="http://habrahabr.ru/post/230643/">Part 8: Subscribers, Contacts and Friends (this article)</a> <br>  <a href="http://habrahabr.ru/post/230897/">Part 9: Pagination</a> <br>  <a href="http://habrahabr.ru/post/234613/">Part 10: Full Text Search</a> <br>  <a href="http://habrahabr.ru/post/234737/">Part 11: Email Support</a> <br>  <a href="http://habrahabr.ru/post/234785/">Part 12: Reconstruction</a> <br>  <a href="http://habrahabr.ru/post/236753/">Part 13: Date and Time</a> <br>  <a href="http://habrahabr.ru/post/236861/">Part 14: I18n and L10n</a> <br>  <a href="http://habrahabr.ru/post/237065/">Part 15: Ajax</a> <br>  <a href="http://habrahabr.ru/post/237317/">Part 16: Debugging, Testing, and Profiling</a> <br>  <a href="http://habrahabr.ru/post/237489/">Part 17: Deploying to Linux (and even to Raspberry Pi!)</a> <br>  <a href="http://habrahabr.ru/post/237517/">Part 18: Deploying to Heroku Cloud</a> <br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Brief repetition </h2><br>  Our little microblogging is slowly growing, and today we will touch on topics that are necessary for a complete application. <br><br>  Today we will work a little with our database. <a name="habracut"></a>  Each user of our application should be able to choose the users whom he wants to track, and our database should also store data about who is tracking whom.  All social applications have these features in different variations.  Some call it Contacts, others Connections, Friends, Pals or Subscribers.  Some sites use a similar idea for the Allowed and Ignored Users list.  We will call them Subscribers, but we will implement without holding on to the name. <br><br><h2>  Subscribers feature design </h2><br>  Before we start writing code, let's think about the functionality that we want to get from this feature.  Let's start with the most obvious.  We want our users to conveniently maintain lists of subscriptions to other users.  On the other hand, we want to know the list of subscribers of each user.  We also want to be able to find out whether the user has a subscriber or whether he subscribes to other users.  Users will click on the Subscribe link in any other user‚Äôs profile to start tracking it.  In the same way, clicking on the "unsubscribe" link will cancel the subscription to the user.  The last requirement is the ability of the user to request from the database all posts of the monitored users. <br><br>  So, if you thought it would be quick and easy, think again! <br><br><h2>  Communication within the base </h2><br>  We said that we want to have lists of subscribers and subscriptions for all users.  Unfortunately, relational databases do not have the @@ list @@ type, all we have is tables with records and relationships between records.  We already have a table in our database representing the users, it remains to come up with dependency relationships that will model the connections of subscribers / subscriptions.  This is a good point to sort out three types of relationships in relational databases: <br><br><h3>  One-to-many </h3><br>  We have already seen the one-to-many relationship in the previous database article: <br><img src="https://habrastorage.org/getpro/habr/post_images/aa3/cff/63d/aa3cff63d109e4418fab6fda82f958ed.png" alt="image"><br><br>  Two entities related to this relationship are <code>users</code> and <code>posts</code> .  We say that the user can have many posts, and the post has only one user.  These relationships are used in the database with the foreign key (FK) on the "many" side.  In the example above, the external key is the <code>user_id</code> field added to the <code>posts</code> table.  This field links each post with the author‚Äôs entry in the users table. <br><br>  It is clear that the <code>user_id</code> field provides direct access to the author of this post, but what about feedback?  For the link to be useful, we must be able to get a list of posts written by the user.  It turns out that the <code>user_id</code> field in the <code>posts</code> table is enough to answer our question, since the databases have indices that allow you to make such requests as ‚Äúreceive all messages where user_id is X‚Äù. <br><br><h3>  Many-to-many </h3><br>  The many-to-many relationship is a bit more complicated.  For example, consider the database in which <code>students</code> and <code>teachers</code> are stored.  We can say that a student can have many teachers, and a teacher can have many students.  It looks like two partially coincident one-to-many relationships. <br><br>  For this type of relationship, we need to be able to query the database and get a list of the teachers who teach the student and the list of students in the teacher‚Äôs class.  It turns out that it is rather difficult to present in the database; such an attitude cannot be modeled by adding foreign keys to already existing tables. <br><br>  The implementation of the many-to-many relationship requires the use of an auxiliary table, called a pivot table.  For example, the database for students and teachers will look like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/585/415/716/585415716aa54bef9df8dc95fbda52c3.png" alt="image"><br><br>  Although it may seem difficult, but the summary table can answer many of our questions, such as: <br><ul><li>  Who does student S study? </li><li>  Who does teacher T teach? </li><li>  How many students does teacher T have? </li><li>  How many teachers does student S have? </li><li>  Teacher T teaches student S? </li><li>  Is student S attending teacher class T? </li></ul><br><br><h3>  One to one </h3><br>  One-to-one relationships are a special case of one-to-many relationships.  The presentation is very similar, but it prohibits the addition of more than one link, so as not to become one-to-many.  Although there are cases in which this type of relationship is useful, it does not happen as often as in the case of the other two types, since in a situation where two tables are related by the one-to-one relationship, it may make sense to combine the tables into one. <br><br><h5>  Subscribers \ Subscriptions Submission </h5><br>  From the relationships above, we can easily determine that the many-to-many data model is right for us, because the user can follow many other users and the user can have many subscribers.  But there is a feature.  We want to represent users who are subscribed to other users, but we have only one user table.  So, what should we use as a second entity in a many-to-many relationship? <br><br>  Of course, the second entity in the relationship will be the same table of users.  Relations in which instances of an entity are associated with other instances of the same entity are called self-referential relationships, and this is exactly what we need. <br><br>  This is a diagram of our many-to-many relationships: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/649/c7a/a48/649c7aa489c545ac79863698b3d348a1.png" alt="image"><br><br>  The <code>followers</code> table is a pivot table.  Both foreign keys point to the <code>user</code> table, since  we tied the table with ourselves.  Each entry in this table represents one relationship between the subscribed user and the person to whom it is subscribed.  As in the example of students and teachers, a configuration like this allows our database to answer all the questions about subscribers and their subscriptions that we need.  It's pretty simple. <br><br><h2>  DB Model </h2><br>  Changes in our model will not be very big.  We start by adding the @@ followers @@ table (file @@ app / models.py @@): <br><br><pre> <code class="python hljs">followers = db.Table(<span class="hljs-string"><span class="hljs-string">'followers'</span></span>, db.Column(<span class="hljs-string"><span class="hljs-string">'follower_id'</span></span>, db.Integer, db.ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)), db.Column(<span class="hljs-string"><span class="hljs-string">'followed_id'</span></span>, db.Integer, db.ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)) )</code> </pre><br><br>  This is a live translation of the table links from our diagram.  Notice that we did not declare this table as a model, as we did for <code>users</code> and <code>posts</code> .  Since this is an auxiliary table that does not have data other than foreign keys, we will use the low-level flask-sqlalchemy API to create the table without creating its model. <br><br>  Next, we describe the many-to-many relationships in the <code>users</code> table ( <code>app/models.py</code> ) <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> id = db.Column(db.Integer, primary_key = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) nickname = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) email = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">120</span></span>), index = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) role = db.Column(db.SmallInteger, default = ROLE_USER) posts = db.relationship(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>, backref = <span class="hljs-string"><span class="hljs-string">'author'</span></span>, lazy = <span class="hljs-string"><span class="hljs-string">'dynamic'</span></span>) about_me = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">140</span></span>)) last_seen = db.Column(db.DateTime) followed = db.relationship(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, secondary = followers, primaryjoin = (followers.c.follower_id == id), secondaryjoin = (followers.c.followed_id == id), backref = db.backref(<span class="hljs-string"><span class="hljs-string">'followers'</span></span>, lazy = <span class="hljs-string"><span class="hljs-string">'dynamic'</span></span>), lazy = <span class="hljs-string"><span class="hljs-string">'dynamic'</span></span>)</code> </pre><br><br>  The configuration of the relationship is non-trivial and requires some explanation.  We use the <code>db.relationship</code> function to define the relationship between the tables, as we did in the previous article.  We will associate a <code>User</code> instance with another <code>User</code> instance, and for the agreement, we say that, in a pair of related users, the left user is subscribed to the right user.  As can be seen from the description of the relationship, we called the left side <code>followed</code> , because when we request the left side relationship, we get a list of subscribers.  Let's look at all the <code>db.relationship</code> arguments <code>db.relationship</code> by one: <br><ul><li>  <code>'User'</code> right side of the entity in the relationship (the left side is the parent class).  When we define self-referencing relationships, we use the same class on both sides. </li><li>  <code>secondary</code> indicates the pivot table used in this relationship. </li><li>  <code>primaryjoin</code> describes the connection of the left side of an entity with a pivot table.  Note that the <code>followers</code> table is not a model, so a slightly weird syntax is used to get to the field name. </li><li>  <code>secondaryjoin</code> describes the relationship of the right side with the pivot table. </li><li>  <code>backref</code> describes how this relationship will be available on the right side of the entity.  We said that for this user request <code>followed</code> returned all users on the right side that are associated with the user on the left.  The backlink is called <code>followers</code> and it will return all users on the left, who are associated with the user on the right.  The optional argument <code>lazy</code> indicates how this request is executed.  This mode indicates that the request will not be executed unless explicitly requested.  This is useful for improving performance, and also because we can get this request and change it before executing.  We will discuss this in more detail later. </li><li>  The <code>lazy</code> parameter is a bit like the parameter with the same name in the <code>backref</code> , but this one refers to the request, not the feedback. </li></ul><br><br>  Do not despair if it is difficult to understand.  We will see how to use these requests, and then everything will become clearer.  Since we made the database update, now we can create a new migration: <br><br><pre> <code class="bash hljs">./db_migrate.py</code> </pre><br><br>  This we completed the database changes.  It remains quite a bit. <br><br><h2>  Add and remove subscribers </h2><br>  To support reuse of the code, we will implement the subscription \ subscriber functionality within the <code>User</code> model and will not make it into the view.  Thus, we can use this function for the current application (refer from the view) and use it in testing.  In principle, it is always better to move the application logic from the view to the model, this greatly simplifies testing.  You have to keep the submissions as simple as possible, because they are harder to test automatically. <br><br>  Below is the code for adding and removing subscribers, defined as methods of the <code>User</code> model (file <code>app/models.py</code> ): <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... def follow(self, user): if not self.is_following(user): self.followed.append(user) return self def unfollow(self, user): if self.is_following(user): self.followed.remove(user) return self def is_following(self, user): return self.followed.filter(followers.c.followed_id == user.id).count() &gt; 0</span></span></code> </pre><br><br>  Thanks to the power of Alchemy SQL, which does a lot of work, these methods are surprisingly simple.  We simply add or remove items, and SQLAlchemy does the rest of the work.  The <code>follow</code> and <code>unfollow</code> defined so that they return an object when everything is successful, and None when the operation cannot be completed.  When the object returns, it must be added to the database and made a commit. <br><br>  The <code>is_following</code> method does quite a lot, despite one line of code.  We accept a query that returns all pairs <code>(follower, followed)</code> with user input and we filter them by the <code>followed</code> column.  From <code>filter()</code> returns the modified request, not yet executed.  Thus, we call <code>count()</code> on this query and now this query will be executed and will return the number of records found.  If we get at least one, then we will know that there are connections.  If we do not receive anything, then we will know that there are no connections. <br><br><h2>  Testing </h2><br>  Let's write a test for our code (file <code>tests.py</code> ): <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... def test_follow(self): u1 = User(nickname = 'john', email = 'john@example.com') u2 = User(nickname = 'susan', email = 'susan@example.com') db.session.add(u1) db.session.add(u2) db.session.commit() assert u1.unfollow(u2) == None u = u1.follow(u2) db.session.add(u) db.session.commit() assert u1.follow(u2) == None assert u1.is_following(u2) assert u1.followed.count() == 1 assert u1.followed.first().nickname == 'susan' assert u2.followers.count() == 1 assert u2.followers.first().nickname == 'john' u = u1.unfollow(u2) assert u != None db.session.add(u) db.session.commit() assert u1.is_following(u2) == False assert u1.followed.count() == 0 assert u2.followers.count() == 0</span></span></code> </pre><br><br>  After adding this test to the test framework, we can start the test suite with the command: <br><br><pre> <code class="bash hljs">./tests.py</code> </pre><br><br>  And if everything works, all tests will be successfully passed. <br><br><h2>  Queries to the database </h2><br>  Our current database model supports most of the requirements we listed at the beginning.  What we lack is, in fact, the most difficult to implement.  On the main page of the site will be shown messages written by all the people who are monitored by our logged in user, so we need a request that returns all these messages. <br><br>  The most obvious solution is a query that will give a list of tracked people that we can already do.  Then for each of these users, we will execute a request to get his messages.  When we have all the messages, we can combine them into a single list and sort them by time.  It sounds good?  Not really. <br><br>  This approach has a couple of problems.  What happens if a user tracks a thousand people?  We will have to perform a thousand queries to the database only to collect messages.  And now we have thousands of lists in memory that we need to sort and merge.  On our main page page numbers are implemented, so we will not show all available messages, but only the first 50, and the links on which the next 50 can be viewed. If we are going to show messages sorted by date, how do we know which of them are the last 50 messages all users, unless we first receive all the messages and sort them. <br><br>  In fact, this is a terrible solution that scales very badly.  Although this method of collecting and sorting somehow works, it is not effective enough.  This is exactly the job in which relational databases succeed.  The database contains indexes that allow it to perform queries and sorts much more efficiently than we can do it on our part. <br><br>  We have to come up with a query that expresses what we want to receive, and the database will calculate how to more effectively extract the information we need. <br><br>  To dispel the mystery, here is a request that will do what we need.  Unfortunately, this is another overloaded one-liner, which we add to the user's model ( <code>app.models.py</code> file): <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... def followed_posts(self): return Post.query.join(followers, (followers.c.followed_id == Post.user_id)).filter(followers.c.follower_id == self.id).order_by(Post.timestamp.desc())</span></span></code> </pre><br><br>  Let's try to decrypt this request step by step.  Here are 3 parts: join, filter, and order_by. <br><br><h3>  Joins </h3><br>  To understand what the join operation does, let's look at an example.  Suppose we have a <code>User</code> table with the following content: <br><br><table><tbody><tr><th colspan="2">  User </th></tr><tr><th>  id </th><th>  nickname </th></tr><tr><td>  one </td><td>  john </td></tr><tr><td>  2 </td><td>  susan </td></tr><tr><td>  3 </td><td>  mary </td></tr><tr><td>  four </td><td>  david </td></tr></tbody></table><br><br>  Other table fields are not displayed, so as not to complicate the example. <br><br>  Let's assume that our summary table says that the user ‚Äújohn‚Äù is subscribed to ‚Äúsusan‚Äù and ‚Äúdavid‚Äù, the user ‚Äúsusan‚Äù is subscribed to ‚Äúmary‚Äù and ‚Äúmary‚Äù is subscribed to ‚Äúdavid‚Äù.  Then the pivot table will look like this: <br><br><table><tbody><tr><th colspan="2">  followers </th></tr><tr><th>  follower_id </th><th>  followed_id </th></tr><tr><td>  one </td><td>  2 </td></tr><tr><td>  one </td><td>  four </td></tr><tr><td>  2 </td><td>  3 </td></tr><tr><td>  3 </td><td>  four </td></tr></tbody></table><br><br>  Finally, our <code>Post</code> table contains one post from each user: <br><br><table><tbody><tr><th colspan="3">  Post </th></tr><tr><th>  id </th><th>  text </th><th>  user_id </th></tr><tr><td>  one </td><td>  post from susan </td><td>  2 </td></tr><tr><td>  2 </td><td>  post from mary </td><td>  3 </td></tr><tr><td>  3 </td><td>  post from david </td><td>  four </td></tr><tr><td>  four </td><td>  post from john </td><td>  one </td></tr></tbody></table><br><br>  Some fields have also been removed here so as not to complicate the example. <br><br>  The following is part of our query with join isolated from the rest: <br><br><pre> <code class="python hljs">Post.query.join(followers, (followers.c.followed_id == Post.user_id))</code> </pre><br><br>  The <code>join</code> operation is called on the <code>Post</code> table.  There are two arguments, the first one is another table, in our case <code>followers</code> .  The second argument specifies which fields to join the table.  The <code>join</code> operation will make a temporary table with data from <code>Post</code> and <code>followers</code> merged according to the specified condition. <br><br>  In this example, we want the <code>followers</code> table fields to correspond to the <code>user_id</code> table <code>user_id</code> fields. <br><br>  To perform this merge, we take each record from the <code>Post</code> table (the left part of the join) and join the fields from the record in the <code>followers</code> table (the right part of the join) that match the condition.  If the record does not meet the condition, then it does not fall into the table. <br><br>  The result of the join on our example in this temporary table <br><br><table><tbody><tr><th colspan="3">  Post </th><th colspan="2">  followers </th></tr><tr><th>  id </th><th>  text </th><th>  user_id </th><th>  follower_id </th><th>  followed_id </th></tr><tr><td>  one </td><td>  post from susan </td><td>  2 </td><td>  one </td><td>  2 </td></tr><tr><td>  2 </td><td>  post from mary </td><td>  3 </td><td>  2 </td><td>  3 </td></tr><tr><td>  3 </td><td>  post from david </td><td>  four </td><td>  one </td><td>  four </td></tr><tr><td>  3 </td><td>  post from david </td><td>  four </td><td>  3 </td><td>  four </td></tr></tbody></table><br><br>  Notice how the message with user_id = 1 was removed from join, because there are no entries in the table of subscribers that there was followed_id = 1.  Also note that the message with user_id = 4 appears twice, because the table of subscribers has two entries with followed_id = 4. <br><br><h3>  Filters </h3><br>  The join operation gave us a list of messages from people that someone is following, without specifying who the subscriber is.  We are interested in a subset of this list, in which only those messages that are monitored by one particular user.  So we will filter this table by subscriber.  The part of the request with the filter will be as follows: <br><br><pre> <code class="python hljs">filter(followers.c.follower_id == self.id)</code> </pre><br><br>  Remember that the request is executed in the context of our target user, therefore the self.id method of the User class in this context gives the id of the user that interests us.  With this filter, we tell the database that we want to leave only those records from the table created with the help of join in which our user is specified as a subscriber.  Continuing our example, if we query users with id = 1, then we will come to another temporary table: <br><br><table><tbody><tr><th colspan="3">  Post </th><th colspan="2">  followers </th></tr><tr><th>  id </th><th>  text </th><th>  user_id </th><th>  follower_id </th><th>  followed_id </th></tr><tr><td>  one </td><td>  post from susan </td><td>  2 </td><td>  one </td><td>  2 </td></tr><tr><td>  3 </td><td>  post from david </td><td>  four </td><td>  one </td><td>  four </td></tr></tbody></table><br><br>  And this is exactly the posts that we need! <br><br>  Remember that the query was executed on the Post class, so even if we end up in a temporary table not related to any model, the result will be included in this temporary table, without additional columns added by the join operation. <br><br><h3>  Sorting </h3><br>  The final step in the process is to sort the results according to our criteria.  The part of the query that does this is as follows: <br><br><pre> <code class="python hljs">order_by(Post.timestamp.desc())</code> </pre><br><br>  Here we say that the results should be sorted by <code>timestamp</code> in descending order, so the first post will be the first. <br><br>  There is only one minor detail that can improve our query.  When users read posts that are subscribed to, they may want to see their own posts in the feed, and it would be nice to include them in the query result. <br><br>  There is an easy way to do this, which does not require any changes!  We just simply make sure that each user is added to the database as his own subscriber and this little problem will no longer concern us.  At the conclusion of our long discussion of queries, let's write a unit test for our query (file tests.py): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... from datetime import datetime, timedelta from app.models import User, Post #... class TestCase(unittest.TestCase): #... def test_follow_posts(self): # make four users u1 = User(nickname = 'john', email = 'john@example.com') u2 = User(nickname = 'susan', email = 'susan@example.com') u3 = User(nickname = 'mary', email = 'mary@example.com') u4 = User(nickname = 'david', email = 'david@example.com') db.session.add(u1) db.session.add(u2) db.session.add(u3) db.session.add(u4) # make four posts utcnow = datetime.utcnow() p1 = Post(body = "post from john", author = u1, timestamp = utcnow + timedelta(seconds = 1)) p2 = Post(body = "post from susan", author = u2, timestamp = utcnow + timedelta(seconds = 2)) p3 = Post(body = "post from mary", author = u3, timestamp = utcnow + timedelta(seconds = 3)) p4 = Post(body = "post from david", author = u4, timestamp = utcnow + timedelta(seconds = 4)) db.session.add(p1) db.session.add(p2) db.session.add(p3) db.session.add(p4) db.session.commit() # setup the followers u1.follow(u1) # john follows himself u1.follow(u2) # john follows susan u1.follow(u4) # john follows david u2.follow(u2) # susan follows herself u2.follow(u3) # susan follows mary u3.follow(u3) # mary follows herself u3.follow(u4) # mary follows david u4.follow(u4) # david follows himself db.session.add(u1) db.session.add(u2) db.session.add(u3) db.session.add(u4) db.session.commit() # check the followed posts of each user f1 = u1.followed_posts().all() f2 = u2.followed_posts().all() f3 = u3.followed_posts().all() f4 = u4.followed_posts().all() assert len(f1) == 3 assert len(f2) == 2 assert len(f3) == 2 assert len(f4) == 1 assert f1 == [p4, p2, p1] assert f2 == [p3, p2] assert f3 == [p4, p3] assert f4 == [p4]</span></span></code> </pre><br><br>  This test has a lot of pre-tuning code, but the test code itself is rather short.  First we check that the number of monitored posts returned for each user is equal to the expected one.  Then for each user, we check that the correct posts were returned and they came in the correct order (note that we inserted messages with timestamps guaranteeing always the same order). <br><br>  Note the use of followed_post () method.  This method returns a query object, not a result.  It also works lazy = "dynamic" in the relationship DB. <br><br>  It is always a good idea to return an object instead of a result, because it gives the caller the opportunity to complete the query before executing. <br><br>  There are several methods in the query object that trigger the query.  We have seen that count () executes the query and returns the number of results, discarding the data itself.  We also used first () to return the first result in the list and discard the rest.  In the test, we used the all () method to get an array with all the results. <br><br><h2>  Possible improvements </h2><br>  We have now implemented all the necessary functions of subscriptions, but there are several ways to improve our design and make it more flexible.  All social networks that we love to hate support similar communication paths of users, but they have more opportunities to manage information.  For example, it is not possible to block subscribers.  This will add another layer of complexity to our requests, as we now have to not only select users, but also weed out the posts of those users who have blocked us.  How to implement it? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simple way is another self-referencing table with a many-to-many relationship for recording who is blocking whom, and another join + filter in the query that returns tracked posts. </font><font style="vertical-align: inherit;">Another popular feature of social networks is the ability to group subscribers into lists to share their information with each group. </font><font style="vertical-align: inherit;">This also requires additional links and adds complexity to the queries. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not have these functions in the microblogging, but if it causes enough interest, I will be happy to write an article on this topic. </font><font style="vertical-align: inherit;">Let me know in the comments!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We put things in order </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are now quite advanced. </font><font style="vertical-align: inherit;">But although we solved the problems with database configuration and queries, we did not include new functionality in our application. </font><font style="vertical-align: inherit;">Fortunately for us, this is no problem. </font><font style="vertical-align: inherit;">We just need to fix the view functions and patterns to call new methods in the User model when necessary. </font><font style="vertical-align: inherit;">So let's do it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make ourselves our own subscriber. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We decided to mark all users subscribed to themselves, so that they could see their posts in the feed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are going to do this at the point where users are assigned the first account settings in the after_login handler for OpenID (the file 'app / views.py'):</font></font><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@oid.after_login def after_login(resp): if resp.email is None or resp.email == "": flash('Invalid login. Please try again.') return redirect(url_for('login')) user = User.query.filter_by(email = resp.email).first() if user is None: nickname = resp.nickname if nickname is None or nickname == "": nickname = resp.email.split('@')[0] nickname = User.make_unique_nickname(nickname) user = User(nickname = nickname, email = resp.email, role = ROLE_USER) db.session.add(user) db.session.commit() # make the user follow him/herself db.session.add(user.follow(user)) db.session.commit() remember_me = False if 'remember_me' in session: remember_me = session['remember_me'] session.pop('remember_me', None) login_user(user, remember = remember_me) return redirect(request.args.get('next') or url_for('index'))</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Links subscribe and unsubscribe </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, we define the functions of the subscription and unsubscribe presentation (file app / views.py): </font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/follow/&lt;nickname&gt;') @login_required def follow(nickname): user = User.query.filter_by(nickname = nickname).first() if user == None: flash('User ' + nickname + ' not found.') return redirect(url_for('index')) if user == g.user: flash('You can\'t follow yourself!') return redirect(url_for('user', nickname = nickname)) u = g.user.follow(user) if u is None: flash('Cannot follow ' + nickname + '.') return redirect(url_for('user', nickname = nickname)) db.session.add(u) db.session.commit() flash('You are now following ' + nickname + '!') return redirect(url_for('user', nickname = nickname)) @app.route('/unfollow/&lt;nickname&gt;') @login_required def unfollow(nickname): user = User.query.filter_by(nickname = nickname).first() if user == None: flash('User ' + nickname + ' not found.') return redirect(url_for('index')) if user == g.user: flash('You can\'t unfollow yourself!') return redirect(url_for('user', nickname = nickname)) u = g.user.unfollow(user) if u is None: flash('Cannot unfollow ' + nickname + '.') return redirect(url_for('user', nickname = nickname)) db.session.add(u) db.session.commit() flash('You have stopped following ' + nickname + '.') return redirect(url_for('user', nickname = nickname))</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This should be clear, but you should pay attention to the checks in which we try to prevent an error and try to provide a message to the user when a problem has occurred. </font><font style="vertical-align: inherit;">Now we have view functions, so we can connect them. </font><font style="vertical-align: inherit;">Links to subscribe or unsubscribe will be available on each user's profile page (file app / templates / user.html):</font></font><br><br><pre> <code class="python hljs">&lt;!-- extend base layout --&gt; {% extends <span class="hljs-string"><span class="hljs-string">"base.html"</span></span> %} {% block content %} &lt;table&gt; &lt;tr valign=<span class="hljs-string"><span class="hljs-string">"top"</span></span>&gt; &lt;td&gt;&lt;img src=<span class="hljs-string"><span class="hljs-string">""</span></span>&gt;&lt;/td&gt; &lt;td&gt; &lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.about_me %}&lt;p&gt;{{user.about_me}}&lt;/p&gt;{% endif %} {% <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.last_seen %}&lt;p&gt;&lt;i&gt;Last seen on: {{user.last_seen}}&lt;/i&gt;&lt;/p&gt;{% endif %} &lt;p&gt;{{user.followers.count()}} followers | {% <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.id == g.user.id %} &lt;a href=<span class="hljs-string"><span class="hljs-string">"{{url_for('edit')}}"</span></span>&gt;Edit your profile&lt;/a&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> g.user.is_following(user) %} &lt;a href=<span class="hljs-string"><span class="hljs-string">"{{url_for('follow', nickname = user.nickname)}}"</span></span>&gt;Follow&lt;/a&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> %} &lt;a href=<span class="hljs-string"><span class="hljs-string">"{{url_for('unfollow', nickname = user.nickname)}}"</span></span>&gt;Unfollow&lt;/a&gt; {% endif %} &lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> post <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> posts %} {% include <span class="hljs-string"><span class="hljs-string">'post.html'</span></span> %} {% endfor %} {% endblock %}</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the line in which there was an ‚ÄúEdit‚Äù link, we now show the number of subscribers that the user has and one of three possible links: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if the profile belongs to the logged in user, the button ‚ÄúEdit‚Äù will be visible </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> otherwise, if not subscribed to Subscribe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> otherwise, the "Unsubscribe" link </font></font></li></ul><br><br>     ,   ,     OpenID     . <br><br> ,          ,         ,      . <h2>  Final words </h2><br>       . <br>         ,     - ,        . <br>         ,   , ,     . <br><br>          : <br><br>  <a href="">microblog-0.8.zip</a> . <br><br>  ,         flask.      . <br><br>        .    ! <br>  <a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers-contacts-and-friends">Miguel</a> </div><p>Source: <a href="https://habr.com/ru/post/230643/">https://habr.com/ru/post/230643/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230631/index.html">Soap: all-in-one router for smart home</a></li>
<li><a href="../230633/index.html">Phalcon amazing framework</a></li>
<li><a href="../230635/index.html">WebCamp 2014 Live Webcast</a></li>
<li><a href="../230637/index.html">How to improve your programming style?</a></li>
<li><a href="../230639/index.html">The best rake of Russian IT startups</a></li>
<li><a href="../230645/index.html">Areas of application of homomorphic encryption</a></li>
<li><a href="../230647/index.html">Guarantees of getting the correct result when calculating dynamic systems</a></li>
<li><a href="../230649/index.html">Functional Javascript. We write our lenses, part 1</a></li>
<li><a href="../230651/index.html">An overview of the ST Nucleo developer platform using the example of Nucleo-F401RE</a></li>
<li><a href="../230655/index.html">Beaver mysql logger or how to find an error in the MySql application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>