<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SNORT as a service IPS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Much has been said about SNORT, but most articles deal with SNORT as a means of total network monitoring, which collects all data from ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SNORT as a service IPS</h1><div class="post__text post__text-html js-mediator-article"><h5>  Introduction </h5><br>  Much has been said about SNORT, but most articles deal with SNORT as a means of total network monitoring, which collects all data from the network interface.  In this article I will explain how to build a structure in which SNORT will not monitor all traffic on the interface in IPS mode, but only traffic that can be described using iptables rules.  I will not deal with setting up rules, it will be solely about how to build a SNORT on a bare system to work in IPS mode and how to approach the protection of an abstract service.  The assembly and launch of SNORT will also be described. <br><br><a name="habracut"></a><h4>  How does it work? </h4><br>  Having entered SNORT, the packet passes through decoders and preprocessors successively and only then it enters the detector, which begins to apply the rules.  The task of the decoders is to ‚Äúpull out‚Äù the data of the network and transport layer (IP, TCP, UDP) from the data link layer protocols (Ethernet, 802.11, Token Ring ...). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e92/c4c/ba4/e92c4cba44ba3d654b52f824a4673583.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task of preprocessors is to prepare data from transport and network protocols to the process of applying the rules.  For our case, we will use a preprocessor for working with TCP, the list of tasks it solves in general is: <br><ul><li>  Condition monitoring (protocol monitoring) </li><li>  Session assembly (merging data from multiple session packages) </li><li>  Protocol normalization (rather slippery feature with editing the packet header on the fly) </li></ul><br>  Competent preprocessing can significantly improve system performance and reduce the amount of garbage data entering the detector.  Also, due to the peculiarities of the architecture, it is possible to connect a self-written preprocessor to SNORT relatively easily. <br><br>  As a result, ‚Äúoverpacks‚Äù are formed before being sent to the detector, to which the rules begin to apply.  The process of applying the rules is reduced to searching in the ‚Äúoverpack‚Äù defined in the rule signatures.  The rules themselves consist of a description of the traffic, the desired signature, a description of the threat and a description of the reaction to detection. <br><br><h4>  Compile SNORT. </h4><br>  Downloading the latest Ubuntu 11.04.  The installation is described for a 32-bit system.  Download everything you need: <br><br> <code>daq-0.5.tar.gz <br> libdnet-1.11.tar.gz <br> libnetfilter_queue-1.0.0.tar <br> libnfnetlink-1.0.0.tar <br> libpcap-1.1.1.tar.gz <br> pcre-8.12.zip <br> snort-2.9.0.5.tar.gz <br> snortrules-snapshot-2903.tar.gz</code> <br> <br>  Install the necessary bags: <br><br> <code>apt-get install bison flex gcc g++ zlib1g-dev</code> <br> <br>  We configure and install downloaded software from source in the following order: <br><br> <code>pcre-8.12.zip <br> libpcap-1.1.1.tar.gz <br> libdnet-1.11.tar.gz <br> libnfnetlink-1.0.0.tar <br> libnetfilter_queue-1.0.0.tar <br> daq-0.5.tar.gz</code> <br> <br>  For configure scripts, it is better to force the installation directories in order to avoid unpleasant surprises. <br><br> <code>./configure --libdir=/usr/lib --includedir=/usr/include</code> <br> <br>  If during the daq configuration we see the line <b>‚ÄúBuild NFQ DAQ module ...: yes‚Äù</b> and everything compiles without problems, then we are on the right track.  Now the key moment of the whole undertaking is the assembly of SNORT: <br><br> <code>./configure --libdir=/usr/lib --includedir=/usr/include --enable-ipv6 --enable-gre --enable-targetbased --enable-decoder-preprocessor-rules --enable-active-response --enable-normalizer --enable-reload --enable-react --enable-zlib</code> <br> <br>  <b>--enable-ipv6</b> - IP v6 support (all of a sudden, captain!). <br>  <b>--enable-gre</b> - GRE support encapsulation. <br>  <b>--enable-targetbased</b> - support the collection of fragmented packets. <br>  <b>--enable-decoder-preprocessor-rules</b> - support for rules for reacting to anomalies detected in traffic when preprocessors and decoders work. <br>  <b>--enable-active-response</b> - support for embedding in a packet session when a rule is triggered. <br>  <b>--enable-normalizer</b> - support for protocol normalizer. <br>  <b>--enable-reload</b> - the ability to load / unload rules without restarting SNORT. <br>  <b>--enable-react</b> - support immediate session break (RST) when the rule is triggered. <br>  <b>--enable-zlib</b> - support for processing compressed traffic. <br><br>  Next <b>make;</b>  <b>make install</b> .  SNORT is installed. <br><br><h4>  Set up a combat start. </h4><br>  The freshly downloaded snort config makes a heavy impression on an inexperienced user, but if you understand its structure, then it‚Äôs easy to understand.  A shortened version of the minimal config itself, which solves our problem in general, looks like this: <br><br> <code>#  1:     <br> #     <br> var HOME_NET any <br> var RULE_PATH ../rules <br> #  2:   <br> config disable_decode_alerts <br> ‚Ä¶‚Ä¶ <br> #  3:   <br> #     <br> config pcre_match_limit: 3500 <br> ‚Ä¶‚Ä¶ <br> #  5:   <br> #    <br> #    ,  ,,   <br> preprocessor normalize_ip4 <br> ‚Ä¶. <br> #     <br> preprocessor frag3_global: max_frags 65536 <br> ‚Ä¶ <br> #       <br> preprocessor stream5_global: max_tcp 8192, track_tcp yes, track_udp ‚Ä¶. <br> ‚Ä¶ <br> #  6:     <br> include classification.config <br> ‚Ä¶.. <br> #  7:   <br> include $RULE_PATH/test.rules <br></code> <br>  For simplicity, in the test.rules file we will have only one rule: <br> <code>reject tcp any any -&gt; any any (msg:"Test pattern for snort abc123"; content:"abc123"; classtype:shellcode-detect; sid:310; rev:1;)</code> <br>  This rule says that if an <b>abc123</b> substring is detected in incoming tcp packets, then an RST will be sent to the source immediately and the session will be terminated.  Dangerous package on the IPS will not get into the system.  Run SNORT: <br><br> <code>snort -Q --daq nfq --daq-var queue=2 -c /home/ubuntu/Downloads/snort/etc/snort.conf -l /var/log/snort -A full</code> <br> <br>  <b>-Q</b> - work in IPS mode <br>  <b>--daq</b> - package source <br>  <b>--daq-var</b> - package source options <br>  <b>-c</b> - path to config <br>  <b>-l</b> - path to logs <br>  <b>-A full</b> - detailed logs (description of attacks and traffic dumps) <br>  <b>-D</b> - work in daemon mode (use when everything is debugged) <br><br>  If the launch has broken off with errors, then you should not be sad - most likely you need to correct the paths to the files in the config file. <br><br><h4>  Creating a queue. </h4><br>  The system packet filter can be configured to transfer the received packet from the kernel level to the user level, where the user program will process it and send it back to the kernel level, in our case this program is SNORT.  Since SNORT is running in order to work with a numbered queue (NFQUEUE), we need to supply filtered traffic in this queue: <br>  <b>iptables -t nat -A PREROUTING -p tcp --dport 8080 -j NFQUEUE --queue-num 2</b> <br><br><h5>  Why was the PREROUTING chain chosen? </h5><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c58/2ca/19e/c582ca19e3ea755168920b13fa637777.png" alt="image"><br><br>  In the Iptables model, the packet enters the <b>PREROUTING</b> base queue before any routing rules are applied to it.  Sending a packet to SNORT at this stage is convenient in that we can either process it locally or forward it further, for example, using NAT.  The advantage of using numbered queues is that you can create several queues and pass traffic from each queue through a snort running with a set of rules sharpened by the filtered traffic.  A serious disadvantage of this approach is that in case of a SNORT crash, the protected service becomes unavailable, since there is no one to transfer data from user mode back to the kernel.  After starting SNORT and creating a queue, you should immediately check the operation, sending, for example, via netcat, the signature from the rule - <b>abc123 to the queue.</b>  If everything was done correctly, the connection will be immediately terminated. <br><br><h4>  Monitoring </h4><br>  Starting with the described parameters, SNORT will, for each identified threat, write an alert file (it can also write to the database or send a syslog): <br><br> <code>[**] [1:310:1] Test pattern for snort abc123 [**] <br> [Classification: Executable Code was Detected] [Priority: 1] <br> 01/19-12:03:12.155213136 172.16.249.1:56473 -&gt; 172.16.249.130:8080 <br> TCP TTL:64 TOS:0x0 ID:1241 IpLen:20 DgmLen:59 DF <br> ***AP*** Seq: 0x9510F391 Ack: 0xC40C0E14 Win: 0x8218 TcpLen: 32 <br> TCP Options (3) =&gt; NOP NOP TS: 125531844 9470333</code> <br> <br>  And to write to the log file a piece of the session in which the signature was detected, this can be useful for detecting detection errors.  This is where SNORT‚Äôs work ends and ‚ÄúSNORT log analysis systems‚Äù come into play.  De facto, these are sets of scripts of varying degrees of wretchedness, to which, in some cases, the heartbreaking ‚Äúweb interface‚Äù is attached (BASE, ACID ...).  Their main disadvantages are the inability to perform flexible data analysis and inefficient work with the DBMS, which results in the inability to work with large amounts of data.  In my experience, the only solution that makes working with snort logs bearable is Splunk.  In general, Splunk is a log management system that saves them, indexes and provides a convenient interface for working with the resulting database.  This is proprietary software, which is conditionally free (the amount of indexed data per day is not more than 500Mb, which is more than enough for snort).  The system combines the convenience of management and the ability to work with large amounts of data, and most importantly: for this system there is a plug-in, specially sharpened to work with the SNORT logs.  Download Splunk <a href="http://www.splunk.com/download">here.</a> <br><br>  Install splunk: <br> <code>dpkg -i splunk-4.2.1-98164-linux-2.6-intel.deb</code> <br>  Run: <br> <code>/opt/splunk/bin/splunk start</code> <br> <br>  We go to the web-face, we find and install the plugin: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/249/110/ea12491105d8381337e446d90c1443d0.png" alt="image"><br>  Next, add the data source - the file.  There, everything is intuitive and the only subtle point is that the Source Type must be manually set: <b>snort_alert_full</b> .  When everything is ready, we generate an alert (via netcat we send abc123 to the protected port).  And we see in splunk: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/528/882/462/5288824629769b8b43a2521c26ab62bd.png" alt="image"><br><br>  The column to the left shows the data that the parser recognized and on which indexes are built for the incoming data.  Using this data, you can analyze using the built-in query language, you can build graphs, you can display sources on the map, and much, much more. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/530/af2/e2b/530af2e2ba61d8cc82d7c6eb77e888fd.png" alt="image"><br><br>  In addition, the process of creating your own plug-ins is described on the manufacturer's website, which allows you to create your own plugin, which will be customized for a specific task. <br><br><h6>  Conclusion </h6><br>  Before launching a snort into a production unit, so that it doesn‚Äôt have excruciating pain later, <br><ul><li>  Build a version control system for rules and store rules on a third-party host (SVN is quite suitable). </li><li>  Develop a plan for emergency operation (if snort fell, and traffic does not go). </li><li>  Recovery plan in case the hardware snort fails with data loss. </li><li>  Create a test rule of the type described above abc123, which should check the work of the snort every time after making any changes. </li></ul><br>  I am pleased to answer questions. </div><p>Source: <a href="https://habr.com/ru/post/123474/">https://habr.com/ru/post/123474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123465/index.html">Songsterr - the results of three years</a></li>
<li><a href="../123466/index.html">Arduino? - Not! IDuino - Yes! (Part 1)</a></li>
<li><a href="../123467/index.html">Unlock for iPhone 4</a></li>
<li><a href="../123469/index.html">WaterSpout - web server for asynchronous data transfer</a></li>
<li><a href="../123473/index.html">Estimation of the number of errors in the program. Double evaluation, Historical experience</a></li>
<li><a href="../123477/index.html">Introducing Oracle Siebel CRM</a></li>
<li><a href="../123480/index.html">Postsharp. We solve the problem of caching</a></li>
<li><a href="../123484/index.html">Testers! All on Ciklum QA Subbotnik (July 16)!</a></li>
<li><a href="../123485/index.html">New efficiency record for solar cells</a></li>
<li><a href="../123489/index.html">DataRetriever - a service for collecting and analyzing data from online media and social networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>