<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing serializers for .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Serbench code is on github . 

 Project start 
 This benchmark project began with the article ‚Äú Serializers in .NET v.2 ‚Äù on GeeksWithBlogs.net. T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing serializers for .NET</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://github.com/aumcode/serbench">The Serbench code is on github</a> . <br><br><h4>  Project start </h4><br>  This benchmark project began with the article ‚Äú <a href="http://geekswithblogs.net/LeonidGaneline/archive/2015/05/06/serializers-in-.net.-v.2.aspx">Serializers in .NET v.2</a> ‚Äù on GeeksWithBlogs.net.  The article reviewed quite a lot of serializers available under .NET.  But in order to turn this article and the corresponding code into a real benchmark, it was necessary to make several improvements. <br><br>  First, serializers had to be tested on several data types.  There are universal serializers, and there are specialized ones.  Specialized work very well with only a few data types, for other data they work much worse or do not work at all.  What we have seen in the future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Secondly, serializers differ greatly in interfaces.  Our benchmark should not force the serializer to follow our interface selection.  On the contrary, the benchmark must be so flexible that each serializer can use the interface that is most suitable for it.  That is, it is necessary to transfer additional parameters of a specific serializer to the benchmark. <br><a name="habracut"></a><br>  The author of one of the serializers asked the author of the <a href="https://github.com/leo-gan">article</a> to make an improved test.  <a href="https://github.com/itadapter">The author of the serializer</a> was the initiator of this project, he was also the lead developer.  <a href="https://github.com/sergey-msu">Sergey</a> was the developer of the entire Web part of the project, all the great reports.  <a href="https://github.com/aumcode/nfx">NFX was</a> used as a benchmark <a href="https://github.com/aumcode/nfx">platform</a> , which made it possible to do everything planned (and much, much more) very quickly.  NFX pulls on hundreds of similar articles, I hope it will interest you too. <br><br><h4>  Presentation of test results </h4><br>  To begin with, I will dwell a bit on presenting the results, on what requires special attention. <br><br>  For example, look at the summary information of one of the tests: <br><br><img src="https://habrastorage.org/files/ea1/941/18b/ea194118ba0e4ceca93c0fd51252b774.jpg" width="804" height="410"><br><br>  On the left we will see three winners in the two most important categories: in speed and in the size of the data being serialized.  At once I will make a reservation that there can be more winners, that all serializers that have fallen into the blue, green and, to a lesser, light brown category can be considered winners.  The gray category is serializers that did not pass this test. <br><br>  In the speed column, you can click on the name of the serializer and get a decryption of speed with separate numbers by serialization and deserialization. <br><br>  The worst speed from serialization and deserialization is taken as the main one.  We assume that the total system performance is important to you, and not just serialization or only de-serialization.  Your case may be different, so the speed of another operation is also given on the chart with a thin stick. <br><br><h5>  What to look for: </h5><br><ul><li>  For serializers that did not pass the test: </li></ul><br>  On some tests, <b>most of the</b> tested serializers lost data.  If you choose a ‚Äúfast‚Äù serializer to work with, and it will spoil your data, this is the worst thing you can imagine.  You will spend a lot of time trying to understand the cause of the corrupted data.  And you are lucky if you stumble upon it in development, and not in production. <br><br><ul><li>  Match your data with test data: </li></ul><br>  Our recommendation: download the benchmark code, change the test data or add your data and test it again.  Never trust your intuition, do not trust extrapolation.  Virtually any serializer will fall on some particular amount of data.  We did not perform marginal tests, do them yourself according to your data.  Very few serializers have passed all of our tests. <br>  Attention! <br>  Further on in the text you will constantly come across the words ‚Äúusually‚Äù, ‚Äúmost often‚Äù, etc.  I apologize for this and understand that this makes the test results a bit uncertain.  I hope that you also understand that the test results should not show us the best serializer.  They only limit the group of serializers that you need to base.  You will use the serializer for YOUR data.  Therefore, the final decision should be taken after running tests on ITS data, especially if these data are very different from those used in our tests. <br><h5>  What NOT to pay attention to: </h5><br><ul><li>  If the tests show the difference in numbers several times, do not pay attention to the difference in percentages.  This is not only meaningless, but also wrong.  Small variations in speed or size can be easily distorted by slightly changing the test data. </li></ul><br><h4>  Test data </h4><br>  We tried to provide data for the most used applications.  We have no statistics on the use of serializers, so we selected data based on our own experience.  If you see that we missed something important, let us know or just add your test data to Serbench. <br><br>  We see typical applications in several areas: <br><ul><li>  <b>distributed, independent systems (distributed systems)</b> .  Programs work independently, in different processes or on different machines, and exchange data.  Programs exchange only contracts, interfaces.  Under this type of fall <b>messaging system (messaging)</b> . </li></ul><br>  Data relating to this type: Typical Person, Telemetry, EDI, Batching. <br><br><ul><li>  <b>distributed but tightly coupled systems</b> .  The difference from the previous case is that systems can exchange not only contracts, but also libraries.  Most often, these related systems are developed in one place.  This type includes <b>RPC</b> (Remote Procedure Call) systems. </li></ul><br>  Data related to this type: Typical Person, Batching, Object Graph. <br><br><ul><li>  <b>storage systems</b> .  Data is transferred between programs and data stores.  The difference from the previous cases is that the serialization-deserialization cycle does not occur within microseconds or seconds.  Data can be stored for years.  During the retention period, data contracts often change, which raises the problem of data versioning.  We have not tested serializers to work with versions.  Any of the available test data can work with storage systems.  But serializers that support data versioning may be more convenient in this case. </li></ul><br><h5>  Typical Person </h5><br>  Here is a simple class with no interfaces and no inheritance.  Almost all presented serializers pass this test. <br><br><h5>  Telemetry </h5><br>  Such data is generated by IoT (Internet of Things) devices.  Their difference is the availability of numerical information, timestamps and several identifiers.  Sometimes data is very short when one or more numbers are sent;  sometimes large arrays of numbers are sent.  The data structure is simple.  The speed and density of data packing is important here. <br><br><h5>  Edi </h5><br>  EDI (Electronic Data Interchange) data are equivalent documents.  They are characterized by a complex hierarchical structure and nesting of classes.  There are collections of classes. <br><br><img src="https://habrastorage.org/files/33a/a5d/a0d/33aa5da0deac4a7e834d34fbd9cb7e74.jpg" width="825" height="772"><br><br><h5>  Object graph </h5><br>  If you use object-oriented development, you probably had to deal with such classes.  They are characterized by complex relationships between classes.  We are testing the Conference class, which has a collection of Events (Event).  An event can have several participants (Participant) and several Topics (Conference Topic). <br><br>  Interestingly, a participant can have multiple Relationships, each of which refers to another participant.  The result is cyclic links.  This is a common situation, but it turns out that very few serializers can work with cyclic connections. <br><br><img src="https://habrastorage.org/files/46a/ca6/d59/46aca6d59eb24950840a672e9197ce1c.jpg"><br><br><h5>  Batching </h5><br>  Imagine a situation where you need to send multiple instances of objects at once.  This is a typical situation in distributed systems.  By combining several data items into one packet, which is transmitted over the network in one step, we can significantly speed up the transfer.  The package is called batch, hence the name - batching. <br><br>  Usually, we need to explicitly create a package by enclosing data elements in a special envelope class.  Some serializers allow you to do without envelopes, which greatly simplifies development. <br><br><h4>  Testing process </h4><br>  Everything is simple here.  In one test cycle, we will serialize an object or many objects in the case of a batch, and immediately diserialize it back.  The target and source objects are compared to filter out errors.  The comparison is quick, only for some values.  We do not make a full comparison, but all interfaces for a full comparison are available. <br><br>  Several test cycles are combined into one run (run), at the beginning of which the test data is generated. <br><br>  Several tests are combined in sequences, the first test in which is the warmup test.  This test usually consists of a single loop, the purpose of which is to initialize all the objects necessary for a given serializer. <br><br>  Some serializers quickly initialize, but slowly serialize, some - vice versa.  If you need to use the serializer once, then you should not neglect the results of warm-up tests, for you they are the main ones. <br><br>  We usually tested a single object first, and then a collection of objects.  As it turned out, serializers can be optimized for working with collections.  Then they can break from outsiders to the leaders. <br><br>  Any data, but usually collections, can be very large, which can lead to a sharp slowdown in the work of the serializer, or lead to errors.  In some unpleasant situations, the serializer simply hung the system. <br><br><h3>  Test results </h3><br>  We list the winners in the tests, only in the sum of all tests.  The winners in the individual tests are very well represented on the test results pages on the <a href="http://aumcode.github.io/serbench/">site</a> .  Here we draw some conclusions.  I draw your attention to the fact that we do not claim the ultimate truth, we only comment on the numbers.  Numbers can change a lot with future test updates. <br><br><h5>  Typical Person </h5><br>  <a href="http://aumcode.github.io/serbench/Specimens_Typical_Person/web/overview-charts.htm">Test results</a> <br><br>  I will review this test in detail.  The rest of the tests - just mostly. <br><br><h6>  All tests </h6><br>  Almost all the tests revealed the same fast serializers: ProtoBuf, NFX Slim, MsgPack, NetSerializer.  The warm-up tests gave a very large velocity spread.  Microsoft BinaryFormatter showed good packaging on the collections and the worst on the same site.  Unfortunately, Json.Net did not break into the lead in any test. <br><br><h6>  Warm Up Tests (Warmup) </h6><br><h6>  Speed </h6><br>  There is an amazing speed variation.  NFX Slim does thousands of operations, and, for example, Jil has only one operation per second.  The bulk of serializers does one or two dozen operations per second, sometimes a few dozen.  What is even more amazing, NFX Slim makes about 45 thousand!  deserializations per second.  But for obvious reasons, we consider only the slowest operation. <br><br><h6>  Packaging </h6><br>  The spread is not as large as in speeds.  Several winners show almost the same result and JSON serializers, which naturally, show similar results.  We specifically made two tests for one of the JSON serializers (NFX Json).  One of the tests gives JSON text in a beautiful format, with all indents and line breaks, and the other test gives JSON without formatting.  As you can see, the sizes for both cases are quite different from each other. <br><br>  This result once again confirms the well-known rule: <i>never format the serialized data in the channel!</i>  <i>Do formatting for presentation only and never for data transfer.</i> <br><br><h5>  Batching </h5><br>  <a href="http://aumcode.github.io/serbench/MsgBatching/web/overview-charts.htm">Test results</a> <br><br>  Only ProtoBuf, Microsoft BinaryFormatter and NFX Slim can perform batching serialization.  At the same time, Slim has a special batching mode. <br><br>  There is a large variation in rates for different types of data.  Winners vary from ProtoBuf for Trading and EDI classes, to Slim for RPC and Personal classes.  At the same time, ProtoBuf could not serialize the RPC class in which the object [] field was encountered.  It can be summarized that only Microsoft BinaryFormatter and NFX Slim successfully passed this test.  Microsoft BinaryFormatter, as always, showed excellent results in warm-up tests and consistently worse results in packaging, which does not detract from the fact that it worked without errors. <br><br><h5>  Object graph </h5><br>  <a href="http://aumcode.github.io/serbench/ObjectGraph_Conference/web/overview-charts.htm">Test results</a> <br><br>  This test was the most difficult to serialize.  Many serializers have not passed it.  Many have passed, but at the same time showed terrible speed and packaging.  For example, Jil on the test <b>ObjectGraph:</b> Conferences: 1;  Participants: 250;  Events: 10 packed data in 2.6 MB, and leaders packed data in a little more than 100 KV, that is, they spent 26 times less memory. <br><br>  In this test, we see several leaders who win by a very large margin.  This is ProtoBuf and NFX Slim.  Microsoft BinaryFormatter unexpectedly turned out to be among these leaders in terms of packaging. <br><br><h5>  EDI X12 </h5><br>  <a href="http://aumcode.github.io/serbench/EDI_X12_835/web/overview-charts.htm">Test results</a> <br><br>  It was interesting how with the growth of the data volume more and more serializers ended up working with errors. <br><br>  As usual on the warming-up dough, the leader is NFX Slim. <br><br>  It seems that the leaders in the package: ProtoBuf, MsgPack, NetSerializer, NFX Slim - use special packaging methods for such cases and these methods work very well. <br><br>  I draw your attention to the fact that XML, which is often used for serialization and processing of EDI documents, showed, in the face of the XmlSerializer, disgusting results in packaging, using 8-9 times more space for serialized data. <br><br><h3>  Serializer Selection </h3><br>  Why do we need to choose a serializer?  Why can't we do with the serializers from the .NET Framework?  (Microsoft supplies several serializers, some of which have appeared quite recently, such as Bond and Avro.) <br><br>  The fact is that serializers are becoming increasingly important elements of distributed systems.  A slow serializer can interfere with maximum performance; a fast one can make your system better than its competitors.  New serializers for .NET now appear with an enviable constancy.  Each of them is advertised as the fastest.  As proof of the creators cite test results. <br><br>  We have developed our own test system and conducted an independent study.  Now we will discuss the criteria that will help you make an informed choice of the serializer.  The selection criteria are based on the results of the tests performed. <br><br><h5>  <i>Serialization Reliability</i> </h5><br>  We were surprised to find that many serializers do not pass elementary tests.  At best, we got an error in the program, at worst, the data was lost without any warning, or Windows was hanging for an indefinite time.  In the intermediate case, the objects were distorted. <br><br>  Carefully read the results of our tests.  These results are very dependent on data.  If the data is simple in structure, then almost any serializers do the job.  If the data is complex or large, then, alas, all is not so good. <br><br>  I emphasize reliability, because it‚Äôs unlikely that the speed or density of data packing will be an excuse for lost data or a hung system. <br><br>  Surely, the most reliable serializer is <a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v%3Dvs.110).aspx">Microsoft BinaryFormatter</a> .  He is not the fastest, but there is an important reason.  It serializes almost everything without errors. <br><br><h5>  <i>Do you choose the data format?</i> </h5><br>  For example, you receive data from a partner in XML format, and you must work with XML.  You have no opportunity to change this situation.  In this case, your choice is limited to XmlSerializer and Json.Net. <br><br>  If you integrate your system with foreign systems, the choice will be made for you, and you will most likely have to use one of two standard formats: XML or JSON.  In rare cases, you will have to work with the CSV format or with the format of a particular system.  Most often this happens when integrating with systems from the past millennium. <br><br>  If you need to serialize simple .NET types, such as int, double, bool, then the elementary function ToString () is enough for you. <br><br>  JSON serializers are more common.  JSON is much simpler than XML, which in most cases is an advantage. <br><br>  Many serializers pack data into their own binary format.  JSON format is usually much more compact than XML.  Binary formats are usually smaller than JSON. <br><br>  If you can choose the data format yourself, the binary format is most likely the best choice.  But remember, in this case, you must use the same serializer for both serialization and deserialization.  At the moment, all binary formats are unique, none of them is standardized. <br><br><h5>  <i>Data packing density</i> </h5><br>  What is more important: serialization-deserialization speed or data packing density? <br><br>  The size of serialized data is usually more important than the speed of the serialization-deserialization process.  This is due to the fact that the speed of the processor (the speed that determines serialization-deserialization) is much higher than the speed of the data in the network, which is usually directly related to the size of the transmitted data.  A 10% reduction in data size can lead to a 10% acceleration of data transfer, and a two-fold increase in the serialization-deserialization rate only to a 1% acceleration. <br><br><h5>  <i>Are you trying to squeeze maximum performance out of your system?</i>  <i>Or maybe the performance of developers is more important for you?</i> </h5><br><br>  Look, for example, at serializers such as Bond, Thrift, Cap'n Proto.  You don't just take and serialize any classes.  You need to use a special IDL language and describe these classes for nothing.  Usually you will be helped by utilities that generate class descriptions from the classes themselves.  But even if they are, you need to deal with this language, take time away from the development itself. <br><br>  Other serializers, for example, <a href="https://github.com/aumcode/nfx">Slim</a> from NFX, do not require anything from you.  You simply serialize any classes.  In intermediate cases, the classes being serialized need to be decorated with attributes.  Surely you know the attribute [Serializable]. <br><br>  Is this important?  Yes it can be important.  Especially when your classes are not trivial in structure.  For example, in our test system, you will find an EDI test class composed of dozens of nested classes and hundreds of fields.  Adding attributes to all these classes and fields was a tedious and lengthy job. <br><br>  This is also important when you serialize classes from <b>libraries whose code you do not have access to</b> .  You can not take the code and add attributes there, the code is not available.  Often, to circumvent this situation, programmers use the so-called DTO ( <a href="https://en.wikipedia.org/wiki/Data_transfer_object">Data Transfer Object</a> ).  Their use is fraught with the complexity of the program and the drop in the speed of development.  Instead of working on business logic, you have to write code that has nothing to do with it. <br><br><h5>  <i>Do you select a serializer for serialization and for deserialization, or just for one of these operations?</i> </h5><br>  If your system is only the receiving or sending side, then you will agree that this is different from the case when you are responsible for both operations. <br><br><h5>  <i>Do you have collections in your data?</i> </h5><br>  Serializers can be optimized to work with collections of objects.  Other serializers do not distinguish the collection in any way, so they will show much worse speed and packaging. <br><br><h5>  <i>What is the size of your data?</i> </h5><br>  Data can be very large, which can lead to a sharp slowdown of the serializer or lead to errors in serialization.  The serializer can just hang the system. <br><br>  Big data in memory can affect garbage collection, which in turn can cause long stops for programs. <br><br><h5>  <i>Do you need to serialize something very extraordinary?</i> </h5><br>  And here you will be helped by serializers specializing in exactly this task.  Here for example, the <a href="">serializer engaged Linq expressions</a> . <br><br><h5>  <i>Do you need super super performance?</i> </h5><br>  Then the best option would be to write your own highly specialized serializer. <br><br>  If you do not want to do this, then pay attention to the additional methods used by different serializers.  For example, <b>batching</b> is a great way to increase speed.  Unfortunately, only a few serializers can use it without additional encoding. <br><br>  <b>Parallel serialization is</b> also a good method for achieving high speeds.  If you use it, the <b>thread-safety of the</b> serializer is important for you. </div><p>Source: <a href="https://habr.com/ru/post/263705/">https://habr.com/ru/post/263705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263695/index.html">The ideal way to implement a static code analyzer</a></li>
<li><a href="../263697/index.html">Central Park NY: official app redesign</a></li>
<li><a href="../263699/index.html">How-to: responsive emails in Gmail</a></li>
<li><a href="../263701/index.html">Modernization of operational data center</a></li>
<li><a href="../263703/index.html">Another hack FL.ru</a></li>
<li><a href="../263707/index.html">Who are the content hackers?</a></li>
<li><a href="../263711/index.html">SysLogViewer - simplify the process of analyzing AudioCodes logs</a></li>
<li><a href="../263713/index.html">Evolution of the Top Story application interface</a></li>
<li><a href="../263715/index.html">HP Software - a modern approach to building an IT and business services monitoring system</a></li>
<li><a href="../263717/index.html">Landing Page and lead generation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>