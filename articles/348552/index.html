<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extending and using the Linux Crypto API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[0] Intro 


 The Linux cryptographic API was introduced from version 2.5.45 of the kernel. Since then, the Crypto API has been overgrown with all pop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extending and using the Linux Crypto API</h1><div class="post__text post__text-html js-mediator-article"><h2 id="0-intro">  [0] Intro </h2><br><p>  <em>The</em> <em>Linux</em> cryptographic <em>API</em> was introduced from version 2.5.45 of the kernel.  Since then, the <em>Crypto API</em> has been overgrown with all popular (and not only) international standards: </p><br><ul><li>  symmetric encryption: <em>AES</em> , <em>Blowfish</em> , ... </li><li>  Hashing: <em>SHA1 / 256/512</em> , <em>MD5</em> , ... </li><li>  imitation protection: <em>hMAC-SHA1 /</em> <em>256/512</em> , <em>hMAC-MD5</em> , ... </li><li>  <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">AEAD</a> : <em>AES-GCM</em> , <em>ChaCha20-Poly1305</em> , ... </li><li>  generating pseudo random numbers: <em>FIPS</em> , ... </li><li>  asymmetric encryption: <em>RSA</em> </li><li>  key agreement: <em>DH</em> , <em>ECDH</em> </li><li>  compression: <em>Deflate</em> , <em>ZLIB</em> </li></ul><br><p>  This cryptography is available and is mainly used by various kernel subsystems (in the <em>kernel space</em> ): <em>IPsec</em> , <em>dm-crypt</em> , etc. It is also possible to use the <em>Crypto API</em> functions from <em>user space</em> ( <em>user space</em> ) through a <em>Netlink</em> interface, where, starting with 2.6.38 kernel, the _AF <em>ALG</em> family is introduced, which provides access to the kernel cryptography from the <em>user space of the</em> code.  However, the existing functionality is sometimes not enough, thus there is a need to extend the <em>Crypto API</em> with new algorithms. </p><a name="habracut"></a><br><p>  So, about two years ago, I was faced with the task of embedding national (in the Republic of Belarus) cryptography into the <em>IPsec</em> implementation of the <em>Linux kernel</em> (version 3.13).  At that time, I never did programming in the <em>kernel space,</em> and this was my first experience in writing kernel modules, with which <strong>Robert Love</strong> 's book <strong>Linux Kernel: Description of the Development Process</strong> helped me a lot.  It was much more difficult to deal with the <em>Crypto API itself</em> - in the mentioned book this question is not covered in principle, and in the <a href="https://www.kernel.org/doc/html/v4.13/crypto/index.html">official documentation</a> , although a rather detailed description of the architecture is given, there is almost no information about the implementation of new algorithms.  In my search, in the Hacker magazine, I came across a wonderful <a href="https://xakep.ru/2009/01/20/46840">article</a> , popularly telling <em>how to use the Crypto API</em> , but, again, there is not a word about its extension.  In the end, I turned to the original source (kernel code) for the knowledge I needed, and decided to solve the problem. </p><br><p>  Some time has passed since then, and only now, having actualized my knowledge, I took up writing this text.  It is about the <em>crypto api</em> .  With specific examples, we will look at how arbitrary algorithms can be built into the <em>Crypto API</em> and how to access them from both the <em>kernel space</em> and the <em>user space</em> .  I am sure that this material will be extremely useful for developers who are faced with similar problems, but I hope that the casual reader can find here something interesting for himself.  Welcome under the cut! </p><br><p>  PS The compiled source codes of my programs, fragments of which will appear below, are available on <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor"><em>github</em></a> .  There is also the source of this article.  All code was written and tested under desktop Ubuntu 16.04 LTS with kernel version 4.13.0-32-generic.  Some of the interfaces that I used in the modules were introduced in 4 versions of the kernel, therefore on kernels 3. * they are <em>NOT</em> compiled for sure. </p><br><hr><br><h2 id="1-arhitektura-crypto-api">  [1] Crypto API Architecture </h2><br><p>  Before we start writing the code, let's talk a little about how things work in the <em>Crypto API</em> .  However, I was told about this in detail in the <a href="https://www.kernel.org/doc/html/v4.13/crypto/architecture.html">documentation</a> , but I, in turn, will cite only a squeeze, which should be enough to understand the material.  Immediately make a reservation, then we will discuss mainly symmetric encryption, other types of crypto-transformations, in general, work in a similar way, but the numerous nuances would greatly complicate everything. </p><br><p>  So, from the introduction, we already know that the cryptographic subsystem of the kernel includes many implementations of cryptographic algorithms and provides the interfaces accessible to the user (hereinafter, the user and developer mean, respectively, the <em>API user</em> and the <em>API developer</em> ).  In terms of the <em>Crypto API</em> , the algorithms are called "transformations" ( <em>transformations</em> ), for example, different types of transformations have their own sub- <em>API</em> , and the descriptors (handles) of transformations are usually named " <em>tfm</em> ", for example: </p><br><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_cipher</span></span></span></span> *tfm = crypto_alloc_cipher(<span class="hljs-string"><span class="hljs-string">"aes"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Here <em>tfm</em> is the handle of some transformation, in this case, the encryption of the data block using the <em>AES</em> algorithm.  The life cycle of the <em>Crypto API</em> handle is reduced to three stages: </p><br><ul><li>  create / initialize handle </li><li>  performing the necessary cryptooperations through the handle </li><li>  handle destruction </li></ul><br><p>  Regardless of the algorithm used, implementations of the basic functions of <em>encrypting a single</em> data <em>block</em> are available through the <code>crypto_cipher</code> type handle, and the <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"><em>Single Block Cipher API</em></a> ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"><em>API</em></a> ) provides methods for key installation and block encryption / decryption.  As a standalone <em>API,</em> it is not of great interest to the user, however, from the point of view of the developer, it is important, since it uses the key concept of the <em>Crypto API</em> - the so-called "templates".  Templates are used in conjunction with the basic functions and implement: </p><br><ul><li>  block encryption modes ( <em>ECB</em> , <em>CBC</em> , <em>CFB</em> , <em>CTR</em> , ...) </li><li>  key-independent hashing mode ( <em>hMAC</em> ) </li><li>  <em>AEAD</em> encryption modes </li><li>  functions that are not related to direct data encryption, for example - parallelization ( <em>pcrypt</em> ) </li></ul><br><p>  When creating a handle (see example above), the required algorithm is specified by a string ‚Äî the name of the algorithm; this string has the following semantics: </p><br><pre> <code class="markdown hljs">template(single block cipher/message digest)</code> </pre> <br><p>  In addition, where applicable, the templates can be wrapped in other templates: </p><br><pre> <code class="markdown hljs">template<span class="hljs-emphasis"><span class="hljs-emphasis">_a(template_</span></span>b(single block cipher/message digest))</code> </pre> <br><p>  In this case, the use of templates without the basic algorithm is impossible.  I will give a few examples: </p><br><ul><li>  <em>aes</em> - <em>AES</em> base encryption algorithm </li><li>  <em>cbc (aes)</em> - <em>AES</em> encryption algorithm in the cipher block concatenation ( <em>CBC</em> ) mode </li><li>  <em>sha1</em> - <em>SHA1</em> hashing algorithm </li><li>  <em>hmac (sha1)</em> is a key-independent hashing algorithm (imitation protection) with the <em>SHA1</em> hash function </li><li>  <em>authenc (hmac (sha1), cbc (aes))</em> - <em>AEAD</em> with <em>AES-CBC</em> encryption algorithm and <em>hMAC (SHA1)</em> imitation algorithm </li></ul><br><p>  The use of symmetric block ciphers in any mode is carried out through a separate <em>API</em> .  It is worth noting that now there are three such <em>APIs</em> in the core, however two of them are <em>deprecated</em> , and the <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"><em>Symmetric Key Cipher API</em></a> is relevant.  This <em>API</em> provides the user with methods for setting the key / syncing and encrypting / decrypting data of arbitrary length, it is also <em>non-blocking</em> (asynchronous) - encryption methods quickly return control to the caller, while the request to perform crypto operation and the callback function used for notification user about the completion of the operation, passed to the system scheduler.  <em>The Symmetric Key Cipher API</em> will be discussed in detail when we proceed to create a kernel module testing our embedded algorithm. </p><br><p>  In addition to the two mentioned, in the <em>Crypto API</em> there are sub- <em>APIs</em> for: </p><br><ul><li>  <em>AEAD</em> Encryption ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-aead.html"><em>Authenticated Encryption With Associated Data (AEAD) Cipher API</em></a> ) </li><li>  blocking hashing / <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-digest.html"><em>synchronization message digest API</em></a> </li><li>  non-blocking hashing / asynchronous <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-digest.html"><em>message digest API</em></a> </li><li>  generating pseudo-random numbers ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-rng.html"><em>Random Number API</em></a> ) </li><li>  Asymmetric Encryption ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-rng.html"><em>Asymmetric Cipher API</em></a> ) </li><li>  <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-kpp.html"><em>Key Agreement</em></a> ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-kpp.html"><em>Key-agreement Protcol Primitives (KPP) Cipher API</em></a> ) </li></ul><br><p>  For a developer, the presence of templates in the <em>Crypto API</em> means that by embedding a new symmetric encryption algorithm, it suffices to implement only the basic block encryption function, which can then be encapsulated into the corresponding templates to obtain the required modes.  <strong>But it is not so.</strong>  Indeed, if you look at the source code of the algorithms included in the core ( <em>crypto / aes_generic.c</em> , <em>crypto / blowfish_generic.c</em> , ...), you can see that only basic functions are implemented there.  However, if we in the same way implement the encryption function of the classic <em>GOST 28147-89</em> block, ‚Äúwrap‚Äù it in the gamming mode ( <em>CTR</em> template), and then check the resulting algorithm on test sequences, then we will get the wrong result!  The thing is that the gammating mode described in <em>GOST</em> differs from the gamming algorithm implemented in the <em>CTR</em> template.  The same applies to other national algorithms with which I dealt.  In such cases, it is necessary to embed high-grade block ciphers in the desired modes, as is done, for example, in an optimized implementation of the <em>AES</em> algorithm ( <em>AES-NI</em> - <em>arch / x86 / crypto / aesni-intel_glue.c</em> ).  Later we will look at both embedding options. </p><br><p>  Perhaps this is all I wanted to say about architecture.  Those interested in a more detailed description should refer to the <a href="https://www.kernel.org/doc/html/v4.13/crypto/architecture.html">documentation</a> , and my presentation should be enough so that we can move on. </p><br><hr><br><h2 id="2-podgotovka-pochvy">  [2] Soil preparation </h2><br><p>  So, we are ready to start embedding some new algorithm in the <em>Crpyto API</em> , with the only reservation that we do not yet have an algorithm that could be embedded.  For this article, I did not bother to implement the "real" cryptoalgorithm, since I could hardly do it qualitatively (leave it to the cryptographers).  On the other hand, it would be not so interesting to make a ‚Äúdummy‚Äù <em>cipher</em> ( <em>null cipher</em> ), especially since there is already one in the kernel.  Thus, we compromise and write the implementation of an elementary encryption algorithm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/303/cc3/265/303cc3265be54ed476594f65674d8ace.svg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/940/f8d/92d/940f8d92d1ac3857a38a2d08d6da098b.svg"></div><br><p>  Where: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0c5/724/5db/0c57245dbd3c18e987498491056a7911.svg" alt="inline_formula">  - ciphertext block </li><li><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f88/9e6/6a0f889e65ee5874186066fc8cd43fbc.svg" alt="inline_formula">  - plaintext block </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ab7/107/747/ab71077472a1edfcec1d89b9acbae694.svg" alt="inline_formula">  - key </li><li><img src="https://habrastorage.org/getpro/habr/post_images/38c/158/78b/38c15878bbbafd451916fa718c076dc4.svg" alt="inline_formula">  - operation "exclusive OR" ( <em>XOR</em> ) </li></ul><br><p>  The block and key sizes for this algorithm are assumed to be equal to 128 bits (16 bytes). </p><br><p>  We can start implementation.  We define the crypto context of our algorithm and the function to create / destroy context: </p><br><pre> <code class="hljs rust">#define XOR_CIPHER_KEY_SIZE <span class="hljs-number"><span class="hljs-number">16</span></span> typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher_ctx</span></span></span></span> xor_cipher_ctx; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher_ctx</span></span></span></span> { uint8_t key[XOR_CIPHER_KEY_SIZE]; }; xor_cipher_ctx* xor_cipher_allocate() { xor_cipher_ctx *cipher = calloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(xor_cipher_ctx)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cipher; } void xor_cipher_free(xor_cipher_ctx *ctx) { memset(ctx-&gt;key, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, XOR_CIPHER_KEY_SIZE); free(ctx); }</code> </pre> <br><p>  Add key installation methods and block encryption / decryption: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XOR_CIPHER_BLOCK_SIZE 16 void xor_cipher_set_key(xor_cipher_ctx *ctx, uint8_t *key) { memmove(ctx-&gt;m_key, key, XOR_CIPHER_KEY_SIZE); } void xor_cipher_crypt_block(xor_cipher_ctx *ctx, uint8_t *dst, uint8_t *src) { for (int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; XOR_CIPHER_BLOCK_SIZE; i++) { dst[i] = src[i] ^ ctx-&gt;key[i]; } }</span></span></span></span></code> </pre> <br><p>  Given the reversibility of the " <em>XOR</em> " operation, the <code>xor_cipher_crypt_block</code> method <code>xor_cipher_crypt_block</code> used to encrypt and decrypt simultaneously. </p><br><p>  Block encryption is good, but it will be even better if we implement any of the block encryption modes, for example, <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">the cipher block chaining ( <em>CBC</em> ) mode</a> : </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/b89/819/21cb89819f62e4c9954bab449892d9ec.svg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/d3d/277/afad3d27760082b4dd6f41f5251e14dc.svg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/53d/331/9bd53d3318426661b03dddc58e4e02f5.svg"></div><br><p>  Where: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/458/c2d/5d9/458c2d5d97f927f98d3891a846032716.svg" alt="inline_formula">  - synchro send </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8bc/8f5/2eb/8bc8f52ebbff9e91ad38872f265ce649.svg" alt="inline_formula">  , <img src="https://habrastorage.org/getpro/habr/post_images/347/cc2/538/347cc2538753abac13c3be8d4bb34f4e.svg" alt="inline_formula">  - the function of encrypting and decrypting the block on the key <img src="https://habrastorage.org/getpro/habr/post_images/ab7/107/747/ab71077472a1edfcec1d89b9acbae694.svg" alt="inline_formula">  respectively </li></ul><br><p>  Let's continue the work, we will implement the methods of encryption and decryption in the mode of coupling blocks of cipher. </p><br><div class="spoiler">  <b class="spoiler_title">Encryption</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_encrypt_cbc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xor_cipher_ctx *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_iv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blocks = len / XOR_CIPHER_BLOCK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> leftover = len - (blocks * XOR_CIPHER_BLOCK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *dst = _dst, *src = _src, *iv = _iv; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; blocks; i++) { memmove(dst, src, XOR_CIPHER_BLOCK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; XOR_CIPHER_BLOCK_SIZE; j++) { dst[j] ^= iv[j]; } xor_cipher_crypt_block(ctx, dst, dst); iv = dst; dst += XOR_CIPHER_BLOCK_SIZE; src += XOR_CIPHER_BLOCK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftover) { memmove(dst, src, leftover); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; leftover; i++) { dst[i] ^= iv[i]; dst[i] ^= ctx-&gt;key[i]; } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Decryption</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_decrypt_cbc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xor_cipher_ctx *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_iv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blocks = len / XOR_CIPHER_BLOCK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> leftover = len - (blocks * XOR_CIPHER_BLOCK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> u[XOR_CIPHER_BLOCK_SIZE], iv[XOR_CIPHER_IV_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *dst = _dst, *src = _src; memmove(iv, _iv, XOR_CIPHER_IV_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; blocks; i++) { memmove(u, src, XOR_CIPHER_BLOCK_SIZE); xor_cipher_crypt_block(ctx, dst, src); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; XOR_CIPHER_BLOCK_SIZE; j++) { dst[j] ^= iv[j]; } memmove(iv, u, XOR_CIPHER_IV_SIZE); dst += XOR_CIPHER_BLOCK_SIZE; src += XOR_CIPHER_BLOCK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftover) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; leftover; i++) { dst[i] = src[i] ^ ctx-&gt;key[i]; dst[i] ^= iv[i]; } } }</code> </pre> </div></div><br><p>  Now this is more interesting!  Now, using this implementation, we can prepare test sequences, on which, later on, we will check the implementation of the same algorithm in the kernel.  Under the spoiler - the values ‚Äã‚Äãthat I used. </p><br><div class="spoiler">  <b class="spoiler_title">Test sequences</b> <div class="spoiler_text"><table><thead><tr><th>  Block encryption </th><th></th></tr></thead><tbody><tr><td>  Key </td><td> <code>2f 1b 1a c6 d1 be cb a2 f8 45 66 0d d2 97 5c a3</code> </td> </tr><tr><td>  <strong>Test number 1</strong> </td><td></td></tr><tr><td>  Input data </td><td> <code>cc 6b 79 0c db 55 4f e5 a0 69 05 96 11 be 8c 15</code> </td> </tr><tr><td>  Output </td><td> <code>e3 70 63 ca 0a eb 84 47 58 2c 63 9b c3 29 d0 b6</code> </td> </tr><tr><td>  <strong>Test number 2</strong> </td><td></td></tr><tr><td>  Input data </td><td> <code>53 f5 f1 ef 67 a5 ba 6c 68 09 b5 7a 24 de 82 5f</code> </td> </tr><tr><td>  Output </td><td> <code>7c ee eb 29 b6 1b 71 ce 90 4c d3 77 f6 49 de fc</code> </td> </tr></tbody></table><br><table><thead><tr><th>  <em>CBC</em> Encryption </th><th></th></tr></thead><tbody><tr><td>  Key </td><td> <code>ec 8d 93 30 69 7e f8 63 0b f5 58 ec de 78 24 f2</code> </td> </tr><tr><td>  Synchro parcel </td><td> <code>db 02 1f a8 5a 22 15 cf 49 f7 80 8b 7c 24 a1 f3</code> </td> </tr><tr><td>  Plain text </td><td> <code>6e 96 50 42 84 d2 7e e8 44 9b 75 1d e0 ac 0a 58 ee 40 24 cc 32 fc 6e c4 e2 fc d1 f5 76 6a 45 9a e4 88 ba d6 12 07 28 86</code> </td> </tr><tr><td>  Ciphertext </td><td> <code>59 19 dc da b7 8e 93 44 06 99 ad 7a 42 f0 8f 59 5b d4 6b 26 ec 0c 05 e3 ef 90 24 63 ea e2 ee 31 53 d1 42 c0 97 75 d5 06</code> </td> </tr></tbody></table><br><table><thead><tr><th>  <em>CBC</em> decryption </th><th></th></tr></thead><tbody><tr><td>  Key </td><td> <code>ec 8d 93 30 69 7e f8 63 0b f5 58 ec de 78 24 f2</code> </td> </tr><tr><td>  Synchro parcel </td><td> <code>db 02 1f a8 5a 22 15 cf 49 f7 80 8b 7c 24 a1 f3</code> </td> </tr><tr><td>  Ciphertext </td><td> <code>db e9 1d c6 1f 13 1a 5a 34 2b 90 1e c3 b1 6f e9 52 1b 91 7f 8d 8f 6d b4 42 87 ad 85 5f 2d 89 7d</code> </td> </tr><tr><td>  Plain text </td><td> <code>ec 66 91 5e 2c 4f f7 f6 76 29 48 79 61 ed ea e8 65 7f 1f 89 fb e2 8f 8d 7d 59 65 77 42 e4 c2 66</code> </td> </tr></tbody></table></div></div><br><p>  The sources for the implementation of the algorithm and the testing program are available <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor/samples/xor-cipher">here</a> , and we are almost ready to go into the <em>kernel space</em> , but before that I want to draw your attention to one important point.  The fact is that many well-known encryption algorithms do not involve processing the last <em>incomplete</em> block of input data.  For example, implementations of the algorithm of <em>GOST 28147-89 MUST</em> return an error sign if the size of the input data is not a multiple of the block size, while the Belarusian <em>Belt</em> provides for such processing.  My algorithm also provides for it (the key and the current value of synchromy are truncated to the size of an incomplete block).  This fact will play its role a little later, while you just have to keep this in mind. </p><br><hr><br><h2 id="3-pogruzhenie-v-yadro">  [3] Immersion in the core </h2><br><p>  The action is transferred to the kernel space.  Programming in the kernel is somewhat different from programming in user space and, due to the complexity of debugging, is a rather time-consuming process.  However, while working on this material, I did not set myself the task of acquainting the reader with the basics of programming kernel modules, because even without this I have written enough, including here, on <a href="https://habrahabr.ru/post/343828/">Habr√©</a> ( <a href="https://habrahabr.ru/post/117654/">more</a> ; and <a href="https://habrahabr.ru/post/138328">more</a> ).  Therefore, if the reader is completely unfamiliar with writing modules, then I would recommend to first look at the materials that I cited above, or to search on my own (I assure you, this will not take much time).  And with those who are ready to go further, we begin a deep study of the <em>Crypto API</em> . </p><br><p>  So, we have an algorithm, and we want to build it into the kernel, but where do we start?  Of course, with the documentation.  Unfortunately, the section devoted to the <a href="https://www.kernel.org/doc/html/v4.13/crypto/devel-algos.html">development / integration of algorithms</a> provides only very general knowledge of this process, but at least it helps to orient in the right direction.  Specifically, we learn about the existence of functions responsible for registering and deregistering algorithms in the kernel.  Let's understand: </p><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/crypto.h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_register_alg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crypto_alg *alg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_register_algs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crypto_alg *algs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_unregister_alg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crypto_alg *alg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_unregister_algs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crypto_alg *algs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  These functions return a negative value in the event of an error, and 0 - in the case of successful completion, and (once) the registered algorithm (s) are described by the <code>crypto_alg</code> structure, let's look at its definition ( <em>include / linux / crypto.h</em> ): </p><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/crypto.h */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_alg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cra_list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cra_users</span></span></span><span class="hljs-class">;</span></span> u32 cra_flags; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cra_blocksize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cra_ctxsize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cra_alignmask; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cra_priority; <span class="hljs-keyword"><span class="hljs-keyword">atomic_t</span></span> cra_refcnt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cra_name[CRYPTO_MAX_ALG_NAME]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cra_driver_name[CRYPTO_MAX_ALG_NAME]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_type</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cra_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ablkcipher_alg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ablkcipher</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blkcipher_alg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blkcipher</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cipher_alg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cipher</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compress_alg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compress</span></span></span><span class="hljs-class">;</span></span> } cra_u; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*cra_init)(struct crypto_tfm *tfm); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*cra_exit)(struct crypto_tfm *tfm); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*cra_destroy)(struct crypto_alg *alg); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cra_module</span></span></span><span class="hljs-class">;</span></span> } CRYPTO_MINALIGN_ATTR;</code> </pre> <br><p>  Fortunately, this structure is very well documented, and we don‚Äôt have to guess about the meaning of this or that field: </p><br><ul><li>  <strong><code>cra_flags</code></strong> : a set of flags describing the algorithm.  Flags are defined by constants starting with " <code>CRYPTO_ALG_</code> " in <em>include / linux / crypto.h</em> , and are used to tune the algorithm description. </li><li>  <strong><code>cra_blocksize</code></strong> : the byte size of the algorithm block.  All types of transformations, except for hashing, return an error when trying to process data that is smaller than this value. </li><li>  <strong><code>cra_ctxsize</code></strong> : the byte size of the <strong><code>cra_ctxsize</code></strong> .  The kernel uses this value when allocating memory for context. </li><li>  <strong><code>cra_alignmask</code></strong> : alignment mask for input and output.  The buffers for the input and output of the algorithm must be aligned with this mask.  This is mandatory for algorithms running on hardware that is unable to access data at arbitrary addresses. </li><li>  <strong><code>cra_priority</code></strong> : the priority of this implementation of the algorithm.  If more than one transformation with the same <strong><code>cra_name</code></strong> registered in the kernel, then when accessing by this name, the algorithm with the highest priority will be returned </li><li>  <strong><code>cra_name</code></strong> : the name of the algorithm.  The kernel uses this field to search for implementations. </li><li>  <strong><code>cra_driver_name</code></strong> : a unique name for the implementation of the algorithm.  If more than one transformation with the same <strong><code>cra_name</code></strong> registered in the kernel, and you need to request an algorithm with a lower priority, then you need to contact this name </li><li>  <strong><code>cra_type</code></strong> : type of crypto-transform.  Pointer to an instance of a <code>crypto_type</code> structure that implements callback functions common to all conversion types.  Available options: <code>&amp;crypto_blkcipher_type</code> , <code>&amp;crypto_ablkcipher_type</code> , <code>&amp;crypto_ahash_type</code> , <code>&amp;crypto_rng_type</code> .  This field should be left blank for the following transformation types: block encryption ( <code>cipher</code> ), compression ( <code>compress</code> ), blocking hashing ( <code>shash</code> ) </li><li>  <strong><code>cra_u</code></strong> : actually, the implementation of the algorithm.  One of the union structures must be filled with specific functions defined by the type of transformation.  This field should be left blank for blocking and non-blocking hashing ( <code>ahash</code> ) </li><li>  <strong><code>cra_init</code></strong> : initialization function of the transform instance.  This function is called once, during the creation of the instance (immediately after the memory is allocated for crypto context).  In this function, you should perform various preparatory actions, if such are necessary (for example, allocating additional memory, checking hardware capabilities).  Otherwise, the field can be left blank. </li><li>  <strong><code>cra_exit</code></strong> : deinitialize the transform instance.  In this function, you should perform actions that are inverse to those that were performed in <strong><code>cra_init</code></strong> , if any.  Otherwise, the field can be left blank. </li><li>  <strong><code>cra_module</code></strong> : the owner of this conversion implementation.  The value should be set to <code>THIS_MODULE</code> </li></ul><br><p>  Undocumented remaining fields are intended for internal use and should not be filled.  It seems to be nothing complicated.  To begin with, we want to embed the implementation of the block encryption algorithm, so let's take a look at the <code>cipher_alg</code> structure from the <code>cra_u</code> union: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/crypto.h */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> cipher_alg { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cia_min_keysize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cia_max_keysize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*cia_setkey)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_tfm *tfm, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *key, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keylen); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*cia_encrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_tfm *tfm, u8 *dst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *src); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*cia_decrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_tfm *tfm, u8 *dst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *src); };</code> </pre> <br><p>  It is still simpler and, it seems to me, does not need clarification.  Now we are ready to see how all this works in practice.  By the way, note that the function signatures in the <code>cipher_alg</code> structure <code>cipher_alg</code> similar to the function signatures from the <em>API of</em> our algorithm in 2 parts </p><br><p>  We write the kernel module.  We define the <code>cipher_alg.cia_setkey</code> and the key installation function in accordance with the <code>cipher_alg.cia_setkey</code> signature: </p><br><pre> <code class="hljs rust">#define XOR_CIPHER_KEY_SIZE <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher_ctx</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> key[XOR_CIPHER_KEY_SIZE]; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int xor_cipher_setkey(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_tfm</span></span></span></span> *tfm, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> *key, unsigned int len) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher_ctx</span></span></span></span> *ctx = crypto_tfm_ctx(tfm); <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> *flags = &amp;tfm-&gt;crt_flags; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len != XOR_CIPHER_KEY_SIZE) { *flags |= CRYPTO_TFM_RES_BAD_KEY_LEN; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } memmove(ctx-&gt;key, key, XOR_CIPHER_KEY_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  In the <em>API of</em> our algorithm, the <code>crypto_tfm_ctx</code> context was passed to the functions directly, but here the functions are taken by the handle of the <code>tfm</code> algorithm, from which, then, the context is retrieved using the <code>crypto_tfm_ctx</code> function.  Also, here we check the length of the transferred key.  If the length is incorrect, then we set the corresponding flag ( <code>CRYPTO_TFM_RES_BAD_KEY_LEN</code> ) and return the <code>EINVAL</code> code (22: <em>Invalid argument</em> ). </p><br><p>  Now, we define the block encryption function in accordance with <code>cipher_alg.cia_encrypt</code> : </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_crypt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crypto_tfm *tfm, u8 *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8 *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> xor_cipher_ctx *ctx = crypto_tfm_ctx(tfm); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; XOR_CIPHER_BLOCK_SIZE; i++) { <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[i] ^ ctx-&gt;key[i]; } }</code> </pre> <br><p>  Here is nothing new.  Just like in the original <em>API</em> , we will not define an additional function for decryption, and <code>cipher_alg.cia_decrypt</code> simply initialize the <code>cipher_alg.cia_decrypt</code> pointer with the <code>cipher_alg.cia_decrypt</code> function. </p><br><p>  Finally, we define an instance of the <code>crypto_alg</code> structure, fill it in and call the registration and deregistration functions of the algorithm, respectively, after loading and before unloading the module: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_alg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher</span></span></span><span class="hljs-class"> = {</span></span> .cra_name = <span class="hljs-string"><span class="hljs-string">"xor-cipher"</span></span>, .cra_driver_name = <span class="hljs-string"><span class="hljs-string">"xor-cipher-generic"</span></span>, .cra_priority = <span class="hljs-number"><span class="hljs-number">100</span></span>, .cra_flags = CRYPTO_ALG_TYPE_CIPHER, .cra_blocksize = XOR_CIPHER_BLOCK_SIZE, .cra_ctxsize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct xor_cipher_ctx), .cra_module = THIS_MODULE, .cra_u = { .cipher = { .cia_min_keysize = XOR_CIPHER_KEY_SIZE, .cia_max_keysize = XOR_CIPHER_KEY_SIZE, .cia_setkey = xor_cipher_setkey, .cia_encrypt = xor_cipher_crypt, .cia_decrypt = xor_cipher_crypt } } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto_register_alg(&amp;xor_cipher); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ crypto_unregister_alg(&amp;xor_cipher); }</code> </pre> <br><p>  Given all the above, no questions should arise here.  If, having compiled and loaded such a module, execute the command " <code>cat /proc/crypto</code> " in the terminal, then you can find your own in the list of registered algorithms: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> : xor-cipher driver : xor-cipher-generic module : xor_cipher priority : <span class="hljs-number"><span class="hljs-number">100</span></span> refcnt : <span class="hljs-number"><span class="hljs-number">1</span></span> selftest : passed <span class="hljs-type"><span class="hljs-type">internal</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> : cipher blocksize : <span class="hljs-number"><span class="hljs-number">16</span></span> min keysize : <span class="hljs-number"><span class="hljs-number">16</span></span> max keysize : <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br><p>  Not bad, huh?  But this is only the beginning, and now, in theory, I had to move on to writing a module testing our algorithm, but still, I decided not to mix the issues of embedding and use.  Therefore, we will be tested later, and in the next part we will see how we can embed the implementation of our algorithm in the mode of coupling cipher blocks. </p><br><hr><br><h2 id="31-nemnogo-bolee-glubokoe-pogruzhenie-v-yadro">  [3.1] "A little deeper" immersion into the core </h2><br><p>  I run a little forward.  The attentive reader remembers the existence of patterns.  So, having implemented block encryption in the last part, we can easily wrap this implementation in the <em>CBC</em> template and get the implementation of our algorithm in the cipher block chaining mode, but after testing it on my sequences, the <em>CBC</em> mode encryption call returns error code 22 ( <code>EINVAL</code> ).  And now is the time to recall what I said about the processing of an incomplete block of input data and the <code>crypto_alg.cra_blocksize</code> field.  The fact is that the implementation of the <em>CBC</em> kernel mode has no idea how to handle an incomplete block.  Moreover, by wrapping our algorithm in <em>CBC</em> mode, the kernel registers a new algorithm, the block size of which is equal to the block size of the basic algorithm.  After calling the "cipher" encryption function by the cbc algorithm <em>(xor-cipher)</em> , the size of the input data is checked for the multiplicity of the block size and, if they are not multiples, the function returns <code>EINVAL</code> .  The size of the test vector for encryption in <em>CBC</em> mode (40 bytes) was deliberately chosen not to be a multiple of the block size.  In my opinion, if an encryption standard provides for processing an incomplete block, and the implementation does not, then such an implementation will hardly be checked for compliance with the standard, even if the implementation gives the correct result when the multiplicity condition is met (in this case, it is).  Therefore, now we will make the full implementation of the cipher block linkage mode for our algorithm.     2  ,            <em>API</em> <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html">  </a> ,      <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"> <em>API</em></a> , ,   ,   .        <em>Symmetric Key Cipher API</em> . </p><br><p>          ,  ,          ,    ,      <em>Crypto API</em> ,    . ,     ( <em>arch/x86/crypto/aesni-intel_glue.c</em> ), ,   ,      . ,        / : </p><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* include/crypto/internal/skcipher.h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_register_skcipher</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skcipher_alg *alg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_register_skciphers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skcipher_alg *algs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_unregister_skcipher</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skcipher_alg *alg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_unregister_skciphers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skcipher_alg *algs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><p>     <code>skcipher_alg</code> : </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* include/crypto/skcipher.h */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> skcipher_alg { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*setkey)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_skcipher *tfm, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *key, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keylen); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*encrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> skcipher_request *req); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*decrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> skcipher_request *req); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*init)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_skcipher *tfm); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*exit)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_skcipher *tfm); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> min_keysize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max_keysize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivsize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunksize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> walksize; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_alg base; };</code> </pre> <br><p>    ,    <em>include/crypto/skcipher.h</em>   . ,        <code>struct crypto_alg</code> ,  ,  ,  <code>init</code>  <code>exit</code> ,       <code>crypto_alg</code> . ,   ,   <code>chunksize</code>  <code>walksize</code> : </p><br><ul><li> <strong><code>chunksize</code></strong> :          ,    ,    ( <em>stream cipher</em> ),      , ,    ,        ( <em>underlying</em> ) . ,   ,      .       ( <code>skcipher_alg.base.cra_blocksize</code> )  ,    <code>chunksize</code>      ,     </li><li> <strong><code>walksize</code></strong> :   <code>chunksize</code> ,   ,       ,  <code>walksize</code>   ,  <code>chunksize</code> ,       </li></ul><br><p>          <code>encrypt</code>  <code>decrypt</code> .  <code>skcipher_request</code>  ,      :   /   ,     .        ,        <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html">- <em>API</em></a> , ,  ,     ,     . </p><br><p>   ,    <em>Crypto API</em>  .   ,   - <em>API</em>       /         (   <em>API</em>  ),     <code>scatterlist</code> . , ,    <em>Synchronous Block Cipher API</em> : </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/crypto.h */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> crypto_blkcipher_encrypt(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> blkcipher_desc *desc, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *dst, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *src, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbytes);</code> </pre> <br><p>  <code>skcipher_request</code>     <code>struct scatterlist *src</code>  <code>struct scatterlist *dst</code>      .      <code>scatterlist</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/scatterlist.h */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scatterlist</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> page_link; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> };</code> </pre> <br><p>         . ,     <code>sg_init_one</code> : </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* include/linux/scatterlist.h */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sg_init_one(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *sg, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buflen);</code> </pre> <br><p>  <a href="https://xakep.ru/2009/01/20/46840"></a> : </p><br><blockquote>      ,   "" buf ( <code>page_link</code> ),     buf     ( <code>offset</code> ). </blockquote><p>  ,       .     ,    : </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_blkcipher</span></span></span></span> *tfm; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blkcipher_dest</span></span></span></span> desc; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scatterlist</span></span></span></span> sg[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> *first_segment, *second_segment; <span class="hljs-comment"><span class="hljs-comment">/* crypto and data allocation... */</span></span> sg_init_table(sg, <span class="hljs-number"><span class="hljs-number">2</span></span>); sg_set_buf(&amp;sg[<span class="hljs-number"><span class="hljs-number">0</span></span>], first_segment, len); sg_set_buf(&amp;sg[<span class="hljs-number"><span class="hljs-number">1</span></span>], second_segment, len); crypto_blkcipher_encrypt(&amp;desc, &amp;sg, &amp;sg, <span class="hljs-number"><span class="hljs-number">2</span></span>*len);</code> </pre> <br><p> , <code>first_segment</code>  <code>second_segment</code>   , <em></em>  .  , <em>Crypto API</em> (    )      "" <code>scatterlist</code> -,  "" ( <em>scattered</em> ) .    <a href="https://www.kernel.org/doc/Documentation/crypto/api-intro.txt"></a>   <em>Crypto API</em>     <em>IPsec</em> : </p><br><blockquote> One of the initial goals of this design was to readily support IPsec, so that processing can be applied to paged <a href="http://vger.kernel.org/~davem/skb.html">skb's</a> without the need for linearization. </blockquote><p>   , <code>scatterlist</code>     <em>API</em>       /      ( <em>Direct Memory Access</em> , <em>DMA I/O</em> ).       /    ,  ""     , , , <a href="https://lwn.net/Articles/256368/">    </a> . </p><br><p>     .     ,      : </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xor_skcipher_setkey(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_skcipher *tfm, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *key, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xor_cipher_setkey(crypto_skcipher_tfm(tfm), key, len); }</code> </pre> <br><p>  Everything is simple here.   <em>CBC</em>         ( <code>struct xor_cipher_ctx</code> ),      ,       ,  . </p><br><p>     . </p><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cbc_encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct skcipher_request *req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_tfm</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tfm</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_skcipher_tfm</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_skcipher_reqtfm</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class">));</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xor_cipher_ctx</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_tfm_ctx</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tfm</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skcipher_walk</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">walk</span></span></span><span class="hljs-class">;</span></span> u32 nbytes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, blocks; u8 *src, *dst, *iv; skcipher_walk_virt(&amp;walk, req, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); iv = walk.iv; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((nbytes = walk.nbytes) &gt;= XOR_CIPHER_BLOCK_SIZE) { src = (u8*)walk.src.virt.addr; dst = (u8*)walk.dst.virt.addr; blocks = nbytes / XOR_CIPHER_BLOCK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (blocks) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; XOR_CIPHER_BLOCK_SIZE; i++) { dst[i] = src[i] ^ iv[i]; } xor_cipher_crypt(tfm, dst, dst); iv = dst; src += XOR_CIPHER_BLOCK_SIZE; dst += XOR_CIPHER_BLOCK_SIZE; blocks--; } nbytes &amp;= XOR_CIPHER_BLOCK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>; skcipher_walk_done(&amp;walk, nbytes); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((nbytes = walk.nbytes)) { src = (u8*)walk.src.virt.addr; dst = (u8*)walk.dst.virt.addr; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nbytes; i++) { dst[i] = src[i] ^ iv[i]; dst[i] ^= ctx-&gt;key[i]; } skcipher_walk_done(&amp;walk, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XOR_CIPHER_IV_SIZE 16 static int cbc_decrypt(struct skcipher_request *req) { struct crypto_tfm *tfm = crypto_skcipher_tfm(crypto_skcipher_reqtfm(req)); struct xor_cipher_ctx *ctx = crypto_tfm_ctx(tfm); struct skcipher_walk walk; u8 u[XOR_CIPHER_BLOCK_SIZE], iv[XOR_CIPHER_BLOCK_SIZE]; u32 nbytes; int i, blocks; u8 *src, *dst; skcipher_walk_virt(&amp;walk, req, true); memmove(iv, walk.iv, XOR_CIPHER_IV_SIZE); while ((nbytes = walk.nbytes) &gt;= XOR_CIPHER_BLOCK_SIZE) { src = (u8*)walk.src.virt.addr; dst = (u8*)walk.dst.virt.addr; blocks = nbytes / XOR_CIPHER_BLOCK_SIZE; while (blocks) { memmove(u, src, XOR_CIPHER_BLOCK_SIZE); xor_cipher_crypt(tfm, dst, src); for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; XOR_CIPHER_BLOCK_SIZE; i++) { dst[i] ^= iv[i]; } memmove(iv, u, XOR_CIPHER_IV_SIZE); dst += XOR_CIPHER_BLOCK_SIZE; src += XOR_CIPHER_BLOCK_SIZE; blocks--; } nbytes &amp;= XOR_CIPHER_BLOCK_SIZE - 1; skcipher_walk_done(&amp;walk, nbytes); } if ((nbytes = walk.nbytes)) { src = (u8*)walk.src.virt.addr; dst = (u8*)walk.dst.virt.addr; for (i = 0; i &lt; nbytes; i++) { dst[i] = src[i] ^ ctx-&gt;key[i]; dst[i] ^= iv[i]; } skcipher_walk_done(&amp;walk, 0); } return 0; }</span></span></span></span></code> </pre> </div></div><br><p> , ,  , ""        <code>skcipher_walk</code>     . ,  <code>skcipher_walk</code>   <code>skcipher_walk_virt</code> ,     <code>skcipher_walk_done</code>        "" /  ( <code>walk.src.virt.addr</code>  <code>walk.dst.virt.addr</code> )  <code>walk.nbytes</code> ,    <code>scatterlist</code> -. </p><br><p>     <code>skcipher_alg</code> ,  / : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> skcipher_alg cbc_xor_cipher = { .<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = { .cra_name = <span class="hljs-string"><span class="hljs-string">"cbc(xor-cipher)"</span></span>, .cra_driver_name = <span class="hljs-string"><span class="hljs-string">"cbc-xor-cipher"</span></span>, .cra_priority = <span class="hljs-number"><span class="hljs-number">400</span></span>, .cra_flags = CRYPTO_ALG_ASYNC, .cra_blocksize = <span class="hljs-number"><span class="hljs-number">1</span></span>, .cra_ctxsize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> xor_cipher_ctx), .cra_module = THIS_MODULE, }, .min_keysize = XOR_CIPHER_KEY_SIZE, .max_keysize = XOR_CIPHER_KEY_SIZE, .ivsize = XOR_CIPHER_IV_SIZE, .setkey = xor_skcipher_setkey, .encrypt = cbc_encrypt, .decrypt = cbc_decrypt, .chunksize = XOR_CIPHER_BLOCK_SIZE, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { crypto_register_alg(&amp;xor_cipher); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto_register_skcipher(&amp;cbc_xor_cipher); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor_cipher_exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { crypto_unregister_alg(&amp;xor_cipher); crypto_unregister_skcipher(&amp;cbc_xor_cipher); }</code> </pre> <br><p>      <code>cra_blocksize</code> .   ,   ,   <code>skcipher_walk_done</code> ""    ,   . </p><br><p>    ,   <code>/proc/crypto</code>  : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> : cbc(xor-cipher) driver : cbc-xor-cipher module : xor_cipher priority : <span class="hljs-number"><span class="hljs-number">400</span></span> refcnt : <span class="hljs-number"><span class="hljs-number">1</span></span> selftest : passed <span class="hljs-type"><span class="hljs-type">internal</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> : skcipher async : yes blocksize : <span class="hljs-number"><span class="hljs-number">1</span></span> min keysize : <span class="hljs-number"><span class="hljs-number">16</span></span> max keysize : <span class="hljs-number"><span class="hljs-number">16</span></span> ivsize : <span class="hljs-number"><span class="hljs-number">16</span></span> chunksize : <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br><p>   ( <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor/samples/kernel-xor-cipher"></a> )      : " <code>xor-cipher</code> " (  )  " <code>cbc(xor-cipher)</code> " (     ).  ,  ,   .           ,      ( <em>arch/x86/crypto</em> ),      . </p><br><hr><br><h2 id="4-testirovanie"> [4]  </h2><br><p>  ,          ,   "",  ,   ,    ,     . , ,  ‚Äî   ,      : ,  ,  <em></em> <em>Crypto API</em> .            ,     ,   , . </p><br><p>    .       <code>cipher_testvec_t</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test_t</span></span> { TEST_BLK_ENCRYPT = <span class="hljs-number"><span class="hljs-number">0</span></span>, TEST_BLK_DECRYPT, TEST_CBC_ENCRYPT, TEST_CBC_DECRYPT, TEST_END, } <span class="hljs-keyword"><span class="hljs-keyword">test_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cipher_testvec_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test_t</span></span> test; u32 len; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *key; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *iv; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *in; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *result; };</code> </pre> <br><p>     :   <code>in</code> ,  <code>len</code> ,       ( <code>.test = TEST_BLK_*</code> )        ( <code>.test = TEST_CBC_*</code> ),   <code>key</code> ,   ,  <code>iv</code> .        <code>result</code> .  <code>TEST_END</code>       <code>cipher_testvec_t</code> . </p><br><p>  ‚Äî     : </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int test_blk(cipher_testvec_t *testvec) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_cipher</span></span></span></span> *tfm = NULL; int encrypt = (testvec-&gt;test == TEST_BLK_ENCRYPT) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> dst[<span class="hljs-number"><span class="hljs-number">16</span></span>]; tfm = crypto_alloc_cipher(<span class="hljs-string"><span class="hljs-string">"xor-cipher"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(tfm)) { pr_err(<span class="hljs-string"><span class="hljs-string">"error allocating xor-cipher: %ld\n"</span></span>, PTR_ERR(tfm)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } crypto_cipher_setkey(tfm, (<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;key, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (encrypt) { crypto_cipher_encrypt_one(tfm, dst, (<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { crypto_cipher_decrypt_one(tfm, dst, (<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>); } crypto_free_cipher(tfm); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memcmp(dst, testvec-&gt;result, <span class="hljs-number"><span class="hljs-number">16</span></span>)) { pr_err(<span class="hljs-string"><span class="hljs-string">"block %sciphering test failed!\n"</span></span>, encrypt ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-string"><span class="hljs-string">"de"</span></span>); dumpb((<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;key, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"key"</span></span>); dumpb((<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>); dumpb(dst, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"result"</span></span>); dumpb((<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>*)testvec-&gt;result, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"should be"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>    ,        <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"><em>Single Block Cipher API</em></a> . ,    <code>crypto_alloc_cipher</code> ,        " <em>xor-cpher</em> ".  ,    ( <code>crypto_cipher_setkey</code> ), ,     ,    ( <code>crypto_cipher_encrypt_one</code> )   ( <code>crypto_cipher_decrypt_one</code> ) .  ,   ( <code>crypto_free_cipher</code> )       . </p><br><p>       CBC   . </p><br><div class="spoiler"> <b class="spoiler_title">  CBC</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cbc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cipher_testvec_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *testvec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scatterlist</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cb_data_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cb_data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_skcipher</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tfm</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skcipher_request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> encrypt = (testvec-&gt;test == TEST_CBC_ENCRYPT) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; u32 err; u8 *buf = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; tfm = crypto_alloc_skcipher(<span class="hljs-string"><span class="hljs-string">"cbc-xor-cipher"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(tfm)) { pr_err(<span class="hljs-string"><span class="hljs-string">"error allocating cbc-xor-cipher: %ld\n"</span></span>, PTR_ERR(tfm)); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } req = skcipher_request_alloc(tfm, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!req) { pr_err(<span class="hljs-string"><span class="hljs-string">"error allocating skcipher request\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } buf = kmalloc(testvec-&gt;len, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buf) { pr_err(<span class="hljs-string"><span class="hljs-string">"memory allocation error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } memmove(buf, (u8*)testvec-&gt;in, testvec-&gt;len); sg_init_one(&amp;sg, buf, testvec-&gt;len); crypto_skcipher_setkey(tfm, (u8*)testvec-&gt;key, <span class="hljs-number"><span class="hljs-number">16</span></span>); skcipher_request_set_crypt(req, &amp;sg, &amp;sg, testvec-&gt;len, (u8*)testvec-&gt;iv); skcipher_request_set_callback(req, <span class="hljs-number"><span class="hljs-number">0</span></span>, skcipher_cb, &amp;cb_data); init_completion(&amp;cb_data.completion); err = (encrypt) ? crypto_skcipher_encrypt(req) : crypto_skcipher_decrypt(req); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> -EINPROGRESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> -EBUSY: wait_for_completion(&amp;cb_data.completion); err = cb_data.err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: pr_err(<span class="hljs-string"><span class="hljs-string">"failed with error: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(buf, testvec-&gt;result, testvec-&gt;len)) { pr_err(<span class="hljs-string"><span class="hljs-string">"cbc %sciphering test failed!\n"</span></span>, encrypt ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-string"><span class="hljs-string">"de"</span></span>); dumpb((u8*)testvec-&gt;key, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"key"</span></span>); dumpb((u8*)testvec-&gt;iv, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"iv"</span></span>); dumpb((u8*)testvec-&gt;in, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"in"</span></span>); dumpb(buf, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"result"</span></span>); dumpb((u8*)testvec-&gt;result, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"should be"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } skcipher_request_free(req); crypto_free_skcipher(tfm); kfree(buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buf) { kfree(buf); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req) { skcipher_request_free(req); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tfm) { crypto_free_skcipher(tfm); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><p>  :     <em></em> <em>API</em> ( <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-skcipher.html"><em>Symmetric Key Cipher API</em></a> ),       . </p><br><p>    <code>test_cbc</code> : </p><br><ul><li>          ,   : <code>cb_data_t</code> ,      </li><li>       :   " <em>cbc-xor-cipher</em> " ( <code>crypto_alloc_skcipher</code> )   <code>skcipher_requset</code> ( <code>skcipher_request_alloc</code> ) </li><li>      / :     ( <code>kmalloc</code> )   ,    ,      ;       <code>scatterlist</code> ( <code>sg_init_one</code> ) </li><li>    ( <code>crypto_skcipher_setkey</code> )    <code>skcipher_requset</code> ( <code>skcipher_request_set_crypt</code> ).      <code>skcipher_request_set_crypt</code> , ,    .             <code>scatterlist</code> ,  ,    " ",        <code>buf</code> </li><li>    ,      ( <code>skcipher_request_set_callback</code> ) </li></ul><br><p>     .       <em>API</em> ,      ,       ,     .   ,     ,     ,  .             <code>skcipher_request_set_callback</code> .        <code>cb_data_t</code> ,     ( <code>skcipher_cb</code> )   : </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cb_data_t</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">completion</span></span></span></span> completion; int err; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void skcipher_cb(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_async_request</span></span></span></span> *req, int error) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cb_data_t</span></span></span></span> *data = req-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error == -EINPROGRESS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } data-&gt;err = error; complete(&amp;data-&gt;completion); }</code> </pre> <br><p>  <code>completion</code>           <code>test_cbc</code> ,  .   ,     ,        <code>test_cbc</code> .   ,     <code>test_cbc</code> ,    : </p><br><ul><li>   <code>completion</code> ( <code>init_completion</code> ),     </li><li>     ,    ( <code>crypto_skcipher_encrypt</code> )   ( <code>crypto_skcipher_decrypt</code> ) </li><li>     : </li><li><ul><li> 0 ,      </li></ul><br></li><li><ul><li>  <code>-EINPROGRESS</code>  <code>-EBUSY</code>   ,     .   ,        <code>completion</code> ( <code>complete</code>  <code>wait_for_completion</code> ),     </li></ul><br></li><li><ul><li>         <code>crypto_skcipher_encrypt</code> </li></ul><br></li></ul><br><p>   <code>switch</code> -a    .  That's all.      <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor/samples/kernel-testmgr"></a> ,      ( ,      ),     - : </p><br><pre> <code class="bash hljs">insmod: ERROR: could not insert module xor_cipher_testing.ko: Operation not permitted</code> </pre> <br><p>     ( <code>dmesg</code> )   : </p><br><pre> <code class="bash hljs">[---] <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> 4 tests, passed: 4, failed: 0</code> </pre> <br><p> ,  <a href="https://www.kernel.org/doc/html/v4.13/crypto/api-samples.html"></a>     <em>SK Cipher API</em> ,     .   ‚Äî         "",    <em>Asynchronous Block Cipher API</em> ,  .  -,   -,    ,  . </p><br><hr><br><h2 id="41-vozvraschenie-v-user-space"> [4.1]   <em>user-space</em> </h2><br><p>   ,        .       <a href="https://www.kernel.org/doc/html/v4.13/crypto/userspace-if.html"></a> , ,  ,      ,        ,    ,         <em>Linux</em> .       <a href="http://www.chronox.de/libkcapi.html"><em>libkcapi</em></a> ,     <em>Crypto API</em> (   ).  ""      <em>Netlink</em> -,  ""    <em>Netlink</em>    <em>API</em> . ,   ,       ,        ,  ,       (  1.0.3). </p><br><p>           ,    . ,   ,     ,     (   ),   <em>Crypto API</em> .        <em>af_alg</em>  <em>Strongswan</em> ,  <a href="https://github.com/strongswan/src/libstrongswan/plugins/af_alg"></a>     . </p><br><p>  So let's go.  ,        ,     . ,       ,          .  ,      <code>test_cbc</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  CBC  user-space</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cbc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cipher_testvec_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *testvec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst[testvec-&gt;len]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> encrypt = (testvec-&gt;test == TEST_CBC_ENCRYPT) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_skcipher</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tfm</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> tfm = af_alg_allocate_skcipher(<span class="hljs-string"><span class="hljs-string">"cbc-xor-cipher"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tfm) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"error allocating \"cbc-xor-cipher\"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!af_alg_skcipher_setkey(tfm, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;key, XOR_CIPHER_KEY_SIZE)) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"can't set \"cbc-xor-cipher\" key\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!af_alg_skcipher_crypt(tfm, encrypt, dst, testvec-&gt;len, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;in, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;iv, XOR_CIPHER_IV_SIZE)) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> err; } af_alg_free_skcipher(tfm); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(dst, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;result, testvec-&gt;len)) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"cbc %sciphering test failed!\n"</span></span>, encrypt ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-string"><span class="hljs-string">"de"</span></span>); dumpb((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;key, XOR_CIPHER_KEY_SIZE, <span class="hljs-string"><span class="hljs-string">"key"</span></span>); dumpb((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;iv, XOR_CIPHER_IV_SIZE, <span class="hljs-string"><span class="hljs-string">"iv"</span></span>); dumpb((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;in, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"in"</span></span>); dumpb(dst, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"result"</span></span>); dumpb((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)testvec-&gt;result, testvec-&gt;len, <span class="hljs-string"><span class="hljs-string">"should be"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; err: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tfm) { af_alg_free_skcipher(tfm); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><p>       . ,      ,  ,  ,  ,       .       <code>af_alg_skcipher</code>      <code>af_alg_*</code> .  We look further. </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_skcipher</span></span></span></span> { int sockfd; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_skcipher</span></span></span></span>* af_alg_allocate_skcipher(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *name) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_skcipher</span></span></span></span> *tfm = NULL; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_alg</span></span></span></span> sa = { .salg_family = AF_ALG, .salg_type = <span class="hljs-string"><span class="hljs-string">"skcipher"</span></span>, }; strncpy((<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)sa.salg_name, name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa.salg_name)); tfm = calloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_skcipher</span></span></span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tfm) { errno = ENOMEM; goto err; } tfm-&gt;sockfd = socket(AF_ALG, SOCK_SEQPACKET, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tfm-&gt;sockfd == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { goto err; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bind(tfm-&gt;sockfd, (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span></span>*)&amp;sa, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa)) == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { goto err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tfm; err: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tfm-&gt;sockfd &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(tfm-&gt;sockfd); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tfm) { free(tfm); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NULL; }</code> </pre> </div></div><br><p>   : </p><br><ul><li>    <code>sockaddr_alg</code> (  ) </li><li>      ( <code>calloc</code> ) </li><li>    <em>Crypto API</em> ( <code>socket</code> ) </li></ul><br><p>     <code>socket</code>   ,      ""   .  <em>AF_ALG</em>     <em>Crypto API</em> .  <em>AF_ALG</em> , ,     <em>sys/socket.h</em> ,    ,     : </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> AF_ALG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AF_ALG 38 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><ul><li>  ,         ( <code>bind</code> ) </li></ul><br><p>       <code>sockaddr_alg</code> ,          <code>bind</code> : </p><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* sys/socket.h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sockfd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sockaddr *addr, socklen_t addrlen</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  <code>sockadr</code>   : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sa_family_t</span></span> sa_family; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> sa_data[<span class="hljs-number"><span class="hljs-number">14</span></span>]; }</code> </pre> <br><p>        ,    ,       ( <code>sa_family</code> ),  <em>AF_ALG</em> : </p><br><pre> <code class="hljs rust"><span class="hljs-comment"><span class="hljs-comment">/* linux/if_alg.h */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_alg</span></span></span></span> { __<span class="hljs-built_in"><span class="hljs-built_in">u16</span></span> salg_family; __<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> salg_type[<span class="hljs-number"><span class="hljs-number">14</span></span>]; __<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> salg_feat; __<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> salg_mask; __<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> salg_name[<span class="hljs-number"><span class="hljs-number">64</span></span>]; };</code> </pre> <br><p>    : </p><br><ul><li> <strong><code>salg_family</code></strong> : .  </li><li> <strong><code>salg_type</code></strong> :   : " <code>skcipher</code> " ‚Äî , " <code>hash</code> " ‚Äî   , " <code>aead</code> " ‚Äî , <em>AEAD</em> , "rng" ‚Äî    </li><li> <strong><code>salg_name</code></strong> :     ( <code>cra_name</code>  <code>cra_driver_name</code> ) </li></ul><br><p>       ,  <code>bind</code>  -1,    <code>errno</code>     <code>ENOENT</code> . </p><br><p>  ,    <code>af_alg_allocate_skcipher</code>   ,         .           . </p><br><p>      : </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af_alg_skcipher_setkey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct af_alg_skcipher *tfm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keylen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (setsockopt(tfm-&gt;sockfd, SOL_ALG, ALG_SET_KEY, key, keylen) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>       <code>setsockopt</code> ,          <a href="https://linux.die.net/man/2/setsockopt"><em>man</em> -</a> .   ,   <code>SOL_ALG</code>  <code>ALG_SET_KEY</code> , ,    <em>sys/socket.h</em>  <em>linux/af_alg.h</em> , ,   ,   ,     : </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SOL_ALG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOL_ALG 279 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ALG_SET_KEY #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALG_SET_KEY 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p> ,    . </p><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af_alg_skcipher_crypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct af_alg_skcipher *tfm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> encrypt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *iv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ivlen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type = encrypt ? ALG_OP_ENCRYPT : ALG_OP_DECRYPT; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msghdr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> = {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmsghdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmsg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">af_alg_iv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ivm</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iovec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iov</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[CMSG_SPACE(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(type)) + CMSG_SPACE(offsetof(struct af_alg_iv, iv) + ivlen)]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> op = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> len, remainig = _len; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *src = _src, *dst = _dst; op = accept(tfm-&gt;sockfd, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> end; } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(buf, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); <span class="hljs-comment"><span class="hljs-comment">/* fill in af_alg cipher controll data */</span></span> msg.msg_control = buf; msg.msg_controllen = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf); <span class="hljs-comment"><span class="hljs-comment">/* operation type: encrypt or decrypt */</span></span> cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg-&gt;cmsg_level = SOL_ALG; cmsg-&gt;cmsg_type = ALG_SET_OP; cmsg-&gt;cmsg_len = CMSG_LEN(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(type)); memmove(CMSG_DATA(cmsg), &amp;type, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(type)); <span class="hljs-comment"><span class="hljs-comment">/* initialization vector */</span></span> cmsg = CMSG_NXTHDR(&amp;msg, cmsg); cmsg-&gt;cmsg_level = SOL_ALG; cmsg-&gt;cmsg_type = ALG_SET_IV; cmsg-&gt;cmsg_len = CMSG_LEN(offsetof(struct af_alg_iv, iv) + ivlen); ivm = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)CMSG_DATA(cmsg); ivm-&gt;ivlen = ivlen; memmove(ivm-&gt;iv, iv, ivlen); <span class="hljs-comment"><span class="hljs-comment">/* set data stream (scatter/gather list) */</span></span> msg.msg_iov = &amp;iov; msg.msg_iovlen = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remainig) { iov.iov_base = src; iov.iov_len = remainig; len = sendmsg(op, &amp;msg, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EINTR) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> end; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read(op, dst, len) != len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EINTR) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> end; } } src += len; remainig -= len; <span class="hljs-comment"><span class="hljs-comment">/* no iv for subsequent data chunks */</span></span> msg.msg_controllen = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* done */</span></span> close(op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; end: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(op); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><p>   ,        .    ,   ,    , ,      ,      .  ,     3 : </p><br><ul><li>   ,     <code>accept</code> ,     ,  ,  ,        </li><li>   ,    ( <code>msghdr</code> ),     ( <code>cmsghdr</code> ) , ,   /  ( <code>iovec</code> ) </li></ul><br><p>         ( <code>ALG_SET_OP</code> ):  ( <code>ALG_OP_ENCRYPT</code> )   ( <code>ALG_OP_DECRYPT</code> ),   ( <code>ALG_SET_IV</code> , <code>af_alg_iv</code> ).  , ,         <em>linux/if_alg.h</em> , ,    ,      : </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ALG_SET_IV #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALG_SET_IV 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ALG_SET_OP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALG_SET_OP 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ALG_OP_DECRYPT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALG_OP_DECRYPT 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ALG_OP_ENCRYPT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALG_OP_ENCRYPT 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><ul><li> ,   ,    <code>sendmsg</code>  <code>read</code> ,  ,   <code>accept</code> , , ,      /    </li></ul><br><p>  That's all.      <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor/samples/user-testmgr"></a> .    ,    : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">done</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> tests, passed: <span class="hljs-number"><span class="hljs-number">2</span></span>, failed: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>   ‚Äî  ,     . </p><br><hr><br><h2 id="5-chto-dalshe"> [5]  ? </h2><br><p> ,        , ,  , ,   ,      ,   ,     .   ,     ,      .             . </p><br><p>     ‚Äî   . ,       ,   ,  . ,       <em>Crypto API</em> .  ,         - <em>API</em> ,           . ,   ,      ,    ,     . </p><br><p>  ,        :  ,     ,  ,    <abbr title="eyesscreasmake@rambler.ru"></abbr>    .  ,          <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor">github</a> .  Thanks for attention! </p><br><hr><br><h3 id="ispolzuem-shablony">   </h3><br><p>      ,      ""  ,      ‚Äî <em></em>  .    !      . ,     <em>xor-cipher</em> , ,         <em>CBC</em> ,     ( <em>SK Cipher API</em> ,   ‚Äî ): </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_skcipher</span></span></span></span> *tfm = crypto_alloc_skcipher(<span class="hljs-string"><span class="hljs-string">"cbc(xor-cipher)"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>       <em>xor-cipher</em> ,        ( <em>crypto/cbc.c</em> ). </p><br><p> " ! ‚Äî  . ‚Äî  ,        <em>cbc(xor-cipher)</em> ?". " ", ‚Äî  .          ,        . </p><br><p>      ,    : </p><br><ul><li>        </li><li>    ,           </li><li>     ,    " "    </li></ul><br><p>         .        ""       . ,   " <em>cbc</em> ",    : </p><br><pre> <code class="hljs objectivec">.cra_name = <span class="hljs-string"><span class="hljs-string">"xor-cipher"</span></span>; .cra_driver_name = <span class="hljs-string"><span class="hljs-string">"xor-cipher-generic"</span></span>;</code> </pre> <br><p>        : </p><br><pre> <code class="hljs objectivec">.cra_name = <span class="hljs-string"><span class="hljs-string">"cbc(xor-cipher)"</span></span>; .cra_driver_name = <span class="hljs-string"><span class="hljs-string">"cbc(xor-cipher-generic)"</span></span>;</code> </pre> <br><p>   ,     <code>crypto_alg</code> ,    ,  <code>cra_driver_name</code>  <em></em>   ,       .      , ,  <code>cra_driver_name</code>   " <em>cbc(xor-cipher-generic)</em> ",      : </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">crypto_skcipher</span></span></span></span> *tfm = crypto_alloc_skcipher(<span class="hljs-string"><span class="hljs-string">"cbc(xor-cipher-generic)"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><hr><br><h3 id="bolshe-testov">   </h3><br><p> ,       ,   ,       . ,  <em>Crypto API</em>  ,   ,         . </p><br><p>    <em>tcrypt</em> ( <em>crypto/tcrypt.c</em> )      .   ,          <em>crypto/tcrypt.c</em> ,        ,   <em>crypto/testmgr.c</em> .    , <em>testmgr</em>              ,    (         ). </p><br><p>   ,        <em>tcrypt</em>  .    ""  <em>tcrypt</em>  <em>testmgr</em> ,        <em>Makefile</em> ,      ‚Äî <em>tcryptext (tcrypt External)</em> .        <a href="https://githib.com/HenadizMatuts/tcryptext"></a> . </p><br><p>          <em>tcryptext</em> (     <em>tcrypt</em> ,    ),            -    ,   .          (   <em>README.md</em> ,  ). </p><br><p>  <em>testmgr.c</em>          <em>Crypto API</em> . </p><br><hr><br><h3 id="domik-na-dereve">    </h3><br><p> ,   <em>Linux-based</em>         .    (    )           . </p><br><p>      .            " <em>crypto</em> "       <em>crypto/Kconfig</em>  <em>Makefile</em> . ,   <em>crypto</em>    <em>xor_cipher.c</em> ,    <em>crypto/Kconfig</em> (  <em>comment "Ciphers"</em> )   : </p><br><pre> <code class="hljs sql">... config CRYPTO_XOR_CIPHER tristate "XOR cipher algorithm" <span class="hljs-keyword"><span class="hljs-keyword">help</span></span> Custom <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span> cipher algorithm. ...</code> </pre> <br><p>    <em>crypto/Makefile</em> : </p><br><pre> <code class="hljs mel">... obj-$(CONFIG_CRYPTO_XOR_CIPHER) += xor_cipher.o ...</code> </pre> <br><p>       ( " <em>Cryptographic API</em> ")      .            ,     . </p><br><p>          <em>tcrypt</em>  <em>testmgr</em> . </p><br><hr><br><h3 id="poleznye-ssylki">  useful links </h3><br><p>  Literature: </p><br><ul><li> <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">Authenticated encryption</a> </li><li> <a href="https://www.kernel.org/doc/html/v4.13/crypto/index.html">Linux Kernel Crypto API</a> </li><li> <a href="https://xakep.ru/2009/01/20/46840">Crypto API   Linux</a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">   </a> </li><li> <a href="https://habrahabr.ru/post/343828/">    Linux</a> </li><li> <a href="https://habrahabr.ru/post/117654/">     Linux</a> </li><li> <a href="https://habrahabr.ru/post/138328">    (Netfilter)     HTTPS</a> </li><li> <a href="https://www.kernel.org/doc/Documentation/crypto/api-intro.txt">Scatterlist Cryptographic API</a> </li><li> <a href="http://vger.kernel.org/~davem/skb.html">How SKBs work</a> </li><li> <a href="https://lwn.net/Articles/256368/">The chained scatterlist API</a> </li><li> <a href="http://www.chronox.de/libkcapi.html">libkcapi ‚Äî Linux Kernel Crypto API User Space Interface Library</a> </li><li> <a href="https://linux.die.net/man/2/setsockopt">setsockopt(2) ‚Äî Linux man page</a> </li></ul><br><p> Git: </p><br><ul><li> <a href="https://github.com/HenadziMatuts/linux-crypto-api-tutor">   </a> </li><li> <a href="https://github.com/HenadziMatuts/tcryptext">tcryptext</a> </li><li> <a href="https://github.com/strongswan/src/libstrongswan/plugins/af_alg">Strongswan af_alg plugin</a> </li><li> <a href="https://github.com/torvalds/linux">Linux kernel</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348552/">https://habr.com/ru/post/348552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348540/index.html">Competition Pri-matrix Factorization on DrivenData with 1TB of data - how we took 3rd place (translation)</a></li>
<li><a href="../348542/index.html">Amazon S3 and all-all-all: choose object storage</a></li>
<li><a href="../348546/index.html">Why is it so hard to attract money in the open source?</a></li>
<li><a href="../348548/index.html">Selection: 7 Chrome extensions to bypass locks</a></li>
<li><a href="../348550/index.html">SLA philosophy: about query priorities</a></li>
<li><a href="../348554/index.html">Welcome to Cradle: Rave. And no, this is not a disco</a></li>
<li><a href="../348558/index.html">The fundamental HTML vulnerability when embedding scripts</a></li>
<li><a href="../348560/index.html">Relationship functionality</a></li>
<li><a href="../348562/index.html">BI & Blockchain is a collective intelligence based solution. Part 2</a></li>
<li><a href="../348564/index.html">We write scalable and supported servers on Node.js and TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>