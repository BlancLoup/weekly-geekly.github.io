<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Metaballs without shaders + fluid physics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I had a dispute with the ZimM habrauser about a non-2D 2D engine: I argued that shaders are not necessary for simple 2D games, almost all the eff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Metaballs without shaders + fluid physics</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/927/7e5/c70/9277e5c70d9f49a79c0442d34b71eafe.gif">  Once I had a dispute with the ZimM <a href="https://habrahabr.ru/users/zimm/" class="user_link">habrauser</a> about a non-2D 2D engine: I argued that shaders are not necessary for simple 2D games, almost all the effects can be done with sprites, its position was the opposite.  I repeatedly returned to this argument in my mind and invented tasks that could not be implemented at first glance without shaders, and it was the solution of one such task that led to the creation of a game where the player controls the fluid by tilting the phone. <br><a name="habracut"></a><br><h4>  Theory </h4><br>  As you can guess from the title, the task was to draw liquids using metaballs.  The essence of this technology is in finding a set of points that are not further some distance from the center of any of the meta-balls - ‚Äúdrops‚Äù that make up the liquid (more precisely, look at the <a href="https://en.wikipedia.org/wiki/Metaballs">wiki</a> ).  There are many different options for rendering them, including on <a href="http://habrahabr.ru/post/250001/">CSS</a> .  The simplest and most effective method is to draw circles with reverse quadratic transparency and in the resulting picture, drop zones with transparency less than 0.5, and paint the rest with one color. <br><br>  In this screenshot from <a href="https://www.jwz.org/xscreensaver/">XScreenSaver</a> MetaBalls, it can be seen that the intersecting circles form sufficiently high-quality ‚Äúspikes‚Äù and look organically in places of multiple overlapping.  This screensaver did not filter zones, but modern equipment can handle it. <br><br><img src="https://habrastorage.org/files/d9d/2ae/988/d9d2ae988a664d0bb63970df17539283.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, I started thinking like making metaballs on shaders: first, we send four vertices for each Metaball to the vertex shader, create a square with texture coordinates from them, then in the pixel shader we draw either a ready-made texture or the result of an inverse-quadratic function: <br><br><pre><code class="hljs perl">vec2 <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> = texCoord.xy - vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>); color.a = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>/dot(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>);</code> </pre> <br>  The result of the work is written to the buffer and processed again with a pixel shader with discard if alpha is less than 0.5 and painting or texture for the other values.  Of course, it will be necessary to pick up the coefficients and maybe a few ‚Äúdecorations‚Äù in the final shader. <br><br><h4>  Practice </h4><br>  But without shaders, the same approach, but on the CPU it looks doubtful: we create a buffer in memory, for example, 1024x1024xRGBA, pass through an array with liquid ‚Äúdrops‚Äù and arrange the coefficients using the inverse square of the distance for everyone in a square with R * 2 + 1 sides from the center.  Well, then we run over the finished buffer and clean up the RGBA values, imitating the discard, paint over the solid zones, and then send this buffer to the video card.  It turns out at a radius of R = 20 and 40 "drops" each frame must be done 67240 calculations + 1048576 iterations over an array of pixels with additional processing.  This is not to mention the transfer of 4Mb textures to video memory and the hope of a 60fps frequency on mobile devices. <br><br>  For the sake of experiment, I implemented such a scheme and got the brakes even on a desktop computer.  Yes, and the result looked frankly weak: stepped edges, uniform fill color, too geometrically reliable "spikes".  At the same time, I made a classic mistake of premature optimization - I tried to do all the operations with integer coordinates, which could have increased the speed, but it had a bad effect on quality and added ‚Äújerkiness‚Äù to the fluid movement. <br><br>  It was thoughts about integer calculations that gave me the idea that I went the wrong way: I put too much on the CPU, although it was possible to transfer some of the work to the GPU.  The right decision was ... reducing the texture several times!  But now I decided to use the same effect that Valve uses for fonts and graffiti - <a href="http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">Signed Distance Field Alpha Magnification</a> .  For those who have not encountered this technology, in a nutshell, the principle is this: increasing the picture does not degrade the quality of zones with gradients, i.e.  if there is a smooth transition from a value of 0.0 to 1.0, then the gap inside it will retain its shape at any scale, as in this picture: <br><img src="https://habrastorage.org/files/5ef/5f7/5d6/5ef5f75d6a63460b961cc75a8169cd8a.png"><br><br>  You can read more <a href="http://habrahabr.ru/post/245729/">here</a> . <br><br>  In the case of liquids, I made a 256x256 buffer and left a gradient at the border of each ‚Äúdrop‚Äù, slightly scaling the alpha - simply, everything is dropped below the initial value of 0.4, above 0.6 it is filled with a solid color, and where there was a transition from 0.4 to 0.6, now the transition from 0.0 to 1.0 (in fact, a cubic function is used there, see the code below).  I reduced the radius of each ‚Äúdrop‚Äù to 5 pixels, so for each frame there were 4840 calculations and 65536 pixels in a 256Kb buffer.  Such a reduction in the load made it possible to switch to floating-point operations with fairly high accuracy - for each ‚Äúdrop‚Äù a region of 11x11 pixels is processed and for each pixel the distance to the exact coordinate of the ‚Äúdrop‚Äù is calculated, and not to the pixel in the center of the region.  The result is sent to the video card via glTexSubImage2D with ALPHA_TEST at 0.5.  The GPU cuts off the edge of the drop visually, quite neatly, even when scaling a texture with liquid 4-8 times. <br><br><img src="https://habrastorage.org/files/37d/4ad/314/37d4ad314135459cb369251f4b07be73.png"><br><br>  Here is the processing code with which the picture was taken above: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_metaballs.Length; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> minX = (<span class="hljs-type"><span class="hljs-type">int</span></span>)Math.Floor(m_metaballs [i].Position.X - s_radius); <span class="hljs-type"><span class="hljs-type">int</span></span> minY = (<span class="hljs-type"><span class="hljs-type">int</span></span>)Math.Floor(m_metaballs [i].Position.Y - s_radius); <span class="hljs-type"><span class="hljs-type">int</span></span> maxX = (<span class="hljs-type"><span class="hljs-type">int</span></span>)Math.Ceiling(m_metaballs [i].Position.X + s_radius); <span class="hljs-type"><span class="hljs-type">int</span></span> maxY = (<span class="hljs-type"><span class="hljs-type">int</span></span>)Math.Ceiling(m_metaballs [i].Position.Y + s_radius); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> y = minY; y &lt; maxY; y++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> x = minX; x &lt; maxX; x++) { <span class="hljs-type"><span class="hljs-type">float</span></span> dist = (x - m_metaballs[i].Position.X) * (x - m_metaballs[i].Position.X) + (y - m_metaballs[i].Position.Y) * (y - m_metaballs[i].Position.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; s_radiusSqrd) { dist = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - (dist * s_iradiusSqrd); <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = (<span class="hljs-type"><span class="hljs-type">int</span></span>)(dist * dist * <span class="hljs-number"><span class="hljs-number">256.0</span></span>f); <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = (x + y * s_fieldWidth) * <span class="hljs-number"><span class="hljs-number">4</span></span>; m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] = (byte)NormalizeInt(m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); // shift <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> top left <span class="hljs-type"><span class="hljs-type">int</span></span> v = (<span class="hljs-type"><span class="hljs-type">int</span></span>)((Math.Abs(x - minX) + Math.Abs(y - minY)) * <span class="hljs-number"><span class="hljs-number">32.0</span></span>f); // middle <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] = (byte)NormalizeInt((m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] + v) /<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); // max <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] = (byte)NormalizeInt(Math.Max(m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], v), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); // metaball <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> m_field[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>] = (byte)(i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_field.Length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> a = m_field [i + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">40</span></span>) { <span class="hljs-type"><span class="hljs-type">float</span></span> na = a / <span class="hljs-number"><span class="hljs-number">255.0</span></span>f + <span class="hljs-number"><span class="hljs-number">0.4</span></span>f; na = (na * na * na); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (na &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>f) na = <span class="hljs-number"><span class="hljs-number">0.8</span></span>f; <span class="hljs-type"><span class="hljs-type">float</span></span> nx = m_field [i + <span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">32.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nx &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) nx = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> ny = m_field [i + <span class="hljs-number"><span class="hljs-number">1</span></span>] / <span class="hljs-number"><span class="hljs-number">32.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ny &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) ny = <span class="hljs-number"><span class="hljs-number">4</span></span>; m_field [i + <span class="hljs-number"><span class="hljs-number">0</span></span>] = (byte)(<span class="hljs-number"><span class="hljs-number">25</span></span> * na + <span class="hljs-number"><span class="hljs-number">30</span></span> * nx + <span class="hljs-number"><span class="hljs-number">5</span></span> * ny); m_field [i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = (byte)(<span class="hljs-number"><span class="hljs-number">100</span></span> * na + <span class="hljs-number"><span class="hljs-number">30</span></span> * nx + <span class="hljs-number"><span class="hljs-number">10</span></span> * ny); m_field [i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = (byte)(<span class="hljs-number"><span class="hljs-number">150</span></span> * na + <span class="hljs-number"><span class="hljs-number">30</span></span> * nx + <span class="hljs-number"><span class="hljs-number">5</span></span> * ny); m_field [i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = (byte)(<span class="hljs-number"><span class="hljs-number">255</span></span> * na); } }</code> </pre><br></div></div><br>  A little more shamanism was needed to give the fluid a more ‚Äúvolumetric‚Äù look with darkening in the upper left corner and to draw the outline.  This is what the final version looks like with GL_ONE / GL_ONE_MINUS_SRC_ALPHA blending: <br><br><img src="https://habrastorage.org/files/700/7b1/2b0/7007b12b02694329b10e90c8514b767c.jpg"><br><br>  If you take a closer look, then not perfect shading quality is seen closer to the edge due to the low resolution of the texture.  This could be corrected by making all the liquid monochrome, but I decided to leave this effect to get a more dynamic picture. <br><br><h4>  Physics </h4><br>  In general, the fluids turned out visually more or less normal and then I wanted to make a puzzle out of the game, similar to Teeter.  I sometimes use the <a href="https://farseerphysics.codeplex.com/">Farseer</a> engine (Box2D port in C #) in games, because when I found the blog comrade.  <a href="http://www.quantumyeti.com/blog/box2d-fluid-part-1">QuantumYeti was</a> very happy and after some time was able to run its code.  Everything would be fine, but liquids seeped through the smallest gaps between objects and flowed behind the screen.  As a quick fix, I sketched a patch to the engine, which at each vertex of the convex polygon adds a small offset along the normal vector.  This solved most of the problems, because I gave the prototype to the designer and waited for the result.  After a few weeks, the level designer began to complain that simple elements are processed relatively normally, but on complex curves and sharp corners, the liquid can get stuck forever. <br><br>  This did not seem like a big problem and just looked like a temporary bug.  I dug a little into the code Comrade.  QuantumYeti realized that everything was pretty bad there, because it was more of a proof of concept and not a working engine for liquids: dubious execution logic, constants in the code, storage of temporary variables in a class with public fields and other jambs.  But most importantly, the logic of collisions with objects was very conditional and not suitable for our task - when liquid particles got inside the object, their speed was reset and they teleported in the direction of the normal vector to the surface.  If at the same time the particle fell into another object, then the external forces and the viscosity of the fluid hung forever and no longer acted on it.  Particles were also considered to be point bodies and the TestPoint method was used for collisions, so they could leak into the slots.  Simple patches did not help here, and my hack with the increase in objects aggravated the situation, so I decided to switch to another physics engine. <br><br>  The choice fell on <a href="https://github.com/google/liquidfun/tree/master/liquidfun">liquidfun</a> , or rather, on its full C # port, <a href="https://github.com/gordonmcshane/sharpbox2d">sharpbox2d</a> .  This engine is made by guys from Google, is good enough inside, gives a pleasant speed and dynamics of the movement of liquids.  The port on C # turned out to be a bit worse and, on the whole, not finished - it compiled, but did not work, since  The Java approach was often used when a function changes an instance of a class, but it is not marked with the words ref or out, and if it turned into a struct during porting, the operation logic is violated.  I took up the correction of these problems and in a day I had a working version of the engine (ps I can put in git if someone needs it), and then adapted the whole game to work with it.  Everything would be fine, but the level designer described the behavior of the fluid in the new engine as ‚Äúa piece of dough creeping along the oiled walls‚Äù.  For a while I was playing with the parameters, until I realized that there would be no sense from this - physically accurate and high-quality this engine did not allow me to get the necessary viscosity and density parameters, which in the prototype from QuantumYeti were set "by eye", stitched constants and approximate formulas. <br><br>  At this point, I had already pretty well figured out the physics of liquids and could conditionally understand how collisions should work and why the previous version did not work.  The basis was the ray casting method while the particle is moving.  It took several days to rework one small method, but on the whole, the final version suited me ‚Äî liquids no longer leak, do not stick to the walls, and do not stop internal movements when they come into contact with objects. <br><br><pre> <code class="hljs lua"> RayCastInput <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> = new RayCastInput(); <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.Point1 = particle.oldPosition; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.Point2 = newPosition; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.MaxFraction = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; RayCastOutput <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = new RayCastOutput(); /// ... skipped ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fixture.RayCast(out <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>, ref <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>, c)) { Vector2 n = <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Normal; Vector2 p = (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Fraction) * <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.Point1 + <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Fraction * <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.Point2 + PUSHBACK * n; Vector2 v = (p - particle.position); float ax = moveVector.X - vX; float ay = moveVector.Y - vY; float fdn = ax * nX + ay * nY; antiGravity -= n * fdn; }</code> </pre><br>  During the iteration of all the figures with which there are (or will be in the next frame) intersections, I form an antiGravity vector, directed opposite to the motion vector. <br><br>  My FluidSystem.cs code with some sweep, but with the namespace, logic, and comments of the first author is available here: <a href="">runserver.net/temp/FluidSystem.cs</a> <br><br>  Perhaps someone wants to use it in their projects, or just bring to mind and add to any engine. <br><br>  The final stroke in physics was the addition of moving objects - they can begin to intersect with the fluid themselves, and not as a result of particle motion, because ray casting does not quite fit here and had to use the author‚Äôs original approach with the TestPoint method and spot checks.  Then there were some bugs, but for this project they were no longer significant. <br><br>  In general, it can be said that the whole project is born from crutches and it also keeps on them - shader graphics without shaders, fluid physics without a fluid engine, patches and patches instead of refactoring.  But on the other hand, if something good came out of a funny dispute and the desire to do something that is not feasible by ordinary methods - pourquoi pas? <br><br><img src="https://habrastorage.org/files/cee/d5c/fde/ceed5cfde2f34b4c90f6fd7a2a36f530.png"></div><p>Source: <a href="https://habr.com/ru/post/268263/">https://habr.com/ru/post/268263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268251/index.html">Welcome to GDG DevFest Voronezh 2015</a></li>
<li><a href="../268253/index.html">Usability Authorization Forms</a></li>
<li><a href="../268257/index.html">Integration of CoreSpotlight on the example of "Rambler. Mail"</a></li>
<li><a href="../268259/index.html">The problem of cheats in online games</a></li>
<li><a href="../268261/index.html">Three-Way Bitwise Quick Sort</a></li>
<li><a href="../268265/index.html">AngularJS: Migration from 1.2 to 1.4, Part 1</a></li>
<li><a href="../268267/index.html">Sometimes less is better - why only Google authorization? + channel Rusbase</a></li>
<li><a href="../268269/index.html">Why I chose Yii2</a></li>
<li><a href="../26827/index.html">Firefox Setup 3.0 RC 2</a></li>
<li><a href="../268271/index.html">ECFG: put ~ / .emacs on a diet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>