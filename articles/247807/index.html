<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Combinatorial algorithms: combination index, partitioning into subsets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Short preface 
 Combinatorial algorithms are used quite often. On the Internet you can find a lot of information regarding combinatorial algorithms. H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Combinatorial algorithms: combination index, partitioning into subsets</h1><div class="post__text post__text-html js-mediator-article"><h3>  Short preface </h3><br>  Combinatorial algorithms are used quite often.  On the Internet you can find a lot of information regarding combinatorial algorithms.  However, the Russian-language Internet, basically, gives the simplest tasks of continuous enumeration (generation) of combinatorial objects in a cycle.  For example: <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   3  52 for (int i1 = 0; i1 &lt; 50; ++i1) for (int i2 = i1+1; i2 &lt; 51; ++i2) for (int i3 = i2+1; i3 &lt; 52; ++i3) // ...</span></span></code> </pre> <br></div></div><br><h3>  Combination index </h3><br>  Each combination, permutation, placement, and other combinatorial objects can be associated with an index ‚Äî this is the number in which it appears when iterating through this algorithm. <br><br>  Here we will look at a more complex task, the solutions of which I haven‚Äôt found in Runet (however, I‚Äôll give one <a href="http://www.sql.ru/forum/650975/kak-uznat-indeks-sochetaniya-kombinatorika-znaya-vybrannoe-podmnozhestvo">link</a> , but that formula is clearly incorrect) - based on the combination itself (in this case, a set of three numbers), find its index. <br><a name="habracut"></a><br>  There is a brute force "in the forehead."  We turn on the counter of combinations, we take the algorithm above and until we reach the desired option, we sort out everything.  This option has a very large time complexity, so this option will be discarded. <br>  Suppose there are numbers i1, i2, i3 at the input.  First of all, we need to arrange them in ascending order (note that the generation algorithm itself, given above, always displays them in an ordered form, although the very notion of ‚Äúcombination‚Äù implies an arbitrary order). <br><br>  Put, for definiteness, after ordering i1 = 3, i2 = 7, i3 = 12. <br>  This means that we ‚Äúwent through‚Äù all the combinations, where i1 was equal to 0, 1 and 2. <br>  For i1 = 0, we went through C (2, 51) combinations, since the indices i1, i2 run through all the combinations of 2 out of 51 numbers. <br>  For i1 = 1, we passed C (2, 50) combinations. <br>  For i1 = 2, we passed C (2, 49) combinations. <br>  Total we passed the SUM {from n = 0 to n = i1-1) C (2, 51-n}. <br>  With i1 = 3, we will consider the combinations that we went through, running over the index i2 (and it starts with i2 = i1 + 1 = 4). <br>  With i2 = 4, C (1, 47) combinations passed, with i2 = 5 C (1, 46) combinations passed, with i2 = 6 C (1, 45) combinations passed. <br>  By complete analogy, with i2 = 7, we consider the combinations that the i3 index ran. <br>  We get the general formula: <br>  The desired combination index = SUM {from n = 0 through i1-1} C (2, 51-n) + SUM {from n = i1 + 1 through i2-1} C (1, 51-n) + SUM {from n = i2 + 1 through i3-1} C (0, 51-n). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Index of partitioning into subsets </h3><br>  In combinatorics, there is a more complex object - splitting into subsets.  For example, splitting a 52-element set into three subsets, consisting, respectively, of, say, 2, 3, and 47 elements, where the order of the elements within each subset is unimportant.  (By the way, a combination of 2 out of 52 is just a special case of splitting into two subsets of 2 and 50 elements, respectively). <br><br>  A typical generation algorithm is that we generate combinations of 2 of 52, and for each such combination in a nested loop we generate combinations of 3 of 50, and check that the indices (i3, i4, i5) in the nested combination do not match the indices (i1, i2) in external combination: <br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   for (int i1 = 0; i1 &lt; 51; ++i1) for (int i2 = i1+1; i2 &lt; 52; ++i2) //   for (int i3 = 0; i3 &lt; 50; ++i3) if (i3 != i1 &amp;&amp; i3 != i2) for (int i4 = i3+1; i4 &lt; 51; ++i4) if (i4 != i1 &amp;&amp; i4 != i2) for (int i5 = i4+1; i5 &lt; 52; ++i5) if (i5 != i1 &amp;&amp; i5 != i2) // ...</span></span></code> </pre><br></div></div><br>  Again, each such partition has its own index. <br>  It turns out that our algorithm for finding the combination index can be modified to find the partition index. <br>  It should be noted that the indices in the ‚Äúexternal combination‚Äù i1, i2 must be ordered among themselves, and the indices i3, i4, i5 among themselves, but independently of the first two. <br>  It should also be noted that in the ‚Äúnested combination‚Äù we are essentially working with a 50-element set, but the indices i3, i4, i5 need to be ‚Äúshifted‚Äù in a certain way so that they change not from 0 to 51, but from 0 to 49: <br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i3 &gt;= i1) --i3; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i3 &gt;= i2) --i2; <span class="hljs-comment"><span class="hljs-comment">//   i4, i5</span></span></code> </pre><br></div></div><br>  (so to speak, we cut out the indices i1, i2 from our 52-element set and then shift the remaining set to close the holes, while the indexes i3-i5 are shifted). <br>  It should be borne in mind that inside each "external" combination we have exactly C (3, 50) "nested" combinations. <br>  Then the algorithm will be reduced to the following: <br>  CALCULATION INDEX (i1, i2 of 52) * NUMBER OF COUNTINGS_PO_3_IZ_50 + CALCULATION INDEX (i3, i4, i5 of 50 after the shift of indices). <br><br><h3>  Reduction of algorithms to constant complexity </h3><br>  Immediately I should note that a ‚Äúerror‚Äù occurs in the formula if, for example, i1 = 0 (we assume the sum for n = from 0 to -1) or i2 = 1 (we count the sum from 1 to 0).  In fact, in such cases, the corresponding amount should be taken equal to zero, and the result will be correct. <br>  I should also pay attention to the time complexity of our algorithms: they have linear complexity, provided that C is considered to be constant time.  This is much better than brute force. <br>  But in fact, <i>for a fixed dimension of the base set</i> (in our case 52), nothing prevents us from reducing the algorithm to constant complexity.  For this, we apply the knowledge of mathematics and analytically calculate all sums. <br>  For example, the number of combinations of C (2, K), if "open" it in the form of the formula K!  / ((K-2)! * 2!), Is reduced to a polynomial of the 2nd degree.  And since we have it under the sum sign, then we can apply the formulas for the sum of the Nth powers of the numbers of the natural series (see <a href="https://en.wikipedia.org/wiki/Faulhaber%2527s_formula">Wikipedia</a> ) and get a single polynomial of the 3rd degree.  Which obviously has a constant temporal complexity.  (And the ‚Äúmistake‚Äù that I gave at the beginning of the subtitle doesn‚Äôt manifest itself at all, the formula remains correct). <br>  Again, this is <i>for a fixed dimension of the base set</i> .  However, I am sure that using metaprogramming, you can ‚Äúteach‚Äù the compiler to do this work for you. <br><div class="spoiler">  <b class="spoiler_title">Sample code for index splitting into 2, 3, 47</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_split_2_3_47_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i5)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    2  52,   C(3, 50) int offset = ( (52*51 - (51-i1)*(52-i1)) / 2 + (i2 - i1 - 1) ) * 19600; // ""   ,    0...49 if (i3 &gt;= i1) --i3; if (i3 &gt;= i2) --i3; if (i4 &gt;= i1) --i4; if (i4 &gt;= i2) --i4; if (i5 &gt;= i1) --i5; if (i5 &gt;= i2) --i5; //      3 // 0: //   n = 0  i3-1  (2, 49-n) // =   m = 50-i3  49 (m * (m-1) / 2) offset += (19600 - ( ((49-i3)*(50-i3)*(99-2*i3)) / 6 - ((49-i3)*(50-i3)) / 2 ) / 2 ); // 1: //   n = i3+1  i4-1  (1, 49-n) offset += (((48-i3)*(49-i3) - (49-i4)*(50-i4)) / 2); // 2: //   n = i4+1  i5-1 (1) offset += (i5 - i4 - 1); return offset; }</span></span></code> </pre><br></div></div><br><br><h3>  Afterword </h3><br>  In my poker simulator (Texas Hold'em), I wanted to pre-calculate and store the winning probabilities for all possible combinations of my hand cards (2 pieces) and all the flop cards (3 cards on the table).  This corresponds to the division of the 52-set into 2, 3, 47 subsets. <br>  Calculated and saved. <br>  But when it came time to read the data from a file for a particular combination, I really didn‚Äôt want to calculate something for a long time or search in a gigabyte file.  Now I just define the offset in the file and read directly what I need. <br><br>  In general, I would divide combinatorial algorithms into such classes: <br><ul><li>  Generation of combinatorial objects in a single cycle (everything is simple, I gave examples); </li><li>  The transition to the next (or previous) combinatorial object, knowing the previous one (a kind of forward / backward iterator, to put it in terms of C ++) - here you can mention the textbook T. I. Fedoriaeva, where the constant time complexity algorithm for permutations is given, and other examples in runet can be found, but only for permutations - and it would be interesting to see similar algorithms for other combinatorial objects; </li><li>  Finding the index of the object.  There are no examples at all, except for Fedoryaeva‚Äôs allowance, with linear complexity, and only for permutation; </li><li>  Finding an object by index. </li></ul><br>  It would be interesting to get a reference book on combinatorial algorithms for all combinatorial objects, including permutations, combinations, placements, splitting into subsets, combinations with repetitions, placing with repetitions. </div><p>Source: <a href="https://habr.com/ru/post/247807/">https://habr.com/ru/post/247807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247789/index.html">How I loved vim, emacs and keyboard</a></li>
<li><a href="../247791/index.html">Experiment: 10 things that I learned, using only water for a month</a></li>
<li><a href="../247793/index.html">Monitoring from Brazil - continue to conquer Latin America</a></li>
<li><a href="../247799/index.html">ATtiny13a: Controller of the STOP signal and the parking lights of the car</a></li>
<li><a href="../247805/index.html">Concurrent programming with CUDA. Part 3: Fundamental GPU algorithms: convolution (reduce), scan (scan) and histogram (histogram)</a></li>
<li><a href="../247809/index.html">Perhaps the first game on Dart + Box2D</a></li>
<li><a href="../247811/index.html">Three-dimensional background for the site in real time on JavaScript using three.js</a></li>
<li><a href="../247813/index.html">Non-personalized recommendations: association method</a></li>
<li><a href="../247815/index.html">Micro-conference UX-Wednesday ‚Ññ21 in the framework of User Experience Russia 2014</a></li>
<li><a href="../247817/index.html">Herringbone, light up! Part 1: Garland and build software for OpenWRT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>