<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows 8.1 Kernel Patch Protection - PatchGuard</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodically, as a rule, on the second Wednesday of the month, you can hear stories that Windows, after the next update, stops loading, showing the bl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows 8.1 Kernel Patch Protection - PatchGuard</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/91e/da9/5e2/91eda95e2394493386212af5e4969c76.png" align="left" alt="image">  Periodically, as a rule, on the second Wednesday of the month, you can hear stories that Windows, after the next update, stops loading, showing the blue screen of death.  In most cases, the cause of such a situation is either a rootkit or specific system software that treats the internal structures of the operating system frivolously.  The blame, of course, is still an update, because ‚Äúeverything worked before it‚Äù.  With this attitude, it is not surprising that Microsoft does not encourage the use of everything that is not documented.  At some point, namely with the release of Windows Server 2003, MS took a more active position in the fight against third-party miracle crafts.  Then a kernel integrity protection mechanism appeared - kernel patch protection, better known as PatchGuard. <br><br>  From the very beginning, it was not positioned as a protection mechanism against rootkits, since rootkits work in the kernel with the same privileges, and therefore, PatchGuard can be disabled.  It is rather a filter that cuts off lazy rootkit developers. <a name="habracut"></a><br><br><h4>  What PatchGuard Protects </h4><br>  The most popular place for modifying the kernel was the system call table.  By modifying the pointers to the functions of the system calls, they could easily be intercepted, filtered, logged, etc. Moreover, this patch was popular for both rootkits and antivirus software.  Other objects of interest for the patch are descriptor tables (GDT, IDT).  Through modifying the global table of descriptors, it was possible to change the attributes of the segments, creating backdoors for the code, and through the table of interrupt descriptors it was possible to intercept ... interrupts!  The advanced guys splice the kernel functions themselves. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Accordingly, the first version of PatchGuard protected: <br><ul><li>  system call tables (SST), </li><li>  global descriptor table (GDT), </li><li>  interrupt descriptor table (IDT) </li><li>  kernel image </li><li>  nuclear stacks. </li></ul><br>  With the development of NT, many components of the kernel were reworked, including PatchGuard.  At the moment it is already difficult to list everything that is protected with its help: <br><ul><li>  many system images, not only the kernel image (nt, hal, WerLiveKernelApi, tm, clfs, pshed, kdcom, bootvid, ci, msrpc, ndis, ntfs, tcpip, fltmgr), </li><li>  critical kernel data structures (for example, a process list), </li><li>  MSR set (for example, model specific register IA32_LSTAR), </li><li>  KdpStub is a debugger routine that gets control after exceptions. </li></ul><br><h4>  How PatchGuard Guards </h4><br>  It should be noted that PatchGuard is actively using the new implementation of exception handling, introduced in x64-versions of Windows.  It is used both for obfuscating PatchGuard itself and for checking the integrity of protected images. <br><br>  In previous versions of Windows, the exception handler used data structures directly on the stack, which even made it possible to bypass stack cookies when exploiting vulnerabilities.  The main change is the storage of a special table within the executable image with entries for each of its individual functions. <br><br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_RUNTIME_FUNCTION_ENTRY</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> BeginAddress; <span class="hljs-comment"><span class="hljs-comment">//   uint32_t EndAddress; //   union { uint32_t UnwindInfoAddress; //   ,      uint32_t UnwindData; //   }; } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;</span></span></code> </pre> <br>  Due to the fact that the address of the beginning and end of any function can be obtained directly in runtime, the task of counting the checksum of a single function becomes trivial.  For comparison, in the x86 versions, the integrity control of images is impossible because it is not clear how to define the boundaries of a particular function, and the entire image (or even its individual sections) cannot be covered with a checksum because the same core contains functions that are patched by the core itself on the fly. <br><br>  When loading the OS, PatchGuard creates from 1 to 4 contexts - data structures in which copies of the functions used by it are stored, checksums of the structures being protected and the encryption keys of the context itself.  These contexts are stored in an unloaded pool in an encrypted form.  Let's talk about context checking a bit later. <br><br>  PatchGuard contexts are initialized in phase 1 of the OS boot.  The function directly involved in creating the context does not have a public symbol (we will call it KiInitializePatchGuardContext), but you can find it inside the KiFilterFiberContext function.  We found two places in which to create a PatchGuard context: <br><br><pre> <code class="dos hljs">... -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; Phase1InitializationDiscard -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; KeInitAmd64SpecificState -(exception)-&gt; KiFilterFiberContext</code> </pre><br><pre> <code class="dos hljs">... -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; Phase1InitializationDiscard -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; sub_14071815C -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; ExpLicenseWatchInitWorker -(<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>)-&gt; KiFilterFiberContext</code> </pre><br>  The first option always creates at least one context, while the second only in 4% of cases.  Also, the first option is notable for the fact that it invokes the KiFilterFiberContext function implicitly, namely, by throwing an exception. <br><div class="spoiler">  <b class="spoiler_title">Pseudocode KeInitAmd64SpecificState</b> <div class="spoiler_text"><pre> <code class="hljs ruby">__int64 KeInitAmd64SpecificState() { signed int v<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> edx@2 __int64 result; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> rax@2 /<span class="hljs-regexp"><span class="hljs-regexp">/    PatchGuard   if ( !InitSafeBootMode ) { v0 = __ROR4__(KdPitchDebugger | KdDebuggerNotPresent, 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       (    -1), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      KiFilterFiberContext result = (v0 /</span></span> ((KdPitchDebugger <span class="hljs-params"><span class="hljs-params">| KdDebuggerNotPresent) != 0 ? -1 : 17)); } </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span><span class="hljs-params"> result; }</span></span></code> </pre><br></div></div><br>  The function sub_14071815C obviously does not have a public symbol, since it is associated with checking the OS license. <br><div class="spoiler">  <b class="spoiler_title">ExpLicenseWatchInitWorker pseudocode</b> <div class="spoiler_text"><pre> <code class="hljs ruby">VOID ExpLicenseWatchInitWorker() { PVOID KiFilterParam; NTSTATUS (*KiFilterFiberContext)(PVOID pFilterparam); BOOLEAN ForgetAboutPG; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> KiServiceTablesLocked == KiFilterParam KiFilterParam = KiInitialPcr.Prcb.HalReserved[<span class="hljs-number"><span class="hljs-number">1</span></span>]; KiInitialPcr.Prcb.HalReserved[<span class="hljs-number"><span class="hljs-number">1</span></span>] = NULL; KiFilterFiberContext = KiInitialPcr.Prcb.HalReserved[<span class="hljs-number"><span class="hljs-number">0</span></span>]; KiInitialPcr.Prcb.HalReserved[<span class="hljs-number"><span class="hljs-number">0</span></span>] = NULL; ForgetAboutPG = (InitSafeBootMode != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-params"><span class="hljs-params">| (KUSER_SHARED_DATA.KdDebuggerEnabled &gt;&gt; 1); // 96%  </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (__rdtsc() % 100 &gt; 3) ForgetAboutPG |</span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ForgetAboutPG &amp;&amp; KiFilterFiberContext(KiFilterParam) != <span class="hljs-number"><span class="hljs-number">1</span></span>) KeBugCheckEx(SYSTEM_LICENSE_VIOLATION, <span class="hljs-number"><span class="hljs-number">0x42424242</span></span>, <span class="hljs-number"><span class="hljs-number">0xC000026A</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br>  Below is the pseudo-code of the KiFilterFiberContext function, which selects the method for checking a specific context and calls the function for creating the context itself. <br><div class="spoiler">  <b class="spoiler_title">KiFilterFiberContext pseudocode</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> KiFilterFiberContext(PVOID pKiFilterParam) { <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>; DWORD64 dwDpcIdx1 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">13</span></span>; //  DPC,      DWORD64 dwRand2 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">10</span></span>; // <span class="hljs-number"><span class="hljs-number">50</span></span>  <span class="hljs-number"><span class="hljs-number">50</span></span>,     DWORD64 dwMethod1 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">6</span></span>; //     AntiDebug(); Result = KiInitializePatchGuardContext(dwDpcIdx, dwMethod1, (dwRand2 &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, pKiFilterParam, <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dwRand2 &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) { DWORD64 dwDpcIdx2 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">13</span></span>; DWORD64 dwMethod2 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { dwMethod2 = __rdtsc() % <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((dwMethod1 != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (dwMethod1 == dwMethod2)); Result = KiInitializePatchGuardContext(dwDpcIdx2, dwMethod2, <span class="hljs-number"><span class="hljs-number">2</span></span>, pKiFilterParam, <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>); } AntiDebug(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result; }</code> </pre><br></div></div><br>  The function that creates the PatchGuard context is so obfuscated that automatic tools cannot cope with it, and researchers suddenly find it uninteresting to reverse it.  In statics, this is a complete mess, 10K + lines of decompiled head-on code (decompilation itself in IDA Pro takes about 40 minutes). <br><br><img src="https://habrastorage.org/files/622/a1d/6b2/622a1d6b281e4938b0d53014e62a2e9c.png" alt="image"><br><br>  Everything speaks about the extensive use of macros: <br><ul><li>  even the simplest operation, such as taking a random number, is spread over 50+ lines of assembly code; </li><li>  all cycles are expanded; </li><li>  a lot of dead code is inserted; </li><li>  indirect access to variables and external functions is used. </li></ul><br>  Dynamics is also quite difficult.  Here are a couple of examples of what is scattered around the code. <br><pre> <code class="dos hljs">cli xor eax, eax cmp byte ptr cs:KdDebuggerNotPresent, al jnz short loc_140F3CFBD jmp short loc_140F3CFBB sti</code> </pre><br><div class="spoiler">  <b class="spoiler_title">What does the anti-debugging trick 1 do?</b> <div class="spoiler_text">  When the debugger is connected, it enters an infinite uninterrupted loop. <br></div></div><br><pre> <code class="dos hljs">cli sidt fword ptr [rbp+<span class="hljs-number"><span class="hljs-number">320</span></span>h] lidt fword ptr [rbp+<span class="hljs-number"><span class="hljs-number">228</span></span>h] mov dr7, r13 lidt fword ptr [rbp+<span class="hljs-number"><span class="hljs-number">320</span></span>h] sti</code> </pre><br><div class="spoiler">  <b class="spoiler_title">What does the anti-debugging trick 2 do?</b> <div class="spoiler_text">  Loads a temporary invalid interrupt descriptor table.  If we watched access to the debug registers, a debug exception will occur that, under these conditions, will cause a tripple fault followed by a reboot. <br></div></div><br>  Consider the parameters of the KiInitializePatchGuardContext function. <br><ol><li>  The DPC index of the function to be called for context checking and can be one of the following: <br><ul><li>  KiTimerDispatch </li><li>  KiDpcDispatch </li><li>  ExpTimerDpcRoutine </li><li>  Ioptimerdispatch </li><li>  IopIrpStackProfilerTimer </li><li>  PopThermalZoneDpc </li><li>  CmpEnableLazyFlushDpcRoutine </li><li>  CmpLazyFlushDpcRoutine </li><li>  KiBalanceSetManagerDeferredRoutine </li><li>  ExpTimeRefreshDpcRoutine </li><li>  ExpTimeZoneDpcRoutine </li><li>  ExpCenturyDpcRoutine </li></ul><br></li><li>  Scheduling verification method: <br><ol><li>  KeSetCoalescableTimer <br>  A timer object is created, which will start the test after 2m: 05s ¬± 5 s. </li><li>  Prcb.AcpiReserved <br>  DPC will operate at a specific ACPI event, for example, when it enters a low power state.  It works not earlier than in 2m: 05s ¬± 5 s. </li><li>  Prcb.HalReserved <br>  DPC will work with the HAL timer tick.  Not earlier than in 2m: 05s ¬± 5 s. </li><li>  PsCreateSystemThread <br>  A separate system stream is created, sleeping 2 m: 05 s ¬± 5 s.  After this, the context check is invoked. </li><li>  KeInsertQueueApc <br>  A regular kernel APC is created that works immediately, but waits for 2m: 05s ¬± 5 seconds inside the work item. </li><li>  KiBalanceSetManagerPeriodicDpc <br>  DPC will work according to the timer of the balancing manager, not earlier than in 2m: 05s ¬± 5 s. </li></ol><br></li><li>  The purpose of the parameter is not completely clear; it is only known that it affects the number of checks in the context. </li><li>  Parameter specific to the selected planning method. </li><li>  Parameter indicating the need for recalculation of checksums for the context. </li></ol><br>  DPCs that call validation through an exception within themselves, ‚Äúlook‚Äù - whether the DeferredContext parameter is a pointer to non-canonical memory.  If the pointer is OK, the DPC does its legitimate work.  Otherwise, the DPC calls a chain of recursive functions, which ultimately lead to an exception (due to dereference of the non-canonical address) and the execution of its handler. <br><div class="spoiler">  <b class="spoiler_title">Call sequences of recursive functions depending on the DPC function</b> <div class="spoiler_text">  ExpTimerDpcRoutine -&gt; KiCustomAccessRoutine0 -&gt; KiCustomRecurseRoutine0 ... KiCustomRecurseRoutineN <br>  IopTimerDispatch -&gt; KiCustomAccessRoutine1 -&gt; KiCustomRecurseRoutine1 ... KiCustomRecurseRoutineN <br>  IopIrpStackProfilerTimer -&gt; KiCustomAccessRoutine2 -&gt; KiCustomRecurseRoutine2 ... KiCustomRecurseRoutineN <br>  PopThermalZoneDpc -&gt; KiCustomAccessRoutine3 -&gt; KiCustomRecurseRoutine3 ... KiCustomRecurseRoutineN <br>  CmpEnableLazyFlushDpcRoutine -&gt; KiCustomAccessRoutine4 -&gt; KiCustomRecurseRoutine4 ... KiCustomRecurseRoutineN <br>  CmpLazyFlushDpcRoutine -&gt; KiCustomAccessRoutine5 -&gt; KiCustomRecurseRoutine5 ... KiCustomRecurseRoutineN <br>  KiBalanceSetManagerDeferredRoutine -&gt; KiCustomAccessRoutine6 -&gt; KiCustomRecurseRoutine6 ... KiCustomRecurseRoutineN <br>  ExpTimeRefreshDpcRoutine -&gt; KiCustomAccessRoutine7 -&gt; KiCustomRecurseRoutine7 ... KiCustomRecurseRoutineN <br>  ExpTimeZoneDpcRoutine -&gt; KiCustomAccessRoutine8 -&gt; KiCustomRecurseRoutine8 ... KiCustomRecurseRoutineN <br>  ExpCenturyDpcRoutine -&gt; KiCustomAccessRoutine9 -&gt; KiCustomRecurseRoutine9 ... KiCustomRecurseRoutineN <br></div></div><br>  The context check consists of two stages: first, checking the structure of the context itself, which occurs at the DPC level, then a work item is planned, which checks the protected structures in the system flow.  If the test was successful, the old context is deleted and a new one is created instead, which will be launched at a random time interval.  If the check fails, PatchGuard clears all its tracks, including zeroing the stack, and displays a blue screen with error code 0x109: CRITICAL_STRUCTURE_CORRUPTION. <br><br>  Gif with self-decrypting context in the first stage of verification: <br><img src="https://habrastorage.org/files/8fd/6a5/849/8fd6a58495e1413486476ea934f9f9f4.gif" alt="image"><br><br><h4>  How to win </h4><br>  There are several approaches to neutralizing PatchGuard: <br><ul><li>  Such a patch of the kernel image so that PatchGuard is not initialized at all. </li><li>  Patch context checking procedures. </li><li>  Hook KeBugCheck with system state recovery. </li><li>  Cancellation of scheduled checks is what we implemented. </li></ul><br>  We liked the latter method, since it is the most ‚Äúpure‚Äù: nothing needs to be hooked and dirty, you just need to replace the value of some variables. <br><ol><li>  KeSetCoalescableTimer <br>  You need to scan all timers for which the DPC will contain a DeferredContext with a non-canonical address, and increase the timeout for those found to infinity. </li><li>  Prcb.AcpiReserved <br>  Just zanulit this field. </li><li>  Prcb.HalReserved <br>  Just zanulit this field. </li><li>  PsCreateSystemThread <br>  Scan the sleeping threads and unwind their stack.  If it rests on a function from the KiServiceTablesLocked structure, this is our client.  We set a hibernation time equal to infinity. </li><li>  KeInsertQueueApc <br>  Scan all workflows with stack promotion.  If there are functions in the stack that are not from the kernel code section, and they are untwisted using the data for the functions FsRtlMdlReadCompleteDevEx and FsRtlUnininitializeSmallMcb, this is exactly the PatchGuard workflow.  We neutralize as in the previous version. </li><li>  KiBalanceSetManagerPeriodicDpc <br>  Restore the "legitimate" procedure - KiBalanceSetManagerDeferredRoutine. </li></ol><br>  These actions must be completed in 2 minutes for the reasons described above.  The result is that the context check will never be launched, and a new one will not be scheduled.  PatchGuard will not work. <br><br><h4>  Windows 10 </h4><br>  When viewing KiFilterFiberContext from Windows 10 Technical Preview, we noticed a slight change.  All old planning methods remained the same.  However, a new one has appeared, which so far unconditionally returns STATUS_HV_FEATURE_UNAVAILABLE.  Having a little rummaged, we found the KiSwInterruptDispatch function, inside which there is a clear decryption and a call to the context check.  Obviously, the ability to check contexts on the Hyper-V hypervisor request will be added.  Under certain conditions, a synthetic interrupt will come from the hypervisor, the handler of which will check the integrity of the kernel. <br><br><h4>  The story continues </h4><br>  In the article we tried not to specify the names of specific functions, not because we feel sorry for.  It's simple: the names of the functions used to decrypt and verify contexts are intentionally changed by the developers of PatchGuard and are changed in different versions of the OS. <br><br>  Here is an example of the inconsistency of the function name with what it actually does.  This is the same function, a copy of which is used to self-interpret the context. <br><img src="https://habrastorage.org/files/46b/d0f/bea/46bd0fbea53e48848695c1722c9df477.png" alt="image"><br><br>  One thing is good - all these functions are nearby, so you can start with the KiFilterFiberContext function.  Obviously, they all lie in one source file.  However, kernel integrity checking is not limited to PatchGuard alone.  Macros are inserted into various parts of the kernel, checking for those or other structures.  Each such place has to be searched manually.  Example: <br><br><pre> <code class="dos hljs">... --&gt; Phase1InitializationDiscard --&gt; CcInitializeCacheManager --&gt; CcInitializeBcbProfiler</code> </pre><br>  With a probability of 50%, this function calculates a checksum for an arbitrary kernel function and plans to check it every 2 minutes in DPC with the CcBcbProfiler function. <br><br>  So good luck with your search!  PatchGuard is interesting precisely because it is fun to reverse;) <br><br>  Links to help: <br>  <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/dn613955(v%3Dvs.85).aspx">Kernel patch protection: frequently asked questions</a> <br>  <a href="http://uninformed.org/index.cgi%3Fv%3D3%26a%3D3">Bypassing PatchGuard on Windows x64</a> <br>  <a href="http://uninformed.org/index.cgi%3Fv%3D8%26a%3D5">PatchGuard Reloaded</a> <br>  <a href="http://kitrap08.blogspot.ru/2012/07/patch-guard-1.html">TSS blog: Patch-Guard 1</a> <br>  <a href="http://vrt-blog.snort.org/2014/08/the-windows-81-kernel-patch-protection.html">The Windows 8.1 Kernel Patch Protection</a> <br>  <a href="http://www.nosuchcon.org/talks/2014/D2_01_Andrea_Allievi_Win8.1_Patch_protections.pdf">Understanding and Defeating Windows 8.1 Kernel</a> <a href="http://www.nosuchcon.org/talks/2014/D2_01_Andrea_Allievi_Win8.1_Patch_protections.pdf"><br></a>  <a href="http://www.nosuchcon.org/talks/2014/D2_01_Andrea_Allievi_Win8.1_Patch_protections.pdf">Patch protection</a> <br>  <a href="http://blog.ptsecurity.com/2014/09/microsoft-windows-81-kernel-patch.html">Microsoft Windows 8.1 Kernel Patch Protection Analysis &amp; Attack Vectors</a> </div><p>Source: <a href="https://habr.com/ru/post/246841/">https://habr.com/ru/post/246841/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246829/index.html">Authorization of users with AngularJS and Firebase</a></li>
<li><a href="../246831/index.html">Eleventh grader, or we test layout bugs</a></li>
<li><a href="../246835/index.html">Video Metadata Framework SDK Video Metadata Management Tool - Intel New Year Gift</a></li>
<li><a href="../246837/index.html">Introducing Pop-up Events</a></li>
<li><a href="../246839/index.html">Why employees of large companies use ‚Äúleft‚Äù software for professional communication and what to do about it</a></li>
<li><a href="../246843/index.html">Why great achievements will not make you happier (and what to do about it!)</a></li>
<li><a href="../246845/index.html">Not another evalboard for STM32 - we do it right in XFR-L3 "KYRNN"</a></li>
<li><a href="../246849/index.html">Hacker's guide to neural networks. Chapter 2: Machine Learning. Network learning based on support vector machine (SVM)</a></li>
<li><a href="../246851/index.html">Do not make icons, make live tiles</a></li>
<li><a href="../246853/index.html">School call to .NET Micro Framework with remote control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>