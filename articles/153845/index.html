<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Marcus Bread and YAGNI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, two heroes appeared in our news feed, bakers programmers Boris and Markus. Boris is a good person and a perfectionist, and Marcus is a very ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Marcus Bread and YAGNI</h1><div class="post__text post__text-html js-mediator-article"><img alt="image" src="https://habrastorage.org/getpro/habr/post_images/7a8/e25/627/7a8e256279e46e5fde0259a478672bff.jpg" width="220" height="165" align="left">  Recently, two heroes appeared in our news feed, bakers programmers Boris and Markus.  Boris is a good person and a perfectionist, and Marcus is a very modest and gray programmer who does not want to stand out.  Both strive for the best and want to be helpful.  But it seems that Marcus did not try very hard. <br>  This is a new branch - continuation.  Today, the storyline touches only Marcus.  He is the main character. <br>  So, the story under the cut. <br><a name="habracut"></a><br>  Original post: <a href="http://habrahabr.ru/post/153225/">How two programmers baked bread</a> <br><br>  <strong>Introduction</strong> <br><br>  I considered that in the original post much attention was paid to Boris and very little to Marcus.  Perhaps because of his modesty.  The post was fun, I, and many, judging by the comments, liked.  And I am very glad that they shot <a href="http://www.gnuman.ru/joel/Ne_dajte_Astronavtam_Arhitektury_vas_zapugat/">astronauts of architecture</a> .  And Marcus was in an advantageous position.  But it was only the first volley, it was time to adjust the scope.  In the original post there was a certain trick - what Boris did was fully revealed, and what Marcus did remained in the shadows behind the external interface.  It was implicitly assumed that there was a terrible spaghetti code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today I will try to rehabilitate the position of Marcus.  The post will be devoted to the principle of YAGNI.  This is just an example of using YAGNI and is based on personal experience.  Unfortunately, there are not so many books that would show with examples how to apply this principle.  And the majority of programmers, besides reading books, give birth to these skills through experience and work.  I believe that this is exactly the skills of working with code, and not just a theory.  And such an experience would be nice to share.  I would be glad if I learned something new from you too.  This post is only about practice and the task will be considered in C #.  That, unfortunately, can reduce the potential audience.  But I see no other way out, because the theory itself cannot be accepted by the opponents until they see real possibilities.  I don't like UML class diagrams.  And for Marcus, they apparently were not needed. <br><br>  I also ask that you don‚Äôt pay much for errors in style and C # code, since  I would just like to show the essence of the approach, as I understand it.  And do not spray your attention on the little things.  Also, I will not show the TDD approach, I will not show how to write unit tests, otherwise even for such a simple task the post would be very voluminous.  Although, TDD, of course, would add its own corrections to the code.  But we are only interested in whether Marcus would have gotten so bad code if he had used YAGNI, as it seemed from the original post. <br><br>  And of course, I will write trivial things.  With many, judging by the comments, I am a like-minded person and they would write such a post no worse.  And some are even much better (using the functional approach). <br><br>  Let's start.  Let's go through the entire chain of requirements.  I am Marcus.  True, I'm a little different Marcus and do not exactly behave like the previous one. <br><br>  <strong>Requirement 1</strong> <br>  <em>- Guys, we need bread to be made.</em> <br><br>  <strong>Analysis</strong> <br><br>  To make bread, you need a method.  What is bread?  This is a kind of entity.  This is not an object, otherwise it can be confused with other objects.  This is not an int or any other built-in or created type.  So bread is a new separate class.  Does he have a condition or behavior?  Personally, I know that it consists of dough (flour, wheat or rye ...), that you can buy it in the store and that you can eat it.  But this is my personal knowledge.  The customer has not yet said a word about any behavior or condition.  And since  I‚Äôm a lazy person, even though I know a little more, I don‚Äôt press the button again, without directly indicating what the customer wants. <br><br>  We proceed only from the requirements: bread has no state and behavior, and also needs a method for obtaining bread.  The C # language itself unfortunately or fortunately requires a little more fuss, namely: to define a method in any class.  But since  the customer did not say a word about this, then we don‚Äôt bother with the name, we don‚Äôt bother with the copies, I decided to do a static method.  If anything, always have time to redo it.  I choose the name to meet the most average understanding of the requirements.  So, the first code: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bread</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BreadMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeBread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } }</code> </pre> <br><br>  <strong>Requirement 2</strong> <br>  <em>- We need to not just make bread, and baked in the oven</em> <br><br>  <strong>Analysis</strong> <br><br>  Sometimes customers want to specify how to implement something, instead of saying what they want.  The wishes of the customer about the implementation of me neither physically nor psychologically do not act.  In this case, this is not a requirement.  The customer can not verify where I took the bread.  And until he even expressed such a desire - to check.  Therefore, how I get bread and give it to him is not its customer business.  But I can politely agree with the demand and be glad that they continue to pay money for idleness. <br><br>  While doing nothing.  But just in case, I remember about the stove.  The customer did not indicate either the stove, or their differences, or their different influence on the bread.  The latter is also important.  Even if the customer indicated several types of ovens, there is still no hurry - the bread is the same. <br><br>  But nevertheless we will make the authorities happy and slightly correct the code so that it matches the meaning.  Namely: we already know that bread will be baked in the oven, and not bought in the store.  Just rename the method of obtaining bread: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BreadMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeBread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } }</code> </pre><br><br>  <strong>Requirement 3</strong> <br>  <em>- We need a gas stove to not be able to stove without gas</em> <br><br>  <strong>Analysis</strong> <br><br>  ABOUT!  New information has come.  It turns out that there is a gas stove and its behavior is different from other stoves.  True, the topic of other furnaces is not disclosed again.  Well, okay.  Let them be different. <br><br>  Let's try to compare several implementations. <br><br>  Implementation 1. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Oven { GasOven, OtherOven } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BreadMaker</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> GasLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeBread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Oven oven</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oven == Oven.GasOven &amp;&amp; GasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } }</code> </pre><br><br>  Immediately struck by the side effect.  Sets the gas level separately from the BakeBread () call.  Once there is a gap, then a wide field of opportunities opens up for the appearance of bugs.  The appearance of these bugs (bugs) can damage our field, then there will be no wheat and, therefore, no bread. <br><br>  With such a separate setting of parameters, the user of our code (and we can be this victim-user as well) may well forget to set the gas level before starting the gas furnace.  And then the gas level may remain from the previous setting of the stove, when we baked bread before.  Which will lead to unpredictable behavior if we really forget. <br><br>  We also see that the property is static.  Which is also very bad - we have only one level of gas.  But getting rid of static methods and properties does not solve the problem described above, so we do not consider this option. <br><br>  Implementation 2. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Oven { GasOven, OtherOven } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BreadMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeBread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Oven oven, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gasLevel</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oven == Oven.GasOven &amp;&amp; gasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } }</code> </pre><br><br>  Pretty simple.  And a little better than the previous version of the implementation.  But matching parameters are not always passed to the BakeBread () method.  For non-gas furnaces gasLevel does not make sense.  And although the method will work, the task of gasLevel for non-gas furnaces will confuse users of our code.  And the correctness of the parameters is not checked at the compilation stage. <br><br>  Implementation 3. In order to coordinate the parameters, the furnace will have to be made, it seems, by classes. <br>  And the usual bake bread always, but gas is not always.  Those.  two classes, virtual methods, overload.  But you need to think about how to make access modifiers so that the furnaces do not create by themselves, but use my BakeBread () method, otherwise side effects will appear. <br><br>  And here it overshadows me (Marcus)!  At this stage, it is enough to do so: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BreadMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeBreadByGasOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gasLevel</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeBreadByOtherOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bread(); } }</code> </pre><br><br>  And indeed, the customer has not yet said a word how we will use the furnaces.  This code is quite satisfactory at this stage. <br><br>  <strong>Requirement 4</strong> <br>  <em>- We need the ovens to bake more pies (separately - with meat, separately - with cabbage), and cakes.</em> <br><br>  <strong>Analysis</strong> <br><br>  Sure, not a problem!  And if you set the temperature in the oven, then we can bake ice cream in it.  Joke.  I, Marcus, try to be serious - not a word about temperature.  Who knows you, customers)) <br><br>  So, pies and cakes.  Moreover, two kinds of patties.  But this, we know from life that a meat patty and a cabbage pie have more in common than a cake.  But in the context of the task the customer did not talk about it.  He did not say that we would somehow group the cakes separately, the cakes separately.  Therefore, for now, based on the requirements, the cake behaves almost like a pie with cherries - they are all equal.  Do they have behavior?  Not.  Is there a condition?  Not.  This means that in order to distinguish them from each other, it is quite enough for us to start the transfer.  And to run ahead, guessing the wishes of the customer, which will arise tomorrow, we basically do not want.  This means that the listing is the most correct.  Probably.  Not sure.  But do not.  You can always rewrite, if that. <br><br>  In parallel, we change names, now we bake not bread, but bakery products. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BakeryProductType { Bread, MeatPasty, CabbagePasty, Cake } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProduct</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeryProduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BakeryProductType bakeryProductType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BakeryProductType = bakeryProductType; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BakeryProductType BakeryProductType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProductMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByGasOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BakeryProductType bakeryProductType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gasLevel</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(bakeryProductType); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByOtherOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BakeryProductType breadType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(breadType); } }</code> </pre><br><br>  <strong>Requirement 5</strong> <br>  <em>- We need bread, cakes and pies baked according to different recipes</em> <br><br>  <strong>Analysis</strong> <br><br>  Glancing at the code, we notice that we have an excellent enumeration of BakeryProductType.  It is called somehow clumsy, somehow programmatically, not close to the subject area.  But behaves like a recipe.  In what happens!  Bread and bread are baked by recipe, not by type.  And we all the same gets to the designer of the roll, probably the recipe.  Enough to rename.  The only disorder is the property-type "rolls".  But I would be humbled.  Looking mechanically at the code and imagining the subject area as some kind of set, I don‚Äôt see much difference between the recipe and the type.  Those.  The recipe is the direct cause of what happens afterwards.  Of course, in life, we know a little more about recipes - they not only describe what happens.  They also contain an acquisition algorithm.  But who cares?  The customer talked about this?  Not.  So, in the context of the task this was not.  An algorithm will be needed - we will tie it later, think of something. <br>  Therefore, I accept the fact that the property will remain a type, and the enumeration - a recipe.  Do not create the same bunch of heirs or other enumeration due to the properties of our spoken language.  In the context of the problem, everything is accurate.  Although not very beautiful.  Compromise? <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Recipe { Bread, MeatPasty, CabbagePasty, Cake } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProduct</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeryProduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BakeryProductType = recipe; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Recipe BakeryProductType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProductMaker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByGasOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gasLevel</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(recipe); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByOtherOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(recipe); } }</code> </pre><br><br>  <strong>Requirement 6</strong> <br>  <em>- We need to be able to burn bricks in the furnace</em> <br><br>  <strong>Analysis</strong> <br><br>  If you absolutely literally follow this requirement and all written requirements, then a brick is no different from a cake or bread.  The funny thing is that the brick we have is much more different from the pie with jam, because we do not have it in the requirements, but from the pie with meat so-so.  Just like from bread.  Therefore, this requirement for YAGNI, highly exaggerated, is realized only by expanding the enumeration of recipes with the renaming of all classes - rolls into the ‚Äúoven product‚Äù, which is also a brick, etc.  The whole point of how to create a class architecture is how it will be used.  It is from what is considered general (that is, the state and behavior of the base class), and what is private (the state and behavior of the heirs).  If neither one nor the other, then you can transfer.  Not scary not to guess.  Enumeration in a class and successors easily turns. <br><br>  Have any of you seen the horror in the code?  Maybe this code is difficult to test?  Yes, it seems, Boris's code is much more difficult to test.  Volume more, more tests.  More functionality than required?  More tests. <br>  Of course, it seems that in the original post it was implied that the requirements were more detailed and each phrase was clarified with detailed explanations.  But the genre YAGNI requires not to think out. <br><br>  Let's continue playing requirements. <br><br>  <strong>Requirement 7</strong> <br>  <em>- How did you not inspected?</em>  <em>Not every furnace can burn bricks.</em>  <em>For this you need a special oven.</em> <br><br>  <strong>Analysis</strong> <br><br>  Well, okay.  We remove the brick from the enumeration (recipe?) And return the names.  Create a separate empty Brick class.  And the new method: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Brick </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeBrickByFurnace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Brick(); }</code> </pre><br><br>  By the way, the abundance of methods, where everyone produces exactly some kind of object, is better than some flexible way of creating objects, if flexibility is not required right now.  If flexibility is not required, then the program should allow less, be more limited.  We are not currently considering unit tests, where it is often convenient to replace objects of specific types with interfaces.  All this code is easily converted to interfaces.  Yes, and C # with its reflection is not very demanding in testing to some interchanges. <br><br>  Further, the customer decided to play against Marcus. <br><br>  <strong>Requirement 8</strong> <br>  <em>- Each recipe should contain products and their quantity (weight).</em>  <em>Recipes in the requirement attached.</em> <br><br>  <strong>Analysis</strong> <br><br>  The first blood that Boris was waiting for. <br><br>  Let's try to cope with the terrible spaghetti code, which should have been formed in our country for a long time and would not give us any chance of refactoring.  Is it so? <br><br>  Products for the recipe - obviously - listing.  The recipe itself already contains not only the name of what it will create (or, what is the same thing, the name itself), but also a set of products with their quantity.  But at the same time, we note that a specific set of products is associated with a specific recipe and it does not change.  (Once again we recall that the post about YAGNI - no ‚Äúwhat if the reserve wants to change‚Äù! No suddenly, today is today, and tomorrow is tomorrow). <br><br>  Those.  the customer did not say that the products and the weight in the recipe may vary.  He, of course, did not say that they should be fixed.  But the fixed case is more limited and strict.  And we always choose more limited cases.  For us, it is better not that it is more flexible, but that which is simpler and stricter. <br><br>  Yes, and a recipe with a strict set of products - better matches personal experience.  From this it follows that in this case it is inappropriate to use inheritance and write a class for each recipe.  Then each class will store just constants. <br><br>  And a couple more thoughts.  Since  at the moment, the recipes in the code are just a given enumeration and it is set before the compilation, then if there are no other requirements, it seems that this behavior should remain.  From this, it follows that all recipes should be available to us and they are specified directly in the code.  You cannot create a new one without an extension.  From here, it seems, you need to make the Recipe class, after renaming the enumeration with this name into RecipeName.  The world is so changeable.  Now the listing only indicates the recipe and allows you to select it, but does not fully characterize it. <br><br>  To satisfy the conditions above, it is enough like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RecipeName { Bread, MeatPasty, CabbagePasty, Cake } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RecipeProduct { Salt, Sugar, Egg, Flour } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Recipe</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RecipeName Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;KeyValuePair&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt; Products { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;RecipeName, Dictionary&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt; predefinedRecipes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { predefinedRecipes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;RecipeName, Dictionary&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt; { { RecipeName.Bread, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; { {RecipeProduct.Salt, <span class="hljs-number"><span class="hljs-number">0.2</span></span>}, {RecipeProduct.Sugar, <span class="hljs-number"><span class="hljs-number">0.4</span></span>}, {RecipeProduct.Egg, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}, {RecipeProduct.Flour, <span class="hljs-number"><span class="hljs-number">50.0</span></span>} } } .................. }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Recipe </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRecipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RecipeName recipeName</span></span></span><span class="hljs-function">)</span></span> { Recipe recipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Recipe(); recipe.Name = recipeName; recipe.Products = predefinedRecipes[recipeName]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> recipe; } }</code> </pre><br><br>  Nothing and do not have to break.  For the creation of the product so far just enough recipe name.  We do not change anything there.  It will be necessary, and give the recipe itself. <br><br>  In this code, we just made a recipe-enumeration class and associated the name of the recipe with its constituent products.  It will be necessary to express the sequence of actions in the recipe, just as it can be ‚Äúscrewed‚Äù.  I hope this is understandable and there will be no spaghetti code.  There will be a separate behavior for classes - it is easy for the Recipe class to become basic and to have successors.  But we do not think about it.  We have YAGNI, we were not told to do this.  But we are not afraid of this. <br><br>  <strong>Requirement 9</strong> <br>  Sneaky customer, having learned about our unplanned approach, decided to catch. <br>  <em>‚ÄúI want the recipe to change.‚Äù</em>  <em>And the stove was prepared according to any recipe compiled by the chef.</em> <br><br>  We enter into polemics: <br>  <em>- How to change?</em> <em><br></em>  <em>- We believe that the cook does not know the recipes and can experiment.</em>  <em>Have you made recipes fixed?</em>  <em>And he wants to add a different number of eggs, sugar, etc.</em> <em><br></em>  <em>- What kind of a loaf will we get in this case?</em>  <em>We have to get something?</em>  <em>Bread, pies or cake?</em>  <em>Obviously, if the recipes are different, the cook will bake something else.</em> <em><br></em>  <em>- I think that the cake is different in taste, sweeter, less sweet.</em>  <em>Also bread.</em>  <em>It means that the recipes may differ in some limits, but we will get some product from the list.</em> <em><br></em>  <em>- Ie</em>  <em>to find out what we get, we need to look for the closest recipe to that food list in the cook recipe?</em> <em><br></em>  <em>- Yes.</em> <br><br>  <strong>Analysis</strong> <br><br>  We have fixed recipes.  Now recipes may not be fixed.  But those that we have are reference.  To allow our code users to create their own recipes, it‚Äôs enough to make the constructor open.  But it is also necessary to give the opportunity to ask the products.  I do not want to give the ability to assign users a property or specify a specific type.  Otherwise, he will be able to damage our standards.  So the easiest way to give the opportunity to transfer products to the designer.  It also eliminates the gap between creation and initialization and, therefore, reduces the likelihood of a bug. <br><br>  Now we have two constructors: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;KeyValuePair&lt;RecipeProduct, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; products</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; copiedProducts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;RecipeProduct, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> products) { copiedProducts.Add(pair.Key, pair.Value); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Products = copiedProducts; }</code> </pre><br><br>  A copy is created in the second constructor.  This is because of the C # properties - to pass links by default.  The user of the class will keep the link, and if he doesn‚Äôt make a copy, he can later change the ingredients of the recipe.  What is not included in our plans. <br><br>  Also, in this post, I try not to use less lambda and zheneriki, remaining within the framework of the standard OOP.  To make it more accessible to a larger audience.  The code could be written differently and simpler.  But my goal is to describe the very principle of YAGNI and some ways to evaluate the code, and not to show the different possibilities of Sharp.  Of course, assessment methods depend on the language and its capabilities. <br><br>  The second constructor, which for users, does not set the value of the property - the name of the recipe.  Since  our products are transferred to the designer and cannot change, then in the same place and somehow calculate the proximity.  More precisely, especially "smart" can change, but we will not suffer from paranoia.  We believe that the developers are adequate and are in a position of creation, not destruction. <br><br>  Need to write some kind of proximity method.  The customer did not specify, so we will write the most simple, with the method of least squares.  Given that each ingredient has a different "weight".  For now, let's write some weights that can be customized later. <br><br>  The code is approximately as follows: <br><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">double</span></span> GetDistance(Recipe recipe) { <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt; weights = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); weights[RecipeProduct.Salt] = <span class="hljs-number"><span class="hljs-number">50</span></span>; weights[RecipeProduct.Sugar] = <span class="hljs-number"><span class="hljs-number">20</span></span>; weights[RecipeProduct.Egg] = <span class="hljs-number"><span class="hljs-number">5</span></span>; weights[RecipeProduct.Flour] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(KeyValuePair&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt; otherProductAmount <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> recipe.Products) { var productAmounts = this.Products.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(p =&gt; p.Key == otherProductAmount.Key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (productAmounts.Count() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { sum += Math.Pow(productAmounts.First().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> - otherProductAmount.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) * weights[otherProductAmount.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>.MaxValue; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } private RecipeName GetRecipeName() { IEnumerable&lt;Recipe&gt; etalons = ((RecipeName[])Enum.GetValues(typeof(RecipeName))) .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(recipeName =&gt; Recipe.GetReceipt(recipeName)); IEnumerable&lt;KeyValuePair&lt;RecipeName, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;&gt; recipeNamesWithDistances = etalons .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(e =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> KeyValuePair&lt;RecipeName, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(e.Name, GetDistance(e))); <span class="hljs-type"><span class="hljs-type">double</span></span> minDistance = recipeNamesWithDistances.Min(rd =&gt; rd.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minDistance == <span class="hljs-type"><span class="hljs-type">double</span></span>.MaxValue) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("   "); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> recipeNamesWithDistances.First(rd =&gt; rd.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> == minDistance).Key; }</code> </pre><br><br>  And in the constructor call, respectively, the assignment of the name is added: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Recipe(IEnumerable&lt;KeyValuePair&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;&gt; products) { <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt; copiedProducts = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;RecipeProduct, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt; pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> products) { copiedProducts.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(pair.Key, pair.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); } this.Products = copiedProducts; this.Name = GetRecipeName(); }</code> </pre><br><br>  It would be more reliable to calculate always on the fly.  But then it would be necessary to invent a division of naming for the standard and for non-fixed recipes.  That's enough for now. <br><br>  As you can see, it‚Äôs not at all scary to remake the code to meet this current requirement.  We didn't really break anything.  And just expanded.  There is no more time for revision than if we had foreseen beforehand.  But to guess and not to guess is really scary.  Imagine this, like a simple code, on this demand, but made earlier.  This is just a monster that requires too much testing.  And now it is written justified. <br><br>  The code is not perfect, I already could not not start up in women and lambdas.  So the code gets smaller and cleaner.  I hope it doesn‚Äôt hurt the understanding of strangers with C # and lambdas readers.  Of course, it can be further reduced.  But I try to be understood by more people. <br><br>  I have already started here on a specific algorithm, although this particular customer did not require it.  Yagni is it or not?  Here we understand the situation.  Perhaps the customer immediately needs a visible result.  More often it happens.  Therefore, we need at least some algorithm.  But if later we need another algorithm, it doesn‚Äôt cost anything to replace this one with another.  Or even write a few and choose.  Or even from users of the code to take a delegate who will do a comparison for proximity. <br><br>  Understandably, now you need to transfer not the name of the recipe to the manufacturing methods, but the recipes themselves.  Those.  like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProduct</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeryProduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BakeryProductType = recipe.Name; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RecipeName BakeryProductType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><br>  AND: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByGasOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gasLevel</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gasLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(recipe); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByOtherOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(recipe); }</code> </pre><br><br>  Here, refactoring is not at all overstretched. <br><br>  <strong>Requirement 10</strong> <br>  The insidious customer somehow studied our code and is looking for the most painful place, for which our code is absolutely not ready.  After all, we should have 9 times unreadable spaghetti.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We wrote without a plan and our code is not terribly flexible. Apparently Boris entered into a deal with him and they are looking for weaknesses. </font></font><br><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- And now I need to, that everything that is produced by the furnace, could be sold in the store and it was called a commodity. A store must place a certain amount of goods in it, each item has a price and you must be able to calculate the price of all items in the store. At the same time, workers who make bricks and rolls are not qualified and do not know how to make them. They just pour the raw material into the stove (abstract))), and get the product, i.e. goods that are brought to the store.</font></font></em> <br><br>  <strong>Analysis</strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before that, our furnaces sometimes made unrelated things. Brick, for example. He has no common ancestor with the rolls. And right, how could we know what they have in common? No, of course, we also know in life about bricks and bread. But we could not believe that the customer would want to consider them later as a commodity. Then, we have three different methods that do not overlap. There is no one method that would release any thing. Should I have? Ancestor was not. Should not.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, the class hierarchy is more evil. Like any extra line of code. The fact that at this moment we had separate methods for returning concrete classes was better, safer. Imagine that we would immediately make a furnace that does something through a single method. How did Boris. And so she would release Product. What is a Product? This is the base class. Which has a basic behavior and state. But we, for example, in the user code needed to make exactly the pie. Here, the oven, makes the product. Not a pie.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this pie is really only when we get it out of the oven, it is called a product. </font><font style="vertical-align: inherit;">And suddenly we needed to know how much meat there is in it. </font><font style="vertical-align: inherit;">And this behavior in the heir, namely - in a pie with meat. </font><font style="vertical-align: inherit;">What should we do then? </font><font style="vertical-align: inherit;">Bring a link to a product to a link to its real type. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then just need to wait for trouble. </font><font style="vertical-align: inherit;">When casting from the base type to the successor, the compiler cannot control the correctness of the cast.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">violated the severity of typing. </font><font style="vertical-align: inherit;">You have to use reflection in the user code, find out what the real type is or try to bring, and then create branches, throw out exceptions, if something goes wrong, etc.</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premature flexibility is not only not useful, it is harmful. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now we really needed it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we ourselves formulate the requirements that have been formed at the moment: ‚ÄúBreads are made according to the recipe, there are no bricks. </font><font style="vertical-align: inherit;">Bricks can be made only in a special furnace, and only bricks (not rolls) can be made in it. </font><font style="vertical-align: inherit;">We need a single mechanism for loading raw materials and receiving the goods. </font><font style="vertical-align: inherit;">Bricks and bricks are a commodity that has a price. ‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The latter is realized simply. </font><font style="vertical-align: inherit;">A common ancestor, a commodity, appeared at the rolls and bricks.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Article</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Price { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Article</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Price = price; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We inherit classes: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BakeryProduct</span></span> : <span class="hljs-title"><span class="hljs-title">Article</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeryProduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BakeryProductType = recipe.Name; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RecipeName BakeryProductType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Brick</span></span>: <span class="hljs-title"><span class="hljs-title">Article</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Brick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And refactor calls of methods of manufacturing, passing the price set by the user to the constructors. </font></font><br><br>  Something like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BakeryProduct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BakeByOtherOven</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Recipe recipe, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BakeryProduct(recipe, price); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is almost half the battle. Little things left. But for the sake of reducing the post, I'll just describe what needs to be done. It is necessary to create one method which would return the goods. For consistency of parameters, it is necessary to make a class Raw materials and heirs, which will be - raw materials for rolls and raw materials for bricks. Raw materials for rolls, of course, contains a recipe. Classes are needed because just by a set of parameters (gas level, recipe, etc.) we can transmit strange parameters, which makes the program unreliable. In essence, raw material classes are ways of matching parameter packing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a single method for the receipt of goods, we can in the simplest case use a switch and select the desired method, which is already there, for the production of what is needed, depending on the raw materials. I would do that in this case. With a small number of items in the listing, this is not very cluttering the code. With increasing number of elements, you can think of other ways. For example, about an abstract factory. With the help of overloaded methods in it, you create a raw material and a stove at the same time that can work with this raw material.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there are no difficulties to transform the architecture on the go, as requirements arrive. There is no difficulty in covering it with tests. Methods are not great. Moreover, such code is easier to cover with tests, because it is smaller. A code without prediction is always in a more or less flexible state in all directions. At the same time it is quite tough. The Boris code slipped from the distance by another third of the way. And this can be converted to infinity. To make conversions possible, you should always refactor. The principle of YAGNI only says that you need to implement only minimal functionality. But in no case does he say that if the code works, then do not touch it. The refactoring and unit tests principle YAGNI does not apply. Only then does this technology work.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, the code in the post is not perfect. </font><font style="vertical-align: inherit;">The goal was only to show the principle. </font><font style="vertical-align: inherit;">I am sure that with many particulars in the way I did the analysis of requirements, and supporters of YAGNI will not agree. </font><font style="vertical-align: inherit;">Everyone has their own personal experience. </font><font style="vertical-align: inherit;">Everyone has their own methods and techniques. </font><font style="vertical-align: inherit;">And it also greatly depends on the programming language, because it is a means of expressing thoughts.</font></font></div><p>Source: <a href="https://habr.com/ru/post/153845/">https://habr.com/ru/post/153845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153825/index.html">ThinkPad 20 years old</a></li>
<li><a href="../153827/index.html">Mapping Features for Alien Swarm</a></li>
<li><a href="../153835/index.html">Finding Dyson's Sphere is a more realistic option than hearing alien radio</a></li>
<li><a href="../153837/index.html">Imperfect technology</a></li>
<li><a href="../153841/index.html">E2E (end-to-end) voting system with the possibility of verification by the voter</a></li>
<li><a href="../153849/index.html">Review of the report ‚ÄúEnsuring the availability of mobile phones and mobile services for people with disabilities‚Äù</a></li>
<li><a href="../153851/index.html">How the project of the smart home BeeToo Home won the iRidium Awards 2014</a></li>
<li><a href="../153853/index.html">Programming in maxima</a></li>
<li><a href="../153855/index.html">Warm and lamp VPN</a></li>
<li><a href="../153857/index.html">Creating icons for Mac OS X applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>