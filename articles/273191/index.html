<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test the theory of six handshakes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to tell you about my experiment in testing the Theory of Six Handshakes . I was inspired to write this material by the article ‚ÄúAnalysis of VK ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test the theory of six handshakes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b74/bc9/c7b/b74bc9c7b14a41c695dd8bc0861ca5f7.gif"><br><br>  I want to tell you about my experiment in testing <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D1%2588%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8_%25D1%2580%25D1%2583%25D0%25BA%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25B6%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B9">the Theory of Six Handshakes</a> .  I was inspired to write this material by the article <a href="http://habrahabr.ru/post/221251/">‚ÄúAnalysis of VK Friendship Relations with Python‚Äù</a> (to avoid repetitions, I will refer to it later).  As a whole, the task was set differently by me, and the methods used are also different, I decided that it might be interesting. <br><a name="habracut"></a><br><br>  Task formulation: visualize all connections between two users within one social network.  In this connection should not be duplicated, for example, if Vanya knows Petya through Olya, then Olya does not participate in further iterations in finding common friends.  To practice the API, I chose ‚ÄúVkontakte‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Based on the limitations of the API and the functionality of the methods, it was decided that the optimal number of "handshakes" from the point of view of the time of receiving information will be 3. So we will still check the "Theory of Three Handshakes", for now.  Thus, with an average of 200 friends, we get a sample of 8 million people.  For example, on the scale of Ukraine, I almost always found connections.  Structurally, the task can be divided into the following stages: <br><br><img src="https://habrastorage.org/files/80f/07d/31d/80f07d31d9fe498781bfd4915762a67a.gif"><br><br><ol><li>  Search for common friends between the source user 1 (user_1) and the source user 2 (user_2). </li><li>  Search for common friends between user_2 and friends user_1. </li><li>  Find common friends between user_2 friends and user_1 friends. </li><li>  Getting detailed information about the found links. </li><li>  Visualization. </li></ol><br>  So what we need: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Thread <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tokens <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><br>  <a href="http://docs.python-requests.org/en/latest/">Requests</a> - a common HTTP library for Python, described in the article <a href="http://habrahabr.ru/post/126262/">"Library to simplify HTTP requests</a> . <a href="http://habrahabr.ru/post/126262/">"</a> <br>  <a href="https://docs.python.org/2/library/time.html">Time</a> is a basic module whose name speaks for itself.  We will use to introduce delays in time. <br>  <a href="https://docs.python.org/2/library/threading.html">Threading</a> - the basic module for working with threads.  Well described in the article <a href="http://habrahabr.ru/post/149420/">"Learning to write multi-threaded and multiprocess applications in Python</a> . <a href="http://habrahabr.ru/post/149420/">"</a> <br>  Tokens - the tokens.py file will contain OAuth tokens for authorization in the API.  How to get the token is described in the <a href="http://habrahabr.ru/post/221251/">source article</a> , as well as on <a href="https://vk.com/dev/auth_mobile">the API page "Vkontakte"</a> . <br><br>  Before proceeding with the first stage, I‚Äôll focus on the API functionality and some limitations: <br><br><ul><li>  To call the API method, use a POST or GET request. </li><li>  The list of methods I used: <a href="">users.get</a> , <a href="">friends.get</a> , <a href="https://vk.com/dev/friends.getMutual">friends.getMutual</a> , <a href="https://vk.com/dev/execute">execute</a> . </li><li>  The <a href="https://vk.com/dev/execute">execute</a> method allows you to run up to 25 methods in a single query. </li><li>  Per second, no more than 3 requests can be made (using one token). </li><li>  The limit for the target_uids parameter of the friends.getMutual method is 300. I <a href="https://vk.com/dev/friends.getMutual">‚Äôll discuss</a> this in more detail below. </li></ul><br>  Thus, globally, the scheme is reduced to sending GET requests to the Vkontakte server and analyzing responses from the server in json format.  At the same time, we use the <a href="https://vk.com/dev/execute">execute</a> method and multithreading to optimize time. <br><br>  Remark to the original article that inspired me.  The author of the article <a href="https://habrahabr.ru/users/stleon/" class="user_link">STLEON</a> uses the <a href="https://vk.com/dev/friends.getMutual">friends.getMutual</a> method in one-to-one mode, using the target_uid parameter.  I believe this was due to the lack of the target_uids parameter in the previous version of the API.  I use this method in the ‚Äúone to many‚Äù mode, which significantly saves time.  The target_uids parameter has a limit on the length of the string, about which I did not find anything in the documentation.  It was established experimentally that the maximum length is about 310-330 UID, depending on the length of each identifier.  I rounded this figure to 300. <br><br>  All the above is summarized by declaring the following constants: <br><br><pre> <code class="python hljs">f_1_max = <span class="hljs-number"><span class="hljs-number">300</span></span> f_2_max = <span class="hljs-number"><span class="hljs-number">24</span></span> t = <span class="hljs-number"><span class="hljs-number">0.35</span></span></code> </pre><br>  Why f_2_max = 24, not 25, will be clear later. <br><br><h3>  Stage 1. Search for common friends between user_1 and user_2 </h3><br><img src="https://habrastorage.org/files/e49/a8b/e77/e49a8be77242438d8f29fac204ea7b14.png"><br><br>  Let us write the function with the help of which we will communicate with the server "Vkontakte" by means of a GET request: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vk</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method, parameters, token)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> requests.get(<span class="hljs-string"><span class="hljs-string">'https://api.vk.com/method/%s?%s&amp;access_token=%s'</span></span> % (method, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>.join(parameters), token)).json()</code> </pre><br>  This function has three arguments: <br><br><ul><li>  method is the name of the method we are accessing via the API. </li><li>  parameters are the parameters of this method (can be found in the description of each method). </li><li>  token is a string that authorizes you on the server.  I repeat that getting a token is described in detail <a href="http://habrahabr.ru/post/221251/">here</a> and <a href="https://vk.com/dev/auth_mobile">here</a> . </li></ul><br>  Further, we will use sets to save all the collected information.  We initialize the sets for each of the three ‚Äúhandshakes‚Äù. <br><br><pre> <code class="python hljs">edges_1, edges_2, edges_3 = set(), set(), set()</code> </pre><br>  To fulfill the condition so that the links are not duplicated and Olya does not appear as a common friend of Petit and Vanya in all three ‚Äúhandshakes‚Äù, but only in the first, filters must be entered.  Immediately add to the filter the first ‚Äúhandshake‚Äù of the original users. <br><br><pre> <code class="python hljs">filter_1, filter_2 = set(), set() filter_1.update([user_1, user_2])</code> </pre><br>  Find the friends of user_1 by calling the <a href="">friends.get</a> method.  After completing the call to the API method, we introduce the necessary delay in time t = 0.35.  Note that one of the parameters is the API version (v = 5.4 in my case).  It is very important to indicate it everywhere, because inconsistencies may appear.  The parameters of the order and count methods are optional. <br><br><pre> <code class="python hljs">friends_1 = set(vk(<span class="hljs-string"><span class="hljs-string">'friends.get'</span></span>, [<span class="hljs-string"><span class="hljs-string">'user_id=%s'</span></span> % user_1, <span class="hljs-string"><span class="hljs-string">'order=hints'</span></span>, <span class="hljs-string"><span class="hljs-string">'count=900'</span></span>, <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]) time.sleep(t)</code> </pre><br>  Next, we proceed directly to finding common friends between user_1 and user_2 by calling the <a href="https://vk.com/dev/friends.getMutual">friends.getMutual</a> method. <br><br><pre> <code class="python hljs">mutual_friends = vk(<span class="hljs-string"><span class="hljs-string">'friends.getMutual'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source_uid=%s'</span></span> % user_1, <span class="hljs-string"><span class="hljs-string">'order=hints'</span></span>, <span class="hljs-string"><span class="hljs-string">'target_uid=%s'</span></span> % user_2, <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] time.sleep(t)</code> </pre><br>  And the last point of the first stage is saving information to multiple edges_1, updating filt_1 and removing found common friends from the user_1 friends list to avoid repetitions in the future. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mutual_friends: edges_1.update([(user_1, user), (user, user_2)]) friends_1.remove(user) filter_1.update([user])</code> </pre><br><h3>  Stage 2. Search for mutual friends between user_2 and friends user_1 (friends_1) </h3><br><img src="https://habrastorage.org/files/0a8/18c/336/0a818c336a9f4c089d925a8693e5e9a5.png"><br><br>  Globally, the second stage repeats the first, the only difference is that instead of searching for common friends in the one-to-one mode, we use the one-to-many mode, which requires a few extra lines of code. <br>  We initialize the list in which we will save the friends we got, as well as some variables that we will need in intermediate calculations. <br><br><pre> <code class="python hljs">user_1_mutual_friends, temp_users, j = [], [], <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Next, counting the portions (not the most appropriate word) from the user_1 friends by 300 UID, we alternately send requests to the server about common friends between user_2 and the UID portion, which are written to the target_uids parameter of the friends.getMutual method. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, friend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(friends_1): temp_users += [friend] j += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j == f_1_max: user_1_mutual_friends += vk(<span class="hljs-string"><span class="hljs-string">'friends.getMutual'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source_uid=%s'</span></span> % user_2, <span class="hljs-string"><span class="hljs-string">'order=hints'</span></span>, <span class="hljs-string"><span class="hljs-string">'target_uids=%s'</span></span> % str(temp_users)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] temp_users, j = [], <span class="hljs-number"><span class="hljs-number">0</span></span> time.sleep(t) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == len(friends_1) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(friends_1) % f_1_max != <span class="hljs-number"><span class="hljs-number">0</span></span>: user_1_mutual_friends += vk(<span class="hljs-string"><span class="hljs-string">'friends.getMutual'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source_uid=%s'</span></span> % user_2, <span class="hljs-string"><span class="hljs-string">'order=hints'</span></span>, <span class="hljs-string"><span class="hljs-string">'target_uids=%s'</span></span> % str(temp_users)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] time.sleep(t)</code> </pre><br>  We save the received information in a set of edges_2 and update the information in the filter, as it was in the previous stage.  There may be exceptions, for example, if the UID has closed access to shared friends or the user‚Äôs page is deleted, so we use the <a href="https://docs.python.org/2/tutorial/errors.html">try-except</a> construction. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> friend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user_1_mutual_friends: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] != user_2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter_1: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> friend[<span class="hljs-string"><span class="hljs-string">'common_count'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> common_friend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> friend[<span class="hljs-string"><span class="hljs-string">'common_friends'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> common_friend != user_1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> common_friend <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter_1: edges_2.update([(user_1, friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]), (friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>], common_friend), (common_friend, user_2)]) friends_1.remove(friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]) filter_2.update([friend[<span class="hljs-string"><span class="hljs-string">'id'</span></span>], common_friend]) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre><br><h3>  Stage 3. Search for common friends between friends user_2 and friends user_1 </h3><br><img src="https://habrastorage.org/files/198/209/3f6/1982093f69c14dada21933da5268f9d9.png"><br><br>  This stage is the most time-consuming, since you need to send a lot of requests.  It is here that it is impossible to do without using the execute method.  From practice I will say that without the use of multithreading, the time to perform this stage according to this algorithm is 50 - 120 seconds, and in some cases even more.  Using multiple threads, it is possible to reduce the time to the execution of a single execute request, which is processed from 5 to 12 seconds. <br><br>  We declare filter_3, combining the sets filter_1 and filter_2.  We transform the set of friends of user_1 (friends_1) into a list. <br><br><pre> <code class="python hljs">filter_3 = filter_1.union(filter_2) friends_1 = list(friends_1)</code> </pre><br>  This is followed by a monstrous block of code, in which we declare a function for finding common friends between friends user_1 and friends user_2 and saving information in multiple edges_3.  Here again, the entire algorithm is the same as in the previous stages, only the ‚Äúmany-to-many‚Äù principle is used, which further complicates the code, especially in my implementation it is clearly redundant, so you have something to work on.  Below I will give some explanations for this multi-letter. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_edges_3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(friends_1, token)</span></span></span><span class="hljs-function">:</span></span> prefix_code = <span class="hljs-string"><span class="hljs-string">'code=var friends = API.friends.get({"v": "5.4", "user_id":"%s", "count":"500", "order": "hints"}).items; '</span></span> % user_2 lines, j, k = [], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, friend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(friends_1): lines += [<span class="hljs-string"><span class="hljs-string">'API.friends.getMutual({"v": "5.4", "source_uid": "%s", "count":"500", "target_uids": friends})'</span></span> % friend] <span class="hljs-comment"><span class="hljs-comment"># Generating string for 'execute' request. j += 1 if j == f_2_max: code = prefix_code + 'return [' + ','.join(str(x) for x in lines) + '];' response = vk('execute', [code, 'v=5.4'], token_1) for friends in response['response']: k += 1 if len(edges_3) &lt; max_edges_3: try: for one_friend in friends: if one_friend['common_count'] &gt; 0: for common_friend in one_friend['common_friends']: if common_friend not in filter_3 and one_friend['id'] not in filter_3: edges_3.update([(user_1, friends_1[k]), (friends_1[k], common_friend), (common_friend, one_friend['id']), (one_friend['id'], user_2)]) except: continue lines, j = [], 0 time.sleep(t) if i == len(friends_1) - 1 and len(friends_1) % f_2_max != 0 : code = prefix_code + 'return [' + ','.join(str(x) for x in lines) + '];' response = vk('execute', [code, 'v=5.4'], token_1) for friends in response['response']: k += 1 if len(edges_3) &lt; max_edges_3: try: for one_friend in friends: if one_friend['common_count'] &gt; 0: for common_friend in one_friend['common_friends']: if common_friend not in filter_3 and one_friend['id'] not in filter_3: edges_3.update([(user_1, friends_1[k]), (friends_1[k], common_friend), (common_friend, one_friend['id']), (one_friend['id'], user_2)]) except: continue time.sleep(t)</span></span></code> </pre><br>  The sum of the lines prefix_code and lines is VKScript code and is the only parameter for the <a href="https://vk.com/dev/execute">execute</a> method.  This script contains 25 calls to API methods. <br><br>  prefix_code is the part of the line containing reference number 1 to the <a href="">friends.get</a> method.  Here we get the list of friends for user_2 and assign it to the variable friends. <br><br>  lines - the second part of the line, containing calls ‚Ññ‚Ññ 2-25 to the method of <a href="https://vk.com/dev/friends.getMutual">friends.getMutual</a> .  Here we get a list of mutual friends between each of the 24 friends of user_1 and the list of friends of user_2.  In the loop, we add prefix_code and 24 lines of lines, thus obtaining the code string, which we use as a parameter to the <a href="https://vk.com/dev/execute">execute</a> method. <br><br>  Next, I will give an example using multiple threads, but I will not dwell on it in detail.  All information can be found in the article <a href="http://habrahabr.ru/post/149420/">"Learning to write multi-threaded and multiprocess applications in Python</a> . <a href="http://habrahabr.ru/post/149420/">"</a> <br><br><pre> <code class="python hljs">t1 = Thread(target=get_edges_3, args=(friends_1[ : len(friends_1) * <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>], token_1)) t2 = Thread(target=get_edges_3, args=(friends_1[len(friends_1) * <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> : len(friends_1) * <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>], token_2)) t3 = Thread(target=get_edges_3, args=(friends_1[len(friends_1) * <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> : ], token_3)) t1.start() t2.start() t3.start() t1.join() t2.join() t3.join()</code> </pre><br><h3>  Stage 4. Obtaining detailed information about the found links </h3><br>  Now we must lay down all the edges of our still unbuilt graph of friends and extract from them a list of vertices.  Then, using the <a href="">users.get</a> method described above, in portions of 300 UID, we send requests for obtaining data on the last and first names of users.  At the output we get a list, in each cell of which there will be a UID and a dictionary with information about this UID.  These data, in combination with sets of edges, are later used for visualization. <br><br><pre> <code class="python hljs">edges = list(edges_1) + list(edges_2) + list(edges_3) nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> edges: nodes += [edge[<span class="hljs-number"><span class="hljs-number">0</span></span>], edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]] nodes = list(set(nodes)) nodes_info, temp_nodes, j = [], [], <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(nodes): temp_nodes += [node] j += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j == f_1_max: nodes_info += vk(<span class="hljs-string"><span class="hljs-string">'users.get'</span></span>, [<span class="hljs-string"><span class="hljs-string">'user_ids=%s'</span></span> % str(temp_nodes)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-string"><span class="hljs-string">'fields=first_name, last_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] temp_nodes, j = [], <span class="hljs-number"><span class="hljs-number">0</span></span> time.sleep(t) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == len(nodes) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(nodes) % f_1_max != <span class="hljs-number"><span class="hljs-number">0</span></span>: nodes_info += vk(<span class="hljs-string"><span class="hljs-string">'users.get'</span></span>, [<span class="hljs-string"><span class="hljs-string">'user_ids=%s'</span></span> % str(temp_nodes)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-string"><span class="hljs-string">'fields=first_name, last_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'v=5.4'</span></span>], token_1)[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] time.sleep(t) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(nodes_info): <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: nodes[i] = (nodes[i], {<span class="hljs-string"><span class="hljs-string">'first_name'</span></span>: node[<span class="hljs-string"><span class="hljs-string">'first_name'</span></span>], <span class="hljs-string"><span class="hljs-string">'last_name'</span></span>: node[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre><br><h3>  Stage 5. Visualization </h3><br>  I will not dwell on the technical implementation of this stage.  I will describe only briefly my experience. <br><br>  As in the original article, I tried to use the <a href="http://networkx.github.io/documentation/latest/overview.html">networkx</a> library to build a graph.  I changed the diameter and color of the vertices depending on the gender or the number of connections, tried many visualization methods that are available in this library, but I did not like the result.  A random graph was not informative, with an average and a large number of edges and vertices.  Information was lost. <br><br>  I came to the conclusion that some kind of interactive solution is needed.  The first thing I found was the <a href="http://d3js.org/">D3.js library</a> .  But here, in the format of a regular graph, despite the interactivity, the result was unsatisfactory.  Then, in the same library, an example of the tree structure <a href="http://bl.ocks.org/mbostock/4063550">‚ÄúRadial Reingold ‚Äì Tilford Tree‚Äù was found</a> , which seemed to me suitable.  With this construction, user_1 is in the center, and user_2 is at the edge of each branch of the tree. <br><br><img src="https://habrastorage.org/files/f3b/d36/6cf/f3bd366cfbe14297b236adfe7f1165a3.gif"><br><br>  I modeled the whole bundle using the <a href="http://www.cherrypy.org/">CherryPy</a> web framework and was satisfied with the result, although I had to enter all the same restrictions on the displayed data (depending on the type and number of links found).  I deliberately omitted the preparation of data for visualization, as this procedure is of no interest and differs depending on the method chosen.  My version of the code is available in <a href="https://github.com/InspiredByData/social-media-spy">the GitHub repository</a> , which also describes the preparation of data for use with the <a href="http://d3js.org/">D3.js library</a> using the example of the <a href="http://bl.ocks.org/mbostock/4063550">‚ÄúRadial Reingold ‚Äì Tilford Tree‚Äù</a> template. <br><br>  It would also be interesting to display the relationship between the list of friends in this way (see figure below), so you can experiment.  This example is also taken from <a href="http://d3js.org/">D3.js</a> and it is called <a href="https://www.jasondavies.com/d3-dependencies/">D3 Dependencies</a> . <br><br><img src="https://habrastorage.org/files/884/81a/24f/88481a24f4cd42c0bcd627e1a391f8d4.gif"><br><br>  As for the verification of the theory, in the scale of Ukraine the scheme with three handshakes works in 90% of cases.  Exceptions are users with a very small number of friends. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/273191/">https://habr.com/ru/post/273191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273179/index.html">Atlassian Plugins: Diving into Active Objects and Plugin Settings</a></li>
<li><a href="../273181/index.html">Lan Lite and Lan Base Differences for Cisco 2960 Switches</a></li>
<li><a href="../273183/index.html">Intel¬Æ Tamper Protection Toolkit - Obfuscating compiler and code integrity checking tools</a></li>
<li><a href="../273185/index.html">A bit about Facebook data center</a></li>
<li><a href="../273189/index.html">XML, XQuery and Triple Grief with Performance</a></li>
<li><a href="../273193/index.html">Introducing Kerio Control 9</a></li>
<li><a href="../273197/index.html">Give the youth</a></li>
<li><a href="../273199/index.html">Apply machine learning to improve PostgreSQL performance.</a></li>
<li><a href="../273201/index.html">Installing the VNC server, and setting it up over SSH</a></li>
<li><a href="../273205/index.html">3 business projects that improve the data center industry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>