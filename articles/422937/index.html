<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Disk caching of lazy computing trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The concept of lazy computing is hardly worth talking about in detail. The idea to do the same thing less often, especially if it is long and heavy, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Disk caching of lazy computing trees</h1><div class="post__text post__text-html js-mediator-article"><p>  The concept of lazy computing is hardly worth talking about in detail.  The idea to do the same thing less often, especially if it is long and heavy, is as old as the world.  Because immediately to the point. </p><br><p>  According to the understanding of the author of this text, a normal lenifier should: </p><br><ol><li>  Save calculations between program calls. </li><li>  Track changes to the calculation tree. </li><li>  Have a moderately transparent syntax. </li></ol><br><p><img src="https://habrastorage.org/webt/de/dw/ec/dedwectoekaqhwzkercd2dgnk1u.jpeg" alt="Lazy Tree"></p><a name="habracut"></a><br><h2 id="koncepciya">  Concept </h2><br><p>  In order: </p><br><ol><li>  Save calculations between program calls: <br>  Indeed, if we call the same script several tens or hundreds of times a day, why recalculate the same thing every time the script is called, if you can store the result object in a file.  It is better to pull up the object from the disk, but ... we must be sure of its relevance.  Suddenly the script is rewritten and the saved object is outdated.  Based on this, we can not just take and in fact the presence of the file to load the object.  Hence the second point. </li><li>  Track changes in the calculation tree: <br>  The need to update an object should be calculated based on the data on the arguments of the function generating it.  So we will be sure that the loaded object is valid.  Indeed, for a pure function, the return value depends only on the arguments.  So, while we cache the results of pure functions and monitor the change of arguments, we can be sure that the cache is relevant.  At the same time, if a calculated object depends on another cached (lazy) object, which in turn depends on another, you need to correctly work out changes in these objects, timely updating the chained nodes that have ceased to be relevant.  On the other hand, it would be nice to consider that we do not always need to load the data of the entire chain of calculations.  Often enough to download only the final result object. </li><li>  Have a moderately transparent syntax: <br>  This item is clear.  If in order to rewrite the script for lazy calculations it is necessary to change all the code, this is so-so decision.  Changes should be made to a minimum. </li></ol><br><p>  This chain of reasoning led to a technical solution, designed in the python library evalcache (links at the end of the article). </p><br><h2 id="sintaksicheskoe-reshenie-i-mehanizm-raboty">  Syntactic solution and mechanism of work </h2><br><div class="spoiler">  <b class="spoiler_title">Simple example</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> evalcache <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shelve lazy = evalcache.Lazy(cache = shelve.open(<span class="hljs-string"><span class="hljs-string">".cache"</span></span>), algo = hashlib.sha256) @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * a a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = sqr(<span class="hljs-number"><span class="hljs-number">2</span></span>) c = lazy(<span class="hljs-number"><span class="hljs-number">3</span></span>) lazyresult = summ(a, b, c) result = lazyresult.unlazy() print(lazyresult) <span class="hljs-comment"><span class="hljs-comment">#f8a871cd8c85850f6bf2ec96b223de2d302dd7f38c749867c2851deb0b24315c print(result) #8</span></span></code> </pre> </div></div><br><p>  How it works? </p><br><p>  The first thing that catches your eye here is the creation of a lazy decorator.  This syntactic solution is fairly standard for Python-based lenificators.  A lazy decorator is passed a cache object in which the lenifier will store the results of the calculations.  The dict-like interface requirements are imposed on the cache type.  In other words, we are able to cache into everything that implements the same interface that the type dict has.  For the demonstration in the example above, a dictionary from the shelve library is used. </p><br><p>  Also, the decorator is transferred to the hash protocol, which he will use to build the hash keys of objects and some additional options (write permission, read permission, debug output), which can be found in the documentation or code. </p><br><p>  The decorator can be applied both to functions and to objects of other types.  At this moment, a lazy object with a hash key calculated on the basis of the representation (or with the help of a specially defined hash function) is built on their basis. </p><br><p>  A key feature of the library is that a lazy object can spawn other lazy objects, with the hash key of the parent (or parents) mixed into the hash key of the child.  For lazy objects, it is allowed to use an attribute operation, use calls ( <code>__call__</code> ) of objects, use operators. </p><br><p>  When passing through the script, in fact, no calculations are made.  For b, the square is not calculated, and for lazyresult the sum of the arguments is not considered.  Instead, a tree of operations is constructed and the hash keys of lazy objects are calculated. </p><br><p>  Real calculations (if the result was not previously put in the cache) will be performed only in the line: <code>result = lazyresult.unlazy()</code> </p><br><p>  If the object was calculated earlier, it will be loaded from the file. <br>  You can visualize the construction tree: </p><br><div class="spoiler">  <b class="spoiler_title">Build tree visualization</b> <div class="spoiler_text"><pre> <code class="python hljs">evalcache.print_tree(lazyresult) ... generic: &lt;function summ at <span class="hljs-number"><span class="hljs-number">0x7f1cfc0d5048</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">1</span></span> generic: &lt;function sqr at <span class="hljs-number"><span class="hljs-number">0x7f1cf9af29d8</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">2</span></span> ------- <span class="hljs-number"><span class="hljs-number">3</span></span> -------</code> </pre> </div></div><br><p>  Since object hashes are built on the basis of the data about the arguments that generate these objects, when the argument changes, the object hash changes and along with it the hashes of the entire chain dependent on it change in a cascade.  This allows you to keep cache data up to date, making updates on time. </p><br><p>  Lazy objects line up in a tree.  If we perform an unlazy operation on one of the objects, exactly as many objects as necessary to obtain a valid result will be loaded and recalculated.  Ideally, the required object will simply be loaded.  In this case, the algorithm will not pull up forming objects into memory. </p><br><h2 id="v-deystvii">  In action </h2><br><p>  Above was a simple example that shows syntax, but does not demonstrate the computational power of the approach. <br>  Here is an example a little more approximate to real life (sympy is used). </p><br><div class="spoiler">  <b class="spoiler_title">Example using sympy and numpy</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3.5 from sympy import * import numpy as np import math import evalcache lazy = evalcache.Lazy(evalcache.DirCache(".evalcache"), diag = True) pj1, psi, y0, gamma, gr= symbols("pj1 psi y0 gamma gr") ###################### Construct sympy expression ##################### F = 2500 xright = 625 re = 625 y0 = 1650 gr = 2*math.pi / 360 #gamma = pi / 2 xj1q = xright + re * (1 - cos(psi)) yj1q = (xright + re) * tan(psi) - re * sin(psi) #+ y0 pj1 = sqrt(xj1q**2 + yj1q**2) pj2 = pj1 + y0 * sin(psi) zj2 = (pj2**2)/4/F asqrt = sqrt(pj2**2 + 4*F**2) xp2 = 2*F / asqrt yp2 = pj2 / asqrt xp3 = yp2 yp3 = -xp2 xmpsi = 1295 gmpsi = 106 * gr aepsi = 600 bepsi = 125 b = 0.5*(1-cos(pi * gamma / gmpsi)) p1 = ( (gamma * xmpsi / gmpsi * xp2) * (1-b) + (aepsi * xp2 * sin(gamma) + bepsi * yp2 * (1-cos(gamma)))*b + pj1 ) ####################################################################### #First lazy node. Simplify is long operation. #Sympy has very good representations for expressions print("Expression:", repr(p1)) print() p1 = lazy(simplify)(p1) ######################################################################################### ## Really don't need to lazify fast operations Na = 200 angles = [t * 2 * math.pi / 360 / Na * 106 for t in range(0,Na+1)] N = int(200) a = (np.arange(0,N+1) - N/2) * 90/360*2*math.pi/N ######################################################################################### @lazy def genarray(angles, a, p1): points = [] for i in range(0, len(angles)): ex = p1.subs(gamma, angles[i]) func = lambdify(psi, ex, 'numpy') # returns a numpy-ready function rads = func(a) xs = rads*np.cos(a) ys = rads*np.sin(a) arr = np.column_stack((xs,ys,[i*2]*len(xs))) points.append(arr) return points #Second lazy node. arr = genarray(angles, a, p1).unlazy() print("\nResult list:", arr.__class__, len(arr))</span></span></code> </pre> </div></div><br><p>  Operations to simplify symbolic expressions are extremely costly and literally ask for lenification.  Further construction of a large array is performed even longer, but thanks to lazification, the results will be pulled from the cache.  Note that if at the top of the script where the sympy expression is generated, some factors are changed, the results will be recalculated because the hash key of the lazy object changes (thanks to the cool <code>__repr__</code> operators). </p><br><p>  Quite often there is a situation when the researcher conducts computational experiments on a long time generated object.  It can use several scripts to separate the generation and use of the object, which can cause problems with late data update.  The proposed approach can facilitate this case. </p><br><h2 id="radi-chego-vsyo-zatevalos">  What was it all for </h2><br><p>  evalcache is part of the zencad project.  This is a small scripted Kadik, inspired and exploiting the same ideas as openscad.  Unlike mesh-oriented openscad, in zencad, running on the opencascade core, the object representation is brep, and the scripts are written in python. </p><br><p>  Geometric operations are often performed long.  The lack of scripted cad systems is that every time the script is launched, the product is completely recalculated again.  Moreover, with the growth and complication of the model, the overheads grow by no means linear.  This leads to the fact that you can work comfortably only with extremely small models. </p><br><p>  The evalcache task was to smooth the problem.  In zencad, all operations are declared as lazy. </p><br><p>  Examples: </p><br><div class="spoiler">  <b class="spoiler_title">Model building example</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 #coding: utf-8 from zencad import * xgate = 14.65 ygate = 11.6 zgate = 11 t = (xgate - 11.7) / 2 ear_r = 8.6/2 ear_w = 7.8 - ear_r ear_z = 3 hx_h = 2.0 bx = xgate + ear_w by = 2 bz = ear_z+1 gate = ( box(xgate, ygate, t).up(zgate - t) + box(t, ygate, zgate) + box(t, ygate, zgate).right(xgate - t) ) gate = gate.fillet(1, [5, 23,29, 76]) gate = gate.left(xgate/2) ear = (box(ear_w, ear_r * 2, ear_z) + cylinder(r = ear_r, h = ear_z).forw(ear_r).right(ear_w)).right(xgate/2 - t) hx = linear_extrude( ngon(r = 2.5, n = 6).rotateZ(deg(90)).forw(ear_r), hx_h ).up(ear_z - hx_h).right(xgate/2 -t + ear_w) m = ( gate + ear + ear.mirrorYZ() - hx - hx.mirrorYZ() - box(xgate-2*t, ygate, zgate, center = True).forw(ygate/2) - box(bx, by, bz, center = True).forw(ear_r).up(bz/2) - cylinder(r = 2/2, h = 100, center = True).right(xgate/2-t+ear_w).forw(ear_r) - cylinder(r = 2/2, h = 100, center = True).left(xgate/2-t+ear_w).forw(ear_r) ) display(m) show()</span></span></code> </pre> <br><p>  This script generates the following model: <br><img src="https://habrastorage.org/webt/np/4i/go/np4igo9nth8jdmuplhz6pd2o9mg.png"><br>  Please note that there are no evalcache calls in the script.  The trick is that lenification is embedded in the zencad library itself and at first glance it‚Äôs not even visible from the outside, although all the work here is working with lazy objects, and the direct calculation is performed only in the 'display' function.  Of course, if some model parameter is changed, the model will be recalculated from the place where the first hash key has changed. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Models with cumbersome calculations</b> <div class="spoiler_text"><p>  Here is another example.  This time we will limit ourselves to pictures: <br><img src="https://habrastorage.org/webt/go/3f/zu/go3fzuma_btpyqlvqsb8zxnc6qc.png"><br>  Scaling a threaded surface is no easy task.  On my computer, such a bolt is built in about ten seconds ... It is more pleasant to edit a model with the threads of a lot using caching. </p><br><p>  And now it's a miracle: <br><img src="https://habrastorage.org/webt/ux/qs/kc/uxqskci0b_u_3cfdghkpdliygou.png"><br>  The intersection of threaded surfaces is a difficult design problem.  Practical value, but no, except for checking mathematics.  The calculation takes a minute and a half.  A worthy goal for lazification. </p></div></div><br><h2 id="problemy">  Problems </h2><br><p>  The cache may not work as intended. <br>  Cache errors can be divided into <strong>false positive</strong> and <strong>false negative</strong> . </p><br><h3 id="lozhnootricatelnye-oshibki">  False negative errors </h3><br><p>  False negative errors are situations when the result of the calculation is in the cache, but the system has not found it. <br>  This happens if the hash key algorithm used by evalcache for some reason produced a different key for re-evaluation.  If a hash function is not redefined for a cached type object, evalcache uses the <code>__repr__</code> object to build the key. <br>  An error happens, for example, if the class being leased does not override the standard <code>object.__repr__</code> , which changes from start to start.  Or, if redefined <code>__repr__</code> , it somehow depends on changing data that is insignificant for calculating (like an object address or a time stamp). </p><br><p>  Poorly: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#        -  __repr__.</span></span></code> </pre> <br><p>  Good: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A({})"</span></span>.format(self.i) A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#     .</span></span></code> </pre> <br><p>  False negative errors lead to the fact that lenification does not work.  The object will be recalculated with each new execution of the script. </p><br><h3 id="lozhnopolozhitelnye-oshibki">  False positive errors </h3><br><p>  This is a more vile type of error, since it leads to errors in the final object of the calculation: <br>  It can happen for two reasons. </p><br><ul><li>  Incredible: <br>  There was a hash key collision in the cache.  For the sha256 algorithm, which has a space of 115 1152020232316195423570985008687907853269984665640564039457584007913129639936 possible keys, the probability of a collision is negligible. </li><li>  Likely: <br>  The representation of the object (or the overridden hash function) does not fully describe it, or it is the same as the representation of an object of another type. </li></ul><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) A_lazy = lazy(A) B_lazy = lazy(B) a = A_lazy().unlazy() b = B_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#.     B,        A.</span></span></code> </pre> <br><p>  Both problems are related to the incompatible <code>__repr__</code> object.  If for some reason you cannot rewrite the type of the <code>__repr__</code> method, the library allows you to specify a special hash function for the user type. </p><br><h2 id="ob-analogah">  About analogues </h2><br><p>  There are many libraries of lenification, which basically consider it sufficient to perform the calculation no more than once per script call. </p><br><p>  There are many disk caching libraries that, at your request, will save an object with the necessary key for you. </p><br><p>  But I still could not find the libraries that would allow caching the results on the execution tree.  If they are, please, opt. </p><br><p>  References: </p><br><p>  <a href="https://github.com/mirmik/evalcache">Project on github</a> <br>  <a href="https://pypi.org/project/evalcache/">Project on pypi</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422937/">https://habr.com/ru/post/422937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422923/index.html">How to celebrate the day of the programmer, not decorating office ficus with zeros and units</a></li>
<li><a href="../422925/index.html">Interview with Godfrey Chan, RubyRussia Conference Speaker</a></li>
<li><a href="../422929/index.html">Yandex mail [was] unavailable for about an hour at 12:16 MSK</a></li>
<li><a href="../422931/index.html">Looking at tools for monitoring distributed applications</a></li>
<li><a href="../422935/index.html">2GIS on your hand. How we added a map to Apple Watch</a></li>
<li><a href="../422939/index.html">The book "Kali Linux from developers"</a></li>
<li><a href="../422941/index.html">"Three in a boat, poverty and dogs", or how Antiplagiat seeks paraphrase</a></li>
<li><a href="../422943/index.html">A little bit about industrial mining</a></li>
<li><a href="../422945/index.html">September 27, Moscow - Mitap QIWI SERVER PARTY 3.0</a></li>
<li><a href="../422947/index.html">How to set up archiving of Veeam backups in Microsoft Azure Blob Storage using StarWind VTL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>