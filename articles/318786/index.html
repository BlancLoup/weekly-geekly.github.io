<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Competitiveness: Cooperativeness</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue my small series of articles on the means of organizing and implementing competitive computing. 


 In the last article, we looked at the ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Competitiveness: Cooperativeness</h1><div class="post__text post__text-html js-mediator-article"><p>  I continue my small series of articles on the means of organizing and implementing competitive computing. </p><br><p>  <a href="https://habrahabr.ru/post/318374/">In the last article,</a> we looked at the abstraction of threads, which allows us to pretend that the code of functions is executed simultaneously and continuously. </p><br><p>  In this we will look at two more models, one of which does not do this kind, and the second looks at competitive calculations from a more abstract side. </p><br><ul><li>  <a href="https://habrahabr.ru/post/318374/">Parallelism</a> (part 1) <br><ul><li>  <a href="https://habrahabr.ru/post/318374/">Streams: scheduling, sleep</a> </li><li>  <a href="https://habrahabr.ru/post/318374/">Synchronization</a> : <a href="https://habrahabr.ru/post/318374/">Spinlock, semaphores</a> , <a href="https://habrahabr.ru/post/318374/">memory barriers</a> </li><li>  <a href="https://habrahabr.ru/post/318374/">Atomicity: TAS, CAS</a> </li></ul><br></li><li>  <b>Cooperativeness</b> (part 2, current) <br><ul><li>  <a href="https://habr.com/ru/post/318786/">Coroutines</a> </li><li>  <a href="https://habr.com/ru/post/318786/">Actors</a> </li></ul><br></li><li>  <a href="https://habrahabr.ru/post/319350/">Asynchrony</a> (part 3) <br><ul><li>  <a href="https://habrahabr.ru/post/319350/">Event loop</a> <ul><li>  <a href="https://habrahabr.ru/post/319350/">select</a> </li></ul></li><li>  <a href="https://habrahabr.ru/post/319350/">Callbacks</a> </li><li>  <a href="https://habrahabr.ru/post/319350/">Async monad</a> </li><li>  <a href="https://habrahabr.ru/post/319350/">Promises (promises)</a> </li><li>  <a href="https://habrahabr.ru/post/319350/">async / await - promises + corutines</a> </li></ul><br></li></ul><a name="habracut"></a><br><h1 id="kooperativnost">  Cooperative </h1><br><p>  Unlike preemptive multitasking, which interrupts the execution of your code at any time, in any place you want, cooperative is the ‚Äúmanual version‚Äù, when your code knows that more than one is running, there are other pending processes, and it decides when to transfer control to others. </p><br><p>  With cooperative multitasking, it is important not to perform lengthy operations, and if you perform, then periodically transfer control. </p><br><p>  The ideal option would be if your ‚Äúcooperative part‚Äù does not work with blocking I / O and powerful calculations, but will use a non-blocking asynchronous API, and these time-consuming things will be carried out ‚Äúoutside‚Äù, where parallel ‚Äúpseudo-parallelism‚Äù will be executed. </p><br><h2 id="korutiny">  Korutiny </h2><br><p>  I said that the operating system <a href="https://habrahabr.ru/post/318374/">schedule streams</a> , executing their code in certain portions of time.  But let's think about how this is possible in principle.  There are two options: </p><br><ol><li><p>  The processor supports the ability to interrupt the execution of instructions after some time and execute some other predefined code (timer interrupt, or, if possible, by the number of instructions executed). </p><br></li><li>  We are compiling the machine code compiler into the machine code, which will itself count the number of instructions executed in some way and interrupt execution when the counter reaches a certain limit. </li></ol><br><p>  The second option to the overhead projector for context switching (save the value of all registers somewhere) adds an overhead projector to this modification of the code (although it can be done by the <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> ), plus the calculation of instructions during their execution (everything will become slower no more than two times, and in most cases - much less). </p><br><p>  And when for some reason we don‚Äôt want (or can‚Äôt) use processor interrupts on a timer, and the second option is generally a trough - cooperative multitasking comes into play.  We can write functions in such a style that we ourselves say when we can interrupt its execution and perform some other tasks.  Something like this: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ doSomeWork(); yield(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { doAnotherWork(); yield(); } doLastWork(); }</code> </pre> <br><p>  Where, with each call to <code>yield()</code> system retains the entire context of the function (the values ‚Äã‚Äãof the variables, the place where <code>yield()</code> was called) and continues to perform another function of the same type, restoring its context and resuming execution from the place where it had finished the last time. </p><br><p>  This approach has both pros and cons.  Of the benefits: </p><br><ul><li>  If we have only one physical flow (or if our group of tasks is executed only in one), then locks will not be required for some of the shared memory, since  we decide when other tasks will be performed, and we can perform actions without fear that someone else will see or intervene in them halfway, and where locks are needed, they are implemented simply by boolean. </li></ul><br><p>  Minuses: </p><br><ul><li>  The time quanta will be very uneven (which is not so important, the main thing is that they <i>are small enough</i> so that delays are not noticeable). </li><li>  Any function may still create a noticeable delay, implemented incorrectly.  And, much worse, if she does not return control at all. </li></ul><br><p>  In terms of speed, it's hard to talk.  On the one hand, it can be faster if it does not change contexts as often as the scheduler, it can be slower if it switches contexts too often, and on the other hand, too long delays between returning control to other tasks can affect the UI or I / O, that becomes noticeable and then the user is unlikely to say that it began to work faster. </p><br><p>  But back to our Korutin.  Coroutines (coroutines, coroutines) have more than one entry point and one exit (as usual functions are subprograms), but one starting point, optionally one final and an arbitrary number of output-input pairs. </p><br><p>  First, consider the case with an infinite number of outputs (an infinite list generator): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i++; } }</code> </pre> <br><p>  This is Javascript, when you call the <b>serial</b> function, an object will be returned that has a <code>next()</code> method, which, when successively called, will return objects of the form <code>{value: Any, done: Boolean}</code> , where <b>done</b> will be <b>false</b> until the generator runs at the end of the function block , and in <b>value</b> , the values ‚Äã‚Äãthat we send by yield. </p><br><p>  ... but besides returning the value of a <b>yield, it</b> can also take new data inside.  For example, let's make some such adder: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> total; total += n; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = sum(); s.next(); <span class="hljs-comment"><span class="hljs-comment">// 0 s.next(3); // 3 s.next(5); // 8 s.next(7); // 15 s.next(0); // 15</span></span></code> </pre> <br><p>  The first call to <code>next()</code> gets the value that the first <b>yield</b> passed, and then we can pass to <code>next()</code> value that we want the <b>yield to</b> return. </p><br><p>  I think you understand how it works.  But if you still don‚Äôt understand how to use it - wait for the next article, where I will talk about <strong>promises</strong> and <strong>async / await</strong> . </p><br><h2 id="aktory">  Actors </h2><br><p>  The actor model is a powerful and fairly simple model of parallel computing, which makes it possible to achieve both efficiency and convenience at a low price (more on this later).  There are only two entities: the <strong>actor</strong> (which has the <i>address</i> and <i>state</i> ) and <strong>messages</strong> (arbitrary data).  Upon receipt of a message, the actor may: </p><br><ul><li>  Act according to your <i>condition</i> </li><li>  Create new actors, he will know their <i>addresses</i> , can set their initial <i>state</i> </li><li>  Send messages to known <i>addresses</i> (you can send <i>addresses</i> in messages, including your own) </li><li>  Change your <i>state</i> </li></ul><br><p>  What is good in actors?  If the resources are properly divided by actors, then you can completely get rid of any locks (although, if you think <b>locks</b> become <b>results expectations</b> , during this wait you have to process other messages, and not just wait). </p><br><p>  In addition, your code is likely to become much better organized, logically divided, you will have to work out the actors API well.  And the actor is much easier to reuse than just a class, since  the only way to interact with him is to send him messages and receive messages from him at the addresses passed to him, he has no hard dependencies and implicit connections, and any of his "outside call" is easily intercepted and customized. </p><br><p>  The price of this is a message queue and an overhead to work with it.  Each actor will have a queue of incoming messages to it, in which incoming messages will accumulate.  If he does not have time to process them - it will grow.  In loaded systems, you will have to somehow solve this problem by inventing ways for parallel processing so that you have groups of actors who do some one task.  But in this case, the queues give you a plus, because  it becomes very easy to monitor places where you do not have enough performance.  Instead of one metric <em>"I waited for the 50ms result"</em> , you have for each component of the system a metric <em>"can process N requests per minute"</em> . </p><br><p>  Actors can be implemented in many different ways: you can create your own thread for each (but then we can‚Äôt create really <b>many</b> instances), or you can create a couple of threads that will actually work in parallel and twist the message handlers inside them - nothing will change (if only some of them do not take very long operations, which will block the implementation of the rest), and it will be possible to create more actors.  If the messages are serializable, then there are no problems to distribute the actors across different machines, which increases the ability to scale well. </p><br><p>  I will not give examples if you are interested, I advise you to read <a href="http://learnyousomeerlang.com/">Learn You Some Erlang for Great Good!</a>  .  Erlang is an IP program built entirely on the concept of actors, and the supervisor system allows you to make applications truly resilient.  Not to mention <em>OTP</em> , which sets the right tone and makes the task of writing a bad system rather complicated. </p><br><hr><br><p>  In the third part, we turn to the most interesting part - the methods of organizing asynchronous calculations, when we make a request for some action, and we get the result of this request only in an uncertain future.  Without any pasta, callback hell and undefined states. </p><br><p>  <strong>UPD:</strong> <a href="https://habrahabr.ru/post/319350/">The third part</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318786/">https://habr.com/ru/post/318786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318776/index.html">Stylish Python code, or learning to use Flake8</a></li>
<li><a href="../318778/index.html">PHPixie Cache: PSR-6, PSR-16 and some interesting features</a></li>
<li><a href="../318780/index.html">Approaches to design in virtual reality</a></li>
<li><a href="../318782/index.html">Java socket framework</a></li>
<li><a href="../318784/index.html">Can your code reason?</a></li>
<li><a href="../318788/index.html">42% of people who do not buy your product</a></li>
<li><a href="../318790/index.html">Creating a blog engine with Phoenix and Elixir / Part 7. Add comments / New Year's announcement in the conclusion</a></li>
<li><a href="../318792/index.html">FBI, CIA and Obama against PHP script</a></li>
<li><a href="../318796/index.html">Sending a GPS track via SMS</a></li>
<li><a href="../318798/index.html">We want to give you a New Year's gift, but we need your help.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>