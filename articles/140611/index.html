<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hamming code. An example of the algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction. 
 First of all, it is necessary to say what the Hamming Code is and why it is actually needed. Wikipedia gives the following definition:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hamming code. An example of the algorithm</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction. </h1><br>  First of all, it is necessary to say what the Hamming Code is and why it is actually needed.  <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Wikipedia</a> gives the following definition: <br><br><blockquote>  Hamming codes are the most well-known and probably the first of self-controlling and self-correcting codes.  They are constructed in relation to the binary number system. <br></blockquote><br>  In other words, it is an algorithm that allows you to encode any informational message in a certain way and after transmission (for example, over the network) to determine if some error occurred in this message (for example due to interference) and, if possible, to recover this message .  Today, I will describe the simplest Hamming algorithm that can correct only one mistake. <br><a name="habracut"></a><br>  It is also worth noting that there are more advanced modifications of this algorithm that allow you to detect (and if it is possible to correct) more errors. <br><br>  Immediately it should be said that the Hamming Code consists of two parts.  The first part encodes the original message, inserting into it in certain places the control bits (calculated in a special way).  The second part receives the incoming message and re-calculates the control bits (according to the same algorithm as the first part).  If all newly calculated check bits are the same as received, then the message is received without errors.  Otherwise, an error message is displayed and, if possible, the error is corrected. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  How it works. </h2><br>  In order to understand the operation of this algorithm, consider an example. <br><br><h3>  Training </h3><br>  Suppose we have a message ‚Äúhabr‚Äù that needs to be transmitted without errors.  To do this, you first need to encode our message with the Hamming Code.  We need to present it in binary form. <br><br><img src="https://habrastorage.org/storage2/288/3c8/b62/2883c8b624d59ba1dffbdfea96743a39.png"><br><br>  At this stage, it is necessary to determine the so-called length of the information word, that is, the length of the string of zeros and ones that we will encode.  Suppose we have a word length of 16. So, we need to divide our original message (‚Äúhabr‚Äù) into blocks of 16 bits, which we will then encode separately from each other.  Since one character occupies 8 bits in memory, exactly two ASCII characters fit into one coded word.  So, we got two binary strings of 16 bits each: <br><br><img src="https://habrastorage.org/storage2/7e3/8f2/0fe/7e38f20fe4ac07f834f5a68ec775a829.png">  and <img src="https://habrastorage.org/storage2/917/51d/2a9/91751d2a972767500f78b7700c9e21dc.png"><br><br>  After that, the encoding process is parallelized, and the two parts of the message (‚Äúha‚Äù and ‚Äúbr‚Äù) are encoded independently of each other.  Consider how this is done on the example of the first part. <br>  First of all, it is necessary to insert check bits.  They are inserted in strictly defined places - these are positions with numbers equal to powers of two.  In our case (with the length of the information word in 16 bits) these will be positions 1, 2, 4, 8, 16. Accordingly, we have 5 control bits (highlighted in red): <br><br>  It was: <br><img src="https://habrastorage.org/storage2/7e3/8f2/0fe/7e38f20fe4ac07f834f5a68ec775a829.png"><br><br>  It became: <br><img src="https://habrastorage.org/storage2/14f/13a/b50/14f13ab5014ce60d2a6a04275d144331.png"><br><br>  Thus, the length of the entire message increased by 5 bits.  Before calculating the check bits themselves, we assigned them the value "0". <br><br><h3>  Calculation of check bits. </h3><br>  Now it is necessary to calculate the value of each control bit.  The value of each control bit depends on the values ‚Äã‚Äãof the information bits (as unexpectedly), but not on all, but only on those that this control bits control.  In order to understand which bits each control bit is responsible for, it is necessary to understand a very simple pattern: the control bit with the N number controls all subsequent N bits after every N bits, starting from the position N. Not very clear, but I think it will be from the picture clearer: <br><img src="https://habrastorage.org/storage2/5bb/3f1/983/5bb3f198377397fa041e5bb390eec466.png"><br>  Here, the ‚ÄúX‚Äù denotes those bits that are controlled by the check bit, the number of which is to the right.  That is, for example, bit number 12 is controlled by bits with numbers 4 and 8. It is clear that in order to know which bits control bit with number N, you just need to decompose N in powers of two. <br><br>  But how to calculate the value of each control bit?  This is done very simply: we take each check bit and see how many bits of units it controls, we get some integer number and, if it is even, then we set zero, otherwise we set one.  That's all!  Of course, it is possible and vice versa, if the number is even, then we set one, otherwise, we put 0. The main thing is that the algorithm is the same in the ‚Äúcoding‚Äù and ‚Äúdecoding‚Äù parts.  (We will apply the first option). <br>  Having calculated the check bits for our information word, we get the following: <br><img src="https://habrastorage.org/storage2/719/e5c/30a/719e5c30a55f74f58db64960cbe01191.png"><br>  and for the second part: <br><img src="https://habrastorage.org/storage2/f4c/b23/f09/f4cb23f09724cc292f3de4b4730d9650.png"><br><br>  That's all!  The first part of the algorithm is complete. <br><br><h3>  Decoding and correction of errors. </h3><br>  Now, let's say we received the message encoded by the first part of the algorithm, but it came to us with an error.  For example, we got this (the 11th bit was transmitted incorrectly): <br><img src="https://habrastorage.org/storage2/e14/9f0/22e/e149f022e390deae045650c6e17c03ba.png"><br>  The whole second part of the algorithm is that it is necessary to re-calculate all the control bits (as in the first part) and compare them with the control bits that we received.  So, counting the control bits with the wrong 11th bit, we get the following picture: <br><img src="https://habrastorage.org/storage2/989/a6d/122/989a6d1229152233eb9c11b1a77d1e74.png"><br>  As we can see, the check bits numbered 1, 2, 8 do not coincide with the same check bits that we received.  Now simply adding the position numbers of the wrong control bits (1 + 2 + 8 = 11) we get the position of the wrong bit.  Now simply inverting it and discarding the control bits, we get the original message in its original form!  We do the same thing with the second part of the message. <br><br><h3>  Conclusion </h3><br>  In this example, I took the length of the informational message exactly 16 bits, since it seems to me that it is the most optimal for considering the example (not too long and not too short), but of course you can take any length.  Only it is necessary to take into account that in this simple version of the algorithm only one error can be corrected for one information word. <br><br><h3>  Note. </h3><br>  I was inspired to write this topic by the fact that I didn‚Äôt find articles on this topic on Habr√© (which I was extremely surprised with).  Therefore, I decided to partly correct this situation and show as much as possible how this algorithm works.  I deliberately did not give a single formula in order to try in my own words to convey the process of the algorithm using an example. <br><br><h3>  Sources. </h3><br>  1. <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Wikipedia</a> <br>  2. <a href="http://users.cs.fiu.edu/~downeyt/cop3402/hamming.html">Calculating the Hamming Code</a> </div><p>Source: <a href="https://habr.com/ru/post/140611/">https://habr.com/ru/post/140611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140603/index.html">Frustro: impossible font</a></li>
<li><a href="../140604/index.html">Hitachi Kokusai Electric has developed a new face recognition system.</a></li>
<li><a href="../140605/index.html">Full archive of Einstein's manuscripts</a></li>
<li><a href="../140607/index.html">17 "TFT: floor to table</a></li>
<li><a href="../140609/index.html">Differences in the design of applications iPad and Metro</a></li>
<li><a href="../140612/index.html">SCSS - a little practice, part I</a></li>
<li><a href="../140613/index.html">There are only structural and object programming paradigms.</a></li>
<li><a href="../140616/index.html">Access to static data</a></li>
<li><a href="../140617/index.html">Without wires. Release 3</a></li>
<li><a href="../140623/index.html">We trade Bitcoin title characters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>