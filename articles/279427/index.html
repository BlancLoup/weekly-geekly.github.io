<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About one funny approach to filtering unimodal signals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, our engineers would like to share with Habr a rather interesting tool that can be effectively used to filter out noisy signals, using...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About one funny approach to filtering unimodal signals</h1><div class="post__text post__text-html js-mediator-article">  In this article, our engineers would like to share with Habr a rather interesting tool that can be effectively used to filter out noisy signals, using a priori knowledge of signal unimodality. <br><br>  The problem of offline signal filtering in the case when the expected waveform is known with an accuracy of up to several unknown parameters is reduced to the approximation problem.  For example, if it is known that the signal grows linearly over the considered interval, the problem will be reduced to linear regression, and if it can be assumed that the noise is normal, then the correct method will be <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25B5%25D0%25BD%25D1%258C%25D1%2588%25D0%25B8%25D1%2585_%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25B2">OLS</a> .  But once we faced the task of evaluating the shape of an X-ray microprobe profile (beam), about which only one thing was known a priori: the profile is unimodal, namely, it has exactly one maximum.  It turns out that in this case, the best (in the sense, for example, L2 metrics) approach the experimental signal with a function belonging to a known set (a set of unimodal functions).  Moreover, with acceptable asymptotics of computational complexity. <br><br><img src="https://habrastorage.org/files/e0b/2f0/b23/e0b2f0b23c4f4d9286de905eea8efa43.png">  ===&gt; <img src="https://habrastorage.org/files/04a/18d/7e7/04a18d7e73d64928ac47b70f6d123241.png">  ===&gt; <img src="https://habrastorage.org/files/737/c56/027/737c56027a27439794de77ffd56158e5.png"><br><a name="habracut"></a><br>  So, we will talk about the problem of approximation of a certain noisy signal <img src="https://tex.s2cms.ru/svg/Y" alt="Y">  as functions of a discrete argument <img src="https://tex.s2cms.ru/svg/X" alt="X">  , and it is known that the original signal is unimodal.  In the case under consideration, it is additionally known that at the edges the signal asymptotically approaches zero.  It should be noted that the method considered below does not in itself require such an assumption. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, for simplicity, it makes sense to consider the same problem for a monotonic function.  The description is given for a monotonously non-strictly increasing function, although, of course, for the monotonically decreasing one can do the same. <br><br>  If we assume that the noise is normally distributed, then the problem will be reduced to minimizing the quadratic functional <img src="https://tex.s2cms.ru/svg/%5Chbox%7B%5Csum_i(%5Cwidetilde%7BY%7D(X_i)%20-%20Y(X_i))%5E2%7D" alt="\ hbox {\ sum_i (\ widetilde {Y} (X_i) - Y (X_i)) ^ 2}">  in the presence of inequalities of the form <img src="https://tex.s2cms.ru/svg/%5Cwidetilde%7BY%7D(X_%7Bi%2B1%7D)%20%5Cge%20%5Cwidetilde%7BY%7D(X_i)" alt="\ widetilde {Y} (X_ {i + 1}) \ ge \ widetilde {Y} (X_i)">  .  This is a quadratic programming problem, and for it on the Internet you can find a number of ready solvers.  But, first, the problem of quadratic programming in the general case is calculated rather slowly, and secondly, the problem of approximating a unimodal signal is not written out in a similar form if the position of the extremum is not known in advance. <br><br>  There is an alternative solution that does not have these disadvantages, but when using it, the signal scale <img src="https://tex.s2cms.ru/svg/%5Cwidetilde%7BY%7D" alt="\ widetilde {Y}">  will have to be considered discrete.  It is worth noting that the task is not interesting in the case of low noise, since the usual linear filtering will most likely remove all practical problems.  What is interesting, strong noise?  In fig.  1, one can see a model signal before and after such a noise.  The noise here is given by a normal distribution. <img src="https://tex.s2cms.ru/svg/N(0%2C%200.8%5E2)" alt="N (0, 0.8 ^ 2)">  .  Under such conditions, the discretization of the approximating signal does not seem to be a significant loss.  In addition, as will be seen later, as the number of samples increases, the complexity of the calculations will increase linearly. <br><img src="https://habrastorage.org/files/847/4f4/d6e/8474f4d6e6294bb2aeb958590158f690.png"><br>  Fig.  1: a) Model monotonous signal until the noise increases.  b) Model monotonous signal after noise imposing. <br><br>  It turns out that in the discrete approximation, filtering a normally noisy monotone signal reduces to dynamic programming with two parameters, and using this solution, it is possible to construct a computational circuit of the same complexity for a unimodal case. <br><br>  You can read about what dynamic programming is <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">here</a> , and how and to which tasks it is used - <a href="https://habrahabr.ru/post/113108">here</a> . <br><br><h2>  Monotone filtering by dynamic programming </h2><br>  In the problem under consideration, the dynamic programming table is two-dimensional, its columns <i>i</i> correspond to increasing values ‚Äã‚Äãof the discrete argument from left to right <img src="https://tex.s2cms.ru/svg/X" alt="X">  experimental points, and lines <i>j</i> - increasing from the bottom up possible values ‚Äã‚Äãof the approximating function <img src="https://tex.s2cms.ru/svg/%5Cwidetilde%7BY%7D" alt="\ widetilde {Y}">  .  Minimized functional - the sum of squared deviations <img src="https://tex.s2cms.ru/svg/%5Cwidetilde%7BY%7D" alt="\ widetilde {Y}">  from <img src="https://tex.s2cms.ru/svg/Y" alt="Y">  along paths with allowable crossings.  It is obvious that the transitions to 1 to the right with a simultaneous non-negative upward shift will be admissible. <br><br>  The outer loop is conducted along the coordinate <i>i</i> from left to right.  For each value <img src="https://tex.s2cms.ru/svg/X" alt="X">  an inner loop is performed on the <i>j</i> coordinate from bottom to top.  The minimum value of the functional is determined by the formula <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AW_%7Bi%2C%20j%7D%20%3D%20%5Cmin%5Climits_%7Bk%20%5Cle%20j%7D(W_%7Bi-1%2C%20k%7D)%20%2B%20(Y_j%20-%20%5Cwidetilde%7BY%7D_j)%5E2%2C%0A" alt="W_ {i, j} = \ min \ limits_ {k \ le j} (W_ {i-1, k}) + (Y_j - \ widetilde {Y} _j) ^ 2,"></div><br>  and outside the table, the functionality is considered to be zero. <br><br>  At the same time, in order not to recalculate each time the minimum at smaller values ‚Äã‚Äãof <i>j</i> , it is useful to save it during the filling process along with the value of the functional, and since at the end you need to restore the path, it is more convenient to save the value of m at which this minimum was reached: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0Am_%7Bi%2C%20j%7D%20%3D%20%5Cbegin%7Bcases%7D%0Am_%7Bi%2C%20j-1%7D%2C%20%26%20W_%7Bi%2C%20m_%7Bi%2C%20j%20-%201%7D%7D%20%3C%20W_%7Bi%2C%20j%7D%20%5C%5C%0Aj%2C%20%20%20%20%20%20%20%20%20%20%26%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A" alt="m_ {i, j} = \ begin {cases} m_ {i, j-1}, &amp; amp; W_ {i, m_ {i, j - 1}} &amp; lt; W_ {i, j} \\ j, &amp; amp; \ text {otherwise} \ end {cases}"></div><br>  Then the calculation of the functional itself can be performed in O (1) for each cell: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AW_%7Bi%2C%20j%7D%20%3D%20W_%7Bi-1%2C%20m_%7Bi-1%2C%20j%7D%7D%20%2B%20(Y_j%20-%20%5Cwidetilde%7BY%7D_j)%5E2.%0A" alt="W_ {i, j} = W_ {i-1, m_ {i-1, j}} + (Y_j - \ widetilde {Y} _j) ^ 2."></div><br>  After the completion of the direct passage, it remains to obtain an approximation in an explicit form.  To do this, look for a minimum among the values ‚Äã‚Äãof the functional for the rightmost column (the column with the highest coordinate <i>i</i> ), and then perform a reverse pass through <i>i</i> , with the index being restored, the value of the filtered signal <i>j *</i> in each column: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0Aj%5E*_%7Bi%7D%20%3D%20%5Cbegin%7Bcases%7D%0A%5Coperatornamewithlimits%7Bargmin%7D%5Climits_%7Bj%7D(W_%7Bn-1%2C%20j%7D)%2C%20%26%20i%20%3D%20n%20-%201%20%5C%5C%0Am_%7Bi%2Cj%5E*_%7Bi%2B1%7D%7D%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%20i%20%3C%20n%20-%201%0A%5Cend%7Bcases%7D%0A" alt="j ^ * _ {i} = \ begin {cases} \ operatornamewithlimits {argmin} \ limits_ {j} (W_ {n-1, j}), &amp; amp; i = n - 1 \\ m_ {i, j ^ * _ {i + 1}}, &amp; amp; i &amp; lt; n - 1 \ end {cases}"></div><br>  Final values <img src="https://tex.s2cms.ru/svg/%5Cwidetilde%7BY%7D" alt="\ widetilde {Y}">  defined as <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cwidetilde%7BY%7D(X_i)%20%3D%20%5Cwidetilde%7BY%7D_%7Bj%5E*_i%7D%0A" alt="\ widetilde {Y} (X_i) = \ widetilde {Y} _ {j ^ * _ i}"></div><br>  In fig.  2 shows an example of the result of the described algorithm for a monotonous signal. <br><img src="https://habrastorage.org/files/54c/069/476/54c0694768494e668caf45131d105e8d.png"><br>  Fig.  2: Filtering a monotonically increasing signal by dynamic programming.  The input noise signal is shown in blue, the result of the algorithm is shown in green, the ideal non-noise signal in red. <br><br>  On this consideration of the auxiliary monotonous case is completed. <br><br><h2>  Unimodal signal </h2><br>  Using the result obtained, one can solve the problem of a unimodal signal by filling in 2 tables of the DP: one is filled as for a monotonic function, the second - in the same way, but in the opposite direction.  As a result, 2 functionalities are calculated: <img src="https://tex.s2cms.ru/svg/W%5E%7Blr%7D" alt="W ^ {lr}">  and <img src="https://tex.s2cms.ru/svg/W%5E%7Brl%7D" alt="W ^ {rl}">  as well as values <img src="https://tex.s2cms.ru/svg/m%5E%7Blr%7D" alt="m ^ {lr}">  and <img src="https://tex.s2cms.ru/svg/m%5E%7Brl%7D" alt="m ^ {rl}">  to restore paths to tables.  After that, among all values ‚Äã‚Äãof <i>i</i> and <i>j,</i> such a pair is searched. <img src="https://tex.s2cms.ru/svg/(i_0%2C%20j_0)" alt="(i_0, j_0)">  for which the sum of the functionals is minimal is the indices of the maximum of the approximated function.  The values ‚Äã‚Äãof the function on each side of it are restored according to the corresponding table. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A(i_0%2C%20j_0)%20%3D%20%5Coperatornamewithlimits%7Bargmin%7D%5Climits_%7Bi%2C%20j%7D(W%5E%7Blr%7D_%7Bi%2C%20j%7D%20%2B%20W%5E%7Brl%7D_%7Bi%2C%20j%7D)%0A" alt="(i_0, j_0) = \ operatornamewithlimits {argmin} \ limits_ {i, j} (W ^ {lr} _ {i, j} + W ^ {rl} _ {i, j})"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0Aj%5E*_%7Bi%7D%20%3D%20%5Cbegin%7Bcases%7D%0Aj_0%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%20i%20%3D%20i_0%20%5C%5C%0Am%5E%7Blr%7D_%7Bi%2C%20j%5E*_%7Bi%2B1%7D%7D%2C%20%26%20i%20%3C%20i_0%20%5C%5C%0Am%5E%7Brl%7D_%7Bi%2C%20j%5E*_%7Bi-1%7D%7D%2C%20%26%20i%20%3E%20i_0%0A%5Cend%7Bcases%7D%0A" alt="j ^ * _ {i} = \ begin {cases} j_0, &amp; amp; i = i_0 \\ m ^ {lr} _ {i, j ^ * _ {i + 1}}, &amp; amp; i &amp; lt; i_0 \\ m ^ {rl} _ {i, j ^ * _ {i-1}}, &amp; amp; i &amp; gt; i_0 \ end {cases}"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cwidetilde%7BY%7D(X_i)%20%3D%20%5Cwidetilde%7BY%7D_%7Bj%5E*_i%7D%0A" alt="\ widetilde {Y} (X_i) = \ widetilde {Y} _ {j ^ * _ i}"></div><br>  Figures 3 and 4 show an example of the original unimodal signal and the result of its processing by the proposed algorithm. <br><img src="https://habrastorage.org/files/ca1/903/b32/ca1903b32c50487bafb32f51b15965b4.png"><br>  Fig.  3: Noisy unimodal signal. <br><img src="https://habrastorage.org/files/409/095/1d7/4090951d7c0449dd89eeb495f5718e4b.png"><br>  Fig.  4: Filtering a unimodal signal by dynamic programming.  The input noise signal is shown in blue, the result of the algorithm is shown in green, the ideal non-noise signal in red. <br><br><h2>  Derivative constraint </h2><br>  In case it is known that the signal cannot change faster than some fixed speed <img src="https://tex.s2cms.ru/svg/v" alt="v">  (which is quite likely), the accuracy of the regression can be improved by introducing this restriction into the algorithm explicitly.  To do this, it is enough to calculate the maximum possible change in the signal value index <img src="https://tex.s2cms.ru/svg/dj_%7Bi%7D" alt="dj_ {i}">  for each <i>i</i> and prohibit transitions in the DP table with a change in <i>j by</i> more than this value: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0Adj_%7Bi%7D%20%3D%20%5Clceil%20v%20%5Ccdot%20(X_%7Bi%7D%20-%20X_%7Bi-1%7D)%20%2F%20(%5Cwidetilde%7BY%7D_%7B1%7D%20-%20%5Cwidetilde%7BY%7D_%7B0%7D)%5Crceil%0A" alt="dj_ {i} = \ lceil v \ cdot (X_ {i} - X_ {i-1}) / (\ widetilde {Y} _ {1} - \ widetilde {Y} _ {0}) \ rceil"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AW_%7Bi%2C%20j%7D%20%3D%20%5Cmin%5Climits_%7Bj-dj%20%5Cle%20k%20%5Cle%20j%7D(W_%7Bi-1%2C%20k%7D)%20%2B%20(%5Cwidetilde%7BY%7D_%7Bj%7D%20-%20Y_%7Bj%7D)%5E2%0A" alt="W_ {i, j} = \ min \ limits_ {j-dj \ le k \ le j} (W_ {i-1, k}) + (\ widetilde {Y} _ {j} - Y_ {j}) ^ 2"></div><br>  However, in order not to lose in laboriousness, you need to be able to get the minimum value of the functional on the segment [ <i>j - dj</i> , <i>j</i> ] for a constant time. <br>  This can be done using the Van Herk-Gil-Verman algorithm, described, for example, <a href="https://habrahabr.ru/post/116236">here</a> . <br><br>  The result of applying the algorithm with the restriction on the derivative <img src="https://tex.s2cms.ru/svg/v%20%3D%201.2" alt="v = 1.2">  shown in fig.  five. <br><img src="https://habrastorage.org/files/52b/725/65b/52b72565b407417184ac2feeb60bd275.png"><br>  Fig.  5: Filtering a unimodal signal by dynamic programming with a limitation on the rate of change of the signal.  The input noise signal is shown in blue, the result of the algorithm is shown in green, the ideal non-noise signal in red. <br><br><h2>  Exposing black magic </h2><br>  An inquisitive reader may suspect that the same or better results can be achieved in simpler ways.  Of course, with certain parameters of the signal and noise, the described technique will be superfluous.  In addition, the road you know is shorter.  Therefore, for each tricky case a specialist will surely find a favorite method that will give an acceptable result in his hands. <br><br>  To dispel a sense of possible fraud, in fig.  Figures 6 and 7 show examples of signal processing by Gaussian smoothing and median filtering with a zerkalization at zero.  Filter parameters were selected in order to obtain an optimal result, but without fanaticism. <br><img src="https://habrastorage.org/files/08c/66a/ad3/08c66aad31714caaa081d3891bad337a.png"><br>  Fig.  6: Filtering a unimodal signal with Gaussian smoothing.  The blue color shows the input noisy signal, green - the result of filtering, red - the ideal non-noise signal. <br><img src="https://habrastorage.org/files/4ed/de1/8ab/4edde18ab57d451583016d9b3232120e.png"><br>  Fig.  7: Median unimodal filtering.  The blue color shows the input noisy signal, green - the result of filtering, red - the ideal non-noise signal. <br><br>  As can be seen, on sufficiently arbitrary data, the dynamic programming method gives a better result than the simplest well-known filters.  At the same time, comparing them on model examples in detail is absolutely pointless.  The above method is valuable precisely because it is an example of a ‚Äúsuit tailored to measure‚Äù: a formalized statement of the problem was laid at the very foundation of the method.  In the case under consideration, this was a condition of unimodality.  Similarly, linear methods ‚Äúby measure‚Äù to signals that are frequency-separable with noise.  Another tool in the kit - what could be better for an engineer? </div><p>Source: <a href="https://habr.com/ru/post/279427/">https://habr.com/ru/post/279427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279417/index.html">JPoint Witnesses: What Makes a Programmer Special?</a></li>
<li><a href="../279419/index.html">Why I write my algorithms in 95% of cases, and I will continue to develop code bikes</a></li>
<li><a href="../279421/index.html">ECMA-262 standard (JavaScript) in pictures, part 1</a></li>
<li><a href="../279423/index.html">New round of fighting Rutraker and pirated resources</a></li>
<li><a href="../279425/index.html">Using √Öngstr√∂m Style System in real projects</a></li>
<li><a href="../279429/index.html">Three main browsers added support for low-level WebAssembly binary format</a></li>
<li><a href="../279431/index.html">ePMP AP Lite | Use of ePMP 1000 Cambium Networks Licenses</a></li>
<li><a href="../279435/index.html">New ICQ for Windows, open source and something else</a></li>
<li><a href="../279437/index.html">Checking the source code of the PVS-Studio plugin with PVS-Studio</a></li>
<li><a href="../279439/index.html">A simple and not very obvious way to hang chrome, firefox and nodejs inside a native function</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>