<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ tests without macros and dynamic memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many popular libraries for testing, such as Google Test, Catch2, Boost.Test, are heavily tied to using macros, so as an example of tests on these libr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ tests without macros and dynamic memory</h1><div class="post__text post__text-html js-mediator-article"><p>  Many popular libraries for testing, such as Google Test, Catch2, Boost.Test, are heavily tied to using macros, so as an example of tests on these libraries, you usually see a picture like this: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  To macros in C ++, the attitude is wary, why are they so flourishing in libraries for creating tests? </p><a name="habracut"></a><br><p>  The unit test library should provide its users with a way to write tests, so that the test runtime environment can somehow find and execute them.  When you think about how to do this, then using macros seems the easiest.  The TEST () macro usually defines a function somehow (in the case of the Google Test, the macro also creates a class) and ensures that the address of this function falls into some global container. </p><br><p>  A well-known library in which the approach is implemented without a single macro is the <a href="https://github.com/mrzechonek/tut-framework">tut-framework</a> .  Let's see her example from the tutorial: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  The idea that lies at the core is quite interesting and it works, it‚Äôs all not very complicated.  In short, you have a base class in which the template function is implemented, which assumes parameterization with an integer number: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Now when you write this test: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  You actually create a test method specialization for a specific number N = 1 (this is exactly what the <code>template&lt;&gt;template&lt;&gt;</code> ).  By calling <code>test&lt;N&gt;()</code> the test execution environment can understand whether it was a real test or it was a stub looking at the value <code>called_method_was_a_dummy_test_</code> after the test was executed. </p><br><p>  Further, when you declare a group of tests: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  First, you enumerate all <code>test&lt;N&gt;</code> to a certain constant wired into the library, and, secondly, as a side effect, add information about the group to the global container (group name and addresses of all test functions). </p><br><p>  Tut uses exceptions as test conditions, so the <code>tut::ensure_equals()</code> function will simply throw an exception if the two values ‚Äã‚Äãpassed to it are not equal, and the test run environment will catch the exception and count the test as failed.  I like this approach; any C ++ developer will immediately understand where such asserts can be used.  For example, if my test created an auxiliary stream, then it is useless to place asserts there, no one will catch them.  In addition, I understand that my test should be able to free up resources in the event of an exception, as if it were a normal exception-safe code. </p><br><p>  In principle, the tut-framework library looks pretty good, but there are some drawbacks to its implementation.  For example, for my case, I would like the test to have not only a number, but also other attributes, in particular the name, as well as the "size" of the test (for example, is it an integration test or is it a unit test).  This can be solved within the tut API, and even something is already there, but something can be realized by adding a method to the library API, and calling it in the body of the test to set some of its parameters: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Another problem is that the tut test runner knows nothing about such an event as the beginning of a test.  The environment performs <code>object::test&lt;N&gt;()</code> and it does not know in advance whether the test is implemented for this N, or is it just a stub.  She only learns when the test is over by analyzing the value of the <code>called_method_was_a_dummy_test_</code> .  This feature does not show itself very well in CI systems that can group the output that the program made between the beginning and the end of the test. </p><br><p>  However, in my opinion the main thing that can be improved ("fatal flaw") is the presence of unnecessary auxiliary code required for writing tests.  In the tutorial tut-framework, there are quite a lot of things: it is proposed to first create a certain class <code>struct basic{}</code> , and describe tests as object methods related to this.  In this class, you can define the methods and data that you want to use in a test group, and the constructor and destructor frame the test execution, creating such a thing as fixture from jUnit.  In my practice of working with tut, this object is almost always empty, but it drags a certain number of lines of code. </p><br><p>  So, we go to the bicycle workshop and try to shape the idea in the form of a small library. </p><br><p>  Here is the minimum test file in the "tested" library: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  In addition to the absence of macros, the bonus is the absence of the use of dynamic memory inside the library. </p><br><h3 id="opredelenie-test-keysov">  Test Case Definition </h3><br><p>  For registration of tests the template magic of initial level is used on the same principle as tut.  Somewhere in tested.h there is a template function of this type: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Test cases that library users write are simply specializations of this method.  The function is declared static, i.e.  in each translation unit we create specializations that do not intersect each other by name when linking. </p><br><p>  There is such a rule that you first need to call <code>StartCase()</code> , which you can pass things like the name of the test and maybe some other things that are still in development. </p><br><p>  When the test calls <code>runtime-&gt;StartTest()</code> interesting things can happen.  First of all, if the tests are now in run mode, then you can report somewhere that the test has started execution.  Secondly, if now there is a mode of collecting information about the available tests, <code>StartTest()</code> throw a special kind of exception that will mean that the test is real, and not a stub. </p><br><h3 id="registraciya">  check in </h3><br><p>  At some point, you need to collect the addresses of all test cases and somewhere to put them.  In tested, this is done using groups.  This is done by the constructor of the class tested :: Group as a side effect: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  The constructor creates a group with the specified name and adds to it all <code>Case&lt;N&gt;</code> cases that it finds in the current translation unit.  It turns out that in one translation unit you cannot have two groups.  It also means that you cannot split one group into multiple translation units. </p><br><p>  The template parameter goes to how many test cases to look for in the current translation unit for the group being created. </p><br><h3 id="linkovka">  Linking </h3><br><p>  In the above example, the creation of the object tested :: Group () occurs inside a function that we have to call from our application to register the tests: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  The function is not always required, sometimes you can simply declare an object of the class <code>tested::Group</code> inside the file.  However, my experience is that the linker sometimes "optimizes" the entire file, if it is compiled inside the library, and none of the main application uses any characters from this cpp file: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  When the calc_test.cpp is not linked to the run_test.exe sources, the linker simply removes this file from consideration in its entirety, together with the creation of a static object, despite the fact that it has the necessary side effects. </p><br><p>  If what chain leads from run_test.exe, then a static object will appear in the executable file.  And no matter how it will be done, as in the example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  or so: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  The first option, in my opinion, is better because the constructor call is executed after the start of the main () operation, and the application has some control over this process. </p><br><p>  I think that this installation of crutches is required for any unit-testing library that uses global variables and constructor side effects to create a database of tests.  However, it can probably be avoided by linking the test library with the key --whole-archive (the analogue in MSVC appeared only in Visual Studio 2015.3). </p><br><h3 id="makrosy">  Macros </h3><br><p>  I promised that there will be no macros here, but it is - <code>CASE_COUNTER</code> .  The working version is that it is used by <code>__COUNTER__</code> , a macro that the compiler increases by one each time it is used inside the translation unit. <br>  GCC, CLANG, MSVC is supported, but not standard.  If this is frustrating, here are some alternatives: </p><br><ul><li>  use digits 0, 1, 2 </li><li>  use standard <code>__LINE__</code> . </li><li>  use constexpr magic level 80.  You can search for "constexpr counter" and try to find a compiler on which it will work. </li></ul><br><p>  The problem with <code>__LINE__</code> is that using large numbers in the template parameters creates a large executable file size.  That is why I limited the signed char template type to 128 as the maximum number of tests in a group. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  Waiver of dynamic memory </h3><br><p>  It turned out that when registering tests, you can not use dynamic memory, which I used.  It is possible that there is no dynamic memory in your environment or you are searching for memory leaks in test cases, so that the intervention of the test execution environment is not what you need.  Google Test is struggling with this, here is a fragment from there: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  And we can simply not create difficulties. </p><br><p>  How do we then get a list of tests?  These are more technical insides that are easier to see in the source code, but I‚Äôll tell you anyway. </p><br><p>  When a group is created, its class will receive a pointer to the function <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , which will collect all the tests of the translation unit into the list.  This is how it works: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  It turns out that in each translation unit there are many static variables of the form CaseListEntry CaseCollector \ :: s_caseListEntry, which are elements of the test list, and the collect () method collects these elements into a single-linked list.  Approximately in the same way the list forms test groups, but without patterns and recursion. <br></p><br><h3 id="struktura">  Structure </h3><br><p>  Tests need a different binding, such as output in the console with red letters Failed, creating test reports in a format understandable for CI or GUI in which you can view a list of tests and run selected ones - in general, a lot of things.  I have a vision of how this can be done, which is different from what I saw before in the testing library.  The claim is mainly to libraries that call themselves "header-only", while including a large amount of code, which in fact is not at all for header files. </p><br><p>  The approach that I assume is that we divide the library into a front-end ‚Äî this one itself is tested.h and the back-end are libraries.  For writing tests, only tested.h is needed, which is now C ++ 17 (because of the awesome std :: string_view) but it is assumed that it will be C ++ 98.  Tested.h performs the actual registration and search for tests, the minimally convenient launch option, and the ability to export tests (groups, addresses of test case functions).  Back-end libraries that do not exist yet can do everything they need, in terms of output and launch, using the export functionality.  In the same way, you can adjust the launch to the needs of your project. </p><br><h3 id="itog">  Total </h3><br><p>  The library tested ( <a href="https://github.com/vzvezda/tested">github code</a> ) still has some stabilization.  In the near future plans to add the ability to perform asynchronous tests (needed for integration tests in WebAssembly) and specify the size of the tests.  In my opinion, the library is still not quite ready for production use, but I have already unexpectedly spent a lot of time and this stage has come to stop, take a breath and ask for feedback from the community.  Would you be interested in using this kind of library?  Maybe in C ++ arsenal there are any other ideas on how to create a library without macros?  Is such a problem statement interesting at all? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/434906/">https://habr.com/ru/post/434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434894/index.html">The art of shamanism or custom firmware for Olinuxino. Part 1</a></li>
<li><a href="../434896/index.html">Hall of Fame consumer electronics: the history of the best gadgets of the last 50 years, part 1</a></li>
<li><a href="../434898/index.html">Grasp2Vec: Learning to Represent Objects Through Self-Learning Capture</a></li>
<li><a href="../434900/index.html">Happy New Year 2019 - competition</a></li>
<li><a href="../434902/index.html">Creating a custom query generator in Spring Data Neo4j (Part 1)</a></li>
<li><a href="../434908/index.html">Programming Education - What? Where? When?</a></li>
<li><a href="../434912/index.html">The annual stock of Porsche Taycan is already reserved, mainly by Tesla owners.</a></li>
<li><a href="../434924/index.html">What to read about the organization of jobs, coworking and design of spaces for remote work</a></li>
<li><a href="../434928/index.html">Methods of application and distortion of accuracy in games. Visual graphs for comparison</a></li>
<li><a href="../434930/index.html">Video advertising today: must have a successful business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>