<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multi-Modularity and Dagger 2. Yandex Lecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When your application is built on a multi-modular architecture, you have to devote a lot of time to ensuring that all communications between modules a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multi-Modularity and Dagger 2. Yandex Lecture</h1><div class="post__text post__text-html js-mediator-article">  When your application is built on a multi-modular architecture, you have to devote a lot of time to ensuring that all communications between modules are correctly written in the code.  Half of this work can be entrusted to the Dagger 2 framework. Head of the Yandex.Maps group for Android Vladimir Tagakov <a href="https://habr.com/users/noxa/" class="user_link">Noxa</a> spoke about the pros and cons of multi- <a href="https://habr.com/users/noxa/" class="user_link">modularity</a> and convenient DI organization inside modules using Dagger 2. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pMEAD6jjbaI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - My name is Vladimir, I am developing Yandex.Maps and today I will tell you about modularity and the second Dagger. <a name="habracut"></a><br><br>  I understood the longest part when I studied it myself, the fastest.  The second part, over which I sat for several weeks, I will tell very quickly and concisely. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/t5/2r/s5/t52rs5gcestw_7jvexuardxaaus.jpeg"><br><br>  Why are we in Maps started a difficult process of dividing into modules?  We just wanted to increase the speed of assembly, everyone knows about it. <br><br>  The second point of the goal is to reduce the code engagement.  I hooked from Wikipedia.  This means that we wanted to reduce interconnections between modules so that the modules are separate and can be used outside the application.  The initial formulation of the problem: other Yandex projects should be able to use part of the functionality of the Maps exactly as we have.  And to develop this functionality, we were engaged in the development of the project. <br><br>  I want to throw burning sneakers towards [k] apt, which slows down the speed of assembly.  I don't hate him much, but I love him a lot.  He allows me to use Dagger. <br><br><img src="https://habrastorage.org/webt/9c/bz/iv/9cbzivba2osslltalebrdwqfsre.jpeg"><br><br>  The main disadvantage of the separation process into modules is, paradoxically, slowing down the assembly speed.  Especially at the very beginning, when you take out the first two modules, Common and some of your features, the overall build speed of the project drops, no matter how hard you try.  At the end, when less and less code remains in your main module, the build speed will increase.  Still, this does not mean that everything is very bad, there are ways to get around this and even have a profit from the first module. <br><br>  The second drawback is that it is difficult to divide the code into modules.  Who tried, knows that you are starting to draw some kind of dependencies, some kind of classics, and everything ends with the fact that you copied your entire main module into another module and started again.  Therefore, you need to clearly understand the moment when you need to stop and break the connection using some kind of abstraction.  The disadvantage is more abstractions.  More abstractions - harder to design - more abstractions. <br><br>  It's hard to add new gradle modules.  Why?  For example, a developer comes, takes a new feature into development, immediately does well, makes a separate module.  What is the problem?  He should keep in mind all the available code that is in the main module, so that, if anything, reuse it and bring it to Common.  Because the process of removing a module in Common is constant until your main App module turns into a thin layer. <br><br>  Modules, modules, modules ... Gradle modules, Dagger modules, interface modules - horror. <br><br><img src="https://habrastorage.org/webt/2b/nj/x2/2bnjx25ooi8xw2exdinm5yfmmys.jpeg"><br><br>  The report will consist of three parts: small, large and complex.  First, about the difference between Implementation and API in AGP.  Android Gradle Plugin 3.0 appeared relatively recently.  How was it before him? <br><br><img src="https://habrastorage.org/webt/qc/oa/fw/qcoafwzux6royjdv11tr0sqvmug.jpeg"><br><br>  Here is a typical project of a healthy developer, consisting of three modules: the App module, which is the main one, is assembled and installed into the application, and two Feature modules. <br><br>  Immediately talk about the arrows.  This is a big pain, everyone draws in the direction in which he is comfortable to draw.  For me, they mean that the arrow goes from Core to Feature.  So, Feature knows about Core, can use classes from Core.  As you can see, there are no arrows between Core and App, which means the App should not use Core.  Core is not a Common Module, it is, everything depends on it, it is separate, there is little code in it.  While we will not consider it. <br><br>  Our core module has changed, we need to redo it somehow.  We change the code in it.  Yellow - change code. <br><br><img src="https://habrastorage.org/webt/l4/b1/5w/l4b15wdqsgukdttudzee9vbxne0.jpeg"><br><br>  After rebuilding the project.  It is clear that after changing a module, it will have to be recompiled, recompiled.  Okay. <br><br><img src="https://habrastorage.org/webt/_q/jo/mh/_qjomhp4-vkpioy_0ai112zuam0.jpeg"><br><br>  After going and Feature module, which depends on it.  It‚Äôs also understandable, his dependency was rebuilt, and you need to update yourself.  Who knows what has changed there. <br><br>  And here comes the most unpleasant.  The App module is being assembled, although it is not clear why.  I know for sure that I don‚Äôt use Core at all, and it‚Äôs unclear why the App is being rebuilt.  And it is very big, because at the very beginning of the journey, and this is a very big pain. <br><br><img src="https://habrastorage.org/webt/hu/j8/la/huj8larhnqmhr6dq7qhp2etnkc8.jpeg"><br><br>  In addition, if several features depend on Core, many modules, then the whole world is reassembled, this is a very long time. <br><br>  Let's move on to the new version of AGP and replace, as the instruction says, all compile with the API, and not with Implementation, as you thought.  Nothing changes.  Identical schemes.  What is the new way to specify dependencies Implementation?  Imagine the same scheme using only this keyword, without an API?  It will look like this. <br><br><img src="https://habrastorage.org/webt/nj/ns/fg/njnsfgghg9om12lpwlu5yh21hmu.jpeg"><br><br>  Here in the implementation it is clear that there is a connection between Core and App.  Here we can clearly understand that we don‚Äôt need it, we want to get rid of it, so we just remove it.  It becomes all kind of simpler. <br><br><img src="https://habrastorage.org/webt/rp/lx/xr/rplxxrfrsee28vucqevngre8xq4.jpeg"><br><br>  Now almost everything is good, even more than.  If we change some API in Core, add a new class, a new public or package private method, Core and Feature will be rebuilt.  If you change the implementation inside the method or add the private method, then theoretically the Reassembly Feature should not do anything at all, because nothing has changed. <br><br><img src="https://habrastorage.org/webt/mk/ub/1e/mkub1ect0enydqitlermncinoyk.jpeg"><br><br>  Let's go further.  It so happened that many depend on our Core.  Probably, Core is some kind of Network or user data processing.  Because it is a Network, everything changes quite often, everything is rebuilt, and we got the same pain that we diligently ran away from. <br>  Let's look at two ways how to deal with it. <br><br><img src="https://habrastorage.org/webt/um/_d/c-/um_dc-9rumfh-vyvlqdavr6zvgg.jpeg"><br><br>  We can take out from our Core module in a separate module only API interfaces, its API, which we use.  And in a separate module we can take out the implementation of these interfaces. <br><br><img src="https://habrastorage.org/webt/eu/o8/0-/euo80-48enzm_rvppcwmb1qbjca.jpeg"><br><br>  You can look at the connection on the screen.  Core Impl will not be available for ficherov.  That is, there will be no connection between the features and the Core implementation.  And the module highlighted in yellow will only provide factories that will provide some unknown implementations of your interfaces. <br><br>  After such a conversion, I want to note that the Core API, due to the fact that the API keyword is, will be available to all features transitively. <br><br><img src="https://habrastorage.org/webt/7a/lq/iu/7alqiukvhfpie8_olsuekuczfgi.jpeg"><br><br>  After these transformations, we change something in the implementation that you do most often, and only the module with factories will be rebuilt, it is very light, small, you can not even consider how long it takes. <br><br><img src="https://habrastorage.org/webt/8p/ri/ah/8priahixb3prj9of3cqpzqjxaeg.jpeg"><br><br>  Another option does not always work.  For example, if this is some kind of Network, then I can hardly imagine how this can happen, but if this is some sort of user login screen, then it may well be. <br><br><img src="https://habrastorage.org/webt/eu/rf/cs/eurfcs3tlrk9jasm6fqphr5lb4y.jpeg"><br><br>  We can make Sample, the same full root module as the App, and collect only one feature in it, it will be very fast, and it can be quickly and iteratively developed.  At the end of the presentation, I‚Äôll show how much time it takes to build and assemble a sample. <br><br>  With the first part finished.  What modules are there? <br><br><img src="https://habrastorage.org/webt/sv/jm/xk/svjmxkqxazeydcsinvypfuh_-24.jpeg"><br><br>  Modules are of three types.  Common, of course, should be as easy as possible, and it should not be some features, but only the functionality that is used by all.  For us in our team this is especially important.  If we provide our Feature modules to other applications, we will force them to drag Common anyway.  If he is very fat, then no one will love us. <br><br><img src="https://habrastorage.org/webt/bd/n-/1s/bdn-1si0fx1fxre86gldhgepx34.jpeg"><br><br>  If you have a smaller project, then with Common you can feel more free, you also do not have to be very zealous. <br><br><img src="https://habrastorage.org/webt/ah/jj/fi/ahjjfiyfzltnadyswlalhsoeh-u.jpeg"><br><br>  The next type of module is Standalone.  The most common and intuitive module that contains a specific feature: a screen, a user script, and so on.  It should be as independent as possible, and for it most often you can make a sample App and develop it in it.  The Sample App is very important at the beginning of the split process, because everything is still building slowly and you want to get profit as soon as possible.  At the end, when everything is beaten into modules, you can reassemble everything, it will be fast.  Because it will not reassemble once again. <br><br><img src="https://habrastorage.org/webt/sz/la/p5/szlap5ot3jnjdtvsj5roegwlboy.jpeg"><br><br>  Celebrity modules.  I myself came up with the word.  The point is that he is very well known to everyone, and many depend on him.  Same Network.  I have already told you, if you often rebuild it, how can you avoid the fact that everything is being rebuilt.  There is another way that can be applied to small projects for which it is not worth the goal to give everything out as a separate dependency, a separate artifact. <br><br><img src="https://habrastorage.org/webt/pk/yq/u8/pkyqu8xflbfu40ufwly3wr4rgzi.jpeg"><br><br>  What does this look like?  We repeat that from Celebrity you take out the API, take out its implementation, and now watch your hands, pay attention to the arrows from Feature to Celebrity.  It happens.  The API of your module got into Common, the implementation remained in it itself, and the factory, which provides the implementation of this API, appeared in your main module.  If someone watched Mobius, then Denis Neklyudov talked about it.  Very similar scheme. <br><br>  We use Dagger in the project, we like it, and we wanted to get as much benefit from this as possible in the context of different modules. <br><br><img src="https://habrastorage.org/webt/kr/ak/xu/krakxunqnjjjoinel9yk0sfbemc.jpeg"><br><br>  We wanted each module to have an independent dependency graph, to have a specific root component from which you can do anything, we wanted to have its own generated code for each Gradle module.  We did not want the generated code to creep into the main one.  We wanted as much compile-time validation as possible.  We suffer from [k] apt, at least some profit should get from what gives Dagger.  And with all this, we did not want to force anyone to use the Dagger.  Neither the person who implements the fresh feature module is separate, nor the one who then consumes it, our colleagues, who ask for some features for themselves. <br><br>  How to organize a separate dependency graph inside our feature module? <br><br><img src="https://habrastorage.org/webt/9p/-u/im/9p-uimpq3hakpiwmedw-kinrsai.jpeg"><br><br>  You can try using Subcomponent, and it will even work.  But this has quite a few flaws.  You can see that in Subcomponent it is not clear exactly what dependencies it uses from the Component.  To understand this, you will have to rebuild the project for a long time and painfully, look at what Dagger swears at and add it. <br>  In addition, the subcomponents are designed in such a way that they force others to use Dagger, and it will not be possible to launch all this at your clients and yourself if you decide to opt out of some module. <br><br><img src="https://habrastorage.org/webt/d3/wz/vj/d3wzvj5_hjyy31e9rl-6hlo36ck.jpeg"><br><br>  One of the most disgusting things is that when using Subcomponent, all dependencies are pulled into the main module.  Dagger is designed so that subcomponents are generated by the nested class of their framing components, the parent ones.  Maybe someone looked at the gene code and its size, on their gene components?  We have 20 thousand lines in it.  Since the subcomponents are always nested classes for components, it turns out that the subcomponents of the subcomponents are also nested, and the entire gene code falls into the main module, this twenty thousand-fold file that needs to be compiled, and it needs to be refactored, the Studio starts to slow down - pain. <br><br>  But there is a solution.  You can use just the Component. <br><br><img src="https://habrastorage.org/webt/dr/1b/lc/dr1blc8pj2qzzhxs3pnnu7lbqui.jpeg"><br><br>  In Dagger, a component can specify dependencies.  This is shown in the code, and shown in the picture.  Dependencies, where you specify Provision methods, factory methods that show which particular entity your component depends on.  He wants to get them at the time of creation. <br>  Previously, I always thought that only other components could be specified in these dependencies, and for some reason, the documentation says so. <br><br><img src="https://habrastorage.org/webt/gk/us/45/gkus45n1uhs0jhqjojmciaa3y48.jpeg"><br><br>  Now I understand what it means to use the component interface, but earlier I thought it was just a component.  In fact, you need to use an interface that is composed according to the rules for creating an interface for a component.  In short, just Provision-methods, when you just have getters for some dependencies.  Also, sample code is in the Dagger documentation. <br><br><img src="https://habrastorage.org/webt/ry/jo/63/ryjo63y8bfqo1a5kfkgeff4iv10.jpeg"><br><br>  OtherComponent is also written there, and this is confusing, because in fact, it is not only possible to thrust components there. <br><br>  How would we like to use this business in reality? <br><br><img src="https://habrastorage.org/webt/sy/v1/r_/syv1r_5jzsr7i8vkniesru582gg.jpeg"><br><br>  In reality, there is a Feature-module, it has an API package that is visible, is close to the root of all packages, and there it is indicated that there is an entry point - the FeatureActivity.  It is not necessary to use typealias, just to be clear.  This may be a fragment, maybe a ViewController - it does not matter.  And there are his dependencies, FeatureDeps, where it is indicated that he needs a context, some kind of Network-service, from Common some kind of thing that he wants to receive from the App, and any client is obliged to satisfy it.  When he does, it will work. <br><br><img src="https://habrastorage.org/webt/tu/rl/yk/turlykyi-zrmheakatdmpasqqr4.jpeg"><br><br>  How do we use all this in the feature module?  Here I use Activity, this is optional.  We normally create our root Dagger component and use the magic method findComponentDependencies, it is very similar to Dagger for Android, but we cannot use it first of all because we don‚Äôt want to drag subcomponents.  Otherwise, all the logic we can learn from them. <br><br>  At first I tried to tell how it works, but you can see it in the sample project on Friday.  How do you need to use your library clients in your main module? <br><br><img src="https://habrastorage.org/webt/ui/nk/mj/uinkmj6kxqhr3218cfbo_y8v9uk.jpeg"><br><br>  First of all, it's just typealias.  In fact, it has a different name, but for brevity so.  MapOfDepth on the Dependency interface class gives you its implementation.  In the App, we say that we can do dependencies in the same way as in Dagger for Android, and it is very important that the component inherits this interface, automatically receives Provision-methods.  Dagger from this moment begins to force us to provide this dependence.  Until you provide it, it will not compile.  This is the main convenience: you decide to make a feature, expand your component with this interface - everything, until you do everything else, it will not just compile, but will produce clear error messages.  The module is simple, the point is that it binds your component to the interface implementation.  About the same as in Dagger for Android. <br><br>  We turn to the results. <br><br><img src="https://habrastorage.org/webt/hs/gv/0o/hsgv0oyk_v-jbzjk8lono2uepju.jpeg"><br><br>  I checked on our mainframe and on my local laptop, before turning off all that is possible.  If we add a public method to Feature, then the build time is significantly different.  Here I show the differences in the case when I bilju sample-project.  It is 16 seconds.  Or when I collect all the cards - it means two minutes to sit and wait at every, even minimal change.  Therefore, we develop many features and will develop them in sample projects.  On the mainframer time is comparable. <br><br><img src="https://habrastorage.org/webt/ey/ou/va/eyouvaxzp3kw8cl0eb3jznokvpe.jpeg"><br><br>  Another important result.  Before the Feature module was selected, it looked like this: there were 28 seconds on the mainframe, now it's 49 seconds.  We have identified the first module, and have already received a slowdown of the assembly almost twice. <br><br><img src="https://habrastorage.org/webt/f2/px/_o/f2px_oqd8uktolgh3-f2ae8j6to.jpeg"><br><br>  And one more option is a simple incremental build of our module, not features like the previous one.  28 seconds was before the module was selected.  When they identified a code that does not need to be re-compiled each time, and [k] apt, which is not necessary to be carried out each time, they won three seconds.  God knows that, but I hope that with each new module, time will only decrease. <br><br>  Here are useful links to articles: <a href="http://bit.ly/build-time-test">API versus implementation</a> , <a href="http://bit.ly/new-agp">article with measurements of build time</a> , <a href="http://bit.ly/modules-sample">sample module</a> .  The presentation will be <a href="https://yadi.sk/i/qlzAWgS93YDc8j">available</a> .  Thank. </div><p>Source: <a href="https://habr.com/ru/post/419295/">https://habr.com/ru/post/419295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419273/index.html">Writing Linux kernel module: IRQ-enabled GPIO</a></li>
<li><a href="../419277/index.html">Thermal tape with protection class IP68. Suitable for light in the bath</a></li>
<li><a href="../419279/index.html">The digest of interesting materials for the mobile developer # 264 (July 30 - August 5)</a></li>
<li><a href="../419283/index.html">Bezos throws money and engineers to develop a rocket in connection with the acceleration of the space race</a></li>
<li><a href="../419291/index.html">Announcement of Heisenbug 2018 Moscow: all the answers</a></li>
<li><a href="../419297/index.html">View comments on Habr√© in order of adding</a></li>
<li><a href="../419299/index.html">Smart lamp that shows the mood in your city</a></li>
<li><a href="../419303/index.html">Tesla report showed higher losses and revenue than investors expected</a></li>
<li><a href="../419305/index.html">Spy toy or find: Barbie ‚Ñ¢ typewriter</a></li>
<li><a href="../419307/index.html">Roskomnadzor inquired about Facebook business connections</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>