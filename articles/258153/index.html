<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Coverage SQL in Postgres</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One thing that makes me look at the ORM from the side is how they try so hard to hide and abstract all the power and expressiveness of SQL. Before I w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Coverage SQL in Postgres</h1><div class="post__text post__text-html js-mediator-article">  One thing that makes me look at the ORM from the side is how they try so hard to hide and abstract all the power and expressiveness of SQL.  Before I write further, let me say that, <a href="https://twitter.com/fransbouma">Frans Bouma</a> reminded me yesterday that there is a difference between ORM and the people who use them.  These are just tools (in ORM) and I agree with that, I also agree that not bad fast food makes people full, and these are people who eat it too much. <br><br>  Instead of scolding ORM, I would like to tell you why I do not use an OO abstraction at the base of my database.  In short: because SQL can help you a lot to express the value of your application in terms of data.  The only way to know how your application works is to know from what data it is generated. <br><a name="habracut"></a><br>  Try to devote some time to studying it, and you will see how your favorite DB engine in work emphasizes the SQL standard.  Let's look at some examples, all the functionality that I use is described <a href="http://www.postgresql.org/docs/9.4/static/functions.html">here</a> , there are many things in the documentation that you can find out, my examples below, but this is only part of the functionality that I use. <br><br><h1>  Postgres Built-in Fun </h1><br>  Right from the start, there are a lot of syntax sugar in Postgres, and it's really fun to do with it.  SQL is ANSI standardized languages ‚Äã‚Äã- this means that you can count on some rules when moving from one system to another.  Postgres follows standards almost to the letter, but goes beyond with very funny additions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Regular expressions </h1><br>  At some point you may have to run some chain of algorithms.  Many databases including <a href="https://msdn.microsoft.com/en-us/magazine/cc163473.aspx">SQL Server</a> (sorry for the link to MSDN) allow you to use Regex patterns through functions or some other constructs.  It is a pleasure to work with Posters.  Easy way (using psql for old Takepub database): <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sku,title <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> title ~* <span class="hljs-string"><span class="hljs-string">'master'</span></span>; sku | title <span class="hljs-comment"><span class="hljs-comment">------------+--------------------------------- aspnet4 | Mastering ASP.NET 4.0 wp7 | Mastering Windows Phone 7 hg | Mastering Mercurial linq | Mastering Linq git | Mastering Git ef | Mastering Entity Framework 4.0 ag | Mastering Silverlight 4.0 jquery | Mastering jQuery csharp4 | Mastering C# 4.0 with Jon Skeet nhibernate | Mastering NHibernate 2 (10 rows)</span></span></code> </pre> <br>  The ~ * operator says: that the POSIX regular expression pattern follows (case insensitive) <br>  You can do this case-sensitive by omitting *. <br>  Regular expressions can be a pain at work, but you could improve this query using functions for full-text search using indexes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector(title) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'Mastering'</span></span>); sku | title <span class="hljs-comment"><span class="hljs-comment">------------+--------------------------------- aspnet4 | Mastering ASP.NET 4.0 wp7 | Mastering Windows Phone 7 hg | Mastering Mercurial linq | Mastering Linq git | Mastering Git ef | Mastering Entity Framework 4.0 ag | Mastering Silverlight 4.0 jquery | Mastering jQuery csharp4 | Mastering C# 4.0 with Jon Skeet nhibernate | Mastering NHibernate 2 (10 rows)</span></span></code> </pre><br>  But it is a little more difficult.  Postgres is a field type using the full text search tsvector.  You can even have this column in the table, if you want, and that's great, since it is not hidden in some binary index somewhere.  I converted the title on the fly to the tsvector using the to_tsvector function.  It breaks and prepares the string for the search.  I show this through the to_tsquery function.  This query is built from the term "Mastering".  The @@ bits simply say to return true if the tsvector fields match the tsquery.  The syntax hurts the eye a little, but it works very well and quickly.  You can use the concat function to concatenate strings with additional fields: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector(<span class="hljs-keyword"><span class="hljs-keyword">concat</span></span>(title,<span class="hljs-string"><span class="hljs-string">' '</span></span>,description)) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'Mastering'</span></span>); sku | title <span class="hljs-comment"><span class="hljs-comment">------------+--------------------------------- aspnet4 | Mastering ASP.NET 4.0 wp7 | Mastering Windows Phone 7 hg | Mastering Mercurial linq | Mastering Linq git | Mastering Git ef | Mastering Entity Framework 4.0 ag | Mastering Silverlight 4.0 jquery | Mastering jQuery csharp4 | Mastering C# 4.0 with Jon Skeet nhibernate | Mastering NHibernate 2 (10 rows)</span></span></code> </pre><br>  Combining the title and description into one area allows you to search for them at the same time, using all the features of <a href="http://www.postgresql.org/docs/9.4/static/textsearch.html">full-text search</a> . <br><br><h1>  Generation Series </h1><br>  There is a good generate_series function that outputs a sequence that you can use in queries for various reasons: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>); generate_series <span class="hljs-comment"><span class="hljs-comment">----------------- 1 2 3 4 5 6 7 8 9 10</span></span></code> </pre><br>  If sequential functions do not suit you, you can use other functions of the type random (): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); generate_series <span class="hljs-comment"><span class="hljs-comment">----------------- 3 5 7 1 9 (5 rows)</span></span></code> </pre><br>  Here I added an additional argument, talking about the omission of values ‚Äã‚Äãby 2. It also works with dates: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2014-01-01'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2014-12-01'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'42 days'</span></span>); generate_series <span class="hljs-comment"><span class="hljs-comment">--------------------- 2014-01-01 00:00:00 2014-02-12 00:00:00 2014-03-26 00:00:00 2014-05-07 00:00:00 2014-06-18 00:00:00 2014-07-30 00:00:00 2014-09-10 00:00:00 2014-10-22 00:00:00 (8 rows)</span></span></code> </pre><br>  I'm talking about dates 2014 with an interval of 42 days.  You can do this in the opposite direction, simply using a negative interval.  Why is this useful?  You can use alias and connect the numbers from the generated series, depending on what you think: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> first_of_the_month <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-string"><span class="hljs-string">'2014-01-01'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>,<span class="hljs-string"><span class="hljs-string">'2014-12-01'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>,<span class="hljs-string"><span class="hljs-string">'1 month'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f(x); first_of_the_month <span class="hljs-comment"><span class="hljs-comment">--------------------- 2014-01-01 00:00:00 2014-02-01 00:00:00 2014-03-01 00:00:00 2014-04-01 00:00:00 2014-05-01 00:00:00 2014-06-01 00:00:00 2014-07-01 00:00:00 2014-08-01 00:00:00 2014-09-01 00:00:00 2014-10-01 00:00:00 2014-11-01 00:00:00 2014-12-01 00:00:00 (12 rows)</span></span></code> </pre><br>  Alias ‚Äã‚Äãfunctions allow you to use the result string in accordance with the SQL call. <br>  Such things are useful for analytics and verification of your data.  Also note the month specification.  This Postgres interval is something you'll use often in queries. <br><br><h1>  Work with dates </h1><br>  Intervals are a good combination for working with dates in Postgres.  For example, if you want to know the date today which will be in a week: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'1 week'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a_week_from_now; a_week_from_now <span class="hljs-comment"><span class="hljs-comment">------------------------------- 2015-03-03 10:08:12.156656+01 (1 row)</span></span></code> </pre><br>  Postgres sees <b>now ()</b> as a timestamp and uses the ( <b>+</b> ) operator to convert the string '1 week' as an interval.  The result <i>12015-05-06 17: 59: 30.587874</i> was interesting. <br>  This will tell me the current date and time down to the millisecond.  And also the timezone (+1 which is now in Italy) If you have ever struggled with dates in UTC, then you know that this is a big pain.  Postgres has a built-in timestamptz data type (representing a time zone label) and the conversion will take place automatically when the date is calculated. <br>  For example, I want to ask Postgres what time in California: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'PDT'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cali_time; cali_time <span class="hljs-comment"><span class="hljs-comment">---------------------------- 2015-02-24 02:16:57.884518 (1 row)</span></span></code> </pre><br>  Returns the interval difference between two timesamp.  At 2 AM it is better not to call Jon Galloway to say that his SQL server is on fire.  Let's see how many hours between me and John: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'PDT'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cali_diff; cali_diff <span class="hljs-comment"><span class="hljs-comment">----------- 08:00:00 (1 row)</span></span></code> </pre><br>  Note that it returns a value with an 8 hours mark, which is not an integer.  Why is this important? Time is a relative thing; it is very important to know the time zone of your server when calculating data depending on time.  For example, in my Takepub database I wrote down when orders were placed.  If 20 orders came at the end of the year, my accountant wanted to know which orders came earlier or later than January 1, 2013.  My server is in New York. My company is registered in Hawaii. <br><br>  These important things in Postgres: handlers and many other functions for working with dates are pretty enjoyable. <br><br><h1>  Aggregation </h1><br>  Dealing with aggregation and aggregation in Postgres can be tedious because it is very, very standards compliant.  You can always be sure that the GROUP BY is not important in your SELECT statement.  If you want to see the sales for the month, grouped for the week, you need to run the following queries: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sku, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price), date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> invoice_items <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sku,date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) <span class="hljs-keyword"><span class="hljs-keyword">having</span></span> date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) = <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  This is a bit of an extreme syntax, use a better Postgres future - window functions: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> sku, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> invoice_items <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) = <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  The same data, but too much less (window functions are also available on the SQL server). <br>  Here I am making a set based on the calculations, indicating that I want to run the SUM function on the data section for this row.  If you did not specify DISTINCT here, the query would have issued all the sales as if we simply indicated a SELECT query. <br>  Excellent opportunity to use window functions together with aggregating ones: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> sku, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> revenue, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sales_count <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> invoice_items <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) = <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  Gives me the number of monthly sales calculated by the field sku and revenues.  I can also display total sales per month in the following column: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> sku, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> revenue, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sales_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sales_total <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> invoice_items <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) = <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  I use PARTITTION BY 0, thus saying that I need to use the ‚Äúentire section set‚Äù it will output all sales in September ... And by combining this inclusion in the CTE ( <a href="http://rob.conery.io/2015/02/09/inserting-using-new-record-postgres/">a Common Table Expression</a> ) I can run some interesting calculations: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> september_sales <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> sku, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> revenue, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sku) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sales_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(price) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sales_total <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> invoice_items <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date_part(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,created_at) = <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sku, revenue::money, sales_count, sales_total::money, trunc((revenue/sales_total * <span class="hljs-number"><span class="hljs-number">100</span></span>),<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> percentage <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> september_sales</code> </pre><br>  In the final select, select the revenue fields and sales_total as money type - it will be beautifully formatted with a currency symbol.  Quite a comprehensive sales request - I get the total sku, the number of sales and the percentage of sales per month, it turns out pretty simple SQL.  I use trunc CTE to round up to 4-digit numbers, because the result in percent can be quite long. <br><br><h1>  Strings </h1><br>  I showed you some charms over the Regex.  But much more you can do over the lines in Postgres.  Consider a query that I use quite often: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title, downloads.list_order, downloads.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> episode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> downloads.product_id = products.id <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku, downloads.list_order;</code> </pre><br>  The request receives all my videos and individual episodes (called downloads). I could use this request on pages that are displayed to the user.  But what if you want to summarize the episodes?  I can use some aggregation functions for this.  The simplest example is a comma-separated string of names: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title, string_agg(downloads.title, <span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> downloads.product_id = products.id <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku, products.title <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku</code> </pre><br>  string_agg works like String.join () in your favorite language.  But we can do better by combining through concat and then into an array: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title, array_agg(<span class="hljs-keyword"><span class="hljs-keyword">concat</span></span>(downloads.list_order,<span class="hljs-string"><span class="hljs-string">') '</span></span>,downloads.title)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> downloads.product_id = products.id <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku, products.title <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku</code> </pre><br>  Here I use array_agg pulling data from list_order and title to combine downloads into a table and the output is an array. <br><br>  I use the concat function to combine the list_order. <br>  If you use Node.Js at the output, you can immediately run through it with an iterator. <br>  Also using Node, you can use JSON: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> products.sku, products.title, json_agg(downloads) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> products <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> downloads <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> downloads.product_id = products.id <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku, products.title <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> products.sku</code> </pre><br>  Where I show the relations of the boot bits (ie Child Records) with fields which I can easily work on the client with an array of JSON. <br><br><h1>  findings </h1><br>  If you know SQL not very well - especially as your favorite DBMS implements it - use this week to get to know it better.  This is a very powerful tool for your application to work: your data. </div><p>Source: <a href="https://habr.com/ru/post/258153/">https://habr.com/ru/post/258153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258137/index.html">Wi-Fi CO2 meter on ESP8266 + K-30</a></li>
<li><a href="../258139/index.html">What to expect when you expect a child: PHP 7, part 2</a></li>
<li><a href="../258145/index.html">Forget the SAR theorem as no longer relevant.</a></li>
<li><a href="../258147/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ160 (May 11 - 17, 2015)</a></li>
<li><a href="../258151/index.html">5 tools to help analyst</a></li>
<li><a href="../258155/index.html">Energia Launchpad wireless electronic lock</a></li>
<li><a href="../258157/index.html">Audio playback on Intel Edison via Bluetooth using the Advanced Audio Distribution Profile (A2DP)</a></li>
<li><a href="../258159/index.html">Install OpenCV 3.0.0-rc1 (using IPP and TBB) on Intel Edison Yocto. USB camera in OpenCV</a></li>
<li><a href="../258163/index.html">Using the Intel Edison board to change the color of the Orbotix Sphero ball when new tweets appear</a></li>
<li><a href="../258165/index.html">How we do landings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>