<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Attempts to make learning path finding algorithms easier.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Path finding algorithms are an integral part of game development. As well as various navigation systems, orientation and much more. But we will focus ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Attempts to make learning path finding algorithms easier.</h1><div class="post__text post__text-html js-mediator-article">  Path finding algorithms are an integral part of game development.  As well as various navigation systems, orientation and much more.  But we will focus on the gaming industry and the algorithms that are used in it. <br><br>  Each game developer is faced with a task in which it is necessary to force a character (or bot) to pass from one point to another, without having collected all the walls.  And strategy developers still need to take into account the permeability of cells (roads, swamps, forests, and so on).  This is where path finding algorithms come to the rescue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/78a/208/0b578a20808152ba8b2065fe6903c560.png" alt="image"><br><a name="habracut"></a><br><h3>  What for? </h3><br>  From the foregoing, we can conclude that any game developer will sooner or later have to face and deal with finding a path, and later modify and optimize it for their own projects.  And since so many newbies go to GameDev right away, it‚Äôs not always easy for them to read several articles and understand one or another algorithm.  This post describes the attempts to create software that will help ease the process of understanding the principles of operation of path finding algorithms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  A few words about the basic algorithms </h3><br>  We will consider 3 basic algorithms.  Now briefly about each of the main algorithms and screenshots of the visualization of their work in the program (slightly ahead of the event). <br><br><h4>  Dijkstra's Algorithm </h4><br>  Developed by the Netherlands scientist Edsger Dijkstra in 1959.  The algorithm will check each of the vertices of the graph until it finds the shortest path to the original vertex.  More details can be read, for example, <a href="https://habrahabr.ru/post/111361/">here</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/099/0b5/fbe/0990b5fbe1cbe56d472197f4c601e49a.png" alt="image"><br><br><h4>  A * (A Star) </h4><br>  This algorithm was first described in 1968 by Peter Hart, Nils Nilson and Bertram Rafael.  When considering each individual vertex, the transition is made to that neighboring vertex, the supposed path from which to the desired vertex is the shortest. <br>  You can start learning <a href="http://www.policyalmanac.org/games/aStarTutorial_rus.htm">here</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dab/9a1/36f/dab9a136fa8c54c8f36a8cf35b393936.png" alt="image"><br><br><h4>  Jump Point Search </h4><br>  This algorithm was introduced in 2011 by D. Harbor and A. Grastien.  JPS speeds up the search for a path by "jumping over" many places that need to be viewed.  ‚ÄúJump points‚Äù allow speeding up the path finding algorithm, considering only the ‚Äúnecessary‚Äù nodes.  The working principle <a href="https://habrahabr.ru/post/162915/">here is</a> very well explained. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/f1a/d91/ff9f1ad91302d14d2125760bfa120bf1.png" alt="image"><br><br><h3>  Slight reservation </h3><br>  It is worth noting that the <a href="http://weblog.jamisbuck.org/2011/1/27/maze-generation-growing-tree-algorithm">Growing Tree</a> generator, also presented in the program, creates a ‚Äúclassic maze‚Äù as in the picture below (only bigger), the height and width in the settings are then set specifically for it.  This generator was added to create a ‚ÄúWow effect‚Äù for a beginner and to demonstrate the path built by the most basic algorithms (Rule of the right or left hand, DFS), in the post I will not stop here and focus on manual mode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7d/c68/286/e7dc682861ac9dc2f74fea2f366b69e2.png" alt="image"><br><br><h3>  Search base - checkered field </h3><br>  The search works on a graph, the easiest to create a graph from a map is to <s>arrange the waypoints to</s> translate the map into a checkered field.  Since the goal is to facilitate understanding of the basics, we are going to work with square cells. <br><br>  First we need to determine the class of the cell.  The user should be able to set the input, output and put impassable obstacles on the field, also for studying it is useful to know the characteristics of the cell, its parent and status right during the operation of the algorithm.  As a result, we get the presented class (I removed the set-, get-functions to save space): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Status{ Click, Unclick, Enter, Exit, NoStatus }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ListStatus {NoList, InClosed, InOpen}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsCell</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QGraphicsRectItem { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GraphicsCell(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *, QGraphicsItem *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pressButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buttonID)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QPoint pos)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> upd)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight = INT_MAX; Status status; ListStatus listStatus; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *isEnter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *isExit; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> visited; GraphicsCell *par; QGraphicsRectItem *infoBox; };</code> </pre> <br>  The pressButton and updateStatus functions handle changing the status and color of a cell.  And showInfo and deleteInfo for infobox, about which further.  The variables x and y are responsible for the coordinates;  f, g, h, weight for the characteristics required for the search algorithms, status and listStatus for <br>  cell status, isEnter and isExit, whether there is an input and output on the card, par beyond the parent cell (necessary to restore the constructed path). <br><br><h3>  Work with field </h3><br>  We have created a checkered field, now it would be good to give the user the opportunity to apply the entrance and exit, arrange the walls and call the aforementioned infobox. <br><br>  Fortunately, the QGraphicsView class from the Qt framework, on which we create the interface, provides us with virtual functions of clicking, double clicking and moving the cursor (mousePressEvent, doubleClickEvent, mouseMoveEvent, respectively).  We also overload them in a class of a scene which contains our cells. <br><br>  The checkPos function checks that the cursor is over the cell object. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MazeWindow::mousePressEvent(QMouseEvent *event) { checkPos(event); GraphicsCell *currCell = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;GraphicsCell *&gt;(scene()-&gt;itemAt(mapFromGlobal(cursor().pos()), QTransform())); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currCell == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startStatus == Status::NoStatus) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currCell-&gt;status == Status::Click) startStatus = Status::Click; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startStatus = Status::Unclick; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::RightButton) { currCell-&gt;showInfo(mapFromGlobal(cursor().pos())); cellWithInfo = currCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> currCell-&gt;pressButton(event-&gt;button()); }</code> </pre> <br>  The implementation of the click function.  We determine by which cell we clicked and ask it to update its status.  Infobox had to be installed on PCM, since in Qt, when using a double click, the normal click function is first called and this caused the cell to flicker (we updated the cell state with a single click and returned it back when we realized that the click was double). <br><br>  The input is set to 'Ctrl + LKM', and the output to the mouse wheel or to the touchpad 'Alt + LKM'.  Conveniently enough.  The wall is installed ordinary paintwork. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MazeWindow::mouseMoveEvent(QMouseEvent *event) { checkPos(event); GraphicsCell *currCell = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;GraphicsCell *&gt;(scene()-&gt;itemAt(mapFromGlobal(cursor().pos()), QTransform())); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currCell == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellWithInfo != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; currCell != cellWithInfo) { cellWithInfo-&gt;deleteInfo(); cellWithInfo = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currCell-&gt;status == Status::Enter || currCell-&gt;status == Status::Exit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;buttons() &amp; Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startStatus == Status::Click &amp;&amp; currCell-&gt;status == Status::Click) currCell-&gt;updateStatus(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startStatus == Status::Unclick &amp;&amp; currCell-&gt;status == Status::Unclick) currCell-&gt;updateStatus(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br>  I also wanted to allow the user to draw the walls, as it was done in the usual graphic editors, holding the LMB and driving across the field. <br><br>  To do this, overload the mouseMoveEvent () function.  We check that we are above the cells, and we ask you to update the state of the cell under the cursor.  If we start drawing from an empty cell, then we will continue to draw the walls, if we have erased the wall, then we will continue in the eraser mode.  The function is still responsible for removing the infobox if we remove the cursor from the cell where it was called. <br><br>  Create the infobox as a regular rectangle, which shows the characteristics of weight, F, G, H (if you are familiar with the algorithms presented above, you know these notations), the current status of the cell and its parent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37b/13d/492/37b13d492f58f1c9967de627f31b6b76.png" alt="image"><br><br>  Everything, we provided the field for visualization, half of the complex work was done, hurray! <br><br><h3>  Visualization of the course of work on the search path </h3><br>  The most interesting part of the program is what should turn a boring (or not so) article into something: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc9/9fa/3aa/cc99fa3aa55351b3a7cc395ecb2fa4e6.gif" alt="image"><br><br>  There is also a step-by-step mode, which, in conjunction with infoboxes, will help you to understand 100% of the operation of each algorithm. <br><br>  Now a few words about how it was implemented.  For example, consider the function of the algorithm AStar, the other algorithms are implemented similarly.  We will also leave the signal from the button to the function itself. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MazeWindow::ASolve(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mode) { currMode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ,    if (aL != NULL) scene()-&gt;removeItem(aL); clearLabyr(); a = new A(&amp;labyr); a-&gt;solveMaze(0); } if (mode == 0) { while (!a-&gt;solveMaze(1)); // updatePictureSolve(Algorithms::AStarAlgo); currMode = 1; return true; } else { if (a-&gt;solveMaze(1)) { // updatePictureSolve(Algorithms::AStarAlgo); QMessageBox msgBox; msgBox.setText(tr("Sucsess")); msgBox.setIcon(QMessageBox::Information); msgBox.exec(); currMode = 1; return true; } } return false; }</span></span></code> </pre> <br>  We implemented step-by-step mode and complete solution with one function, so you have to transfer mode IDs (0 is a complete solution and 1 is for the next step).  Further, if this is a complete solution or the first step in a step-by-step procedure, we clear the field of the remnants of the previous solution, clean up the cell status and update the characteristics using the clearLabyr function.  The functions of the algorithms themselves are implemented in such a way that they return true if the end point of the search is reached or the search cannot continue, and false if it is possible to continue working.  Therefore, for a complete solution with the while operator, we call the function until it returns true and plot the line of the path on the scene by calling the updatePictureSolve function.  For step-by-step mode, we call the function with each click, if the path is found, we also send it to the drawing and display a message so that the user does not accidentally click the solution point. <br><br>  The search algorithms themselves update the status of cells when they are entered into an open or closed list. <br><br><h3>  Control Panel </h3><br>  The program includes: <br><br><ul><li>  Two types of generators: <a href="http://weblog.jamisbuck.org/2011/1/27/maze-generation-growing-tree-algorithm">Growing Tree</a> and manual mode (check field mentioned above) </li><li>  Five types of algorithms: DFS and <a href="http://myrobot.ru/articles/logo_mazesolving.php">search by hand rule</a> for Generator Growing Tree, as well as Dijkstra, AStar, JPS for manual mode. </li></ul><br>  It was necessary to allow the user to conveniently switch between the named options.  The result of the <s>great design</s> work was a small panel of the menu in the workspace, which can be hidden and called through the toolbar.  It is possible to change the colors of the path line by clicking on the color field.  <s>(if you don't like my taste)</s> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b8/772/87f/1b877287f7fb5a3ca2733aa7676c5af2.png" alt="image"><br><br><h3>  Work with statistics </h3><br>  The program can also be used to select the most efficient algorithm for this situation: <br><br><ul><li>  Approximately draw the necessary map, it turns out something like in the picture </li><li>  We start all 3 algorithms, by eye we estimate work. </li></ul><br><div class="spoiler">  <b class="spoiler_title">What approximately can turn out</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/369/129/ca63691292b744fc1501ebe887012a49.png" alt="image"><br></div></div><br>  It is obvious that for more or less serious projects "by eye" is not enough, so you need to display statistics. <br><br>  We will do this in the form of a widget with a brief statistics of the current algorithm in the workspace and a separate window displaying the work of all the algorithms for the session and allowing you to create a report that can be copied, for example, in Excel, to build graphs there. <br><br>  Implementing a widget with brief statistics is very much like implementing a widget with settings, and it looks almost the same: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17e/e8c/83a/17ee8c83a5348a849b0486e0c3aba809.png" alt="image"><br><br>  The algorithm itself calculates the number of operations.  The length of the path can be learned from the characteristics of the exit cell, and we consider time as timers, subtracting the time spent on drawing (although this is not very accurate).  When the algorithm finishes, it passes the statistics to the widget and calls the function to create a record in the table.  As a result, has the following table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c8/19a/0e6/7c819a0e67fc0072b63c26c3c75f15b1.png" alt="image"><br>  It should be said separately why A * and Dextra have the same results, while JPS has excellent results.  This is due to the fact that 2 different methods for calculating distances between cells are used: A * and Dijkstra use the cost of vertical and horizontal transition 10 and diagonal 14, and then divide the total result by 10;  JPS uses 1 and sqrt (2), respectively, and divides nothing, but also rounds.  JPS shows the path length somewhat more precisely, which is why the numbers are different. <br><div class="spoiler">  <b class="spoiler_title">After processing the data, you can get something like this:</b> <div class="spoiler_text">  <i>For such a situation:</i> <br><img src="https://habrastorage.org/getpro/habr/post_images/499/1f4/12a/4991f412aea9e1397eed678d0ec22af7.png" alt="image"><br><br>  <i>This schedule:</i> <br><img src="https://habrastorage.org/getpro/habr/post_images/6ea/f10/ca8/6eaf10ca8b014709539bdac3fb3365ff.png" alt="image"><br></div></div><br><h3>  Conclusion </h3><br>  We got a program that helps beginners, and not only programmers to understand the path finding algorithms.  At least I did help a couple of my friends) <br><br>  The author will be happy to listen to your wishes and fulfill them as soon as he writes the exams. <br>  Perhaps a series of improvements will lead to the fact that we will get a powerful library with algorithms, and the program will become a pleasant demo for it (Like <a href="https://qiao.github.io/PathFinding.js/visual/">PathFinding.js</a> , only better). <br><br>  If you might like to write an article about finding a path, you can attach this program to it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/9f6/a19/98b9f6a19b7a889a7cb109213f1630e5.png" alt="image"><br><br>  ‚Üí Experienced research material: <a href="https://qiao.github.io/PathFinding.js/visual/">PathFinding.js</a> <br>  ‚Üí Download the archive with the program can be from the <a href="https://yadi.sk/d/s20hYX6R3FT6nM">poison</a> or with <a href="">DropBox</a> . <br>  UPD: initially, by mistake, a not fully debugged version was published, now everything is ok.  I apologize.  03/14/2017 (yes, for about 4 days, the downloaded version hung: C) <br>  ‚Üí Source project VS2013: POISON and <a href="">Dropbox</a> </div><p>Source: <a href="https://habr.com/ru/post/323650/">https://habr.com/ru/post/323650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323638/index.html">Direction Finder on Augmented Reality</a></li>
<li><a href="../323640/index.html">Hacker put up for sale 640 thousand stolen user accounts PlayStation</a></li>
<li><a href="../323644/index.html">Another new feature pg_filedump: restore the PostgreSQL directory</a></li>
<li><a href="../323646/index.html">Potential vulnerabilities eliminated by the PVS-Studio team this week: release N1</a></li>
<li><a href="../323648/index.html">Battle drone, completely yours. We teach gaming AI method busting strategies</a></li>
<li><a href="../323652/index.html">Security Week 10: DNS remote control, how Google deceived its captcha, a hole in the Wordpress plugin</a></li>
<li><a href="../323654/index.html">Make changes to the code little by little</a></li>
<li><a href="../323656/index.html">NeoQuest 2017: Reverse android apps in the task ‚ÄúRepair the Leader!‚Äù</a></li>
<li><a href="../323658/index.html">US intelligence agencies are attacking vendors. Now MikroTik. Patch is already available</a></li>
<li><a href="../323660/index.html">When the ‚Äúcloud‚Äù breaks down: what can be done in this situation?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>