<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another side of the moon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing applications, one of the most important issues is memory consumption and responsiveness (speed). 

 It is considered that the garbage col...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another side of the moon</h1><div class="post__text post__text-html js-mediator-article">  When writing applications, one of the most important issues is memory consumption and responsiveness (speed). <br><br>  It is considered that the garbage collector is a black box whose work cannot be foreseen. <br><br>  And they say that GC in .NET is practically not customizable.  And also, that it is impossible to look at the sources of both the .NET Framework classes, and the CLR, GC, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And I will say no matter how! <br><br>  In this article we will consider: <br><ul><li>  structure of the organization of the placement of objects in memory </li><li>  <b>CLR 4.5 Background Server GC</b> </li><li>  correct setting of the garbage collector </li><li>  effective upgrade of applications to .NET 4.0+ </li><li>  proper manual memory management </li></ul><br><a name="habracut"></a><br><h3>  <font color="SandyBrown">‚ñå</font> Structure of the organization of the placement of objects in memory </h3><br>  Once I already <a href="http://habrahabr.ru/post/136609/">wrote</a> about determining the size of CLR-objects.  In order not to retell the article, let's just remember the main points. <br><br>  For variable reference types, when using the CIL instruction <b>newobj</b> or, for example, the <b>new</b> operator in C #, a fixed-size value is placed on the stack (4 bytes, for example, for x86, the DWORD type) containing the address of an instance of an object created in the regular heap (do not forget that the managed heap is divided into Small Object Heap and Large Object Heap - more on this later in the paragraph about GC).  So, in C ++, this value is called a pointer to an object, and in the .NET world, a reference to an object. <br><br>  The link lives on the stack when executing any method, or lives in the field of a class. <br><br>  You cannot create an object in a vacuum without creating a link. <br>  To avoid speculations about the size of objects and carrying out any tests using <a href="http://msdn.microsoft.com/en-us/library/bb190764.aspx">SOS (Son of Strike)</a> , measuring GC.TotalMemory, etc.  - just look at the CLR sources, or rather <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D4917">Shared Source Common Language Infrastructure 2.0</a> , which is a kind of research project. <br><br>  Each type has its own MethodTable, and all instances of objects of the same type refer to the same MethodTable.  This table stores information about the type itself (interface, abstract class, etc.). <br><br>  Each object contains two additional fields ‚Äî the object header, in which the <b>SyncTableEntry</b> address (syncblk entry) is stored, and the Method Table Pointer (TypeHandle). <br><br>  <b>SyncTableEntry</b> is a structure that stores a link to a CLR object and a link to SyncBlock itself. <br><br>  <b>SyncBlock</b> is a data structure that stores a hash code for any object. <br><br>  Saying ‚Äúfor any‚Äù means that the CLR initializes a certain number of SyncBlocks in advance.  Then, when calling GetHashCode () or Monitor.Enter (), the environment simply inserts a pointer to the already-ready SyncBlock into the object's header, simultaneously calculating the hash code. <br><br>  This is done by calling the <b>GetSyncBlock</b> method (see the <code>%  %\sscli20\clr\src\vm\syncblk.cpp)</code> file <code>%  %\sscli20\clr\src\vm\syncblk.cpp)</code> .  In the body of the method we can see the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bits &amp; BIT_SBLK_IS_HASHCODE) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { DWORD hashCode = bits &amp; MASK_HASHCODE; syncBlock-&gt;SetHashCode(hashCode); }</code> </pre><br><br>  The System.Object.GetHashCode method relies on the SyncBlock structure by calling the <b>SyncBlock :: GetHashCode</b> method. <br><br>  The initial syncblk value is 0 for CLR 2.0, but since CLR 4.0 the value is -1. <br><br>  When you call Monitor.Exit (), syncblk becomes -1 again. <br><br>  I would also like to note that the SyncBlock array is stored in a <b>separate</b> memory, <b>inaccessible by the</b> GC. <br><br>  How so?  You ask. <br><br>  The answer is simple - weak links.  The CLR creates a weak reference to an entry in the SyncBlock array.  When the CLR object dies, SyncBlock is updated. <br><br>  The implementation of the Monitor.Enter () method depends on the platform and the JIT itself.  So the pseudonym for this method in the SSCLI source is <b>JIT_MonEnter</b> . <br><br>  Returning to the topic of placing objects in memory and their sizes, I would like to recall that any instance of an object (empty class) takes up at least 12 bytes in x86, and in x64 it is already 24 bytes. <br><br>  Verify this without running SOS. <br><br>  Go to the file <code>%  %\sscli20\clr\src\vm\object.h</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MIN_OBJECT_SIZE (2*sizeof(BYTE*) + sizeof(ObjHeader)) class Object { protected: MethodTable* m_pMethTab; }; class ObjHeader { private: DWORD m_SyncBlockValue; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// the Index and the Bits };</span></span></span></span></code> </pre><br><br>  In the comments to the article about the size of CLR-objects I was accused of inaccurate calculation of the size of System.String without any evidence. <br><br>  However, I trust the numbers and ... the source code! <br><br>  System.String in .NET 4.0 consists of the following members: <br><ul><li>  m_firstChar </li><li>  m_stringLength </li><li>  Empty </li></ul><br><img src="https://habrastorage.org/storage2/4c6/5c3/5b3/4c65c35b3cc3c734a16cc657c0216dd3.png" alt="image"><br><br>  Empty we do not take into account, since  This is an empty static string. <br>  m_stringLength specifies the length of the string. <br><br>  m_firstChar is a <b>pointer</b> (!!!) to the beginning of storage of an array of Unicode characters, and <b>not the</b> first character in the array. <br><br>  No magic is used here - the CLR simply finds an offset. <br><br>  To make sure of this, again open the% folder with the archive% \ sscli20 \ clr \ src \ vm \ object.h <br><br>  At the very beginning of the file we see the comments to the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * StringObject - String objects are specialized objects for string * storage/retrieval for higher performance */</span></span></code> </pre><br><br>  This is the internal storage structure of string data. <br><br>  Next we find the class <b>StringObject</b> and its method GetBuffer (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WCHAR* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LEAF_CONTRACT; _ASSERTE(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (WCHAR*)( PTR_HOST_TO_TADDR(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + offsetof(StringObject, m_Characters) ); }</code> </pre><br><br>  Well, the buffer (also an array of characters) is simply calculated by offset. <br><br>  But what about the System.String itself? <br><br>  Open the file% folder with the archive% \ sscli20 \ clr \ src \ bcl \ system \ string.cs <br><br>  We see the following lines: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//NOTE NOTE NOTE NOTE //These fields map directly onto the fields in an EE StringObject. See object.h for the layout. // [NonSerialized]private int m_stringLength; [NonSerialized]private char m_firstChar;</span></span></code> </pre><br><br>  However, System.String in its work relies on COMString, which implements the constructor itself, as well as many methods (PadLeft, etc.). <br>  To correctly match the names of the methods from the framework and internal C ++ implementations, I advise you to look at the <code>%  %\sscli20\clr\src\vm\ecall.cpp</code> <br>  Well, to finally make sure that m_firstChar is a <b>pointer</b> , consider, for example, part of the code of the Join method: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = &amp;text.m_firstChar) { UnSafeCharBuffer unSafeCharBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnSafeCharBuffer(ptr, num); unSafeCharBuffer.AppendString(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>[startIndex]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = startIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= num2; j++) { unSafeCharBuffer.AppendString(separator); unSafeCharBuffer.AppendString(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>[j]); } }</code> </pre><br><br>  A slightly different <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/04/05/of-memory-and-strings.aspx">version of</a> the calculation (but with the same <a href="http://habrahabr.ru/post/136609/">results</a> ) leads the famous Jon Skeet. <br><br>  Before moving forward, I would like to remember about the stack. <br>  A stack is a container created by the environment on every call to any method.  It stores all the data needed to complete the call (local variable addresses, parameters, etc.). <br><br>  Thus, calls to the call tree are a FIFO container consisting of stacks.  When the call to the current method is completed, the stack is cleared and destroyed, returning control to the parent branch. <br><br>  As I wrote above, for variable reference types, a fixed-size value is placed on the stack (4 bytes, for example, for x86, type DWORD), which contains the address of an instance of an object created in a regular heap. <br><br>  By default, instances of primitive types that are not involved in boxing are placed on the stack. <br><br>  However, with some optimizations, JIT- can immediately locate the values ‚Äã‚Äãof variables in the processor registers, bypassing RAM. <br><br>  Recall what a processor register is - a block of memory cells that forms ultra-fast RAM inside the processor, used by the processor itself and for the most part inaccessible to the programmer. <br><br>  The larger the CPU cache, the better performance you can get, regardless of the software platform. <br><br><h3>  <font color="DeepSkyBlue">‚ñå</font> GC device </h3><br><br>  As you know, memory management (creating and destroying objects) is done by the garbage collector - aka Garbage Collector (GC). <br><br>  For the CLR application to work, it immediately initializes two segments of the virtual address space - the Small Object Heap and the Large Object Heap. <br><br>  A quick note: virtual memory is a logical representation of memory, not a physical one.  Physical memory is allocated only as needed.  Each process in a modern operating system is allocated a virtual address space of the maximum addressable size (4GB for 32-bit OS) with division into pages (for x86, IA-64, PowerPC-64 platforms, the minimum size is 4KB, SPARC - 8 KB).  Due to this, it becomes possible to isolate the address space of one process from another, and it also becomes possible to use swap on the disk. <br><br>  To allocate and return memory to the system, the GC uses the Win32 functions of <b>VirtualAlloc</b> and <b>VirtualFree</b> . <br><br>  The garbage collector in .NET is generational, i.e.  managed pile (respectively, and objects) is divided into generations.  All objects are divided by life cycle into several generations. <br><br>  The source of references to objects is the so-called GC roots: <br><ul><li>  stack </li><li>  static (global) objects </li><li>  finalizable objects </li><li>  unmanaged interop objects (CLR objects participating in COM / unmanaged calls) </li><li>  processor registers </li><li>  other CLR objects with links </li></ul><br>  In this case, there are 3 generations: <br><ul><li>  <b>Generation 0</b> .  The life cycle of objects of this generation is the shortest.  Gen0 usually refers to temporary variables created in the body of methods. </li><li>  <b>Generation 1</b> .  The life cycle of objects of this generation is also short.  This includes objects with an intermediate lifetime - objects moving from Gen0 to Gen2. </li><li>  <b>Generation 2</b> .  It is the most long-lived objects.  Also, objects larger than 85,000 bytes automatically fall into the Large Object Heap and are marked as Gen2. </li></ul><br>  The initial size of each segment (SOH, LOH) varies and depends on the specific machine (usually 16 MB for the desktop and 64 MB for the server).  I want to note that this is <b>virtual</b> memory - an application can take up altogether 5 MB of <b>physical</b> memory. <br><br>  Object LOH includes not only objects larger than 85,000 bytes, but also some types of arrays. <br><br>  So an array from System.Double with a size of 10,600 elements (85,000 / 8 bytes) should fall into LOH.  However, this happens at a rate of 1000+. <br><br>  The objects in the managed heap are arranged one after the other, which can result in fragmentation if a large number of objects are deleted. <br><br>  However, to solve this problem, the CLR will <b>always</b> (with the exception of manual memory management) defragment the Small Object Heap. <br><br>  The process is as follows: the current objects are copied to free memory (spaces in the heap, which automatically disappear). <br><br>  Thus, the minimum memory consumption is achieved, but it also requires a certain CPU time.  However, this should not worry, because  for Gen0, Gen1 objects, the delay is only <b>1 ms</b> . <br><br>  What about the Large Object Heap?  It is never defragmented (almost never).  This would require a large amount of time, which may have a bad effect on the operation of the application.  However, this does not mean that the CLR begins to consume more and more memory just like that.  During Full-GC (Gen0, Gen1, Gen2), the system still returns the OS memory, freeing itself from already dead objects from LOH (or defragmenting SOH). <br><br>  The CLR also places new objects in LOH not only one after the other, as in SOH, for example, but also in places with already free memory, without waiting for Full-GC. <br>  The launch of GC is not deterministic, except for calling the GC.Collect () method. <br><br>  However, there are still approximate criteria by which it can be predicted (remember that the following conditions are approximate and the CLR adapts itself to the behavior of the application, much still depends on the type of garbage collector): <br><ul><li>  When Gen0 generation size reaches 256 KB </li><li>  When Gen1 generation size reaches 2 MB </li><li>  When Gen2 generation size is 10 MB </li></ul><br>  Also, garbage collection starts when there is a shortage of system memory.  The CLR uses the Win32 functions <b>CreateMemoryResourceNotification</b> and <b>QueryMemoryResourceNotification</b> for this. <br><br>  Another point when working with memory is the use of unmanaged resources. <br><br>  Because  unmanaged resources can contain any objects, regardless of the duration of life and the GC is not deterministic, then for these purposes there is a finalizer. <br><br>  When the application starts, the CLR finds types with finalizers and excludes them from normal garbage collection (but this does not mean that objects are not tied to generations). <br><br>  After the GC finishes its work, the objects being finalized are processed in a separate thread (method call Finalize). <br><br>  An example of the implementation of the Dispose pattern: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; ~Foo() { Dispose(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Dispose(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); GC.SuppressFinalize(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_disposed) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { <span class="hljs-comment"><span class="hljs-comment">// Free managed objects } // Free unmanaged objects _disposed = true; } } }</span></span></code> </pre><br><br>  Now consider the GCs themselves, available in the .NET Framework. <br><br>  Before the release of .NET 4.0, there were two Server and Workstation modes available. <br><br>  Workstation mode - GC is optimized to run on client machines.  It tries not to particularly load the processor, and also works with minimal delays for applications with UI.  Available in two modes - parallel and synchronous. <br><br>  In parallel mode, the GC runs in a separate stream (with normal priority) for the Gen2 generation, while blocking the work of ephemeral generations (allocation of new objects is not possible, all threads are suspended). <br><br>  If the application is available very (!!!) a lot of free memory, then SOH does not become compact (GC sacrifices memory, for the sake of application responsiveness). <br><br>  Thus, Workstation mode is ideal for GUI applications. <br><br>  In addition, if you need to use server-side GC, then you can enable it like this: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gcServer</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  For verification, you can use the GCSettings.IsServerGC property in your code. <br><br>  To force a shutdown of Workstation Concurrent GC, use the following parameters: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gcConcurrent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  By default, parallel mode is enabled for Workstation GC.  However, if the processor is single core, then the GC automatically goes into synchronous mode. <br><br>  Consider now Server GC. <br><br>  Server GC divides the managed heap into segments, the number of which is equal to the number of <b>logical</b> processors, using one thread to process each of them. <br><br>  Small note: the logical processor does not necessarily correspond to the physical processor.  Systems with multiple physical processors (i.e., multiple sockets) and multi-core processors provide the OS with many logical processors, and the core (!!!) can also be more than 1 logical processor (for example, using Intel's hyper-threading technology). <br><br>  Also one of the main differences is the <b>GCSettings.LatencyMode</b> property, available with the .NET Framework 3.5 SP1 (consisting of three modes). <br><br>  By default, LatencyMode for Workstation Concurrent GC is installed as Interactive, Server - Batch. <br><br>  There is also a LowLatency, but using it can lead to an OutOfMemoryException, since  in this mode GC Full garbage collection occurs only in case of high memory load.  Also, it cannot be enabled for Server GC. <br><br>  What is the difference between Batch and Interactive? <br><br>  Because  Server GC divides the managed heap into several segments (each of which serves a separate logical processor), then there is no longer a need for parallel garbage collection (if another thread was started on another logical processor).  This mode forcibly overrides the gcConcurrent parameter.  If gcConcurrent mode is enabled, Batch mode will prevent further parallel garbage collection (!!!).  Batch is equivalent to non-parallel garbage collection on a workstation.  When using this mode, the processing of large (!!!) data volumes is typical. <br><br>  It should be remembered that changing the value of GCLatencyMode affects the current running threads, which means the impact on the execution environment itself and unmanaged code. <br><br>  And since  Since threads can run on different logical processors, there is no guarantee of instantaneous transfer of GC mode. <br>  And what if another thread wants to change this value.  And if flows 100? <br><br>  Feel that a problem is brewing for a multi-threaded application?  And especially for the CLR - an exception may be caused in the environment itself, and not in the application code. <br><br>  For such cases, there is a constrained execution region (CER) - a guarantee of handling all exceptions (both synchronous and asynchronous). <br>  In a block of code marked as CER, the runtime environment is prohibited from throwing some asynchronous exceptions. <br><br>  For example, when calling Thread.Abort (), the stream executed under CER will not be interrupted until the execution of the CER-protected code is completed. <br>  Also, the CLR prepares the CER during initialization to ensure operation even in the event of low memory. <br><br>  It is recommended not to use CER for large areas of code, since  There are a number of restrictions for this kind of code: boxing, calling virtual methods, calling methods through reflection, using Monitor.Enter, etc. <br><br>  But let's not delve into this matter and see how to safely switch the LatencyMode mode. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldMode = GCSettings.LatencyMode; System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { GCSettings.LatencyMode = GCLatencyMode.Batch; <span class="hljs-comment"><span class="hljs-comment">//       } finally { GCSettings.LatencyMode = oldMode; }</span></span></code> </pre><br>  Well, we have already reviewed the main part of the GC work in .NET - no questions have arisen? <br><br>  Definitely not?  And even nothing embarrassed? <br><br>  Hmm ... didn‚Äôt the question about the impossibility of allocating new objects in ephemeral generations in any way interested? <br><br>  But the .NET command - yes :) <br><br>  Now we have a new Background GC available for Workstation mode (starting with .NET 4.5 and for Server). <br><br>  The purpose of its creation was to reduce delays with Full-GC, in particular Gen2. <br><br>  Background GC is the same Concurrent GC, with one exception - with Full-GC, ephemeral generations are not blocked for allocation of new objects. <br><br>  Agree that handling Gen2 and LOH is very expensive.  And blocking Gen0, Gen1 - i.e.  The normal operation of the application may cause delays (in certain situations). <br><br>  Another question addressed by the new GC is the postponement of the allocation of new objects when the size limit of the managed heap is reached (16 MB - desktop, 64 - server). <br><br><img src="http://habrastorage.org/storage2/d06/8b1/e18/d068b1e18d46e92b012c7e46b46ee60d.png"><br><br>  Now, to prevent such a situation, not only the background thread for Gen2, but also the foreground thread (yes, we also have Foreground GC), which marks dead objects from ephemeral generations and combines current ephemeral generations with Gen2 (because Merging is a less expensive operation than copying and transfers them to background thread processing, thereby allowing memory to be allocated for new objects (I remind you that in Background GC Gen0, Gen1 are not blocked while GC is working for Gen2). <br><br><img src="http://habrastorage.org/storage2/e5c/dc0/2c3/e5cdc02c3d04b61ce5c89ee0e36b3152.png"><br><br>  Reducing the number of delays can be compared on the chart below: <br><br><img src="http://habrastorage.org/storage2/394/0e7/6c9/3940e76c9539b1779b0e5eb94990c8a2.png"><br><br><h3>  <font color="#F39">‚ñå</font> Manual memory management </h3><br>  One of the most interesting and unusual features of the CLR and, in particular, C # is manual memory management, i.e.  work with pointers. <br><br>  In general, this is the third type in .NET - Pointer Type.  It is a DWORD address for a specific instance of either Value Type.  Those.  Reference Types are not available to us. <br><br>  But we can also work with unmanaged code. <br><br>  For such purposes, a System.Runtime.InteropServices.GCHandle structure has been created - objects with a fixed address that provide access to the managed object from unmanaged memory. <br><br>  For GCHandle, the CLR uses a separate table for each AppDomain. <br>  GCHandle is destroyed when GCHandle.Free () is called, or when the AppDomain is unloaded. <br><br>  To create a method is used GChandle.Alloc (). <br>  The following allocation modes are available: <br><ul><li>  Normal </li><li>  Weak </li><li>  Weak track resurrection </li><li>  Pinned </li></ul><br>  Learn more about GCHandle - <a href="http://msdn.microsoft.com/en-us/library/83y4ak54.aspx">MSDN</a> . <br><br>  When you may need to work with memory, you ask? <br><br>  For example, to copy an array of bytes. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sourceOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* pSource = source, pTarget = target) { <span class="hljs-comment"><span class="hljs-comment">// Set the starting points in source and target for the copying. byte* ps = pSource + sourceOffset; byte* pt = pTarget + targetOffset; // Copy the specified number of bytes from source to target. for (int i = 0; i &lt; count; i++) { *pt = *ps; pt++; ps++; } } }</span></span></code> </pre><br><br> ,  GC  SOH?             SOH. <br><br>     ( .NET     ‚Äî    ).     ‚Äì  . <br><br><h3> <font color="slateBlue">‚ñå</font>     ||    .NET 4.0+ </h3><br> ,   .NET 2.0,             .NET 4.0. <br><br><img src="http://habrastorage.org/storage2/035/7c7/710/0357c771012c83172be02ddf1bce08f5.png"><br><br> [ <a href="http://msdn.microsoft.com/en-us/library/bb822049(v%3Dvs.110).aspx">.NET Framework Versions and Dependencies</a> ] <br><br>     .NET 1.1,   ,   ,    2.0. <br><br> .NET 3.5   CLR 2.0,   2.0 +   3.0 + 3.5.     , ,    ..  . <br><br>  .NET 4.0    : <br><ul><li>  CLR </li><li>  GC </li><li>      </li><li>  Thread Pool </li><li>    </li></ul><br>   CLR 2.0   CLR 4.0    : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">startup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">supportedRuntime</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"v4.0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sku</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NETFramework,Version=v4.0"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">startup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>     : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NetFx40_LegacySecurityPolicy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>   SEH- ,          : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">legacyCorruptedStateExceptionsPolicy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">runtime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>         , : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">startup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">useLegacyV2RuntimeActivationPolicy</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">supportedRuntime</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"v4.0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sku</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NETFramework,Version=v4.0"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">startup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  ,            .NET 4.0. <br><br><h3> <font color="limeGreen">‚ñå</font>   || FastCall </h3><br>  ,   JIT ‚Äì ,    VC++,   ‚Äì FastCall. <br><br>     ,    ECX, EDX   2  . <br><br>   x64 ‚Äì   RCX, RDX, R8, R9. <br>    ? <br><br> ,   -         (   ,   ). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Compute(startIndex, endIndex, x, y); Console.WriteLine(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startIndex; i &lt; endIndex; i++) { result += x * startIndex + y * endIndex; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br><br>      startIndex  endIndex      ECX, EDX,  (x, y)  . <br><br>  ‚Äì    . <br><br>          <code>CTRL + D, R</code> . <br><br><img src="http://habrastorage.org/storage2/93b/bce/0a4/93bbce0a4ddbc46bc93f8d649996b92e.png"><br><br>     <code>CTRL + ALT + D</code> . <br><br><img src="http://habrastorage.org/storage2/9f9/5a5/32d/9f95a532d742ee0f843767270ab033c9.png"><br><br><hr><br> ,     ! <br><br>  Thanks for attention! <br></div><p>Source: <a href="https://habr.com/ru/post/149584/">https://habr.com/ru/post/149584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149578/index.html">8 successful freelance years, tips and tricks</a></li>
<li><a href="../149580/index.html">Small QCoreApplication speed test</a></li>
<li><a href="../149581/index.html">Context binding (this) to a function in javascript and partial application of functions</a></li>
<li><a href="../149582/index.html">Ruby NoName Podcast S04E15</a></li>
<li><a href="../149583/index.html">Why cloud computing should switch to open source</a></li>
<li><a href="../149586/index.html">Perl - Deploy again</a></li>
<li><a href="../149589/index.html">Clear addresses of profiles have appeared on Google+, but only for favorites.</a></li>
<li><a href="../149590/index.html">Why not Drupal?</a></li>
<li><a href="../149591/index.html">IM + Paranoia Mode On</a></li>
<li><a href="../149592/index.html">The list of "rakes" of websocket implementation to the client web resources of site designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>