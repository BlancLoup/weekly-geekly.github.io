<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of the algorithm A *</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of my introduction to the A * algorithm . In it, I showed how wide the search is implemented, Dijkstra's algorithm, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">ğŸ”</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">ğŸ“œ</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">â¬†ï¸</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">â¬‡ï¸</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of the algorithm A *</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/3a8/810/442/3a8810442f124277a2a6d38536ea534a.png"><br><br>  This article is a continuation of my <a href="https://habrahabr.ru/post/331192/">introduction to the A * algorithm</a> .  In it, I showed how wide the search is implemented, Dijkstra's algorithm, the greedy search for the best first match, and A *.  I tried to simplify the explanation as much as possible. <br><br>  Graph search is a family of similar algorithms.  There are <i>many</i> variations of algorithms and their implementations.  Treat the code of this article as a starting point, and not the final version of the algorithm, suitable for all situations. <br><a name="habracut"></a><br><h2>  1. Implementation in Python </h2><br>  Below I will explain most of the code.  The <a href="http://www.redblobgames.com/pathfinding/a-star/implementation.py">implementation.py</a> file is somewhat wider.  The code uses <b>Python 3</b> , so if you are using Python 2, you will need to change the <code>super()</code> call and the <code>print</code> function with analogues from Python 2. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1.1 Search in width </h3><br>  Let's implement a wide Python search.  The first article shows the Python code for the search algorithm, but we also need to determine the graph with which we will work.  Here are the abstractions I use: <br><br>  <b>Count</b> : a data structure that can report the neighbors of each point (see <a href="http://www.redblobgames.com/pathfinding/grids/graphs.html">this tutorial</a> ) <br><br>  <b>Points (locations)</b> : a simple value (int, string, tuple, etc.) marking the points in the graph <br><br>  <b>Search</b> : an algorithm that receives a graph, a starting point and (optionally) an endpoint that calculates useful information (visited, a pointer to the parent element, a distance) for some or all of the points <br><br>  <b>Queue</b> : data structure used by the search algorithm to select the order in which the points are processed. <br><br>  In the first article, I mainly looked at the <b>search</b> .  In this article I will explain everything else necessary to create a fully working program.  Let's start with the <b>graph</b> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleGraph</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.edges = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.edges[id]</code> </pre> <br>  Yes, and that's all we need!  You may ask: where is the Node object?  Answer: I rarely use the node object.  It seems to me more simple to use integers, strings or tuples as points, and then use arrays or hash tables to take points as indices. <br><br>  Notice that the edges have a <i>direction</i> : we may have an edge from A to B, but there may not be an edge from B to A. In game cards, the edges are mostly bi-directional, but sometimes there are one-way doors or jumping from ledges, which are designated as directional edges.  Let's create an example of a graph where the <b>points</b> will be denoted by the letters AE. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e9/956/f83/7e9956f837f4a80173aa64148827f927.png"><br><br>  For each point you need a list of points to which it leads: <br><br><pre> <code class="python hljs">example_graph = SimpleGraph() example_graph.edges = { <span class="hljs-string"><span class="hljs-string">'A'</span></span>: [<span class="hljs-string"><span class="hljs-string">'B'</span></span>], <span class="hljs-string"><span class="hljs-string">'B'</span></span>: [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>], <span class="hljs-string"><span class="hljs-string">'C'</span></span>: [<span class="hljs-string"><span class="hljs-string">'A'</span></span>], <span class="hljs-string"><span class="hljs-string">'D'</span></span>: [<span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>], <span class="hljs-string"><span class="hljs-string">'E'</span></span>: [<span class="hljs-string"><span class="hljs-string">'B'</span></span>] }</code> </pre> <br>  Before using the search algorithm, we need to set the <b>queue</b> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> collections <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.elements = collections.deque() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.elements) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.elements.append(x) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.elements.popleft()</code> </pre> <br>  This queue class is simply a wrapper around the built-in <code>collections.deque</code> class.  In your code, you can use <code>deque</code> directly. <br><br>  Let's try using our example graph with this queue and a wide search code from the previous article: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">breadth_first_search_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, start)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,    frontier = Queue() frontier.put(start) visited = {} visited[start] = True while not frontier.empty(): current = frontier.get() print("Visiting %r" % current) for next in graph.neighbors(current): if next not in visited: frontier.put(next) visited[next] = True breadth_first_search_1(example_graph, 'A')</span></span></code> </pre> <br> <code>Visiting 'A' <br> Visiting 'B' <br> Visiting 'C' <br> Visiting 'D' <br> Visiting 'E'</code> <br> <br>  Grids can also be expressed as graphs.  Now I define a new <b>graph</b> <code>SquareGrid</code> , with a tuple (int, int) <b>points</b> .  Instead of storing the edges explicitly, we will compute them as <code>neighbors</code> . <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquareGrid</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> self.width = width self.height = height self.walls = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in_bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id)</span></span></span><span class="hljs-function">:</span></span> (x, y) = id <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &lt; self.width <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &lt; self.height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.walls <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id)</span></span></span><span class="hljs-function">:</span></span> (x, y) = id results = [(x+<span class="hljs-number"><span class="hljs-number">1</span></span>, y), (x, y<span class="hljs-number"><span class="hljs-number">-1</span></span>), (x<span class="hljs-number"><span class="hljs-number">-1</span></span>, y), (x, y+<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + y) % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: results.reverse() <span class="hljs-comment"><span class="hljs-comment">#   results = filter(self.in_bounds, results) results = filter(self.passable, results) return results</span></span></code> </pre> <br>  Let's check it on the first grid from the previous article: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * g = SquareGrid(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) g.walls = DIAGRAM1_WALLS <span class="hljs-comment"><span class="hljs-comment">#  long, [(21, 0), (21, 2), ...] draw_grid(g)</span></span></code> </pre> <br> <code>. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . ##########. . . . <br> . . . ####. . . . . . . . ####. . . . . . ##########. . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . .</code> <br> <br>  To recreate the paths, we need to save the point from which we came, so I renamed <code>visited</code> (True / False) to <code>came_from</code> (point): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">breadth_first_search_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, start)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  "came_from" frontier = Queue() frontier.put(start) came_from = {} came_from[start] = None while not frontier.empty(): current = frontier.get() for next in graph.neighbors(current): if next not in came_from: frontier.put(next) came_from[next] = current return came_from g = SquareGrid(30, 15) g.walls = DIAGRAM1_WALLS parents = breadth_first_search_2(g, (8, 7)) draw_grid(g, width=2, point_to=parents, start=(8, 7))</span></span></code> </pre> <br> <code>â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† â† ####â†’ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† â† â† ####â†’ â†’ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†‘ â†‘ ####â†’ â†“ â†“ â†“ â†“ â†“ â†“ â† ####â†‘ â† â† â† â† â† ####â†’ â†’ â†’ â†“ â†“ â†“ â†“ <br> â†‘ â†‘ â†‘ ####â†’ â†’ â†“ â†“ â†“ â†“ â† â† ####â†‘ â†‘ â† â† â† â† ##########â†“ â†“ â†“ â† <br> â†‘ â†‘ â†‘ ####â†’ â†’ â†’ â†“ â†“ â† â† â† ####â†‘ â†‘ â†‘ â† â† â† ##########â†“ â†“ â† â† <br> â†‘ â†‘ â†‘ ####â†’ â†’ â†’ A â† â† â† â† ####â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†’ â†’ â†‘ â†‘ â†‘ â† â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† <br> â†’ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† <br> â†’ â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† <br> â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† <br> â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â†</code> <br> <br>  In some implementations, by creating a Node object, <i>internal storage is used</i> to store <code>came_from</code> and other values â€‹â€‹for each node of the graph.  Instead, I decided to use <i>external storage</i> by creating a single table of hashes for storing <code>came_from</code> all nodes of the graph.  If you know that the points of your map have integer indices, then there is another option - use the array for storing the <code>came_from</code> . <br><br><h3>  1.2 Early exit </h3><br>  Repeating the code of the previous article, we just need to add the <i>if</i> construct to the main loop.  This check is optional for a wide search and Dijkstra algorithm, but is required for a greedy search for the best first match and A *: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">breadth_first_search_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, start, goal)</span></span></span><span class="hljs-function">:</span></span> frontier = Queue() frontier.put(start) came_from = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> came_from: frontier.put(next) came_from[next] = current <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> came_from g = SquareGrid(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) g.walls = DIAGRAM1_WALLS parents = breadth_first_search_3(g, (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>), (<span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) draw_grid(g, width=<span class="hljs-number"><span class="hljs-number">2</span></span>, point_to=parents, start=(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br> <code>. â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† . . . . ####. . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† . . . ####. . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† Z . . . ####. . . . . . . <br> â†’ â†’ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† . . ####. . . . . . . <br> . â†‘ â†‘ ####â†’ â†“ â†“ â†“ â†“ â†“ â†“ â† ####â†‘ â† â† . . . ####. . . . . . . <br> . . â†‘ ####â†’ â†’ â†“ â†“ â†“ â†“ â† â† ####â†‘ â†‘ . . . . ##########. . . . <br> . . . ####â†’ â†’ â†’ â†“ â†“ â† â† â† ####â†‘ . . . . . ##########. . . . <br> . . . ####â†’ â†’ â†’ A â† â† â† â† ####. . . . . . . . . . . . . . . <br> . . . ####â†’ â†’ â†‘ â†‘ â†‘ â† â† â† ####. . . . . . . . . . . . . . . <br> . . â†“ ####â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† ####. . . . . . . . . . . . . . . <br> . â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† ####. . . . . . . . . . . . . . . <br> â†’ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> . â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . .</code> <br> <br>  As we can see, the algorithm stops when it finds a target <code>Z</code> <br><br><h3>  1.3 Dijkstra's Algorithm </h3><br>  This adds complexity to the algorithm, because we will start processing the points in an improved order, and not just â€œfirst entered, first out.â€  What principle will we use? <br><br><ol><li>  <i>Count</i> need to know the cost of movement. </li><li>  <i>Queues</i> need to return nodes in a different order. </li><li>  <i>The search</i> should track this value in the graph and transfer it to the queue. </li></ol><br><h4>  1.3.1 Weights Graph </h4><br>  I'm going to add the <code>cost(from_node, to_node)</code> function <code>cost(from_node, to_node)</code> , which tells us the cost of moving from <code>from_node</code> to its neighbor <code>to_node</code> .  In this forest map, I decided that movement would depend only on <code>to_node</code> , but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement using both nodes</a> .  An alternative to the implementation will be to merge it into the function <code>neighbors</code> . <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridWithWeights</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SquareGrid)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> super().__init__(width, height) self.weights = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, from_node, to_node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.weights.get(to_node, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h4>  1.3.2 Priority Queue </h4><br>  The priority queue associates with each element a number called a â€œpriorityâ€.  When returning an item, it selects the item with the lowest number. <br><br>  <b>insert</b> : adds an item to the queue <br><br>  <b>remove</b> : removes the element with the smallest number <br><br>  <b>reprioritize</b> : (optional) changes the priority of an existing item to a lower number. <br><br>  Here is a fairly fast priority queue that uses a <i>binary heap</i> , but does not support reprioritize.  To get the correct order, we use a tuple (priority, element).  When you insert an item that is already in the queue, we get a duplicate.  I will explain why this suits us in the â€œOptimizationâ€ section. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> heapq <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PriorityQueue</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.elements = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.elements) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item, priority)</span></span></span><span class="hljs-function">:</span></span> heapq.heappush(self.elements, (priority, item)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> heapq.heappop(self.elements)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><h4>  1.3.3 Search </h4><br>  There is a tricky moment of implementation: since we add the cost of movement, there is the likelihood of re-visiting a point with a better <code>cost_so_far</code> .  This means that the line <code>if next not in came_from</code> will not work.  Instead, we need to check whether the cost has decreased since the last visit.  (In the original version of the article, I did not check it, but my code still worked. <a href="http://www.redblobgames.com/pathfinding/posts/reprioritize.html">I wrote notes about this error</a> .) <br><br>  This map with the forest is taken from the <a href="https://habrahabr.ru/post/331192/">previous article</a> . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstra_search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, start, goal)</span></span></span><span class="hljs-function">:</span></span> frontier = PriorityQueue() frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>) came_from = {} cost_so_far = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): new_cost = cost_so_far[current] + graph.cost(current, next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cost_so_far <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> new_cost &lt; cost_so_far[next]: cost_so_far[next] = new_cost priority = new_cost frontier.put(next, priority) came_from[next] = current <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> came_from, cost_so_far</code> </pre> <br>  After the search you need to build a path: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reconstruct_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(came_from, start, goal)</span></span></span><span class="hljs-function">:</span></span> current = goal path = [current] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> current != start: current = came_from[current] path.append(current) path.append(start) <span class="hljs-comment"><span class="hljs-comment">#  path.reverse() #  return path</span></span></code> </pre> <br>  Although the ways are better perceived as a sequence of edges, it is more convenient to store as a sequence of nodes.  To create the path, let's start from the end and follow the <code>came_from</code> map pointing to the previous node.  When we reach the beginning, it's done.  This is the <b>return</b> path, so at the end of <code>reconstruct_path</code> we call <code>reverse()</code> if we need to store it in a direct sequence.  In fact, it is sometimes more convenient to store the path in reverse.  In addition, it is sometimes convenient to keep the starting node in the list. <br><br>  Let's try: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * came_from, cost_so_far = dijkstra_search(diagram4, (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)) draw_grid(diagram4, width=<span class="hljs-number"><span class="hljs-number">3</span></span>, point_to=came_from, start=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)) print() draw_grid(diagram4, width=<span class="hljs-number"><span class="hljs-number">3</span></span>, number=cost_so_far, start=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)) print() draw_grid(diagram4, width=<span class="hljs-number"><span class="hljs-number">3</span></span>, path=reconstruct_path(came_from, start=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)))</code> </pre> <br> <code>â†“ â†“ â† â† â† â† â† â† â† â† <br> â†“ â†“ â† â† â† â†‘ â†‘ â† â† â† <br> â†“ â†“ â† â† â† â† â†‘ â†‘ â† â† <br> â†“ â†“ â† â† â† â† â† â†‘ â†‘ . <br> â†’ A â† â† â† â† . . . . <br> â†‘ â†‘ â† â† â† â† . . . . <br> â†‘ â†‘ â† â† â† â† â† . . . <br> â†‘ #########â†‘ â† â†“ . . . <br> â†‘ #########â†“ â†“ â†“ Z . . <br> â†‘ â† â† â† â† â† â† â† â† . <br> <br> 5 4 5 6 7 8 9 10 11 12 <br> 4 3 4 5 10 13 10 11 12 13 <br> 3 2 3 4 9 14 15 12 13 14 <br> 2 1 2 3 8 13 18 17 14 . <br> 1 A 1 6 11 16 . . . . <br> 2 1 2 7 12 17 . . . . <br> 3 2 3 4 9 14 19 . . . <br> 4 #########14 19 18 . . . <br> 5 #########15 16 13 Z . . <br> 6 7 8 9 10 11 12 13 14 . <br> <br> . . . . . . . . . . <br> . . . . . . . . . . <br> . . . . . . . . . . <br> . . . . . . . . . . <br> @ @ . . . . . . . . <br> @ . . . . . . . . . <br> @ . . . . . . . . . <br> @ #########. . . . . . <br> @ #########. . @ @ . . <br> @ @ @ @ @ @ @ . . .</code> <br> <br>  The <code>if next not in cost_so_far or new_cost &lt; cost_so_far[next]</code> can be simplified to <code>if new_cost &lt; cost_so_far.get(next, Infinity)</code> , but I didnâ€™t want to explain <code>get()</code> Python in the last article, so I left it as it is.  You can also use <code>collections.defaultdict</code> with a default infinity value. <br><br><h3>  1.4 Search A * </h3><br>  And the greedy search for the best first match, and A * use a heuristic function.  The only difference is that A * uses both heuristics and ordering from the Dijkstra algorithm.  Here I will show A *. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heuristic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> (x1, y1) = a (x2, y2) = b <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> abs(x1 - x2) + abs(y1 - y2) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a_star_search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, start, goal)</span></span></span><span class="hljs-function">:</span></span> frontier = PriorityQueue() frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>) came_from = {} cost_so_far = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): new_cost = cost_so_far[current] + graph.cost(current, next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cost_so_far <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> new_cost &lt; cost_so_far[next]: cost_so_far[next] = new_cost priority = new_cost + heuristic(goal, next) frontier.put(next, priority) came_from[next] = current <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> came_from, cost_so_far</code> </pre> <br>  Let's try: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * came_from, cost_so_far = a_star_search(diagram4, (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)) draw_grid(diagram4, width=<span class="hljs-number"><span class="hljs-number">3</span></span>, point_to=came_from, start=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)) print() draw_grid(diagram4, width=<span class="hljs-number"><span class="hljs-number">3</span></span>, number=cost_so_far, start=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), goal=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>))</code> </pre> <br> <code>. . . . . . . . . . <br> . â†“ â†“ â†“ . . . . . . <br> â†“ â†“ â†“ â†“ â† . . . . . <br> â†“ â†“ â†“ â† â† . . . . . <br> â†’ A â† â† â† . . . . . <br> â†’ â†‘ â† â† â† . . . . . <br> â†’ â†‘ â† â† â† â† . . . . <br> â†‘ #########â†‘ . â†“ . . . <br> â†‘ #########â†“ â†“ â†“ Z . . <br> â†‘ â† â† â† â† â† â† â† . . <br> <br> . . . . . . . . . . <br> . 3 4 5 . . . . . . <br> 3 2 3 4 9 . . . . . <br> 2 1 2 3 8 . . . . . <br> 1 A 1 6 11 . . . . . <br> 2 1 2 7 12 . . . . . <br> 3 2 3 4 9 14 . . . . <br> 4 #########14 . 18 . . . <br> 5 #########15 16 13 Z . . <br> 6 7 8 9 10 11 12 13 . .</code> <br> <br><h4>  1.4.1 Straightened paths </h4><br>  If you implement this code in your own project, you may find that some of the paths are not as â€œstraightâ€ as we would like.  <b>This is normal</b> .  When using <i>grids</i> , and especially grids, in which each step has the same cost of movement, you will get <b>equal options</b> : many ways have exactly the same value.  A * selects one of many shortcuts, and very often <b>it does not look very nice</b> .  You can use a fast hack, <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">eliminating equivalent options</a> , but it is not always fully suitable.  It would be better to <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">change the map view</a> , which will make A * much faster and create more direct and pleasant paths.  However, this is suitable for static maps in which each step has one movement cost.  For the demo on my page I use a fast hack, but it only works with my slow priority queue.  If you switch to a faster priority queue, you will need another quick hack. <br><br><h2>  2 Implementation in C ++ </h2><br>  Note: to perform part of the example code, add <a href="">redblobgames / pathfinding / a-star / implementation.cpp</a> .  I use <b>C ++ 11</b> for this code, so if you are using an older version of the C ++ standard, you will have to partially change it. <br><br><h3>  2.1 Search in width </h3><br>  First read the section on Python.  In this section there will be a code, but there will not be the same explanations.  First we add the general class of the graph: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleGraph</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> L Location; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt;::iterator iterator; <span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Location, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; &gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; neighbors(Location id) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edges[id]; } };</code> </pre> <br>  and the same example of a graph from Python code that uses <code>char</code> to mark points: <br><br><img src="http://www.redblobgames.com/pathfinding/a-star/implementation-example-graph.png" alt="image"><br><br><pre> <code class="cpp hljs">SimpleGraph&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; example_graph {{ {<span class="hljs-string"><span class="hljs-string">'A'</span></span>, {<span class="hljs-string"><span class="hljs-string">'B'</span></span>}}, {<span class="hljs-string"><span class="hljs-string">'B'</span></span>, {<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>}}, {<span class="hljs-string"><span class="hljs-string">'C'</span></span>, {<span class="hljs-string"><span class="hljs-string">'A'</span></span>}}, {<span class="hljs-string"><span class="hljs-string">'D'</span></span>, {<span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>}}, {<span class="hljs-string"><span class="hljs-string">'E'</span></span>, {<span class="hljs-string"><span class="hljs-string">'B'</span></span>}} }};</code> </pre> <br>  Instead of defining the queue class, we use the class from the standard C ++ library.  Now we can try a wider search: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Graph&gt; void breadth_first_search(Graph graph, typename Graph::Location start) { typedef typename Graph::Location Location; queue&lt;Location&gt; frontier; frontier.push(start); unordered_set&lt;Location&gt; visited; visited.insert(start); while (!frontier.empty()) { auto current = frontier.front(); frontier.pop(); std::cout &lt;&lt; "Visiting " &lt;&lt; current &lt;&lt; std::endl; for (auto&amp; next : graph.neighbors(current)) { if (!visited.count(next)) { frontier.push(next); visited.insert(next); } } } } int main() { breadth_first_search(example_graph, 'A'); }</span></span></span></span></code> </pre> <br> <code>Visiting A <br> Visiting B <br> Visiting C <br> Visiting D <br> Visiting E</code> <br> <br>  The code is slightly longer than in Python, but this is quite normal. <br><br>  What about squares grids?  I will define another class of the graph.  Notice that it is not related to the previous class of the graph.  I use patterns, not inheritance.  The graph should only provide a typedef <code>Location</code> and a <code>neighbors</code> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquareGrid</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Location; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Location, 4&gt; DIRS; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, height; <span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;Location&gt; walls; SquareGrid(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width_, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height_) : width(width_), height(height_) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in_bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Location id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; tie (x, y) = id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt; width &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt; height; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Location id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !walls.count(id); } <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; neighbors(Location id) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, dx, dy; tie (x, y) = id; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; results; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dir : DIRS) { tie (dx, dy) = dir; <span class="hljs-function"><span class="hljs-function">Location </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x + dx, y + dy)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (in_bounds(next) &amp;&amp; passable(next)) { results.push_back(next); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x + y) % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      std::reverse(results.begin(), results.end()); } return results; } }; array&lt;SquareGrid::Location, 4&gt; SquareGrid::DIRS {Location{1, 0}, Location{0, -1}, Location{-1, 0}, Location{0, 1}};</span></span></code> </pre> <br>  In the auxiliary <code>implementation.cpp</code> file, I defined a function for grid drawing: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> int main() { SquareGrid grid = make_diagram1(); draw_grid(grid, 2); }</span></span></code> </pre> <br> <code>. . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . . . . . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . . . . . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . ####. . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . ##########. . . . <br> . . . ####. . . . . . . . ####. . . . . . ##########. . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . ####. . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . . <br> . . . . . . . . . . . . . ####. . . . . . . . . . . . . . .</code> <br> <br>  Let's do a wider search again by tracking <code>came_from</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Graph&gt; unordered_map&lt;typename Graph::Location, typename Graph::Location&gt; breadth_first_search(Graph graph, typename Graph::Location start) { typedef typename Graph::Location Location; queue&lt;Location&gt; frontier; frontier.push(start); unordered_map&lt;Location, Location&gt; came_from; came_from[start] = start; while (!frontier.empty()) { auto current = frontier.front(); frontier.pop(); for (auto&amp; next : graph.neighbors(current)) { if (!came_from.count(next)) { frontier.push(next); came_from[next] = current; } } } return came_from; } int main() { SquareGrid grid = make_diagram1(); auto parents = breadth_first_search(grid, std::make_tuple(7, 8)); draw_grid(grid, 2, nullptr, &amp;parents); }</span></span></span></span></code> </pre> <br> <code>â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† â† ####â†’ â†“ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†’ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† â† â† ####â†’ â†’ â†“ â†“ â†“ â†“ â†“ <br> â†’ â†‘ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† ####â†‘ â† â† â† â† â† ####â†’ â†’ â†’ â†“ â†“ â†“ â†“ <br> â†‘ â†‘ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â† â† ####â†‘ â†‘ â† â† â† â† ##########â†“ â†“ â†“ â† <br> â†‘ â†‘ â†‘ ####â†’ â†“ â†“ â†“ â†“ â† â† â† ####â†‘ â†‘ â†‘ â† â† â† ##########â†“ â†“ â† â† <br> â†“ â†“ â†“ ####â†’ â†’ â†“ â†“ â† â† â† â† ####â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†’ â†’ * â† â† â† â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†’ â†‘ â†‘ â†‘ â† â† â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† â† <br> â†“ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† â† <br> â†’ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† â† <br> â†’ â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† â† <br> â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â† â† <br> â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† â† â†</code> <br> <br>  In some implementations, <i>internal storage is used</i> and a Node object is created to store <code>came_from</code> and other values â€‹â€‹for each node of the graph.  I chose to use <i>external storage</i> , creating a single <code>std::unordered_map</code> for storing <code>came_from</code> for all nodes of the graph.  If you know that the points of your map have integer indices, then there is another option - use a one-dimensional or two-dimensional array / vector to store <code>came_from</code> and other values. <br><br><h4>  2.1.1 TODO: struct points </h4><br>  In this code, I use <code>std::tuple</code> C ++, because I used tuples in my Python code.  However, the tuples are unfamiliar to most C ++ programmers.  It will be a little longer to define a struct with {x, y}, because you need to define a constructor, a copy constructor, an assignment operator, and an equality comparison along with a hash function, but such code will be more <i>familiar to</i> most C ++ programmers.  You will need to change it. <br><br>  Another option (I use it in my code) is to encode {x, y} as an <code>int</code> .  T If the A * code always has a dense set of integer-valued values â€‹â€‹instead of arbitrary <code>Location</code> types, this allows for additional optimizations.  You can use arrays for different sets, not hashes tables.  You can leave most of them uninitialized.  For those arrays that need to be initialized anew each time, you can make them permanent for A * calls (possibly using local stream storage) and reinitialize only those parts of the array that were used in the previous call.  This is a more complicated technique that I do not want to use in the tutorial of the initial level. <br><br><h3>  2.2 Early exit </h3><br>  As in the Python version, we just need to add a parameter to the function and check the main loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Graph&gt; unordered_map&lt;typename Graph::Location, typename Graph::Location&gt; breadth_first_search(const Graph&amp; graph, typename Graph::Location start, typename Graph::Location goal) { typedef typename Graph::Location Location; queue&lt;Location&gt; frontier; frontier.push(start); unordered_map&lt;Location, Location&gt; came_from; came_from[start] = start; while (!frontier.empty()) { auto current = frontier.front(); frontier.pop(); if (current == goal) { break; } for (auto&amp; next : graph.neighbors(current)) { if (!came_from.count(next)) { frontier.push(next); came_from[next] = current; } } } return came_from; } int main() { SquareGrid grid = make_diagram1(); auto parents = breadth_first_search(grid, SquareGrid::Location{8, 7}, SquareGrid::Location{17, 2}); draw_grid(grid, 2, nullptr, &amp;parents); }</span></span></span></span></code> </pre> <br> <code>. â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† . . . . ####. . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† . . . ####. . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† . . . ####. . . . . . . <br> â†’ â†’ â†‘ ####â†“ â†“ â†“ â†“ â†“ â†“ â†“ â†“ â† â† â† â† â† â† . . ####. . . . . . . <br> . â†‘ â†‘ ####â†’ â†“ â†“ â†“ â†“ â†“ â†“ â† ####â†‘ â† â† . . . ####. . . . . . . <br> . . â†‘ ####â†’ â†’ â†“ â†“ â†“ â†“ â† â† ####â†‘ â†‘ . . . . ##########. . . . <br> . . . ####â†’ â†’ â†’ â†“ â†“ â† â† â† ####â†‘ . . . . . ##########. . . . <br> . . . ####â†’ â†’ â†’ * â† â† â† â† ####. . . . . . . . . . . . . . . <br> . . . ####â†’ â†’ â†‘ â†‘ â†‘ â† â† â† ####. . . . . . . . . . . . . . . <br> . . â†“ ####â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â† â† ####. . . . . . . . . . . . . . . <br> . â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â† ####. . . . . . . . . . . . . . . <br> â†’ â†“ â†“ ####â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> â†’ â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> â†’ â†’ â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . . <br> . â†’ â†’ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ ####. . . . . . . . . . . . . . .</code> <br> <br><h3>  2.3 Dijkstraâ€™s Algorithm </h3><br><h4>  2.3.1 Weights Count </h4><br>  We have a grid with a list of forest tiles, the cost of movement on which is 5. In this forest map, I decided to perform movement only depending on <code>to_node</code> , but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement using both nodes</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridWithWeights</span></span></span><span class="hljs-class">:</span></span> SquareGrid { <span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;Location&gt; forests; GridWithWeights(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h): SquareGrid(w, h) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Location from_node, Location to_node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> forests.count(to_node) ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } };</code> </pre> <br><h4>  2.3.2 Priority Queue </h4><br>  We need a priority queue.  In C ++, there is a <code>priority_queue</code> class that uses a binary heap, but without a priority change operation.  I use a pair (priority, element) for the elements of the queue to get the correct order.  By default, the C ++ priority queue first returns the maximum element using the <code>std::less</code> comparator.  We need a minimal element, so I use the <code>std::greater</code> comparator. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">priority_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PriorityQueue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">priority_t</span></span>, T&gt; PQElement; priority_queue&lt;PQElement, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PQElement&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::greater&lt;PQElement&gt;&gt; elements; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elements.empty(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">priority_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ elements.emplace(priority, item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T best_item = elements.top().second; elements.pop(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_item; } };</code> </pre> <br>  In this example code, I wrap the C ++ <code>std::priority_queue</code> , but I think it would be wise to use this class without a wrapper. <br><br><h4>  2.3.3 Search </h4><br>  See the <a href="https://habrahabr.ru/post/331192/">map with the forest from the previous article</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstra_search</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph&amp; graph, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location&gt;&amp; came_from, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; cost_so_far)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph::Location Location; PriorityQueue&lt;Location, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; frontier; frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>); came_from[start] = start; cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!frontier.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> current = frontier.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; next : graph.neighbors(current)) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> new_cost = cost_so_far[current] + graph.cost(current, next); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cost_so_far.count(next) || new_cost &lt; cost_so_far[next]) { cost_so_far[next] = new_cost; came_from[next] = current; frontier.put(next, new_cost); } } } }</code> </pre> <br>  The types of <code>cost</code> variables must match the types used in the graph.  If you use <code>int</code> , you can use <code>int</code> for variable values â€‹â€‹and priorities in the priority queue.  If you use <code>double</code> , then you also need to use <code>double</code> for them.  In this code, I used <code>double</code> , but <code>int</code> could also be used, and the code would work just the same.  However, if the cost of the graph edges is stored in double or double is used in heuristics, then double should be used here. <br><br>  And finally, after the search you need to build a path: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Location&gt; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; reconstruct_path( Location start, Location goal, <span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Location, Location&gt;&amp; came_from ) { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Location&gt; path; Location current = goal; path.push_back(current); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { current = came_from[current]; path.push_back(current); } path.push_back(start); <span class="hljs-comment"><span class="hljs-comment">//  std::reverse(path.begin(), path.end()); return path; }</span></span></code> </pre> <br>  Although the paths are better seen as a sequence of edges, it is convenient to store them as a sequence of nodes.  To build the path, let's start from the end and follow the <code>came_from</code> map pointing to the previous node.  The process will end when we reach the beginning.  This is a <b>return</b> path, so if you want to store it in a direct form, then at the end of <code>reconstruct_path</code> you need to call <code>reverse()</code> .  Sometimes it is more convenient to store the path in reverse.  Sometimes it is also useful to keep the starting node in the list. <br><br>  Let's try: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> int main() { GridWithWeights grid = make_diagram4(); SquareGrid::Location start{1, 4}; SquareGrid::Location goal{8, 5}; unordered_map</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SquareGrid::Location, SquareGrid::Location&gt; came_from; unordered_map&lt;SquareGrid::Location, double&gt; cost_so_far; dijkstra_search(grid, start, goal, came_from, cost_so_far); draw_grid(grid, 2, nullptr, &amp;came_from); std::cout &lt;&lt; std::endl; draw_grid(grid, 3, &amp;cost_so_far, nullptr); std::cout &lt;&lt; std::endl; vector&lt;SquareGrid::Location&gt; path = reconstruct_path(start, goal, came_from); draw_grid(grid, 3, nullptr, nullptr, &amp;path); }</span></span></span></span></code> </pre> <br> <code>â†“ â†“ â† â† â† â† â† â† â† â† <br> â†“ â†“ â† â† â† â†‘ â†‘ â† â† â† <br> â†“ â†“ â† â† â† â† â†‘ â†‘ â† â† <br> â†“ â†“ â† â† â† â† â† â†‘ â†‘ â† <br> â†’ * â† â† â† â† â† â†’ â†‘ â† <br> â†‘ â†‘ â† â† â† â† . â†“ â†‘ . <br> â†‘ â†‘ â† â† â† â† â† â†“ â† . <br> â†‘ ######â†‘ â† â†“ â†“ â† . <br> â†‘ ######â†“ â†“ â†“ â† â† â† <br> â†‘ â† â† â† â† â† â† â† â† â† <br> <br> 5 4 5 6 7 8 9 10 11 12 <br> 4 3 4 5 10 13 10 11 12 13 <br> 3 2 3 4 9 14 15 12 13 14 <br> 2 1 2 3 8 13 18 17 14 15 <br> 1 0 1 6 11 16 21 20 15 16 <br> 2 1 2 7 12 17 . 21 16 . <br> 3 2 3 4 9 14 19 16 17 . <br> 4 #########14 19 18 15 16 . <br> 5 #########15 16 13 14 15 16 <br> 6 7 8 9 10 11 12 13 14 15 <br> <br> . @ @ @ @ @ @ . . . <br> . @ . . . . @ @ . . <br> . @ . . . . . @ @ . <br> . @ . . . . . . @ . <br> . @ . . . . . . @ . <br> . . . . . . . . @ . <br> . . . . . . . . . . <br> . #########. . . . . . <br> . #########. . . . . . <br> . . . . . . . . . .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The results do not completely coincide with the results of the Python version, because for the priority queue I use the built-in hash tables, and the iteration order over the hash tables will not be constant. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 Search A * </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A * almost completely repeats Dijkstra's algorithm, except for the added heuristic search. </font><font style="vertical-align: inherit;">Note that the algorithm code </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used not only for grids</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Knowledge of grids is in the class of the graph (in this case </font></font><code>SquareGrids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and in the function </font></font><code>heuristic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If you replace them, you can use the code of the algorithm A * with any other structure of graphs.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heuristic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SquareGrid::Location a, SquareGrid::Location b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1, y1, x2, y2; tie (x1, y1) = a; tie (x2, y2) = b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(x1 - x2) + <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(y1 - y2); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a_star_search</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph&amp; graph, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location&gt;&amp; came_from, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph::Location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; cost_so_far)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph::Location Location; PriorityQueue&lt;Location, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; frontier; frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>); came_from[start] = start; cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!frontier.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> current = frontier.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; next : graph.neighbors(current)) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> new_cost = cost_so_far[current] + graph.cost(current, next); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cost_so_far.count(next) || new_cost &lt; cost_so_far[next]) { cost_so_far[next] = new_cost; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> priority = new_cost + heuristic(next, goal); frontier.put(next, priority); came_from[next] = current; } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The type of values </font></font><code>priority</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, including the type used for the priority queue, must be large enough to contain both the value of the graph ( </font></font><code>cost_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and the heuristic value. </font><font style="vertical-align: inherit;">For example, if the value of the graph is stored in an int, and the heuristics returns a double, then it is necessary that the priority queue can receive a double. </font><font style="vertical-align: inherit;">In this code example I use </font></font><code>double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for all three values â€‹â€‹(cost, heuristics and priority), but I could use and </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because my cost and heuristics have integer values. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small note: it would be more correct to write </font></font><code>frontier.put(start, heuristic(start, goal))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, rather than</font></font><code>frontier.put(start, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but here it is not important, because the priority of the initial node does not matter. </font><font style="vertical-align: inherit;">This is the only node in the priority queue and it is selected and deleted before something is written there.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"redblobgames/pathfinding/a-star/implementation.cpp"</span></span></span><span class="hljs-meta"> int main() { GridWithWeights grid = make_diagram4(); SquareGrid::Location start{1, 4}; SquareGrid::Location goal{8, 5}; unordered_map</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SquareGrid::Location, SquareGrid::Location&gt; came_from; unordered_map&lt;SquareGrid::Location, double&gt; cost_so_far; a_star_search(grid, start, goal, came_from, cost_so_far); draw_grid(grid, 2, nullptr, &amp;came_from); std::cout &lt;&lt; std::endl; draw_grid(grid, 3, &amp;cost_so_far, nullptr); std::cout &lt;&lt; std::endl; vector&lt;SquareGrid::Location&gt; path = reconstruct_path(start, goal, came_from); draw_grid(grid, 3, nullptr, nullptr, &amp;path); }</span></span></span></span></code> </pre> <br> <code>â†“ â†“ â†“ â†“ â† â† â† â† â† â† <br> â†“ â†“ â†“ â†“ â† â†‘ â†‘ â† â† â† <br> â†“ â†“ â†“ â†“ â† â† â†‘ â†‘ â† â† <br> â†“ â†“ â†“ â† â† â† . â†‘ â†‘ â† <br> â†’ * â† â† â† â† . â†’ â†‘ â† <br> â†’ â†‘ â† â† â† â† . . â†‘ . <br> â†‘ â†‘ â†‘ â† â† â† . . . . <br> â†‘ ######â†‘ . . . . . <br> â†‘ ######. . . . . . <br> â†‘ . . . . . . . . . <br> <br> 5 4 5 6 7 8 9 10 11 12 <br> 4 3 4 5 10 13 10 11 12 13 <br> 3 2 3 4 9 14 15 12 13 14 <br> 2 1 2 3 8 13 . 17 14 15 <br> 1 0 1 6 11 16 . 20 15 16 <br> 2 1 2 7 12 17 . . 16 . <br> 3 2 3 4 9 14 . . . . <br> 4 #########14 . . . . . <br> 5 #########. . . . . . <br> 6 . . . . . . . . . <br> <br> . . . @ @ @ @ . . . <br> . . . @ . . @ @ . . <br> . . . @ . . . @ @ . <br> . . @ @ . . . . @ . <br> . @ @ . . . . . @ . <br> . . . . . . . . @ . <br> . . . . . . . . . . <br> . #########. . . . . . <br> . #########. . . . . . <br> . . . . . . . . . .</code> <br> <br><h4> 2.4.1   </h4><br>          ,      Â«Â»,   . <b> </b> .   <i></i> ,    ,        ,     <b> </b> :     . A*      ,    <b>    </b> .  <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">  </a>    ,     .   <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">  </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will speed up A * much and create more direct and beautiful paths. </font><font style="vertical-align: inherit;">However, this only works with static maps, in which each step has the same cost of movement. </font><font style="vertical-align: inherit;">For the demo on my page, I used a fast hack, but it only works with my slow priority queue. </font><font style="vertical-align: inherit;">If you move to a faster priority queue, then you need another quick hack.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 TODO: vector neighbors () should be transmitted </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of selecting and returning each time a new vector for neighbors, the A * code should allocate one vector and each time pass it to the neighbors function. </font><font style="vertical-align: inherit;">In my tests, this made the code much faster.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.3 TODO: eliminate template parameterization </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The goal of this page is to create easy-to-understand code, and I believe that parameterizing a template is too difficult to read. </font><font style="vertical-align: inherit;">Instead, I use several typedefs.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.4 TODO: add requirements </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are two types of graphs (weighted and unweighted), and the search code for the graph does not indicate which type is required. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 Implementation on C # </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These are my first C # programs, so they may be uncharacteristic or stylistically incorrect for this language. </font><font style="vertical-align: inherit;">These examples are not as complete as the examples in the Python and C ++ sections, but I hope they will be useful. </font><font style="vertical-align: inherit;">Here is an implementation of a simple graph and search in width:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Graph</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Location</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//        string, //      NameValueCollection public Dictionary&lt;Location, Location[]&gt; edges = new Dictionary&lt;Location, Location[]&gt;(); public Location[] Neighbors(Location id) { return edges[id]; } }; class BreadthFirstSearch { static void Search(Graph&lt;string&gt; graph, string start) { var frontier = new Queue&lt;string&gt;(); frontier.Enqueue(start); var visited = new HashSet&lt;string&gt;(); visited.Add(start); while (frontier.Count &gt; 0) { var current = frontier.Dequeue(); Console.WriteLine("Visiting {0}", current); foreach (var next in graph.Neighbors(current)) { if (!visited.Contains(next)) { frontier.Enqueue(next); visited.Add(next); } } } } static void Main() { Graph&lt;string&gt; g = new Graph&lt;string&gt;(); g.edges = new Dictionary&lt;string, string[]&gt; { { "A", new [] { "B" } }, { "B", new [] { "A", "C", "D" } }, { "C", new [] { "A" } }, { "D", new [] { "E", "A" } }, { "E", new [] { "B" } } }; Search(g, "A"); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is a graph representing a grid with weighted edges (an example of a forest and walls from the previous article): </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-comment"><span class="hljs-comment">//  A*   WeightedGraph    L,   ** //   .       . public interface WeightedGraph&lt;L&gt; { double Cost(Location a, Location b); IEnumerable&lt;Location&gt; Neighbors(Location id); } public struct Location { //   :   Equals  , //     . ,     //  Equals  GetHashCode. public readonly int x, y; public Location(int x, int y) { this.x = x; this.y = y; } } public class SquareGrid : WeightedGraph&lt;Location&gt; { //   :      , //    , ,    //     . public static readonly Location[] DIRS = new [] { new Location(1, 0), new Location(0, -1), new Location(-1, 0), new Location(0, 1) }; public int width, height; public HashSet&lt;Location&gt; walls = new HashSet&lt;Location&gt;(); public HashSet&lt;Location&gt; forests = new HashSet&lt;Location&gt;(); public SquareGrid(int width, int height) { this.width = width; this.height = height; } public bool InBounds(Location id) { return 0 &lt;= id.x &amp;&amp; id.x &lt; width &amp;&amp; 0 &lt;= id.y &amp;&amp; id.y &lt; height; } public bool Passable(Location id) { return !walls.Contains(id); } public double Cost(Location a, Location b) { return forests.Contains(b) ? 5 : 1; } public IEnumerable&lt;Location&gt; Neighbors(Location id) { foreach (var dir in DIRS) { Location next = new Location(id.x + dir.x, id.y + dir.y); if (InBounds(next) &amp;&amp; Passable(next)) { yield return next; } } } } public class PriorityQueue&lt;T&gt; { //       ,    //     .      //      C#: https://github.com/dotnet/corefx/issues/574 // //     ,     : // * https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp // * http://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx // * http://xfleury.github.io/graphsearch.html // * http://stackoverflow.com/questions/102398/priority-queue-in-net private List&lt;Tuple&lt;T, double&gt;&gt; elements = new List&lt;Tuple&lt;T, double&gt;&gt;(); public int Count { get { return elements.Count; } } public void Enqueue(T item, double priority) { elements.Add(Tuple.Create(item, priority)); } public T Dequeue() { int bestIndex = 0; for (int i = 0; i &lt; elements.Count; i++) { if (elements[i].Item2 &lt; elements[bestIndex].Item2) { bestIndex = i; } } T bestItem = elements[bestIndex].Item1; elements.RemoveAt(bestIndex); return bestItem; } } /*   :      Python   *  ,     .   C++ *     typedef,     int, double  *  .     C#    ,  *   double.   int,   ,   *    ,    ,  ,  *    . */ public class AStarSearch { public Dictionary&lt;Location, Location&gt; cameFrom = new Dictionary&lt;Location, Location&gt;(); public Dictionary&lt;Location, double&gt; costSoFar = new Dictionary&lt;Location, double&gt;(); // :   A*   Location //  Heuristic static public double Heuristic(Location a, Location b) { return Math.Abs(ax - bx) + Math.Abs(ay - by); } public AStarSearch(WeightedGraph&lt;Location&gt; graph, Location start, Location goal) { var frontier = new PriorityQueue&lt;Location&gt;(); frontier.Enqueue(start, 0); cameFrom[start] = start; costSoFar[start] = 0; while (frontier.Count &gt; 0) { var current = frontier.Dequeue(); if (current.Equals(goal)) { break; } foreach (var next in graph.Neighbors(current)) { double newCost = costSoFar[current] + graph.Cost(current, next); if (!costSoFar.ContainsKey(next) || newCost &lt; costSoFar[next]) { costSoFar[next] = newCost; double priority = newCost + Heuristic(next, goal); frontier.Enqueue(next, priority); cameFrom[next] = current; } } } } } public class Test { static void DrawGrid(SquareGrid grid, AStarSearch astar) { //   cameFrom for (var y = 0; y &lt; 10; y++) { for (var x = 0; x &lt; 10; x++) { Location id = new Location(x, y); Location ptr = id; if (!astar.cameFrom.TryGetValue(id, out ptr)) { ptr = id; } if (grid.walls.Contains(id)) { Console.Write("##"); } else if (ptr.x == x+1) { Console.Write("\u2192 "); } else if (ptr.x == x-1) { Console.Write("\u2190 "); } else if (ptr.y == y+1) { Console.Write("\u2193 "); } else if (ptr.y == y-1) { Console.Write("\u2191 "); } else { Console.Write("* "); } } Console.WriteLine(); } } static void Main() { //  " 4"    var grid = new SquareGrid(10, 10); for (var x = 1; x &lt; 4; x++) { for (var y = 7; y &lt; 9; y++) { grid.walls.Add(new Location(x, y)); } } grid.forests = new HashSet&lt;Location&gt; { new Location(3, 4), new Location(3, 5), new Location(4, 1), new Location(4, 2), new Location(4, 3), new Location(4, 4), new Location(4, 5), new Location(4, 6), new Location(4, 7), new Location(4, 8), new Location(5, 1), new Location(5, 2), new Location(5, 3), new Location(5, 4), new Location(5, 5), new Location(5, 6), new Location(5, 7), new Location(5, 8), new Location(6, 2), new Location(6, 3), new Location(6, 4), new Location(6, 5), new Location(6, 6), new Location(6, 7), new Location(7, 3), new Location(7, 4), new Location(7, 5) }; //  A* var astar = new AStarSearch(grid, new Location(1, 4), new Location(8, 5)); DrawGrid(grid, astar); } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 Optimization </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating the code for the article, I focused on simplicity and applicability, and not on performance. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First make the code work, then optimize the speed. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many of the optimizations used by me in real projects are specific to the project, so instead of showing the optimal code, Iâ€™ll give you some ideas that you can implement in your own project:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.1 Count </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The biggest optimization you can make is reducing the number of nodes. </font><font style="vertical-align: inherit;">Recommendation number 1: If you are using a map from grids, then try using a </font></font><a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-grid-based</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> path search graph </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is not always possible, but this option is worth considering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the graph has a simple structure (for example, a grid), then calculate the neighbors in the function. </font><font style="vertical-align: inherit;">If it has a more complex structure (without grids, or a grid with a large number of walls, like in a maze), then store your neighbors in a data structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also save copy operations on the reuse of an array of neighbors. </font><font style="vertical-align: inherit;">Instead of performing a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> every time, select it once in the search code and pass it to the method of the neighbors graph.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2 Queue </font></font></h3><br>       ,     ,    .    ,    .       .            .   ,     ,         . <br><br>      deque. deque         ,          .  Python   <a href="https://docs.python.org/3/library/collections.html">collections.deque</a> ;  C++   <a href="http://en.cppreference.com/w/cpp/container/deque">deque</a> .          :      ,   ,     . <br><br>       ,      .        ,         - .  Python   <a href="https://docs.python.org/2/library/heapq.html">heapq</a> ;  C++   <a href="http://en.cppreference.com/w/cpp/container/priority_queue">priority_queue</a> . <br><br>  Python     Queue  PriorityQueue  ,       .  ,       ,  .  C++  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that in the Dijkstra algorithm, the priority queue with priorities is stored twice, once in the priority queue, the second is in </font></font><code>cost_so_far</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so you can write a priority queue that takes priority from any place. I do not know whether it is worth it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard implementation of the Dijkstra algorithm uses priority changes in the priority queue. However, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what happens if you do not change the priority?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, duplicate elements will appear there. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the algorithm still works.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He will re-visit some points more than necessary. There will be more elements in the priority queue than necessary, which slows down work, but data structures that support priority changes also slow down work due to the presence of more elements. See the study </font></font><a href="http://www.cs.sunysb.edu/~rezaul/papers/TR-07-54.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">â€œPriority Queues and Dijkstra's Algorithmâ€ by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chen, Chowdheri, Ramachandran, Lan-Roch, and Tonga. This study also recommends considering </font></font><a href="http://en.wikipedia.org/wiki/Pairing_heap"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pairing heaps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and other data structures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are thinking of using something instead of a binary heap, first measure the size of the border and the frequency of changing priorities. Profile the code and see if the priority queue is a bottleneck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I feel that a promising direction is</font></font><i> </i> .             ,     ,       A*    .     <i> </i> .         <code>f</code> ,       <code>f+e</code> ,  <code>e</code> â€”   .          1  5.  ,         <code>f</code>  <code>f+5</code> .     , <i>    </i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can use six blocks or do not sort anything at all! </font><font style="vertical-align: inherit;">A * creates a wider range of priorities, but still this method is worth considering. </font><font style="vertical-align: inherit;">And there are more interesting approaches to grouping that can handle a wider range of situations. </font></font><br><br> <a href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have another article on priority queuing data structures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3 Search </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heuristics increase the complexity and cost of CPU time. However, the goal here is to study fewer nodes. In some maps (for example, in labyrinths), heuristics may not add much information, and it may be better to use a simpler algorithm without heuristics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If your graph as points using integer values, then consider the possibility of using </font></font><code>cost_so_far</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>came_from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. a simple array, not a hash table. Since it </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a boolean array, you can use a bit vector. Initialize the bit vector for all the IDs, but leave </font></font><code>cost_so_far</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>came_from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uninitialized (if the language allows it). Then initialize them only at the first visit.</font></font><br><br>         ,              .     ,     .       ,     . ,     <code>visited[]</code> ,   1000 ,       100 ,     ,      100     ,     1000     . <br><br>       A* <i></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(overestimated) heuristics. It seems reasonable. However, I did not carefully consider these implementations. I suppose (but I donâ€™t know for sure) that some elements already visited need to be visited again, even if they have already been removed from the border. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some implementations, </font><font style="vertical-align: inherit;">a new node is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inserted </font><font style="vertical-align: inherit;">into an open set </font><font style="vertical-align: inherit;">, even if it is already there. This avoids the potentially costly step of checking whether a node is already in an open set. But at the same time, the open set becomes larger / slower and, as a result, will have to evaluate more nodes than necessary. If checking an open set turns out to be costly, then you might want to use this approach. However, in the code I presented, I made the check cheap, and I do not use this approach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some implementations</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It does not check</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> whether a new node is better than an existing one in an open set. </font><font style="vertical-align: inherit;">This avoids potentially costly validation. </font><font style="vertical-align: inherit;">However, this may </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lead to an error</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On some types of cards you will not find the shortest path if you skip this check. </font><font style="vertical-align: inherit;">In the code I presented, I perform this check ( </font></font><code>new_cost &lt; cost_so_far</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">This check is cheap because I made the search </font></font><code>cost_so_far</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cheap.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 Troubleshooting </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.1 Wrong paths </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you do not get the shortest path, try the following checks: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Does the priority queue work correctly? </font><font style="vertical-align: inherit;">Try stopping the search and retrieving all items from the queue. </font><font style="vertical-align: inherit;">They must go in order.</font></font></li><li>     ? <code>priority</code>          ,      (  ,       ). </li><li>       ,       .          ,      ,         .       ,        ,   ,       . </li></ul><br><h3> 5.2   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most often, when performing A * on grids, they ask me a question: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">why do the paths not look straight? </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you tell A * that all movements along the grid have equal cost, you get a set of shortest paths of the same length, and the algorithm randomly chooses one of them. </font><font style="vertical-align: inherit;">The path is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">short</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but it does not </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> good.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One solution would be to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">straighten the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> paths after the algorithm using the string pulling algorithm.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another solution is to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> path in the right direction by regulating heuristics. </font><font style="vertical-align: inherit;">There are some cheap tricks that do not work in all situations; </font></font><a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here you can read more about this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>   â€” <i>  </i> .  A*  ,    ,     . <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">     </a> . </li><li>   â€” ,     .         (: , , , ),    Â«Â»   (  (x+y) % 2 == 1). <b>      .</b> </li></ul><br><h2> 6   </h2><br><ul><li>           .          . : <ul><li> <code>cost</code>    <i>w</i> or <i>d</i>  <i>l</i>  length </li><li> <code>cost_so_far</code>    <i>g</i>  <i>d</i>  distance </li><li> <code>heuristic</code>    <i>h</i> </li><li> <code>priority</code>  A*    <i>f</i> ,  <i>f</i> = <i>g</i> + <i>h</i> </li><li> <code>came_from</code>    <i>Ï€</i>  parent  previous  prev </li><li> <code>frontier</code>   OPEN </li><li> <code>visited</code> â€”   OPEN  CLOSED </li><li> , , <code>current</code>  <code>next</code>   <i>u</i> , <i>v</i> </li></ul></li><li>   : <ul><li> <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)"></a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584"></a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">  </a> </li><li> () <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25BF%25D0%25BE_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25BC%25D1%2583_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25BB%25D1%2583%25D1%2587%25D1%2588%25D0%25B5%25D0%25BC%25D1%2583_%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BF%25D0%25B0%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258E">    </a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B"> </a> </li><li> <a href="https://ru.wikipedia.org/wiki/A*"> A*</a> </li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/331220/">https://habr.com/ru/post/331220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331208/index.html">A fistful of relays. Part 4. System commands or what can fit in 8 machine instructions?</a></li>
<li><a href="../331210/index.html">Self-registration of the second factor for two-factor authentication based on the RADIUS protocol</a></li>
<li><a href="../331212/index.html">Development kit from analytics to outsourced artists</a></li>
<li><a href="../331214/index.html">Automatic configuration of Cisco voice gateways and Eltex Asterisk provisioning</a></li>
<li><a href="../331216/index.html">HTTP / 2 Server Push is not as simple as I thought.</a></li>
<li><a href="../331222/index.html">No place to hide - how aggressive marketing services haunt you</a></li>
<li><a href="../331224/index.html">Translation of the Appium Essentials book. Chapter 1</a></li>
<li><a href="../331226/index.html">On the use of video cameras with character recognition on low-performance computing devices</a></li>
<li><a href="../331228/index.html">Debian 9: what's new</a></li>
<li><a href="../331230/index.html">The incredible machine or my best test.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>