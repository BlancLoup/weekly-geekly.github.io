<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Useful code implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes how to build a bridge between unmanaged and managed code using the example of the mathematical package Mathcad. The picture show...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Useful code implementation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/7ec/6dc/3b67ec6dcfeb786f807a6cc00d44eaab.jpg" width="400"><br><br>  The article describes how to build a bridge between unmanaged and managed code using the example of the mathematical package Mathcad.  The picture shows an example of how the one chipmunk is going to process his image by means of a mathematical package.  For this, he ‚Äúused‚Äù a user-defined function written on VB.Net, in which the ability to connect to a webcam and create a snapshot is implemented.  The result of the function is immediately available in the working document. <br><a name="habracut"></a><br><h4>  Sources </h4><br>  For impatient people who want to understand everything at once, having run the code diagonally, I specify the storage: <a href="https://github.com/ViacheslavMezentsev/NetEFI">NetEFI</a> .  You can also find test user libraries in three languages: c #, vb.net and c ++ / cli (VS2012, .Net 2.0, x86-32).  So far only 32-bit implementation is available. <br><br><h4>  Prehistory </h4><br>  In the mathematical program Mathcad there is the possibility of connecting third-party libraries.  This interface is called User EFI and was developed more than 10 years ago.  Since then, it has not changed at all, although Mathcad himself has changed beyond recognition.  There was a time when this interface was thrown out of the package, but old users have requested it back and in new versions of Mathcad Prime this rare interface is once again alive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is quite a clear guide to creating custom libraries, I brought it at the end of the article.  In short, the process looks like this.  We create a regular dll, where at the entry point, i.e.  when loading it, register our functions.  At the same time, in the function descriptor we specify its address for the subsequent call from Mathcad directly.  In addition, you can still register one table with error messages.  The result returned by the user function in the event of an error can be used to select messages from this table.  Here, in general, and the whole kitchen. <br><br>  The function descriptor looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">FUNCTIONINFO structure</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LRESULT</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* LPCFUNCTION )</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ... )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// The FUNCTIONINFO structure contains the information that Mathcad uses to register a // user function. Refer below for each member and its description. typedef struct tagFUNCTIONINFO { // Points to a NULL-terminated string that specifies the name of the user // function. char * lpstrName; // Points to a NULL-terminated string that specifies the parameters of the // user function. char * lpstrParameters; // Points to a NULL-terminated string that specifies the function description. char * lpstrDescription; // Pointer to the code that executes the user function. LPCFUNCTION lpfnMyCFunction; // Specifies the type of value returned by the function. The values are // COMPLEX_ARRAY or COMPLEX_SCALAR. long unsigned int returnType; // Specifies the number of arguments expected by the function. Must be // between 1 and MAX_ARGS. unsigned int nArgs; // Specifies an array of long unsigned integers containing input parameter // types. long unsigned int argType[ MAX_ARGS ]; } FUNCTIONINFO;</span></span></code> </pre> </div></div><br>  The problem is that today it would be much more convenient to write our functions if we did it in .net languages.  But the direct way to do this is through the use of C ++ / CLI.  The option of ‚Äúwrapping‚Äù each user-defined function through an adapter to C ++ / CLI or marshaling structures, I think, can be dismissed immediately as impractical and requiring nontrivial knowledge from the user of the mathematical program.  I want to offer a universal "wrapper", which I called .Net User EFI. <br><br>  The question arises as to how to create a universal function that could be registered instead of all the functions of all connected assemblies, but at the same time it would have all the necessary information at the entry point to call a specific function from a specific assembly.  The reseller library in which such a function is located should automatically work with any number of connected assemblies and functions in them. <br><br>  To implement such universality there is one significant problem.  Mathcad requires you to specify the address of the called function, the prototype itself is declared as having a variable number of parameters.  It turns out that at the entry point of the universal function, the stack with parameters will have a different size and there is no possibility to pass this information when the function is called by standard means, since  it is determined by the compiled code itself.  In the structure above, only the address itself acts as a parameter by which we could distinguish the calling of one function from another. <br><br>  And here our thought should come to one known solution, which is called code injection.  On Habr√©, more than once they wrote about it, but there are not so many practical useful examples of using such equipment.  In a sense, we will also intercept function calls from dll, everything will look a bit more specific, but much easier. <br><br><h4>  Idea </h4><br>  So, what we will inject, introduce, where and why.  Once again, clarify the situation.  We want to write a universal function that will process all calls uniformly and distribute them depending on the type of the function being called.  Mathcad should not ‚Äúsuspect‚Äù anything, and we should get additional information from somewhere at the entry point of the universal function about the call parameters. <br><br>  The solution will be to dynamically generate the code at the address that we register in Mathcad.  We will reserve a lot of space in memory for dynamic code.  This code will carry out auxiliary work on the transfer of parameters of the universal function.  First, I‚Äôll say that two parameters are enough for us, this is the number of the assembly in the array of loaded assemblies and the number of the function from the assembly.  There are two ways to pass parameters: global variables and the stack.  I chose the first option, because  disrupting the stack balance (in which the parameters are located) is easy, but I think it will be difficult to restore it in our case. <br><br>  I forgot to mention that there are only three user function types and all of them are passed by pointer: MCSTRING, COMPLEXSCALAR and COMPLEXARRAY.  The maximum number is also limited to 10 pieces.  This simplifies the implementation of parsing parameters in a universal function. <br><br><h4>  Implementation </h4><br>  Now we are morally ready to sort out the specific sequence of events that should occur at the stage of implementation and after it. <br><br>  <b>Step 1</b> .  The user creates a .net class that implements the IFunction interface, which contains the necessary information about the function.  Compiles it into an assembly and copies it to the userefi folder.  Also in this folder should be an intermediary assembly, we will call it netefi. <br><br>  <b>Step 2</b> .  When loading Mathcad, the netefi mediation build is perceived as a user library.  It searches for all .net assemblies in the current folder and searches the functions in them for the implementation of the IFunction interface. <br><br>  <b>Step 3</b> .  netefi stores information about assemblies and functions in them in internal arrays, while in order to define a function, you need two numbers: the assembly index and the function index in it. <br><br>  <b>Step 4</b> .  netefi enumerates all the functions and registers them in Mathcad in a standard way, but in the address field of the FUNCTIONINFO structure we write a link to the dynamic code, the form of which is determined by the two indices from the previous step. <br><br>  Here is the concrete implementation of the implementation method: <br><br><div class="spoiler">  <b class="spoiler_title">Dynamic code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> assemblyId = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionId = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PBYTE pCode = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unmanaged LRESULT CallbackFunction( void * out, ... ) { return ::UserFunction( &amp; out ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> managed </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> 64-bit. void Manager::InjectCode( PBYTE &amp; p, int k, int n ) { //   ( )   . * p++ = 0xB8; // mov eax, imm32 p[0] = k; p += sizeof( int ); * p++ = 0xA3; // mov [assemblyId], eax ( int * &amp; ) p[0] = &amp; assemblyId; p += sizeof( int * ); //   ( )   . * p++ = 0xB8; // mov eax, imm32 p[0] = n; p += sizeof( int ); * p++ = 0xA3; // mov [functionId], eax ( int * &amp; ) p[0] = &amp; functionId; p += sizeof( int * ); // jmp to CallbackFunction. * p++ = 0xE9; ( UINT &amp; ) p[0] = ( PBYTE ) ::CallbackFunction - 4 - p; p += sizeof( PBYTE ); }</span></span></span></span></code> </pre> </div></div><br>  The InjectCode () method is called in a loop when registering functions in Mathcad.  The global variables assemblyId and functionId are used to determine the type of the function at the time it is called.  It works like this.  Mathcad for each function receives a link to such a dynamic code.  In this case, the assembly index recorded in the assemblyId, known at the time of loading (parameter k), the function index is written to functionId ‚Äî the parameter n.  Next comes the unconditional transition to CallbackFunction (), in which our universal function is called.  This is done so that you can call managed code in UserFunction ().  Unmanaged / managed directives will not allow this to be done in CallbackFunction (). <br><br>  Note that the parameter of the universal function is a link to the CallbackFunction () stack, i.e.  on the array of parameters (the return value is in the same place).  The dynamic code does not spoil the stack for us, so after the completion of CallbackFunction () control will return to Mathcad.  That's all the magic. <br><br>  <b>Step 5</b> .  After registration is complete, you can call a custom function in a Mathcad document.  The universal UserFunction () function can now restore the user function type by the global assemblyId and functionId parameters and disassemble the stack, knowing the number and type of parameters. <br><br>  <b>Step 6</b> .  Each unmanaged type of the function parameter is replaced with an analog: MCSTRING with String, COMPLEXSCALAR with TComplex (I did not use Complex from .Net 4.0, so that there was no conflict) and COMPLEXARRAY with TComplex [,]. <br><br>  <b>Step 7</b> .  The implementation of the IFunction.NumericEvaluation method for the function is called.  The returned result passes the reverse sequence of transformations and is given to Mathcad. <br><br><h4>  About implementation </h4><br>  I think that I explained this particular implementation method more or less clearly.  As for the source of the project itself, it is worth mentioning briefly the environment and some details.  Visual Studio 2012, C ++ / CLI, .Net Framework 2.0 is used as the development environment (the corresponding mode is set in the project properties).  Since the dynamic code, generally speaking, depends on the digit capacity and I still don‚Äôt know exactly how to bring it to the 64-bit representation, all projects are set to be compiled for 32-bit machines.  Although <a href="http://stackoverflow.com/questions/24466513/calculating-jmp-instructions-address-x86-64">I was told</a> that there would be few changes. <br><br>  Using global variables is not good, but working in Mathcad does not involve the simultaneous calling of several functions.  Everything is done there in order, one after the other. <br><br>  In the mediation assembly, some more ideas are implemented that allow you to fully use the old interface in the new environment.  This applies to error handling and you need to write about it separately.  All main code is concentrated in a single Manager class (netefi.cpp).  Analyzing test examples, you can understand how to work with the interface IFunction.  All test examples in different languages ‚Äã‚Äãdo the same thing, and are called almost the same. <br><br>  Examples are tested in Mathcad 15 and Mathcad Prime 3.0.  Since the User EFI interface itself has not changed for more than 10 years (and it is unlikely to change already), the described method can also be used in other versions of Mathcad, starting, probably, from version 11.  In Mathcad Prime 3.0, custom functions were given a new name - Custom Functions, although the filling is the same. <br><br><h4>  Test cases </h4><br>  As mentioned above, you can find them <a href="https://github.com/ViacheslavMezentsev/NetEFI">here</a> .  But the article would not be complete if you did not show the specific form of .net user-defined functions for Mathcad. <br><br>  Let's see how the echo function will look like for one string parameter. <br><br><div class="spoiler">  <b class="spoiler_title">C # option</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NetEFI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">csecho</span></span>: <span class="hljs-title"><span class="hljs-title">IFunction</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FunctionInfo Info { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionInfo( <span class="hljs-string"><span class="hljs-string">"csecho"</span></span>, <span class="hljs-string"><span class="hljs-string">"s"</span></span>, <span class="hljs-string"><span class="hljs-string">"return string"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>( String ), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>( String ) } ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FunctionInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFunctionInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lang </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Info; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NumericEvaluation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result </span></span></span><span class="hljs-function">)</span></span> { result = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">VB.Net option</b> <div class="spoiler_text"><pre> <code class="vbscript hljs">Imports NetEFI <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> vbecho Implements IFunction <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> ReadOnly <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> Info() As FunctionInfo _ Implements IFunction.Info <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> Return <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> FunctionInfo(<span class="hljs-string"><span class="hljs-string">"vbecho"</span></span>, <span class="hljs-string"><span class="hljs-string">"s"</span></span>, <span class="hljs-string"><span class="hljs-string">"return string"</span></span>, _ GetType([<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>]), <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> Type() {GetType([<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>])}) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> GetFunctionInfo(lang As <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) As FunctionInfo _ Implements IFunction.GetFunctionInfo Return Info <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> NumericEvaluation(args As Object(), <span class="hljs-keyword"><span class="hljs-keyword">ByRef</span></span> result As Object) As Boolean _ Implements IFunction.NumericEvaluation result = args(<span class="hljs-number"><span class="hljs-number">0</span></span>) Return <span class="hljs-literal"><span class="hljs-literal">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C ++ / CLI option</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once using namespace System; using namespace System::Text; using namespace NetEFI; public ref class cppecho: public IFunction { public: virtual property FunctionInfo^ Info { FunctionInfo^ get() { return gcnew FunctionInfo( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cppecho"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"return string"</span></span></span><span class="hljs-meta">, String::typeid, gcnew array</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Type^&gt; { String::typeid } ); } } virtual FunctionInfo^ GetFunctionInfo(String^ lang) { return Info; } virtual bool NumericEvaluation( array&lt; Object^ &gt; ^ args, [Out] Object ^ % result ) { result = args[0]; return true; } };</span></span></span></span></code> </pre> </div></div><br><h4>  Other </h4><br>  Although the main functionality is almost ready, there are some shortcomings.  For example, it is desirable that the work of a universal function be performed in a separate thread.  This is one of the first things to do.  Interruption of work by calling isUserInterrupted is not reflected in any way in the new interface.  All hope so far that Mathcad himself can interrupt the function.  I will think about it and it echoes the work in the stream. <br><br>  The current project only works on 32-bit systems.  To add 64-bit configurations, you need to test the operation of dynamic code on 64-bit systems.  There is no such possibility yet. <br><br>  Working with COM inside the user function is now also apparently impossible.  I faced this when I implemented the function to create a snapshot from a webcam.  One of the standard options intended to use the interface to the Clipboard, and so it did not work, saying that the stream should be with the STAThreadAttribute attribute.  Solved the problem through Graphics.CopyFromScreen.  Also need to understand. <br><br>  Downloading the missing assemblies is also not done reliably enough, because  Assembly :: LoadFile () is used.  If you use Assembly :: LoadFrom (), then Mathcad hangs in this place.  There is also a problem with debugging mixed code.  For some reason, she did not work for me as it should.  I practically debugged the code in my mind, only logs were saved. <br><br>  Maybe someone did something like this and could suggest good ideas to simplify my code.  I will listen to all practical options.  It would be great if someone made my project work under the studio debugger in mixed mode.  While only breakpoints in unmanaged code are working.  In the test examples, you can wander through the code, of course. <br><br><h4>  Links </h4><br>  0. <a href="http://stackoverflow.com/questions/4911993/how-to-generate-and-run-native-code-dynamically">How to generate and run native code dynamically?</a> <br>  1. <a href="https://github.com/ViacheslavMezentsev/NetEFI">Source codes and test examples on github</a> . <br>  2. <a href="http://en.smath.info/forum/resource.ashx%3Fa%3D1475">Creating a User DLL</a> (pdf). <br>  3. <a href="http://communities.ptc.com/message/247400">.Net User EFI interface</a> (a thread on the main PTC forum). <br>  4. <a href="http://communities.ptc.com/message/247740">Sources and builds of the example with a webcam</a> (in the same thread below). <br>  5. <a href="http://en.smath.info/forum/yaf_postst755_Mathcad-EFI-plugin.aspx">Mathcad EFI plugin</a> (another project of mine that performs the inverse function - calls unmanaged code from a managed one). </div><p>Source: <a href="https://habr.com/ru/post/227455/">https://habr.com/ru/post/227455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227445/index.html">Navio - autopilot card for the Raspberry Pi</a></li>
<li><a href="../227447/index.html">Continuing Amateur</a></li>
<li><a href="../227449/index.html">Who could tell me how to require to connect</a></li>
<li><a href="../227451/index.html">A year long crash, or an Android game development experience</a></li>
<li><a href="../227453/index.html">How to find out the real version of Windows from compatibility mode</a></li>
<li><a href="../227459/index.html">Russian stage of the World Olympics Robots - we did it!</a></li>
<li><a href="../227467/index.html">Stories that have taught us a lot: the results of habrakrakursa</a></li>
<li><a href="../227471/index.html">Russian physicists have discovered two types of dust in the atmosphere of Mars.</a></li>
<li><a href="../227473/index.html">DIY Epilepsy Attack Detector</a></li>
<li><a href="../227475/index.html">Creating audio plugin, part 9</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>