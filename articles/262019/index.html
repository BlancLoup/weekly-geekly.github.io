<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The first acquaintance with the coprocessor Intel Xeon Phi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The desire to get acquainted with the Xeon Phi coprocessor arose long ago, but then everything was not possible, that time. In the end, the miracle ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The first acquaintance with the coprocessor Intel Xeon Phi</h1><div class="post__text post__text-html js-mediator-article">  The desire to get acquainted with the Xeon Phi coprocessor arose long ago, but then everything was not possible, that time.  In the end, the miracle happened and got to the object of lust.  Unfortunately, far from the latest model - <a href="http://ark.intel.com/products/71992/Intel-Xeon-Phi-Coprocessor-5110P-8GB-1_053-GHz-60-core">5110P</a> - fell into the hands, but for the first acquaintance it will do.  Having experience working with CUDA, I was very interested in the question of differences between programming for the GPU and the coprocessor.  The second question was: "What (except for an extra headache) will I have using this device instead of a GPU or CPU?" <br><a name="habracut"></a><br>  Note: This article is not an advertisement or anti-advertising of any software or hardware product, but only describes the personal experience of the author. <br><br><h1>  Wisdom from the Developer's Quick Start Guide </h1><br>  In fact, the coprocessor is a separate piece of hardware that is installed in the PCI-e slot.  Unlike the GPU, the coprocessor has its own Linux-like micro OS, the so-called Card OS or uOS.  There are two options to run the code on Xeon Phi: <br><ul><li>  Compile the native code for the MIC using the ‚Äìmmic flag </li><li>  Run the code via offload.  In this case, part of the compiled code is run on the host (computer containing the coprocessor), and part on the device (hereinafter, the coprocessor will be referred to as just a device). </li></ul><br>  Another important point is the possibility of using OpenMP to distribute work between the threads inside the device - that's fine, let's do that.  First we implement a simple algorithm on the CPU, and then we remake the program so that it works on the coprocessor. <br><br><h1>  Test task description </h1><br>  As a test example, the task of force interaction of the bodies was chosen ( <a href="https://en.wikipedia.org/wiki/N-body_problem">n-body problem</a> ): there are N bodies the interaction between which is described by a certain pair potential, it is necessary to determine the position of each body after some time. <br>  The potential and strength of the pair interaction (in this case, we can take any function since we are not interested in the physics of the process): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/fa5/af3/a7c/fa5af3a7cafd4cb698438a7f163a7130.gif"></div><br>  The algorithm is simple: <br><ol><li>  We set the initial coordinates and velocities of the bodies; </li><li>  We calculate the force acting on each body by the others; </li><li>  We determine the new coordinates of the bodies; </li><li>  Repeat steps 2 and 3 until we reach the desired result. </li></ol><br>  Obviously, the most ‚Äúdifficult‚Äù stage is the calculation of forces, since it is necessary to perform about N <sup>2</sup> operations, and even at each time step (of course, using tricks like neighbor lists and remembering Newton's third law, you can significantly reduce the number of operations, but separate story). <br>  The serial code of this algorithm is very simple and easily converted to parallel using OpenMP directives. <br><div class="spoiler">  <b class="spoiler_title">Parallel code using OpenMP</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* N-Body simulation benchmark */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* written by MSOzhgibesov */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 04 July 2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdio.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdlib.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;string.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">time</span></span>.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;omp.h&gt; #define HOSTLEN <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> numProc; // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI); // Forces acting <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> body <span class="hljs-type"><span class="hljs-type">void</span></span> forces(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); // Calculate velocities <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> coordinates <span class="hljs-type"><span class="hljs-type">void</span></span> integration(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, const <span class="hljs-type"><span class="hljs-type">char</span></span> * argv[]) { <span class="hljs-type"><span class="hljs-type">int</span></span> const nI = <span class="hljs-number"><span class="hljs-number">32</span></span>; // Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X, Y <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Z directions <span class="hljs-type"><span class="hljs-type">int</span></span> const nBod = nI*nI*nI; // Total Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-type"><span class="hljs-type">int</span></span> const maxIter = <span class="hljs-number"><span class="hljs-number">20</span></span>; // Total number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterations (<span class="hljs-type"><span class="hljs-type">time</span></span> steps) <span class="hljs-type"><span class="hljs-type">float</span></span> const initDist = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; // Initial distance <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> the bodies <span class="hljs-type"><span class="hljs-type">float</span></span> *rA; // Coordinates <span class="hljs-type"><span class="hljs-type">float</span></span> *vA; // Velocities <span class="hljs-type"><span class="hljs-type">float</span></span> *fA; // Forces <span class="hljs-type"><span class="hljs-type">int</span></span> iter; <span class="hljs-type"><span class="hljs-type">double</span></span> startTime0, endTime0; <span class="hljs-type"><span class="hljs-type">char</span></span> host[HOSTLEN]; rA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); fA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); vA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); gethostname(host, HOSTLEN); printf("Host name: %s\n", host); numProc = omp_get_num_procs(); printf("Available number of processors: %d\n", numProc); // Setup initial conditions initCoord(rA, vA, fA, initDist, nBod, nI); startTime0 = omp_get_wtime(); // Main <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter &lt; maxIter; iter++ ) { forces(rA, fA, nBod); integration(rA, vA, fA, nBod); } endTime0 = omp_get_wtime(); printf("\nTotal time = %10.4f [sec]\n", endTime0 - startTime0); free(rA); free(vA); free(fA); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI) { <span class="hljs-type"><span class="hljs-type">int</span></span> i, j, k; <span class="hljs-type"><span class="hljs-type">float</span></span> Xi, Yi, Zi; <span class="hljs-type"><span class="hljs-type">float</span></span> *rAx = &amp;rA[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; //<span class="hljs-comment"><span class="hljs-comment">---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- int ii = 0; memset(fA, 0.0, 3*nBod*sizeof(float)); memset(vA, 0.0, 3*nBod*sizeof(float)); for (i = 0; i &lt; nI; i++) { Xi = i*initDist; for (j = 0; j &lt; nI; j++) { Yi = j*initDist; for (k = 0; k &lt; nI; k++) { Zi = k*initDist; rAx[ii] = Xi; rAy[ii] = Yi; rAz[ii] = Zi; ii++; } } } } // Forces acting on each body void forces(float *rA, float *fA, int nBod) { int i, j; float Xi, Yi, Zi; float Xij, Yij, Zij; // X[j] - X[i] and so on float Rij2; // Xij^2+Yij^2+Zij^2 float invRij2, invRij6; // 1/rij^2; 1/rij^6 float *rAx = &amp;rA[ 0]; //---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- float *fAx = &amp;fA[ 0]; //---- float *fAy = &amp;fA[ nBod]; // Pointers on X, Y, Z components of forces float *fAz = &amp;fA[2*nBod]; //---- float magForce; // Force magnitude float const EPS = 1.E-10; // Small value to prevent 0/0 if i==j #pragma omp parallel for num_threads(numProc) private(Xi, Yi, Zi, \ Xij, Yij, Zij, magForce, invRij2, invRij6, j) for (i = 0; i &lt; nBod; i++) { Xi = rAx[i]; Yi = rAy[i]; Zi = rAz[i]; fAx[i] = 0.0; fAy[i] = 0.0; fAz[i] = 0.0; for (j = 0; j &lt; nBod; j++) { Xij = rAx[j] - Xi; Yij = rAy[j] - Yi; Zij = rAz[j] - Zi; Rij2 = Xij*Xij + Yij*Yij + Zij*Zij; invRij2 = Rij2/((Rij2 + EPS)*(Rij2 + EPS)); invRij6 = invRij2*invRij2*invRij2; magForce = 6.0*invRij2*(2.0*invRij6 - 1.0)*invRij6; fAx[i]+= Xij*magForce; fAy[i]+= Yij*magForce; fAz[i]+= Zij*magForce; } } } // Integration of coordinates an velocities void integration(float *rA, float *vA, float *fA, int nBod) { int i; float const dt = 0.01; // Time step float const mass = 1.0; // mass of a body float const mdthalf = dt*0.5/mass; float *rAx = &amp;rA[ 0]; float *rAy = &amp;rA[ nBod]; float *rAz = &amp;rA[2*nBod]; float *vAx = &amp;vA[ 0]; float *vAy = &amp;vA[ nBod]; float *vAz = &amp;vA[2*nBod]; float *fAx = &amp;fA[ 0]; float *fAy = &amp;fA[ nBod]; float *fAz = &amp;fA[2*nBod]; #pragma omp parallel for num_threads(numProc) for (i = 0; i &lt; nBod; i++) { rAx[i]+= (vAx[i] + fAx[i]*mdthalf)*dt; rAy[i]+= (vAy[i] + fAy[i]*mdthalf)*dt; rAz[i]+= (vAz[i] + fAz[i]*mdthalf)*dt; vAx[i]+= fAx[i]*dt; vAy[i]+= fAy[i]*dt; vAz[i]+= fAz[i]*dt; } }</span></span></code> </pre> <br></div></div><br><h1>  Load the coprocessor </h1><br>  Consider our original program.  First we find out the device name and the available number of processors.  The figure below clearly shows the differences between the code for the host (the top image) and the device (the bottom image). <br><div style="text-align:center;"><img src="https://habrastorage.org/files/f4b/8b9/b1d/f4b8b9b1d68540238ae484b477cd2a22.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f20/02f/6f0/f2002f6f06d34d9cb36c331fa116f661.png"></div><br>  In the lower figure you can see that the directive #pragma offload is used to perform the unloading (offload) of the code on the device, the target for unloading is mic (our device).  If there are several coprocessors in the system, then the device number must be specified  Example: <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> offload target (mic:1)</span></span></code> </pre> <br>  After specifying the target, the unloading parameters follow, they can be: <br><ul><li>  in - variables are input only, that is, after the completion of the code, the values ‚Äã‚Äãof the variables back to the host are not copied. </li><li>  out - variables are solely the result, that is, before starting the work of the unloaded part, their values ‚Äã‚Äãare not copied from the host. </li><li>  inout - before launching the unloaded code, all variables are copied to the device, and after completion - to the host. </li><li>  nocopy - variables are not copied anywhere.  Used to reuse variables already initialized. </li></ul><br>  Detailed description offload <a href="https://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-EAB414FD-40C6-4054-B094-0BA70824E2A2.htm">here</a> . <br>  In this case, the variables numProc and host are only declared on the host, but not initialized, so we use out to copy (you can, of course, inout, but we will not disturb the order). <br>  The resulting code is quite possible to compile and run - no special compilation flags are required.  In this case, the number of threads will determine the device, returning the value of numProc, while the calculations will still be done on the host, since we have not yet unloaded the procedures. <br>  The very first procedure sets the initial conditions, it requires about N operations and is called only once, so we will leave it on the host. <br>  Next, a time cycle is started, at each step of which it is necessary to calculate the interaction forces and integrate the equations of motion.  The latter procedure requires, as well as setting the initial conditions, about N operations, and it would seem that it would also be logical to leave it on the host, but this will require copying the array with forces at each step.  Obviously, with a large system size, most of the time will go on dragging the array back and forth.  Therefore, it is necessary to upload all the source data to the device, perform the necessary number of iterations and upload the result to the host.  This approach is also used when parallelizing for a GPU. <br><pre> <code class="hljs pgsql"> startTime0 = omp_get_wtime(); // Main <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> #pragma offload target(mic) <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span>(rA, fA, vA:length(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod)) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(nBod) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter &lt; maxIter; iter++ ) { forces(rA, fA, nBod); integration(rA, vA, fA, nBod); } endTime0 = omp_get_wtime();</code> </pre><br>  In addition to the names of arrays, here you must also specify their size.  Thus, the cycle is fully loaded on the device, executed on it, after which the results are copied back.  It should be noted that for the routines that will be executed on the device, you must specify the appropriate <a href="https://software.intel.com/sites/products/documentation/doclib/iss/2013/compiler/cpp-lin/GUID-CCAC04A3-DD2F-4DFF-BD89-7235B321F7F3.htm">attributes</a> : <br><pre> <code class="hljs pgsql">// Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI); // Forces acting <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> body __attribute__ ((target(mic))) <span class="hljs-type"><span class="hljs-type">void</span></span> forces(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); // Calculate velocities <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> coordinates __attribute__ ((target(mic))) <span class="hljs-type"><span class="hljs-type">void</span></span> integration(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod);</code> </pre><br>  That's all, the first program for Intel Xeon Phi is ready and even works.  When you start the program, it may be useful to find out who exactly and where it copies (between the host and the device).  This can be done using the environment variable OFFLOAD_REPORT.  Example ( <a href="https://software.intel.com/en-us/node/510196">detailed</a> ): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b8a/0b7/a9e/b8a0b7a9e76948febc20a3f28cee1047.png"></div><br>  It can be seen that in the first unloading nothing was copied onto the device, but 54 bytes were received from it (the line with the name and the integer number of processors).  In the second case (the second unload), it was received 4 bytes less than it was sent, since the value of the variable nBod was not copied back. <br>  Code operation time on 24 host threads (2 Intel Xeon E5-2680v3 processors): 5.9832 sec <br><div style="text-align:center;"><img src="https://habrastorage.org/files/43c/829/60c/43c82960c1ae4bc78d69ccb5a154f9f4.png"></div><br>  Code operation time on 236 device threads (Intel Xeon Phi 5110P): 1.8667 sec <br><div style="text-align:center;"><img src="https://habrastorage.org/files/2c1/e37/4c2/2c1e374c2a56422a872074d5d5a5f525.png"></div><br>  Total, 2 lines of code gave a performance boost of almost 3 times - very nice.  It should be noted that you can also consider the option of hybrid computing - part of the problem is solved on the host, part on the device, however, there is no way to avoid data exchanges between the host and the device to synchronize coordinates. <br><div class="spoiler">  <b class="spoiler_title">Full code for Xeon Phi</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* N-Body simulation benchmark */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* written by MSOzhgibesov */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 04 July 2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdio.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdlib.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;string.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">time</span></span>.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;omp.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;unistd.h&gt; #define HOSTLEN <span class="hljs-number"><span class="hljs-number">50</span></span> __attribute__ ((target(mic))) <span class="hljs-type"><span class="hljs-type">int</span></span> numProc; // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI); // Forces acting <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> body __attribute__ ((target(mic))) <span class="hljs-type"><span class="hljs-type">void</span></span> forces(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); // Calculate velocities <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> coordinates __attribute__ ((target(mic))) <span class="hljs-type"><span class="hljs-type">void</span></span> integration(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, const <span class="hljs-type"><span class="hljs-type">char</span></span> * argv[]) { <span class="hljs-type"><span class="hljs-type">int</span></span> const nI = <span class="hljs-number"><span class="hljs-number">32</span></span>; // Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X, Y <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Z directions <span class="hljs-type"><span class="hljs-type">int</span></span> const nBod = nI*nI*nI; // Total Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-type"><span class="hljs-type">int</span></span> const maxIter = <span class="hljs-number"><span class="hljs-number">20</span></span>; // Total number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterations (<span class="hljs-type"><span class="hljs-type">time</span></span> steps) <span class="hljs-type"><span class="hljs-type">float</span></span> const initDist = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; // Initial distance <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> the bodies <span class="hljs-type"><span class="hljs-type">float</span></span> *rA; // Coordinates <span class="hljs-type"><span class="hljs-type">float</span></span> *vA; // Velocities <span class="hljs-type"><span class="hljs-type">float</span></span> *fA; // Forces <span class="hljs-type"><span class="hljs-type">int</span></span> iter; <span class="hljs-type"><span class="hljs-type">double</span></span> startTime0, endTime0; <span class="hljs-type"><span class="hljs-type">double</span></span> startTime1, endTime1; <span class="hljs-type"><span class="hljs-type">char</span></span> host[HOSTLEN]; rA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); fA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); vA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); #pragma offload target(mic) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>(numProc, host) { gethostname(host, HOSTLEN); numProc = omp_get_num_procs(); } printf("Host name: %s\n", host); printf("Available number of processors: %d\n", numProc); // Setup initial conditions initCoord(rA, vA, fA, initDist, nBod, nI); startTime0 = omp_get_wtime(); // Main <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> #pragma offload target(mic) <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span>(rA, fA, vA:length(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod)) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(nBod) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter &lt; maxIter; iter++ ) { forces(rA, fA, nBod); integration(rA, vA, fA, nBod); } endTime0 = omp_get_wtime(); printf("\nTotal time = %10.4f [sec]\n", endTime0 - startTime0); free(rA); free(vA); free(fA); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI) { <span class="hljs-type"><span class="hljs-type">int</span></span> i, j, k; <span class="hljs-type"><span class="hljs-type">float</span></span> Xi, Yi, Zi; <span class="hljs-type"><span class="hljs-type">float</span></span> *rAx = &amp;rA[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; //<span class="hljs-comment"><span class="hljs-comment">---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- int ii = 0; memset(fA, 0.0, 3*nBod*sizeof(float)); memset(vA, 0.0, 3*nBod*sizeof(float)); for (i = 0; i &lt; nI; i++) { Xi = i*initDist; for (j = 0; j &lt; nI; j++) { Yi = j*initDist; for (k = 0; k &lt; nI; k++) { Zi = k*initDist; rAx[ii] = Xi; rAy[ii] = Yi; rAz[ii] = Zi; ii++; } } } } // Forces acting on each body __attribute__ ((target(mic))) void forces(float *rA, float *fA, int nBod) { int i, j; float Xi, Yi, Zi; float Xij, Yij, Zij; // X[j] - X[i] and so on float Rij2; // Xij^2+Yij^2+Zij^2 float invRij2, invRij6; // 1/rij^2; 1/rij^6 float *rAx = &amp;rA[ 0]; //---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- float *fAx = &amp;fA[ 0]; //---- float *fAy = &amp;fA[ nBod]; // Pointers on X, Y, Z components of forces float *fAz = &amp;fA[2*nBod]; //---- float magForce; // Force magnitude float const EPS = 1.E-10; // Small value to prevent 0/0 if i==j #pragma omp parallel for num_threads(numProc) private(Xi, Yi, Zi, \ Xij, Yij, Zij, magForce, invRij2, invRij6, j) for (i = 0; i &lt; nBod; i++) { Xi = rAx[i]; Yi = rAy[i]; Zi = rAz[i]; fAx[i] = 0.0; fAy[i] = 0.0; fAz[i] = 0.0; for (j = 0; j &lt; nBod; j++) { Xij = rAx[j] - Xi; Yij = rAy[j] - Yi; Zij = rAz[j] - Zi; Rij2 = Xij*Xij + Yij*Yij + Zij*Zij; invRij2 = Rij2/((Rij2 + EPS)*(Rij2 + EPS)); invRij6 = invRij2*invRij2*invRij2; magForce = 6.0*invRij2*(2.0*invRij6 - 1.0)*invRij6; fAx[i]+= Xij*magForce; fAy[i]+= Yij*magForce; fAz[i]+= Zij*magForce; } } } // Integration of coordinates an velocities __attribute__ ((target(mic))) void integration(float *rA, float *vA, float *fA, int nBod) { int i; float const dt = 0.01; // Time step float const mass = 1.0; // mass of a body float const mdthalf = dt*0.5/mass; float *rAx = &amp;rA[ 0]; float *rAy = &amp;rA[ nBod]; float *rAz = &amp;rA[2*nBod]; float *vAx = &amp;vA[ 0]; float *vAy = &amp;vA[ nBod]; float *vAz = &amp;vA[2*nBod]; float *fAx = &amp;fA[ 0]; float *fAy = &amp;fA[ nBod]; float *fAz = &amp;fA[2*nBod]; #pragma omp parallel for num_threads(numProc) for (i = 0; i &lt; nBod; i++) { rAx[i]+= (vAx[i] + fAx[i]*mdthalf)*dt; rAy[i]+= (vAy[i] + fAy[i]*mdthalf)*dt; rAz[i]+= (vAz[i] + fAz[i]*mdthalf)*dt; vAx[i]+= fAx[i]*dt; vAy[i]+= fAy[i]*dt; vAz[i]+= fAz[i]*dt; } }</span></span></code> </pre><br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Conclusion </h1><br>  The only similarity between programming for the GPU and Xeon Phi is the need to take care of moving data between the host and the device, in fact, this is the difference from using OpenMP exclusively for the CPU.  It should be noted that the native compiler is able to automatically vectorize the code not only for the host, but also for the device, so you can get decent performance without much getting into the details. <br>  In my opinion, Xeon Phi is well suited if you already have ready code that works with OpenMP and you need to improve performance, but there is no desire / ability to rewrite for the GPU.  An important point, which will surely be enjoyed by people from the scientific community, is the support of Fortran. <br><br><h1>  useful links </h1><br>  <a href="http://www.prace-ri.eu/best-practice-guide-intel-xeon-phi-html/">www.prace-ri.eu/best-practice-guide-intel-xeon-phi-html</a> <br>  <a href="https://www.ichec.ie/infrastructure/xeonphi">www.ichec.ie/infrastructure/xeonphi</a> <br>  <a href="http://www.cism.ucl.ac.be/XeonPhi.pdf">www.cism.ucl.ac.be/XeonPhi.pdf</a> <br>  <a href="http://hpc-education.unn.ru/files/courses/XeonPhi/Lection03.pdf">hpc-education.unn.ru/files/courses/XeonPhi/Lection03.pdf</a> </div><p>Source: <a href="https://habr.com/ru/post/262019/">https://habr.com/ru/post/262019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262009/index.html">Teach telnet.exe to play the correct MUDs</a></li>
<li><a href="../262011/index.html">The first steps in working with Arduino</a></li>
<li><a href="../262013/index.html">Critical security update for node.js and io.js</a></li>
<li><a href="../262015/index.html">The mystery of flicker noise unraveled</a></li>
<li><a href="../262017/index.html">Shadow DOM: Specification</a></li>
<li><a href="../262021/index.html">Creating the simplest data structures using functions in Python</a></li>
<li><a href="../262023/index.html">Entity Framework through the eyes of a stranger</a></li>
<li><a href="../262025/index.html">Cohort analysis: 3 cases</a></li>
<li><a href="../262027/index.html">UNetLab emulator - revolutionary leap</a></li>
<li><a href="../262029/index.html">Load testing CMS "1C-Bitrix"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>