<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js Part 8 Tutorial: HTTP and WebSocket Protocols</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js is a server platform. The main task of the server is to process requests from clients, in particular - from browsers, as quickly and efficient...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js Part 8 Tutorial: HTTP and WebSocket Protocols</h1><div class="post__text post__text-html js-mediator-article">  Node.js is a server platform.  The main task of the server is to process requests from clients, in particular - from browsers, as quickly and efficiently as possible.  The eighth part of the translation guide for Node.js, which we publish today, is devoted to the protocols HTTP and WebSocket. <br><br> <a href="https://habr.com/company/ruvds/blog/424557/"><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[We advise to read] Other parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habr.com/company/ruvds/blog/422893/">General Information and Getting Started</a> <br>  Part 2: <a href="https://habr.com/company/ruvds/blog/423153/">JavaScript, V8, some design tricks</a> <br>  Part 3: <a href="https://habr.com/company/ruvds/blog/423701/">Hosting, REPL, work with the console, modules</a> <br>  Part 4: <a href="https://habr.com/company/ruvds/blog/423703/">npm, package.json and package-lock.json files</a> <br>  Part 5: <a href="https://habr.com/company/ruvds/blog/423705/">npm and npx</a> <br>  Part 6: <a href="https://habr.com/company/ruvds/blog/424553/">event loop, call stack, timers</a> <br>  Part 7: <a href="https://habr.com/company/ruvds/blog/424555/">Asynchronous Programming</a> <br>  Part 8: <a href="https://habr.com/company/ruvds/blog/424557/">Node.js Guide, part 8: HTTP and WebSocket protocols</a> <br>  Part 9: <a href="https://habr.com/company/ruvds/blog/424969/">Node.js Guide, part 9: working with the file system</a> <br>  Part 10: <a href="https://habr.com/company/ruvds/blog/425667/">Node.js Guide, part 10: standard modules, streams, databases, NODE_ENV</a> <br>  <a href="https://habr.com/company/ruvds/blog/428576/">Full PDF Node.js Manual</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What happens when making HTTP requests?</font> </h2><br>  Let's talk about how browsers perform requests to servers using the HTTP / 1.1 protocol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you have ever been interviewed in the IT field, then you might be asked about what happens when you type something into the address bar of the browser and press Enter.  Perhaps this is one of the most popular questions that is encountered at such interviews.  The one who asks such questions wants to know if you can explain some fairly simple concepts and find out if you understand the principles of the Internet. <br><br>  This question involves many technologies, to understand the general principles of which is to understand how one of the most complex systems ever built by mankind, which covers the whole world, is arranged. <br><br><h3>  <font color="#3AC1EF">HTTP HTTP Protocol</font> </h3><br>  Modern browsers are able to distinguish real URLs entered in their address bar from search queries, which are usually processed using the default search engine.  We will talk about URLs.  If you enter a site address, like <code>flaviocopes.com</code> , into a browser line, the browser converts this address to the form <code>http://flaviocopes.com</code> , assuming that the HTTP protocol will be used to exchange data with the specified resource.  Please note that on Windows, what we are going to talk about here may look a little different than on macOS and Linux. <br><br><h3>  <font color="#3AC1EF">DNS DNS Lookup Phase</font> </h3><br>  So, the browser, starting work on downloading data from the address requested by users, performs a DNS lookup (DNS Lookup) operation in order to find out the IP address of the corresponding server.  Character resource names entered in the address bar are convenient for people, but the Internet device implies the ability to exchange data between computers using IP addresses, which are sets of numbers like 222.324.3.1 (for IPv4). <br><br>  First, figuring out the IP address of the server, the browser looks in the local DNS cache in order to find out if a similar procedure has been performed recently.  In the Chrome browser, for example, there is a convenient way to view the DNS cache by typing the following address in the address bar: <code>chrome://net-internals/#dns</code> . <br><br>  If the cache does not find anything, the browser uses the POSIX <code>gethostbyname</code> system call to find out the IP address of the server. <br><br><h3>  <font color="#3AC1EF">GetGethostbyname feature</font> </h3><br>  The <code>gethostbyname</code> function first checks the <code>hosts</code> , which, on macOS or Linux, can be found at <code>/etc/hosts</code> , in order to find out whether it is possible to dispense with local information when figuring out the server address. <br><br>  If it is not possible to resolve the request for finding the IP address of the server by local means, the system executes the request to the DNS server.  Addresses of such servers are stored in the system settings. <br><br>  Here are a couple of popular DNS servers: <br><br><ul><li>  8.8.8.8: Google's DNS server. </li><li>  1.1.1.1: CloudFlare DNS Server. </li></ul><br>  Most people use the DNS servers provided by their providers.  The browser performs DNS queries using the UDP protocol. <br><br>  TCP and UDP are two basic protocols used in computer networks.  They are located at the same conceptual level, but TCP is a connection-oriented protocol, and for exchanging UDP messages, the processing of which creates a small additional load on the systems, the connection establishment procedure is not required.  We will not talk about exactly how data is exchanged via UDP. <br><br>  The IP address corresponding to the domain name in question may be in the cache of the DNS server.  If this is not the case, it will contact the root DNS server.  The root DNS server system consists of 13 servers on which the entire Internet depends. <br><br>  It should be noted that the root DNS server is unknown correspondences between all existing domain names in the world and IP addresses.  But such servers know the addresses of top-level DNS servers for domains such as .com, .it, .pizza, and so on. <br><br>  After receiving the request, the root DNS server redirects it to the DNS server of the top-level domain, to the so-called TLD server (from the Top-Level Domain). <br><br>  Suppose a browser is looking for an IP address for the <code>flaviocopes.com</code> server.  By accessing the root DNS server, the browser will receive from it the TLD server address for the .com zone.  Now this address will be stored in the cache, as a result, if you need to know the IP address of another URL from the .com zone, the root DNS server will not have to be contacted again. <br><br>  TLD servers have IP addresses of name servers (Name Server, NS), which can be used to find out the IP address from the URL we have.  Where do NS servers get this information from?  The fact is that if you buy a domain, the domain registrar sends data about it to the name servers.  A similar procedure is performed, for example, when changing hosting. <br><br>  The servers in question are usually owned by hosting providers.  As a rule, to protect against failures, several such servers are created.  For example, they may have the following addresses: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  To find out the IP address at the URL, in the end, refer to such servers.  It is they who keep current data about IP addresses. <br><br>  Now, after we managed to find out the IP address behind the URL entered in the address bar of the browser, we proceed to the next step of our work. <br><br><h3>  <font color="#3AC1EF">‚ñç TCP connection establishment</font> </h3><br>  Having learned the server‚Äôs IP address, the client can initiate a TCP connection procedure to it.  In the process of establishing a TCP connection, the client and the server send each other some service data, after which they will be able to exchange information.  This means that after the connection is established, the client will be able to send a request to the server. <br><br><h3>  <font color="#3AC1EF">Sending a request</font> </h3><br>  A request is a structured text according to the rules of the protocol used.  It consists of three parts: <br><br><ul><li>  Query string </li><li>  Request header </li><li>  Body request. </li></ul><br><h4>  Query string </h4><br>  The query string is a single text string that contains the following information: <br><br><ul><li>  HTTP method. </li><li>  Resource address </li><li>  Protocol version. </li></ul><br>  For example, it may look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  Request header </h4><br>  The request header is represented by a pair of <code>: </code> .  There are 2 required header fields, one of which is <code>Host</code> , and the second is <code>Connection</code> .  The remaining fields are optional. <br><br>  The headline might look like this: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  The <code>Host</code> field indicates the domain name that the browser is interested in.  The <code>Connection</code> field set to the <code>close</code> value means that the connection between the client and the server does not need to be kept open. <br><br>  Other commonly used query headers include the following: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  In fact, there are many more. <br><br>  The request header ends with an empty string. <br><br><h4>  Request body </h4><br>  The request body is optional, it is not used in GET requests.  The request body is used in POST requests, as well as in other requests.  It may contain, for example, data in JSON format. <br><br>  Since now we are talking about a GET request, the request body will be empty, we will not work with it. <br><br><h3>  <font color="#3AC1EF">‚ñç Answer</font> </h3><br>  After the server receives the request sent by the client, it processes it and sends a response to the client. <br><br>  The response starts with a status code and a corresponding message.  If the request is successful, the beginning of the response will look like this: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  If something went wrong, there may be other codes.  For example, the following: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  The response further contains a list of HTTP headers and the response body (which, since the request is executed by the browser, will be HTML code). <br><br><h4>  HTML parsing </h4><br>  After the browser receives a response from the server, the body of which contains the HTML code, it begins to parse it, repeating the above process for each resource that is needed to form the page.  These resources include, for example, the following: <br><br><ul><li>  CSS files. </li><li>  Images. </li><li>  Webpage icon (favicon). </li><li>  Javascript files </li></ul><br>  The way the browser displays the page does not apply to our conversation.  The main thing that interests us here is that the above-described process of requesting and receiving data is used not only for the HTML code, but also for any other objects transmitted from the server to the browser using the HTTP protocol. <br><br><h2>  <font color="#3AC1EF">About creating a simple server using Node.js</font> </h2><br>  Now, after we have analyzed the interaction between the browser and the server, you can take a fresh look at the First Node.js application section from the <a href="https://habr.com/company/ruvds/blog/422893/">first part of</a> this series of materials, in which we described the simple server code. <br><br><h2>  <font color="#3AC1EF">Making HTTP requests using Node.js</font> </h2><br>  To execute HTTP requests using Node.js, the corresponding <a href="http.html">module is used</a> .  The examples below use the <a href="https.html">https</a> module.  The fact is that in modern conditions, whenever possible, it is necessary to use the HTTPS protocol. <br><br><h3>  <font color="#3AC1EF">‚ñç GET requests</font> </h3><br>  Here is an example of performing a GET request using Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPOST request execution</font> </h3><br>  Here's how to perform a POST request from Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPUT and DELETE requests</font> </h3><br>  The execution of such requests looks the same as the execution of POST requests.  The main difference, in addition to the semantic content of such operations, is the value of the <code>method</code> property of the <code>options</code> object. <br><br><h3>  <font color="#3AC1EF">‚ñçExecuting HTTP requests in Node.js using the Axios library</font> </h3><br>  Axios is a very popular JavaScript library that also works in a browser (this includes all modern browsers and IE, starting with IE8), and in Node.js, which can be used to perform HTTP requests. <br><br>  This library is based on promises, it has some advantages over standard mechanisms, in particular, over API Fetch.  Among its advantages are the following: <br><br><ul><li>  Support for older browsers (you need a polyfill to use Fetch). </li><li>  Ability to interrupt requests. </li><li>  Support setting timeouts for requests. </li><li>  Built-in protection against CSRF attacks. </li><li>  Support for uploading data providing progress information on this process. </li><li>  Support JSON data conversion. </li><li>  Work at Node.js </li></ul><br><h4>  Installation </h4><br>  To install the Axios, you can use npm: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  The same effect can be achieved when working with yarn: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  You can connect the library to the page using <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API Axios </h4><br>  You can execute an HTTP request using the <code>axios</code> object: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  But it is usually more convenient to use special methods: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  This is similar to how jQuery uses <code>$.get()</code> and <code>$.post()</code> instead of <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios offers separate methods for performing other types of HTTP requests that are not as popular as GET and POST, but are still used: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  The library has a method for executing a query designed to get only HTTP headers, without the response body: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  GET requests </h4><br>  Axios is convenient to use with the use of the modern syntax async / await.  In the following sample code for Node.js, the library is used to load a list of dog breeds from <a href="https://dog.ceo/">the Dog API</a> .  Here the <code>axios.get()</code> method is used and the rocks are calculated: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  The same can be rewritten without using async / await, using promises: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Using Parameters in GET Requests </h4><br>  A GET request may contain parameters that look like this in a URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  With Axios, this kind of query can be done like this: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  The same effect can be achieved by setting the <code>params</code> property in an object with parameters: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  POST requests </h4><br>  The execution of POST requests is very similar to the execution of GET requests, but here, instead of the <code>axios.get()</code> method, the <code>axios.post()</code> method is used: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  As a second argument, the <code>post</code> method takes an object with query parameters: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Using the WebSocket protocol in Node.js</font> </h2><br>  WebSocket is an alternative to HTTP, it can be used to organize data exchange in web applications.  This protocol allows you to create long-lived bidirectional communication channels between the client and the server.  After the connection is established, the communication channel remains open, which gives the application a very fast connection, characterized by low latency and a small additional load on the system. <br><br>  The WebSocket protocol is supported by all modern browsers. <br><br><h3>  <font color="#3AC1EF">‚ñçDifference from HTTP</font> </h3><br>  HTTP and WebSocket are very different protocols that use different approaches to data exchange.  HTTP is based on the request-response model: the server sends some data to the client after it has been requested.  In the case of WebSocket, everything is different.  Namely: <br><br><ul><li>  The server can send messages to the client on its own initiative, without waiting for a request from the client. </li><li>  Client and server can exchange data simultaneously. </li><li>  When sending a message is used extremely small amount of service data.  This, in particular, leads to low data transfer delays. </li></ul><br>  The WebSocket protocol is very well suited for real-time communication through channels that remain open for a long time.  HTTP, in turn, is great for organizing episodic communication sessions initiated by the client.  At the same time, it should be noted that, from the point of view of programming, implementing data exchange via the HTTP protocol is much easier than using the WebSocket protocol. <br><br><h3>  <font color="#3AC1EF">Secure version of WebSocket protocol</font> </h3><br>  There is an insecure version of the WebSocket protocol (URI scheme <code>ws://</code> ), which resembles <code>http://</code> in terms of security.  The use of <code>ws://</code> should be avoided, preferring the protected version of the protocol - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Creating WebSocket connections</font> </h3><br>  To create a WebSocket connection, you need to use the appropriate <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">constructor</a> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  After a successful connection is established, the <code>open</code> event is raised.  You can listen to this event by assigning the callback function to the <code>onopen</code> property of the <code>connection</code> object: <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  For error handling, the <code>onerror</code> event handler is used: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçSending data to server</font> </h3><br>  After opening the WebSocket connection to the server, you can send data to it.  This can be done, for example, in the onopen <code>onopen</code> : <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçReceiving data from the server</font> </h3><br>  To receive data sent from the server using the WebSocket protocol, you can assign an onmessage <code>onmessage</code> to be called when the <code>message</code> event is received: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Implementing a WebSocket server in Node.js environment</font> </h3><br>  In order to implement a WebSocket server in the Node.js environment, you can use the popular <a href="https://github.com/websockets/ws">ws</a> library.  We will use it for server development, but it is suitable for creating clients and for organizing interaction between two servers. <br><br>  Install this library by initializing the project: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  The WebSocket server code that we need to write is rather compact: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Here we create a new server that listens on port 8080, which is standard for the WebSocket protocol, and describe a callback that, when the connection is established, sends the <code>ho!</code> Message to the client <code>ho!</code>  and displays in the console the message received from the client. <br><br>  <a href="https://glitch.com/edit/">Here is a</a> working example of a WebSocket server, and <a href="https://glitch.com/edit/">here</a> is a client that can interact with it. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we talked about the networking mechanisms supported by the Node.js platform, drawing parallels with similar mechanisms used in browsers.  Our next topic will be working with files. <br><br>  <b>Dear readers!</b>  Do you use the WebSocket protocol in your web applications, the server part of which was created using Node.js? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/424557/">https://habr.com/ru/post/424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424543/index.html">Java 11 / JDK 11: General Availability</a></li>
<li><a href="../424545/index.html">How to understand that planning a sprint went well?</a></li>
<li><a href="../424551/index.html">Warm and lamp: five balalaika about magnetic recording technology</a></li>
<li><a href="../424553/index.html">Node.js tutorial, part 6: event loop, call stack, timers</a></li>
<li><a href="../424555/index.html">Node.js tutorial, part 7: asynchronous programming</a></li>
<li><a href="../424559/index.html">Big Data resistance 1 or elusive Joe. Internet anonymity, anti-detection, anti-tracking for anti-you and anti-us</a></li>
<li><a href="../424561/index.html">Russian program to create a global satellite Internet network may lose a single investor</a></li>
<li><a href="../424563/index.html">Beeline sends details of conversations to strangers</a></li>
<li><a href="../424565/index.html">Review: 3D scanning of real estate premises</a></li>
<li><a href="../424567/index.html">Experience blocking online advertising in the company's local network</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>