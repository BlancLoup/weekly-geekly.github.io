<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modern approach to competition in Android: Korutin in Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 We remind you that we have already opened a pre-order for the long-awaited book about the Kotlin language from the famous Big Nerd Ranch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modern approach to competition in Android: Korutin in Kotlin</h1><div class="post__text post__text-html js-mediator-article"> Hi, Habr! <br><br>  We remind you that we have already opened a <a href="https://www.piter.com/collection/soon/product/kotlin-programmirovanie-dlya-professionalov">pre-order for the long-awaited book</a> about the Kotlin language from the famous Big Nerd Ranch Guides series.  Today we decided to bring to your attention a translation of an article telling about Kotlin's quilts and the correct work with streams in Android.  The topic is being discussed very actively, so for the sake of completeness we also recommend viewing <a href="https://habr.com/ru/post/445242/">this article</a> from Habr and <a href="https://axmor.ru/blog/primenyaem-kotlin-coroutines-v-boevom-android-proekte/">this detailed post</a> from the Axmor Software blog. <br><a name="habracut"></a><br>  A modern Java / Android framework for concurrency creates callback hell and leads to blocking states, since Android does not have a simple enough way to guarantee thread safety. <br><br>  Kotlin Korutin is a very efficient and complete toolkit that makes managing competitiveness much easier and more productive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Suspending and blocking: what's the difference</b> <br><br>  Cortinas do not replace threads, but rather provide a framework for managing them.  The coruntine philosophy is to define a context that allows <b>one</b> to <b>wait</b> until the background operations have completed without blocking the main stream. <br><br>  The goal of Corutin in this case is to avoid callbacks and simplify competition. <br><br>  <b>Simplest example</b> <br><br>  To begin with, let's take the simplest example: let's run coruntine in the context of <code>Main</code> (main thread).  In it, we will extract the image from the <code>IO</code> stream and send this image back to <code>Main</code> for processing. <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  The code is simple as a single-threaded function.  Moreover, while <code>getImage</code> is executed in a dedicated pool of <code>IO</code> threads, the main thread is free and can take on any other task!  The withContext function suspends the current coruntine while its action is running ( <code>getImage()</code> ).  As soon as <code>getImage()</code> returns and the <code>looper</code> from the main thread becomes available, the coroutine will resume work in the main thread and call <code>imageView.setImageBitmap(image)</code> . <br><br>  The second example: now we need to have 2 background tasks performed so that they can be used.  We will use the async / await duet to make these two tasks run in parallel, and use their result in the main thread as soon as both tasks are ready: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> is similar to <code>launch</code> , but returns <code>deferred</code> (Kotlin entity equivalent to <code>Future</code> ), so its result can be obtained using <code>await()</code> .  When called without parameters, it works in the default context for the current scope. <br><br>  Again, the main thread remains free while we wait for our 2 values. <br>  As you can see, the <code>launch</code> function returns a <code>Job</code> , which can be used to wait until the operation completes ‚Äî this is done using the <code>join()</code> function.  It works like in any other language, with the proviso that it simply <b>suspends coruntine, and does not block the flow</b> . <br><br>  <b>Dispatching</b> <br><br>  Dispatching is a key concept when working with Corutin.  This is an action that allows you to "jump" from one thread to another. <br><br>  Consider how the equivalent for dispatching in <code>Main</code> looks in java, that is, <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  The implementation of the <code>Main</code> context for Android is a <code>Handler</code> based dispatcher.  So this is really a very suitable implementation: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> sends <code>Runnable</code> to <code>Handler</code> , so its code is not executed immediately. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> will immediately execute its lambda expression in the current thread. <br><br>  <code>Dispatchers.Main</code> <b>ensures that when the corutin resumes work, it will be sent to the main stream</b> ;  In addition, Handler is used here as the native Android implementation for sending app events to the loop. <br><br>  The exact implementation looks like this: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Here is a good article to help you understand the subtleties of dispatching in Android: <br>  <a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a">Understanding Android Core: Looper, Handler, and HandlerThread</a> . <br><br>  <b>Context korutiny</b> <br><br>  The korutina context (also known as the korutina manager) determines in which thread its code will run, what to do if an exception is thrown, and accesses the parent context to propagate the cancellation. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> will cancel all coroutines whose parent is <code>job</code> .  A exceptionHandler will receive all the exceptions thrown in these quiches. <br><br>  <b>Area of ‚Äã‚Äãvisibility</b> <br><br>  The <code>coroutineScope</code> interface simplifies error handling: <br>  If any of its subsidiary Corutin fails, then all scope and all subsidiary Corutins will fail. <br><br>  In the <code>async</code> example, if the value could not be retrieved, another task continued to work - we have a damaged state, and something needs to be done about it. <br><br>  When working with <code>coroutineScope</code> , the <code>useValues</code> function will be called only if the retrieval of both values ‚Äã‚Äãwas successful.  Also, if <code>deferred2</code> fails, <code>deferred1</code> will be canceled. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  You can also ‚Äúput in the scope‚Äù a whole class to set its default <code>CoroutineContext</code> context and use it. <br><br>  An example of a class that implements the <code>CoroutineScope</code> interface: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Running Corutin in <code>CoroutineScope</code> : <br><br>  The <code>launch</code> or <code>async</code> default dispatcher now becomes the dispatcher of the current scope. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { ‚Ä¶ } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   ‚Ä¶ } launch(Dispatchers.Default) { // -        ‚Ä¶ }</span></span></code> </pre> <br>  Autonomous launch of the coroutine (outside of any CoroutineScope): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . ‚Ä¶ }</span></span></code> </pre> <br>  You can even define the scope for an application by setting the default <code>Main</code> Manager: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Remarks</b> <br><br><ul><li>  Korutiny limit Java interoperability </li><li>  Limit volatility to avoid blocking </li><li>  Korutiny designed to wait, not to organize the flow </li><li>  Avoid I / O in <code>Dispatchers.Default</code> (and <code>Main</code> ...) - Dispatchers.IO is designed for this </li><li>  Threads are resource intensive, so single-threaded contexts are used. </li><li>  <code>Dispatchers.Default</code> based on <code>ForkJoinPool</code> , which appeared in Android 5+ </li><li>  Korutin can be used through channels </li></ul><br>  <b>We get rid of locks and callbacks using channels</b> <br><br>  Channel definition from the JetBrains documentation: <br><br><blockquote>  <code>Channel</code> conceptually very similar to <code>BlockingQueue</code> .  The key difference is that it does not block the put operation, it provides a suspending <code>send</code> (or nonblocking <code>offer</code> ), and instead of blocking a take operation it provides a suspending <code>receive</code> . </blockquote><br><br>  <b>Actors</b> <br><br>  Consider a simple tool for working with channels: <code>Actor</code> . <br><br>  <code>Actor</code> , again, is very similar to <code>Handler</code> : we define the context of the korutina (that is, the stream in which we are going to perform the actions) and work with it in a sequential order. <br><br>  The difference, of course, is that cortinas are used here;  <b>You can specify the power, and the executable code - pause</b> . <br><br>  Basically, <code>actor</code> will redirect any command to the cortina channel.  It <b>guarantees the execution of a command and restricts operations in its context</b> .  This approach perfectly helps to get rid of <code>synchronize</code> calls and keep all streams free! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  In this example, we use the sealed Kotlin classes, choosing which action to perform. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  Moreover, all these actions will be put in a queue, they will never be executed in parallel.  This is a convenient way to <b>limit the variability</b> . <br><br>  <b>Android + Cortina Life Cycle</b> <br><br>  Actors can be very useful for controlling the user interface of Android, simplify the cancellation of tasks and prevent overloading the main stream. <br>  Let's implement this and call <code>job.cancel()</code> when destroying activity. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  The <code>SupervisorJob</code> class is similar to the normal <code>Job</code> with the only exception that cancellation only extends in the downstream direction. <br><br>  Therefore, we do not cancel all of the Korutin in the <code>Activity</code> , when one of them refuses. <br><br>  Slightly better is the <a href="https://kotlinlang.org/docs/reference/extensions.html">extension function</a> , which allows access to this <code>CoroutineContext</code> from any <code>View</code> in <code>CoroutineScope</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Now we can combine all of this, the <code>setOnClick</code> function creates a combined actor to control its <code>onClick</code> actions.  In the case of multiple clicks, intermediate actions will be ignored, thus eliminating ANR errors (the application is not responding), and these actions will be performed within the scope of the <code>Activity</code> .  Therefore, if you destroy the activity, all this will be canceled. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  In this example, we set the value for the <code>Channel</code> to be <code>Conflated</code> , so that it ignores part of the events if there are too many of them.  You can replace it with <code>Channel.UNLIMITED</code> if you prefer to queue events without losing any of them, but you still want to protect the application from ANR errors. <br><br>  You can also combine cortices and lifecycle frameworks to automate the cancellation of tasks associated with the user interface: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Simplify callbacks (part 1)</b> <br><br>  Here's how to transform the use of call-based APIs with <code>Channel</code> . <br><br>  The API works like this: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> initiates a parsing of the folder located at <code>url</code> . </li><li>  The <code>listener</code> receives <code>onMediaAdded(media: Media)</code> for any media file found in this folder. </li><li>  <code>listener.onBrowseEnd()</code> is called upon completion of the folder parsing </li></ol><br>  Here is the old <code>refresh</code> function in the content provider for the VLC browser: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>How to improve it?</b> <br><br>  Create a channel that will run in <code>refresh</code> .  Now browser callbacks will only send media to this channel, and then close it. <br><br>  Now the <code>refresh</code> function has become clearer.  It creates a channel, calls the VLC browser, then builds a list of media files and processes it. <br><br>  Instead of the <code>select</code> or <code>consumeEach</code> you can use <code>for</code> to wait for the media, and this cycle will break as soon as the <code>browserChannel</code> channel closes. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Simplify callbacks (part 2): Retrofit</b> <br><br>  The second approach: we do not use kotlinx cortuins at all, but we use a corutin core framework. <br><br>  See how the Korutins actually work! <br><br>  The <code>retrofitSuspendCall</code> function wraps the request for a <code>Retrofit Call</code> to make it a <code>suspend</code> function. <br><br>  With the help of <code>suspendCoroutine</code> we call the <code>Call.enqueue</code> method and suspend the coruntine.  The callback provided in this way will apply to <code>continuation.resume(response)</code> to resume the quortenine response from the server as soon as it is received. <br><br>  Next, we just have to combine our Retrofit functions into <code>retrofitSuspendCall</code> , in order to use them to return query results. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Thus, the call blocking the network is made in the selected Retrofit stream, the quortenine is here, waiting for a response from the server, and there is no place to use it in the application! <br><br>  This implementation is inspired by the <a href="https://github.com/gildor/kotlin-coroutines-retrofit">gildor / kotlin-coroutines-retrofit library</a> . <br><br>  There is also a <a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter">JakeWharton / retrofit2-kotlin-coroutines-adapter</a> with a different implementation, giving a similar result. <br><br>  <b>Epilogue</b> <br><br>  <code>Channel</code> can be used in many other ways;  Look at <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-broadcast-channel/index.html">BroadcastChannel for</a> more powerful implementations that may be useful to you. <br><br>  You can also create channels using the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">Produce</a> function. <br><br>  Finally, using channels, it is convenient to organize communication between UI components: the adapter can transmit click events to its fragment / activity via the <code>Channel</code> or, for example, via <code>Actor</code> . </div><p>Source: <a href="https://habr.com/ru/post/457224/">https://habr.com/ru/post/457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457202/index.html">How we choose ideas for the development of our products: the vendor must be able to hear ...</a></li>
<li><a href="../457204/index.html">Windows PowerShell and Long Paths</a></li>
<li><a href="../45721/index.html">Nostalgia for sega</a></li>
<li><a href="../457210/index.html">Keep static resources on your hosting</a></li>
<li><a href="../457212/index.html">Why is it not too late to start learning Java (or other PLs)</a></li>
<li><a href="../45723/index.html">Pocket Plextor</a></li>
<li><a href="../457232/index.html">Bumble Robop Bead - the first test flight inside the ISS</a></li>
<li><a href="../457234/index.html">Cognitive distortions during product creation</a></li>
<li><a href="../457236/index.html">How did an IT company fight for the right to sell music</a></li>
<li><a href="../45724/index.html">Dual-core player</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>