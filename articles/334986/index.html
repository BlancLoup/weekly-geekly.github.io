<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comedy. Actors in Node.JS for flexible scaling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, habravchane! In this article I will introduce you to the Comedy framework - the implementation of actors in Node.JS. Actors allow you to scale ind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comedy. Actors in Node.JS for flexible scaling</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, habravchane!  In this article I will introduce you to the <a href="https://github.com/untu/comedy">Comedy</a> framework - the implementation of actors in Node.JS.  Actors allow you to scale individual modules of your Node.JS application without changing the code. </p><a name="habracut"></a><br><h1 id="ob-aktorah">  About actors </h1><br><p>  Although the model of actors is quite popular today, not everyone knows about it.  Despite the somewhat intimidating <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">Wikipedia article</a> , the actors are very simple. </p><br><p>  What is an actor?  This is such a thing that can: </p><br><ul><li>  receive messages </li><li>  send messages </li><li>  create child actors </li></ul><br><p><img src="https://habrastorage.org/web/f3c/a14/944/f3ca149442a04546b79f3b4cf6155b78.png" alt="image"></p><br><p>  The only way to do something with the actor is to send him a message.  The internal state of the actor is completely isolated from the outside world.  Due to this, the actor is a universal unit for scaling an application.  And its ability to generate subsidiary actors makes it possible to form a clear structure of modules with a clear division of responsibilities. </p><br><p>  I understand it sounds a bit abstract.  Below we will look at a specific live example, how the work with actors and Comedy is going on.  But first ... </p><br><h1 id="zachem-eto-vsyo">  Why is it all </h1><br><p>  ... first motivation. </p><br><p>  All those who program on Node.JS (yours truly among them) are well aware that Node.JS is single-threaded.  On the one hand, this is good, as it saves us from a whole class of very dumb and hardly reproducible bugs - multi-threaded bugs.  In our applications, such bugs can not be fundamentally, and this greatly reduces the cost and speeds up development. </p><br><p>  On the other hand, this limits the scope of applicability of Node.JS.  It is great for network-intensive applications with a relatively small computational load, but for CPU-intensive applications it is not good, because intensive calculations block our precious single stream, and everything gets up with a stake.  We know that very well. </p><br><p>  We also know that any real application still consumes a certain amount of CPUs (even if we have no business logic at all, we need to handle network traffic at the application level ‚Äî HTTP is there, database protocols, etc.).  And as the load grows, we still sooner or later arrive at a situation where our only thread consumes 100% of the core power.  What happens in this case?  We do not have time to process messages, the queue of tasks accumulates, the response time grows, and then bang!  - out of memory. </p><br><p>  And here we come to the situation when we need to scale our application into several CPU cores.  And ideally, we do not want to limit ourselves to the cores on only one machine - we may need several machines.  And at the same time, we want to rewrite our application as little as possible.  It's great if the application is scaled by a simple configuration change.  And even better - automatically, depending on the load. </p><br><p>  And here actors come to our aid. </p><br><h1 id="prakticheskiy-primer-servis-prostyh-chisel">  Practical example: prime numbers service </h1><br><p>  In order to demonstrate how Comedy works, I sketched a small <a href="">example</a> : microservice, which finds primes.  Access to the service through the REST API. </p><br><p>  Of course, the search for prime numbers is a purely CPU-intensive task.  If we in real life designed such a service, we would have to think ten times before choosing Node.JS.  But in this case, we just deliberately chose a computational task to make it easier to reproduce the situation when one core is not enough. </p><br><p>  So.  Let's start with the essence of our service - we implement an actor that finds primes.  Here is his code: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Actor that finds prime numbers. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFinderActor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Finds next prime, starting from a given number (not inclusive). * * @param {Number} n Positive number to start from. * @returns {Number} Prime number next to n. */</span></span> nextPrime(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Illegal input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0 = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._isPrime(n0)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n0; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nextPrime(n0); } <span class="hljs-comment"><span class="hljs-comment">/** * Checks if a given number is prime. * * @param {Number} x Number to check. * @returns {Boolean} True if number is prime, false otherwise. * @private */</span></span> _isPrime(x) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; x; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  The <code>nextPrime()</code> method finds a prime number following the specified (not necessarily simple).  The method uses tail recursion, which is exactly supported in Node.JS 8 (to run the example, you will need to take Node.JS at least version 8, since there will still be async-await).  The method uses an auxiliary method <code>_isPrime()</code> , which checks the number for simplicity.  This is not the most optimal algorithm for such verification, but for our example it is only better. </p><br><p>  What we see in the code above, on the one hand, is a regular class.  On the other hand, for us, this is the so-called <em>definition of the actor</em> , that is, a description of the behavior of the actor.  The class describes which messages the actor can receive (each method is a message handler with the same topic), what it does when accepting these messages (method implementation) and which one produces the result (return value). </p><br><p>  At the same time, since this is a normal class, we can write a unit-test for it and easily test the correctness of its implementation. </p><br><div class="spoiler">  <b class="spoiler_title">Unit test may look something like this.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'PrimeFinderActor'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should correctly find next prime'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrimeFinderActor(); expect(pf.nextPrime(<span class="hljs-number"><span class="hljs-number">1</span></span>)).to.be.equal(<span class="hljs-number"><span class="hljs-number">2</span></span>); expect(pf.nextPrime(<span class="hljs-number"><span class="hljs-number">2</span></span>)).to.be.equal(<span class="hljs-number"><span class="hljs-number">3</span></span>); expect(pf.nextPrime(<span class="hljs-number"><span class="hljs-number">3</span></span>)).to.be.equal(<span class="hljs-number"><span class="hljs-number">5</span></span>); expect(pf.nextPrime(<span class="hljs-number"><span class="hljs-number">30</span></span>)).to.be.equal(<span class="hljs-number"><span class="hljs-number">31</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should only accept positive numbers'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrimeFinderActor(); expect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> pf.nextPrime(<span class="hljs-number"><span class="hljs-number">0</span></span>)).to.throw(); expect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> pf.nextPrime(<span class="hljs-number"><span class="hljs-number">-1</span></span>)).to.throw(); }); });</code> </pre> </div></div><br><p>  Now we have a prime number actor. </p><br><p><img src="https://habrastorage.org/web/7f3/70a/8cd/7f370a8cd2b4488eb31bc326def598f1.png" alt="image"></p><br><p>  Our next step is to implement the actor of the REST server.  Here is what its definition will look like: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restify = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'restify'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restifyErrors = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'restify-errors'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> P = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Prime numbers REST server actor. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestServerActor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Actor initialization hook. * * @param {Actor} selfActor Self actor instance. * @returns {Promise} Initialization promise. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> initialize(selfActor) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.log = selfActor.getLog(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.primeFinder = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> selfActor.createChild(PrimeFinderActor); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._initializeServer(); } <span class="hljs-comment"><span class="hljs-comment">/** * Initializes REST server. * * @returns {Promise} Initialization promise. * @private */</span></span> _initializeServer() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = restify.createServer({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'prime-finder'</span></span> }); <span class="hljs-comment"><span class="hljs-comment">// Set 10 minutes response timeout. server.server.setTimeout(60000 * 10); // Define REST method for prime number search. server.get('/next-prime/:n', (req, res, next) =&gt; { this.log.info(`Handling next-prime request for number ${req.params.n}`); this.primeFinder.sendAndReceive('nextPrime', parseInt(req.params.n)) .then(result =&gt; { this.log.info(`Handled next-prime request for number ${req.params.n}, result: ${result}`); res.header('Content-Type', 'text/plain'); res.send(200, result.toString()); }) .catch(err =&gt; { this.log.error(`Failed to handle next-prime request for number ${req.params.n}`, err); next(new restifyErrors.InternalError(err)); }); }); return P.fromCallback(cb =&gt; { server.listen(8080, cb); }); } }</span></span></code> </pre> <br><p>  What is going on in it?  The main and only thing - it has a method <code>initialize()</code> .  This method will be called Comedy when the actor is initialized.  A <em>copy of the</em> actor is passed to it.  This is the very thing in which you can send messages.  The <em>instance</em> has a number of useful methods.  <code>getLog()</code> returns a logger for the actor (it will be useful to us), and using the <code>createChild()</code> method we create a child actor - the very <code>PrimeFinderActor</code> that we implemented at the very beginning.  In <code>createChild()</code> we pass the definition of the actor, and we get in return a promise that will be resolved as soon as the child actor is initialized and gives us a <em>copy of the</em> created child actor. </p><br><p>  As you noticed, the initialization of the actor is an asynchronous operation.  Our <code>initialize()</code> method is also asynchronous (it returns a promise).  Accordingly, our <code>RestServerActor</code> will be considered initialized only when the promise is cleared (well, not to write "the promise will be fulfilled"), given by the method <code>initialize()</code> . </p><br><p>  Ok, we created a child <code>PrimeFinderActor</code> , waited for it to initialize and assigned a reference to the <code>primeFinder</code> .  Small things remained - to configure the REST server.  We do this in the <code>_initializeServer()</code> method (it is also asynchronous) using the <code>Restify</code> library. </p><br><p>  We create a single request handler (‚Äúhandle‚Äù) for the <code>GET /next-prime/:n</code> method, which calculates the next following integer, sending a message to the child <code>PrimeFinderActor</code> actor and receiving a response from it.  We send the message using the <code>sendAndReceive()</code> method, the first parameter is the name of the topic ( <code>nextPrime</code> , by method name) and the next parameter is the message.  In this case, the message is just a number, but there may be a string, and an object with data, and an array.  The <code>sendAndReceive()</code> method is asynchronous, returns a promise with the result. </p><br><p>  Almost done.  We have one more trifle left: to run it all.  We add a couple of lines to our example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actors = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'comedy'</span></span>); actors({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: RestServerActor });</code> </pre> <br><p>  Here we create a <em>system of actors</em> .  As parameters, we specify the definition of the root (the parent itself) actor.  They are <code>RestServerActor</code> . </p><br><p>  It turns out this hierarchy: </p><br><p><img src="https://habrastorage.org/web/1ea/50d/80f/1ea50d80f0f145beb97adc2e278abca8.png" alt="image"></p><br><p>  We are lucky with the hierarchy, it is quite simple! </p><br><div class="spoiler">  <b class="spoiler_title">Real hierarchy example</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/5bd/568/d98/5bd568d981c7400db04b8f26da0fd0af.png" alt="image"></p></div></div><br><p>  Well, run the application and test? </p><br><pre> <code class="bash hljs">$ nodejs prime-finder.js Mon Aug 07 2017 15:34:37 GMT+0300 (MSK) - info: Resulting actor configuration: {}</code> </pre> <br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/30; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 31</code> </pre> <br><p>  Works!  Let's experiment with: </p><br><pre> <code class="bash hljs">$ time curl http://localhost:8080/next-prime/30 31 real 0m0.015s user 0m0.004s sys 0m0.000s $ time curl http://localhost:8080/next-prime/3000000 3000017 real 0m0.045s user 0m0.008s sys 0m0.000s $ time curl http://localhost:8080/next-prime/300000000 300000007 real 0m2.395s user 0m0.004s sys 0m0.004s $ time curl http://localhost:8080/next-prime/3000000000 3000000019 real 5m11.817s user 0m0.016s sys 0m0.000s</code> </pre> <br><p>  As the starting number increases, the request processing time increases.  Particularly impressive is the transition from three hundred million to three billion.  Let's try parallel queries: </p><br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/3000000000 &amp; [1] 32440 $ curl http://localhost:8080/next-prime/3000000000 &amp; [2] 32442</code> </pre> <br><p>  In the top, we see that one core is fully occupied. </p><br><pre> <code class="bash hljs"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 32401 weekens 20 0 955664 55588 20956 R 100,0 0,7 1:45.19 node</code> </pre> <br><p>  In the server log we see: </p><br><pre> <code class="bash hljs">Mon Aug 07 2017 16:05:45 GMT+0300 (MSK) - info: InMemoryActor(5988659a897e307e91fbc2a5, RestServerActor): Handling next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000</code> </pre> <br><p>  That is, the first request is executed, and the second just waits. </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">jobs</span></span> [1]-  curl http://localhost:8080/next-prime/3000000000 &amp; [2]+  curl http://localhost:8080/next-prime/3000000000 &amp;</code> </pre> <br><p>  This is exactly the situation that was described: we lack one core.  We need more cores! </p><br><h1 id="showtime">  Showtime! </h1><br><p>  So, it is time to scale out.  All our further actions will not require modification of the code. </p><br><p>  Let's first <code>PrimeFinderActor</code> into a separate subprocess.  In itself, this action is quite useless, but I want to bring you up to date gradually. </p><br><p>  We create the <code>actors.json</code> file in the project root directory with the following contents: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"PrimeFinderActor"</span></span>: { <span class="hljs-string"><span class="hljs-string">"mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"forked"</span></span> } }</code> </pre> <br><p>  And restart the example.  What happened?  We look into the list of processes: </p><br><pre> <code class="bash hljs">$ ps ax | grep nodejs 12917 pts/19 Sl+ 0:00 nodejs prime-finder.js 12927 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor $ pstree -a -p 12917 nodejs,12917 prime-finder.js ‚îú‚îÄnodejs,12927 /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor ‚îÇ ‚îú‚îÄ{V8 WorkerThread},12928 ‚îÇ ‚îú‚îÄ{V8 WorkerThread},12929 ‚îÇ ‚îú‚îÄ{V8 WorkerThread},12930 ‚îÇ ‚îú‚îÄ{V8 WorkerThread},12931 ‚îÇ ‚îî‚îÄ{nodejs},12932 ‚îú‚îÄ{V8 WorkerThread},12918 ‚îú‚îÄ{V8 WorkerThread},12919 ‚îú‚îÄ{V8 WorkerThread},12920 ‚îú‚îÄ{V8 WorkerThread},12921 ‚îú‚îÄ{nodejs},12922 ‚îú‚îÄ{nodejs},12923 ‚îú‚îÄ{nodejs},12924 ‚îú‚îÄ{nodejs},12925 ‚îî‚îÄ{nodejs},12926</code> </pre> <br><p>  We see that there are two processes now.  One is our main ‚Äúlaunching‚Äù process.  The second is a child process in which <code>PrimeFinderActor</code> now spinning, since it is now running in <code>"forked"</code> mode.  We configured it using the <code>actors.json</code> file, without changing anything in the code. </p><br><p>  It turned out this picture: </p><br><p><img src="https://habrastorage.org/web/1f1/395/4f1/1f13954f14cc42e09174fba8bafe3248.png" alt="image"></p><br><p>  Run the test again: </p><br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/3000000000 &amp; [1] 13240 $ curl http://localhost:8080/next-prime/3000000000 &amp; [2] 13242</code> </pre> <br><p>  We look at the log: </p><br><pre> <code class="bash hljs">Tue Aug 08 2017 08:54:41 GMT+0300 (MSK) - info: InMemoryActor(5989504694b4a23275ba5d29, RestServerActor): Handling next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000 Tue Aug 08 2017 08:54:43 GMT+0300 (MSK) - info: InMemoryActor(5989504694b4a23275ba5d29, RestServerActor): Handling next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000</code> </pre> <br><p>  Good news: everything still works.  The bad news: everything works, almost as before.  The kernel still fails, and requests are queued up.  Only now the kernel is loaded by our child process (note the PID): </p><br><pre> <code class="bash hljs"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 12927 weekens 20 0 907160 40892 20816 R 100,0 0,5 0:20.05 nodejs</code> </pre> <br><p>  Let's make more processes: we cluster <code>PrimeFinderActor</code> to 4 copies.  Change <code>actors.json</code> : </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"PrimeFinderActor"</span></span>: { <span class="hljs-string"><span class="hljs-string">"mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"forked"</span></span>, <span class="hljs-string"><span class="hljs-string">"clusterSize"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> } }</code> </pre> <br><p>  Restart the service.  What we see? </p><br><pre> <code class="bash hljs">$ ps ax | grep nodejs 15943 pts/19 Sl+ 0:01 nodejs prime-finder.js 15953 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor 15958 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor 15963 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor 15968 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor</code> </pre> <br><p>  Child processes was 4. Everything as we wanted.  By a simple configuration change, we changed the hierarchy, which now looks like this: </p><br><p><img src="https://habrastorage.org/web/2de/8da/0ba/2de8da0badb7482e985a02ff0851c83b.png" alt="image"></p><br><p>  That is, Comedy multiplied <code>PrimeFinderActor</code> to the number of 4 pieces, each launched in a separate process, and between these actors and the parent <code>RestServerActor</code> th <code>RestServerActor</code> an intermediate actor, which will scatter requests for child actors round-robin. </p><br><p>  Run the test: </p><br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/3000000000 &amp; [1] 20076 $ curl http://localhost:8080/next-prime/3000000000 &amp; [2] 20078</code> </pre> <br><p>  And we see that now two cores are occupied: </p><br><pre> <code class="bash hljs"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 15953 weekens 20 0 909096 38336 20980 R 100,0 0,5 0:13.52 nodejs 15958 weekens 20 0 909004 38200 21044 R 100,0 0,5 0:12.75 nodejs</code> </pre> <br><p>  In the application log, we see two parallel processing requests: </p><br><pre> <code class="bash hljs">Tue Aug 08 2017 11:51:51 GMT+0300 (MSK) - info: InMemoryActor(5989590ef554453e4798e965, RestServerActor): Handling next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000 Tue Aug 08 2017 11:51:52 GMT+0300 (MSK) - info: InMemoryActor(5989590ef554453e4798e965, RestServerActor): Handling next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000 Tue Aug 08 2017 11:57:24 GMT+0300 (MSK) - info: InMemoryActor(5989590ef554453e4798e965, RestServerActor): Handled next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000, result: 3000000019 Tue Aug 08 2017 11:57:24 GMT+0300 (MSK) - info: InMemoryActor(5989590ef554453e4798e965, RestServerActor): Handled next-prime request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number 3000000000, result: 3000000019</code> </pre> <br><p>  Scaling works! </p><br><h1 id="eschyo-bolshe-yader">  More cores! </h1><br><p>  Our service can now process in parallel 4 requests for finding a prime number.  The remaining requests are in the queue.  On my machine, only 4 cores.  If I want to process more parallel requests, I need to scale to neighboring machines.  Let's do that! </p><br><p>  First, a little theory.  In the last example, we switched <code>PrimeFinderActor</code> to <code>"forked"</code> mode.  Each actor can be in one of three modes: </p><br><ul><li>  <code>"in-memory"</code> (default): the actor works in the same process as the code that created it.  Sending messages to such an actor comes down to calling its methods.  The overhead of communication with the <code>"in-memory"</code> actor is zero (or close to zero); </li><li>  <code>"forked"</code> : the actor runs in a separate process on the same machine where the code that created it runs.  Communication with the actor is carried out via IPC (Unix pipes in Unix, named pipes in Windows). </li><li>  <code>"remote"</code> : the actor is launched in a separate process on the remote machine.  Communication with the actor via TCP / IP. </li></ul><br><p>  As you understand, now we need to transfer <code>PrimeFinderActor</code> from the <code>"forked"</code> mode to the <code>"remote"</code> .  We want to get this scheme: </p><br><p><img src="https://habrastorage.org/web/9e1/a30/d15/9e1a30d1559949d9b57b89b6ebb7ea16.png" alt="image"></p><br><p>  Let's edit the <code>actors.json</code> file.  Simply specifying the <code>"remote"</code> mode is not enough in this case: you must also specify the host on which we want to start the actor.  I have in the neighborhood a machine with the address <code>192.168.1.101</code> .  I use it: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"PrimeFinderActor"</span></span>: { <span class="hljs-string"><span class="hljs-string">"mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"remote"</span></span>, <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.101"</span></span>, <span class="hljs-string"><span class="hljs-string">"clusterSize"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> } }</code> </pre> <br><p>  Only trouble: this most neighboring machine does not know anything about Comedy.  We need to run on it a special listener process on a known port.  This is done like this: </p><br><pre> <code class="bash hljs">$ ssh weekens@192.168.1.101 ... weekens@192.168.1.101 $ mkdir comedy weekens@192.168.1.101 $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> comedy weekens@192.168.1.101 $ npm install comedy ... weekens@192.168.1.101 $ node_modules/.bin/comedy-node Thu Aug 10 2017 19:29:51 GMT+0300 (MSK) - info: Listening on :::6161</code> </pre> <br><p>  Now the listener process is ready to accept requests for the creation of actors on the well-known port <code>6161</code> .  We try: </p><br><pre> <code class="bash hljs">$ nodejs prime-finder.js</code> </pre> <br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/3000000000 &amp; $ curl http://localhost:8080/next-prime/3000000000 &amp;</code> </pre> <br><p>  See the top on the local machine.  No activity (except for Chromium): </p><br><pre> <code class="bash hljs">$ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 25247 weekens 20 0 1978768 167464 51652 S 13,6 2,2 32:34.70 chromium-browse</code> </pre> <br><p>  We look at the remote machine: </p><br><pre> <code class="bash hljs">weekens@192.168.1.101 $ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 27956 weekens 20 0 908612 40764 21072 R 100,1 0,1 0:14.97 nodejs 27961 weekens 20 0 908612 40724 21020 R 100,1 0,1 0:11.59 nodejs</code> </pre> <br><p>  There is a calculation of integers, all as we wanted. </p><br><p>  There is only one small touch: use the kernels both on the local and remote machines.  It's very simple: we specify in <code>actors.json</code> not one host, but several: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"PrimeFinderActor"</span></span>: { <span class="hljs-string"><span class="hljs-string">"mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"remote"</span></span>, <span class="hljs-string"><span class="hljs-string">"host"</span></span>: [<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"192.168.1.101"</span></span>], <span class="hljs-string"><span class="hljs-string">"clusterSize"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> } }</code> </pre> <br><p>  Comedy will distribute the actors evenly between the specified hosts and will distribute round-robin messages to them.  Let's check. </p><br><p>  First, run the listener process additionally on the local machine: </p><br><pre> <code class="bash hljs">$ node_modules/.bin/comedy-node Fri Aug 11 2017 15:37:26 GMT+0300 (MSK) - info: Listening on :::6161</code> </pre> <br><p>  Now run an example: </p><br><pre> <code class="bash hljs">$ nodejs prime-finder.js</code> </pre> <br><p>  Let's see the list of processes on the local machine: </p><br><pre> <code class="bash hljs">$ ps ax | grep nodejs 22869 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor 22874 pts/19 Sl+ 0:00 /usr/bin/nodejs /home/weekens/workspace/comedy-examples/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor</code> </pre> <br><p>  And by remote machine: </p><br><pre> <code class="bash hljs">192.168.1.101 $ ps ax | grep node 5925 pts/4 Sl+ 0:00 /usr/bin/nodejs /home/weekens/comedy/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor 5930 pts/4 Sl+ 0:00 /usr/bin/nodejs /home/weekens/comedy/node_modules/comedy/lib/forked-actor-worker.js PrimeFinderActor</code> </pre> <br><p>  Two on each, as wanted (need more - <code>clusterSize</code> increase <code>clusterSize</code> ).  We send requests: </p><br><pre> <code class="bash hljs">$ curl http://localhost:8080/next-prime/3000000000 &amp; [1] 23000 $ curl http://localhost:8080/next-prime/3000000000 &amp; [2] 23002</code> </pre> <br><p>  Enjoying the download on the local machine: </p><br><pre> <code class="bash hljs"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 22869 weekens 20 0 908080 40344 21724 R 106,7 0,5 0:07.40 nodejs</code> </pre> <br><p>  See the download on the remote machine: </p><br><pre> <code class="bash hljs"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 5925 weekens 20 0 909000 40912 21044 R 100,2 0,1 0:14.17 nodejs</code> </pre> <br><p>  Loaded one core on each machine.  That is, we now distribute the load evenly across both machines.  Notice, we achieved this without changing a single line of code.  And Comedy and the model of actors helped us in this. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  We looked at an example of flexible scaling of an application using the model of actors and its implementation in Node.JS - <a href="https://github.com/untu/comedy">Comedy</a> .  The algorithm of our actions was as follows: </p><br><ol><li>  Describe our application in terms of actors. </li><li>  Configure the actors to evenly distribute the load across the many CPU cores available to us. </li></ol><br><p>  How to describe the application in terms of actors?  This is an analogue of the question "How to describe an application in terms of objects and classes?".  Programming on actors is very similar to OOP.  We can say that it is OOP ++.  OOP has various well-established and successful <a href="https://habrahabr.ru/post/210288/">design patterns</a> .  Similarly, the actor model has its own patterns.  Here is a <a href="https://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830">book</a> on them.  These patterns can be used, and they will certainly help you, but if you already own the PLO, you will definitely not have problems with the actors. </p><br><p>  What if your application is already written?  Do I need to "rewrite it into actors"?  Of course, code modification is required in this case.  But not necessarily do a massive refactoring.  There are several main, "large" actors, and after that you can already scale.  "Large" actors can eventually be broken up into smaller ones.  Again, if your application is already described in terms of OOP, the transition to actors will most likely be painless.  The only point that you may have to work with is that the actors are completely isolated from each other, unlike simple objects. </p><br><p>  What about the maturity of the framework.  The first working version of Comedy was developed within the <a href="http://saymon.info/">SAYMON</a> project in June 2016.  The framework from the very first version worked in production under combat conditions.  In April 2017, the library was released in Open Source under the Eclipse Public License.  Comedy at the same time continues to be part of SAYMON and is used to scale the system and ensure its fault tolerance. </p><br><p>  The list of planned features is <a href="https://github.com/untu/comedy">here</a> . </p><br><p>  In this article, I did not mention a number of Comedy functionalities: about fault tolerance ("respawn" of actors), about resource injection into actors, about named clusters, about marshalling user classes, about TypeScript support.  But most of the above can be found in the documentation, and the fact that it has not yet been described is in <a href="https://github.com/untu/comedy/tree/master/test">tests</a> and <a href="https://github.com/untu/comedy-examples">examples</a> .  Plus, maybe I will write more articles about Comedy and actors in Node.JS, if the topic goes to the masses. </p><br><p>  Use Comedy!  Create issues!  Waiting for your comments! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334986/">https://habr.com/ru/post/334986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334976/index.html">Rotate 180. From CRM systems to game dev # 1</a></li>
<li><a href="../334978/index.html">Shops / developers / buyers / publishers</a></li>
<li><a href="../334980/index.html">Hidden messages in JavaScript property names</a></li>
<li><a href="../334982/index.html">Application availability for visually impaired users</a></li>
<li><a href="../334984/index.html">Resource planning. Part 1. What is it all about?</a></li>
<li><a href="../334988/index.html">Struct, union, and enum types in Modern C ++</a></li>
<li><a href="../334990/index.html">Introduction to octree</a></li>
<li><a href="../334992/index.html">How to view 20 million domain names and be satisfied</a></li>
<li><a href="../334994/index.html">I want to like YouTube</a></li>
<li><a href="../334996/index.html">Usability card product. Scenario profitable for business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>