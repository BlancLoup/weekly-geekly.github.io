<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yew - Rust & WebAsse framework for frontend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew is an analogue of React and Elm, written entirely on Rust and compiled into an honest WebAssembly. In the article, Denis Kolodin, the developer of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yew - Rust & WebAsse framework for frontend</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://github.com/DenisKolodin/yew">Yew</a> is an analogue of React and Elm, written entirely on Rust and compiled into an honest WebAssembly.  In the article, Denis Kolodin, the developer of Yew, talks about how you can create a framework without a garbage collector, effectively provide immutable, without the need to copy the state due to the rules for owning Rust data, and what are the features when translating Rust to WebAssembly. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>The post was prepared based on the report of Denis at the conference <a href="https://holyjs-piter.ru/">HolyJS 2018 Piter</a> .</i>  <i>Under the cut - video and text transcript of the report.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin works for the Bitfury Group company, which is developing various blockchain solutions.</i>  <i>For more than two years he has been kodit in Rust, a programming language from Mozilla Research.</i>  <i>During this time, Denis managed to thoroughly study this language and use it to develop various system applications, the backend.</i>  <i>Now, in connection with the advent of the WebAssembly standard, I began to look in the direction of the frontend.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Agenda </h2><br>  Today we will learn what Yew is (the name of the framework is read the same as the English word ‚Äúyou‚Äù - you; ‚Äúyew‚Äù is a yew tree translated from English). <br><br>  We will talk a little about architectural aspects, about what ideas the framework is built on, about the possibilities that are incorporated in it, as well as about the features that Rust gives us in addition to other languages. <br><br>  At the end, I'll show you how to start using Yew and WebAssembly today. <br><br><h2>  What is Yew? </h2><br>  First of all, it is WebAssembly, i.e.  executable bytecode that works in browsers.  It is needed in order to run complex algorithms, for example, cryptography, encoding / decoding, on the user‚Äôs side.  It is easier to implement it in the system languages, than to fasten crutches. <br><br>  WebAssembly is a standard that is clearly described, understood and supported by all modern browsers.  It allows the use of various programming languages.  And this is primarily interesting because you can reapply the code created by the community in other languages. <br><br>  If you wish, you can completely write an application to WebAssembly, and Yew allows you to do this, but it is important not to forget that even in this case, JavaScript remains in the browser.  It is needed to prepare WebAssembly ‚Äî take a module (WASM), add an environment to it and start it.  Those.  without javascript is indispensable.  Therefore, it makes sense to treat WebAssembly as an extension rather than a revolutionary alternative to JS. <br><br><h3>  How does the development </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  You have the source, there is a compiler.  You translate all this into a binary format and launch it in a browser.  If the browser is old, without WebAssembly support, then emscripten is required.  This, roughly speaking, is a WebAssembly emulator for the browser. <br><br><h3>  Yew - wasm framework ready for use </h3><br>  Let's go to Yew.  I developed this framework at the end of last year.  Then I wrote some kind of cryptocurrency application on Elm and faced with the fact that due to the limitations of the language I cannot create a recursive structure.  And at that moment I thought: in Rust, my problem would be solved very easily.  And since 99% of the time I write on Rust and just adore this language precisely because of its capabilities, I decided to experiment - compile the application with the same update-function in Rust. <br><br>  The first sketch took me several hours, I had to figure out how to compile a WebAssembly.  I launched it and realized that within a few hours I had laid a core, which is very easy to develop.  It took me just a few more days to bring all this to the minimum engine framework. <br><br>  I posted it in open source, but did not expect it to be any popular.  However, today he has collected more than 4 thousand stars on GitHub.  See the project can be <a href="https://github.com/DenisKolodin/yew">on the link</a> .  There are also many examples. <br><br>  The framework is written entirely in Rust.  Yew supports compiling directly to WebAssembly (wasm32-unknown-unknown target) without emscripten.  If necessary, you can work through emscripten. <br><br><h2>  Architecture </h2><br>  Now a few words about how the framework differs from the traditional approaches that exist in the world of JavaScript. <br><br>  First, I‚Äôll show you what limitations of the language I encountered in Elm.  Take the case when there is a model and there is a message that allows you to transform this model. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  In Elm, we simply create a new model and display it on the screen.  The previous version of the model remains unchanged.  Why do I emphasize this?  Because the Yew model is mutable, and this is one of the most frequent questions.  Next, I will explain why this is done. <br><br>  Initially, I walked the classic path when the model was created anew.  But as the framework evolved, I saw that there was no point in keeping the previous version of the model.  Rust allows you to track the lifetime of all data, changeable or not.  And so I can change the model safely, knowing that Rust controls the absence of conflict. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  This is the first moment.  The second point: why do we need the old version of the model?  In the same Elm there is hardly a problem of some kind of competitive access.  The old model is needed only to understand when to render.  Awareness of this moment allowed me to completely get rid of immutable and not keep the old version. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Look at the option when we have the <code>update</code> function and two fields, <code>value</code> and <code>name</code> .  There is a value that is saved when we enter data into the <code>input</code> field.  The model is changing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  It is important that <code>value</code> does not participate in rendering.  And therefore we can change it as much as necessary.  But we do not need to influence the DOM tree and do not need to initiate these changes. <br><br>  This gave me the idea that only a developer can know the right moment when it is really necessary to initiate rendering.  To initiate, I began to use the flag - just a boolean value - <code>ShouldRender</code> , which signals that the model has changed and you need to start rendering.  At the same time, there are no overhead costs for constant comparisons, there is no memory consumption - applications written in Yew are as efficient as possible. <br><br>  In the example above, no memory allocation occurred at all, except for the message that was generated and sent.  The model has retained its state, and this is reflected in the rendering only with the help of the flag. <br><br><h2>  Opportunities </h2><br>  Writing a framework that works in WebAssembly is not an easy task.  We have JavaScript, but it has to create some kind of environment with which to interact, and this is a huge amount of work.  The initial version of these bundles looked like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  I took a demonstration from another project.  There are many projects that go this way, but he quickly leads to a dead end.  After all, the framework is a fairly large development and you have to write a lot of docking code.  I began to use libraries in Rust, which are called crates, in particular, <code>Stdweb</code> . <br><br><h3>  JS integrated </h3><br>  With the help of Rust macros, you can extend the language - we can insert javascript into Rust code, this is a very useful feature of the language. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  Using macros and Stdweb allowed me to quickly and efficiently write all the necessary bundles. <br><br><h3>  Jsx templates </h3><br>  At first, I followed the path of Elm and started using patterns implemented with code. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  I have never been a React supporter.  But when I started writing my own framework, I realized that JSX in React is a very cool thing.  There is a very convenient presentation of code templates. <br><br>  As a result, I took the macro on Rust and injected Rust directly inside the opportunity to write HTML markup, which immediately generates elements of the virtual tree. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  It can be said that JSX-like patterns are pure code patterns, but on steroids.  They are presented in a convenient format.  Also note that here I directly insert a Rust expression into the button (a Rust expression can be inserted inside these templates).  This allows for very tight integration. <br><br><h3>  Components with fair structure </h3><br>  Then I began to develop templates and implemented the possibility of using components.  This is the first issue that was made in the repository.  I have implemented components that can be used in the template code.  You simply declare an honest structure on Rust and write some properties for it.  And these properties can be set directly from the template. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  I note once again the important thing that these templates are honestly generated Rust code.  Therefore, any error here will be noticed by the compiler.  Those.  you can't go wrong, as is often the case in JavaScript development. <br><br><h3>  Typed areas </h3><br>  Another interesting feature is that when a component is placed inside another component, it can see the type of the parent message. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  The compiler binds these types tightly and will not give you the opportunity to make a mistake  When processing events, the messages that the component is waiting for or can send will have to fully comply with the parent. <br><br><h3>  Other features </h3><br>  From Rust I transferred the implementation directly to the framework, which allows you to conveniently use various serialization / deserialization formats (providing it with additional wrappers).  Below is an example: we are accessing local storage and, when restoring data, we specify some kind of wrapper - what we expect json here. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  There can be any format, including binary.  Accordingly, serialization and deserialization become transparent and convenient. <br><br>  The idea of ‚Äã‚Äãanother opportunity that I realized came from the users of the framework.  They asked for fragments.  And here I am faced with an interesting thing.  Having seen the ability to insert fragments into the DOM tree in JavaScript, I first decided that it would be very easy to implement such a function in my framework.  But I tried this option and it turned out that it does not work.  I had to figure it out, walk on this tree, see what changed there, etc. <br><br>  The Yew framework uses a virtual DOM tree, everything initially exists in it.  In fact, when some changes appear in the template, they turn into patches that already change the rendered DOM tree. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Additional benefits </h2><br>  Rust provides many more powerful features, I‚Äôll only talk about the most important ones. <br><br><h3>  Services: interaction with the outside world </h3><br>  The first opportunity I want to talk about is services.  You can describe the necessary functionality as a service, publish it as a crate and reuse it. <br><br>  In Rust, the ability to create libraries, their integration, docking and gluing is very qualitatively implemented.  In fact, you can create different APIs for interacting with your service, including JavaScript.  In this case, the framework can interact with the outside world, despite the fact that it works inside the WebAssembly runtime. <br><br>  Examples of services: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Custom Services ... <br></li></ul><br>  Rust services and crates: <a href="https://crates.io/">crates.io</a> . <br><br><h3>  Context: State Requirements </h3><br>  Another thing that I implemented in the framework is not quite traditional, this is the context.  In React there is a Context API, I used Context in a different sense.  The Yew framework consists of the components you make, and Context is a global state.  Components may not take into account this global state, and may impose some requirements - so that the global entity meets some criteria. <br><br>  Suppose our abstract component requires the ability to upload something to S3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  Below you can see that he uses this unloading, i.e.  sends data to S3.  Such a component can be laid out in the form of a crate.  The user who downloads this component and adds the template inside his application will encounter an error - the compiler will ask him where is the S3 support?  The user will need to implement this support.  After this, the component automatically begins to live a full life. <br><br>  Where is it needed?  Imagine: you are creating a component with clever cryptography.  He has requirements that the surrounding context should allow him to log in somewhere.  All you need to do is add an authorization form in the template and in your context implement the link with your service.  Those.  This will be literally three lines of code.  After this, the component starts working. <br><br>  Imagine that we have dozens of different components.  And they all have the same requirement.  This allows you to implement some functionality once, in order to revive all the components and pull up the data you need.  Right out of context.  And the compiler will not allow you to make a mistake: if you do not implement an interface that requires a component, it will not work. <br><br>  Therefore, you can easily create very fastidious buttons that will ask for some API or other features.  Thanks to Rust and the system of these interfaces (they are called trait in Rust), it is possible to declare the requirements of the component. <br><br><h3>  The compiler will not let you make a mistake </h3><br>  Imagine that we are creating a component with some properties, one of which is the ability to set call back.  And, for example, we set the property and missed one letter in its name. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  We are trying to compile, Rust responds to this quickly.  He says that we were mistaken and there is no such property: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  As you can see, Rust directly uses this template and can render all errors inside the macro.  He suggests what the property should actually be called.  If you have passed the compiler, then you will not have stupid runtime errors like typos. <br><br>  Now let's imagine we have a button that asks our global context to be able to connect to S3.  And create a context that does not implement S3 support.  Let's see what will happen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  The compiler reports that we inserted a button, but this interface is not implemented for context. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  It remains only to go to the editor, add a connection to Amazon in the context, and everything will start.  You can create ready-made services with some kind of API, then simply add to the context, substitute a link to it - and the component immediately comes to life.  This allows you to do very cool things: you add components, create a context, stuff it with services.  And it all works completely automatically, we need minimal effort to connect it all. <br><br><h2>  How to start using Yew? </h2><br>  What to start with if you want to try compiling a WebAssembly application?  And how can this be done using the Yew framework? <br><br><h3>  Rust-to-wasm compilation </h3><br>  First, you need to install a compiler.  For this there is a rustup tool: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  Plus, you may need emscripten.  What can it be useful for?  Most of the libraries that are written for system programming languages, especially for Rust (initially system), are developed for Linux, Windows and other full-fledged OSes.  Obviously, there are no many possibilities in the browser. <br><br>  For example, the generation of random numbers in a browser is done differently from Linux.  emscripten comes in handy if you want to use libraries that require a system API. <br><br>  Libraries and the entire infrastructure are quietly moving to an honest WebAssembly, and emscripten is no longer required (you use JavaScript-based capabilities to generate random numbers and other things), but if you need to build something that is not supported in the browser at all, you can‚Äôt do without emscripten . <br><br>  I also recommend using cargo-web: <br><br> <code>cargo install cargo-web <br></code> <br>  It is possible to compile WebAssembly without additional utilities.  But cargo-web is a cool tool that gives you several things that are useful for JavaScript developers.  In particular, it will monitor the files: if you make any changes, it will start compiling immediately (the compiler does not provide such functions).  In this case, Cargo-web will allow you to speed up development.  There are different build systems for Rust, but cargo is 99.9% of all projects. <br><br>  A new project is created as follows: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Then just start the project: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  I gave an example of honest WebAssembly.  If you need to compile under emscripten (the rust compiler itself can connect emscripten), in the very last element of <code>unknown</code> you can insert the word <code>emscripten</code> , which allows you to use more crates.  Do not forget that emscripten is a rather large additional body kit to your file.  Therefore, it is better to write honest WebAsse installation code. <br><br><h3>  Existing restrictions </h3><br>  Anyone who has experience in coding in system programming languages ‚Äã‚Äãcan be upset by limitations in the framework.  Not all libraries can be used in WebAssembly.  For example, there are no threads in the JavaScript environment.  WebAssembly basically does not declare this, and you, of course, can use it in a multi-threaded environment (this is an open question), but JavaScript is still a single-threaded environment.  Yes, there are workers, but this is isolation, so no threads will be there. <br><br>  It would seem that you can live without streams.  But if you want to use thread-based libraries, for example, you want to add some runtime, it may not take off. <br><br>  There is also no system API here besides the one that you transfer from JavaScript to WebAssembly.  So many libraries will not transfer.  You cannot write and read files directly, you cannot open sockets, you cannot write to the network.  If you want to make a web-socket for example, you need to drag it out of javascript. <br><br>  Another disadvantage is that the WASM debugger exists, but no one has seen it.  He is still in such a raw state that it is unlikely to be useful to you.  Therefore, debugging WebAssembly is a complex issue. <br><br>  When using Rust, almost all runtime problems will be associated with errors in business logic, which will be easy to fix.  But very rarely, low-level bugs appear - for example, some of the libraries do wrong docking - and this is a difficult question.  For example, at the moment there is such a problem: if I compile the framework with emscripten and there is a variable memory cell, the ownership of which is then taken, then it is given, emscripten falls apart somewhere in the middle (and I'm not even sure that it is emscripten).  Know if you stumble upon a problem somewhere in the middleware at a low level, then it will be difficult to fix it at the moment. <br><br><h2>  Future of the framework </h2><br>  How will Yew continue to develop?  I see its main purpose in creating monolithic components.  You will have a compiled WebAsse-file, and you will simply insert it into the application.  For example, it may provide cryptographic capabilities, rendering, or editing. <br><br><h3>  JS integration </h3><br>  JavaScript integration will be enhanced.  A large number of cool libraries are written in JavaScript that are convenient to use.  And there are examples in the repository where I show how you can use the existing JavaScript library directly from the Yew framework. <br><br><h3>  Typed CSS </h3><br>  Since Rust is used, it is obvious that you can add typed CSS, which can be generated in the same macro as in the example of a JSX-like template engine.  In this case, the compiler will check, for example, whether you have assigned some other attribute instead of color.  It saves tons of your time. <br><br><h3>  Finished components </h3><br>  I also look in the direction of creating a ready-to-use component.  On the framework, you can make racks that will provide, for example, a set of some buttons or elements that will be connected as a library, added to templates and used. <br><br><h3>  Improved performance in particular cases </h3><br>  Performance is a very delicate and complex issue.  Is WebAssembly faster than JavaScript?  I have no proof of a positive or negative answer.  Feels like, and for some very simple tests that I conducted, WebAssembly works very quickly.  And I have full confidence that its performance will be higher than that of JavaScript, just because it is a low-level byte code, where memory allocation and many other moments requiring resources are not required. <br><br><h3>  More contributors </h3><br>  I would like to attract more contributors.  Doors to participate in the framework are always open.  Anyone who wants to upgrade, understand the kernel and transform the tools that a large number of developers work with can easily connect and suggest their own changes. <br><br>  Many contributors have already participated in the project.  But there are no Core contributors at the moment, because for this you need to understand the vector of development of the framework, but it has not yet been clearly formulated.  But there is a backbone, guys, who know a lot about Yew - about 30 people.  If you also want to add something to the framework, always please send a pull request. <br><br><h3>  Documentation </h3><br>  A must in my plans is to create a large amount of documentation on how to write applications on Yew.  Obviously, the development approach in this case is different from what we saw in React and Elm. <br><br>  Sometimes guys show me interesting cases how to use the framework.  Still, creating a framework is not the same thing as writing professionally on it.  The practice of using the framework is still being formed. <br><br>  Try it, install Rust, expand your capabilities as a developer.  Mastering WebAssembly will be useful to each of us, because the creation of very complex applications is the moment we have been waiting for.  In other words, WebAssembly is not only about the web browser, but it is generally runtime that is precisely developed and will be developed even more actively. <br><br><blockquote>  If you like the report, please note: on November 24-25, a new <a href="https://holyjs-moscow.ru/">HolyJS</a> will take place in Moscow, and there will also be many interesting things there.      ‚Äî  ,       ( <b>  </b>  ). </blockquote></div><p>Source: <a href="https://habr.com/ru/post/422253/">https://habr.com/ru/post/422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422239/index.html">How to start shipping for millions of users</a></li>
<li><a href="../422241/index.html">KPI - three letter sticking</a></li>
<li><a href="../422243/index.html">CRM for small business. Do you need it?</a></li>
<li><a href="../422247/index.html">OK Instant Games Cup. Contest for HTML5 games</a></li>
<li><a href="../422251/index.html">"High level of self-discipline." Jeffrey Richter on how to code, write books and create your own companies</a></li>
<li><a href="../422255/index.html">Creating characters in Blender and Unity</a></li>
<li><a href="../422257/index.html">Reader PocketBook 627 review: middle class with backlight, Wi-Fi and cloud service</a></li>
<li><a href="../422259/index.html">Basic data structures. Materiel Ases</a></li>
<li><a href="../422261/index.html">Zextras Powerstore and single-tier storage systems</a></li>
<li><a href="../422263/index.html">"Dormamma, I came to agree": an algorithm for mutually beneficial cooperation with a person</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>