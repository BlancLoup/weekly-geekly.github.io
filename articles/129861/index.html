<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Event-oriented HTTP server in C # using Rx and HttpListener</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Big enough name? Yes? In this post I will show you an alternative approach to creating a simple event-oriented HTTP server in C #, using the power of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Event-oriented HTTP server in C # using Rx and HttpListener</h1><div class="post__text post__text-html js-mediator-article">  Big enough name?  Yes?  In this post I will show you an alternative approach to creating a simple event-oriented HTTP server in C #, using the power of <a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a> . <br><a name="habracut"></a><br><h5>  Introduction </h5><br>  I‚Äôm not very good at explaining, so I‚Äôll quote a very interesting article from Dan York about the node.js event model: <br><blockquote>  The ‚Äútraditional‚Äù mode of web servers has always been based on the threading model.  When you start Apache or any other web server, it starts accepting connections.  When it accepts a connection, it keeps the connection open until it finishes processing the page or another transaction.  If reading a page from disk or writing results to a database takes several microseconds, then the web server is blocked for I / O operations.  (This is referred to as ‚Äúblocking I / O‚Äù).  To scale this type of server, you will need to run additional copies of the server itself (referred to as ‚Äúthread-based‚Äù, because each copy usually requires an additional operating system thread). <br>  In contrast, Node.JS uses an event-oriented model, in which the web server receives requests, quickly puts them in for processing, then is taken as the next request.  When the initial request is completed, it returns to the processing queue and when it reaches the end of the queue, the results are returned (or whatever the next action requires).  This model is very efficient and scalable, because the web server usually always accepts requests, because  does not wait for any read or write operation to complete.  (This method is referred to as ‚Äúnon-blocking I / O‚Äù or ‚Äúevent-oriented I / O‚Äù). <br></blockquote><br><h5>  What happens in the .NET world? </h5><br>  A lot of things happen around this in the .NET ecosystem: <br><ul><li>  <a href="http://manosdemono.org/">Manos de mono</a> (not for .NET, but close to it) was created not so long ago, following this concept </li><li>  <a href="">Node.Net</a> - implementing Node.JS for .Net runtime using JScript.Net </li><li>  <a href="http.com/">Kayak</a> is an asynchronous HTTP server written in C # </li><li>  <a href="https://github.com/panesofglass/frank">Frank</a> is a Sinatra clone written in F # </li><li>  <a href="https://github.com/NancyFx/Nancy">Nancy</a> will support <a href="https://groups.google.com/group/nancy-web-framework/browse_thread/thread/3f9a8e50216ea60e">asynchronous handlers soon.</a> </li></ul><br><h5>  Alternative approach </h5><br>  Using the HttpListener class and Reactive Extensions, we can create something like this: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HttpServer</span></span> : <span class="hljs-title"><span class="hljs-title">IObservable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">RequestContext</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpListener listener; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IObservable&lt;RequestContext&gt; stream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpListener(); listener.Prefixes.Add(url); listener.Start(); stream = ObservableHttpContext(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IObservable&lt;RequestContext&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObservableHttpContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.Create&lt;RequestContext&gt;(obs =&gt; Observable.FromAsyncPattern&lt;HttpListenerContext&gt;(listener.BeginGetContext, listener.EndGetContext)() .Select(c =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestContext(c.Request, c.Response)) .Subscribe(obs)) .Repeat() .Retry() .Publish() .RefCount(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { listener.Stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IDisposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IObserver&lt;RequestContext&gt; observer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream.Subscribe(observer); } }</code> </pre> <br>  Some notes to this code: <br><ul><li>  FromAsyncPattern is a convenient method that comes with Rx.  This method converts Begin / End signatures to IObservable. </li><li>  RequestContext is an easy wrapper for working with HttpListener.  I'm not going to give his code here, but you can see the whole source code a bit later. </li><li>  I repeat: if you have ever seen the use of HttpListener, then I am sure you have seen the code inside the while loop.  This is the same. </li><li>  Try again: if we get an error, then try again. </li><li>  Publish / Refcount: this will help us create ‚Äúwarm‚Äù observers from ‚Äúcold‚Äù ones.  They behave like ‚Äúhot‚Äù.  You can read more <a href="http://enumeratethis.com/2010/04/17/warm-observables-with-publish-refcount/">here</a> and <a href="http://blogs.microsoft.co.il/blogs/bnaya/archive/2010/03/13/rx-for-beginners-part-9-hot-vs-cold-observable.aspx">here</a> . </li></ul><br><h5>  Usage example </h5><br>  You can create any type of web application based on this concept.  The application of the ‚Äúhello world‚Äù level will look like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//a stream os messages var subject = new Subject&lt;string&gt;(); using(var server = new HttpServer("http://*:5555/")) { var handler = server.Where(ctx =&gt; ctx.Request.Url.EndsWith("/hello")) .Subscribe(ctx =&gt; ctx.Respond(new StringResponse("world"))); Console.ReadLine(); handler.Dispose(); } }</span></span></code> </pre><br>  I recommend that everything you do be asynchronous.  For example, if you are connecting to a database, this should be an asynchronous operation, and you will need to hold together callbacks / observables / Tasks, etc. <br><br>  There is an even more interesting application that I would like to share, and which is called <a href="http://en.wikipedia.org/wiki/Push_technology">long polling</a> : <br><blockquote>  Long polling is a variation of the traditional polling technique and allows you to emulate sending information from the server to the client.  With long polling, the client requests information from the server in the same manner as with a normal request.  However, if the server does not have any available information for the client, instead of sending an empty response, the server holds the request and waits for the availability of information. <br></blockquote><br>  So, we have the simplest example of long polling, working through the above code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//a stream os messages var subject = new Subject&lt;string&gt;(); using(var server = new HttpServer("http://*:5555/")) { //the listeners stream and subscription var listeners = server .Where(ctx =&gt; ctx.Request.HttpMethod == "GET") .Subscribe(ctx =&gt; subject.Take(1) //wait the next message to end the request .Subscribe(m =&gt; ctx.Respond(new StringResponse(m)))); //the publishing stream and subscrition var publisher = server .Where(ctx =&gt; ctx.Request.HttpMethod == "POST") .Subscribe(ctx =&gt; ctx.Request.InputStream.ReadBytes(ctx.Request.ContentLength) .Subscribe(bts =&gt; { ctx.Respond(new EmptyResponse(201)); subject.OnNext(Encoding.UTF8.GetString(bts)); })); Console.ReadLine(); listeners.Dispose(); publisher.Dispose(); } } }</span></span></code> </pre><br>  As you can see, we are making the observers work ... There is no blocking operation.  Even reading from a stream is an asynchronous operation. <br><br><h5>  Want to see a working code? </h5><br>  Below is a video demonstrating how the code works: <br> <a href=""><img src="http://content.screencast.com/users/JoseFR/folders/Jing/media/5a3be883-d2fd-41d2-a84a-f6734692bef7/FirstFrame.jpg" alt="image"></a> <br>  And, at the end, the source code is published <a href="httplistener">here</a> under opensource, if you want to delve into it step by step or just study it. <br>  Special thanks to Gustavo Machado, Silvio Massari and the guys from the Nancy framework for the advice and part of the code I stole from them. <br></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/129861/">https://habr.com/ru/post/129861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129855/index.html">MonoDevelop 2.8 release - integration with Xcode 4, support for iOS 5 and more</a></li>
<li><a href="../129856/index.html">HTC Flyer 16GB WiFi for $ 100</a></li>
<li><a href="../129857/index.html">Microsoft will try to negotiate with Yahoo again</a></li>
<li><a href="../129859/index.html">Synthesis dot everything. Habrahabr live</a></li>
<li><a href="../129860/index.html">India did release a $ 35 tablet</a></li>
<li><a href="../129862/index.html">Steve Jobs I Knew</a></li>
<li><a href="../129863/index.html">Is it worth being ‚Äúsuccessful‚Äù?</a></li>
<li><a href="../129864/index.html">Meet the Evernote web clipper for Safari</a></li>
<li><a href="../129866/index.html">JavaDay Conference in Voronezh, October 29</a></li>
<li><a href="../129867/index.html">SMELLIT odor synchronization system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>