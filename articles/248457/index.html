<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the development of web-applications on PSGI / Plack. Part 4. Asynchrony</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the permission of the author and chief editor of the magazine PragmaticPerl.com, I publish this article. 
 The original article can be read here ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the development of web-applications on PSGI / Plack. Part 4. Asynchrony</h1><div class="post__text post__text-html js-mediator-article">  With the permission of the author and chief editor of the magazine PragmaticPerl.com, I publish this article. <br>  The original article can be read <a href="http://pragmaticperl.com/issues/05/pragmaticperl-05-%25D0%25B2%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B2-%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D1%2583-web-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-%25D0%25BD%25D0%25B0-psgiplack.-%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-4.-%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C.html">here</a> . <br><br>  <i>Continuing a series of articles devoted to the development of PSGI / Plack.</i>  <i>We deal with asynchrony.</i> <br>  In previous articles we looked at the main aspects of development for PSGI / Plack, which, in principle, are sufficient for developing applications of almost any complexity. <br><br>  We figured out what a PSGI is, figured out how Plack works, then we figured out how the main Plack components (Plack :: Builder, Plack :: Request, Plack :: Middleware) work.  Then we looked at Starman in detail, which is a good PSGI server, ready for use in production. <br><a name="habracut"></a><br><h2>  Nuance </h2><br>  Everything that was considered earlier concerned development under the execution model, which is called synchronous.  Now consider the asynchronous model. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Synchronization and asynchrony </h2><br>  The synchronous model is simple and straightforward.  Everything happens one after another in a certain order.  This is called an execution process.  Consider one interpreter process that, say, performs a loop, one of the elements of which is user input.  The next loop iteration will not be executed until the previous one, which includes waiting for user input of data, is completed.  This is a synchronous model. <br><br>  While the user does not enter anything, the program waits for input and does nothing useful.  This situation is called execution execution lock.  In this case, a simple program simply recycles processor time.  But if in the process of waiting for the user, the program does something else, waiting for input, then the process becomes asynchronous, and the situation, accordingly, is non-blocking. <br><br><h2>  We go to the bar </h2><br>  Consider the bar as an example.  A simple bar or pub in which customers sit and drink beer.  A lot of customers.  The bar has two waiters - Bob and Joe.  They work in two different ways.  Bob approaches the clients, takes the order, goes to the bar, orders the barman a glass of beer, waits until the bartender pours the glass, takes it to the customer, the situation repeats.  Bob is working synchronously.  Joe does a completely different thing.  He takes the order from the client, goes to the bartender, tells him: ‚ÄúHey, pour a% beername% glass‚Äù, then goes to take the order from the next client.  As soon as the bartender pours a glass, he calls Joe, who takes the glass and takes it to the customer. <br><br>  In this case, Bob works synchronously, and Joe, respectively, asynchronously.  Joe's job model is event-oriented.  This is the most popular model of asynchronous systems.  In our case, waiting for input is the time required to fill the glass with beer, the event manager is the bartender, and the event is the bartender‚Äôs cry ‚Äú% beername% is poured‚Äù. <br><br><h2>  Problem </h2><br>  Now, readers who have never worked with asynchronous systems should have a question.  ‚ÄúAnd why, in fact, do synchronous things, if asynchrony is faster and more convenient?‚Äù. <br><br>  This is a very popular fallacy, but it is not.  Asynchronous solutions also have a number of problems and disadvantages.  There are a lot of places where you can read that asynchronous solutions are more productive than synchronous ones.  Yes and no. <br><br>  Let's go back to the waiters.  Bob is working slowly, telling jokes to the bartender, steadily spreading glasses, and Joe is constantly wagging like mad.  The load on Joe, of course, higher, because  he does much more at the same time.  The load on Bob is minimal as long as there are no customers.  As soon as there are many customers, they begin to loudly demand their beer and rush Bob.  The load on the client‚Äôs side is increasing, but Bob continues to work at the same pace, he doesn‚Äôt care, he‚Äôs not going to give up his scheme of work, and even if the sky collapses. <br><br>  So, from here we can conclude that asynchrony is not bad, but it should be understood that the asynchronous system will always be under load.  The load, in principle, will be the same as for the synchronous system, but with one difference.  The synchronous system is subject to peak loads, and asynchronous these loads ‚Äúsmears‚Äù over the execution time. <br><br>  And most importantly, we must not forget that any system can simultaneously perform as many tasks as the processor cores are available to the process. <br><br><h2>  Asynchronous PSGI / Plack </h2><br>  Classic Plack application (skip the builder section): <br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'body'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); };</code> </pre> <br><br>  From the code it is clear that the $ app scalar contains a link to a function that returns a valid PSGI response (link to an array).  Thus, it is a reference to a function that returns a reference to an array.  Here you can add asynchrony, but the case does not come out of it, because the executable process will be blocked. <br><br>  A PSGI application that is a reference to a function that returns a reference to an array should be executed to the end, and only then release the execution thread. <br><br>  Naturally, this code will work correctly on any PSGI server, since  he is synchronous.  Any asynchronous server can execute synchronous code, but the synchronous server cannot execute asynchronous code.  The code above is synchronous.  In the last article we touched on a PSGI server like Twiggy.  I recommend installing it if you do not already have it.  This can be done in several ways.  With cpan (cpan install Twiggy), with cpanm (cpanm Twiggy), or take it on github. <br><br><h2>  Twiggy </h2><br>  Twiggy - asynchronous server.  Twiggy and Starman have the same author @miyagawa. <br><br>  About Twiggy @miyagawa says the following: <i>‚ÄúPSGI / Plack HTTP server based on AnyEvent.‚Äù</i> <br><br>  Twiggy - a supermodel from the 60s, which, as many believe, marked the beginning of fashion for "thin", but because  the server is very ‚Äúlight‚Äù, ‚Äúthin‚Äù, ‚Äúsmall‚Äù, the name was not chosen by chance. <br><br><h2>  Delayed response </h2><br>  PSGI application with a deferred response is presented in the documentation as follows: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $responder = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; fetch_content_from_server(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $content = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $responder-&gt;([ <span class="hljs-number"><span class="hljs-number">200</span></span>, $headers, [ $content ] ]); }); }; };</code> </pre><br><br>  Let us see how it works, to understand how to use it further and write your application that works with a deferred answer. <br><br>  An application is a reference to a function that returns a function that will be executed after certain conditions are met (callback).  As a result, the application is a function reference that returns a function reference.  That's all you need to understand.  The server, if the PSGI environment variable ‚Äúpsgi.streaming‚Äù is set, will attempt to perform this operation in non-blocking mode, i.e.  asynchronously. <br><br>  So how does it work? <br><br>  If you run such an application on Starman, there will be no difference, but if we use a delayed response on an asynchronous server, the execution process will look like this. <br><br><ul><li>  The server receives a request. </li><li>  The server is requesting data from somewhere, from where it is coming for a long time (fetch_content_from_server function). </li><li>  Then, while waiting for a response, it can accept more requests. </li></ul><br>  If the model were synchronous, the server would not be able to accept a single request until the previous one had completed. <br><br>  Write the application using the deferred response mechanism.  The application will look like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $responder = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body = <span class="hljs-string"><span class="hljs-string">"ok\n"</span></span>; $responder-&gt;([ <span class="hljs-number"><span class="hljs-number">200</span></span>, [], [ $body ] ]); } }</code> </pre><br>  And now we will launch the application both with the help of Starman, and with the help of Twiggy. <br><br>  The launch team using Starman does not change with us and looks like this: <br><pre> <code class="bash hljs">starman --port 8080 app.psgi</code> </pre><br><br>  To run using Twiggy: <br><pre> <code class="bash hljs">twiggy --port 8081 app.psgi</code> </pre><br><br>  Now we will make a request first to one server, then to another. <br><br>  Request to Starman: <br><pre> <code class="bash hljs">curl localhost:8080/ ok</code> </pre><br><br>  Query to Twiggy: <br><pre> <code class="bash hljs">curl localhost:8081/ ok</code> </pre><br><br>  So far, no difference, and the server work the same way. <br><br>  And now let's do a simple experiment with Twiggy and Starman.  Imagine that we need to write an application that will perform something at the request of the client, and after completing the operation, report on the work done.  But, since  we do not need to keep the client, we use to simulate the execution of anything AnyEvent-&gt; timer () for Twiggy, sleep 5 for Starman.  In general, sleep is not the best option here, but we don‚Äôt have another one, because  code with AnyEvent in Starman will not work. <br><br>  So, we realize two options. <br><br>  Blocking: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $responder = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; $responder-&gt;([ <span class="hljs-number"><span class="hljs-number">200</span></span>, [ <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/json'</span></span>], [ <span class="hljs-string"><span class="hljs-string">'Hi'</span></span> ] ]); } }</code> </pre><br>  No matter how we launch it, even with the help of Starman, even with the help of Twiggy, the result will always be the same.  Start it, for starters, with the help of Starman with the following command: <br><pre> <code class="bash hljs">starman --port 8080 --workers=1 app.psgi</code> </pre><br><br>  <b>Warning: for the purity of the experiment should be used Starman with a single workflow.</b> <br>  Turning to the server from different terminals at the same time, we can see how this application is executed.  First, the worker will take the first request and begin to execute it.  At this point, the second request will be in the queue.  As soon as the first request is completed, the server will begin processing the next request. <br><br>  In total, two requests will be executed in approximately 10 seconds (the second one is launched for processing only after the first one).  If the request is 3, then the estimated execution time will be 18 seconds.  This situation is called blocking. <br><br><h2>  Asynchronous code </h2><br>  If you run the previous execution example using Twiggy, the result will be exactly the same.  Now the question may arise why an asynchronous server is needed if it is blocked and Starman works in the same way. <br><br>  The fact is that in order for something to work asynchronously, a mechanism is needed that will provide asynchrony, an event loop, for example. <br><br>  Twiggy is built around an AnyEvent mechanism that starts when the server starts.  We can use it immediately after starting the server.  It is also possible to use Coro, an article on which will also necessarily be. <br><br>  Now we will write the code that will <b>not</b> work with Starman, and get a ready-made asynchronous application. <br><br>  Let's put the code in order and make the application asynchronous.  As a result, we should have something like this: <br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $respond = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $env-&gt;{timer} = AnyEvent-&gt;timer( <span class="hljs-string"><span class="hljs-string">after =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">cb =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $respond-&gt;([<span class="hljs-number"><span class="hljs-number">200</span></span>, [], [<span class="hljs-string"><span class="hljs-string">'Hi'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>]]); } ); } }</code> </pre><br><br>  It is worth recalling that there will <b>always</b> be locks, where they will be depends on writing the code.  The less time the server is blocked, the better. <br><br>  How it works? <br><br>  The timer starts first.  The main point is that in the return sub {...} you need to assign the observer object (AnyEvent-&gt; timer (...)) to the variable that was declared before the return sub {...}, or use condvar.  Otherwise, the timer will never be executed, because  AnyEvent will consider that the function is completed and nothing needs to be done.  When the timer expires, an event occurs, the function is executed, and the server returns the result.  If you make from different terminals, for example, three requests, then they will all be executed asynchronously, and the response of the timer event will be returned.  But the most important thing is that there is no blocking.  This is evidenced by the result of three queries made from different terminals, the output of STDERR: <br><br><pre> <code class="bash hljs">twiggy --port 8080 app.psgi Hi1372613810 Hi1372613811 Hi1372613812</code> </pre><br>  The server was launched by the following command: <br><br><pre> <code class="bash hljs">twiggy --port 8080 app.psgi</code> </pre><br><br>  And requests were executed using curl: <br><pre> <code class="bash hljs">curl localhost:8080</code> </pre><br><br>  Recall that the preforking server in the classic form is synchronous.  The simultaneity of requests is processed using a certain number of workers.  Those.  If you run the previous synchronous code: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $responder = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; $responder-&gt;([ <span class="hljs-number"><span class="hljs-number">200</span></span>, [ <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/json'</span></span>], [ <span class="hljs-string"><span class="hljs-string">'Hi'</span></span> ] ]); } }</code> </pre><br>  with several workers, it turns out that two requests will be executed simultaneously.  But it‚Äôs not asynchronous, but that each request is processed by its own workflow.  This is how Starman works, preforking PSGI server. <br><br>  Take the asynchronous example: <br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $respond = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $env-&gt;{timer} = AnyEvent-&gt;timer( <span class="hljs-string"><span class="hljs-string">after =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">cb =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $respond-&gt;([<span class="hljs-number"><span class="hljs-number">200</span></span>, [], [<span class="hljs-string"><span class="hljs-string">'Hi'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">time</span></span>() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>]]); } ); } }</code> </pre><br>  We will start the following command: <br><br><pre> <code class="bash hljs">twiggy --port 8080 app.psgi</code> </pre><br>  and repeat the experiment with two simultaneous requests. <br><br>  Indeed, Twiggy works as a single process, but nothing prevents it from performing other useful activities while waiting.  This is asynchrony. <br><br>  This example was used solely to demonstrate how a deferred response can be used.  For a better understanding of how Twiggy works, it is recommended that you read the AnyEvent articles in previous issues of the magazine (‚ÄúEverything you wanted to know about AnyEvent, but were afraid to ask‚Äù and ‚ÄúAnyEvent and fork‚Äù). <br><br>  At the moment there is a fairly large number of PSGI-servers that support event cycles.  Namely: <br><ul><li>  Feersum is an asynchronous XS server with unrealistic performance, based on EV. </li><li>  Twiggy is an asynchronous server, based on AnyEvent. </li><li>  Twiggy :: TLS is the same Twiggy, but with ssl support. </li><li>  Twiggy :: Prefork is the same Twiggy, but with workers. </li><li>  Monoceros is a young, hybrid server with both synchronous and asynchronous parts. </li><li>  Corona - asynchronous server, based on Coro. </li></ul><br><br><h2>  findings </h2><br>  Any technology has its own nuances.  Deciding which approach to use should be based on the data for each specific task, but not use the asynchronous approach everywhere, because it is fashionable. <br>  <a href="http://pragmaticperl.com/authors/6">Dmitry Shamatrin</a> </div><p>Source: <a href="https://habr.com/ru/post/248457/">https://habr.com/ru/post/248457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248445/index.html">Deploy an OpenVPN server with an InfoboxCloud control panel in the cloud and set up access for clients</a></li>
<li><a href="../248449/index.html">(Kiev) from 3 to 6 February, the course "Advanced Switch Operation, Configuration and Management"</a></li>
<li><a href="../248451/index.html">(Belarus) Foundation for data center: Juniper MetaFabric architecture</a></li>
<li><a href="../248453/index.html">Automated testing of services using the MQ protocol using JMeter</a></li>
<li><a href="../248455/index.html">CrystaX NDK 10.1 release</a></li>
<li><a href="../248459/index.html">Remove images from cartridges for Dendy / Famicom / NES</a></li>
<li><a href="../248463/index.html">How to quickly assess what is in the infrastructure and how is it used (for how much)?</a></li>
<li><a href="../248465/index.html">How we were friends Neo4j and Meteor</a></li>
<li><a href="../248467/index.html">Opened vacancies in the laboratory of software engineering</a></li>
<li><a href="../248469/index.html">(Kiev) From January 27 to January 30 the course ‚ÄúENA 15.3: Switch Operation, Configuration & Management‚Äù will take place</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>