<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Drawing vector graphics - triangulation, rasterization, anti-aliasing and new scenarios</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Back in 2013, the game Tiny Thief came out, which caused a lot of noise in the mobile Flash (AIR) development environment due to the rejection of rast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Drawing vector graphics - triangulation, rasterization, anti-aliasing and new scenarios</h1><div class="post__text post__text-html js-mediator-article"><p>  Back in 2013, the game Tiny Thief came out, which caused a lot of noise in the mobile Flash (AIR) development environment due to the rejection of raster graphics in builds, including animation atlases and other things - everything that was in the assembly was stored in a vector format directly from the Flash editor . <br>  This made it possible to use a huge amount of unique content and save the size of the installation file up to ~ 70 megabytes (* .apk file from Google Play).  More recently, there was an interest in the topic of drawing vector graphics on mobile devices (and in general on the topic of vector drawing with hardware support), and I was surprised at the lack of information at the initial level on this topic.  This is an overview article on possible vector drawing methods and already existing solutions, as well as on how such things can be done independently. </p><br><img src="https://habrastorage.org/files/447/ae5/64e/447ae564e4864a358c54fe11ad42a61a.png"><a name="habracut"></a><br><p><br></p><br><h1 id="osnovnoy-sposob">  Main way </h1><br><p>  Vector drawing is most often approached in the following way: they take all the shapes, curves and other things, they are traversed by the triangulation algorithm (separation of closed contours into triangles), assuming various kinds of strokes and lines are similarly filled objects, and get some <em>approximate</em> representation of the described mathematical figure formula. </p><br><p>  That is, the vector circle drawn in this way will actually be a polygon.  The quality criterion in this case will be the number and size of the triangles obtained in the end: </p><br><img src="https://habrastorage.org/files/181/e77/b1d/181e77b1d97340d58293414a338d110c.png"><br><p>  From left to right - </p><br><ol><li>  Inkscape source </li><li>  the result of triangulation with a low number of triangles, </li><li>  resulting triangles </li></ol><br><p>  The reason for such workarounds is simple - the graphics card is able to work effectively only with vertices, triangles and pixels (there is a slightly different story about GPGPU, but in this context it is worth mentioning in passing).  If you draw mathematically correct representations of models using the CPU, then it will take much more time.  Therefore, we simply triangulate and send the graphics card to render in raw form as is. </p><br><h4 id="podvodnye-kamni">  Underwater rocks </h4><br><p>  Such crude drawing of triangles leads to the appearance of an aliasing effect - gradation of the edges of the image (this is clearly seen in the screenshot above).  This problem is inherent in any opaque geometry, represented in the form of triangles. </p><br><p>  If you look at the screenshot of Tiny Thief, then it is immediately obvious that the game is devoid of this drawback - the edges of the objects are beautifully smoothed. </p><br><img src="https://habrastorage.org/files/4d8/4c2/43f/4d84c243f20c4619bac8a1f169c03bf0.png"><br><br><img width="398" height="316" src="https://habrastorage.org/files/e89/bb9/3c0/e89bb93c014b400fb4c1ec57ca0a1729.png"><br><br><h4 id="field-study">  Field study </h4><br><p>  I checked all the things described below with the help of Adreno Profiler, NVIDIA PerfHUD ES and Unity (testing the suggested solutions). </p><br><p>  This is what Adreno Profiler shows if you enable the color grid mode: </p><br><img src="https://habrastorage.org/files/388/852/587/388852587406408fa02c37f931a27f5a.png"><br><p><br>  That is drawing by that method of a triangulation.  Vertices are painted directly without textures (the color parameter of the vertices). </p><br><p>  Here's what's in the alpha buffer (obviously, Adreno GPU has such a thing as an ‚Äúalpha buffer‚Äù): </p><br><img src="https://habrastorage.org/files/9c3/ae3/1b2/9c3ae31b2d8b418bb2b7e5e18916b982.png"><br><p>  There is a thin single-pixel strip along the edges of the objects.  Interestingly, on the edges between neighboring objects (white background-colored letter) alpha channel is ‚Äúwhite‚Äù, that is, the entire logo is drawn in one pass, and smoothing inside such objects is implemented in a slightly different way. </p><br><p>  Shader: </p><br><pre><code class="hljs objectivec">{ lowp vec4 fcolor; <span class="hljs-comment"><span class="hljs-comment">//    color  fcolor = color; //   ,    factor fcolor.a *= factor.a; fcolor = fcolor; gl_FragColor = fcolor; }</span></span></code> </pre> <br><p>  The essence of smoothing is more or less clear - with triangulation, we add a thin set of triangles along the edge of the object. </p><br><p>  No matter how much I tried to zoom in, I couldn‚Äôt see these cunning thin triangles.  But, fortunately, Adreno Profiler, unlike PerfHUD, allows you to export geometry in text form. </p><br><h4 id="sborka-po-kuskam">  Assembly in pieces </h4><br><p>  Having written a simple parser, it turned out to restore the original mesh in Unity.  But a strange picture was waiting for me: </p><br><img width="500" src="https://habrastorage.org/files/181/b41/c9c/181b41c9cced4f7abe40d893b402f319.png"><br><p><br>  Frames without smoothing.  In the grid view mode, the filling triangles are also not visible: </p><br><img width="500" src="https://habrastorage.org/files/a45/9fe/54d/a459fe54d4794c0083a0f8961e920f29.png"><br><p><br>  For a long time I could not understand what was the matter.  It turned out that the filling triangles are <em>turned</em> in the other direction.  This becomes visible when looking at the logo on the other side: </p><br><img width="500" src="https://habrastorage.org/files/ded/630/558/ded6305581664454b35187019ab723f7.png"><br><img width="500" src="https://habrastorage.org/files/500/86f/785/50086f7851de45728e1a2bb25308fa28.png"><br><p><br>  It is also noticeable that there are empty lines between the elements of the logo, which are filled with gradients (the gradient is made by painting the vertices in the corresponding colors), and there is no smoothing. </p><br><img width="500" src="https://habrastorage.org/files/d01/064/3df/d010643dfcc14f7f869adea5bbafcdeb.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we remove the backface culling in the shader, we get what we wanted to get in the end: <br><img width="500" src="https://habrastorage.org/files/685/1c1/194/6851c1194a7d496cbad4efee0791294e.png"><br><br>  But an interesting feature arises - if you bring this object closer to the camera, then anti-aliasing becomes too noticeable and looks like a blur: <br><img width="500" src="https://habrastorage.org/files/daa/2b5/f9b/daa2b5f9b10d4143b44a7fee5435cf65.png"><br><br>  That is, triangulation occurs every time in place, depending on the screen size, and does not imply a change in the size of this object.  The size of the triangles is calculated so that the total width is one screen pixel or less. <br><p>  Almost all objects on the screen are drawn in the same way.  The exception is the background, which is rendered once in texture. </p><br><br><h4 id="statistika">  Statistics </h4><br><p>  It is interesting enough to see a summary of the drawing of characters, on average, each character (guard, cook) in a triangulated form is about 3-4 thousand triangles.  This is about as good quality low-poly 3D model.  The grid is so dense that it seems that the object is drawn with a texture: </p><br><img src="https://habrastorage.org/files/0d3/8cc/a69/0d38cca69ce349a189c816aca8bfaf0f.png"><br><p><br>  The logo occupies almost 9 thousand triangles.  The average number of draw calls on average is about a hundred (it would be much more if the background was not drawn as a texture), but the FPS is consistently maximum even on the old ZTE V811 (Beeline Smart 2). </p><br><p>  In general, while we take the first (and main) way of drawing vector graphics into the piggy bank: <br>  we triangulate our vector image, make a thin border along the joints with intermediate colors, and at the edges make a thin translucent strip. </p><br><h1 id="s-nog-na-golovu">  Turn upside down </h1><br><h4 id="sdf">  SDF </h4><br><p>  If you set a limit on the number of colors of a vector image, then you can take a completely different path.  Suppose that we have a simple vector single-color icon: </p><br><img src="https://habrastorage.org/files/2d0/bd6/248/2d0bd62480834c58b41eabdcc03a763c.png"><br><p>  It can be ‚Äúsqueezed‚Äù almost without loss of quality using the Signed Distance Field.  The bottom line is that we do not store the texture itself, but information about the distance of pixels to the border of the icon.  The value at the border is usually considered to be 0.5.  Anything more is considered an "inside" icon.  Anything less is "outside."  In fact, it does not matter which way the border is outweighed - sometimes you can make less than 0.5 inside and more than 0.5 outside.  For clarity (black icons on a white background) I will show just such an option. </p><br><img src="https://habrastorage.org/files/4f0/deb/b20/4f0debb20670484c832976f7cf255aa6.png"><br><p><br>  The dice so spread out looks like this: </p><br><img src="https://habrastorage.org/files/d0d/738/5ba/d0d7385ba55c46cba0feb076591ef6c5.png"><br><p>  The difference from the usual blur is that by finding the minimum distance between the current pixel and the border, in any case, we will calculate the distance along the normal (the minimum distance from the point to the line is always determined by the perpendicular).  That is, the gradients on the texture describe the direction of the normal to the nearest border. </p><br><img src="https://habrastorage.org/files/bc7/b29/5d5/bc7b295d506349f1bd98d49401eeafac.png"><br><p>  On the Internet and, in particular, on Habr√© there are a lot of articles about SDF, I will give them at the end of the article. </p><br><img width="550" src="https://habrastorage.org/files/5b5/41d/e9f/5b541de9f5bc45158356ac5535171a69.PNG"><br><p>  The picture clearly shows the difference in quality between a regular texture and two variants of SDF.  When you increase the usual images are clearly visible blur.  By increasing the SDF texture, we will in any case get sharp boundaries.  Moreover, even having reduced the size of the texture by half, the presence of artifacts remains almost imperceptible (you can write a separate article about increasing the quality of the raw SDF texture).  Artifacts, in contrast to the usual texture, appear as a smoothed ladder at the beveled edges of the icon.  This is due to the fact that the pixels go exactly horizontally and vertically, and as the image size decreases, the accuracy of the oblique straight approximation also decreases with the help of two perpendicular (recall that we approximate the normal vector to the boundary). </p><br><p>  The shader for drawing will be just a little more complicated than just reading the texture.  In the experiments, I tried a lot of different options, including  and a variant from the article [2], in general, it looks like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> frag (v2fSDF f) : SV_Target { float2 uv = f.uv; half4 texColor = tex2D(_MainTex, uv); //   -  half distance = texColor.a; //    half smoothing = _Smoothing; //    -   _Dilate = <span class="hljs-number"><span class="hljs-number">0.5</span></span> half2 range = half2(_Dilate - smoothing, _Dilate + smoothing); //   (   - ) half totalSmoothing = smoothstep(range.x, range.y, distance); half3 rgb = f.color.rgb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">float4</span></span>(rgb, totalSmoothing); }</code> </pre> <br><p>  It is worth noting that in this case the RBG texture channel is thrown out and is not involved in the calculations (to this we will come back later).  You can <em>adjust</em> _ <em>Smoothing</em> either manually under the current size of the texture on the screen (but then there will be the same problem when enlarged, as was the case with drawing through meshes), or use the <em>cg</em> function <a href="http.developer.nvidia.com/Cg/fwidth.html"><em>fwidth</em></a> , which roughly estimates the size of the current fragment relative to the screen and ‚Äúadjusts "anti-aliasing under the relative size of the icon on the screen. </p><br><p>  Since the main limitation of the SDF method is the need for "binary" (monochrome) of the original symbol, it is most often used when drawing text - by adjusting and modifying the processing options of the same SDF texture, you can create a stroke, shadow, blur, etc.  [one].  A less popular way to use SDF is to draw monochrome icons (as is the case with the image of a die), but for the most part this is just a special case of a text character. <br>  Another disadvantage of this approach is the loss of sharp edges and corners: </p><br><img width="500" src="https://habrastorage.org/files/b9c/714/fa4/b9c714fa48064e8f8555c927f4355a9f.png"><br><br>  On the left - the original texture.  Right - reduced size SDF <br><br>  And another example with the text from the article [3]: <br><img src="https://habrastorage.org/files/968/e04/f17/968e04f1700d42499d9aaafa99bb5983.jpg"><br><br><h4 id="reshenie-problem-po-mere-postupleniya">  Problem solving as they become available </h4><br><p>  There are examples of the implementation of a similar algorithm that preserves sharp angles [4] [5]: <br><img src="https://habrastorage.org/files/018/b54/cfa/018b54cfa7eb4c8abc5b523dbbbe1238.png"><img src="https://habrastorage.org/files/f08/32e/3ab/f0832e3abb804c699f9fa3760de761cf.png"></p><br><p>  The brief essence of the algorithm is as follows: </p><br><p>  The raw SDF rounds the corners because the farther the pixels are from it, the stronger it is rounded.  This happens because the perpendicular cannot be drawn to the corner (the derivative of the function does not exist at this point) - many pixels will count the distance along the radius of the circle, the center of which is just the angle.  This can be avoided by tracing all the angles of the symbol by checking the gaps with a smoothly running curve.  And then, using the truth table, determine whether the quadrant of the angle should be shaded or not.  That is, the corners are usually painted over with intersected SDF cards recorded in different channels, and the final pixel value is calculated by the median of the vectors from the three channels. </p><br><p>  Of course, I can not contain the entire article on 90 pages in one paragraph, so I advise you to look at it in full [5]. </p><br><p>  There were earlier attempts to do something similar with the intersection of various fields scattered across the channels, but some options do not suggest the presence of tricky possibilities of adding shadow, stroke, or increasing the thickness of the symbol, unlike the example described (due to the fact that distance fields per se). </p><br><br><h4 id="menshe-kanalov---bolshe-tochnosti">  Less channels - more accuracy. </h4><br><p>  There is a companion on Twitter who does something like this by hook or by crook, but with one channel: </p><br><img src="https://habrastorage.org/files/abf/b18/1af/abfb181af8fa44e59041c9ae2a3a4fb1.png"><br><p><br>  If you look at the various links on his <a href="https://twitter.com/adamjsimmons">twitter</a> , you can stumble upon some options for implementation.  As I understand it, the approach differs from the standard SDF in that the actual distance to the borders is not used (to avoid that rounding around the corner-center), but a slightly reinterpreted figure is used, the corners of which continue further.  This eliminates both the rounding of corners and several channels, simplifying the shader, and reducing the total amount of information required to represent such shapes. </p><br><p>  This comrade also has a <a href="https://www.shadertoy.com/view/ltXSDB">shader</a> that reads the distance field for the bezier curve on the GPU in real time, but it requires desktop computing power even for one curve (which is set parametrically and its formula lies "right in the shader").  If you twist the settings and code, you can see the distance field itself without shading and modulation: </p><br><img width="500" src="https://habrastorage.org/files/a39/a22/f40/a39a22f405c940d8a0ec4b07ef95beef.png"><br><p><br>  The general essence of these methods lies in the analysis of the curve defining the character boundaries. </p><br><br><h2 id="vozvraschaemsya-k-istokam">  Back to basics </h2><br><p>  You can also go the third way - not to store raster information about any symbol, but to draw, so to speak, ‚Äúfrom the oven‚Äù - directly from the vector representation of the curves.  The problem is that it is relatively difficult to transfer information about curves to a graphics card without loss of performance.  There are several articles describing similar methods: </p><br><p>  <a href="http://wdobbie.com/post/gpu-text-rendering-with-vector-textures/">GPU text rendering with vector textures</a> [3], and Microsoft even has a <a href="https://www.google.com/patents/US7872648">patent</a> . </p><br><p>  In short, the essence is as follows: </p><br><p>  We divide the symbol into cells, for each cell we make a map of the intersection of the curves with the rays, fired at different angles and intersecting this cell.  We look at the number of intersections and the distance at which these intersections occur.  Curve data is stored in the form of a crumpled texture, in which the coordinates of the bezier curves are given.  One bezier curve is 3 or 4 parameters depending on the degree of this curve.  Above the 4th parameter, curves are usually not taken.  The shader is concerned with the fact that, depending on the current cell being drawn and the texture parameters present on this cell, it reads the necessary pixels from the reference texture and uses them to reconstruct the analytical view of the curve on the GPU. </p><br><h4 id="ne-vsyo-tak-raduzhno">  Not everything is so rosy. </h4><br><p>  The disadvantage of these approaches is the use of a relatively large number of texture read operations.  I once dealt with realtime shadow rendering with a tap blur blur on mobile devices, and any Dependent Texture Reads (DTS - I did not find a generally accepted analogue in Russian) significantly impaired performance.  If it is very rough - DTS occurs when the read coordinates of the texture are known only in the fragment shader, that is, directly when the pixel is drawn.  Usually, a high speed of reading a texture in a fragment shader is caused by the fact that a particular interpolated texture coordinate of a pixel becomes known immediately after the vertex shader is working, that is, the video card reads the desired pixel of the texture in advance and gives the pixel value "free."  The algorithms, behavior and degree of effort are determined primarily by the iron on which these shaders are executed.  In OpenGL ES 3.0+, it seems like the DTS performance problem is mostly solved, but at the moment about half of mobile devices are running on OpenGL ES 2.0, so for now you shouldn‚Äôt hope for a good hardware. <br><img src="https://habrastorage.org/files/158/27d/082/15827d082bd345f5a6ad76cb02f24c30.png">  ( <a href="https://developer.android.com/about/dashboards/index.html">source of February 6, 2017</a> ) </p><br><p>  It is worth noting that the patented Microsoft approach allows using 4 channels to encode the color of the pixels in a cell.  And it was from the very beginning that I became interested in drawing color vector images. </p><br><br><h3 id="kak-zhit-dalshe">  How to live on </h3><br><p>  The methods described above have the following disadvantages: </p><br><ol><li>  The quality of the image with the method of triangulation in a mesh significantly depends on the number of triangles, which increases the allocated memory and the load on the video card (small but dense grids load the GPU more than the texture of the same size drawn on the quad). </li><li>  SDF as is does not imply the possibility of drawing multi-colored elements.  One of the conditions is the "binary" of the original image. </li><li>  The methods of "random access" to the pixels defining various vector parameters require a lot of computational power on the GPU side, in particular, a lot of time is spent on additional texture reads. </li></ol><br><p>  Therefore, I had a desire to offer a slightly different way of drawing multicolored vector graphics, based on the same principle of the SDF. </p><br><h4 id="vtoraya-zhizn-dlya-sdf">  Second Life for SDF </h4><br><p>  SDF has become synonymous with monochrome text character rendering.  But if you imagine a vector image as a set of monochrome layers, then using the same SDF texture, you can draw a vector image of any complexity and color.  That is, we simply divide the initial image into a set of monochrome layers. </p><br><p>  An example - a box from Kenney's popular kit, cut into layers, looks like this: </p><br><img width="500" src="https://habrastorage.org/files/fa0/d03/de6/fa0d03de62a74fcdbb8aa0d6210aea04.png"><br><p>  This is the look of the SVG file.  You may notice that the layers do not overlap, but "fit" together.  When viewing such vector images through Inkscape, artifacts inherent in such a matching of these layers are clearly visible: </p><br><img width="500" src="https://habrastorage.org/files/89f/e23/7a0/89fe237a0918442c82434811638cf0e6.png"><br><p><br>  The presence of artifacts depends on how you create vector graphics, but for now let's take this option. </p><br><h4 id="k-deystviyam">  To action </h4><br><p>  For each layer, we will create our own SDF texture and set the layers on top of each other in the same order in which they appear in the SVG file. </p><br><img src="https://habrastorage.org/files/8c0/3fb/7f4/8c03fb7f40ee4c12a59cf99ed7b101f3.png"><br><p><br>  From left to right - SVG Importer with antialiasing enabled, ‚Äúpuffy‚Äù SDF, increased initial texture.  SVG Importer was unable to parse the SVG from Inkscape normally, but that's not the point. </p><br><p>  If you bring both objects very close, the differences look like this: </p><br><img src="https://habrastorage.org/files/0ca/c49/045/0cac49045b024544bc2f967ebd7dfd10.png"><br><p><br>  Triangulation: </p><br><ul><li>  jagging is noticeable on the roundings, limited by the number of triangles (-) </li><li>  cracks may occur at joints for the same reason (-) </li><li>  sharp sharp corners (+) </li><li>  minimum overdraw (translucent geometry that overlaps each other) (+) </li><li>  total amount of triangles - 568 </li><li>  allocated memory - 44 Kb </li></ul><br><p>  Puff SDF: </p><br><ul><li>  a direct disadvantage of the classical approach is the loss of sharp corners (-) </li><li>  substantial overdraw (-) </li><li>  the total number of triangles is 26 (textures are drawn not on quads, but on automatically generated meshes encircling the texture in alpha. For a simpler version, you can simply multiply the number of layers by 2, that is, 10 triangles) (+) </li><li>  On a three-channel texture size of 256x128, compressed using ETC4.  The layers are scattered across the channels, the layer size is 128x128, that is, three layers on the left side of the atlas in a separate channel and two layers on the right side of the atlas.  Allocated memory - 16 KB (+) </li></ul><br><p>  The main disadvantage of this method compared with all the others is a substantial ovedraw.  To draw this box you need 4 full-size layers placed on top of each other, plus a small quad for the fifth layer (a little dash).  In the worst case, overdraw will be directly proportional to the number of layers of the vector image.  The higher the resolution of the device, the slower the rendering will work. <br><br>  But unlike most packages for parsing SVG files into meshes, pre-prepared textures take up much less space.  Scaleform in this plan went further - they generated all the meshes on the fly while loading the scene, without clogging the application archive with previously created files.  For comparison, the initial size of the box is 4 KB of text, that is, the mesh of the vector image previously collected with smoothing takes up 11 times more space than the raw text describing this vector shape. </p><br><h4 id="varianty---tysyachi-ih">  Options - thousands of them </h4><br><p>  I also stumbled upon another way of converting a color image into an SDF view.  [6] The bottom line is to use bit planes images for colors.  Bit cards lay out the brightness of the color bit by bit. <br><br>  That is, the bits of brightness are taken in order and put into a separate binary texture.  Only one image channel needs 8 textures.  That is, 24 textures per color image without transparency. <br><br>  If you go further and present each such binary texture as an 8-bit SDF texture, then it turns out that for a full representation of the initial image you will need 24 eight-bit textures (and not 24 single-bit ones, which are obtained immediately after decomposition into bit-cards). <br><br>  The process of restoring the initial color image from the bit-cards processed using the SDF is as follows: </p><br><ol><li>  For each bitmap of each channel, the current SDF pixel value is checked. </li><li>  If it is less than 0.5, then the source bit is 1, if it is greater than 0. (0.5 in this case is an abstract value, the whole eight-bit numbers are compared with the value 127) </li><li>  All values ‚Äã‚Äãof all bits are collected in order and each channel is restored separately.  For example, if the current pixel of the red channel has the bit values ‚Äã‚Äãequal to 01110011, then the red channel brightness is 115 </li><li>  Passing through all channels of the current pixel in the same way. </li><li>  We restore the color value in three channels. <br></li></ol><br><br><p>  Although this algorithm is quite tricky, the quality leaves much to be desired: </p><br><p><img width="250" src="https://habrastorage.org/files/2e3/3c3/470/2e33c347055b47a3b67832acbba1e8d9.png"><img width="250" src="https://habrastorage.org/files/e4d/4ce/81f/e4d4ce81f9804f35b77b02be0534a5a6.png"><img width="500" src="https://habrastorage.org/files/354/0cb/15f/3540cb15ff31465898c358249f69a1d9.png"></p><br><p>  Artifacts are caused by the fact that the problem of loss of accuracy when storing a reduced copy of an SDF texture is worsened by cutting color channels into a bitwise component.  In my opinion, this method is not particularly applicable for this reason.  But another drawback is the need to store 24 eight-bit SDF textures per source color image. </p><br><h3 id="itogi">  Results </h3><br><p>  I cannot offer a new full-fledged out-of-the-box solution, but there are ideas and attempts to make SDF encoding on palettes with contour markings, which may help to get rid of storing a large number of different textures for different channels and reduce overdraw. </p><br><p>  The article has already turned out very large, and I had to significantly cut content.  From what is not told: </p><br><ul><li>  <a href="https://habrahabr.ru/post/307766/">The easiest way to rasterize vector graphics without a headache and sleepless nights</a> <br>  The article above brought me to a friend of <a href="https://habrahabr.ru/users/therabbitflash/" class="user_link">TheRabbitFlash</a> , who shared a huge amount of information about rasterizing vector graphics in general and Flash in particular.          "" Adobe Flash (    Adobe Animate),         . </li><li>    <a href="http://forum.starling-framework.org/topic/tiny-thief-by-rovio-stars-is-a-flash-game/"> Scaleform Mobile SDK</a>     5 Ants   Starling,            Tiny Thief,           Flash + Starling. </li><li>               . </li><li>         ( Tiny Thief     2561). </li></ul><br><ol><li> <a href="https://habrahabr.ru/post/215905/">Signed Distance Field      </a> </li><li> <a href="https://habrahabr.ru/post/282191/"> UTF-8    SDF </a> </li><li> <a href="http://wdobbie.com/post/gpu-text-rendering-with-vector-textures/">GPU text rendering with vector textures</a> </li><li> <a href="http://computergraphics.stackexchange.com/questions/306/sharp-corners-with-signed-distance-fields-fonts">Sharp Corners with Signed Distance Fields Fonts</a> </li><li> <a href="https://dspace.cvut.cz/bitstream/handle/10467/62770/F8-DP-2015-Chlumsky-Viktor-thesis.pdf">Shape Decomposition for Multi-channel <br> Distance Fields</a> </li><li> <a href="https://gpuhacks.wordpress.com/2013/07/08/signed-distance-field-rendering-of-color-bit-planes/">Signed Distance Field rendering of color bit planes</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/318880/">https://habr.com/ru/post/318880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318870/index.html">"Kazakov" no secrets</a></li>
<li><a href="../318872/index.html">How to write the best post on Habr√©. 7 answers, 7 tips</a></li>
<li><a href="../318874/index.html">Difficulties on the way of creating a ‚Äúuniversal‚Äù metamodel for modeling subject domains</a></li>
<li><a href="../318876/index.html">VCL, get rid of flicker, once and for all</a></li>
<li><a href="../318878/index.html">History of participation (and almost victory) in the annual competition Russian AI Cup 2016</a></li>
<li><a href="../318882/index.html">Launch Telegram bot on Android device (Remote Bot for Telegram)</a></li>
<li><a href="../318886/index.html">Comparison of signal recognition methods. Neural networks against matched filter</a></li>
<li><a href="../318890/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ243 (December 26 - January 1, 2017)</a></li>
<li><a href="../318892/index.html">Pebble for lazy programmers</a></li>
<li><a href="../318894/index.html">How fake programmers design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>