<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DoT.js template engine improvements</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The time of the template zoo has passed, now MVC dinosaurs are running around, and they use built-in template engines and component builders. But to r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DoT.js template engine improvements</h1><div class="post__text post__text-html js-mediator-article"> The time of the template zoo has passed, now MVC dinosaurs are running around, and they use built-in template engines and component builders.  But to replace the old less convenient template engines in Knockout and Backbone, they are sometimes needed, mostly stopped in development at about 2014. <br><br>  It happened with <a href="https://github.com/olado/doT">DoT.js.</a>  Initially abandoned by the authors for about a year in 2013, he received their attention briefly, rising from version 1.0.1 to 1.1.1, and was again abandoned (or stabilized, depending on how you argue).  In this connection, it was needed in 2013 ( <a href="">to make a clone of DoT.js</a> ), and now we need <a href="">to</a> upgrade it. <br><br>  It is as fast as the built-in <code>_.template()</code> in Underscore / Lodash, but with an improved syntax, in which the need to write JS in templates is rare, and in Underscor is always needed.  These brackets with scripts even came up with a special term: javascript encapulated sections (JES), and basically got rid of them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What we get in addition? </h3><br>  1. The template structure <a href="">was redesigned (in 2013, a link from there)</a> to better read and reduce the number of decoding functions; <br>  2. <a href="https://habrahabr.ru/post/201592/">Tests have shown</a> that the speed on the average has not changed (fluctuations -3% - + 10% depending on the parameters); <br>  3. Added team work on the structure, similar to the work on the array; <br><a name="habracut"></a>  4. The 4th parameter is a filter of elements of a structure or array; <br>  5. In some places, slowdowns due to bypassing bugs are compensated for by optimizing the code and regexps; <br>  6. The global name ‚ÄúdoT‚Äù is capable of changing to another in the settings (the original is not); <br>  7. The order was introduced in the version numbering and versioning of the global functions encodeHTML () - the instances adopted here for optimization. <br><br><h4>  <i>For reference on version numbering</i> </h4> <i><br></i>  <i>In npm, a copy of version 1.1.1 of one-in-one in package.json is named as 1.1.2, but in the file there is the number 1.1.1;</i>  <i>in branch 2.0 in repo - the same with non-update of number 1.1.1 and there is only 1 difference in <code>var rw = unescape(...)</code> .</i>  <i>In general, everything is done for confusion.</i>  <i>Therefore, we believe that the newest version is 1.1.1, in which we take into account the difference from branch 2.0.</i>  <i>Vetka 2.0 does not deserve its title.</i> <br><br>  On occasion, it is convenient to make the documentation (there is <a href="http://olado.github.io/doT/index.html">from the authors</a> ), with a tool for checking it.  (What was readable on the web - links below.) In short: <br><br>  ‚Ä¢ he retained the ‚Äúoriginal‚Äù syntax of Underscore <code>_.template()</code> , in which we can write any JS code inside parentheses " <code>{{ ... }}</code> ", including unclosed curly and operator brackets, and outside the parentheses - HTML-text fragments. <br>  ‚Ä¢ brackets can be redefined by overriding in the settings all regexps with them (usually not necessary); <br>  ‚Ä¢ the name of the senior element of the <code>'it'</code> structure can also be redefined, as well as 4 logical settings of the behavior; <br>  ‚Ä¢ AMD, commonJS and just its global name ( <code>'doT'</code> ) are <code>'doT'</code> ; <br>  ‚Ä¢ besides the basic universal syntax, it has a number of commands similar to the Mustache / Handelbars style; <br>  ‚Ä¢ like them, and <code>_.template()</code> , has 2 stages of templating (parameter currying) into a function and then into HTML (or other) code; <br>  ‚Ä¢ not sharpened strictly under HTML, but tied to JS, so its scope is browsers and NodeJS; <br>  ‚Ä¢ not much larger in volume than the source code <code>_.template()</code> - 3.3 K in compressed non-zipped form. <br><br>  <i>(To experiment with the code of a new or old template engine, you can use the old example in <a href="http://jsfiddle.net/6KU9Y/2/">http://jsfiddle.net/6KU9Y/2/</a> (but then there is a js-fiddle better.) A convenient testing page for 2 engines on a common template and data is also built in the repository - in <code>test/index.html</code> . By default, it compares the same results in the deployed and minified versions of files. And the second engine can work only with a clone, since it may have a global name other than <code>'doT'</code> . clone, and in the first place, for example, the original DoT.js</i>  <i>1.1.1 and watch the differences in parsing.)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/98e/aac/7bd/98eaac7bd53342819461c508c5c4542a.jpg" alt="image"></div><br>  In the file of the second engine you need to set the name <code>globalName:'doTmin'</code> before opening the page. <br><br>  However, the same is easy online: <a href="https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/">https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/#Result</a> or with frames and code editing, who has big screens: <a href="https://jsfiddle.net/spmbt/v3yvpbsu/26/">https://jsfiddle.net/spmbt/ v3yvpbsu / 26 /</a> .  You don‚Äôt need to connect files, just copy the contents of 2 versions of DoT.js, and in the second, it‚Äôs more convenient to do it in a clone - correct the name <code>doT</code> to <code>doTmin</code> (even if not minimized).  The default is DoT.js 1.1.1 original and DoT12.js 1.2.1 is a clone. <br><br>  The benchmark (the 3rd button) is arranged over a short period of time, therefore it depends on parallel processes, and the speed of synchronous algorithms can be judged by averaging over a large number of measurements (the average accumulates and allows a little to judge the speeds).  There is a built-in benchmark in the project, but it is complicated, through the node, and it does the same (for a group of test files). <br><br>  The auto-update checkbox and error trapping are built into the test page, which allows you to test for the version that remains intact.  So, it is easy to compare the speeds of the <code>'~'</code> and <code>'@'</code> commands by array.  The second one can also work, but much slower - by 10-15% (checked with the ‚ÄúBench‚Äù button).  This is due to the need to use a slower for-in loop in the second case.  However, it is impossible to do without for-in for structures, in order not to have the need to prepare arrays from structures for the original version, which does not have the <code>'@'</code> command. <br><br>  Immediately, traditionally, we note that the 2nd calculation (calculation <b>on a compiled pattern</b> ) is a hundred times <b>faster (for short expressions) than the full compilation</b> each time (the 1st number, 100 times fewer dimensions).  In the screenshot, " <code>Comp1e3: 99.22ms</code> " means: "1000 full compilations were performed in 99.22ms time."  " <code>Run5e5: 69.08 ms</code> " in the 5th line means: "50 thousand fast HTML generations with a pattern are carried out for an average time of 69.08ms for every 10 thousand generations". <br><br>  A <b>drop-down list of examples has been</b> added, from which typical examples of DoT.js commands can be extracted and tested in 2 versions of the script.  Example changes are temporarily saved and can be returned to them by re-selecting the previous item of the example, if the browser page has not been reloaded. <br><br><h1>  About teams - read more </h1><br>  At the beginning of the paragraph in quotation marks will be given the name, which in the <code>DoT12.js</code> code is the regular expression that is responsible for the given template function (command). <br><br><h4>  " <b>ValEncEval</b> " <b>command</b> </h4><br>  One regexp under this name combines 3 previous commands that have similar syntax. <br><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{     JS }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  Underscore Universal Heritage.  Nothing more is needed; it is self-sufficient to describe everything (spaces in parentheses are optional).  But read ... Read more 40 lines is strictly not recommended.  JS unclosed brackets are interspersed with the same curly braces of the template engine.  They are followed by unclosed HTML tags.  This is a normal practice, it works fine, the machine understands.  At the same time, Mustache / Handlebars are already readable. <br><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{=  JS }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  The value of the expression is laid out in the surrounding stream of HTML, with the preservation of HTML tags and despite the unclosed tag brackets.  So, encountered <code>"&lt;br&gt;"</code> in the meaning of the expression, if it is posted on the browser page, will behave not as text, but as a tag - will lead to the transfer of the line according to HTML rules. <br><br><pre> <code class="hljs erlang-repl">{{!  JS }}</code> </pre> <br>  The same, but returning text to the output with ‚Äúhitting‚Äù the HTML code: html-tags and html-encoded ( <code>&amp;...;</code> ) characters turn into text; <br><br><h4>  Command " <b>conditional</b> " </h4><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{? if- }}</span></span><span class="xml"><span class="xml"> then- </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{?}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  Conditional inclusion of the template (spaces in brackets are optional); <br><br><pre> <code class="hljs vbscript">{{? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>- }} <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>- {{?? [<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>-]}} [<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>-]<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>- {{?}}</code> </pre> <br>  branching and conditional text chain templates. <br><br>  An expression is any containing a global variable or a structure with the name <code>'it'</code> , into which the parameter is passed during templating. <br><br>  if-else is easy to get by inverting the if-expression.  The syntax did not complicate, apparently, for the sake of speed. <br><br><h4>  " <b>Use</b> " command </h4><br><pre> <code class="hljs objectivec">{{<span class="hljs-meta"><span class="hljs-meta"># ,   }}</span></span></code> </pre> <br>  Analogue of the preprocessor (macros) - at the beginning you can insert any fragment of the text, including unmatched template brackets.  The result will be compiled.  For example, through <code>{{# ...}}</code> you can add to the template the text of another template through a variable.  But the team was conceived for simpler and more concrete cases, paired with the define command. <br><br><h4>  " <b>Define</b> " command </h4><br>  Appeared from version 1.0.  At first it was decided not in the text of the templates, but in the list of parameters after the settings (the 3rd parameter in doT.template (template, settings, parameters)). <br><br>  The definition format of a variable for use-commands in the define command: <br><pre> <code class="hljs scala">{{## <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defin1</span></span></span><span class="hljs-function"> </span></span>:___#}}  {{## <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defin1</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">=___#</span></span></span><span class="hljs-function">}} </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span></span>()</code> </pre> <br>  Variables can be with points and $, in them any line is defined.  There are a number of tricks. <br><br>  The points in the name (the style of someone copied). <br><br>  If the first 4 characters are 'def.', They are deleted. <br><br>  If after a colon - the pairs are written def [code] = {arg: param, text: v}; <br><br>  The equality defines the function 'def' (it is convenient to look at the test page in the list of examples). <br><br>  You can define a macro in one place so that you can use it 2 or more times.  Like all macros, it is doubtful in terms of code quality.  If you need macros - it means - it took you to stand before someone, reducing the size of the texts in a dirty way, because it was not time to think out how to reduce it from the point of view of the project.  And the storage of variables is spent script resources. <br><br>  There is a certain plus in the fact that the environments and workplaces of the script are separated, as with a couple of use-useParams commands. <br><br>  And there is a semantic difference in the fact that scripts are executed on the fly, at the time of associating a template with data, and define and use are one step earlier when associating a template function with a template.  In a word - these are macros. <br><br><h4>  The " <b>defineParams</b> " <b>command</b> </h4><br><pre> <code class="hljs objectivec">{{<span class="hljs-meta"><span class="hljs-meta">##foo=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bar"</span></span></span><span class="hljs-meta">#}}</span></span></code> </pre> <br>  So the parameters are determined, accumulating in the internal structure, and then used many times after. <br><br><h4>  " <b>UseParams</b> " <b>command</b> </h4>  Using previously defined parameters. <br><br><pre> <code class="hljs objectivec">{{<span class="hljs-meta"><span class="hljs-meta">#def.foo}}</span></span></code> </pre> <br>  Nothing prevents to take, and determine the parameters in JS: <br><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{  JS }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  besides the reluctance to mix the environment of the template and the rest of JS.  Here syntax highlighting and code analysis in the IDE and editors will be lost.  Therefore, there are more reasons for not writing JS in template texts. <br><br><h4>  " <b>Iterate</b> " command </h4><br>  Combining 2 teams with different speeds and capabilities.  The while template <code>{{~...}}</code> is a while loop through the array.  (They chose, obviously, from everything and chose the fastest at that moment in browsers.) Works faster by 10-15% than its alternative <code>{{@...}}</code> on the for-in-template, which can run through the array or on the structure.  4th parameter - filtering elements by expression.  The original version supports only the array and without filtering.  It does not suit - there is always " <code>{{ ... }}</code> " (it is convenient to write, to read - no, like Perl or machine code). <br><br><pre> <code class="hljs mel">{{~ it : value : index : <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> }} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>- {{~}}</code> </pre> <br>  where <code>it</code> is the word <code>'it'</code> (or another), meaning the first argument, or the global name of the array, or an expression that returns an array;  <code>value</code> - any name, for example, <code>'v'</code> or <code>'value'</code> without quotes, which will be used in the for-template in place of the substituted value of the array element, for example, in the expression <code>{{= value+1}}</code> ;  <code>index</code> - likewise, any name that defines the index of an element in an array. <br><br>  Yes, the parameters are indicated ‚Äúon the contrary‚Äù (first value, then index), but this is how they turned out, we will not change here and in the next similar command.  The logic is that the last (and in general the last) <code>index</code> can be omitted, if not needed in the template, along with a colon. <br><br>  You can omit other parameters in the clone, leaving a colon.  In the original - it is impossible: at least a letter, but it is necessary to write.  The first default parameter is 'it' (or rather, <code>templateSettings.varname</code> ), the rest also have defaults, but they are very technical, not memorable. <br><br>  In sum, everything is done in such a way that both the compilation and the execution of the templates are as fast as possible, without unnecessary actions and beauty.  Most likely, something else can be improved, and some performance improvements will worsen the compile time, so there is a reasonable balance in everything. <br><br><pre> <code class="hljs mel">{{@ it : value : index : <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> }} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>- {{@}}</code> </pre> <br>  Running through the structure of its first level.  It is performed in the browser more slowly (% by 10-15) than in the array. You must take into account the peculiarities of the order of issuing keys-numbers and other keys (numbers go first, then all other keys, except for old versions of IE of type 8 and lower, Opera and old Fxs of the same past time. Where numbers went in the same row as others.).  Moreover, no standard guarantees order, but it exists.  Using it, or testing it, or relying on arrays is a matter for the developer.  The most reputable will say that you cannot be 100% trusted and will be right.  Same story in both Python and JSON. <br><br>  At the same time, using the order in which JSON arrived or the structure was defined reduces the size of the procedure code.  The 4th parameter is an expression - filter condition.  If false, the item is not displayed.  (If there is no condition, is the parasitic <code>"if(1)"</code> condition preserved? This is the balance charge.) <br><br><h4>  Examples of abbreviations </h4><br><pre> <code class="hljs mel">{{@::i}} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>- {{@}}</code> </pre> <br>  it's just a walk through all the elements of the structure. <br><br>  Example: <br><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{@::i}}</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{=it[i]}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{@}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  don't care <br><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{@:v}}</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{=v}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{@}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br>  Instead of patterns, you can use arrays in <code>"@"</code> commands.  But on the contrary, in <code>"~"</code> -commands (in arrays) - structures - it is impossible, for the sake of compatibility with the original. <br><br>  ... After 7 years, all this will disappear and die under the weight of new magnificent frameworks, where the issues will be resolved in their own way and in a different way.  forEach, filter, reduce, JSX - template killers are already on the threshold and with one foot each on this side of the door.  And even chimpanzees can manage screen layouts.  In the meantime - hurry to dig in crutches, until they finally become stories like K155LA3. <br><br><h1>  What are the settings and why are we needed </h1><br><pre> <code class="hljs cs">varname: <span class="hljs-string"><span class="hljs-string">'it'</span></span>,</code> </pre> <br>  This setting is quite understandable.  In template expressions, the name is used instead of arguments [0] (the first parameter of the intermediate compiled function).  arguments [0] are far from always being applied because of nested functions, and the name is almost always if there are no conflicts.  If there are conflicts, the name can be changed, moreover, not only directly in the library template's code, which is moveton, but also in the 2nd parameter <code>doT.template()</code> , in the local settings of the current command.  (There is also a way to "static" change settings, getting to them by <code>window.doT.templateSettings</code> .) <br><br>  There are other specific names for this template engine that can cause conflicts.  They are easy to see on the test page by clicking the "Show function" button on the <code>test/index.html</code> page.  These are the names: <code>out, arr1, arr2</code> , ..., ll (two small L), v, i (when passing through arrays. They screen the same external names. But <code>it</code> is on a special account, without it - nowhere, therefore rendered in the settings. <br><br><pre> <code class="hljs objectivec">strip: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,</code> </pre> <br>  Discarding extra spaces, tabs and line breaks.  If the formatting of the output text is not important, use true.  The function and template will be shorter, and the compilation speed, however strange it may seem, is slightly lower (1-2%);  performance - speed indistinguishable.  Those.  to speed up the compilation you need to set <code>strip: false</code> . <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">append</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,</code> </pre> <br>  The style of adding pieces of HTML code and data to the out variable is summation in a chain or assignment operators.  The latter lengthens the text of the function, therefore, if it is not particularly needed, we select true.  (Apparently, once it was a question - what to choose and what works faster.) <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">log</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,</code> </pre> <br>  Not used.  Either you forgot to delete it, or you need it somewhere in neighboring scripts like NodeJS - express. <br><br><pre> <code class="hljs objectivec">selfcontained: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,</code> </pre> <br>  Here is a little optimization story.  The <code>doT.template(...)</code> function can be prepared in one common environment ( <code>_globals</code> ) and immediately executed as <code>doT.template(...)(...)</code> , or it can be <code>doT.template(...)(...)</code> separately (come by ajax or from a file) .  In the latter case, you need true (extends the function doT.template (...)), and usually, in the first case - false.  Then it is not necessary to generate too much in it, and the calculated is saved in <code>_globals._encodeHTML</code> generated from <code>_globals.doT.encodeHTMLSource()</code> , but not always, but only with the presence of <code>{{! }}</code>  <code>{{! }}</code> in templates. <br><br>  In other words, <code>selfcontained = true</code> means that the template function <code>doT.template()</code> will be used separately from doT.js, so it must contain everything to perform the template.  All - this means only a special case of coding HTML symbols with <code>{{!}}</code> Commands.  If they exist, the function should include the definition of the encoding function - the string <code>doT.encHtmlStr</code> when it is created (this is done in clone 1.2.1, and in the original, the <code>encodeHTMLSource</code> function <code>encodeHTMLSource</code> converted to a string). <br><br>  In version 1.1.1 of the original there is a flaw - the algorithm always ‚Äúputs‚Äù the function code in the template, without compression, even if <code>selfcontained = false</code> , this had to be fixed.  This function also binds the <code>doNotSkipEncoded</code> parameter <code>doNotSkipEncoded</code> time, although this is only necessary when creating a template function. <br><br>  Then, in the original engine, there is a version conflict problem, because they use a global object (window, globals) to optimize the use of the HTML coding function.  It was decided in clone 1.2.1 in that the global name of the encoding function was chosen dependent on the name of the engine and version.  It turned out like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encHt = <span class="hljs-string"><span class="hljs-string">'_'</span></span>+dS.globalName + doT.version.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\./g</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>). ... encHtmlStr:<span class="hljs-string"><span class="hljs-string">'var encodeHTML=typeof '</span></span>+ encHt +<span class="hljs-string"><span class="hljs-string">'!="undefined"?'</span></span>+ encHt +<span class="hljs-string"><span class="hljs-string">':function(c){return((c||"")+"").replace('</span></span> + (dS.doNotSkipEncoded ?<span class="hljs-string"><span class="hljs-string">'/[&amp;&lt;&gt;"\'\\/]/g'</span></span>:<span class="hljs-string"><span class="hljs-string">'/&amp;(?!#?\\w+;)|[&lt;&gt;"\'/]/g'</span></span>) +<span class="hljs-string"><span class="hljs-string">',function(s){return{"&amp;":"&amp;","&lt;":"&lt;","&gt;":"&gt;",\'"\':""","\'":"'</span></span><span class="hljs-string"><span class="hljs-string">","</span></span>/<span class="hljs-string"><span class="hljs-string">":"</span></span>/<span class="hljs-string"><span class="hljs-string">"}[s]||s})};'</span></span></code> </pre> <br>  We get the string to insert into the template function, but if <code>selfcontained = false</code> and there is <code>{{! }}</code>  <code>{{! }}</code> , then we limit ourselves to executing it in the global object, in order to use <code>encodeHTML()</code> from it. <br><br><pre> <code class="hljs objectivec">doNotSkipEncoded: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,</code> </pre> <br>  Argument <code>doT.encodeHTMLSource()</code> .  Works for functions <code>{{! }}</code>  <code>{{! }}</code> - issuing safe (without executable tags) HTML-code.  If they are in any environment template, the first time <code>_globals._encodeHTML</code> function is <code>_globals._encodeHTML</code> generate safe characters to save its repeated calls.  Made to solve such bugs: <a href="https://github.com/olado/doT/issues/106">github.com/olado/doT/issues/106</a> .  If true, all codes of the form <code>"&amp;....;"</code> are not encoded <code>"&amp;....;"</code>  , and the main result is non-encoding of the ampersend in <code>'&amp;'</code> in such expressions. <br><br><h2>  Conclusion </h2><br>  For compilation speed, obviously, you need such parameters that require less action: if possible, <code>selfcontained = false</code> , <code>strip: false</code> , <code>append: true</code> .  The remaining parts of doT are well optimized, the fastest solutions are selected on average.  The speed of the versions depends on the specific type of templates, so the speed statement can only be averaged over the range of tasks. <br><br>  <code>doNotSkipEncoded</code> affects the result in the <code>{{!...}}</code> commands: if <code>true</code> coded characters of the form <code>&amp;...;</code>  . <br><br>  In general, a clone compiles a template into a function somewhat slower due to the increased amount of code analysis that needs to be done to solve some bugs.  For example, the unescape () function has been extended.  If you remove the last two replace from it, the speed will increase by 3% (Chrome v.61 Canary), but there will be some bugs. <br><br>       ,   doT.js ‚Äî     ,    , . ES6        ‚Äî     .     ,     (    IE8).  IE11 .    test.index.html <code>performance.now()</code> . <br><br> ‚Ä¢  ,      DoT ‚Äî DoT12: <a href="https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/">https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/#Result</a> ‚Ä¢  ,      DoT ‚Äî DoT12: <a href="https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/">https://jsfiddle.net/spmbt/v3yvpbsu/26/embedded/#Result</a>      : <a href="https://jsfiddle.net/spmbt/v3yvpbsu/26/">https://jsfiddle.net/spmbt/v3yvpbsu/26/</a> <br><br> ‚Ä¢ <a href="https://github.com/spmbt/doT"> DoT12.js</a> ( ), <a href="https://github.com/olado/doT">DoT.js</a> . <br> ‚Ä¢ <a href="http://jsfiddle.net/6KU9Y/2/">JSFiddle     ( 2013 )  </a> (   Dot;           ,         ;       ‚Äî   ¬´Run¬ª). <br> ‚Ä¢ <a href="https://habrahabr.ru/post/201592/">   DoT.js 2013 </a>   . <br><br> * <a href="https://closure-compiler.appspot.com/">Closure Compiler</a> ‚Äî     Advanced mode,  Uglify; <br> * <a href="http://www.stasha.info/index.php%3Fid%3D170">Using doT.js</a> (  , 2012) <br> * <a href="https://stackoverflow.com/questions/21784346/dot-js-chained-if-else-if-in-dot-js">doT.js: chained if-else if in dot.js</a>    if-else; <br> * <a href="http://olado.github.io/doT/index.html">  ,  , ,     .</a> </div><p>Source: <a href="https://habr.com/ru/post/333662/">https://habr.com/ru/post/333662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333652/index.html">5D market. Projection systems</a></li>
<li><a href="../333654/index.html">Work-stealing scheduler in Go</a></li>
<li><a href="../333656/index.html">XBRL: just about the complex - Chapter 2. What is XBRL?</a></li>
<li><a href="../333658/index.html">Cost of data storage: ‚Äúzero-sum game‚Äù</a></li>
<li><a href="../333660/index.html">Use of vulcanization for polymer modules</a></li>
<li><a href="../333664/index.html">Taming Multimedia with ffmpeg</a></li>
<li><a href="../333668/index.html">[Habr - not a complaint book] How I was deceived by contacting the designer Ramin Nasibov (Berlin, Germany)</a></li>
<li><a href="../333670/index.html">Virtualization and modernization in O & G: the story of one project</a></li>
<li><a href="../333674/index.html">Tale of a project manager at a bank and how he solved problems with a remote contractor</a></li>
<li><a href="../333676/index.html">How EA made life difficult for us, or how we fixed a bug 12 years ago</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>