<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing vector on dlang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 In this post I want to consider some features of the language D, for example, creating the structure of an algebraic vector. The po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing vector on dlang</h1><div class="post__text post__text-html js-mediator-article">  Good day, Habr! <br><br>  In this post I want to consider some features of the language D, for example, creating the structure of an algebraic vector.  The post <b>does not</b> deal with linear algebra or other mathematics. <br><br>  It is worth recalling that, unlike C ++ in D, classes and structures have different logical purposes and are arranged differently.  Structures cannot be inherited, there is no other information in structures except fields (in classes there is a table of virtual functions, for example), structures are stored by value (classes are always links).  Structures are great for simple data types. <br><a name="habracut"></a><br>  So, imagine that we want to create a vector that we could easily use in calculations, transfer to opengl, while it was easy to use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with the simple: <br><br><pre><code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">struct</span></span> <span class="hljs-type"><span class="hljs-type">Vector</span></span>(size_t <span class="hljs-type"><span class="hljs-type">N</span></span>,<span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-type"><span class="hljs-type">T</span></span>[<span class="hljs-type"><span class="hljs-type">N</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; this( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vals</span></span></span><span class="hljs-class">... ) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vals</span></span></span><span class="hljs-class">; } }</span></span></code> </pre> <br>  Everything is clear: the size and type of the vector are determined by the parameters of template. <br>  Let's sort the constructor.  Three dots at the end of vals allow you to call a constructor without brackets for an array: <br><br><pre> <code class="hljs lisp">auto a = Vector!(<span class="hljs-number"><span class="hljs-number">3</span></span>,float)(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  It is not very convenient to prescribe the full type every time you create a variable, make an alias: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Vector3f = Vector!(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>); auto a = Vector3f(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  If this approach seems to you not flexible, D allows you to create aliases with template parameters: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">alias </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>= Vector!(<span class="hljs-number"><span class="hljs-number">3</span></span>,T); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = Vector3!<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = Vector3!<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  But if we pass 0 to templating, we get a static vector with zero length, I don‚Äôt think this is useful.  Add a restriction: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector</span></span></span></span>(size_t N,T) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { ... }</code> </pre><br>  Now when trying to instantiate a zero-length vector template: <br><br><pre> <code class="hljs objectivec">Vector!(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) a;</code> </pre><br>  Get the error: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>.d(<span class="hljs-number"><span class="hljs-number">10</span></span>): Error: template <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>.Vector!(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) does not <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> template declaration Vector(ulong N, T) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Add a little math: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">struct</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size_t N,T</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> N &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-function"><span class="hljs-function">auto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector!(N,T</span></span></span><span class="hljs-function">) b ) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> { Vector!(N,T) ret; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; <span class="hljs-number"><span class="hljs-number">0</span></span> .. N ) mixin( <span class="hljs-string"><span class="hljs-string">"ret.data[i] = data[i] "</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">" b.data[i];"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br>  Now we can use our vector like this: <br><br><pre> <code class="hljs swift"> auto a = <span class="hljs-type"><span class="hljs-type">Vector3!</span></span>float(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); auto b = <span class="hljs-type"><span class="hljs-type">Vector3!</span></span>float(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>); auto <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">Vector3!</span></span>float(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = a + b / <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> * a;</code> </pre><br>  In this case, D retains the priority of operations (first multiplication, then addition). <br>  But if we try to use vectors of different types, we will encounter the problem that these types of vectors are not compatible.  Let's bypass this problem: <br><br><pre> <code class="hljs cs">... <span class="hljs-function"><span class="hljs-function">auto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op,E</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector!(N,E</span></span></span><span class="hljs-function">) b ) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">( mixin( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"T.init"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ~ op ~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E.init"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) ) : T ) )</span></span> { ...} ...</code> </pre><br>  Without changing the function code, we added support for all possible data types, even our own, as long as the binary op operation returns a result.  In this case, the result should be able to be implicitly reduced to type T. It is worth noting that the vector int with the vector float cannot be added, since the result of adding int and float is float, and it is reduced to int only explicitly using the cast construct. <br><br>  Element-based operations with numbers are also implemented: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">auto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op,E</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E b </span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">( mixin( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"T.init"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ~ op ~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E.init"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) ) : T ) )</span></span> { ...}</code> </pre><br>  If you wish, you can limit the set of operations inside the signature constraint structure (‚Äúif‚Äù to the function body) by checking ‚Äúop‚Äù for the desired operations. <br><br>  If we want our vector to be accepted by functions that accept static arrays: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size_t N</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[N] arr </span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  We can use the interesting construction of the D language: creating a pseudonym for this. <br><br><pre> <code class="hljs kotlin">struct Vector(size_t N,T) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { T[N] <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; alias <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ... }</code> </pre><br>  Now everywhere where the compiler wants to get a static array, and a vector is transmitted, the data field will be transmitted.  A side effect is that writeln now also accepts data and does not write out the full type when printing.  Also, it is no longer necessary to override opIndex: <br><br><pre> <code class="hljs lisp"> auto a = Vector3!float(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)<span class="hljs-comment"><span class="hljs-comment">; a[2] = 10;</span></span></code> </pre><br>  Add a little variety.  At the moment, we can instantiate a vector even with strings <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = Vector2!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"hell"</span></span>, <span class="hljs-string"><span class="hljs-string">"habr"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = Vector2!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"o"</span></span>, <span class="hljs-string"><span class="hljs-string">"ahabr"</span></span>); writeln( a ~ b ); <span class="hljs-comment"><span class="hljs-comment">// ["hello", "habrahabr"]</span></span></code> </pre><br>  and some vector operations do not make sense, for example, finding a length or finding a unit vector.  This is not a problem for D. Add methods for finding the length and unit vector as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.algorithm; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.math; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N,T)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( is( typeof( T.init * T.init ) == T ) )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> @property { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce!((r,v)=&gt;r+=v*v)( data.dup ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( is( typeof( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sqrt</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T.init) ) ) )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( len2 ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> / len; } } } } }</code> </pre><br>  Now the len2 (square of length) method will be declared for almost all numeric data types, while len and e are only for float, double and real.  But if you really want, you can do it for everyone: <br><br><pre> <code class="hljs coffeescript">... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.traits; struct Vector(size_t N,T) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(E)( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Vector!(N,E) b ) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>( cast(T)(E.init) ) ) ) { foreach( i; <span class="hljs-number"><span class="hljs-number">0</span></span> .. N ) data[i] = cast(T)(b[i]); } ... static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isNumeric!T ) { auto len(E=CommonType!(T,float))() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqrt( cast(E)len2 ); } auto e(E=CommonType!(T,float))() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector!(N,E)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) / len!E; } } ... }</code> </pre><br>  Now the len and e methods accept the template parameter, which by default is calculated as the largest type of the two <br><br><pre> <code class="hljs pgsql">CommonType!(<span class="hljs-type"><span class="hljs-type">int</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>) a; // <span class="hljs-type"><span class="hljs-type">float</span></span> a; CommonType!(<span class="hljs-type"><span class="hljs-type">double</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>) b; // <span class="hljs-type"><span class="hljs-type">double</span></span> b;</code> </pre><br>  If desired, we can explicitly specify it, for example, if we need double precision of the length of the vector int. <br><br>  A little about the designer.  You can create a constructor with the ability to create a vector is more variable, for example: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = Vector3f(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = Vector2f(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = Vector!(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)( <span class="hljs-number"><span class="hljs-number">0</span></span>, a, <span class="hljs-number"><span class="hljs-number">4</span></span>, b, <span class="hljs-number"><span class="hljs-number">3</span></span> );</code> </pre><br>  It looks simple: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">struct</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size_t N,T</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">N &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(E...)( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> E vals ) { size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( v; vals ) i += fillData( data, i, v ); } ... }</code> </pre><br>  Such a constructor can take parameters of different types, in any quantity. <br><br>  Define the fillData function: <br><br><pre> <code class="hljs kotlin">size_t fillData(size_t N,T,E)( ref T[N] <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, size_t no, E <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isNumeric!E ) { <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[no] = cast(T)<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isStaticArray!E &amp;&amp; isNumeric!(typeof(E.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>])) ) { foreach( i, v; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[no+i] = v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>.length; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isVector!E ) { foreach( i, v; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[no+i] = cast(T)v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.length; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static assert(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"unkompatible type"</span></span>); }</code> </pre><br>  It performs only three basic types: a number, a static array, and a vector.  A more flexible option takes up much more space and there are few great moments.  Consider the isVector pattern.  It allows you to determine whether type E is a vector.  This is again done through checking the existence of the type, but for the function. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">template </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isVector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> isVector = <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>( impl(E.init) ) ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">impl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size_t N,T</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector!(N,T</span></span></span><span class="hljs-function">) x )</span></span>; }</code> </pre><br><br>  A vector will not be complete if we cannot access its fields like this: ax + by <br>  You can simply create several properties with similar names: <br><br><pre> <code class="hljs kotlin">... auto x() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-meta"><span class="hljs-meta">@property</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } ...</code> </pre><br>  but, it is not for us.  Let's try to implement a more flexible access method: <br><ul><li>  with the ability to create vectors with a different set of fields (xyz, rgb, uv) </li><li>  so that you can access the fields not only in the singular (a.xy = vec2 (1,2)) </li><li>  one type of vector should have multiple access options </li></ul><br>  We will use the magic opDispatch method for this.  Its essence is that if a class method (or structure in our case) is not found, then the line after the point is sent to this method as a template parameter: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opDispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x )</span></span></span><span class="hljs-function"> </span></span>{ writeln( str, <span class="hljs-string"><span class="hljs-string">": "</span></span>, x ); } } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A; a.hello( <span class="hljs-number"><span class="hljs-number">4</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// hello: 4</span></span></code> </pre><br><br>  Add a parameterization to the type of our vector by a string and restrict a bit the variants of this string. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SEP1=<span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SEP2=<span class="hljs-string"><span class="hljs-string">"|"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">struct</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size_t N,T,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">alias</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AS</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> N &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; ( AS.length == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || isCompatibleAccessStrings(N,AS,SEP1,SEP2</span></span></span><span class="hljs-function">) ) )</span></span> { ... }</code> </pre><br>  The function isCompatibleAccessStrings checks the validity of the field access string.  Define the rules: <br><ul><li>  field names must be valid identifiers of the D language; </li><li>  the number of names in each variant should correspond to the dimension of the vector N; </li><li>  names separated by a space (SEP1); </li><li>  options should be separated by a vertical bar (SEP2). </li></ul><br>  Although there is nothing special about this function, for completeness, it is worth quoting its text. <br><div class="spoiler">  <b class="spoiler_title">the text function isCompatibleAccessStrings and other helper</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">/// compatible <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> creating <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> dispatches pure <span class="hljs-type"><span class="hljs-type">bool</span></span> isCompatibleArrayAccessStrings( size_t N, string str, string sep1="", string sep2="|" ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( sep1 != sep2 ); } body { auto strs = str.split(sep2); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( s; strs ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !isCompatibleArrayAccessString(N,s,sep1) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; string[] fa; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( s; strs ) fa ~= s.split(sep1); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> v; fa ) v = strip(v); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i, a; fa ) <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( j, b; fa ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i != j &amp;&amp; a == b ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } /// compatible <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> creating <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> dispatches pure <span class="hljs-type"><span class="hljs-type">bool</span></span> isCompatibleArrayAccessString( size_t N, string str, string sep="" ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> N == getAccessFieldsCount(str,sep) &amp;&amp; isArrayAccessString(str,sep); } /// pure <span class="hljs-type"><span class="hljs-type">bool</span></span> isArrayAccessString( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string sep="", <span class="hljs-type"><span class="hljs-type">bool</span></span> allowDot=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.length == <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; auto splt = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.split(sep); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i, val; splt ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !isValueAccessString(val,allowDot) || canFind(splt[<span class="hljs-number"><span class="hljs-number">0.</span></span>.i],val) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } /// pure size_t getAccessFieldsCount( string str, string sep ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.split(sep).length; } /// pure ptrdiff_t getIndex( string <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>, string arg, string sep1="", string sep2="|" ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( sep1 != sep2 ); } body { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( str; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.split(sep2) ) <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i, v; str.split(sep1) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( arg == v ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } /// pure <span class="hljs-type"><span class="hljs-type">bool</span></span> oneOfAccess( string str, string arg, string sep="" ) { auto splt = str.split(sep); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canFind(splt,arg); } /// pure <span class="hljs-type"><span class="hljs-type">bool</span></span> oneOfAccessAll( string str, string arg, string sep="" ) { auto splt = arg.split(""); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>!(a=&gt;oneOfAccess(str,a,sep))(splt); } /// pure <span class="hljs-type"><span class="hljs-type">bool</span></span> oneOfAnyAccessAll( string str, string arg, string sep1="", string sep2="|" ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( sep1 != sep2 ); } body { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( s; str.split(sep2) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( oneOfAccessAll(s,arg,sep1) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } /// <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> symbol count <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> field pure <span class="hljs-type"><span class="hljs-type">bool</span></span> isOneSymbolPerFieldForAnyAccessString( string str, string sep1="", string sep2="|" ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( sep1 != sep2 ); } body { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( s; str.split(sep2) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isOneSymbolPerFieldAccessString(s,sep1) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } /// <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> symbol count <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> field pure <span class="hljs-type"><span class="hljs-type">bool</span></span> isOneSymbolPerFieldAccessString( string str, string sep="" ) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( s; str.split(sep) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } pure { <span class="hljs-type"><span class="hljs-type">bool</span></span> isValueAccessString( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>, <span class="hljs-type"><span class="hljs-type">bool</span></span> allowDot=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startsWithAllowedChars(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) &amp;&amp; (allowDot?(<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>!(a=&gt;isValueAccessString(a))(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.split("."))):allowedCharsOnly(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>)); } <span class="hljs-type"><span class="hljs-type">bool</span></span> startsWithAllowedChars( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ) { switch(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: .. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>: goto <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: .. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'Z'</span></span>: goto <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'_'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-type"><span class="hljs-type">bool</span></span> allowedCharsOnly( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( c; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !allowedChar(c) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> allowedChar( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">char</span></span> c ) { switch(c) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: .. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>: goto <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: .. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'Z'</span></span>: goto <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span>: .. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'9'</span></span>: goto <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'_'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }</code> </pre><br></div></div><br>  Now we will declare the methods: <br><br><pre> <code class="hljs perl">struct Vector( size_t N, T, alias string AS=<span class="hljs-string"><span class="hljs-string">""</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( isCompatibleArrayAccessStrings(N,AS,SEP1,SEP2) || AS.length == <span class="hljs-number"><span class="hljs-number">0</span></span> ) ) { ... static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( AS.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) //      { @property { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      : ax = by; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T opDispatch(string v)() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( getIndex(AS,v,SEP1,SEP2) != -<span class="hljs-number"><span class="hljs-number">1</span></span> ) { mixin( <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"return data[%d];"</span></span>, getIndex(AS,v,SEP1,SEP2) ) ); } //   T opDispatch(string v)() const <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( getIndex(AS,v,SEP1,SEP2) != -<span class="hljs-number"><span class="hljs-number">1</span></span> ) { mixin( <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"return data[%d];"</span></span>, getIndex(AS,v,SEP1,SEP2) ) ); } //  ,    ,   e    static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isOneSymbolPerFieldForAnyAccessString(AS,SEP1,SEP2) ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> auto a = b.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> typeof(a) == Vector!(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-string"><span class="hljs-string">"x y"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> auto a = b.xx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> typeof(a) == Vector!(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>); auto opDispatch(string v)() const <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( v.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; oneOfAnyAccessAll(AS,v,SEP1,SEP2) ) { mixin( <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">`return Vector!(v.length,T,"%s")(%s);`</span></span>, isCompatibleArrayAccessString(v.length,v)?v.<span class="hljs-keyword"><span class="hljs-keyword">split</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>).join(SEP1):<span class="hljs-string"><span class="hljs-string">""</span></span>, array( <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>!(<span class="hljs-string"><span class="hljs-string">a=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">`data[%d]`</span></span>,getIndex(AS,a,SEP1,SEP2)))(v.<span class="hljs-keyword"><span class="hljs-keyword">split</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)) ).join(<span class="hljs-string"><span class="hljs-string">","</span></span>) )); } // a.xy = b.zw; auto opDispatch( string v, U )( in U b ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( v.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; oneOfAnyAccessAll(AS,v,SEP1,SEP2) &amp;&amp; isCompatibleArrayAccessString(v.length,v) &amp;&amp; ( isCompatibleVector!(v.length,T,U) || ( isDynamicVector!U &amp;&amp; is(typeof(T(U.datatype.init))) ) ) ) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; <span class="hljs-number"><span class="hljs-number">0</span></span> .. v.length ) data[getIndex(AS,<span class="hljs-string"><span class="hljs-string">""</span></span>~v[i],SEP1,SEP2)] = T( b[i] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> opDispatch!v; } } } }</code> </pre><br><br>  The text of the full vector can be found on <a href="">github</a> or in the descore package on <a href="http://code.dlang.org/packages/descore">dub</a> (at the moment there is not the latest version, with no access to the fields, but everything will change soon). </div><p>Source: <a href="https://habr.com/ru/post/246763/">https://habr.com/ru/post/246763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246751/index.html">IBM Cloud helps improve diabetic care</a></li>
<li><a href="../246753/index.html">LinkMeUp. Issue number 22. STC Metrotek. Software development for FPGA chips. Ethernet measuring equipment</a></li>
<li><a href="../246755/index.html">Changing user roles 1C 8 (file version)</a></li>
<li><a href="../246757/index.html">How to scratch any application on the iPhone, and how to prevent it</a></li>
<li><a href="../246759/index.html">Scapegoat trees</a></li>
<li><a href="../246765/index.html">How we built the ‚ÄúFault Tree‚Äù</a></li>
<li><a href="../246773/index.html">Interview with the Mainframe Quality Engineers team</a></li>
<li><a href="../246777/index.html">First steps to an online office on Linux or how we ported to Mono (about the difficulties and how to overcome them)</a></li>
<li><a href="../246779/index.html">Cut by the most dynamically growing agencies / studios</a></li>
<li><a href="../246781/index.html">ROS Speech Recognition with Pocketsphinx and Kinect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>