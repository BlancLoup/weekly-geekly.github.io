<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effective segmentation of images on graphs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Image segmentation and object detection ( edge detection ) play an important role in Computer Vision systems and are used for scene recognition and ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effective segmentation of images on graphs</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img title="Segmentation example" src="https://habrastorage.org/getpro/habr/post_images/92c/193/6e6/92c1936e6ddd96f4b2718f8beb509a5f.jpg"></div><br>  <strong>Image segmentation</strong> and object <em>detection</em> ( <em>edge detection</em> ) play an important role in <em>Computer Vision</em> systems and are used for scene recognition and object selection (detection) tasks.  By and large, this is the same tool as, for example, sorting, designed to solve higher-level problems.  And therefore, an understanding of the device of this class of algorithms will not be superfluous when building such systems, taking into account the requirements (in terms of quality / performance) and the specifics of the tasks. <br><br>  This article briefly describes the <strong>‚ÄúEfficient Graph-Based Image Segmentation‚Äù</strong> algorithm by <em>Pedro F. Felzenszwalb</em> ( <em>MIT</em> ) and <em>Daniel P. Huttenlocher</em> ( <em>Cornell University</em> ), <a title="Efficient Graph-Based Image Segmentation" href="http://people.cs.uchicago.edu/~pff/segment/">published</a> in 2004.  Yes, the algorithm is relatively old, but despite this, it still remains very popular, showing good results in terms of performance. <br><br>  Under the cut - a <strong>large</strong> mixture of pictures and text, not demanding to the current level of knowledge of the subject.  <em>Curiosity is welcome</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  First, the algorithm on the graphs, at first glance, having little in common with image processing, will be described.  However, a little later it will be given its interpretation in relation to image segmentation. <br><br><br><h3>  Kruskal Algorithm </h3><br>  <strong>The Kraskal algorithm</strong> ( <a title="Kruskal Algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B0">wiki</a> ) builds a framework - the minimum spanning tree of a given graph.  Further the English abbreviation <strong>MST</strong> (minimum spanning tree) will be used. <br><br>  <strong>Task:</strong> there are several settlements on the map (there are several contacts on the board), it is necessary to connect all of them with each other in such a way that the total length of roads (wires) is minimal. <br><br><div style="text-align:center;"><img title="Task" src="https://habrastorage.org/getpro/habr/post_images/c76/f1f/036/c76f1f03639f20b010524358ed8e8ee2.png"></div><br>  * <em>Yes, a task in such a formulation is usually called the ‚ÄúSteiner task‚Äù ( <a title="Search for the shortest networks" href="http://www.ega-math.narod.ru/Nquant/Network.htm">article</a> ), having solved which, cities can be connected even cheaper.</em>  <em>But we, ultimately, do not lay the asphalt ... =)</em> <br><br>  For the solution will need: <ul><li>  <strong>Counts</strong> : Briefly about what it is and how they are represented in the code has already been described in Habr√© ( <a title="Algorithms on Graphs - Part 0: Basic Concepts" href="http://habrahabr.ru/blogs/algorithm/65367/">article</a> ) </li><li>  <strong>Kraskal's algorithm</strong> ( <a title="Kruskal Algorithm" href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B0">wiki</a> ): the main ‚Äúengine‚Äù for solving the problem in such a formulation.  He is very well described in Cormen‚Äôs, Leiserson‚Äôs bible ‚ÄúAlgorithms: Construction and Analysis‚Äù ( <a title="Book on ozon.ru" href="http://www.ozon.ru/context/detail/id/83808/">book</a> ) </li><li>  <strong>Disjoint-set data structure</strong> ( <a title="Disjoint-set data structure" href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a> ): an additional structure necessary for the efficient implementation of the above algorithm.  How it is arranged, described in the same bible, but only slightly under a different name ( <em>if memory serves: Union Find-Set, something like that</em> ) </li></ul><br><div style="text-align:center;"><img title="Graph example" src="https://habrastorage.org/getpro/habr/post_images/79d/dfb/890/79ddfb890f5f1dd0da651b573223746d.png"></div><br><br>  In the current formulation of the problem, the vertices of the graph <font color="black">(v <sub>i</sub> )</font> are cities, and the edges <font color="black">e (v <sub>i</sub> , v <sub>j</sub> )</font> are roads between cities.  We know the distances between pairs of cities <font color="black">(v <sub>i</sub> , v <sub>j</sub> )</font> - this is the weight of the edges <font color="black">w (e (vi, vj))</font> .  Need to find MST, i.e.  is a tree in the graph (without cycles: why build extra roads) so that the sum of the edges is minimal and at the same time all the vertices are reachable. <br><br>  Initially, each vertex (city) itself is the only proud representative of the corresponding set <font color="black">G <sub>1</sub> , G <sub>2</sub> , ... G <sub>N</sub></font> (by the number of vertices).  Let him think so far that it was she who formed the MST.  In the course of the algorithm, we effectively and diplomatically combine all these separate sets into a single <font color="black">G</font> so that the participating vertices form the MST.  For this: <br><ul><li>  <em>Sort</em> all the edges in the graph in ascending order of length (road) </li><li>  Running along the edges in ascending order of lengths, we look at the ends of the edge <font color="black">e = (a, b)</font> : <ul><li>  <em>If the vertices ( <font color="black">a</font> and <font color="black">b</font> ) belong to the same set</em> : So, they already participate in some educated subset of the micro-MST, within their subgraph the sum of the edges is already minimal.  This edge is skipped - we don‚Äôt need it.  otherwise it forms a cycle in the tree, and we will use up asphalt for nothing </li><li>  <em>If the vertices ( <font color="black">a</font> and <font color="black">b</font> ) belong to different subsets of the</em> micro-MST:  we have found an edge (road) of minimal length, combining (merging) both subsets into one.  All the edges of smaller length have already been considered and cheaper than this edge, it will not be possible to combine.  Such an edge is entered in the list of edges used in constructing the MST tree, and the sets are combined into one </li><li>  <em>Continue the</em> merge <em>cycle</em> to obtain a single set equal to the desired MST, which will contain all the vertices of the graph </li></ul></li><li>  <em>We get one single set of</em> vertices (MST) and a list of edges used to join it, which is a tree of minimum total length, which unites all vertices. </li></ul><br><br><div style="text-align:center;"><img title="Kruskal algorithm" src="https://habrastorage.org/getpro/habr/post_images/bfc/37f/655/bfc37f655c40a47a32a9133e5d227f50.png"></div><br><br><h3>  Disjoint-set data structure </h3><br>  To implement the concept of ‚Äúset‚Äù in the Kraskal algorithm, the <strong>Disjoint-set data structure is used</strong> .  Work with it is optimized to perform two basic operations: <ul><li>  Find out for some vertex which set it belongs to at the moment </li><li>  Quickly merge these sets into one </li></ul>  To get closer to the topic of image segmentation, the description will continue in terms of image pixels and their colors.  Suppose we segment a parrot against the backdrop of some Japanese blue sea.  At first, each pixel (vertex of the graph) will be by itself - in its own segment (set), but during the algorithm, the pixels (vertices) of the "similar" color (one object) are gradually merged into one segment. <br><br>  For example, at a certain step of the algorithm, there is an edge connecting two neighboring pixels: at one end of the edge, the pixel is ‚Äúorange‚Äù, and at the other ‚Äúred‚Äù.  The edge length is defined as the ‚Äúcolor difference‚Äù between pixels.  All the edges of smaller length (with a similar color) are already merged: the orange and red parrot segment is probably already selected.  Following the algorithm, we need to find out if the current ‚Äúorange‚Äù and ‚Äúred‚Äù pixel are in one segment?  If in different, and we believe that the segments are similar in color, then we combine them into one and continue to build ... In general, the same algorithm of Krasalka, only with pixels. <br><br>  The structure used for these operations is very similar to the tree (although it is implemented by an array of indices).  It contains an ancestor for each pixel, i.e.  pointer (index) to some pixel of similar color located in the same segment.  Basic operations: <br><ul><li>  <em>Search for a segment of a</em> certain pixel <font color="black">'x'</font> : go through the ancestors to the very top.  The topmost pixel is the root of the tree, the ‚Äúrepresentative‚Äù of this segment at the current moment. </li><li>  <em>Merge segments</em> .  If the pixels have different ‚Äúrepresentatives‚Äù, then they belong to different segments, otherwise the root would be the same.  To combine the ‚Äúrepresentative‚Äù of a segment of lesser height (from the farthest pixel to the root), we refer (specify from it) to a longer ‚Äúrepresentative‚Äù in order not to increase the height of the tree.  Now we have a combined segment with a common representative. </li><li>  In order not to run the next time far from the pixel to the root, after the ‚Äúrepresentative‚Äù is successfully detected, we establish a direct link from the pixel ‚Äî right to it.  This shortens the path of the following searches, and is called " <em>path compression</em> ". </li></ul><br><div style="text-align:center;"><img title="Disjoint-set data structure" src="https://habrastorage.org/getpro/habr/post_images/23d/a92/ca3/23da92ca3cdf0876bb53ede6063a9bc2.png"></div><br><br>  Great, now we can effectively search for segments by pixels and merge them, as well as build MST using the Kraskal algorithm.  It is time to learn how the decision is made to merge or split the two areas. <br><br><br><br><h3>  Divide and rule </h3><br><img title="Gray segments" align="left" src="https://habrastorage.org/getpro/habr/post_images/e8a/a23/5a4/e8aa235a4adeca53439e1bac5390f40f.png">  The segmentation algorithm must clearly define where one segment ends and another begins.  As a rule, the borders are characteristic drops of brightness and / or hues of color found on the object-background, plane-shadow, parrot-sea, sign on the fence ... And if the "drop" is greater than a certain "threshold", then This should follow that these are different segments.  But there is a small problem: drops can vary greatly for different objects, and it is difficult to ‚Äúseparate‚Äù the segments with a uniquely defined (const) threshold value (threshold).  For the surface of the table on the background of the wall: the differences of neighboring pixels along the surface of the table (wall) will be relatively small, but on the table-wall border there will be a jump, which will separate the segments.  It is clear.  And if we have a parrot on the background of the sea?  He himself is very "motley", inside him there are large differences in intensity (green-red-yellow -...), in order to "separate" him from the sea, we need another "threshold" (threshold).  And we gradually come to the conclusion that the threshold, which decides that the neighboring segments "cannot be together," should be based not only on local indicators: the intensity difference along one edge (connecting neighboring pixels), but also on how much these segments on their own smooth (in terms of color) or "variegated". <br><br><br><br><h3>  Gray pictures </h3><br>  Before proceeding to the processing of full-color images, consider a simplified version, when the image is represented by grayscale, i.e.  Each cell of the image matrix stores a number in the interval <font color="black">[0 ... 1]</font> , which represents the pixel brightness. <br><br><div style="text-align:center;"><img title="Gray room" src="https://habrastorage.org/getpro/habr/post_images/947/3b0/49d/9473b049da31062aa79ca5ca3163fa21.png"></div><br><br><br><br><h2>  Efficient Graph-Based Image Segmentation </h2><br>  Each pixel of the image is represented by a vertex in the graph.  And the weight (length) of the edge connecting adjacent vertices is expressed by the formula: <font color="black"><em>w (v <sub>i</sub> , v <sub>j</sub> ) = | I (p <sub>i</sub> ) -I (p <sub>j</sub> ) |</em></font>  where <font color="black"><em>I (p <sub>i</sub> )</em></font> is the intensity (brightness) of the pixel <font color="black"><em>p <sub>i</sub></em></font> <br><br>  During the execution of the Kraskal algorithm, at the intermediate stage we will have several separate segments (subsets of pixels) with the minimum total weight of the edges inside: the segments will be joined by edges of the minimum length, i.e.  with minimal "intensity differences" between adjacent pixels.  Therefore, adjacent pixels inside one segment will be similar in color.  But only up to a certain value of the maximum edge (differential intensity) ... <br><br>  And so ... we took the minimum edge in the current step.  For two pixels, which are adjacent vertices of this edge, can we determine from one (already constructed) segment? <ul><li>  <em>Yes</em> , from one segment: just continue the execution of the algorithm. </li><li>  <em>No</em>  It is necessary to determine whether the segments represent parts of the same object in the image and should they be combined, or do their intensities ‚Äúsubstantially‚Äù differ? </li></ul>  To determine the differences between the segments, with each already constructed segment we associate a certain quantity ‚Äî the maximum intensity difference inside it, i.e.  longest edge in MST inside a segment: <br><div style="text-align:center;"><img title="Segment internal" src="https://habrastorage.org/getpro/habr/post_images/6c3/5a9/2fd/6c35a92fd5bb3900af76e0c2c5860683.png"></div><br>  Separately, it‚Äôs not necessary to look for it - it‚Äôs enough just to keep the edge length added when combining the components of the ‚Äúsub-segments‚Äù.  Indeed, at the time of combining, the length of the added edge was greater than in the already constructed MST of each ‚Äúsub-segment‚Äù, since  edges are processed in ascending order. <br><br>  We obtain an approximate decision rule for segments <font color="black"><em>C <sub>1</sub> , C <sub>2</sub></em></font> : <br><div style="text-align:center;"><img title="Segmentation decision" src="https://habrastorage.org/getpro/habr/post_images/fdf/7a5/a0f/fdf7a5a0f558d400ba3612959c2d3803.png"></div><table><tbody><tr><td><img title="Decision" src="https://habrastorage.org/getpro/habr/post_images/e79/dbe/899/e79dbe899b621412cc7072c7579dc78e.png"></td><td>  Sign: whether these segments should be delimited </td></tr><tr><td><img title="Defference" src="https://habrastorage.org/getpro/habr/post_images/43e/e81/2d1/43ee812d1300ed5501c8cc8f0f18b357.png"></td><td>  The current edge of the minimum length connecting two separate segments </td></tr><tr><td><img title="Minimax" src="https://habrastorage.org/getpro/habr/post_images/317/a8c/025/317a8c025361fc4226e0822b6bd87062.png"></td><td>  Smaller (of the larger) intensity differences within one of the considered segments </td></tr></tbody></table><br>  <strong>It turns out that</strong> , in order for the segments to ‚Äúmerge,‚Äù the intensity difference at their border must be less than the maximum differential within each of the segments being merged: <br><br><div style="text-align:center;"><img title="Divide by intensity" src="https://habrastorage.org/getpro/habr/post_images/8a1/46b/c6c/8a146bc6cdc838837e9225520db75d02.png"></div><br><br><br><br><h3>  I am looking for you </h3><br>  How to build a graph in the image?  Which pixels are adjacent?  On the surface are two main approaches: <br><ul><li>  <em>4-connected</em> : we connect each pixel with the adjacent top / bottom / left / right.  Such a construction is attractive because the number of edges in the graph is minimal. </li><li>  <em>8-connected</em> : in addition to the previous version, we connect each pixel with the neighboring ones located diagonally.  Thus, there are more edges in the graph, the algorithm runs slightly slower.  But the resulting segmentation should be of higher quality - after all, more connections between the pixels are taken into account. </li></ul><br><div style="text-align:center;"><img title="Graph connections" src="https://habrastorage.org/getpro/habr/post_images/a50/ec9/5f5/a50ec95f5a7294d3d0d6bb0d9bd7bd8c.png"></div><br>  The algorithm should give better results on the 8-connected constructed graph, however 4-connected gives very acceptable results and at the same time it runs much faster.  And as a ‚Äúdistance‚Äù for processing color images we can take just such a simple color difference of pixels, as realized by the authors of the algorithm: <br><div style="text-align:center;"><img title="Simple distance" src="https://habrastorage.org/getpro/habr/post_images/4e5/c2f/b7c/4e5c2fb7c5adadc434f491a6f37d4c78.png"></div><br>  However, this distance formulation has a flaw.  If we consider the ‚Äúintensity drop‚Äù between locally adjacent pixels, then the sky in the next picture will be divided into 2 separate segments with a wire passing across, or we will get even worse result if we process the lawn against the background of the grid: <br><br><div style="text-align:center;"><img title="Wire" src="https://habrastorage.org/getpro/habr/post_images/74a/cb9/df1/74acb9df1b4c77a83521721d28b606a3.png"></div><br>  Each piece of the lawn will be marked as a separate segment, but this is one object! <br><br>  Therefore, in the alternative, the authors propose to consider not only the nearby pixels, but pushing away from the local properties of the image (pixels located in close proximity), try to ‚Äújump over the wire‚Äù (see the picture) and reach for the continuation of a segment located at some distance.  To do this, they suggest choosing the Euclidean distance as the edge length, depending on both the position of the pixels <font color="black">(x, y)</font> and their color <font color="black">(r, g, b)</font> : <br><div style="text-align:center;"><img title="Advanced distance" src="https://habrastorage.org/getpro/habr/post_images/f4a/c23/e91/f4ac23e91b6fd7bbfa7a208034a75f55.png"></div><br>  Now the pixels will be considered ‚Äúneighbors‚Äù if they are located close to each other, or have a similar shade, although they may physically be at some distance.  For the construction of the graph, the authors propose to connect each pixel with 10 (20, 30) "closest" ones.  This gives better segmentation, but requires more computational resources. <br><br><br><h3>  Stick together, team! </h3><br>  Returning to the very beginning.  A long time ago, when all the pixels were scattered ‚Äî there could be a significant difference in intensity between the neighboring ones, which did not allow them to merge.  It is unlikely that they provided us with a microscopic photograph, where each pixel should be isolated - most likely, they are part of some larger object (parrot).  So that they succumb to the "merge" (merge) to a greater extent than the already built large segments, for which the correctness of the splitting is more important, add a value in the final rule depending on the size of the constructed segment: <img title="Segment size correction" src="https://habrastorage.org/getpro/habr/post_images/0ad/8e7/bb3/0ad8e7bb3066c35d99cb0216d8015273.png">  where <font color="black"><em>| C |</em></font>  - power of the considered segment (the number of pixels in it at the current moment), and <font color="black"><em>k</em></font> is already a segmentation parameter set manually.  With a similar amendment in the final rule, the formula will be used: <br><br><div style="text-align:center;"><img title="Distance between segments" src="https://habrastorage.org/getpro/habr/post_images/bba/0ae/4f6/bba0ae4f63dd2fd4a0d2e392965bdd62.png"></div><br>  The ‚Äúamendment‚Äù is gradually leveled with the growth of the segment (increase <font color="black"><em>| C |</em></font> ) ... <br><br>  In fact, instead of this task <font color="black"><em>T,</em></font> you can choose another function that takes into account the specificity of the processed images: the shape of the segments, the position in the photo, certain color shades ... <br><br><br><h3>  Gaussian blur </h3><br>  Returning to the very "colorful" pictures: <br><br><div style="text-align:center;"><img title="Distance between segments" src="https://habrastorage.org/getpro/habr/post_images/387/79b/644/38779b644cc267e2c4891d2e2f1eb7b4.png"></div><br>  It is clear that when determining the distance between pixels in such a definition as ‚Äúintensity difference‚Äù, the pixels of a ‚Äúmotley‚Äù, even if a single object, will not be very flexible to merge into one object.  To make them more ‚Äúcompliant‚Äù to combine and remove noise / artifacts, a Gaussian blur filtering (http://habrahabr.ru/blogs/webdev/43895/) is usually applied to the image with a certain radius (standard deviation) of <font color="black"><em>sigma</em></font> .  This causes the "interpenetration" of the color components of the pixels, and they are more willing to contact. <br><br><br><h2>  Total </h2><br>  There are many methods for segmentation: various approaches are very well described in the <a title="Image segmentation methods: automatic segmentation" href="http://cgm.computergraphics.ru/content/view/147">article</a> ‚ÄúImage segmentation methods: automatic segmentation‚Äù.  And by and large, the segmentation must be either qualitative or productive, and if you are lucky, all at once.  The method described above is exactly the productive version. <br><br>  In this way of segmentation, the most laborious process is the sorting of all edges performed in <font color="black">O (e <em>log</em> ‚Å°e)</font> , where <font color="black">e</font> is the number of edges in the graph.  Thus, for an image of NxM pixel edges will be: <font color="black">| e |</font>  <font color="black">= 4 * N * M</font> <br><br>  The source code of the algorithm is available at this <a href="http://people.cs.uchicago.edu/~pff/segment/">link</a> . <br><br><br><h3>  But what about OpenCV? </h3><br>  In all of your favorite OpenCV library ( <a title="Opencv" href="http://ru.wikipedia.org/wiki/OpenCV">wiki</a> ) there is a method " <a href="http://www.seas.upenn.edu/~bensapp/opencvdocs/ref/opencvref_cv.htm">cvPyrSegmentation</a> ", i.e.  pyramidal image segmentation method.  It is arranged a little differently.  His description would take another article, so - the picture.  Segments are built in layers (level), combining pixels of similar color into one (located in a layer above), and then sequentially processing the layers located at the next level (level) above ‚Äúagainst the stop‚Äù: <br><br><div style="text-align:center;"><img title="Pyramidal segmentation" src="https://habrastorage.org/getpro/habr/post_images/8fb/0ca/e61/8fb0cae61d4ef56bdbd85e4d2fe84195.png"></div><br>  In 2006, a comparison of several pyramidal algorithms was carried out in the Univesity of Malaga (Spain) and the results are presented in the following <a title="Pyramid Segmentation Algorithms Revisited" href="http://nichol.as/papers/Marfil/Pyramid%2520segmentation%2520algorithms%2520revisited.pdf">article</a> : <br><br><div style="text-align:center;"><img title="Pyramid Segmentation Algorithms Revisited" src="https://habrastorage.org/getpro/habr/post_images/4e3/7d0/3e4/4e37d03e4151f469085a5c22845a2b90.png"></div><br>  The authors came to the conclusion that of the 8 methods that deserve attention are 3, thanks to which sufficiently high-quality results of image splitting into objects are obtained.  However, it is worth noting that the execution time of the pyramidal algorithms varies from <em>0.5 sec.</em>  up to <em>4.5 seconds</em>  (256x256 pixels on a Pentium 766 MHz), while the considered " <em>Efficient Graph-Based Image Segmentation</em> " is performed according to the words of the authors "in fraction of a second".  We have <strong>1024x768</strong> photos worked for <strong>0.5 seconds</strong> (U9400 2 x 1.4GHz) inside the "matryoshka": VMWare - Matlab - mex (C ++).  In general, pyramidal - the quality described in the article columns - speed.  Both have the right to life.  =) <br><br><br>  To the most assiduous readers, let us reveal the secret of the ‚Äúmagic bubbles‚Äù: what kind of numbers are depicted in the pictures?  These are just the parameters of the " <em>segmentation (sigma, k, min)</em> " method, with 2 of which you are already familiar with, and the 3rd " <em>min</em> " is the enforced minimum segment size so that there are no "small" ones. <br><br><div style="text-align:center;"><img title="Sport" src="https://habrastorage.org/getpro/habr/post_images/d3a/de5/a5b/d3ade5a5b50167ddd8392021c3e3d210.png"></div><br>  <strong>Good luck!</strong> <br><br>  <em>PS</em> Please do not kick much, this is my ninth post on Habr√©. </div><p>Source: <a href="https://habr.com/ru/post/81279/">https://habr.com/ru/post/81279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../81265/index.html">VoIP and IM in Nokia N900</a></li>
<li><a href="../81266/index.html">Employee motivation, free reasoning</a></li>
<li><a href="../81273/index.html">Valentine Gift Finder: Valentine's Gift Search Engine</a></li>
<li><a href="../81274/index.html">Takara Launches Nostalgic Gamers Gadget</a></li>
<li><a href="../81275/index.html">Motorola MOTOROI - the flagship Android-background company</a></li>
<li><a href="../81281/index.html">Testing Opera and Firefox browsers + Firefox Builder Optimization utility</a></li>
<li><a href="../81282/index.html">Design: Euro 2012 + micro contest</a></li>
<li><a href="../81283/index.html">Purchase Plus account on vimeo.com</a></li>
<li><a href="../81284/index.html">What awaits individual entrepreneurs without employees in 2010?</a></li>
<li><a href="../81287/index.html">The easiest and most convenient way to download videos from YouTube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>