<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to animate the picture in the browser. Multi-pass WebGL rendering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anyone who came across three-dimensional graphics sooner or later opened documentation on drawing methods that involve several passes of the renderer....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to animate the picture in the browser. Multi-pass WebGL rendering</h1><div class="post__text post__text-html js-mediator-article"><p>  Anyone who came across three-dimensional graphics sooner or later opened documentation on drawing methods that involve several passes of the renderer.  Such methods allow you to add a picture with beautiful effects, such as the glow of bright spots (Glow), Ambient occlusion, depth of field effect. </p><br><p>  Both the adult OpenGL and my favorite WebGL offer rich functionality for drawing results into intermediate textures.  However, managing this functionality is a rather complicated process, in which it is very easy to get an error at any stage, from creating the necessary resolution textures to naming uniforms and passing them to the appropriate shader. </p><br><p>  To figure out how to properly prepare WebGL, we turned to the specialists of <a href="https://habrahabr.ru/company/aligntechnology/blog/">Align Technology</a> .  They decided to create a special manager to manage all of this zoo from different textures, which would be convenient to use.  What came out of it will be under the cut.  It is important that an unprepared reader, who has never before encountered the need to organize multi-pass rendering, may seem incomprehensible to the article.  The task is quite specific, but also incredibly interesting. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uv/wc/by/uvwcby6fijhhyolj4noad1zi7j4.png"></div><a name="habracut"></a><br><p>  So that you understand the seriousness of the briefing, I will briefly tell you about the company.  Align has a product that allows people to correct smiles without traditional braces.  That is, their immediate consumers are doctors.  This is a fairly limited audience with specific requests that impose fantastic demands on the reliability, performance and quality of the user interface.  At one time, C ++ was chosen as the main tool, but it had a serious limitation: only the desktop application, only for Windows.  About two years ago, the transition to the web version began.  The capabilities of modern browsers and technology stack made it possible to quickly and conveniently re-create the user interface and adapt the code base, which had been written for almost 15 years.  Of course, this led to the need to solve a bunch of tasks on the front and back end, including the need to optimize data volumes and download speeds.  This and the following articles will be devoted to these tasks. </p><br><p>  And in order not to get up twice, I will try not to clutter the post with source code.  That is, everything that goes into the details of the implementation and depresses the readers of the code will, if possible, be skipped or reduced to a pure, uncluttered idea.  The story will be conducted in the first person, as Vasily Stavenko told - one of the specialists of Align Technology, who agreed to lift the curtain of the inner kitchen of the WebGL-front. </p><br><h1 id="opisanie-problemy">  Description of the problem </h1><br><p>  To begin with, it would be worthwhile to tell what, in fact, we wanted to implement and what was required for this.  Our specifics do not imply a large number of visual effects.  We decided to implement Screen Space Ambient Occlusion (or SSAO) and a simple shadow. </p><br><p>  SSAO is, roughly speaking, the calculation of total shading at a point surrounded by other points.  Here is the essence of this idea: </p><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> light = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> deltaLight; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> astep =<span class="hljs-number"><span class="hljs-number">0</span></span>; astep &lt; ANGULAR_STEPS; ++astep){ vec2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = getOffset(astep, ANGULAR_STEPS); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> rstep = <span class="hljs-number"><span class="hljs-number">0</span></span>; rstep &lt; RADIAL_STEPS; ++rstep ){ <span class="hljs-type"><span class="hljs-type">float</span></span> radius = getRadius(rstep, RADIAL_STEPS); vec4 otherPointPosition = textureLookup(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, radius); <span class="hljs-type"><span class="hljs-type">float</span></span> screenSpaceDistance = length(<span class="hljs-type"><span class="hljs-type">point</span></span>.xy - otherPointPosition.xy); screenSpaceDistance = max(screenSpaceDistance, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> deltaHeight = otherPointPosition.z - <span class="hljs-type"><span class="hljs-type">point</span></span>.z; <span class="hljs-type"><span class="hljs-type">float</span></span> lightness = (deltaHeight / screenSpaceDistance); // ! deltaLight = companyRelatedMagic(lightness); } light += companyRelatedMagic2(deltaLight); }</code> </pre> <br><p>  The <code>textureLookup</code> function selects a pixel from the connected texture, which is not a color, but a point position.  Next, we calculate its illumination as the ratio of its depth to its distance from the current, drawn fragment in the coordinates <code>gl_FragCoords</code> .  Then we do special magic with magic numbers to get the value in the right range. </p><br><p>  The resulting texture will look something like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/mr/em/vsmremdydo2gwyrbkelsv7jiu0a.png"></div><br><p>  This is the final result: </p><br><img src="https://habrastorage.org/webt/83/-g/pi/83-gpirz7ljaj9_c7yixw16ag0i.png"><br><p>  It is noticeable that the SSAO-texture has a lower resolution than the full image.  This is done on purpose.  Immediately after drawing the positions into fragments, we shrink the texture, and only after that we calculate the SSAO.  Lower resolution means faster rendering and processing.  This means that before we compose the final image, we need to increase the resolution of the intermediate image. </p><br><p>  Summarizing, we need to draw the following textures: </p><br><ol><li>  The texture of the original resolution positions in <code>GL_FLOAT</code> format </li><li>  Low resolution texture. </li><li>  Texture SSAO low resolution. </li><li>  Blurred texture SSAO low resolution. </li><li>  Blurred texture SSAO high resolution. </li><li>  Shadow mask texture. </li><li>  The image of the scene, drawn with the correct materials. </li></ol><br><h2 id="zavisimost-i-pereispolzovanie">  Dependency and Reuse </h2><br><p>  Most of the textures can be drawn only if there are already some drawn textures.  And some of them can be used several times.  That is, a mechanism that works with dependencies is needed. </p><br><h2 id="otladka">  Debugging </h2><br><p>  For debugging the rendering process, it can be useful to bring any of the textures into the existing context. </p><br><h2 id="upravlenie-teksturami-i-freymbuferami">  Texture and Framebuffer Management </h2><br><p>  Since we already use the <a href="https://threejs.org/">THREE.js</a> framework for our work, the following requirements already follow from interaction with it.  We decided not to slide into a clean WebGL and used <code>THREE.WebGLRenderTarget</code> , which unfortunately gives the overhead framebuffers, linking the texture and the created framebuffer object together, not allowing existing buffers to be used for other textures.  But even with this overhead projector, our rendering works at acceptable speeds, and managing such an object is much easier than managing two related, but at the same time independent objects. </p><br><h2 id="upravlenie-razresheniem-tekstur">  Texture Resolution Management </h2><br><p>  We would very much like to be able to ‚Äúplay‚Äù with the parameters of downsampling, with the magic of numbers and light limits, and not bother with the fact that we need to completely change the image output code ‚Äî change its resolutions, matrices and other things.  Therefore, it was decided to ‚Äúsew‚Äù the sampling mechanism into our manager. </p><br><h2 id="zamena-materiala-pered-renderingom-sceny">  Replacing the material before rendering the scene </h2><br><p>  The material of all objects in <code>THREE.Scene</code> must be replaced for drawing positions, taking into account the visibility of objects, and then restored without loss.  It should be noted here that one could use the <code>Scene.overrideMaterial</code> parameter.  But in our case, the logic turned out to be somewhat more complex. </p><br><h1 id="realizaciya---osnovnaya-ideya">  Implementation - the main idea </h1><br><p>  What have we done in the end? <br>  First, make a manager, the description of which you will find below.  And they wrote classes that automatically read shaders and see what textures they need to render themselves.  The manager must be able to understand that there are dependencies for drawing a texture, and must draw the necessary dependencies. </p><br><p>  This manager was supposed to be initialized with instances of the Pass class.  That is, we need another object that will add passages to it and will already be application-specific.  Due to the fact that in modern WebGL shaders we cannot set the name of the outgoing texture, we had to make ScreenSpacePass nameless and give it a name when adding.  And you could read it from the shader text. </p><br><p>  Here is such a method: </p><br><pre> <code class="javascript hljs">addPass(name, pass){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pass <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Pass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Adding wrong class to renderer passes"</span></span>); pass.setSceneAndCamera(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.screenSpaceScene, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passes.set(name, pass); }</code> </pre> <br><p>  Yes, on the same manager, we hung up and managing the state of screenSpaceScene.  Fortunately, this is one single mesh with geometry to close the entire screen. </p><br><p>  This is the method we needed to draw a specific passage to the screen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passes.has(name)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">`Multipass manager has no rendertarget named </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passes.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(target.dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._prepareDependencies(target.dependencies); <span class="hljs-comment"><span class="hljs-comment">// &lt;---     target.installDependencies(this.passes); } if(this.prerenderCallbacks[name]) //     . this.prerenderCallbacks[name].forEach(fn=&gt;fn(this)); let clear = options.clear || {color:true, depth:true, stencil:true}; clear = {...clear, ...target.clearOptions} target.setResolutionWithoutScaling(this.width, this.height); //   -  target.prerender(); this.setupClearing(clear); this.renderer.render(target.getScene(), target.getCamera()); this.restoreClearing(); target.postrender();</span></span></code> </pre> <br><p>  A few comments: </p><br><ol><li>  Each target is our Pass to draw. </li><li>  <code>this.passes</code> is an instance of javascript Map () (Type: <code>Map&lt;String, Pass&gt;</code> ). </li><li>  <code>target.dependencies</code> is a list of texture uniforms in the shader.  We read them from the shader source using regular expressions. </li><li>  <code>installDependencies</code> is nothing more than installing uniforms. </li><li>  <code>prepareDependencies</code> for each dependency runs the function <code>this.prerender</code> , which is the younger sister of the specified function.  The difference of methods is small, for example, the drawing goes to the target frame buffer: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.render(target.getScene(), target.getCamera(), target.framebuffer);</code> </pre> <br><p>  Thus, we have drawn a common class for our passes with this interface: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pass</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : constructor(framebufferOptions = {}) {} //   get clearOptions() get framebuffer() resize(w, h) //    setResolution(width, height) //     . setResolutionWithoutScaling(width, height) //       . touchUniformFunctions() prerender() postrender() installDependencies(dependenciesMap) getScene() getCamera() }</span></span></code> </pre> <br><h2 id="kak-eto-dolzhno-rabotat">  How it should work </h2><br><p>  First you need to set up our manager.  To do this, we instantiate it and add a certain number of Pass-s to it.  Then, when we need to draw some kind of Pass to our context, we just call </p><br><pre> <code class="javascript hljs">manager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">"passName"</span></span>);</code> </pre> <br><p>  This Pass should be drawn on the screen, and the manager should prepare all the dependencies before that.  Since we want to reuse textures, our manager will check for the presence of already rendered textures, and so that he does not decide that the textures from the previous frame are those textures that can be left off, we reset the old textures before drawing.  For this, the manager has a function with the appropriate name <code>start</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ manager.start(); manager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">'mainPass'</span></span>); }</code> </pre> <br><p>  The confusion in the slender scheme was made by the need to paint translucent textures on the main canvas.  When blending does not need to erase the previous results, and the blending itself must be configured.  In our case, the prepared textures are superimposed on the image at the final rendering by blending.  The procedure is as follows: </p><br><ol><li>  We erase the background with gl.Clear - three.js does it automatically, if he doesn‚Äôt say that it is not necessary to erase it. </li><li>  Shading with blending. </li><li>  We superimpose the image of our jaw using transparency. </li><li>  Impose SSAO. </li></ol><br><p>  Like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.start(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(showShadow) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">'displayShadow'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">clear</span></span>:{<span class="hljs-attr"><span class="hljs-attr">color</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">stencil</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">depth</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>} }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(showSSAO) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">'displaySSAO'</span></span>,{ <span class="hljs-attr"><span class="hljs-attr">clear</span></span>:{<span class="hljs-attr"><span class="hljs-attr">color</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">stencil</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">depth</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>} }); }</code> </pre><br><p>  It can be seen that the slight difference is that the color buffer is not erased, and all other buffers are cleared. </p><br><p>  If we want to display some kind of intermediate texture (for example, for debugging purposes), we can only slightly modify the render.  For example, the texture with SSAO, which I quoted above, was drawn with this code: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.start(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.renderOnCanvas(<span class="hljs-string"><span class="hljs-string">'ssao'</span></span>); }</code> </pre><br><h2 id="realizaciya-scenepass">  ScenePass implementation </h2><br><p>  Now let's take a closer look at exactly how to draw our passage of scenes into textures.  Obviously, we need something that can draw the scene, replacing the material, and something that will draw everything in screen coordinates. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScenePass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene, camera, options={}){ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prerender=options.prerender ||<span class="hljs-literal"><span class="hljs-literal">null</span></span>, postrender=options.postrender || <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(options.framebufferOptions); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = camera; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._prerender = prerender; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._postrender = postrender; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._clearOptions = options.clearOptions; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.overrideMaterial = options.overrideMaterial || <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } setSceneAndCamera(){ <span class="hljs-comment"><span class="hljs-comment">// Do not rewrite our scene } }</span></span></code> </pre><br><p>  This is the whole class.  It turned out pretty simple, because almost all the functionality was left in the parent.  As you can see, I decided to leave <code>overrideMaterial</code> on the possible case when we can replace the material on the whole scene at once in one assignment operation, and not during the sequential replacement of material on all suitable objects.  Actually, <code>_prerender</code> and <code>_postrender</code> are pretty smart substitutes for material for each individual mesh.  Here is what they look like in our case: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pass</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// Skip-skip prerender(){ if(this.overrideMaterial) this.scene.overrideMaterial = this.overrideMaterial; if(this._prerender) this.scene.traverse(this._prerender); } postrender(){ if(this.scene.overrideMaterial) this.scene.overrideMaterial = null; if(this._postrender) this.scene.traverse(this._postrender); } /// Skip-skip }</span></span></code> </pre> <br><p>  <code>Scene.traverse</code> is a THREE.js method that recursively passes through the entire scene. </p><br><h2 id="realizaciya-screenspacepass">  ScreenSpacePass implementation </h2><br><p>  ScreenSpacePass was conceived so as to pull out the maximum necessary information from the shader in order to work with it without an extra boilerplate.  The class turned out pretty complicated.  The main difficulty came in the logic that provides sampling - that is, the installation of the correct resolution in the texture.  We had to add an additional method to set the resolution of the current framebuffer in cases when we want to draw onto the screen, and not into the texture.  I had to make a compromise between technical complexity, the responsibility of classes, the number of entities and the time allotted for the task. </p><br><p>  Automatic search and installation of uniforms helped quickly find problems such as typos in textural uniforms.  In such cases, the GL can take some other texture, and what you get on the screen looks completely wrong, and you have no idea why. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenSpacePass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(fragmentShader, options = {}){ <span class="hljs-comment"><span class="hljs-comment">// scaleFactor = 1.0, uniforms={}){ let scaleFactor = options.scaleFactor || 1.0; let uniforms = options.uniforms || {}; let blendingOptions = options.blendingOptions || {}; super(options.framebufferOptions); /// Skip } resize(w, h){ const scaler = getScaler(this.scaleFactor, w, h); let v = new Vector2(w,h).multiply(scaler); this.framebuffer.setSize(Math.round(vx), Math.round(vy)); } setResolution(width, height){ const scaling = getScaler(this.scaleFactor, width, height); let v = new Vector2(width, height).multiply(scaling); this.uniforms.resolution.value = v; } setResolutionWithoutScaling(width, height){ this.uniforms.resolution.value = new Vector2(width, height); } isSampler(uname){ return this.samplerUniforms.indexOf(uname) != -1; } tryFindDefaultValueForUniformType(utype){ switch(utype){ case 'vec2': return new Vector2(0., 0.); default: return null; } } getValueForUniform(uniformDescr){ if(!this.uniformData.hasOwnProperty(uniformDescr.name )){ if(uniformDescr.name != 'resolution' &amp;&amp; !this.isSampler(uniformDescr.name)) console.warn(`Value for uniform '${uniformDescr.name}' is not found.`); return this.tryFindDefaultValueForUniformType(uniformDescr.type); } if(typeof(this.uniformData[uniformDescr.name]) == 'function'){ this.uniformData[uniformDescr.name] = this.uniformData[uniformDescr.name].bind(this); return this.uniformData[uniformDescr.name](); } else return this.uniformData[uniformDescr.name]; } touchUniformFunctions(){ for(const k in this.uniformData){ if(typeof this.uniformData[k] !== 'function') continue; this.uniforms[k].value = this.uniformData[k](); } } prerender(){ this.scene.overrideMaterial = this.shader; this.touchUniformFunctions(); } parseUniforms(glslShader){ let shaderLines = glslShader.split('\n'); const uniformRe = /uniform ([\w\d]+) ([\w\d]+);/; let foundUniforms = shaderLines.map(line=&gt;line.match(uniformRe)) .filter(x=&gt;x) .map(x=&gt;{return {type:x[1],name:x[2]}}); const umap = this.mapping; this.dependencies = foundUniforms.filter(x=&gt;x.type == 'sampler2D').map(x=&gt;umap[x.name]?umap[x.name]:x.name); this.samplerUniforms = foundUniforms.filter(x=&gt;x.type == 'sampler2D').map(x=&gt;x.name); this.uniforms = {}; foundUniforms.forEach(u=&gt;{ this.uniforms[u.name] = {value:this.getValueForUniform(u)}; }); if(!this.uniforms.hasOwnProperty('resolution')) throw new Error('ScreenSpace shader in WebGL must have resolution uniform'); } installDependencies(dependenciesMap){ this.samplerUniforms.forEach(uname=&gt;{ this.uniforms[uname].value = dependenciesMap.get(uname).framebuffer.texture; }) } parseShader(fragmentShader){ let glslShader = parseIncludes(fragmentShader); this.parseUniforms(glslShader); return new RawShaderMaterial({ vertexShader: ssVertex, fragmentShader:glslShader, uniforms: this.uniforms, transparent: this.blendingOptions.transparent || false }); } } function parseIncludes( string ) { // Stolen from three.js var pattern = /#include +&lt;([\w\d.]+)&gt;/g; function replace( match, include ) { var replace = ShaderChunk[ include ]; if ( replace === undefined ) { throw new Error( 'Can not resolve #include &lt;' + include + '&gt;' ); } return parseIncludes( replace ); } return string.replace( pattern, replace ); }</span></span></code> </pre> <br><p>  Here the source turned out to be quite large, and the class - quite clever.  However, it can be seen that most of the code just finds out if there are textural uniforms in the shader, and sets them as dependencies. </p><br><p>  Well, at the very end, I will show how we used it.  Application specific entity we called <code>EffectComposer</code> .  In its constructor we create the described manager and create passes for it: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PassManager(threeRenderer); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.addPass(<span class="hljs-string"><span class="hljs-string">'downscalePositionSSAO'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScreenSpacePass(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./shaders/passingFragmentShader.glsl'</span></span>), {scaleFactor}) ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.addPass(<span class="hljs-string"><span class="hljs-string">'downscalePositionShadow'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScreenSpacePass(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./shaders/positionDownSampler.glsl'</span></span>), {scaleFactor}) ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.addPass(<span class="hljs-string"><span class="hljs-string">'ssao'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScreenSpacePass(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./shaders/SSAO.glsl'</span></span>), {scaleFactor}) ); <span class="hljs-comment"><span class="hljs-comment">/// Skip-skip-skip</span></span></code> </pre> <br><p>  As an example, the contents of the file passingFragmentShader.glsl: </p><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D positions; <span class="hljs-comment"><span class="hljs-comment">//   -     positions uniform vec2 resolution; void main(){ vec2 vUv = gl_FragCoord.xy / resolution; gl_FragColor = texture2D(positions, vUv); }</span></span></code> </pre> <br><p>  The shader is very short - get a pixel that will be interpolated, and immediately give it away.  All work will be done by linear interpolation in the texture settings ( <code>GL_LINEAR</code> ). </p><br><p>  Now let's see how the <code>positions</code> will be drawn. </p><br><p>  We need the working scene elsewhere in the program, so the <code>EffectComposer</code> not its owner, it is asked when necessary. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateScenes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scenes, camera</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.addPass(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScenePass(scene, camera)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passManager.addPass(<span class="hljs-string"><span class="hljs-string">'positions'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScenePass(scene, camera, { <span class="hljs-attr"><span class="hljs-attr">prerender</span></span>: materialReplacer, <span class="hljs-attr"><span class="hljs-attr">postrender</span></span>:materialRestore, framebufferOptions })) }</code> </pre> <br><p>  As you can see, if someone tells us about a scene change, the <code>EffectComposer</code> will create two Pass-as: one with the default settings and the other with a tricky substitute material.  Scene passages do not contain any tricky dependencies, they, as a rule, are drawn by themselves, however, the described approach allows us to do this if we add several methods to ScenePass to add dependencies.  Because it is not obvious what kind of material from the scene will want to be drawn dependency. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Despite the ease of use in our case, we were not able to achieve fully automatic generation of passes based on shaders.  I did not want to add markers to the shaders that would complement the scene rendering passes with additional parameters, such as texture output parameters - <code>GL_RGB</code> , <code>GL_RGBA</code> , <code>GL_FLOAT</code> , <code>GL_UNSIGNED_BYTE</code> .  This would, on the one hand, simplify the code, but would give less freedom to reuse shaders.  That is, this setting still had to be described. </p><br><p>  It is worth mentioning that I still had to implement dependency mapping.  This turned out to be useful if we want to use a single shader in several passes and with different incoming textures.  In this case, each pass became more like a function, so I had an idea how to do it a bit more ‚Äúfunctional‚Äù. </p><br><p>  However, all development has proven to be very useful.  In particular, it allows us to add any effects to our project without significant difficulties.  Although I personally like the possibility of easy debugging of images. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/344930/">https://habr.com/ru/post/344930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344918/index.html">Give me your salary and I will tell you who you are</a></li>
<li><a href="../344920/index.html">The grand piano must disappear: the levels of professional development and their evaluation, the programmers</a></li>
<li><a href="../344922/index.html">How did I manage to hack the application</a></li>
<li><a href="../344924/index.html">Digital events in Moscow from December 18 to 24</a></li>
<li><a href="../344926/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ293 (December 11 - 17, 2017)</a></li>
<li><a href="../344932/index.html">Economy solution for the Internet of Things. Azure IoT Hub + Azure functions</a></li>
<li><a href="../344934/index.html">Jeb Klitschko</a></li>
<li><a href="../344936/index.html">The concept of communication in projection modeling</a></li>
<li><a href="../344938/index.html">Multi-pattern matching on GPU myth or reality</a></li>
<li><a href="../344942/index.html">How to ask questions in IRC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>