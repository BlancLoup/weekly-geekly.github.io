<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to run a program without an operating system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It turned out that in our article describing the PCI bus polling mechanism , the most important thing was not described in sufficient detail: how to r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to run a program without an operating system</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/733/5ce/c4d/7335cec4d82e5ebb3c04ca2aa0d4d967.jpg"><br>  It turned out that in our article describing <a href="http://habrahabr.ru/company/neobit/blog/162769/">the PCI bus polling mechanism</a> , the most important thing was not described in sufficient detail: how to run this code on real hardware?  How to create your own boot disk?  In this article we will answer all these questions in detail (some of these questions were discussed in the previous article, but for readability we allow ourselves a little duplication of material). <br><br>  On the Internet, there are a huge number of descriptions and tutorials about how to write your own mini-OS, there are even hundreds of ready-made small hobby OS.  One of the most worthy resources on this topic that I would like to highlight is the portal osdev.org.  To supplement the previous article about PCI (and the ability to write subsequent articles about the various functions that are present in any modern OS), we will describe step-by-step instructions for creating a boot disk with a familiar C program. We tried to write as much as possible so that we could figure it out yourself. <br><br>  So, the goal: having spent as little effort as possible, create your own bootable USB flash drive, which only prints the classic ‚ÄúHello World‚Äù on the computer screen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  To be more precise, we need to ‚Äúget‚Äù into protected mode with page paging turned off and interrupts - the simplest mode of operation of the processor with the usual behavior for a simple console program.  The most reasonable way to achieve this goal is to build a multiboot-compatible kernel and download it using the popular Grub loader.  An alternative to this solution is to write your own volume boot record (VBR), which would load the written own loader.  A decent bootloader, at a minimum, should be able to work with the disk, with the file system, and parse elf images.  This means the need to write a lot of assembly code, and a lot of code in C. In a word, it is easier to use Grub, which already knows how to do everything necessary. <br><br>  To begin with, a further set of compilers and utilities are needed for further actions.  The easiest way to use any Linux (for example, Ubuntu), since it will already contain everything you need to create a bootable flash drive.  If you are used to working in Windows, you can set up a Linux virtual machine (using Virtual Box or VMware Workstation). <br><br>  If you are using Linux Ubuntu, then first of all you need to install several utilities: <br>  1. Grub.  To do this, use the command: <br><pre><code class="bash hljs">sudo apt-get install grub</code> </pre> <br><br>  2. Qemu.  It is needed to quickly <a href="http://habrahabr.ru/company/neobit/blog/141067/">test and debug</a> everything, for this the command is similar: <br><pre> <code class="bash hljs">sudo apt-get install qemu</code> </pre><br><br>  Now our plan looks like this: <br>  1. create a C program, print the line on the screen. <br>  2. compile an image of it (kernel.bin) in the miniboot format so that it is available for download using GRUB. <br>  3. Create a boot disk image file and format it. <br>  4. install on this image Grub. <br>  5. copy the created program to disk (kernel.bin). <br>  6. burn the image to physical media or run it in qemu. <br><br>  and the system boot process: <br><img src="https://habrastorage.org/storage2/b25/c7f/f7c/b25c7ff7c7f79cfd68e4b9c412515c33.jpg"><br><br>  In order to succeed, you will need to create several files and directories: <br><table border="1"><tbody><tr><td><p>  kernel.c </p></td><td><p>  Program code written in C. The program prints a message on the screen. </p></td></tr><tr><td><p>  makefile </p></td><td><p>  Makefile, a script that performs the entire build of the program and the creation of a boot image. </p></td></tr><tr><td><p>  linker.ld </p></td><td><p>  The compiler script for the kernel. </p></td></tr><tr><td><p>  loader.s </p></td><td><p>  An assembler code that is called by Grub and transfers control of the main function from the C program. </p></td></tr><tr><td><p>  include / </p></td><td><p>  Folder with header files. </p></td></tr><tr><td><p>  grub / </p></td><td><p>  Folder with Grub files. </p></td></tr><tr><td><p>  common / </p></td><td><p>  Folder with general purpose functions.  Including the implementation of printf. </p></td></tr></tbody></table><br><br><h4>  Step 1. Creating the target program code (kernel): </h4><br><br>  Create a file kernel.c, which will contain the following code that prints the message on the screen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screen.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> void main(void) { clear_screen(); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n&gt;&gt;&gt; Hello World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br><br>  It's all familiar and simple.  Adding printf and clear_screen functions will be discussed further.  In the meantime, you need to supplement this code with everything you need so that it can be loaded by Grub. <br>  In order for the kernel to be in multiboot format, you need the following structure to be in the first 8 kilobytes of the kernel image: <br><br><table border="1"><tbody><tr><td><p>  0x1BADB002 = MAGIC </p></td><td><p>  Multiboot format signature </p></td></tr><tr><td><p>  0x0 = FLAGS </p></td><td><p>  Flags that contain additional requirements for loading the kernel and parameters passed by the loader to the kernel (our program).  In this case, all flags are reset. </p></td></tr><tr><td><p>  0xE4524FFE = - (MAGIC + FLAGS) </p></td><td><p>  Check sum. </p></td></tr></tbody></table><br><br>  If all the specified conditions are met, then Grub passes the% eax and% ebx registers to a pointer to the multiboot Information structure and the value 0x1BADB002, respectively.  The multiboot Information structure contains various information, including a list of loaded modules and their location, which you may need to further boot the system. <br>  In order for the program file to contain the necessary signatures, create the file loader.s, with the following contents: <br><br><pre> <code class="cpp hljs">.text .global loader <span class="hljs-meta"><span class="hljs-meta"># making entry point visible to linker # setting up the Multiboot header - see GRUB docs for details .set FLAGS, 0x0 # this is the Multiboot </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'flag'</span></span></span><span class="hljs-meta"> field .set MAGIC, 0x1BADB002 # </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'magic number'</span></span></span><span class="hljs-meta"> lets bootloader find the header .set CHECKSUM, -(MAGIC + FLAGS) # checksum required .align 4 .long MAGIC .long FLAGS .long CHECKSUM # reserve initial kernel stack space .set STACKSIZE, 0x4000 # that is, 16k. .lcomm stack, STACKSIZE # reserve 16k stack .comm mbd, 4 # we will use this in kmain .comm magic, 4 # we will use this in kmain loader: movl $(stack + STACKSIZE), %esp # set up the stack movl %eax, magic # Multiboot magic number movl %ebx, mbd # Multiboot data structure call main # call C code cli hang: hlt # halt machine should kernel return jmp hang</span></span></code> </pre><br><br>  Consider the code in more detail.  This code in almost <a href="http://wiki.osdev.org/Bare_Bones">unchanged</a> form is taken from <a href="http://wiki.osdev.org/Bare_Bones">wiki.osdev.org/Bare_Bones</a> .  Since gcc is used for compilation, GAS syntax is used.  Let's take a closer look at what this code does. <br><pre> <code class="cpp hljs">.text</code> </pre><br>  All subsequent code will go into the executable section .text. <br><pre> <code class="cpp hljs">.global loader</code> </pre><br>  We declare the loader symbol visible to the linker.  This is required because the linker will use the loader as an entry point. <br><pre> <code class="cpp hljs"> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> FLAGS, <span class="hljs-number"><span class="hljs-number">0x0</span></span> #  FLAGS = <span class="hljs-number"><span class="hljs-number">0x0</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> MAGIC, <span class="hljs-number"><span class="hljs-number">0x1BADB002</span></span> #  MAGIC = <span class="hljs-number"><span class="hljs-number">0x1BADB002</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> CHECKSUM, -(MAGIC + FLAGS) #  CHECKSUM = -(MAGIC + FLAGS) .align <span class="hljs-number"><span class="hljs-number">4</span></span> #     <span class="hljs-number"><span class="hljs-number">4</span></span>  .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> MAGIC #      MAGIC .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> FLAGS #      FLAGS .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> CHECKSUM #      CHECKSUM</code> </pre><br>  This code forms the signature of the Multiboot format.  The .set directive sets the value of a character to the expression to the right of the comma.  The .align 4 directive aligns subsequent content to 4 bytes.  The .long directive stores the value in four subsequent bytes. <br><pre> <code class="cpp hljs"> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> STACKSIZE, <span class="hljs-number"><span class="hljs-number">0x4000</span></span> #  STACKSIZE = <span class="hljs-number"><span class="hljs-number">0x4000</span></span> .lcomm <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, STACKSIZE #  STACKSIZE . <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>    .comm mbd, <span class="hljs-number"><span class="hljs-number">4</span></span> #  <span class="hljs-number"><span class="hljs-number">4</span></span>    mdb   COMMON .comm magic, <span class="hljs-number"><span class="hljs-number">4</span></span> #  <span class="hljs-number"><span class="hljs-number">4</span></span>    magic   COMMON</code> </pre><br>  During the boot process, grub does not configure the stack, and the first thing that the kernel has to do is configure the stack, for this we reserve 0x4000 (16Kb) bytes.  The .lcomm directive reserves in the .bss section the number of bytes indicated after the comma.  The stack name will be visible only in the compiled file.  The .comm directive does the same thing as .lcomm, but the symbol name will be declared globally.  This means that by writing the following line in the C code, we can use it. <br>  extern int magic <br><br>  And now the last part: <br><pre> <code class="cpp hljs">loader: movl $(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> + STACKSIZE), %esp #   movl %eax, magic #  %eax   magic movl %ebx, mbd #  %ebx   mbd call main #   main cli #     hang: hlt #       jmp hang #    hang</code> </pre><br><br>  The first instruction saves the value of the top of the stack in the register% esp.  As the stack grows down, the address of the end of the range allocated for the stack is written in% esp.  The two following instructions store in the previously reserved 4-byte ranges the values ‚Äã‚Äãthat Grub transmits in the registers% eax,% ebx.  Then the main function, which is already written in C, is called.  In the case of a return from this procedure, the processor will loop. <br><br><h4>  Step 2. Preparation of additional code for the program (system library): </h4><br><br>  Since the entire program is written from scratch, the printf function needs to be written from scratch.  To do this, prepare a few files. <br>  Create a common folder and include: <br><br><pre> <code class="cpp hljs">mkdir common mkdir include</code> </pre><br><br>  Create a file common \ printf.c, which will contain the implementation of the usual printf function.  This entire file can be <a href="http://www.bitvisor.org/">obtained</a> from the project <a href="http://www.bitvisor.org/">www.bitvisor.org</a> .  Path to the file in the bitvisor source code: core / printf.c.  In the printf.c file copied from bitvisor, for use in the target program you need to replace the lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"initfunc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"putchar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spinlock.h"</span></span></span></span></code> </pre><br>  on the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdarg.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screen.h"</span></span></span></span></code> </pre><br><br>  Then, remove the printf_init_global function and all its references in this file: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf_init_global</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ spinlock_init (&amp;printf_lock); } INITFUNC (<span class="hljs-string"><span class="hljs-string">"global0"</span></span>, printf_init_global);</code> </pre><br><br>  Then delete the printf_lock variable and all its references in this file: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spinlock_t</span></span> printf_lock; ‚Ä¶ spinlock_lock (&amp;printf_lock); ‚Ä¶ spinlock_unlock (&amp;printf_lock);</code> </pre><br><br>  The printf function uses the putchar function, which you also need to write.  To do this, create the file common \ screen.c with the following contents: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GREEN 0x2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_COL 80 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Maximum number of columns #define MAX_ROW 25 // Maximum number of rows #define VRAM_SIZE (MAX_COL*MAX_ROW) // Size of screen, in short's #define DEF_VRAM_BASE 0xb8000 // Default base for video memory static unsigned char curr_col = 0; static unsigned char curr_row = 0; // Write character at current screen location #define PUT(c) ( ((unsigned short *) (DEF_VRAM_BASE)) \ [(curr_row * MAX_COL) + curr_col] = (GREEN &lt;&lt; 8) | (c)) // Place a character on next screen position static void cons_putc(int c) { switch (c) { case '\t': do { cons_putc(' '); } while ((curr_col % 8) != 0); break; case '\r': curr_col = 0; break; case '\n': curr_row += 1; if (curr_row &gt;= MAX_ROW) { curr_row = 0; } break; case '\b': if (curr_col &gt; 0) { curr_col -= 1; PUT(' '); } break; default: PUT(c); curr_col += 1; if (curr_col &gt;= MAX_COL) { curr_col = 0; curr_row += 1; if (curr_row &gt;= MAX_ROW) { curr_row = 0; } } }; } void putchar( int c ) { if (c == '\n') cons_putc('\r'); cons_putc(c); } void clear_screen( void ) { curr_col = 0; curr_row = 0; int i; for (i = 0; i &lt; VRAM_SIZE; i++) cons_putc(' '); curr_col = 0; curr_row = 0; }</span></span></span></span></code> </pre><br><br>  The specified code contains a simple logic of printing characters on the screen in text mode.  In this mode, two bytes are used to record a character (one with the character code, the other with its attributes), recorded directly in the video memory displayed immediately on the screen and starting at 0xB8000.  The screen resolution is 80x25 characters.  Direct printing of the symbol is carried out using the macro PUT. <br>  Now just a few header files are missing: <br>  1. File include \ screen.h.  Declares the putchar function that is used in the printf function.  File contents: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SCREEN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SCREEN_H void clear_screen( void ); void putchar( int c ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  2. The file include \ printf.h.  Declares a printf function that is used in main.  File contents: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _PRINTF_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PRINTF_H int printf (const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  3. File include \ stdarg.h.  Declares functions for enumerating arguments, the number of which is not known in advance.  The entire file is taken from the project <a href="http://www.bitvisor.org/">www.bitvisor.org</a> .  Path to the file in the code of the bitvisor project: include \ core \ stdarg.h. <br>  4. File include \ types.h.  Declares NULL and size_t.  File contents: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _TYPES_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TYPES_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NULL 0 typedef unsigned int size_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Thus, the include and common folders contain the minimum system library code that any program needs. <br><br><h4>  Step 3. Creating a script for the linker: <br></h4><br><br>  Create a linker.ld file that will be used by the linker to generate the target program file (kernel.bin).  The file should contain the following: <br><br><pre> <code class="cpp hljs">ENTRY (loader) LMA = <span class="hljs-number"><span class="hljs-number">0x00100000</span></span>; SECTIONS { . = LMA; .<span class="hljs-function"><span class="hljs-function">multiboot </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ loader.o( .text ) } .<span class="hljs-function"><span class="hljs-function">text </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.text) } .<span class="hljs-function"><span class="hljs-function">rodata </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.rodata*) } .<span class="hljs-function"><span class="hljs-function">data </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.data) } .bss : { *(COMMON) *(.bss) } /DISCARD/ : { *(.comment) } }</code> </pre><br><br>  The built-in function ENTRY () allows us to set the input point for our kernel.  It is to this address that grub will transfer control after the kernel is loaded.  The linker using this script will create a binary file in ELF format.  An ELF file consists of a set of segments and sections.  The list of segments is contained in the Program header table, the list of sections in the Section header table.  The linker operates with sections, the image loader (in our case it is GRUB) with segments. <br><img src="https://habrastorage.org/storage2/b4c/25a/34a/b4c25a34aae95e260e602f6acbe7849e.jpg"><br><br>  As can be seen in the figure, the segments consist of sections.  One of the fields describing the section is the virtual address where the section should be located at the time of execution.  In fact, a segment has 2 fields describing its location: the virtual address of the segment and the physical address of the segment.  The virtual address of the segment is the virtual address of the first byte of the segment at the time the code is executed, the physical address of the segment is the physical address where the segment should be loaded.  For application programs, these addresses are always the same.  Grub loads image segments by their physical address.  Since Grub does not configure page addressing, the virtual address of the segment must match its physical address, since in our program virtual memory is also not configurable. <br><br><pre> <code class="cpp hljs">SECTIONS</code> </pre><br>  Says that further sections are described. <br><pre> <code class="css hljs">. = <span class="hljs-selector-tag"><span class="hljs-selector-tag">LMA</span></span>;</code> </pre><br>  This expression indicates to the linker that all subsequent sections are after the LMA address. <br><pre> <code class="cpp hljs"> ALIGN (<span class="hljs-number"><span class="hljs-number">0x1000</span></span>)</code> </pre><br>  The directive above means that the section is aligned on 0x1000 bytes. <br><pre> <code class="cpp hljs">.<span class="hljs-function"><span class="hljs-function">multiboot </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ loader.o( .text ) }</code> </pre><br>  A separate multiboot section, which includes the .text section from the loader.o file, is made to ensure that the multiboot format signature is in the first 8kb of the kernel image. <br><pre> <code class="cpp hljs">.bss : { *(COMMON) *(.bss) }</code> </pre><br>  * (COMMON) is the area in which the memory is reserved with the .comm and .lcomm instructions.  We have it in the .bss section. <br><pre> <code class="cpp hljs">/DISCARD/ : { *(.comment) }</code> </pre><br>  All sections marked DISCARD are removed from the image.  In this case, we delete the .comment section, which contains information about the linker version. <br><br>  Now we compile the code into a binary file with the following commands: <br><pre> <code class="cpp hljs">as -o loader.o loader.s gcc -Iinclude -Wall -fno-builtin -nostdinc -nostdlib -o kernel.o -c kernel.c gcc -Iinclude -Wall -fno-builtin -nostdinc -nostdlib -o <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.o -c common/<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.c gcc -Iinclude -Wall -fno-builtin -nostdinc -nostdlib -o screen.o -c common/screen.c ld -T linker.ld -o kernel.bin kernel.o screen.o <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.o loader.o</code> </pre><br>  Using objdump, we will look at how the image of the kernel looks after linking: <br><pre> <code class="cpp hljs">objdump -ph ./kernel.bin</code> </pre><br><br><img src="https://habrastorage.org/storage2/686/79b/094/68679b094bb161a99ba9a701d94d5d86.jpg"><br><br>  As you can see, the sections in the image are the same as those described in the linker script.  The linker formed 3 segments of the described sections.  The first segment includes sections .multiboot, .text, .rodata and has a virtual and physical address 0x00100000.  The second segment contains the .data and .bss sections and is located at 0x00104000.  So everything is ready to download this file using Grub. <br><br>  Step 4. Preparing the Grub Loader: <br>  Create a grub folder: <br><pre> <code class="cpp hljs">mkdir grub</code> </pre><br><br>  Copy into this folder several Grub files that are necessary for its installation on the image (the following files exist if Grub is installed on the system).  To do this, run the following commands: <br><pre> <code class="cpp hljs">cp /usr/lib/grub/i386-pc/stage1 ./grub/ cp /usr/lib/grub/i386-pc/stage2 ./grub/ cp /usr/lib/grub/i386-pc/fat_stage1_5 ./grub/</code> </pre><br><br>  Create a grub / menu.lst file with the following contents: <br><pre> <code class="cpp hljs">timeout <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">title mini_os </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hd0,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> kernel /kernel.bin</span></span></code> </pre><br><br><h4>  Step 5. Automate and create a boot image: </h4><br>  To automate the build process, we will use the make utility.  To do this, create a makefile file that will build to compile the source code, build the kernel and create a boot image.  Makefile should have the following contents: <br><br><pre> <code class="cpp hljs">CC = gcc CFLAGS = -Wall -fno-builtin -nostdinc -nostdlib LD = ld OBJFILES = \ loader.o \ common/<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.o \ common/screen.o \ kernel.o image: @echo <span class="hljs-string"><span class="hljs-string">"Creating hdd.img..."</span></span> @dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=./hdd.img bs=<span class="hljs-number"><span class="hljs-number">512</span></span> count=<span class="hljs-number"><span class="hljs-number">16065</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;/dev/null <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> @echo <span class="hljs-string"><span class="hljs-string">"Creating bootable first FAT32 partition..."</span></span> @losetup /dev/loop1 ./hdd.img @(echo c; echo u; echo n; echo p; echo <span class="hljs-number"><span class="hljs-number">1</span></span>; echo ; echo ; echo a; echo <span class="hljs-number"><span class="hljs-number">1</span></span>; echo t; echo c; echo w;) | fdisk /dev/loop1 <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;/dev/null <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> || <span class="hljs-literal"><span class="hljs-literal">true</span></span> @echo <span class="hljs-string"><span class="hljs-string">"Mounting partition to /dev/loop2..."</span></span> @losetup /dev/loop2 ./hdd.img \ --offset `echo \`fdisk -lu /dev/loop1 | sed -n <span class="hljs-number"><span class="hljs-number">10</span></span>p | awk <span class="hljs-string"><span class="hljs-string">'{print $$3}'</span></span>\`*<span class="hljs-number"><span class="hljs-number">512</span></span> | bc` \ --sizelimit `echo \`fdisk -lu /dev/loop1 | sed -n <span class="hljs-number"><span class="hljs-number">10</span></span>p | awk <span class="hljs-string"><span class="hljs-string">'{print $$4}'</span></span>\`*<span class="hljs-number"><span class="hljs-number">512</span></span> | bc` @losetup -d /dev/loop1 @echo <span class="hljs-string"><span class="hljs-string">"Format partition..."</span></span> @mkdosfs /dev/loop2 @echo <span class="hljs-string"><span class="hljs-string">"Copy kernel and grub files on partition..."</span></span> @mkdir -p tempdir @mount /dev/loop2 tempdir @mkdir tempdir/boot @cp -r grub tempdir/boot/ @cp kernel.bin tempdir/ @sleep <span class="hljs-number"><span class="hljs-number">1</span></span> @umount /dev/loop2 @rm -r tempdir @losetup -d /dev/loop2 @echo <span class="hljs-string"><span class="hljs-string">"Installing GRUB..."</span></span> @echo <span class="hljs-string"><span class="hljs-string">"device (hd0) hdd.img \n \ root (hd0,0) \n \ setup (hd0) \n \ quit\n"</span></span> | grub --batch <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;/dev/null @echo <span class="hljs-string"><span class="hljs-string">"Done!"</span></span> all: kernel.bin rebuild: clean all .so: as -o $@ $&lt; .co: $(CC) -Iinclude $(CFLAGS) -o $@ -c $&lt; kernel.bin: $(OBJFILES) $(LD) -T linker.ld -o $@ $^ clean: rm -f $(OBJFILES) hdd.img kernel.bin</code> </pre><br><br>  The file declared two main goals: all - compiles the kernel, and image - which creates a boot disk.  The all target is similar to the usual makefile. It contains the .so and .co subgoals, which compile the * .s and * .c files into object files (* .o), as well as the goal of generating kernel.bin, which calls the linker with the previously created script.  These goals accomplish exactly the same commands that are listed in step 3. <br>  Of greatest interest here is the creation of the boot image hdd.img (image target).  Consider in stages how this happens. <br><pre> <code class="cpp hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=./hdd.img bs=<span class="hljs-number"><span class="hljs-number">512</span></span> count=<span class="hljs-number"><span class="hljs-number">16065</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;/dev/null <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  This command creates an image with which further work will take place.  The number of sectors was not chosen randomly: 16065 = 255 * 63. By default, fdsik works with the disk as if it has a CHS geometry, in which Headers (H) = 255, Sectors (S) = 63, and Cylinders (C) depends on disk size.  Thus, the minimum disk size that the fdsik utility can work with, without changing the default geometry, is 512 * 255 * 63 * 1 = 8225280 bytes, where 512 is the sector size and 1 is the number of cylinders. <br>  Next, create a partition table: <br><pre> <code class="cpp hljs">losetup /dev/loop1 ./hdd.img (echo c; echo u; echo n; echo p; echo <span class="hljs-number"><span class="hljs-number">1</span></span>; echo ; echo ; echo a; echo <span class="hljs-number"><span class="hljs-number">1</span></span>; echo t; echo c; echo w;) | fdisk /dev/loop1 <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;/dev/null <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  The first command mounts the hdd.img file to the / dev / loop1 block device, allowing you to work with the file as with a device.  The second command creates a partition table on the / dev / loop1 device, in which there is 1 primary boot partition on the disk occupying the entire disk with the label of the FAT32 file system. <br>  Then we format the created section.  To do this, mount it as a block device and perform formatting. <br><pre> <code class="cpp hljs">losetup /dev/loop2 ./hdd.img \ --offset `echo \`fdisk -lu /dev/loop1 | sed -n <span class="hljs-number"><span class="hljs-number">10</span></span>p | awk <span class="hljs-string"><span class="hljs-string">'{print $$3}'</span></span>\`*<span class="hljs-number"><span class="hljs-number">512</span></span> | bc` \ --sizelimit `echo \`fdisk -lu /dev/loop1 | sed -n <span class="hljs-number"><span class="hljs-number">10</span></span>p | awk <span class="hljs-string"><span class="hljs-string">'{print $$4}'</span></span>\`*<span class="hljs-number"><span class="hljs-number">512</span></span> | bc` losetup -d /dev/loop1</code> </pre><br>  The first command mounts the previously created partition to the / dev / loop2 device.  The option ‚Äìoffset indicates the address of the beginning of the section, and ‚Äìsizelimit the address of the end of the section.  Both parameters are obtained using the fdisk command. <br><pre> <code class="cpp hljs">mkdosfs /dev/loop2</code> </pre><br>  The mkdosfs utility formats the partition into the FAT32 file system. <br>  To directly assemble the kernel, the previously discussed commands are used in the classic syntax of the makefile. <br>  Now let's look at how to install GRUB on the partition: <br><pre> <code class="cpp hljs">mkdir -p tempdir #    mount /dev/loop2 tempdir #     mkdir tempdir/boot #   /boot   cp -r grub tempdir/boot/ #   grub  /boot cp kernel.bin tempdir/ #      sleep <span class="hljs-number"><span class="hljs-number">1</span></span> #  Ubuntu umount /dev/loop2 #    rm -r tempdir #    losetup -d /dev/loop2 #  </code> </pre><br>  After executing the above commands, the image will be ready to install GRUB.  The following command installs GRUB in the MBR disk image hdd.img. <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"device (hd0) hdd.img \n \ root (hd0,0) \n \ setup (hd0) \n \ quit\n"</span></span> | grub --batch 1&gt;/dev/null</code> </pre><br><br>  Everything is ready for testing! <br><br><h4>  Step 6. Launch: </h4><br><br>  To compile, use the command: <br><pre> <code class="bash hljs">make all</code> </pre><br>  After which the file kernel.bin should appear. <br>  To create a bootable disk image, use the command: <br><pre> <code class="bash hljs">sudo make image</code> </pre><br>  As a result, the file hdd.img should appear. <br>  Now you can boot from the hdd.img disk image.  You can check this with the following command: <br><pre> <code class="bash hljs">qemu -hda hdd.img -m 32</code> </pre><br>  or: <br><pre> <code class="bash hljs">qemu-system-i386 -hda hdd.img</code> </pre><br><img src="https://habrastorage.org/storage2/812/f88/b03/812f88b03c670b9438d60f598cfbe7df.jpg"><br><img src="https://habrastorage.org/storage2/b29/98a/194/b2998a194290555364e9749bba5067b1.jpg"><br><br>  To check on a real machine, you need to make dd of this image on a flash drive and boot from it.  For example, such a command: <br><pre> <code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=./hdd.img of=/dev/sdb</code> </pre><br><br>  Summarizing, we can say that as a result of the actions performed, we obtain a set of source codes and scripts that allow us to conduct various experiments in the field of system programming.  The first step towards creating system software, such as hypervisors and operating systems, has been taken. <br><br>  Links to the following articles of the cycle: <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/174157/">part 2</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/176707/">part 3: Graphics</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/181626/">part 4. Parallel computing</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/211470/">part 5. Accessing the BIOS from the OS</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/203706/">part 6. Support for working with disks with the FAT file system</a></b> " </div><p>Source: <a href="https://habr.com/ru/post/173263/">https://habr.com/ru/post/173263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173203/index.html">Google is preparing a competitor Evernote</a></li>
<li><a href="../173205/index.html">Effective online store. How to create marketable content for a large online store? PART 1</a></li>
<li><a href="../173207/index.html">Moedls: smartphone + laser = 3D scanner</a></li>
<li><a href="../173209/index.html">Records from high load HPC conferences</a></li>
<li><a href="../173211/index.html">Impressions from working with Play! Framework 2.1 + Java</a></li>
<li><a href="../173265/index.html">Exposing 12 legal misconceptions about computer programs</a></li>
<li><a href="../173267/index.html">Effective online store. How to create marketable content for a large online store? PART 2</a></li>
<li><a href="../173269/index.html">My version of "gravitsapy"</a></li>
<li><a href="../173271/index.html">Why HTML coders don't like web designers</a></li>
<li><a href="../173273/index.html">On artificial intelligence in poker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>