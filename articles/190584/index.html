<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the UTF-8 flag</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A common misconception is that character strings, unlike byte strings, have the UTF-8 flag set. 
 Many people realize that if the data is ASCII-7-bit,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the UTF-8 flag</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/204/044/55a/20404455ac40f027b0b0fcd46c7fdea1.jpg"><br><br>  A common misconception is that character strings, unlike byte strings, have the UTF-8 flag set. <br>  Many people realize that if the data is ASCII-7-bit, then the UTF-8 flag is simply not important. <br><br>  However, in fact, it can be installed or reset, as well as in characters, and absolutely arbitrary binary data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  <i>Marc Lehmann,</i> widely known in the Perl community, comments on this in the <a href="">JSON :: XS</a> module documentation. <br><br><blockquote>  You can have it.  Other possibilities exist, too. <br></blockquote><br><br><h5>  Consider the case when the ASCII-7bit data has the UTF-8 flag set. </h5><br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> utf8; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $u = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment"># unicode  my $ascii = "x"; #  ASCII  my ($ascii_u, undef) = split(/ /, "$ascii $u"); die unless $ascii_u eq "x"; #   ASCII  print "UTF-8 flag set!" if utf8::is_utf8($ascii_u); #      UTF-8 </span></span></code> </pre> <br><br>  This code displays the ‚ÄúUTF-8 flag set!‚Äù.  That is, the ASCII-7bit string received this flag after the split operation split the Unicode string (with the UTF-8 flag) into parts.  It can be said that the programmer does not control whether his ASCII data will have a UTF-8 flag or not, it depends on where it came from and how the data was received, and on what data was next to it. <br><br>  The same effect is obtained if decoding ASCII-7bit bytes to ASCII-7bit characters using <a href="">Encode :: decode ()</a> <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ascii = <span class="hljs-string"><span class="hljs-string">'x'</span></span>; <span class="hljs-comment"><span class="hljs-comment"># ASCII  my $ascii_u = decode("UTF-8", encode("UTF-8", "$ascii")); die unless $ascii_u eq "x"; #   ASCII  print "UTF-8 flag set!" if utf8::is_utf8($ascii_u); #      UTF-8 </span></span></code> </pre><br><br>  Those.  re-encoding back and forth does not change the data (this is expected), but sets the UTF-8 flag. <br>  (however, this decode () behavior <a href="https://rt.cpan.org/Public/Bug/Display.html%3Fid%3D34259">contradicts</a> its own <a href="">documentation</a> , which, in turn, contradicts the idea that there should be no documentation and guarantees regarding the utf-8 flag in ASCII) <br><br>  The reasons for the appearance of the UTF-8 flag can be explained by efficiency considerations.  It is too expensive after split to analyze a string to see if it consists only of ASCII characters and whether it is possible to reset the flag. <br><br>  This behavior of the UTF-8 flag is similar to a virus ‚Äî it infects all the data with which it comes in contact. <br><br><h5>  Consider the case where non-ASCII, Unicode characters do not have the UTF-8 flag. </h5><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Digest::SHA <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/sha1_hex/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> utf8; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s = <span class="hljs-string"><span class="hljs-string">"¬µ"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s1 = $s; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s2 = $s; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $digest = sha1_hex($s2); <span class="hljs-comment"><span class="hljs-comment">#     print "utf-8 bit ON (s1)\n" if utf8::is_utf8($s1); print "utf-8 bit ON (s2)\n" if utf8::is_utf8($s2); print "s1 and s2 are equal\n" if $s1 eq $s2;</span></span></code> </pre><br><br>  prints: <br><br><pre> utf-8 bit ON (s1)
 s1 and s2 are equal
</pre><br><br>  That is, the function call of the third-party module has reset the UTF-8 flag.  At the same time, the lines with the flag and without, turned out to be completely identical. <br>  This can only happen with&gt; 127 and &lt;= 255 (i.e. Latin-1). <br><br>  Actually, the <b>utf8 :: downgrade</b> operation occurred with the string $ s2 <br><br>  This function is described in the <a href="http://search.cpan.org/perldoc%3Futf8">documentation</a> as changing the internal representation of the string: <br><br><blockquote>  Conversion in Latin America (Latin-1 or EBCDIC).  The logical character sequence itself is unchanged. <br></blockquote><br><br>  In principle, the Digest :: SHA module documents this behavior, although it is not required to: <br><br><blockquote>  Be aware that the digest routines silently convert UTF-8 input into its <br>  equivalent byte sequence in the native encoding (cf. utf8 :: downgrade).  This <br>  side effect <br>  the data intact. <br></blockquote><br><br>  In general, any 3-rd party function can make a downgrade line, without informing the documentation (or, for example, do it only occasionally). <br><br><h5>  Consider the case when absolutely arbitrary binary data has a UTF-8 flag. </h5><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> utf8; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-comment"><span class="hljs-comment">#   bytes::length  ,  '()'  bytes      use bytes (); my $u = ""; #  ASCII  # ,   my $bin = "\xf1\xf2\xf3"; ##   ASCII   UTF-8  my $ascii = "x"; #  ASCII  my ($ascii_u, undef) = split(/ /, "$ascii $u"); die unless $ascii_u eq "x"; #   ASCII  die unless utf8::is_utf8($ascii_u); #      UTF-8  ## // print "original bin length:\t"; print length($bin) . "\t" . bytes::length($bin) ."\n"; my $bin_a = $bin.$ascii; #   ,  ASCII  print "bin_a length:\t"; print length($bin_a) . "\t" . bytes::length($bin_a) ."\n"; my $bin_u = $bin.$ascii_u; #    ,  ASCII  print "bin_u length:\t"; print length($bin_u) . "\t" . bytes::length($bin_u) ."\n"; print "bin_a and bin_u are equal!\n" if $bin_a eq $bin_u; open my $f, "&gt;", "file_a.tmp"; binmode $f; print $f $bin_a; close $f; open $f, "&gt;", "file_u.tmp"; binmode $f; print $f $bin_u; close $f; system("md5sum file_?.tmp"); # md5sum -  linux</span></span></code> </pre><br><br>  gives out: <br><br><pre> original bin length: 3 3
 bin_a length: 4 4
 bin_u length: 4 7
 bin_a and bin_u are equal!
 33818f4b23aa74cddb8eb625845a459a file_a.tmp
 33818f4b23aa74cddb8eb625845a459a file_u.tmp
</pre><br><br>  The result is that the binary data, after concatenating with an ASCII string, increased its internal size in bytes (but not in characters) from 4 to 7, but only if the meaningless UTF-8 flag of ASCII was set . <br><br>  However, when comparing this data with each other, they are identical, as well, when outputting both strings to the file, even without specifying the encoding, the files were also identical. <br><br>  Thus, binary data can increase in size and get the UTF-8 flag, while there is no bug, all Perl built-in functions process them exactly as if the flag were not (if there are exceptions, then a bug in them). <br><br>  Any other perl code must also process such data without errors (if it does not try to analyze the internal structure of the string, or at least analyzes it correctly) <br><br>  In fact, what happened to the binary data is analogous to the <b>utf8 :: upgrade</b> operation.  The data was interpreted as Latin-1, converted to UTF-8, and the UTF-8 flag set.  This operation is the opposite of <b>utf8 :: downgrade</b> , described above.  <b>utf8 :: downgrade</b> can only be done with Latin-1 characters.  And <b>utf8 :: upgrade</b> can be done <br>  with any bytes (since any byte corresponds to a character from Latin-1). <br><br>  This can be important if you have a large amount of binary data in your memory.  It‚Äôs not at all cool if a 400 megabyte blob suddenly turns into a 700 megabyte, just because you added one ASCII-7bit byte with the UTF-8 flag.  A good way out of the situation here is unit tests or runtime <a href="http://en.wikipedia.org/wiki/Assertion_%2528software_development%2529">assertions</a> with checking the UTF-8 flag. <br><br><h5>  In general, it is impossible to distinguish between bytes and characters. </h5><br><br>  Consider the task: to write a function, the input of which will be XML, if the XML is bytes, look at the encoding in the tag "xml" and transcode them into characters.  If it is already a character, do nothing. <br><br>  This function will not work.  For example, for the character string "Hello, M√ºnchen", the function will not <br>  distinguish the characters from this, or bytes encoded in CP1251, or in KOI8-R (in case the line is downgraded, and the programmer in general does not control this). <br><br>  For characters&gt; 255, the UTF-8 flag is always set (you cannot make <b>utf8 :: downgrade</b> with them).  For characters with the code &lt;= 127, UTF-8 bits are not important, in the sense that they can be viewed as both binary data and symbols.  For Latin1 characters, it is not possible to distinguish from bytes. <br><br>  Distinguishing bytes from characters in Perl is the same as distinguishing a file name from an email and from a person‚Äôs name.  Sometimes it is possible, but generally not.  The programmer himself must remember in which variable what is in it. <br><br>  This is in the documentation: <br><br>  <a href="http://perldoc.perl.org/perlunifaq.html">perldoc.perl.org/perlunifaq.html</a> <br><br><blockquote>  How can I determine if a string is a string? <br><br>  You can't.  Flag for this, but it makes it possible to use modules like Data :: Dumper look bad.  Because of the 8 bit encoding (by default ISO-8859-1), it is useless for this purpose. <br><br>  This is something you need to keep track of;  sorry.  You could consider adopting a kind of "Hungarian notation" to help with this. <br></blockquote><br><br>  If you still need to do this, you can create your own class, which will contain a string of bytes or characters, and a flag indicating that it is (the same trick is suitable for email vs file name vs name of person). <br><br><h5>  Wide characters not issued for Latin-1 characters </h5><br><br>  The following example only issues warning <i>Wide characters in print</i> if we print $ s2 <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> utf8; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s1 = <span class="hljs-string"><span class="hljs-string">"√ü"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s2 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s = $ARGV[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? $s1 : $s2; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $s;</code> </pre><br><br>  If we print $ s1, Perl converts the Unicde character ¬µ (U + 00DF, UTF-8 \ xC3xF9) to byte \ xDF and tries to display it on the screen. <br>  The same behavior applies to all functions that accept bytes, not characters (print, syswrite without encoding, checksums SHA, MD5, CRC32, MIME :: Base64). <br><br><h5>  Viral downgrade </h5><br><br>  At the beginning of the article, the ‚Äúviral‚Äù behavior of the UTF-8 bit in ASCII characters (viral <b>utf8 :: upgrade</b> ) was described.  Now consider the ‚Äúviral‚Äù reset of UTF-8 bits in Latin-1 characters <b>(utf8 :: downgrade</b> ). <br><br>  Imagine that we are writing a function that is defined only on bytes and not on characters; a good example is the hash functions, encryption, archiving, Mime :: Base64, etc. <br><br>  1. Since it is impossible to distinguish binary data from characters, you must treat the input data as bytes. <br>  2. Bytes may have an <b>upgrade</b> form (because with the UTF-8 flag).  The result should be the same as for the <b>downgrade</b> form. <br><br>  Therefore, you need to do <b>utf8 :: downgrade</b> and give an error if it fails. <br><br>  For algorithms, such as hash functions, performance concerns are typical.  It is not efficient to make a second copy of the data in memory, so, in most cases, the function modifies the parameter passed to it. <br><br>  As many probably know, in Perl all parameters are passed by reference, but are usually used by value. <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mycode</span></span></span><span class="hljs-function"> </span></span>{ $_[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"X"</span></span>; <span class="hljs-comment"><span class="hljs-comment">#    ,      }</span></span></code> </pre><br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mycode</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($arg1) = @_; <span class="hljs-comment"><span class="hljs-comment">#       $arg1 = "X"; #     ,     }</span></span></code> </pre><br><br>  Thus, when creating a code that works exactly in accordance with the Perl specification, code is created that implicitly makes <b>utf8 :: downgrade</b> over the actual parameters, regardless of the caller‚Äôs will, thereby possibly creating a bug in some other place that handled strings incorrectly and worked well up to that point. <br><br><h5>  For file names, this does not work. </h5><br><br>  Functions that take file names as arguments ( <b>open</b> , file tests <b>-X</b> ), as well as that return file names ( <b>readdir</b> ), do not obey these rules (this is <a href="http://perldoc.perl.org/perlunicode.html">noted</a> in the documentation). <br><br>  They simply interpret the name of the file as it is in memory. <br><br>  The algorithm of their work can be described as follows: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ( ... $filename) = @_; utf8::_utf8_off($filename); <span class="hljs-comment"><span class="hljs-comment">#     _open($filename);</span></span></code> </pre><br><br>  There are several reasons for this: <br><br>  1. On many POSIX systems (Linux / * BSD), on many file systems, a file name may be an arbitrary sequence of bytes, not necessarily a sequence of characters in any encoding. <br>  2. There is no portable way to determine the file system encoding. <br>  3. There may be several file systems with different encoding on the machine. <br>  4. You can not rely on the assumption that the encoding of file names matches the locale encoding. <br>  5. Must be compatible with the old code. <br><br>  As a result, the programmer must determine the encoding himself and communicate it to the interpreter, but the API for this has not yet been done. <br><br>  We modify our example, where we ‚Äúaccidentally‚Äù stumbled upon downgrade character strings. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Digest::SHA <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/sha1_hex/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> utf8; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s = <span class="hljs-string"><span class="hljs-string">"¬µ"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s1 = $s; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s2 = $s; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $digest = sha1_hex($s2); <span class="hljs-comment"><span class="hljs-comment">#     print STDERR "s1 and s2 are equal\n" if $s1 eq $s2; open my $f, "&gt;", "$s1.tmp" or die "s1 failed: $!"; print $f "test"; close $f; open $f, "&lt;", "$s2.tmp" or die "s2 failed: $!"; print STDERR "Done\n";</span></span></code> </pre><br>  Result of work: <br><pre> s1 and s2 are equal
 s2 failed: no such file or directory 
</pre><br><br>  those.  the lines s1 and s2 are the same, but they point to different files, if you remove the <b>sha1_hex</b> export, then to the same files. <br><br>  You can stumble on this same rake, turning to any modules that work with files (for example, <b>File :: Find</b> ) <br><br><h5>  When else is it not working </h5><br><br>  In the Encode module There is a <a href="">decode_utf8</a> function <br>  documented as: <br><br><blockquote>  Equivalent to $ string = decode ("utf8", $ octets [, CHECK]) <br></blockquote><br><br>  But actually, if $ octets is set to the UTF-8 flag, the function simply returns them unchanged (although it should try to make <b>utf8 :: downgrade</b> and work with them as with binary data, and if <b>downgrade</b> fails, give the <i>Wide characters</i> error) . <br><br>  This bug was noticed ( <a href="https://rt.cpan.org/Public/Bug/Display.html%3Fid%3D61671">RT # 61671</a> <a href="https://rt.cpan.org/Public/Bug/Display.html%3Fid%3D87267">RT # 87267</a> ) as it appeared right away - in 2010. <br><br>  But the miner rejects all such bug reports.  At the same time, the essence of reports is not even that the function behaves correctly (in accordance with the idea of ‚Äã‚ÄãPerl), and not even that it contains documentation describing this behavior, but that, at least, this behavior is not must contradict existing documentation.  Maintainer believes that the functions are documented as equivalent, and this does not mean identical (although mine can be regarded as equivalence as similarity and identity).  Perhaps in mathematics the equivalence does not even contain a hint of identity ... If someone can solve this riddle, I will be very grateful. <br><br><h5>  The unicode bug </h5><br><br>  In a <b>downgraded</b> form, Latin-1 cannot be distinguished from bytes, therefore, in this form, some metacharacters in regular expressions do not work well, the functions <b>uc</b> , <b>lc</b> , <b>quotemeta</b> . <br><br>  Workaraund - <b>utf8 :: upgrade</b> , or, in new versions of Perl - some directives that allow you to make this behavior consistent. <br><br>  See the <a href="http://perldoc.perl.org/perlunicode.html">Perl documentation for</a> details. <br><br><h5>  What to do with all this? </h5><br><br>  1. Do not use (if you do not know exactly what you are doing) the following functions: <b>utf8 :: is_utf8</b> , <b>Encode :: _ utf8_on</b> , <b>Encode :: _ utf8_off</b> , and all the functions from the <b>bytes</b> module (the documentation for all these functions does not recommend their use, except as for debugging) <br><br>  2. Use <b>utf8 :: upgrade</b> , <b>utf8 :: downgrade</b> , whenever required by the Perl specification <br><br>  3. To convert from characters to bytes, use <b>Encode :: encode</b> , <b>Encode :: decode</b> <br><br>  3. If you use someone else's code that violates these rules, check it for the presence of bugs, use workarounds. <br><br>  4. When working with file names, you either have to use a wrapper on all functions, or, using tests, make sure that the internal representation of the file names does not change during the operation of the code. <br><br>  There are several examples when violation of these rules seemed to me justified. <br><br><pre> <code class="perl hljs">Encode::_utf8_off($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> utf8::is_utf8($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; (bytes::<span class="hljs-keyword"><span class="hljs-keyword">length</span></span>($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]));</code> </pre><br>  (clears the UTF-8 flag for ASCII-7bit text (thus achieving a 30% increase in performance of regexps, in all Perl, except 5.19) <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; utf8::is_utf8($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; (bytes::<span class="hljs-keyword"><span class="hljs-keyword">length</span></span>($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]) != <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>($_[<span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre><br>  (Returns TRUE if the string has the UTF-8 flag set, nor is it ASCII-7bit. Can be used in unit tests to ensure that your 400 megabytes of binary data is not turning into 700) <br><br>  There is another option to do nothing.  Honestly, it will take quite a long time before you stumble upon any bug (but by that time it will be too late).  This option is not recommended for library developers. </div><p>Source: <a href="https://habr.com/ru/post/190584/">https://habr.com/ru/post/190584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190564/index.html">Support for Advanced Format - optimal work with high-capacity disks</a></li>
<li><a href="../190566/index.html">HHVM: testing performance and compatibility with Joomla, Bitrix and Wordpress</a></li>
<li><a href="../190572/index.html">The process of developing and rolling out releases in Badoo. Automatic testing. Developer Environment</a></li>
<li><a href="../190580/index.html">Studio Trailers returned to Habr</a></li>
<li><a href="../190582/index.html">Moscow, September 12, Windows Camp - come, it will be interesting!</a></li>
<li><a href="../190592/index.html">Dell Latitude 10: Tablet or PC?</a></li>
<li><a href="../190594/index.html">The State Duma agreed to consider a petition against the anti-piracy law</a></li>
<li><a href="../190596/index.html">Notch stops developing 0x10c</a></li>
<li><a href="../190598/index.html">Switch from Flex to Android</a></li>
<li><a href="../190600/index.html">Ilya Massukh‚Äôs reply (FID, ROI) to an open letter on the petition to cancel 187-–§–ó</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>