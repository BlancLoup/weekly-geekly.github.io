<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Floyd-Worshel Algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Floyd-Worshell algorithm ‚Äî an algorithm for finding the shortest distances between all vertices of a weighted graph without cycles with negative weigh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Floyd-Worshel Algorithm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/768334b5/35e872fb/a0dc9ba4/21345db5.png" align="left">  Floyd-Worshell algorithm ‚Äî an algorithm for finding the shortest distances between all vertices of a weighted <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">graph</a> without cycles with negative weights using the dynamic programming method.  This is a basic algorithm, so that those who know it - you can not continue to read. <br><br>  This algorithm was simultaneously published in articles by Robert Floyd ( <a href="http://en.wikipedia.org/wiki/Robert_Floyd">Robert Floyd</a> ) and <a href="http://en.wikipedia.org/wiki/Stephen_Warshall">Stephen Warshall</a> ( <a href="http://en.wikipedia.org/wiki/Stephen_Warshall">Stephen Warshall</a> ) in 1962, although in 1959, Bernard Roy published almost the same algorithm, but it went unnoticed. <br><a name="habracut"></a><br><h2>  Remark </h2><br>  If the graph does not contain edges with negative weight, then to solve this problem, you can use <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra's algorithm</a> to find the shortest path from one vertex to all the others by running it on each vertex.  The running time of such an algorithm depends on the type of data that we will use for the Dijkstra algorithm, it can be either a simple priority queue, or a <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2583%25D1%2587%25D0%25B0">binary</a> or <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BD%25D0%25B0%25D1%2587%25D1%2587%25D0%25B8%25D0%25B5%25D0%25B2%25D0%25B0_%25D0%25BA%25D1%2583%25D1%2587%25D0%25B0">Fibonacci Heap</a> , respectively, the running time will vary from O (V <sup>3</sup> ) to O (V * E * log (V)), where V is the number of vertices, and E is edges.  ( <a href="http://ru.wikipedia.org/wiki/%25C2%25ABO%25C2%25BB_%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25BE%25D0%25B5_%25D0%25B8_%25C2%25ABo%25C2%25BB_%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B5">"About" -big</a> ). <br><br>  If there are edges with negative weight, you can use <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%25A4%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0">the Bellman-Ford algorithm</a> .  But this algorithm, launched on all vertices of the graph, is slower, its running time is O (V <sup>2</sup> * E), and in strongly ‚Äúthick‚Äù graphs it is O (V <sup>4</sup> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Dynamic programming </h2><br>  What does dynamic algorithm mean?  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Dynamic programming</a> is an alternative to solving problems ‚Äúon the forehead,‚Äù that is, brute forc or <a href="http://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B0%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">greedy algorithms</a> .  It is used where the optimal solution of a smaller subtask can be used to solve the original problem.  In general, the method looks like this: <br><br>  1. Splitting a task into smaller subtasks. <br>  2. Finding the optimal solution of subtasks recursively. <br>  3. Using the obtained solution of subtasks for constructing solutions to the original problem. <br><br>  To find the shortest paths between all vertices of the graph, not all possibilities are explored, which will lead to a large working time and require more memory, and the upward dynamic programming, that is, all the subtasks that will later be needed to solve the original problem are calculated in advance and then used. <br><br><h2>  Shortest path structure </h2><br>  The algorithm is based on two properties of the shortest path of the graph.  First: <br><br>  There is a shortest path p <sub>1k</sub> = (v <sub>1</sub> , v <sub>2</sub> , ..., v <sub>k</sub> ) from the vertex v <sub>1</sub> to the vertex v <sub>k</sub> , as well as its subpath p '(v <sub>i</sub> , v <sub>i + 1</sub> , ..., v <sub>j</sub> ), while valid 1 &lt;= i &lt;= j &lt;= k. <br><br><blockquote>  If p is the shortest path from v <sub>1</sub> to v <sub>k</sub> , then p 'is also the shortest path from the vertex v <sub>i</sub> to v <sub>j</sub> </blockquote><br>  This can be easily proved, since the cost of the path p is the sum of the cost of the path p 'and the cost of the rest of its parts.  So having imagined that there is a shorter way p ', we will reduce this amount, which will lead to a contradiction with the statement that this amount was already minimal. <br><br>  The second property is the basis of the algorithm.  We consider the graph G with the vertices {v <sub>1</sub> , v <sub>2</sub> , ..., v <sub>n</sub> } numbered from 1 to n and the path p <sub>ij</sub> from v <sub>i</sub> to v <sub>j</sub> passing through a certain set of allowed vertices bounded by the index k. <br><br>  That is, if k = 0, then we consider direct connections of the vertices with each other, since the set of allowed intermediate vertices is early zero.  If k = 1, we consider the paths passing through the vertex v <sub>1</sub> , with k = 2 - through the vertices {v <sub>1</sub> , v <sub>2</sub> }, with k = 3 - {v <sub>1</sub> , v <sub>3</sub> , v <sub>3</sub> } and so on. <br><br><img src="http://img100.imageshack.us/img100/3797/simpledirectedgraph.jpg" align="left">  For example, we have such a graph (on the left) and k = 1, that is, only the node ‚Äú1‚Äù is allowed as an intermediary node.  In this graph, when k = 1, there is no p <sub>43</sub> path, but there is when k = 2, then you can get from ‚Äú4‚Äù to ‚Äú3‚Äù through ‚Äú2‚Äù or through ‚Äú1‚Äù and ‚Äú2‚Äù. <br><br>  Consider the shortest path p <sub>ij</sub> with allowed intermediate vertices {1..k-1} of cost d <sub>ij</sub> .  Now we expand the set by the kth element, so that the set of allowed vertices becomes {1..k}.  With this expansion, there are 2 possible outcomes: <br><br>  <b>Case 1.</b> The element k is <b>not</b> included in the shortest path p <sub>ij</sub> , that is, we didn‚Äôt win or add anything by adding an additional vertex, so the cost of the shortest path d <sup>k</sup> <sub>ij</sub> did not change, respectively <br><br><blockquote>  <b>d <sup>k</sup> <sub>ij</sub> = d <sup>k-1</sup> <sub>ij</sub></b> - just take over the value before increasing k. </blockquote><br>  <b>Case 2.</b> The element k enters the shortest path p <sub>ij</sub> , that is, after adding a new vertex to the allowed ones, the shortest path has changed and now passes through the vertex v <sub>k</sub> .  How much will the new path get? <br><br>  The new shortest path is divided by the vertex v <sub>k</sub> into p <sub>ik</sub> and p <sub>kj</sub> ; we use the first property; according to it, p <sub>ik</sub> and p <sub>kj</sub> also shortest paths from v <sub>i</sub> to v <sub>k</sub> and v <sub>k</sub> to v <sub>j,</sub> respectively.  Means <br><br>  d <sup>k</sup> <sub>ij</sub> = d <sup>k</sup> <sub>ik</sub> + d <sup>k</sup> <sub>kj</sub> <br><br>  And since, in these paths, k is either the final or initial node, it is not included in the set of intermediate nodes, so it can be removed from it: <br><blockquote>  <b>d <sup>k</sup> <sub>ij</sub> = d <sup>k-1</sup> <sub>ik</sub> + d <sup>k-1</sup> <sub>kj</sub></b> </blockquote><br><h2>  Algorithm </h2><br>  Let's look at the value of d <sup>k</sup> <sub>ij</sub> in both cases - right!  it in both cases is made up of d values ‚Äã‚Äãfor k-1, and thus having initial (k = 0) values ‚Äã‚Äãfor d, we can calculate d for all subsequent values ‚Äã‚Äãof k.  And we know the values ‚Äã‚Äãof d for k = 0, this is the weight / cost of the edges of the graph, that is, compounds without intermediary nodes. <br><br>  For k = n (n is the number of vertices) we get the optimal values ‚Äã‚Äãof d for all pairs of vertices. <br><br>  When increasing from k-1 to k, what value will we store for d <sup>k</sup> <sub>ik</sub> ?  The minimum values ‚Äã‚Äãof cases 1 and 2, that is, we see whether the old path is cheaper or the path with the addition of an additional vertex. <br><br><img src="http://img231.imageshack.us/img231/4611/amsmathsource1.png"><br><br><h2>  Pseudocode </h2><br>  Finally the algorithm itself.  We use the representation of the graph as a <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0_%25D1%2581%25D0%25BC%25D0%25B5%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">matrix of adjacencies</a> . <br><br><img src="http://img833.imageshack.us/img833/3714/bild2s.png"><br><br>  As you can see, the algorithm is very simple - first, the shortest distance matrix D <sup>0</sup> is initialized, initially it coincides with the adjacency matrix, we increase the value of k in the cycle and recalculate the distance matrix, from D <sup>0</sup> we get D <sup>1</sup> , from D <sup>1</sup> to D <sup>2</sup> and so on to k = n. <br><br>  It is assumed that if there is no edge between two vertices, then a large number was written in the adjacency matrix (large enough to be longer than any path in this graph);  then this edge will always be unprofitable to take, and the algorithm will work correctly.  However, if you do not take special measures, then if there are negative weights in the graph of the edges, numbers like ‚àû-1, ‚àû-2, etc. may appear in the resulting matrix, which, of course, still means that between the corresponding there are no peaks at all.  Therefore, if there are negative edges in the graph, Floyd's algorithm is better written so that it does not perform transitions from those states in which there is already ‚Äúno way‚Äù <br><br><h2>  Example </h2><br><img src="http://img176.imageshack.us/img176/9117/bild3sc.png"><br><br>  The first matrix recalculation - one value changes, because of the expansion of the set of allowed vertices to the top ‚Äú1‚Äù we were able to get from the top ‚Äú4‚Äù to ‚Äú2‚Äù using a cheaper way. <br><br>  d <sup>k</sup> <sub>ij</sub> = min (d <sup>k-1</sup> <sub>ij</sub> ; d <sup>k-1</sup> <sub>ik</sub> + d <sup>k-1</sup> <sub>kj</sub> ) <br><br>  d <sup>1</sup> <sub>42</sub> = min (d <sup>0</sup> <sub>42</sub> , d <sup>0</sup> <sub>41</sub> + d <sup>0</sup> <sub>12</sub> ) <br><br>  d <sup>1</sup> <sub>42</sub> = min (4, -1) <br><br>  Second iteration, improved value for p <sub>43</sub> <br><br><img src="http://img407.imageshack.us/img407/7481/bild4e.png"><br><br>  Result <br><br><img src="http://img835.imageshack.us/img835/7391/bild5c.png"><br><br>  <a href="http://rain.ifmo.ru/cat/view.php/vis/graph-paths/floyd-warshall-2004">Here</a> and <a href="http://students.ceid.upatras.gr/~papagel/english/java_docs/allmin.htm">there</a> you can play with the applet and see how the algorithm works live. <br><br><h2>  Analysis of working time and memory usage </h2><br>  The algorithm requires O (n <sup>3</sup> ) memory to save matrices.  However, the number of matrices can be easily reduced to two, each time rewriting an unnecessary matrix or even switching to a two-dimensional matrix altogether, removing the index k y d <sup>k</sup> <sub>ij</sub> .  The best option that is most often used is to write directly into the adjacency matrix, then we don‚Äôt need additional memory at all, though if we immediately rewrite the original matrix, then we need to additionally show the correctness of the algorithm, since the classical academic proof is true only for the case when the previous iteration matrix does not change. <br><br>  As for the running time - three nested cycles from 1 to n - Œò (n <sup>3</sup> ). <br><br><h2>  The case of negative cycles </h2><br>  If the graph has negative weight cycles, then formally the Floyd-Worshell algorithm is inapplicable to such a graph.  But in fact, the algorithm will work correctly for all pairs, the paths of which never go through a cycle of negative cost, and for the rest we get some numbers, possibly very negative ones.  The algorithm can be taught to derive some value for such pairs, corresponding to -‚àû <br><br>  By the way, after working out such a graph on the diagonal of the shortest path matrix, negative numbers will appear - the shortest distance from the vertex in this cycle to itself will be less than zero, which corresponds to the passage through this cycle, so the algorithm can be used to determine the presence of negative cycles in the graph. <br><br><h2>  Path reconstruction </h2><br>  The distance matrix will show us the shortest (cheapest) distance for any pair of vertices, but how to find out the way?  It is very simple, when calculating d <sup>k</sup> <sub>ij</sub> it is also necessary to calculate œÄ <sup>k</sup> <sub>ij</sub> .  œÄ <sup>k</sup> <sub>ij</sub> in this case is the predecessor of the vertex v <sub>j</sub> on the path from v <sub>i</sub> with the set of allowed intermediate vertices {1..k}. <br><br>  I'll just leave it here, the rest can be thought out by everyone <br><br><img src="http://img534.imageshack.us/img534/4862/bild8l.png"><br><br><h2>  Application </h2><br><img src="http://img203.imageshack.us/img203/1023/handcutnewyorkcitymapby.jpg" align="left">  Like any basic algorithm, the Floyd-Worshell algorithm is used very widely and in many places, ranging from the search for the transitive closure of a graph to genetics and project management.  But the first thing that comes to mind is of course the transport and all other networks. <br><br>  Let's say if you take a map of the city - its transport system is a graph, respectively, assigning each edge a certain cost calculated from, say, bandwidth and other important parameters - you can take a companion along the shortest / fastest / cheapest way. <br><br><br><br><br><br>  <sub>Everything is written on it, it is written not so, so if you point out errors, inconsistencies, misunderstandings, etc., I will be grateful, I will need this text :)</sub> <sub><br><br></sub>  <sub>Thanks to <a href="http://habrahabr.ru/users/rustam/" class="user_link">Rustam</a> 'u and <a href="http://habrahabr.ru/users/mastersobg/" class="user_link">mastersobg</a> ' for amendments</sub> </div><p>Source: <a href="https://habr.com/ru/post/105825/">https://habr.com/ru/post/105825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../105816/index.html">New Calculate Linux 10.9</a></li>
<li><a href="../105817/index.html">Yandex oh th board ends, now I fall</a></li>
<li><a href="../105818/index.html">Canobuvosti, 60th edition</a></li>
<li><a href="../105819/index.html">Buying Adobe - Why?</a></li>
<li><a href="../105824/index.html">Acquaintance with Habrapipl</a></li>
<li><a href="../105826/index.html">How I saved the site apachedev.ru</a></li>
<li><a href="../105831/index.html">A conceptual approach to presenting information in online stores. Part 1</a></li>
<li><a href="../105832/index.html">Chromium 8 and V8 Update Javascript Benchmark Suite</a></li>
<li><a href="../105833/index.html">Flash application for iPad without any problems with screen size and pixelling</a></li>
<li><a href="../105834/index.html">If we are not able to produce, then we are not able and possessed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>