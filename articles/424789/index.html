<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to deploy a Ruby on Rails application with HAProxy Ingress, unicorn / puma, and web sockets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After several months of testing, we finally moved the Ruby on Rails application to production with the Kubernetes cluster. 


 In this article, I‚Äôll s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to deploy a Ruby on Rails application with HAProxy Ingress, unicorn / puma, and web sockets</h1><div class="post__text post__text-html js-mediator-article"><p>  After several months of testing, we finally moved the Ruby on Rails application to production with the Kubernetes cluster. </p><br><p>  <em>In this article, I‚Äôll show you how to configure Path-based routing for a Ruby on Rails application in Kubernetes with a HAProxy Ingress controller.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3fa/08e/fa4/3fa08efa4b7f76def073d9be03e73b62.jpg" alt="image"></p><a name="habracut"></a><br><p>  It is assumed that you are roughly aware of what it is <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">like</a> , <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">deployment</a> , <a href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a> , <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">configuration map</a> and <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> in <a href="https://kubernetes.io/">Kubernetes</a> </p><br><p>  Usually in a Rails application there are such services as unicorn / puma, sidekiq / delayed-job / resque, web sockets and some special API services.  We had one web service, open to the outside through the balancer, and everything worked fine.  But traffic grew, and you had to route it to a URL or Path. </p><br><p>  Kubernetes has no ready-made load balancing solution of this type.  The <a href="https://github.com/kubernetes-sigs/aws-alb-ingress-controller">alb-ingress-controller is</a> already being developed for it, but it is still not suitable for the alpha stage and for production. </p><br><p>  For Path-based routing, the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress controller</a> was best. </p><br><p>  We studied the question and found out that k8s has different solutions for Ingress. </p><br><ul><li>  <a href="https://github.com/kubernetes/ingress-nginx">nginx-ingress</a> </li><li>  <a href="https://github.com/kubernetes/ingress-gce">ingress-gce</a> </li><li>  <a href="https://github.com/jcmoraisjr/haproxy-ingress">Haproxy-ingress</a> </li><li>  <a href="https://docs.traefik.io/configuration/backends/kubernetes/">traefik</a> </li><li>  <a href="https://github.com/appscode/voyager">voyager</a> </li></ul><br><p>  We experimented with nginx-ingress and HAProxy and settled on HAProxy - it is better suited for Rails web sockets, which we used in the project. </p><br><p>  I'll tell you step by step how to tie the HAProxy Ingress to a Rails application. </p><br><h3 id="nastroyka-rails-prilozheniya-s-kontrollerom-haproxy-ingress">  Configuring Rails Applications with the HAProxy Ingress Controller </h3><br><p>  Here is what we will do: </p><br><ul><li>  Create a Rails application with different services and deployments. </li><li>  Create a TLS secret for SSL. </li><li>  Create a HAProxy Ingress configuration map. </li><li>  Create the HAProxy Ingress controller. </li><li>  Let's open access to Ingress through service of type LoadBalancer. </li><li>  Configure the DNS applications for the service Ingress. </li><li>  Create different Ingress rules for Path-based routing. </li><li>  Test path based routing. </li></ul><br><p>  Let's create a deployment manifest for Rails applications for different services ‚Äî web (unicorn), background tasks (sidekiq), web socket (ruby thin), API (dedicated unicorn). </p><br><p>  Here is our web application and service template. </p><br><pre><code class="hljs bash">--- apiVersion: v1 kind: Deployment metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: template: metadata: labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web spec: containers: - image: &lt;your-repo&gt;/&lt;your-image-name&gt;:latest name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production imagePullPolicy: Always env: - name: POSTGRES_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-postgres - name: REDIS_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-redis - name: APP_ENV value: production - name: APP_TYPE value: web - name: CLIENT value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ports: - containerPort: 80 imagePullSecrets: - name: registrykey --- apiVersion: v1 kind: Service metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web</code> </pre> <br><p>  Here is the background application template and service template. </p><br><pre> <code class="hljs bash">--- apiVersion: v1 kind: Deployment metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: template: metadata: labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background spec: containers: - image: &lt;your-repo&gt;/&lt;your-image-name&gt;:latest name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production imagePullPolicy: Always env: - name: POSTGRES_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-postgres - name: REDIS_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-redis - name: APP_ENV value: production - name: APP_TYPE value: background - name: CLIENT value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ports: - containerPort: 80 imagePullSecrets: - name: registrykey --- apiVersion: v1 kind: Service metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-background</code> </pre> <br><p>  Here is the application web socket and service template. </p><br><pre> <code class="hljs bash">--- apiVersion: v1 kind: Deployment metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: template: metadata: labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket spec: containers: - image: &lt;your-repo&gt;/&lt;your-image-name&gt;:latest name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production imagePullPolicy: Always env: - name: POSTGRES_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-postgres - name: REDIS_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-redis - name: APP_ENV value: production - name: APP_TYPE value: websocket - name: CLIENT value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ports: - containerPort: 80 imagePullSecrets: - name: registrykey --- apiVersion: v1 kind: Service metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket</code> </pre> <br><p>  Here is the application API and service information. </p><br><pre> <code class="hljs bash">--- `apiVersion: v1 kind: Deployment metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: template: metadata: labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api spec: containers: - image: &lt;your-repo&gt;/&lt;your-image-name&gt;:latest name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production imagePullPolicy: Always env: - name: POSTGRES_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-postgres - name: REDIS_HOST value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-redis - name: APP_ENV value: production - name: APP_TYPE value: api - name: CLIENT value: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ports: - containerPort: 80 imagePullSecrets: - name: registrykey --- apiVersion: v1 kind: Service metadata: name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api labels: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api</code> </pre> <br><p>  Let's run the manifest with the <code>kubectl apply</code> . </p><br><pre> <code class="hljs bash">$ kubectl apply -f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-web.yml -f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-background.yml -f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-websocket.yml -f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-api.yml deployment <span class="hljs-string"><span class="hljs-string">"test-production-web"</span></span> created service <span class="hljs-string"><span class="hljs-string">"test-production-web"</span></span> created deployment <span class="hljs-string"><span class="hljs-string">"test-production-background"</span></span> created service <span class="hljs-string"><span class="hljs-string">"test-production-background"</span></span> created deployment <span class="hljs-string"><span class="hljs-string">"test-production-websocket"</span></span> created service <span class="hljs-string"><span class="hljs-string">"test-production-websocket"</span></span> created deployment <span class="hljs-string"><span class="hljs-string">"test-production-api"</span></span> created service <span class="hljs-string"><span class="hljs-string">"test-production-api"</span></span> created</code> </pre> <br><p>  Once the application is deployed and launched, you will need to create a HAProxy Ingress.  But first, let's create a TLS secret with an SSL key and certificate. </p><br><p>  It will also allow HTTPS for the application URL and terminate it on L7. </p><br><p> <code>$ kubectl create secret tls tls-certificate --key server.key --cert server.pem</code> </p> <br><p>  <code>server.key</code> here is our SSL key, and <code>server.pem</code> is our SSL certificate in pem format. </p><br><p>  Now create the resources of the HAProxy controller. </p><br><h3 id="karta-konfiguracii-haproxy">  HAProxy configuration map </h3><br><p>  All available configuration options for HAProxy are <a href="https://github.com/jcmoraisjr/HAProxy-ingress">here</a> . </p><br><pre> <code class="hljs cs">apiVersion: v1 data: <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>-scaling: <span class="hljs-string"><span class="hljs-string">"true"</span></span> backend-server-slots-increment: <span class="hljs-string"><span class="hljs-string">"4"</span></span> kind: ConfigMap metadata: name: haproxy-configmap <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span>: <span class="hljs-title"><span class="hljs-title">test</span></span></code> </pre> <br><h3 id="razvertyvanie-kontrollera-haproxy-ingress">  Deploying the HAProxy Ingress Controller </h3><br><p>  Deployment pattern for the Ingress Controller with at least two replicas to manage sequential deployment. </p><br><pre> <code class="hljs delphi">apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: run: haproxy-ingress <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: haproxy-ingress namespace: test spec: replicas: <span class="hljs-number"><span class="hljs-number">2</span></span> selector: matchLabels: run: haproxy-ingress template: metadata: labels: run: haproxy-ingress spec: containers: - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: haproxy-ingress image: quay.io/jcmoraisjr/haproxy-ingress:v0.<span class="hljs-number"><span class="hljs-number">5</span></span>-beta.<span class="hljs-number"><span class="hljs-number">1</span></span> args: - --<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-backend-service=$(POD_NAMESPACE)/test-production-web - --<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-ssl-certificate=$(POD_NAMESPACE)/tls-certificate - --configmap=$(POD_NAMESPACE)/haproxy-configmap - --ingress-<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=haproxy ports: - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: http containerPort: <span class="hljs-number"><span class="hljs-number">80</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: https containerPort: <span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: stat containerPort: <span class="hljs-number"><span class="hljs-number">1936</span></span> env: - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: POD_NAME valueFrom: fieldRef: fieldPath: metadata.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace</code> </pre> <br><p>  In this manifesto, we are particularly interested in the arguments passed to the controller. <br>  <code>--default-backend-service</code> is the service that the application will use if no rules match the query. </p><br><p>  We have a <code>test-production-web</code> , but this could be a custom 404 page or something like that - you decide. </p><br><p>  <code>--default-ssl-certificate</code> is the SSL secret we just created.  It will terminate SSL on L7, and the application will be externally accessible via HTTPS. </p><br><h3 id="servis-haproxy-ingress">  HAProxy Ingress Service </h3><br><p>  This is a type of <code>LoadBalancer</code> service that allows client traffic to access our Ingress Controller. </p><br><p>  LoadBalancer has access to the public network and Kubernetes internal network, and on L7 it routes traffic for the Ingress controller. </p><br><pre> <code class="hljs pgsql">apiVersion: v1 kind: Service metadata: labels: run: haproxy-ingress <span class="hljs-type"><span class="hljs-type">name</span></span>: haproxy-ingress namespace: test spec: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: LoadBalancer ports: - <span class="hljs-type"><span class="hljs-type">name</span></span>: http port: <span class="hljs-number"><span class="hljs-number">80</span></span> protocol: TCP targetPort: <span class="hljs-number"><span class="hljs-number">80</span></span> - <span class="hljs-type"><span class="hljs-type">name</span></span>: https port: <span class="hljs-number"><span class="hljs-number">443</span></span> protocol: TCP targetPort: <span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-type"><span class="hljs-type">name</span></span>: stat port: <span class="hljs-number"><span class="hljs-number">1936</span></span> protocol: TCP targetPort: <span class="hljs-number"><span class="hljs-number">1936</span></span> selector: run: haproxy-ingress</code> </pre> <br><p>  Let's apply all the HAProxy manifests. </p><br><pre> <code class="hljs ruby">$ kubectl apply -f haproxy-configmap.yml -f haproxy-deployment.yml -f haproxy-service.yml configmap <span class="hljs-string"><span class="hljs-string">"haproxy-configmap"</span></span> created deployment <span class="hljs-string"><span class="hljs-string">"haproxy-ingress"</span></span> created service <span class="hljs-string"><span class="hljs-string">"haproxy-ingress"</span></span> created</code> </pre> <br><p>  When all resources are running, specify the LoadBalancer endpoint. </p><br><pre> <code class="hljs pgsql">$ kubectl -n test <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> svc haproxy-ingress -o wide <span class="hljs-type"><span class="hljs-type">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTER</span></span>-IP <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span>-IP PORT(S) AGE SELECTOR haproxy-ingress LoadBalancer <span class="hljs-number"><span class="hljs-number">100.67</span></span><span class="hljs-number"><span class="hljs-number">.194</span></span><span class="hljs-number"><span class="hljs-number">.186</span></span> a694abcdefghi11e8bc3b0af2eb5c5d8<span class="hljs-number"><span class="hljs-number">-806901662.</span></span>us-east<span class="hljs-number"><span class="hljs-number">-1.</span></span>elb.amazonaws.com <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">31788</span></span>/TCP,<span class="hljs-number"><span class="hljs-number">443</span></span>:<span class="hljs-number"><span class="hljs-number">32274</span></span>/TCP,<span class="hljs-number"><span class="hljs-number">1936</span></span>:<span class="hljs-number"><span class="hljs-number">32157</span></span>/TCP <span class="hljs-number"><span class="hljs-number">2</span></span>m run=ingress</code> </pre> <br><h3 id="sopostavlenie-dns-s-url-prilozheniya">  DNS mapping to application URL </h3><br><p>  Once we specify the ELB endpoint for the Ingress service, we need to match the DNS service and the request URL (for example, <code>test-rails-app.com</code> ). </p><br><h3 id="realizaciya-ingress">  Implementing Ingress </h3><br><p>  The most difficult thing behind is time to configure Ingress and rules based on the Path. </p><br><p>  We need the following rules. </p><br><p>  Requests to <i><a href="https://test-rails-app.com/">https://test-rails-app.com</a></i> will be processed by the <code>test-production-web</code> . </p><br><p>  Requests to <i><a href="https://test-rails-app.com/websocket">https://test-rails-app.com/websocket</a></i> will be processed by the <code>test-production-websocket</code> . </p><br><p>  Requests to <i><a href="https://test-rails-app.com/api">https://test-rails-app.com/api</a></i> will be processed by the <code>test-production-api</code> . </p><br><p>  Let's create an Ingress manifest with all these rules. </p><br><pre> <code class="hljs bash">--- apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress namespace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> spec: tls: - hosts: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-rails-app.com secretName: tls-certificate rules: - host: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-rails-app.com http: paths: - path: / backend: serviceName: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-web servicePort: 80 - path: /api backend: serviceName: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-api servicePort: 80 - path: /websocket backend: serviceName: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-production-websocket servicePort: 80</code> </pre> <br><p>  In case of configuration changes, we have <a href="https://github.com/jcmoraisjr/haproxy-ingress">annotations for Ingress resources</a> . </p><br><p>  As expected, by default our traffic to <code>/</code> routed to the <code>test-production-web</code> , <code>/api</code> to <code>test-production-api</code> , and <code>/websocket</code> to <code>test-production-websocket</code> . </p><br><p>  We needed Path-based routing and SSL termination on L7 at Kubernetes, and the implementation of Ingress solved this problem. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424789/">https://habr.com/ru/post/424789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424773/index.html">Biopharma and numerical modeling: Amgen's experience and practice</a></li>
<li><a href="../424777/index.html">Using Consul to scale stateful services</a></li>
<li><a href="../424779/index.html">Multi-page SPA on Python</a></li>
<li><a href="../424781/index.html">Learning and testing neural networks on PyTorch using Ignite</a></li>
<li><a href="../424787/index.html">Interview with Aaron Patterson, speaker of the RubyRussia 2018 conference</a></li>
<li><a href="../424791/index.html">Expansion of network capabilities of a programmable relay using WI-FI</a></li>
<li><a href="../424793/index.html">How to print an electric motor</a></li>
<li><a href="../424795/index.html">How big can a solar-powered drone be?</a></li>
<li><a href="../424799/index.html">Two-way analytics of partner iframe widget using Google Tag Manager</a></li>
<li><a href="../424801/index.html">Zeppelin OS - another step towards secure smart contracts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>