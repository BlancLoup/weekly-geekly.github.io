<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java 9 First Steps and the Jigsaw Project - Part Two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. 

 After some delay, publish the second part of the article on the project Jigsaw and Java 9, published in the blog Codecentric. The tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">ğŸ”</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">ğŸ“œ</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">â¬†ï¸</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">â¬‡ï¸</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java 9 First Steps and the Jigsaw Project - Part Two</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr. <br><br>  After some delay, publish the second part of the article on the project Jigsaw and Java 9, published in the blog Codecentric.  The translation of the first part is <a href="http://habrahabr.ru/company/piter/blog/271941/">here</a> . <br><a name="habracut"></a><br><br>  This is the second part of the article for those who want to learn more about the Jigsaw project.  In the <a href="http://habrahabr.ru/company/piter/blog/271941/">first part,</a> we briefly discussed what a module is and how the Java Runtime was modularized.  Then we looked at a simple example of compiling, packaging, and running a modular application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here we will try to answer the following questions: <br><br><ul><li>  Is it possible to introduce a restriction on which modules will be able to read the exported package? </li><li>  What to do with different versions of the same module present on the way to the modules? </li><li>  How does jigsaw interact with non-modular inherited code? </li><li>  How to build your own Java runtime image? </li></ul><br><br>  Let's take as an example the example from part 1 and continue to work with it.  The code is still here. <br><br>  <b>Granting read permission to specific modules.</b> <br><br>  In the <a href="http://habrahabr.ru/company/piter/blog/271941/">first part,</a> we talked about how Java accessibility is developing within the framework of Jigsaw.  One of the levels of accessibility that was mentioned, but not clarified as it should be, is: â€œpublic for some modules, those that read this moduleâ€.  So we can limit the range of modules that will be allowed to read our exported packages.  Suppose the developers of <code>de.codecentric.zipvalidator <br></code> <code>de.codecentric.zipvalidator <br></code>  hate developers <code>de.codecentric.nastymodule <br></code> <code>de.codecentric.nastymodule <br></code>  , therefore can change the <code>module-info.java <br></code> <code>module-info.java <br></code>  like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.zipvalidator{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.zipvalidator.api to de.codecentric.addresschecker; }</code> </pre><br><br>  Thus, only the <code>addresschecker <br></code> <code>addresschecker <br></code>  can access the <code>zipvalidator <br></code> API <code>zipvalidator <br></code>  .  This instruction is carried out at the packet level, so nothing prevents you from restricting access to some packages, while at the same time giving full access to others.  This practice is referred to as â€œ <b>qualified export</b> â€.  If the module is <code>de.codecentric.nastymodule <br></code> <code>de.codecentric.nastymodule <br></code>  will try to access any type from <code>de.codecentric.zipvalidator.api <br></code> <code>de.codecentric.zipvalidator.api <br></code>  , then a compilation error will occur: <br><pre> <code class="java hljs">./de.cc.nastymodule/de/cc/nastymodule/internal/AddressCheckerImpl.java:<span class="hljs-number"><span class="hljs-number">4</span></span>: error: ZipCodeValidatorFactory is not visible because <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> de.cc.zipvalidator.api is not visible</code> </pre><br><br>  Please note: the program does not swear on <code>module-info.java <br></code> <code>module-info.java <br></code>  since <code>zipvalidator <br></code> <code>zipvalidator <br></code>  in principle could export visible packages to <code>nastymodule <br></code> <code>nastymodule <br></code>  .  For example, qualified export can be applied when you want to modularize the internal structure of your application, but do not want to share exported internal module packages with clients. <br><br>  <b>Conflicts between module versions</b> <br><br>  It often happens that through transitive dependencies different versions of a library fall into the same application â€” that is, the same module can appear twice in the path to the modules.  Two scenarios immediately come to mind: <br><br><ul><li>  Modules are available at compile time in different directories or modular jars, but their name is still the same. </li><li>  Different versions of the same module are disparate. </li></ul><br><br>  Let's try to compile the application in the first scenario.  Copied <code>zipvalidator <br></code> <code>zipvalidator <br></code>  : <br><pre> <code class="java hljs">two-modules-multiple-versions â”œâ”€â”€ de.codecentric.addresschecker â”‚ â”œâ”€â”€ de â”‚ â”‚ â””â”€â”€ codecentric â”‚ â”‚ â””â”€â”€ addresschecker â”‚ â”‚ â”œâ”€â”€ api â”‚ â”‚ â”‚ â”œâ”€â”€ AddressChecker.java â”‚ â”‚ â”‚ â””â”€â”€ Run.java â”‚ â”‚ â””â”€â”€ internal â”‚ â”‚ â””â”€â”€ AddressCheckerImpl.java â”‚ â””â”€â”€ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java â”œâ”€â”€ de.codecentric.zipvalidator.v1 â”‚ â”œâ”€â”€ de â”‚ â”‚ â””â”€â”€ codecentric â”‚ â”‚ â””â”€â”€ zipvalidator â”‚ â”‚ â”œâ”€â”€ api â”‚ â”‚ â”‚ â”œâ”€â”€ ZipCodeValidator.java â”‚ â”‚ â”‚ â””â”€â”€ ZipCodeValidatorFactory.java â”‚ â”‚ â”œâ”€â”€ internal â”‚ â”‚ â”‚ â””â”€â”€ ZipCodeValidatorImpl.java â”‚ â”‚ â””â”€â”€ model â”‚ â””â”€â”€ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java â”œâ”€â”€ de.codecentric.zipvalidator.v2 â”‚ â”œâ”€â”€ de â”‚ â”‚ â””â”€â”€ codecentric â”‚ â”‚ â””â”€â”€ zipvalidator â”‚ â”‚ â”œâ”€â”€ api â”‚ â”‚ â”‚ â”œâ”€â”€ ZipCodeValidator.java â”‚ â”‚ â”‚ â””â”€â”€ ZipCodeValidatorFactory.java â”‚ â”‚ â”œâ”€â”€ internal â”‚ â”‚ â”‚ â””â”€â”€ ZipCodeValidatorImpl.java â”‚ â”‚ â””â”€â”€ model â”‚ â””â”€â”€ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java</code> </pre><br><br>  Duplicate modules are in different directories, but the module name remains unchanged.  How does jigsaw respond to this during compilation? <br><br><pre> <code class="java hljs">./de.codecentric.zipvalidator.v2/<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java:<span class="hljs-number"><span class="hljs-number">1</span></span>: error: duplicate <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>: de.codecentric.zipvalidator</code> </pre><br><br>  So, here we can not easily get off.  Jigsaw gives a compilation error when there are two modules of the same name on the module path. <br><br>  What about the second case?  The directory structure remains the same, but now both zipvalidators get different names ( <code>de.codecentric.zipvalidator.v{1|2} <br></code> <code>de.codecentric.zipvalidator.v{1|2} <br></code>  ), and the addresschecker reads both of these names. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.addresschecker{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.addresschecker.api; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> de.codecentric.zipvalidator.v1; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> de.codecentric.zipvalidator.v2; }</code> </pre><br><br>  Most likely, and here it will not be compiled?  Read two modules exporting the same packages?  It turns out to be compiled.  I myself was surprised: the compiler recognizes the situation, but is limited to such warnings: <br><br><pre> <code class="java hljs">./de.cc.zipvalidator.v1/de/codecentric/zipvalidator/api/ZipCodeValidator.java:<span class="hljs-number"><span class="hljs-number">1</span></span>: warning: <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> exists in another <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>: de.codecentric.zipvalidator.v2</code> </pre><br><br>  The developer will readily ignore such a warning and start the application.  But Jigsaw clearly doesnâ€™t like what he sees at runtime: <br><br><pre> <code class="java hljs">java.lang.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.ResolutionException: Modules de.codecentric.zipvalidator.v2 and de.codecentric.zipvalidator.v1 export <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> de.codecentric.zipvalidator.api to <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.addresschecker</code> </pre><br><br>  It seems to me incomprehensible, in my opinion, a compile-time error could be made more accurate.  I wondered in the <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2015-November/005244.html">mailing list</a> why this option was chosen, but at the time of writing this article I havenâ€™t received an answer. <br><br>  <b>Automatic modules and unnamed module</b> <br><br>  Until now, we have worked in a fully modularized environment.  But what to do in such highly probable cases when you have to deal with non-modular Jar files?  This is where <b>automatic modules</b> and a <b>nameless module</b> come into play. <br><br>  Let's start with <b>automatic modules</b> .  An automatic module is a jar file supplied in a modulepath.  After you write it there, you can answer the following three questions about this module: <br><br>  Q: What is his name? <br>  A: This is the name of the jar file.  If you put the guava.jar file in the module path, you will get the automatic guava module. <br><br>  This also means that you cannot use Jar directly from the Maven repository, since guava-18.0 is not a valid Java identifier. <br><br>  Q: What does it export? <br>  A: Automatic module exports all its packages.  So, all public types will be available to any module that reads an automatic module. <br><br>  Q: What does he require? <br>  A: The automatic module reads all (* all *) other available modules (including unnamed, more on this below).  It is important!  From the automatic module, you can access all exported types of any module.  This point is nowhere to indicate, it is implied. <br><br>  Consider an example.  We are starting to use com.google.common.base.Strings in zipvalidator.  To allow such access, we must define a read edge for the automatic Guava module: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> de.codecentric.zipvalidator{ <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> de.codecentric.zipvalidator.api; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> de.codecentric.zipvalidator.model; <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> guava; }</code> </pre><br><br>  To compile, you will need to specify the guava.jar file in the module path (it is located in the ../jars directory): <br><pre> <code class="java hljs">javac -d . -modulepath ../jars -modulesourcepath . $(find . -name <span class="hljs-string"><span class="hljs-string">"*.java"</span></span>)</code> </pre><br><br>  Everything compiles perfectly and runs. <br><br>  (By the way, it was not so easy to run this example. While working with the Jigsaw 86 build, I ran into some problems: the system cursed dependencies on the <code>jdk.management.resource <br></code> module <code>jdk.management.resource <br></code>  .  I asked about this in the ezine, the discussion is <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2015-November/005190.html">here</a> . <br><br>  I must say that in my decision I did not use the â€œearly accessâ€ build (early access build), but I collected the JDK myself.  When working with OSX Mavericks, there were still some problems, as described in the thread, I had to change the makefile, but in the end I fixed everything.  You may have to deal with other problems when working with the following releases). <br><br>  Now is the time to introduce you to the magic wand, which is indispensable when moving to Jigsaw.  This tool is called <code>jdeps <br></code> <code>jdeps <br></code>  .  It scans your unmodularized code and tells you about dependencies. <br><br>  Consider guava: <br><br>  jdeps -s ../jars/guava.jar <br>  We have the following conclusion: <br>  guava.jar -&gt; java.base <br>  guava.jar -&gt; java.logging <br>  guava.jar -&gt; not found <br><br>  This means that the automatic guava module requires <code>java.base <br></code> <code>java.base <br></code>  <code>java.logging <br></code> <code>java.logging <br></code>  and ... â€œnot foundâ€œ ?!  What?  If you remove the switch <code>-s <br></code> <code>-s <br></code>  then <code>jdeps <br></code> <code>jdeps <br></code>  goes from the level of modules and goes down a step to the level of packages (the list is a bit reduced, since there are quite a lot of packages from guava): <br><br><pre> <code class="java hljs"> com.google.common.xml (guava.jar) -&gt; com.google.common.escape guava.jar -&gt; java.lang -&gt; javax.annotation not found</code> </pre><br><br>  Here you can see that the <code>com.google.common.xml <br></code> package <code>com.google.common.xml <br></code>  depends on <code>com.google.common.escape <br></code> <code>com.google.common.escape <br></code>  which is located in the module itself, <code>java.lang <br></code> <code>java.lang <br></code>  which is well known and from the <code>javax.annotation <br></code> annotation <code>javax.annotation <br></code>  which is not found.  We conclude that we need a jar with JSR-305 types, because it contains <code>javax.annotation <br></code> <code>javax.annotation <br></code>  (By the way, I get along without them - in my examples I donâ€™t need any type of these packages, and neither the compiler nor the runtime object object). <br><br>  <b>Unnamed module</b> <br><br>  So, what is a nameless module?  Again, answer three questions: <br><br>  Q: What is his name? <br>  A: You guessed it, he has no name <br><br>  Q: What does it export? <br>  A: The unnamed module exports all its packages to any other module.  This does not mean that it can be read from any other module - it does not have a name and you cannot demand it!  Team requires unnamed;  will not work. <br><br>  Q: What does he require? <br>  A: The unnamed module reads <b>all</b> other available modules. <br><br>  So, if you cannot read a nameless module from any of your modules, then what is the point?  Our old friend helps answer this question - the path to the classes.  Any type read from the classpath (and not from the modulepath) is automatically placed in the unnamed module â€” or, in other words, any type in the unnamed module is loaded via the classpath.  Because the nameless module reads all other modules, we can access all exported types from any type loaded through the class path.  In Java 9, the use of the class path and module paths will be supported both separately and together, to ensure backward compatibility.  Consider a few examples. <br><br>  Suppose we have a neat zipvalidator module, but the addresschecker is still not modularized, it does not have <code>module-info.java <br></code> <code>module-info.java <br></code>  .  The structure of our source will be as follows: <br><br><pre> <code class="java hljs">one-<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-with-unnamed-ok/ â”œâ”€â”€ classpath â”‚ â””â”€â”€ de.codecentric.legacy.addresschecker â”‚ â””â”€â”€ de â”‚ â””â”€â”€ codecentric â”‚ â””â”€â”€ legacy â”‚ â””â”€â”€ addresschecker â”‚ â”œâ”€â”€ api â”‚ â”‚ â”œâ”€â”€ AddressChecker.java â”‚ â”‚ â””â”€â”€ Run.java â”‚ â””â”€â”€ internal â”‚ â””â”€â”€ AddressCheckerImpl.java â”œâ”€â”€ modulepath â”‚ â””â”€â”€ de.codecentric.zipvalidator â”‚ â”œâ”€â”€ de â”‚ â”‚ â””â”€â”€ codecentric â”‚ â”‚ â””â”€â”€ zipvalidator â”‚ â”‚ â”œâ”€â”€ api â”‚ â”‚ â”‚ â”œâ”€â”€ ZipCodeValidator.java â”‚ â”‚ â”‚ â””â”€â”€ ZipCodeValidatorFactory.java â”‚ â”‚ â””â”€â”€ internal â”‚ â”‚ â””â”€â”€ ZipCodeValidatorImpl.java â”‚ â””â”€â”€ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-info.java</code> </pre><br><br>  Now there is one classpath directory, which contains the legacy code tied to zipvalidator access, as well as the modulepath directory containing the zipvalidator module.  We can compile our modules as usual.  To compile the inherited code, we will need to provide information about the modular code.  Just write it in the class path: <br><pre> <code class="java hljs">javac -d classpath/de.codecentric.legacy.addresschecker -classpath modulepath/de.codecentric.zipvalidator/ $(find classpath -name <span class="hljs-string"><span class="hljs-string">"*.java"</span></span>)</code> </pre><br><br>  Everything works as usual. <br><br>  During the performance, two possibilities open up before us.  Namely: <br><ul><li>  Write module to classpath </li><li>  Mix classpath and modulepath </li></ul><br><br>  Choosing the first option, we, in fact, abandon the modular system.  All types that we write to the nameless module can now freely communicate with each other. <br><br><pre> <code class="java hljs">java -cp modulepath/de.cc.zipvalidator/:classpath/de.cc.legacy.addresschecker/ de.codecentric.legacy.addresschecker.api.Run <span class="hljs-number"><span class="hljs-number">76185</span></span></code> </pre><br><br>  works exactly like the java application you use today. <br><br>  On the other hand, mixed use of the module path and the class path works like this: <br><br><pre> <code class="java hljs">java -modulepath modulepath -addmods de.codecentric.zipvalidator -classpath classpath/de.codecentric.legacy.addresschecker/ de.codecentric.legacy.addresschecker.api.Run</code> </pre><br><br>  Use two switches at the same time: <code>-classpath <br></code> <code>-classpath <br></code>  and <code>-modulepath <br></code> <code>-modulepath <br></code>  .  Added <code>-addmods <br></code> switch <code>-addmods <br></code>  - when mixing the class path and the path to the modules, we cannot simply access any module in the modulepath directories, but should specifically indicate which of them should be available. <br><br>  This approach also works fine, but there is a snag here!  Remember, the answer to the question â€œwhat an unnamed module requiresâ€ is â€œall other modulesâ€.  If we use the zipvalidator module via modulepath, we can only work with its exported packages.  Everything else will result in an IllegalAccessError at runtime.  Therefore, in this case, you will have to follow the rules of the module system. <br><br>  <b>Creating Runtime Images with jlink</b> <br><br>  Enough examples with modules;  There is another new tool that deserves our attention. <code>jlink <br></code>  Is a Java 9 utility for creating your own JVM distributions.  The most interesting thing is that, thanks to the new modular architecture of the JDK, you can choose which modules you want to include in this distribution!  Consider an example.  If we want to create an image of the execution environment containing our addresschecker, then we give the command: <br><br><pre> <code class="java hljs">jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/ --addmods de.codecentric.addresschecker --output linkedjdk</code> </pre><br>  We specify only three things: <br><br><ul><li>  Path to modules (including our special modules and the path to the jmods directory in your JDK - here are the standard java modules) </li><li>  The modules you want to include in your distribution </li><li>  Output directory </li></ul><br><br>  The team creates the following structure: <br><br>  linkedjdk / <br>  Binâ”€â”€ bin <br>  â”‚ â”œâ”€â”€ java <br>  â”‚ â””â”€â”€ keytool <br>  Confâ”€â”€ conf <br>  â”‚ â”œâ”€â”€ net.properties <br>  â”‚ â””â”€â”€ security <br>  â”‚ â”œâ”€â”€ java.policy <br>  â”‚ â””â”€â”€ java.security <br>  Libâ”€â”€ lib <br>  Classâ”€â”€ classlist <br>  Jâ”€â”€ jli <br><pre> <code class="java hljs"> â”‚ â””â”€â”€ libjli.dylib â”œâ”€â”€ jspawnhelper â”œâ”€â”€ jvm.cfg â”œâ”€â”€ libjava.dylib â”œâ”€â”€ libjimage.dylib â”œâ”€â”€ libjsig.diz â”œâ”€â”€ libjsig.dylib â”œâ”€â”€ libnet.dylib â”œâ”€â”€ libnio.dylib â”œâ”€â”€ libosxsecurity.dylib â”œâ”€â”€ libverify.dylib â”œâ”€â”€ libzip.dylib â”œâ”€â”€ modules â”‚ â””â”€â”€ bootmodules.jimage â”œâ”€â”€ security â”‚ â”œâ”€â”€ US_export_policy.jar â”‚ â”œâ”€â”€ blacklisted.certs â”‚ â”œâ”€â”€ cacerts â”‚ â””â”€â”€ local_policy.jar â”œâ”€â”€ server â”‚ â”œâ”€â”€ Xusage.txt â”‚ â”œâ”€â”€ libjsig.diz â”‚ â”œâ”€â”€ libjsig.dylib â”‚ â”œâ”€â”€ libjvm.diz â”‚ â””â”€â”€ libjvm.dylib â””â”€â”€ tzdb.dat</code> </pre><br><br>  That's all.  In OSX Mavericks, all this takes about 47 MB.  We can also enable archiving and delete some debugging features that we still will not need in production.  The most compact distribution that I managed to create turned out with the help of this command: <br><br><pre> <code class="java hljs">jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/bin --addmods de.codecentric.addresschecker --output linkedjdk --exclude-files *.diz --compress-resources on --strip-java-debug on --compress-resources-level <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  The size of the distribution is reduced to about 18 MB, in my opinion - just great.  In Linux, you can probably shrink down to 13. <br><br>  When calling <br><br><pre> <code class="java hljs">/bin/java --listmods</code> </pre><br><br>  Displays a list of modules contained in this distribution <br><br><pre> <code class="java hljs">de.codecentric.addresschecker de.codecentric.zipvalidator java.base@<span class="hljs-number"><span class="hljs-number">9.0</span></span></code> </pre><br><br>  So, all applications depending on the maximum number of these modules can run on this JVM.  But I was not able to get our main class to run this script.  For this, I went the other way. <br><br>  The attentive reader may have noticed that the second call is being made to jlink, and the path to the modules there is different from the first call.  In the second case, we specify the path to the bin directory.  This directory contains modular jar files, and the jar for addresschecker also contains in its manifest information about the main class.  The jlink utility uses this information to add additional information to the bin directory of our JVM: <br><br><pre> <code class="java hljs">linkedjdk/ â”œâ”€â”€ bin â”‚ â”œâ”€â”€ de.codecentric.addresschecker â”‚ â”œâ”€â”€ java â”‚ â””â”€â”€ keytool ...</code> </pre><br><br>  So now we can call our application directly.  Beauty! <br><br><pre> <code class="java hljs">./linkedjdk/bin/de.codecentric.addresschecker <span class="hljs-number"><span class="hljs-number">76185</span></span></code> </pre><br><br>  displays <br><br> <code>76185 is a valid zip code <br></code> <br><br>  <b>Conclusion</b> <br><br>  This is the end of our encounter with Jigsaw.  We looked at a number of examples that illustrate what can and cannot be done using Jigsaw and Java 9. Jigsaw introduces fundamental changes that cannot be so easily compensated for using lambda expressions or resources <code>try-with <br></code> <code>try-with <br></code>  .  Our entire toolchain from build tools like Maven or Gradle to IDE will have to be adapted to the modular system.  At the JavaOne conference, Hans Docter from Gradle Inc.  I read a report on how to start writing modular code, even in Java 8 and below.  Gradle performs a check at compile time and fails if the integrity of the module is compromised.  This (experimental) feature was included in the latest release of <a href="https://docs.gradle.org/current/release-notes">Gradle 2.9</a> .  Interesting times are definitely waiting for us! <br><br>  For a more detailed introduction to the Jigsaw, I once again recommend the <a href="http://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a> home page, especially the <a href="http://openjdk.java.net/projects/jigsaw/j1/">slides and videos</a> of Jigsaw reports from the latest JavaOne conference. </div><p>Source: <a href="https://habr.com/ru/post/272861/">https://habr.com/ru/post/272861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272847/index.html">The shortest, most useful and useless ways to transfer information</a></li>
<li><a href="../272851/index.html">Avast Antivirus detects critical vulnerabilities</a></li>
<li><a href="../272853/index.html">Simple Blender. Part 3</a></li>
<li><a href="../272855/index.html">Security Week 50: DDoS root DNS servers, APT Sofacy life, lots of cryptography</a></li>
<li><a href="../272857/index.html">The world's worst captcha for a multimillion-dollar site.</a></li>
<li><a href="../272863/index.html">What happened to hook_menu in Drupal 8?</a></li>
<li><a href="../272865/index.html">We are replacing the Bing search engine with the necessary one in Skype</a></li>
<li><a href="../272867/index.html">Organization of a hybrid port on the Alcatel-Lucent 7210 SAS-M</a></li>
<li><a href="../272869/index.html">About how I spent a week in Bareos</a></li>
<li><a href="../272871/index.html">Haskell for VK, Javascript and ReactJS, Or Alien vs. The Simpsons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>