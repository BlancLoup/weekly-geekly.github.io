<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quake source code analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was delighted to study the Quake World source code and set out in the article everything I understood. I hope this will help those who wish to under...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quake source code analysis</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d32/0d6/ffa/d320d6ffa37f59fd21361a0ae1a0aaab.jpg" alt="image"><br><br>  I was delighted to study <a href="https://github.com/id-Software">the Quake World source code</a> and set out in the article everything I understood.  I hope this will help those who wish to understand.  This article is divided into four parts: <br><br><ul><li>  Architecture </li><li>  Network </li><li>  Forecasting </li><li>  Visualization </li></ul><a name="habracut"></a><br><h2>  Architecture </h2><br><h3>  Quake Client </h3><br>  Quake learning should start with the <code>qwcl</code> project (client).  <code>WinMain</code> entry <code>WinMain</code> is in <b>sys_win.c</b> .  In short, the code looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"> WinMain { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { newtime = Sys_DoubleTime (); time = newtime - oldtime; Host_Frame (time) { setjmp Sys_SendKeyEvents IN_Commands Cbuf_Execute <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> CL_ReadPackets CL_SendCmd <span class="hljs-comment"><span class="hljs-comment">/* // */</span></span> CL_SetUpPlayerPrediction(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-function"><span class="hljs-function">CL_PredictMove </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CL_SetUpPlayerPrediction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> CL_EmitEntities </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-function"> SCR_UpdateScreen } oldtime </span></span>= newtime; } }</code> </pre><br>  Here we can distinguish three main elements of Quake World: <br><br><ul><li>  <code>CL_ReadPackets</code> and <code>CL_SendCmd</code> </li><li>  <code>CL_SetUpPlayerPrediction</code> , <code>CL_PredictMove</code> and <code>CL_EmitEntities</code> </li><li>  <code>SCR_UpdateScreen</code> <b>visualization</b> </li></ul><br>  <b>The network</b> layer (also called the Net Channel) outputs world information to the <code>frames</code> variable ( <code>frame_t</code> array).  They are transmitted to the <b>prediction</b> layer, in which collisions are processed, and the data is output in the form of visibility indications ( <code>cl_visedicts</code> ) with a scope definition (POV).  VisEdicts are used in the render layer along with the POV ( <code>cl.sim*</code> ) variables for rendering the scene. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f2/50d/d17/5f250dd17a4e712b362d566885b9b94b.jpg"><br><br>  <code>setjmp</code> : <br><br>  Setting an intermediate code point, if something bad happens, the program returns here. <br><br>  <code>Sys_SendKeyEvents</code> : <br><br>  Receiving Windows messages, minimizing windows, etc.  The corresponding update of the engine variable (for example, if the window is minimized, then the world is not rendered). <br><br>  <code>IN_Commands</code> : <br><br>  Getting information about the input from the joystick. <br><br>  <code>Cbuf_Execute</code> : <br><br>  In each game cycle, commands are executed in the buffer.  Commands are generated mainly through the console, but they can come from the server or even by pressing a key. <br><br>  The game starts with <code>exec quake.rc</code> in the command buffer. <br><br>  <code>CL_ReadPackets</code> and <code>CL_SendCmd</code> : <br><br>  Processing the <b>network</b> part of the engine. <br><br>  <code>CL_SendCmd</code> intercepts mouse and keyboard input, generates a command, which is then sent. <br><br>  Since Quake World used UDP, transmission reliability was guaranteed by the sequence / sequenceACK set in the netChannel packet headers.  In addition, the last team was systematically sent again.  On the client side, there were no restrictions on packet transmission, updates were sent as often as possible.  From the server side, the message was sent to the client only if the packet was received and the sending speed was lower than the processing speed.  This limit was set by the client and sent to the server. <br><br>  The whole section "Network" is devoted to this topic. <br><br>  <code>CL_SetUpPlayerPrediction</code> , <code>CL_PredictMove</code> and <code>CL_EmitEntities</code> : <br><br>  Performed <b>prediction</b> in the engine and the calculation of collisions.  They are mainly designed to combat network latency. <br><br>  This topic is devoted to the entire section "Prediction". <br><br>  <code>SCR_UpdateScreen</code> : <br><br>  <b>Visualization</b> in the engine.  In this part BSP / PVS are actively used.  Here is the branching of code based on <code>include</code> / <code>define</code> .  The Quake engine can render the world either programmatically or with hardware acceleration. <br><br>  The Visualization section is entirely devoted to this. <br><br><h3>  Opening zip and compiling </h3><br>  <u>Opening zip:</u> <br><br>  The q1sources.zip archive has two folders / two Visual Studio projects: <code>QW</code> and <code>WinQuake</code> . <br><br><ul><li>  <code>WinQuake</code> is a code with a combined client and server code that works as a single process (ideally it should be two separate processes if DOS supported them).  Network play was only possible on the LAN. </li><li>  <code>QW</code> is the ‚ÄúQuake World‚Äù project, in which the server and client must run on separate machines (note that the client <code>WinMain</code> is <code>WinMain</code> (in <code>sys_win.c</code> ), and the server entry point is <code>main</code> (also in <code>sys_win.c</code> )) . </li></ul><br>  I learned Quake World with openGL rendering.  There are four subprojects in this project: <br><br><ul><li>  <code>gas2asm</code> - utility for porting assembly code from GNU ASM to x86 ASM </li><li>  <code>qwcl</code> - Quake client </li><li>  <code>QWFwd</code> - proxy located in front of Quake servers </li><li>  <code>qwsv</code> - Quake server side </li></ul><br>  <u>Compilation:</u> <br><br>  After installing Windows and the DirectX SDK, compilation in Visual Studio 2008 reveals one error: <br><br><pre> <code class="cpp hljs">.\net_wins.c(<span class="hljs-number"><span class="hljs-number">178</span></span>) : error C2072: <span class="hljs-string"><span class="hljs-string">'_errno'</span></span> : initialization of a function</code> </pre> <br>  Currently <code>_errno</code> is a Microsoft macro used for something else.  You can correct these errors by replacing the variable name with <code>_errno</code> for example with <code>qerrno</code> . <br><br> <code>net_wins.c</code> <br> <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qerrno = WSAGetLastError(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qerrno == WSAEWOULDBLOCK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qerrno == WSAEMSGSIZE) { Con_Printf (<span class="hljs-string"><span class="hljs-string">"Warning: Oversize packet from %s\n"</span></span>, NET_AdrToString (net_from)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Sys_Error (<span class="hljs-string"><span class="hljs-string">"NET_GetPacket: %s"</span></span>, strerror(qerrno)); }</code> </pre> <br>  Linker complains about LIBC.lib in the qwcl project.  Just add it to the list of ignored libraries "Ignored Library" and the assembly of four projects will be executed. <br><br><h3>  Instruments </h3><br>  As an IDE, Visual Studio Express (free) came up perfectly.  I recommend reading several books if you want to understand the engine more deeply on the basis of BSP / PVS, Id Software and Quake: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c31/8db/c0f/c318dbc0f45560dd97b0041a05d625c7.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/bca/c54/a3c/bcac54a3c179a4f59fb22ffa0c671706.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/5af/fae/7ec5affaec3e1410f66dae38f9d5a42c.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/40d/6b4/613/40d6b461398911ee769abd88b7796ea3.jpg"><br><br>  My bookshelf for Quake's source code week looked like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/444/167/66c444167f3dcd6e33bd2f1ecc17c68b.jpg"><br><br><h2>  Network </h2><br>  The network architecture of QuakeWorld at one time was considered a terrific innovation.  All subsequent online games used the same approach. <br><br><h3>  Network stack </h3><br>  The basic unit of information exchange in Quake was the <code></code> .  They are used to update the position, orientation, health, damage to the player, etc.  TCP / IP has many excellent features that would be useful in real-time simulation (transmission control, delivery reliability, packet order retention), but this protocol could not be used in the Quake World engine (it was used in the original Quake).  In first person shooters, information that is not received on time is not worth resending.  Therefore, UDP / IP was selected.  To ensure the reliability of the delivery and preserve the order of the packages, a network layer abstraction " <code>NetChannel</code> " was created. <br><br>  From the point of view of OSI, <code>NetChannel</code> conveniently located over UDP: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0c/e02/0a5/e0ce020a56a377506c7293ad2013e818.jpg"><br><br>  So, to summarize: the engine mainly works with <code></code> .  When it needs to send or receive data, it assigns this task to the <code>Netchan_Transmit</code> and <code>Netchan_Process</code> from <code>netchan.c</code> (these methods are the same for the client and server). <br><br><h3>  NetChannel Header </h3><br>  The NetChannel header has the following structure: <br><table><tbody><tr><th>  Bit offset </th><th>  Bits 0-15 </th><th>  16-31 </th></tr><tr><td>  0 </td><td colspan="2">  Sequence </td></tr><tr><td>  32 </td><td colspan="2">  ACK Sequence </td></tr><tr><td>  64 </td><td>  QPort </td><td>  Teams </td></tr><tr><td>  94 </td><td colspan="2">  ... </td></tr></tbody></table><ul><li>  Sequence is an <code>int</code> number initialized by the sender and increasing by one each time a packet is sent.  <code>Sequence</code> used for many purposes, but the most important task is to provide the receiver with the ability to recognize lost / duplicate / extra UDP packets.  The most significant bit of this integer is not part of the sequence, but a flag indicating whether (the <code></code> ) contains <u>reliable data</u> (more on this later). </li><li>  The ACK Sequence is also an <code>int</code> , it is equal to the last received number of the sequence.  Thanks to him, the other side of NetChannel can understand that the package has been lost. </li><li>  QPort is a bypass of the error of the NAT routers (see details at the end of the section).  Its value is a random number set when the client starts. </li><li>  Commands: transmitted meaningful data. </li></ul><br><h3>  Reliable messages </h3><br>  Unreliable commands are grouped into a UDP packet, it is marked with the last outgoing number of the sequence and sent: it does not matter to the sender whether he will be lost.  Reliable commands are handled differently.  The main thing is to understand that there can be only one unconfirmed reliable UDP packet between the sender and the receiver. <br><br>  In each game cycle, when a new reliable team is generated, it is added to the <code>message_buf</code> array (controlled by the <code>message</code> variable) ( <b>1</b> ).  The set of reliable commands is then moved from the <code>message</code> to the <code>reliable_buf</code> ( <b>2</b> ) array.  This only happens if the <code>reliable_buf</code> empty (if it is not empty, it means that another set of commands has been previously sent and its receipt has not yet been confirmed). <br><br>  Then the final UDP packet is formed: a NetChannel ( <b>3</b> ) header is added, then the contents of <code>reliable_buf</code> and the current unreliable commands (if there is enough space). <br><br>  On the receiving side, the UDP message is parsed, the incoming <code>sequence</code> number is transmitted to the outgoing <code>sequence ACK</code> ( <b>4</b> ) (along with a bit flag indicating that the packet contains reliable data). <br><br>  With the following message received: <br><br><ul><li>  If the reliability bit flag is true, it means that the UDP packet is delivered to the receiver.  NetChannel can clear <code>reliable_buf</code> ( <b>5</b> ) and is ready to send a new set of commands. </li><li>  If the reliability bit flag is false, then the UDP packet has not reached the receiver.  NetChannel is retrying sending content <code>reliable_buf</code> .  New commands are accumulated in <code>message_buf</code> .  If the array is full, the client is reset. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/d33/a64/2f4d33a643635a384c8ea3775d9c7c95.jpg"><br><br><h3>  Transmission control </h3><br>  As I understand it, transfer control is performed only on the server side.  The client sends its status updates as often as possible. <br><br>  The first transfer control rule that is active only on the server: send the packet only if the packet was received from the client.  The second type of transfer control is ‚Äúchoke‚Äù, the parameter that the client sets with the console command <code>rate</code> .  It allows the server to skip update messages, reducing the amount of data sent to the client. <br><br><h3>  Important commands </h3><br>  Commands contain a type code stored in a <code></code> followed by useful information from the command.  Perhaps the most important are commands giving information about the state of the game ( <code>frame_t</code> ): <br><br><ul><li>  <code>svc_packetentities</code> and <code>svc_deltapacketentities</code> : update such objects as rocket tracks, explosions, particles, etc. </li><li>  <code>svc_playerinfo</code> : sends updates about the player‚Äôs position, last team, and team duration in milliseconds. </li></ul><br><h3>  Read more about qport </h3><br>  Qport has been added to the NetChannel header to fix the error.  Prior to qport, Quake server identified the client by the combination of ‚Äúremote IP address, remote UDP port‚Äù.  Most of the time this worked well, but some NAT routers can arbitrarily change their port translation pattern (remote UDP port).  The UDP port becomes unreliable, and John Carmack (John Carmack) explained that he decided to identify the client by ‚Äúremote IP address, Qport in the NetChannel header‚Äù.  This fixed the error and allowed the server to change the target UDP response port on the fly. <br><br><h3>  Latency calculation </h3><br>  The Quake engine stores the 64 most recently sent commands (in the <code>frame_t</code> : <code>frames</code> array) along with <code>senttime</code> .  They can be accessed directly by the number of the sequence used to transfer them ( <code>outgoing_sequence</code> ). <br><br><pre> <code class="cpp hljs"> frame = &amp;cl.frames[cls.netchan.outgoing_sequence &amp; UPDATE_MASK]; frame-&gt;senttime = realtime; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br>  After receiving confirmation from the server, the time to send the command is obtained from <code>sequenceACK</code> .  Latency is calculated as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    frame = &amp;cl.frames[cls.netchan.incoming_acknowledged &amp; UPDATE_MASK]; frame-&gt;receivedtime = realtime; latency = frame-&gt;receivedtime - frame-&gt;senttime;</span></span></code> </pre> <br><h3>  Elegant solutions </h3><br>  <u>Array index cycling</u> <br>  The network part of the engine stores the 64 most recently received UDP packets.  A naive solution to looping through an array would be to use the integer division remainder operator: <br><br><pre> <code class="cpp hljs">arrayIndex = (oldArrayIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">64</span></span>;</code> </pre> <br>  Instead, a new value is computed with the binary AND operation for UPDATE_MASK.  UPDATE_MASK is 64-1. <br><br><pre> <code class="cpp hljs">arrayIndex = (oldArrayIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; UPDATE_MASK;</code> </pre> <br>  This code looks like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">frame_t</span></span> *newpacket; newpacket = &amp;frames[cls.netchan.incoming_sequence&amp;UPDATE_MASK];</code> </pre> <br>  <b><u>Update: here is a comment received from Dietrich Epp regarding optimization of division operations with the remainder:</u></b> <br><br><pre> <code class="cpp hljs">    ,        <span class="hljs-string"><span class="hljs-string">""</span></span>.          :   file.c: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modulo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % <span class="hljs-number"><span class="hljs-number">64</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &amp; <span class="hljs-number"><span class="hljs-number">63</span></span>; }  gcc -S file.c      file.s. ,    ,    !     <span class="hljs-string"><span class="hljs-string">""</span></span>    &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>  *<span class="hljs-number"><span class="hljs-number">32.</span></span>      ,    ,   ,     &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>  &amp; <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>,    *<span class="hljs-number"><span class="hljs-number">32</span></span>  %<span class="hljs-number"><span class="hljs-number">64</span></span>  . --Dietrich .globl modulo .type modulo, @function modulo: pushl %ebp movl %esp, %ebp movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %eax andl $<span class="hljs-number"><span class="hljs-number">63</span></span>, %eax popl %ebp ret .size modulo, .-modulo .globl <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> .type <span class="hljs-keyword"><span class="hljs-keyword">and</span></span>, @function <span class="hljs-keyword"><span class="hljs-keyword">and</span></span>: pushl %ebp movl %esp, %ebp movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %eax andl $<span class="hljs-number"><span class="hljs-number">63</span></span>, %eax popl %ebp ret .size <span class="hljs-keyword"><span class="hljs-keyword">and</span></span>, .-<span class="hljs-keyword"><span class="hljs-keyword">and</span></span></code> </pre> <br><h2>  Forecasting </h2><br>  We looked at the NetChannel abstraction for network data exchange.  Now we will find out how latency is compensated by prediction.  Here is the study material: <br><br><ul><li>  <a href="http://fabiensanglard.net/quakeSource/johnc-log.aug.htm">Article by</a> John Carmack himself. </li><li>  Another <a href="http://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization">article</a> ( <a href="">archive</a> ) from Valve about Half-life engine description (Half-life uses Quake engine). </li></ul><br><h3>  Forecasting </h3><br>  Forecasting is probably the hardest, least documented and essential part of the Quake World engine.  The purpose of forecasting is to defeat the latency, namely, to compensate for the delay necessary for the medium to transmit information.  Forecasting is performed on the client side.  This process is called ‚ÄúClient Side Prediction‚Äù.  On the server side, lag compensation techniques are not applied. <br><br>  Problem: <br><br><img src="http://fabiensanglard.net/quakeSource/prediction.jpg"><br><br>  As you can see, the state of the game is ‚Äúolder‚Äù by half the amount of latency.  If we add time to send the command, we need to wait for the full cycle (latency) to see the results of our actions: <br><br><img src="http://fabiensanglard.net/quakeSource/prediction2.jpg"><br><br>  To understand the Quake prediction system, you need to understand how NetChannel fills the <code>frames</code> variable ( <code>frame_t</code> array). <br><br><img src="http://fabiensanglard.net/quakeSource/frameQuestion.jpg"><br><br>  Each command sent to the server is saved in <code>frames</code> along with the <code>senttime</code> index <code>netchannel.outgoingsequence</code> . <br><br>  When the server confirms the receipt of a command using <code>sequenceACK</code> , you can accept the sent command and calculate the latency: <br><br><pre> <code class="cpp hljs">latency = senttime-receivedtime;</code> </pre> <br>  At this stage, we know the world as it was <u>latency / 2</u> back.  In NAT, latency is quite low (&lt;50 ms), but on the Internet it is huge (&gt; 200ms), and it is necessary to perform prediction to simulate the <u>current</u> state of the world.  This process is performed differently for the local player and other players. <br><br><h3>  Local player </h3><br>  For a local player, latency is reduced to almost 0 due to the extrapolation of what will be the state of the server.  This is done using the last status received from the server and the ‚Äúplay‚Äù of all commands sent since that moment. <br><br><img src="http://fabiensanglard.net/quakeSource/prediction3.jpg"><br><br>  Therefore, the client predicts what his position on the server will be at t + latency / 2. <br><br>  From a code point of view, this is done using the <code>CL_PredictMove</code> method.  First, the Quake engine selects the sentime limit for the ‚Äúplayable‚Äù commands: <br><br><pre> <code class="cpp hljs">cl.time = realtime - cls.latency - cl_pushlatency.value*<span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br>  <b>Note:</b> <code>cl_pushlatency</code> is a console variable (cvar) whose value is set on the client side.  It is equal to the negative client latency in milliseconds.  From this it is easy to conclude that: <code>cl.time = realtime</code> . <br><br>  Then all other players are defined in <code>CL_SetSolidPlayers (cl.playernum);</code>  how hard objects (so that you can test collisions) and ‚Äúplay‚Äù commands sent from the last received state to the moment: <code>cl.time &lt;= to-&gt;senttime</code> (collisions are tested at each iteration using <code>CL_PredictUsercmd</code> ). <br><br><h3>  Other players </h3><br>  For other players, the Quake engine does not have ‚Äúsent but not yet confirmed teams‚Äù, so interpolation is used instead.  Starting from the last known position, <code>cmd</code> interpolated to predict the resulting position.  Predicted position only, without angular rotation. <br><br>  Quake World also takes into account the latency of other players.  The latency of each player is sent along with the update of the world. <br><br><h3>  Code </h3><br>  The code for predicting and calculating collisions can be summarized as follows: <br><br><pre> <code class="cpp hljs"> CL_SetUpPlayerPrediction(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) CL_PredictMove | <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> | CL_SetSolidPlayers | | CL_PredictUsercmd | | PlayerMove |   CL_SetUpPlayerPrediction(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) CL_EmitEntities CL_LinkPlayers | <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> |    | | CL_SetSolidPlayers | | CL_PredictUsercmd | | PlayerMove CL_LinkPacketEntities CL_LinkProjectiles CL_UpdateTEnts</code> </pre> <br>  This part is difficult, because Quake World not only performs predictions for players, but also recognizes collisions based on predictions. <br><br> <u><code>CL_SetUpPlayerPrediction(false)</code></u> <br> <br>  The first call does not perform the prediction, it only places the players in the positions received from the server (that is, with a delay in t-latency / 2). <br><br> <u><code>CL_PredictMove()</code></u> <br> <br>  This is where the local player moves: <br><br><ul><li>  Orientation is not interpolated and runs completely in real time. </li><li>  Position and speed: all commands sent up to the current time ( <code>cl.time &lt;= to-&gt;senttime</code> ) are applied to the last position / speed received from the server. </li></ul><br>  Learn more about updating position and speed: <br><br><ul><li>  First, other players turn into solid objects (in their last known position, set in <code>CL_SetUpPlayerPrediction(false)</code> ) using <code>CL_SetSolidPlayers</code> . </li><li>  The engine cycles through all sent commands, checking for collisions and predicting the position using <code>CL_PredictUsercmd</code> .  Collisions for other players are also tested. </li><li>  The resulting position and speed are stored in <code>cl.sim*</code> .  They will be used later to set the viewpoint. </li></ul><br> <u><code>CL_SetUpPlayerPrediction(true)</code></u> <br> <br>  In the second call on the server side, the position of other players at the current moment is predicted (but the movement is not performed yet).  The position is extrapolated from the last known commands and the last known position. <br><br>  <b>Note:</b> There is a small problem here: Valve recommends (for <code>cl_pushlatency</code> ) to predict the state of the local player on the server side at t + latency / 2.  However, the position of other players is predicted on the server side at time t.  Perhaps the best value for <code>cl_pushlatency</code> in QW was -latency / 2? <br><br> <u><code>CL_EmitEntities</code></u> <br> <br>  This is where the visibility guidelines are generated.  Then they are transferred to the renderer. <br><br><ul><li>  <b>CL_LinkPlayers:</b> Other players are moving, other players are turning into solid objects and collision detection is performed for their predicted position. </li><li>  <b>CL_LinkPacketEntitiesPacket:</b> objects from the last state received from the server are predicted and associated with visibility indications.  That is why there is a lag for the released rocket. </li><li>  <b>CL_LinkProjectiles:</b> machining nails and other shells. </li><li>  <b>CL_UpdateTEnts:</b> standard update of light rays and objects. </li></ul><br><h2>  Visualization </h2><br>  When developing the original game, the most effort was spent on the Quake renderer module.  This is described in detail in the book by Michael Abrash and in the files of .plan by John Carmack. <br><br><h3>  Visualization </h3><br>  The scene visualization process is inherently associated with the BSP card.  I recommend reading more about Binary Space Partitioning ( <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">binary space splitting</a> ) in Wikipedia.  In short, Quake maps underwent extensive pre-processing.  Their volume is recursively cut as follows: <br><br><img src="http://fabiensanglard.net/quakeSource/bsp.jpg"><br><br>  This process created a BSP with leaves (the creation rules are as follows: select an existing polygon as a cutting plane and select a separator that cuts fewer polygons).  After creating a BSP, PVS (Potentially Visible Set, potentially visible set) was calculated for each sheet.  Example: Sheet 4 can potentially see leaves 7 and 9: <br><br><img src="http://fabiensanglard.net/quakeSource/pvs.jpg"><br><br>  The final PVS for this sheet was saved as a bit vector: <br><br><table><tbody><tr><th>  Id  sheet </th><th>  one </th><th>  2 </th><th>  3 </th><th>  four </th><th>  five </th><th>  6 </th><th>  7 </th><th>  eight </th><th>  9 </th><th>  ten </th><th>  eleven </th><th>  12 </th><th>  13 </th><th>  14 </th><th>  15 </th><th>  sixteen </th></tr><tr><th>  PVS for sheet 4 </th><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table>  The result was a global PVS of about 5MB in size.  It was too much for the PC in 1996.  Therefore, PVS was compressed using length difference compression. <br><br><table><tbody><tr><th>  Compressed PVS for sheet 4 </th><td>  3 </td><td>  2 </td><td>  one </td><td>  7 </td></tr></tbody></table><br>  Encoded PVS contained only the number of zeros between ones.         ,    (32767)            PVS  20. <br><br><h3>     </h3><br>     BPS  PVS      : <br><br><ul><li>  BSP   ,     . </li><li>    PVS   ,    PVS     BSP. </li><li>  BSP,     . </li><li>   (Node)  ,   . </li><li>          . </li><li>      . </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BSP is used several times. </font><font style="vertical-align: inherit;">For example, to bypass the map from the nearest points to the distance for each active light source and mark polygons on the map. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 2:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> During software rendering, the BSP-tree was traversed from farthest points to the nearest ones.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code analysis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In short, the visualization code can be represented as follows: </font></font><br><pre> <code class="cpp hljs">SCR_UpdateScreen { GL_BeginRendering SCR_SetUpToDrawConsole V_RenderView | R_Clear | R_RenderScene | | R_SetupFrame | | Mod_PointInLeaf | | R_SetFrustum | | R_SetupGL | | R_MarkLeaves | | | Mod_LeafPVS | | | Mod_DecompressVis | | R_DrawWorld | | | R_RecursiveWorldNode | | | DrawTextureChains | | | | R_RenderBrushPoly | | | | DrawGLPoly | | | R_BlendLightmaps | | S_ExtraUpdate | | R_DrawEntitiesOnList | | GL_DisableMultitexture | | R_RenderDlights | | R_DrawParticles | R_DrawViewModel | R_DrawAliasModel | R_DrawWaterSurfaces | R_PolyBlend GL_Set2D SCR_TileClear V_UpdatePalette GL_EndRendering }</code> </pre> <br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCR_UpdateScreen</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calls:</font></font><br><br><ol><li> <code>GL_BeginRendering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sets the values ‚Äã‚Äãof variables ( </font></font><code>glx,gly,glwidth,glheight</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), later used in </font></font><code>R_SetupGL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to set the viewing area and projection matrix)</font></font></li><li> <code>SCR_SetUpToDrawConsole</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Determines the height of the console: why is it here, and not in the part related to 2D ?!) </font></font></li><li> <code>V_RenderView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (3D scene rendering) </font></font></li><li> <code>GL_Set2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (switch to orthogonal projection (2D)) </font></font></li><li> <code>SCR_TileClear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Additional drawing of many 2D objects, console, FPS metrics, etc.) </font></font></li><li> <code>V_UpdatePalette</code> (   ,  openGL          ,   ,   ..).    <code>v_blend</code> </li><li> <code>GL_EndRendering</code> (  ( )!) </li></ol><br> <u>V_RenderView</u> <br> : <br><br><ol><li> <code>V_CalcRefdef</code> (,     ) </li><li> <code>R_PushDlights</code>         (. ) </li><li> <code>R_RenderView</code> </li> </ol><br> <b>:</b> R_PushDlights    ( <code>R_MarkLights</code> ).   BSP    (    ),     . BSP       (    ).  ,           .  <code>R_MarkLights</code>  ,                 ¬´Frames of Reference¬ª ( <code>dist = DotProduct (light-&gt;origin, splitplane-&gt;normal) - splitplane-&gt;dist;</code> )). <br><br> <u>R_RenderView</u> <br><br> : <br><br><ol><li> <code>R_Clear</code> (   GL_COLOR_BUFFER_BIT / GL_DEPTH_BUFFER_BIT) </li><li> <code>R_RenderScene</code> </li> <li> <code>R_DrawViewModel</code> (     ) </li><li> <code>R_DrawWaterSurfaces</code> (   GL_BEND/GL_MODULATE   .       sin  cos  <code>gl_warp.c</code> ) </li><li> <code>R_PolyBlend</code> (     ,   <code>V_UpdatePalette</code>  <code>v_blend</code> .       ( ),      ) </li></ol><br> <u>R_RenderScene</u> <br><br> : <br><ol><li> <code>R_SetupFrame</code> (  BSP,          ¬´r_viewleaf¬ª ) </li><li> <code>R_SetFrustum</code> ( <code> mplane_t[4]</code> .     . </li><li> <code>R_SetupGL</code> ( GL_PROJECTION, GL_MODELVIEW,     glCullFace,     Y  Z,    X  Z  Quake       openGL.) </li><li> <code>R_MarkLeaves</code> </li> <li> <code>R_DrawWorld</code> </li> <li> <code>S_ExtraUpdate</code> (  ,    ) </li><li> <code>R_DrawEntitiesOnList</code> (   ) </li><li> <code>GL_DisableMultitexture</code> ( ) </li><li> <code>R_RenderDlights</code> (    ) </li><li> <code>R_DrawParticles</code> (, ,   ..) </li></ol><br> <u>R_SetupFrame</u> <br><br>  : <br><br><pre> <code class="cpp hljs">r_viewleaf = Mod_PointInLeaf (r_origin, cl.worldmodel);</code> </pre> <br>    Quake  /  BSP,       . <br><br> Mod_PointInLeaf   model.c,    BSP ( BSP-   model-&gt;nodes ). <br><br>   : <br><br><ul><li>      ,    ,       . </li><li>      BSP     (    ,     BSP-)     . </li></ul><br> <u>R_MarkLeaves</u> <br><br>    <code>r_viewleaf</code>    BSP (  <code>R_SetupFrame</code> ),   ( <code>Mod_LeafPVS</code> )   ( <code>Mod_DecompressVis</code> )    (PVS).           BSP: node-&gt;visframe = r_visframecount. <br><br> <u>R_DrawWorld</u> <br><br> : <br><br><ol><li> <code>R_RecursiveWorldNode</code> (  BSP  ,  ,    ( <code>R_MarkLeaves</code> ),   <code>cl.worldmodel-&gt;textures[]-&gt;texturechain</code>  .) </li><li> <code>DrawTextureChains</code> (  ,   texturechain:   cl.worldmodel-&gt;textures[].        . .) </li><li> <code>R_BlendLightmaps</code> ( ,        ). </li></ol><br>  <u>Note:</u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This part uses the notorious openGL ‚Äúimmediate mode‚Äù, while it was considered the ‚Äúlast word of technology‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>R_RecursiveWorldNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">most of the clipping operations are performed. </font><font style="vertical-align: inherit;">A node is shut down if:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Its contents are solid objects. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sheet was not marked in PVS ( </font></font><code>node-&gt;visframe != r_visframecount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sheet does not pass clipping on the pyramid of visibility. </font></font></li></ul><br><img src="http://media.indiedb.com/images/members/1/240/239733/generations000073.jpg" alt="image"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MDL format </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The MDL format is a set of fixed frames. </font><font style="vertical-align: inherit;">The Quake engine does not interpolate the position of the vertices to smooth the animation (therefore, a high frame rate does not improve the animation).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elegant solutions </font></font></h3><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elegant leaf</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tagging A naive approach to leaf tagging BSP for rendering is to use a boolean variable </font></font><code>isMarkedVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Before each frame you need:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set the values ‚Äã‚Äãof all boolean variables to false. </font></font></li><li>   PVS        true. </li><li>      <code>if (leave.isMarkedVisible)</code> </li></ol><br>    Quake         ( <code>r_visframecount</code> variable).      : <br><br><ol><li>   PVS       <code>leaf.visframe = r_visframecount</code> </li><li>      <code>if (leaf.visframe == r_visframecount)</code> </li></ol><br> <u>  </u> <br><br>  <code>R_SetupFrame</code>   ¬´  ¬ª    BSP       while. <br><br><pre> <code class="cpp hljs"> node = model-&gt;nodes; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;contents &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">mleaf_t</span></span> *)node; plane = node-&gt;plane; d = DotProduct (p,plane-&gt;normal) - plane-&gt;dist; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) node = node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = node-&gt;children[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br> <u>   </u> <br><br>  openGL     ( <code>glBindTexture(GL_TEXTURE_2D,id)</code> )  .       ,   ,    ,     . <br><br><pre> <code class="cpp hljs">cl.worldmodel-&gt;textures[textureId]-&gt;texturechain[]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After clipping is complete, texture chains are drawn in order. </font><font style="vertical-align: inherit;">Thus, the total N texture switching is performed, where N is the total number of visible textures.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cl.worldmodel-&gt;textures_num ; i ++) DrawTextureChains(i);</code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/324804/">https://habr.com/ru/post/324804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324794/index.html">What is the difference between UI and UX? Detailed analysis of frequently used terms</a></li>
<li><a href="../324796/index.html">Sending files to the Xamarin.Forms application. Part 2</a></li>
<li><a href="../324798/index.html">Synchronization of rhythm in music games</a></li>
<li><a href="../324800/index.html">Interview with Leonid Vasilyev, Dropbox developer, about work and life in Ireland</a></li>
<li><a href="../324802/index.html">Security defects that PVS-Studio team fixed this week: Issue N3</a></li>
<li><a href="../324808/index.html">Convenient C ++ enumerator</a></li>
<li><a href="../324810/index.html">Modular Java applications. How?</a></li>
<li><a href="../324812/index.html">Development for Sailfish OS: Features of working with dates and time zones</a></li>
<li><a href="../324814/index.html">Learn to think in REM. Talk about the obvious and about productivity in a small web studio</a></li>
<li><a href="../324816/index.html">Launch of the project Nerepetitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>