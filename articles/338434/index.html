<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Oblique frustum. Inside the oblique visibility pyramid</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The following material is probably familiar, or even well known, to programmers who had experience with OpenGL, meanwhile, I found it appropriate to r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Oblique frustum. Inside the oblique visibility pyramid</h1><div class="post__text post__text-html js-mediator-article">  The following material is probably familiar, or even well known, to programmers who had experience with OpenGL, meanwhile, I found it appropriate to recall the <em>oblique frustum</em> model, partially observing (and sharing) the interest of <em>Habr's</em> readers in OpenGL issues and in general three-dimensional modeling, partly because of disagreement with the position of some developers like <a href="https://docs.unity3d.com/ru/530/Manual/ObliqueFrustum.html" title="Unity3D Guide">‚Äú... in order to use it, it is not at all necessary to understand how the projection matrix works,‚Äù</a> partly out of respect and gratitude for Eric Lengel |  <a href="https://habr.com/ru/post/338434/">Eric Lengyel</a> , whose inventive thought has enriched the techniques of working in the OpenGL environment. <br><br>  If there are mirror images in the scenes you are modeling and you have forgotten or not heard about ‚Äúoblique frustum‚Äù, then it is possible that this article will not be useless for you. <br><br>  In spite of the fact that I, following Erik Lengel, were more adhered to in presenting the material of OpenGL presentations, all the subsequent reasoning is easily extended to any other three-dimensional modeling systems. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/3cb/1b6/cc63cb1b62bf2027a2f72c4dc10469a4.png" alt="Reflections">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Reflections in 3D scenes </h2><br>  In the case where reflective surfaces are present in 3D scenes, the usual practice of obtaining reflections is to render the scene using an auxiliary view camera, which itself is a reflection of the main view camera by the plane of the reflecting surface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/000/bbc/a92/000bbca92f358132135802ed1f4a26a4.svg" width="70%" alt="arbitrary camera"></div><br><br>  <strong>Fig</strong> .  1. The top camera is the main camera through which the scene containing the reflective surface is rendered.  The bottom camera is <em>an auxiliary camera</em> designed for rendering reflection.  The X axis is directed to the observer for both the pyramids of visibility ( <em>in the views adopted for OpenGL</em> ), and it is obvious that the coordinate system for the camera that renders the reflection is <em>left-handed</em> . <br><br>  When rendering a reflection with an auxiliary camera (a reflection camera), it may turn out that some of the objects located between the observer and the reflecting surface end up in the resulting render, forming unwanted artifacts in the image.  In order to cut off the undesirable part of the reflected scene from the final render, the programmer restricts the part of the volume of the three-dimensional scene observed from the reflection chamber to an imaginary surface, using various techniques to interrupt the rendering of the scene beyond this surface. <br><br>  You can use the ‚Äúdiscard‚Äù instruction for a fragmentary shader or similar, specific for individual rendering implementations in the general ideology of 3D modeling (for example, kill in AGALMiniAssembler), however, if we want a universal solution that works equally well <a href="https://stackoverflow.com/questions/8509051/is-discard-bad-for-program-performance-in-opengl">on any processor</a> , then pay attention to the technique proposed by Eric Lengel. <br><br>  The idea of ‚Äã‚ÄãEric Lengela was to modify the <em>projection matrix</em> in such a way that the <em>near</em> view of the visibility pyramid becomes just a sort of <em>cutting plane</em> that separates the volume of the main scene that is undesirable in the final render. <br><br>  For further, it is appropriate to recall the elementary representations of <em>analytic geometry</em> . <br><br><h2>  Plane in space </h2><br>  For convenience of presentation, we will adhere to the following notation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9e/e1c/929/e9ee1c9295cf0323549ad848be7f8843.svg" alt="\ begin {center} \ begin {array} {| rlc} \ textbf {for points and vectors:} &amp; amp; \ vec {A}, \ vec {P} \\ \ multicolumn {2} {| l} {\ textit {distinguishing them} \ mathit {w} \ textit {-coordinate in a uniform representation,}}} \\ \ multicolumn { 2} {| l} {\ textit {the coordinate record is enclosed in angle brackets} \ langle ,,, \ rangle} \\ [0.3em] \ textbf {for matrices:} &amp; amp; \ mathbf {M}, \ mathbf {P} \\ \ textbf {transposed matrix:} &amp; amp; \ mathbf {M} ^ \ mathrm {T} \\ \ textbf {inverse matrix:} &amp; amp; \ mathbf {M} ^ {- 1} \\ \ textbf {character} x: &amp; amp; sgn (x) = \ begin {cases} 1, &amp; amp; \ quad \ text {if} x &amp; gt; 0 \\ 0, &amp; amp; \ quad \ text {if} x = 0 \\ -1, &amp; amp; \ quad \ text {if} x &amp; lt; 0 \ end {cases} \\ \ textbf {vector length:} &amp; amp; \ | \ vec {P} \ | \\ \ textbf {scalar product of vectors:} &amp; amp; \ vec {Q} \ cdot \ vec {P} \\ \ end {array} \ end {center}"><br><br><h3>  Plane </h3><br>  For any spatial 3D point <img src="https://habrastorage.org/getpro/habr/post_images/653/a98/910/653a989105bc94f11c1f3b8ad1f26bf2.svg" alt="\ vec {P}">  and vectors <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  , set of 3D points <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  other than <img src="https://habrastorage.org/getpro/habr/post_images/653/a98/910/653a989105bc94f11c1f3b8ad1f26bf2.svg" alt="\ vec {P}">  satisfying the equation <img src="https://habrastorage.org/getpro/habr/post_images/033/138/fe8/033138fe81810792aa8416f75b550ecd.svg" alt="\ vec {N} \ cdot (\ vec {Q} - \ vec {P})">  defines a plane, with a point <img src="https://habrastorage.org/getpro/habr/post_images/653/a98/910/653a989105bc94f11c1f3b8ad1f26bf2.svg" alt="\ vec {P}">  is one of the points belonging to this plane, and the vector <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  is its normal vector. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/ada/f91/d33adaf9113528f2fe59671a4b72bdb7.svg" width="70%" alt="Plane"></div><br>  <strong>Fig</strong> .  2. The plane is completely determined by the point belonging to it. <img src="https://habrastorage.org/getpro/habr/post_images/653/a98/910/653a989105bc94f11c1f3b8ad1f26bf2.svg" alt="\ vec {P}">  and normal vector <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  . <br><br>  The plane equation is often written with the following expression: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/bb8/192/9fa/bb81929fa089459264878faba089e694.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/cdc/ecc/7f0cdcecc22c93fcec947f41403dc76e.svg" alt="Ax + By + Cz + D = 0,"></div><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/4eb/833/86e/4eb83386ec25345c998fba1b73c81da5.svg" alt="\ mathit {A, B}">  and <img src="https://habrastorage.org/getpro/habr/post_images/daf/4ce/4b1/daf4ce4b18a890ba216b1561ffc2e352.svg" alt="\ mathit {C}">  there is <img src="https://habrastorage.org/getpro/habr/post_images/9c0/402/d3e/9c0402d3ef5de292f1c3544234d1cc87.svg" alt="\ mathit {x, y, z}">  normal vector components <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  , and <img src="https://habrastorage.org/getpro/habr/post_images/fb9/3dc/1e3/fb93dc1e325a25f5064b66b2fdbddf4a.svg" alt="D = - \ vec {N} \ cdot \ vec {P}">  .  Value <img src="https://habrastorage.org/getpro/habr/post_images/8cf/e7a/37c/8cfe7a37c7e17274ba8e30d9281bcb5a.svg" alt="| D | / \ | \ vec {N} \ |">  equal to the distance to the plane from the origin ( <em>remember that the components of the normal vector divided by its length are the direction cosines of the unit vector normal to the plane</em> ). <br><br>  In the case of a <em>normalized</em> normal vector, the expression <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/a79/caf/e65/a79cafe65ea1ccf1f75352901195b537.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/90a/707/8bb90a707bd4fa40cc45326470f89b57.svg" alt="d = \ vec {N} \ cdot \ vec {Q} + D,"></div><br>  can be used to find the distance from the plane to an arbitrary point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  .  If a <img src="https://habrastorage.org/getpro/habr/post_images/ab3/ed2/2bd/ab3ed22bd768ef29a090d385893149ab.svg" alt="d = 0">  , <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  lies in the plane.  If <img src="https://habrastorage.org/getpro/habr/post_images/3aa/eea/d06/3aaeead064956ab64f1997996f937792.svg" alt="d &amp; gt; 0">  , point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  is located on the <em>positive</em> side of the plane, i.e.  from the side of the normal plane vector, with <img src="https://habrastorage.org/getpro/habr/post_images/b12/b2c/e91/b12b2ce91752ffb43a84b1aa1e7ad9c8.svg" alt="d &amp; lt; 0">  , point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  is located away from the plane, in the opposite direction to the normal vector of the plane <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  . <br>  It is convenient to record the plane by a four-dimensional vector.  In short, the equation of the plane is written as: <img src="https://habrastorage.org/getpro/habr/post_images/298/0c4/6a9/2980c46a97264eaa85602a2d76e4f686.svg" alt="\ langle \ vec {N}, D \ rangle">  .  Obviously, for an arbitrary point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  having in <em>uniform</em> 4-dimensional coordinates <img src="https://habrastorage.org/getpro/habr/post_images/cdb/5e6/de3/cdb5e6de3f61e1e5dd6696e8f62e0de1.svg" alt="\ mathit {w}">  -coordinate equal to 1, <em>Expression</em> (2) can be rewritten as <img src="https://habrastorage.org/getpro/habr/post_images/425/449/cc5/425449cc5054a2be00fe0b220e8ba0e0.svg" alt="d = \ vec {L} \ cdot \ vec {Q}">  where <img src="https://habrastorage.org/getpro/habr/post_images/2a8/98d/f24/2a898df248d82a9e1ec37e828b7d4104.svg" alt="\ vec {L} = \ langle \ vec {N}, D \ rangle">  and point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  lies in the plane if <img src="https://habrastorage.org/getpro/habr/post_images/c50/274/978/c502749782fe7ac1c7441ec5ee989dbe.svg" alt="\ vec {L} \ cdot \ vec {Q} = 0">  . <br><br><h3>  Plane transform </h3><br>  To understand the features of the spatial transformation of the plane, it will take some attention to transform the <em>normal vector</em> .  In the spatial transformation of a polygonal model, the vectors are tangent to the surface of the polygons and the vectors do not behave normally.  The <em>tangent</em> vector can often be represented as the difference between two transformed vertices, i.e.  between two naturally transformed points, and, as a result, the nature of the transformed vector coincides with our expectations.  But, in the general case of a spatial transformation, the matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  which is not orthogonal, direct application of the transformation matrix to the <em>normal</em> vector will result in this vector no longer being <em>normal</em> ‚Äî perpendicular to the surface of the polygon. <br><br>  Since the vector is tangent <img src="https://habrastorage.org/getpro/habr/post_images/f81/a1d/033/f81a1d0332a404791f3131c6d25c11a9.svg" alt="\ vec {T}">  and the vector is normal <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  belonging to the same polygon must remain perpendicular for the scalar product of transformed vectors <img src="https://habrastorage.org/getpro/habr/post_images/837/96a/542/83796a542a23909d9c28f24ea66d44ab.svg" alt="\ vec {T} {^ '}">  and <img src="https://habrastorage.org/getpro/habr/post_images/841/e1b/325/841e1b3251e9a47adb2f41cd17f41b64.svg" alt="\ vec {N} {^ '}">  the same condition must be met as for the source vectors: <img src="https://habrastorage.org/getpro/habr/post_images/4f2/1b1/fa5/4f21b1fa57faae090b1c186349cecd4b.svg" alt="\ vec {T} {^ '} \ cdot \ vec {N} {^'} = 0">  .  Perform a few simple algebraic operations to clarify the nature of a <em>normal</em> vector: <br><br>  if a <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  - 3x3 matrix of space transformation (for the case of tangent and normal vectors, spatial displacements are insignificant), and <img src="https://habrastorage.org/getpro/habr/post_images/d0d/4d1/147/d0d4d1147e0f6a79ccd2b7e5dcd3c1be.svg" alt="\ vec {T} {^ '} = \ mathbf {M} \ vec {T}">  , then we set ourselves the goal of finding the transformation matrix <img src="https://habrastorage.org/getpro/habr/post_images/f20/fa2/14b/f20fa214b343d110cb51c15d8fdbb4f7.svg" alt="\ mathbf {G}">  for <img src="https://habrastorage.org/getpro/habr/post_images/fe1/665/a58/fe1665a58bcb5c5c314972a1f260ab65.svg" alt="\ vec {N}">  such that it is performed <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/6a4/759/99d/6a475999d4080311ef78a1e9424aac0f.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/7ec/ca9/21f7ecca99b1bf9ecaae59ee5b4cacae.svg" alt="\ vec {N} {^ '} \ cdot \ vec {T} {^'} = (\ mathbf {G} \ vec {N}) \ cdot (\ mathbf {M} \ vec {T}) = 0,"></div><br>  remember that the multiplication of vectors can be written as follows (completely equivalent): <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/0af/1f0/939/0af1f09396086076b8030446fa70e628.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/315/e37/7a8315e3797d4d072724385faa1d6488.svg" alt="(\ mathbf {G} \ vec {N}) \ cdot (\ mathbf {M} \ vec {T}) = (\ mathbf {G} \ vec {N}) ^ \ mathrm {T} (\ mathbf {M } \ vec {T}) = \ vec {N} ^ \ mathrm {T} \ mathbf {G} ^ \ mathrm {T} \ mathbf {M} \ vec {T},"></div><br>  Insofar as <img src="https://habrastorage.org/getpro/habr/post_images/c36/16b/6ff/c3616b6fffcf256f42aaf492551720bd.svg" alt="\ vec {N} ^ \ mathrm {T} \ vec {T} = 0">  , expression <img src="https://habrastorage.org/getpro/habr/post_images/538/148/8d0/5381488d092cb03ef433f20c5fbf300a.svg" alt="\ vec {N} ^ \ mathrm {T} \ mathbf {G} ^ \ mathrm {T} \ mathbf {M} \ vec {T} = 0">  performed if <img src="https://habrastorage.org/getpro/habr/post_images/6f8/f98/821/6f8f98821280b29244c4f49cc3503acf.svg" alt="\ mathbf {G} ^ \ mathrm {T} \ mathbf {M} = \ mathbf {I}">  where <img src="https://habrastorage.org/getpro/habr/post_images/10b/236/8d9/10b2368d92de7a310597377c7fc6ffda.svg" alt="\ mathbf {I}">  - unit matrix.  Which implies that <img src="https://habrastorage.org/getpro/habr/post_images/244/046/4e5/2440464e58c7f35cdb4931e3d5e9154b.svg" alt="\ mathbf {G} = (\ mathbf {M} ^ {- 1}) ^ \ mathrm {T}">  .  A vector that is transformed in a similar way (by means of a transposed inverse transformation matrix) is a <em>covariant</em> vector, while a vector that transforms like a <em>tangent</em> vector is a <em>contravariant</em> vector. <br><br>  However, the plane in homogeneous coordinates, unlike the normal vector, has a nonzero <img src="https://habrastorage.org/getpro/habr/post_images/cdb/5e6/de3/cdb5e6de3f61e1e5dd6696e8f62e0de1.svg" alt="\ mathit {w}">  coordinate, and should further investigate its behavior in 4x4-transformations. <br><br>  The distance to the plane from the origin, after applying the spatial transformation, taking into account the peculiarities of the transformation of the <em>normal</em> vector, for a point lying in this plane <img src="https://habrastorage.org/getpro/habr/post_images/653/a98/910/653a989105bc94f11c1f3b8ad1f26bf2.svg" alt="\ vec {P}">  , through the familiar scalar product: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/018/7e5/abd/0187e5abdd5d89e56ac358a91f005fdd.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d3/193/e0d/3d3193e0d3daa17b21c6e04d3875cdc1.svg" alt="\ begin {array} {l} D {^ '} = - ((\ mathbf {M} {^ {- 1}}) ^ \ mathrm {T} \ vec {N}) \ cdot (\ mathbf {M} \ vec {P} + \ vec {T}) \\ \ qquad {} = - ((\ mathbf {M} ^ {- 1}) ^ \ mathrm {T} \ vec {N}) ^ \ mathrm {T } \ mathbf {M} \ vec {P} - ((\ mathbf {M} ^ {- 1}) ^ \ mathrm {T} \ vec {N}) ^ \ mathrm {T} \ vec {T} \\ \ qquad {} = - \ vec {N} ^ \ mathrm {T} \ mathbf {M} ^ {- 1} \ mathbf {M} \ vec {P} - \ vec {N} ^ \ mathrm {T} \ mathbf {M} ^ {- 1} \ vec {T} \\ \ qquad {} = D - \ vec {N} \ cdot \ mathbf {M} ^ {- 1} \ vec {T}, \ end {array }"></div><br>  We used the transformation matrix in these calculations. <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  added to the operations of rotation, scaling and skew <em>shift</em> operation: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/34b/082/223/34b082223798ff10c0fcd50a3302364e.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/c77/0de/af9c770ded262c1969975fa56c4f217d.svg" alt="\ mathbf {F} = \ left [\: \; \ begin {matrix} \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ quad {} &amp; amp; \ mathbf {M} \ quad {} &amp; amp; \ vline &amp; amp; \ vec {T} \\ \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ hline \ quad {} &amp; amp; 0 \ quad {} &amp; amp; \ vline &amp; amp; 1 \ end {matrix} \: \; \ right] = \ left [\: \; \ begin {matrix} M_ {11} &amp; amp; M_ {12} &amp; amp; M_ {13} &amp; amp; \ vline \, &amp; amp; T_x \\ M_ {21} &amp; amp; M_ {22} &amp; amp; M_ {23} &amp; amp; \ vline \, &amp; amp; T_y \\ M_ {31} &amp; amp; M_ {32} &amp; amp; M_ {33} &amp; amp; \ vline \, &amp; amp; T_z \ hline 0 &amp; amp; 0 &amp; amp; 0 &amp; amp; \ vline \ , &amp; amp; 1 \\ \ end {matrix} \: \; \ right],"></div><br>  Inverse transformation matrix to matrix <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  It is looked for by the usual matrix inversion algorithm: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/ac6/f02/875/ac6f02875612deb38e5865b2a037d51f.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef6/9cd/943/ef69cd9432ba8e763df01aaaf06cf32d.svg" alt="\ mathbf {F} ^ {- 1} = \ left [\: \; \ begin {matrix} \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ quad {} &amp; amp; \ mathbf {M} ^ {- 1} \ quad {} &amp; amp; \ vline &amp; amp; - \ mathbf {M} ^ {- 1} \ vec {T} \\ \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ hline \ quad {} &amp; amp; ; 0 \ quad {} &amp; amp; \ vline &amp; amp; 1 \ end {matrix} \: \; \ right] = \ left [\: \; \ begin {matrix} M_ {11} ^ {- 1} &amp; amp; M_ {12} ^ {- 1} &amp; amp; M_ {13} ^ {- 1} &amp; amp; \ vline \, &amp; amp; \ \ mathbf {M} ^ {- 1} T_x \\ M_ {21} ^ {- 1} &amp; amp; M_ {22} ^ {- 1} &amp; amp; M_ {23} ^ {- 1} &amp; amp; \ vline \, &amp; amp; \ mathbf {M} ^ {- 1} T_y \\ M_ {31} ^ {- 1} &amp; amp; M_ {32} ^ {- 1} &amp; amp; M_ {33} ^ {- 1} &amp; amp; \ vline \, &amp; amp; - \ mathbf {M} ^ {- 1} T_z \\ \ hline 0 &amp; amp; 0 &amp; amp; 0 &amp; amp; \ vline \, &amp; amp; 1 \\ \ end {matrix} \: \; \ right],"></div><br>  Transpose the inverse matrix: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/30d/b67/121/30db67121f43037bdee27ac875c4cd48.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f5e/376/dc7f5e376fd73ba0cd089aef68c1d0ba.svg" alt="{\ left (\ mathbf {F} ^ {- 1} \ right) ^ \ mathrm {T}} = \ left [\: \; \ begin {matrix} \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ quad {} &amp; amp; {\ left (\ mathbf {M} ^ {- 1} \ right) {} ^ \ mathrm {T}} \ quad {} &amp; amp; \ vline &amp; amp; 0 \\ \ quad {} &amp; amp; \ quad {} &amp; amp; \ vline &amp; amp; \ quad {} \\ \ hline \ quad {} &amp; amp; - \ mathbf {M} ^ {- 1} \ vec {T} \ quad {} &amp; amp; \ vline &amp; &amp;; 1 \ end {matrix} \: \; \ right],"></div><br>  Can see that <img src="https://habrastorage.org/getpro/habr/post_images/e9e/110/337/e9e11033715e381f083caa0628fb15c7.svg" alt="D - \ vec {N} \ cdot \ mathbf {M} ^ {- 1} \ vec {T}">  from <em>Expression</em> (5) is the result of multiplying the fourth row of the transposed inverse transformation matrix by a four-dimensional vector in a uniform coordinate record <img src="https://habrastorage.org/getpro/habr/post_images/e9d/f9b/8cf/e9df9b8cff541649983564b430a20394.svg" alt="\ langle N_x, N_y, N_z, D \ rangle">  i.e.  for the plane <img src="https://habrastorage.org/getpro/habr/post_images/db9/728/0b2/db97280b29581f0fdea034d7b1366c84.svg" alt="\ vec {C} = \ langle \ vec {N}, D \ rangle">  , its image with spatial transformation, described by 4x4 transformation matrix <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  expressed: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/0d1/19c/064/0d119c0647973f0dec8f8d2f4e333d96.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/65f/41c/90c65f41c1f67328417f88bb05b771cf.svg" alt="\ vec {C} {^ '} = {\ left (\ mathbf {F} ^ {- 1} \ right) {} ^ \ mathrm {T}} \ vec {C}."></div><br>  For further, it is essential that the plane obeys the covariant character of the spatial transformation. <br><br><h2>  Perspective Projection </h2><br>  <em>Perspective projection</em> is used to create a sense of <em>depth</em> for the observer on the <em>projection plane</em> , the perspective transformation matrix should map the <em>visibility pyramid</em> space to the normalized <em>visibility cube</em> space.  The visibility pyramid can usually be expressed in terms of top, bottom, left, right, far, near or fovy, aspect, near, far, some OpenGL implementations have among their tools work tools for right-handed and left-handed coordinate systems.  The differences and the order of multiplication of the matrix by the vector in each of the systems should be clear to any programmer. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/44a/dc5/f1544adc547d4759ba1c610ecff1b79d.svg" alt="frustum"></div><br><br>  <strong>Fig</strong> .  3. The truncated pyramid of visibility (frustum) in computer graphics systems cuts the field of view, for the purposes of subsequent rendering, from the sides and along the projection axes.  The pyramid of visibility, in the space of the camera view, is located in the right-hand coordinate system so that the top of the pyramid lies in the center of the coordinate system, and the direction of the view from the camera is opposite to the axis <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  , the foreground is at a distance <img src="https://habrastorage.org/getpro/habr/post_images/870/81c/83c/87081c83c06ea78584d7e1ee1efbef58.svg" alt="n">  along the negative axis direction <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  , distant plan - at a distance <img src="https://habrastorage.org/getpro/habr/post_images/549/83a/c9e/54983ac9e8a725208d9d1eedda7caad0.svg" alt="f">  along the negative axis direction <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  . <br><br>  In general, the visibility pyramid does not need to have the shape of a regular truncated pyramid, it can be asymmetric, so the model with top, bottom, left, right, far, near is more suitable for illustrating the features of oblique frustum ("oblique visibility pyramid").  "Compressed space" <em>cube visibility</em> , closed in a volume bounded by planes <img src="https://habrastorage.org/getpro/habr/post_images/cb3/444/0fc/cb34440fc9fc7883f47a9adddca4ba75.svg" alt="x = \ pm 1, y = \ pm 1, z = \ pm 1">  , for uniformity with English terminology, we will hereinafter be called <em>the clip space</em> . <br><blockquote>  To organize the <em>cutting off of</em> parts of objects in the <em>original</em> visibility pyramid, we need to modify the perspective projection matrix used in our model.  Matrix OpenGL programmers can find such matrix parameters on the <a href="">main</a> OpenGL <a href="">documentation</a> website, Flash programmers (AS3) will most likely turn to the <a href="">PerspectiveMatrix3D</a> class, Direct3D programmers have <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb147302(v%3Dvs.85).aspx">their own sources</a> , writing for <em>android</em> will find everything you need in the android.opengl.Matrix class, and t .d  It is not excluded that someone, having understood the basic idea, will prefer to expand his own class of perspective transformation with additional functionality. <br></blockquote><br>  The point from the visibility pyramid space of the view camera is mapped into the <em>clip</em> space <em>of the</em> canonical cube, for example, with the following 4x4-matrix transformation (we use the perspective transformation matrix generated by glFrustum () - the OpenGL function): <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/5c6/892/b58/5c6892b58d1fb621ce534afa2c8be444.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b2/06f/581/9b206f581c3d105d053235a40cec87f0.svg" alt="\ vec {P} {^ '} = \ mathbf {M} _ {frustum} \ vec {P} = \ begin {bmatrix} \ frac {2n} {rl} &amp; amp; 0 &amp; amp; \ frac {r + l} {rl} &amp; amp; 0 \\ [0.3em] 0 &amp; amp; \ frac {2n} {t-b} &amp; amp; \ frac {t + b} {t-b} &amp; amp; 0 \\ [0.3em] 0 &amp; amp; 0 &amp; amp; - \ frac {f + n} {f-n} &amp; amp; - \ frac {2nf} {f-n} \\ [0.3em] 0 &amp; amp; 0 &amp; amp; -1 &amp; amp; 0 \ end {bmatrix} \! \! \ Begin {bmatrix} P_x \\ P_y \\ P_z \\ 1 \ end {bmatrix}."></div><br>  With this conversion, <img src="https://habrastorage.org/getpro/habr/post_images/cdb/5e6/de3/cdb5e6de3f61e1e5dd6696e8f62e0de1.svg" alt="\ mathit {w}">  - coordinate of the transformed point in the homogeneous space of the <em>clip</em> has a sign opposite to the sign <img src="https://habrastorage.org/getpro/habr/post_images/452/3aa/0ea/4523aa0ea566bad357101800bbfa6d87.svg" alt="\ mathit {z}">  coordinates of a point in the space of the camera view. <br><br>  The features of the distortion of the space by the standard transformation matrix are visible from Fig.4: <br><img src="https://habrastorage.org/getpro/habr/post_images/452/3aa/0ea/4523aa0ea566bad357101800bbfa6d87.svg" alt="\ mathit {z}">  -coordinate from the space of the pyramid of visibility is reflected in the range [-1, 1] NDC, and the infinite range behind the far plan of the pyramid of visibility from the view camera is compressed into a finite gap <img src="https://habrastorage.org/getpro/habr/post_images/d96/f33/c00/d96f33c00ac10e95df6fe34cba9ad128.svg" alt="\ left [1, \ tfrac {f + n} {f-n} \ right]">  inside the NDC;  the finite distance from the camera to the middle plane along the Z axis extends to an infinite gap <img src="https://habrastorage.org/getpro/habr/post_images/e22/b7b/2c2/e22b7b2c27a6c46b1fa776203ab566da.svg" alt="] {- \ infty}, -1]">  NDC;  and the points along the Z axis, which are up to the camera, are reflected in the range <img src="https://habrastorage.org/getpro/habr/post_images/46d/1f3/cbb/46d1f3cbb33752de8f56a6c86b2ed913.svg" alt="\ left [\ tfrac {f + n} {f-n}, \ infty \ right [">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7e/e5d/47f/b7ee5d47f54b98e144d73960775aa163.svg" alt="Normalized Device Coordinates" width="90%"></div><br><br>  <strong>Fig</strong> .  4. Reflection <img src="https://habrastorage.org/getpro/habr/post_images/452/3aa/0ea/4523aa0ea566bad357101800bbfa6d87.svg" alt="\ mathit {z}">  - coordinates of a point from the camera space of the view to the space of <em>normalized device coordinates</em> (NDC - <em>normalized device coordinates</em> ). <br><br>  Replacing the foreground of the pyramid of visibility by the cut-off plane, we must preserve the main features of the perspective transformation matrix, <img src="https://habrastorage.org/getpro/habr/post_images/452/3aa/0ea/4523aa0ea566bad357101800bbfa6d87.svg" alt="\ mathit {z}">  -coordinate point lying on the modified near plane, in normalized coordinates of the device (NDC) should remain equal to -1.  All further observations are universal for any <em>reversible</em> projection matrices, and the use of the projection matrix from <em>Expression</em> (10) serves only to illustrate the general process of modifying the transformation matrix. <br><br>  If a <img src="https://habrastorage.org/getpro/habr/post_images/8bf/b44/8ae/8bfb448aec206851b4262154c79755ee.svg" alt="\ vec {C} {^ '}">  is one of the planes bounding the clip space, and at the same time the transformation matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  is a projection matrix from the camera space to the clip space, it‚Äôs not difficult to map this plane <img src="https://habrastorage.org/getpro/habr/post_images/8bf/b44/8ae/8bfb448aec206851b4262154c79755ee.svg" alt="\ vec {C} {^ '}">  into the camera space from the clip space by means of the transposed matrix <img src="https://habrastorage.org/getpro/habr/post_images/fa6/73d/7eb/fa673d7eb789135b067bcb8540db4572.svg" alt="\ mathbf {M} ^ \ mathrm {T}">  , which obviously follows from <em>Expression</em> (9): <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/853/5c6/326/8535c6326bd0ccb37584caab2210329d.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/286/11d/2ab/28611d2ab7cf2c0bed56f0d4401d6f43.svg" alt="\ vec {C} = \ left [\ left (\ mathbf {M} ^ {- 1} \ right) {} ^ {- 1} \ right] {} ^ \ mathrm {T} \ vec {C} {^ '} = \ mathbf {M} ^ \ mathrm {T} \ vec {C} {^'}"></div><br><h2>  Modifying the near plan of the pyramid of visibility </h2><br>  First, extract from an arbitrary projection matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  four-dimensional vectors corresponding to the six clipping planes of the visibility pyramid.  Eric Lengel proceeded from the fact that the planes in the clip space are always the same: the normal of any plane is parallel to one of the main coordinate axes. <br><br>  Figure 5 shows the elements ‚Äú <img src="https://habrastorage.org/getpro/habr/post_images/b3a/99e/e82/b3a99ee824b450cb0fa53a6eed458385.svg" alt="x">  - <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  ¬ª <em>Three</em> -dimensional <em>slice</em> four-dimensional homogeneous space of the clip.  Inside this <em>slice</em> <img src="https://habrastorage.org/getpro/habr/post_images/cdb/5e6/de3/cdb5e6de3f61e1e5dd6696e8f62e0de1.svg" alt="\ mathit {w}">  -coordinate of any point is equal to 1, thus, and <img src="https://habrastorage.org/getpro/habr/post_images/cdb/5e6/de3/cdb5e6de3f61e1e5dd6696e8f62e0de1.svg" alt="\ mathit {w}">  -coordinate of each plane is equal to 1, and, of course, one of <img src="https://habrastorage.org/getpro/habr/post_images/b3a/99e/e82/b3a99ee824b450cb0fa53a6eed458385.svg" alt="x">  -, <img src="https://habrastorage.org/getpro/habr/post_images/97f/a10/8ab/97fa108abfcd32434b0b3973aa8c30a4.svg" alt="y">  -, or <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  -coordinates are equal to ¬± 1, which is reflected in <em>Table</em> 1. To understand <em>Table</em> 1, you need to take another careful look at <em>Expression</em> (11): the sum of some two columns of the matrix <img src="https://habrastorage.org/getpro/habr/post_images/fa6/73d/7eb/fa673d7eb789135b067bcb8540db4572.svg" alt="\ mathbf {M} ^ \ mathrm {T}">  nothing more than the sum of the corresponding two rows of the matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/43c/afd/cf343cafd6c79a51b64c4560ec4ece48.svg" width="50%" alt="slice of homogeneous clip space"></div><br><br>  <strong>Fig</strong> .  5. Normal vectors for left, right, near and far planes bounding the homogeneous cubic space of a clip.  Normal vectors for the upper and lower planes of the clip space are directed <em>from</em> and <em>to the</em> observer. <br><br>  <strong>Tab</strong> .  1. The relationship between the coordinates of the clip space and the space of the truncated visibility pyramid of the view camera.  Projection matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  translates the camera space of the view into the space of the clip, and the designation <img src="https://habrastorage.org/getpro/habr/post_images/37a/915/1d3/37a9151d3855116d606a989188b6ebbc.svg" alt="\ mathbf {M} _i">  presents <img src="https://habrastorage.org/getpro/habr/post_images/eb4/e6c/9d8/eb4e6c9d80848742431282fecce98e45.svg" alt="i">  -th row of the matrix <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  . <br><img src="https://habrastorage.org/getpro/habr/post_images/a60/d8b/3b8/a60d8b3b8d95824f9f59f98b57dc868c.svg" alt="\ begin {center} \ begin {array} {rcc} \ hline \ textbf {Frustum plane} &amp; amp; \ textbf {Clip-space} &amp; amp; \ textbf {Camera-space} \\ \ hline \ text {Near} \ qquad {} &amp; amp; \ langle 0, 0, 1,1 \ rangle &amp; amp; \ vec {M} _4 + \ vec {M} _3 \\ \ text {Far} \ qquad {} &amp; amp; \ langle 0, 0, -1,1 \ rangle &amp; amp; \ vec {M} _4 - \ vec {M} _3 \\ \ text {Left} \ qquad {} &amp; amp; \ langle 1, 0, 0.1 \ rangle &amp; amp; \ vec {M} _4 + \ vec {M} _1 \\ \ text {Right} \ qquad {} &amp; amp; \ langle -1, 0, 0.1 \ rangle &amp; amp; \ vec {M} _4 - \ vec {M} _1 \\ \ text {Bottom} \ qquad {} &amp; amp; \ langle 0, 1, 0,1 \ rangle &amp; amp; \ vec {M} _4 + \ vec {M} _2 \\ \ text {Top} \ qquad {} &amp; amp; \ langle 0, -1, 0,1 \ rangle &amp; amp; \ vec {M} _4 - \ vec {M} _2 \\ \ hline \ end {array} \ end {center}"><br><br>  Let be <img src="https://habrastorage.org/getpro/habr/post_images/01b/a17/9c2/01ba179c2ee60b3a9764db69ef0086a2.svg" alt="\ vec {C} = \ langle C_x, C_y, C_z, C_w \ rangle">  - some plane shown in Fig.  6, in the coordinate space of the camera of the form, by means of which we intend to limit our geometry.  The camera is located on the <em>negative side of the</em> plane (from the side opposite to the direction of the plane vector), therefore <img src="https://habrastorage.org/getpro/habr/post_images/14d/b4d/bc2/14db4dbc28b0c820b77fbc73e47f98c5.svg" alt="C_w &amp; lt; 0">  .  It is with this plane that we intend to replace the near plan of the pyramid of visibility, therefore, in accordance with the ratios of <em>Table</em> 1, for <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  must be performed: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/07a/b8a/8df/07ab8a8df41b989e7e0ce890eeffe6df.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/e32/d4f/0c0e32d4f102a71e4d13cd1daa7bccc0.svg" alt="\ vec {C} = \ vec {M} _4 + \ vec {M} _3."></div><br>  We cannot modify the fourth row of the matrix of the perspective projection, since  it is used to reflect negative <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  - coordinates in <img src="https://habrastorage.org/getpro/habr/post_images/3f0/f5b/d4f/3f0f5bd4f659db43deb78e37c78105a5.svg" alt="w">  - coordinate and necessary for the further correct operation of the graphic conveyor.  However, with the second component of the right side of <em>Expression</em> (12), we can do more freely: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/e43/5c4/d42/e435c4d42fc60eed80548fbba57c5e28.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f20/32d/c10/f2032dc1068a154f791b57a712197138.svg" alt="\ vec {M} _3 {^ '} = \ vec {C} - \ vec {M} _4."></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fb/ddc/87e/4fbddc87e74d0b30c18a1a4caaf2c24e.svg" width="70%" alt="cut clip space"></div><br>  <strong>Fig</strong> .  6. Replacing the near plane of the pyramid of visibility by the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since, according to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1, the third row of the projection matrix is ‚Äã‚Äãincluded in the expression for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distant plan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the visibility pyramid, it is obvious that its modification should be taken into account for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distant plan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/50e/8ab/7e1/50e8ab7e1b6684fa6e67441e2a27071c.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50d/71b/9fb/50d71b9fbf5646516d43d37372d3372e.svg" alt="\begin{array}{|c|}\hline
\;\\
\vec{F}=\vec{M}_4-\vec{M}_3^'}\;\\[0.3em]   
\qquad {}=2\vec{M}_4-\vec{C}\;\\[1em]
\hline \end{array}\:."></div><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'en', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><br>  And this result is a noticeable problem for a perspective projection: since <img src="https://habrastorage.org/getpro/habr/post_images/eaf/5bc/e98/eaf5bce98d5cfef38a65f14338b4c4ad.svg" alt="\ vec {M} _4 = \ langle0, 0, -1, 0 \ rangle">  , then the <em>background</em> and the <em>foreground of the</em> pyramid of visibility cease to be parallel, in the case of non-zero values ‚Äã‚Äãfor <img src="https://habrastorage.org/getpro/habr/post_images/2b4/418/788/2b4418788455fae2329224c21298c289.svg" alt="C_x">  and <img src="https://habrastorage.org/getpro/habr/post_images/c0a/2b7/2c7/c0a2b72c74ae81b34f804cfebdf16f3d.svg" alt="C_y">  .  Moreover, the shape of a truncated pyramid becomes extremely undesirable in the subsequent rendering: consider some point <img src="https://habrastorage.org/getpro/habr/post_images/be9/93d/b2c/be993db2cf7dbcbb3c1946c19209203b.svg" alt="\ vec {P} = \ langle x, y, 0, w \ rangle">  for which is performed <img src="https://habrastorage.org/getpro/habr/post_images/37e/41e/102/37e41e1020c6bce81f86835d8bb8bbbb.svg" alt="\ vec {C} \ cdot \ vec {P} = 0">  and this entails equality to zero and <img src="https://habrastorage.org/getpro/habr/post_images/7e7/9dd/119/7e79dd1197ab048d1117a69974739ee7.svg" alt="\ vec {F} \ cdot \ vec {P}">  , from which we must conclude that our new near and far plans will intersect in a manner similar to that shown in <em>Fig</em> .  7 (a) <br><br>  The projection of the depth of the point, which previously reached a maximum in the background, and which we need for the process of graphic rasterization, is no longer a projection along the axis <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  rather, it becomes a value depending on the position between the near and far plans.  The dependence of the projection depth on the direction inside the visibility pyramid will seriously affect the correctness of <em>the depth buffer</em> values.  However, this undesirable effect can be reduced to a level acceptable for the task of rasterization, reducing the angle between near and far plans to the minimum possible.  Like any plane, a plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  it is possible to scale, and this property of it is most welcome in our case.  Scaling plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  will affect the orientation of the far plan <img src="https://habrastorage.org/getpro/habr/post_images/930/852/0ec/9308520ecd85ef8449fe93731ba98e40.svg" alt="\ vec {F}">  , so we only need to adjust the scaling factor so as to minimize the angle between <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  and <img src="https://habrastorage.org/getpro/habr/post_images/930/852/0ec/9308520ecd85ef8449fe93731ba98e40.svg" alt="\ vec {F}">  without prejudice to the contents of the scene inside the visibility pyramid as shown in <em>Fig</em> .  7 (b). <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22c/23e/64a/22c23e64ab05919c2cdecb9352d53a87.svg" width="70%" alt="modified far plane"></div><br>  <strong>Fig</strong> .  7. (a) The intersection of the amended in accordance with <em>Expression</em> (14) of the far plan <img src="https://habrastorage.org/getpro/habr/post_images/930/852/0ec/9308520ecd85ef8449fe93731ba98e40.svg" alt="\ vec {F}">  with modified foreground <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  at " <img src="https://habrastorage.org/getpro/habr/post_images/b3a/99e/e82/b3a99ee824b450cb0fa53a6eed458385.svg" alt="x">  - <img src="https://habrastorage.org/getpro/habr/post_images/97f/a10/8ab/97fa108abfcd32434b0b3973aa8c30a4.svg" alt="y">  "-Planes.  (b) Scaling the Middle Plan <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  by parameter <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha">  , introduced by <em>Expression</em> (17) changes the angle between the near and far plan to the minimum possible, without damaging the initial type of truncation.  The shaded area refers to the amount of space that is not truncated. <br><br>  Let be <img src="https://habrastorage.org/getpro/habr/post_images/9ed/cab/fb9/9edcabfb9e4abdcb82c99abae7743ac5.svg" alt="\ vec {C} {^ '} = \ left (\ mathbf {M} ^ {- 1} \ right) {} ^ \ mathrm {T} \ vec {C}">  is a projection of the <em>new middle plane</em> in the clip space ( <img src="https://habrastorage.org/getpro/habr/post_images/49d/bb2/c97/49dbb2c9708b24b0672cc275e5a150fc.svg" alt="\ mathbf {M}">  - the original projection matrix).  Angle <img src="https://habrastorage.org/getpro/habr/post_images/707/cc2/456/707cc2456058b43f8419b6d4d34cf409.svg" alt="\ vec {Q} ^ '">  inside the visibility pyramid, lying opposite the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  will have the following coordinates: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/61c/5ff/a31/61c5ffa314b3c4d942ddbd817ad3761b.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a6/eb1/098/9a6eb10989720335db91602368c36f8d.svg" alt="\ vec {Q} {^ '} = \ langle sgn (C {^'} _x), sgn (C {^ '} _y), 1, 1 \ rangle."></div><br>  For most perspective projections, component signs <img src="https://habrastorage.org/getpro/habr/post_images/807/2d2/f34/8072d2f346130f8dad6af68f9171d9af.svg" alt="C {^ '} _x">  and <img src="https://habrastorage.org/getpro/habr/post_images/ba9/a32/581/ba9a3258189ec1dce7767f9cafd1976f.svg" alt="C {^ '} _y">  the transformed planes coincide with the signs of the corresponding components <img src="https://habrastorage.org/getpro/habr/post_images/2b4/418/788/2b4418788455fae2329224c21298c289.svg" alt="C _x">  and <img src="https://habrastorage.org/getpro/habr/post_images/c0a/2b7/2c7/c0a2b72c74ae81b34f804cfebdf16f3d.svg" alt="C _y">  that allows us to use the signs of the coordinate decomposition of the original plane. <br>  Having components of a converted angle <img src="https://habrastorage.org/getpro/habr/post_images/eed/ad9/7af/eedad97afb4b81b8b7f2ecd4bc56e06b.svg" alt="\ vec {Q} {^ '}">  , we can already calculate the components of the original angle <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  lying opposite the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  , as <img src="https://habrastorage.org/getpro/habr/post_images/155/2a8/a19/1552a8a1935f226dc57953ef6af5533b.svg" alt="\ vec {Q} = \ mathbf {M} {^ {- 1}} \ vec {Q} {^ '}">  .  In the normal visibility pyramid, point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  at the apex of the angle formed by the intersection of two side planes and the far plane, lying opposite the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  that is farthest from the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  point. <br><br>  To our <em>distant plan</em> contained a point <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  condition must be met <img src="https://habrastorage.org/getpro/habr/post_images/b30/9ec/364/b309ec364d7db542a538058af4bff26f.svg" alt="\ vec {F} \ cdot \ vec {Q} = 0">  Let's add <em>Expression</em> (14) scaling the plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  a factor <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha"><br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/2ba/fa6/21f/2bafa621fd89b5e10fbddab891cd6278.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/cd3/dd3/dadcd3dd3bab38c47c8eb266b599824d.svg" alt="\ vec {F} = 2 \ vec {M} _4- \ alpha \ vec {C}"></div><br>  and we find from the condition <img src="https://habrastorage.org/getpro/habr/post_images/b30/9ec/364/b309ec364d7db542a538058af4bff26f.svg" alt="\ vec {F} \ cdot \ vec {Q} = 0">  scaling factor: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/926/801/ded/926801dedc4e64d2c029df06e3a99da6.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/5e7/8ce/ba25e78cea94b969e007fbf35793bca4.svg" alt="\ alpha = \ frac {2 \ vec {M} _4 \ cdot \ vec {Q}} {\ vec {C} \ cdot \ vec {Q}."></div><br>  Replacement <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  on <img src="https://habrastorage.org/getpro/habr/post_images/9a4/6e2/cba/9a46e2cbaf565ee9c5fe6adc063f665f.svg" alt="\ alpha \ vec {C}">  in <em>Expression</em> (13) <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/d7b/fe3/165/d7bfe3165983e5a404e01de82e68dce2.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/189/2e3/ed7/1892e3ed7854d381ed7c6156d9d43193.svg" alt="\ vec {M} _3 {^ '} = \ alpha \ vec {C} - \ vec {M} _4"></div><br>  and allow us to optimally orient the distant plan of the pyramid of visibility, as shown in <em>Fig</em> .  7 (b) (this replacement technique works correctly and for the visibility pyramid, the far plane of which is removed to infinity, - the case of an <em>infinite projection matrix</em> , - for this it is enough to require that the far plane be parallel to one of the two generators <em>opposite to the plane</em> <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  <em>angle of</em> faces). <br><br><h3>  Practical use of the observations made above </h3><br>  All theoretical studies that have been done earlier extend to any reversible projection matrices, but since, as an example, the standard for OpenGL matrix in <em>Expression</em> (10) has already been used, it is logical to continue the chain of examples with it. <br><br>  The inverse matrix to it will look like this: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/2c6/039/7ce/2c60397ce093f75f4f20810802a83635.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab3/9d9/0de/ab39d90de244b6218756fb5f1adcaa89.svg" alt="\ mathbf {M} {^ {- 1}} = \ begin {bmatrix} \ frac {r-l} {2n} &amp; amp; 0 &amp; amp; 0 &amp; amp; \ frac {r + l} {2n} \\ [0.3em] 0 &amp; amp; \ frac {tb} {2n} &amp; amp; 0 &amp; amp; \ frac {t + b} {2n} \\ [0.3em ] 0 &amp; amp; 0 &amp; amp; 0 &amp; amp; -1 \\ [0.3em] 0 &amp; amp; 0 &amp; amp; \\ frac {f-n} {2nf} &amp; amp; \ frac {f + n} {2nf} \ end {bmatrix}"></div><br>  Get the value for the third row of the modified projection matrix, as suggested by <em>Expression</em> (18) with <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha">  from <em>Expression</em> (17): <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/952/ad0/37c/952ad037c9407a4e3705b00f63f7be3f.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a2/717/867/6a2717867529f653f8ffb4fde1f6c49f.svg" alt="\ vec {M} _3 {^ '} = {\ frac {2 \ vec {M} _4 \ cdot \ vec {Q}} {\ vec {C} \ cdot \ vec {Q}} \ vec {C} - \ vec {M} _4"></div><br>  Insofar as <img src="https://habrastorage.org/getpro/habr/post_images/eaf/5bc/e98/eaf5bce98d5cfef38a65f14338b4c4ad.svg" alt="\ vec {M} _4 = \ langle 0, 0, -1, 0 \ rangle">  then this expression can be written as <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/a03/597/c0b/a03597c0b9019504299999903478d9db.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/791/5d3/a177915d3299d71f9e3796ee4fc091d4.svg" alt="\ vec {M} _3 {^ '} = {\ frac {-2Q_z} {\ vec {C} \ cdot \ vec {Q}} \ vec {C} + \ langle 0, 0, 1, 0 \ rangle"></div><br>  Multiplying the inverse matrix from <em>Expression</em> (19) by <img src="https://habrastorage.org/getpro/habr/post_images/eed/ad9/7af/eedad97afb4b81b8b7f2ecd4bc56e06b.svg" alt="\ vec {Q} {^ '}">  from <em>Expression</em> (15), we get <img src="https://habrastorage.org/getpro/habr/post_images/5e5/ab4/52c/5e5ab452cb6a4b2aeb2e9139997a2484.svg" alt="\ vec {Q}">  : <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/ca6/f06/65d/ca6f0665d668e6c48451c6a358465f50.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/1a8/5b3/1e81a85b345593f225d3676ec205e7ad.svg" alt="\ vec {Q} = \ begin {bmatrix} sgn (C_x) \ frac {rl} {2n} + \ frac {r + l} {2n} \\ [0.5em] sgn (C_x) \ frac {tb} { 2n} + \ frac {t + b} {2n} \\ [0.5em] -1 \\ [0.3em] 1 / f \ end {bmatrix}"></div><br>  To ensure the correctness of the developed method of modifying the projection matrix, consider the special case of the location of the cut-off plane <img src="https://habrastorage.org/getpro/habr/post_images/24a/5f6/6b6/24a5f66b65f588d630bfe45511513f25.svg" alt="\ vec {C}">  perpendicular to the axis <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  i.e.  parallel to the normal <em>near plan of the</em> pyramid of visibility, - in the coordinate record such a plane will look like <img src="https://habrastorage.org/getpro/habr/post_images/08c/c17/dae/08cc17dae0a976f115ddf59e09c46169.svg" alt="\ vec {C} = \ langle 0, 0, -1, -d \ rangle">  where <img src="https://habrastorage.org/getpro/habr/post_images/506/b81/7c2/506b817c262c43e9c4af46ee3b0fd081.svg" alt="d">  - some positive distance.  It is natural to expect that in the new projection matrix for the visibility pyramid, whose <em>near-plan</em> is removed at a distance <img src="https://habrastorage.org/getpro/habr/post_images/506/b81/7c2/506b817c262c43e9c4af46ee3b0fd081.svg" alt="d">  from the camera, the <em>far plan</em> will remain in its previous position. <br><br>  Scalar product <img src="https://habrastorage.org/getpro/habr/post_images/6e4/23b/8cf/6e423b8cf518b151aa8fc3708fa67ebb.svg" alt="\ vec {C} \ cdot \ vec {Q}">  for such a plane will be equal <img src="https://habrastorage.org/getpro/habr/post_images/6df/1b3/929/6df1b392943331608be3db32937989dc.svg" alt="1-d / f">  , and <em>Expression</em> (21) to calculate the third row of the modified projection matrix will result in <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/4b4/ebb/3b6/4b4ebb3b69f939b30e819de0370cc580.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60e/f04/030/60ef040308576b153015992acf2d38e1.svg" alt="\ begin {array} {l} \ vec {M} _3 {^ '} = {\ frac {2} {1-d / f}} \ langle 0, 0, -1, -d \ rangle + \ langle 0, 0, 1, 0 \ rangle \\ [0.3em] \ qquad {} = \ langle 0, 0, - \ frac {f + d} {fd}, - \ frac {2fd} {fd} \ rangle \ end { array}"></div><br>  - result, coincided with the expectations: with <img src="https://habrastorage.org/getpro/habr/post_images/6f6/420/7b5/6f64207b524dc2df48d2fd282d385cf6.svg" alt="d = n">  the third row of the modified matrix coincides with the third row of the projection matrix from <em>Expression</em> (10). <br><br>  As already assumed above, one should expect that the process of rasterization will not be as usual as in the case of the unmodified visibility pyramid.  The full range of <em>depth buffer</em> values ‚Äã‚Äãwill not be achieved along different directions within the visibility pyramid due to a change in the pyramid geometry.  Take a vector of arbitrary direction <img src="https://habrastorage.org/getpro/habr/post_images/570/95a/32a/57095a32a23c700d3a77200741800fd9.svg" alt="\ vec {V} = \ langle V_x, V_y, V_z, 0 \ rangle">  in the space of the camera of the kind for which <img src="https://habrastorage.org/getpro/habr/post_images/c45/7b5/a02/c457b5a02bbbdb36585d658e90942605.svg" alt="V_z &amp; lt; 0">  and examine normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  -coordinate point <img src="https://habrastorage.org/getpro/habr/post_images/f6f/f62/0ae/f6ff620ae30164d2de1acaa1eacf7ced.svg" alt="\ langle 0, 0, 1, 0 \ rangle + s \ vec {V}">  located inside the visibility pyramid: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/014/83a/d67/01483ad675784a0786e529e3bb753797.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffb/a23/5d0/ffba235d0fc365768d4928d05373f2cf.svg" alt="\ begin {array} {l} z (s) = {\ cfrac {(\ mathbf {M} {^ '} \ langle sV_x, sV_y, sV_z, 1 \ rangle) _z} {(\ mathbf {M} {^ '} \ langle sV_x, sV_y, sV_z, 1 \ rangle) _w}} \\ [0.8em] \ qquad {} = {\ cfrac {(\ alpha \ vec {C} - \ vec {M} _4) \ cdot \ langle sV_x, sV_y, sV_z, 1 \ rangle} {\ vec {M} _4 \ cdot \ langle sV_x, sV_y, sV_z, 1 \ rangle}} \ end {array},"></div><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha">  -scaling factor introduced by <em>Expression</em> (17).  For <img src="https://habrastorage.org/getpro/habr/post_images/eaf/5bc/e98/eaf5bce98d5cfef38a65f14338b4c4ad.svg" alt="\ vec {M} _4 = \ langle 0, 0, -1, 0 \ rangle">  . <em>Expression</em> (24) becomes <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/aca/485/33c/aca48533ce60dc985055a47faa7e12e1.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/340/261/0e0/3402610e0c3688df481494edbc2a056f.svg" alt="\ begin {array} {l} z (s) = \ cfrac {\ alpha sC_xV_x + \ alpha sC_yV_y + \ alpha sC_zV_z + sV_z + \ alpha C_w} {- sV_z} \\ [0.8em] \ qquad {} = \ cfrac {\ alpha s (\ vec {C} \ cdot \ vec {V}) + sV_z + \ alpha C_w} {- sV_z} \ end {array}."></div><br>  We assume that the scalar product <img src="https://habrastorage.org/getpro/habr/post_images/d22/907/086/d22907086ba8a190dec8ddbb7dcb306f.svg" alt="\ vec {C} \ cdot \ vec {V} \ geq 0">  because otherwise the point <img src="https://habrastorage.org/getpro/habr/post_images/f6f/f62/0ae/f6ff620ae30164d2de1acaa1eacf7ced.svg" alt="\ langle 0, 0, 1, 0 \ rangle + s \ vec {V}">  would lie outside the pyramid of visibility.  Consider the situation when <img src="https://habrastorage.org/getpro/habr/post_images/be9/24f/2c8/be924f2c88a720f8d086c1b33f34bd69.svg" alt="s">  tends to infinity: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/410/293/a52/410293a52116ce84b64bda4985b5418a.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/729/34a/c8b/72934ac8b52a7a7bd55ebbc26bb9d0b8.svg" alt="\ lim_ {s \ to \ infty} z (s) = - \ cfrac {\ alpha (\ vec {C} \ cdot \ vec {V}) + V_z} {V_z},"></div><br>  the resulting expression indicates the maximum attainable value of the normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  coordinates in the direction <img src="https://habrastorage.org/getpro/habr/post_images/e41/71a/895/e4171a895ba6bad32566b0e671df4636.svg" alt="\ vec {V}">  . <br>  Investigate the direction <img src="https://habrastorage.org/getpro/habr/post_images/cbb/711/5be/cbb7115be8485c21415c34d476852054.svg" alt="\ vec {V} = \ langle 0, 0, -1, 0 \ rangle">  along the direct view from the camera position: the limit value indicated by <em>Expression</em> (26) is less than one if the condition is met <img src="https://habrastorage.org/getpro/habr/post_images/6ed/4f5/d2d/6ed4f5d2dd649ce7b712c82f9c1e4789.svg" alt="\ alpha C_z &amp; gt; -2">  .  In this case, <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  -coordinate <em>far plan</em> <img src="https://habrastorage.org/getpro/habr/post_images/930/852/0ec/9308520ecd85ef8449fe93731ba98e40.svg" alt="\ vec {F}">  , given by <em>Expression</em> (16), is less than zero, and the <em>far plan is</em> not a plane limiting the scope of the pyramid of visibility.  Since the <em>far plan</em> may not be reachable along the direction <img src="https://habrastorage.org/getpro/habr/post_images/e41/71a/895/e4171a895ba6bad32566b0e671df4636.svg" alt="\ vec {V}">  , the range of normalized values ‚Äã‚Äãfor <em>the depth buffer</em> may be significantly narrower than in the case of the ordinary visibility pyramid. <br><br>  A good practice for a programmer would be, before approving the chosen spatial model for further work, to investigate the behavior of the normalized coordinate inside the modified ( <em>oblique</em> | oblique frustum) visibility pyramid.  Having detected problem areas in time, he can correct either the position of the camera or change the inclination angle of the section plane so as to simplify the work of the depth buffer, bringing it as close as possible to the normal mode.  The cost of such an action will not be particularly significant, but the result will calm the perfectionist. <br>  Continuing to exploit the standard projection matrix from <em>Expression</em> (10), it is easy to proceed to the next example of its use for studying the values ‚Äã‚Äãof normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  Coordinates inside a modified visibility pyramid: <br><br>  Let us assume that the plane, which cuts off geometry that we do not like, and with which we substitute the <em>near plan</em> of the visibility pyramid, is represented in guide cosines as <img src="https://habrastorage.org/getpro/habr/post_images/4ca/f30/f0a/4caf30f0a165a428cdcf4ec4f682b6a9.svg" alt="\ vec {C} = \ langle C_x, C_y, -C_z, -d \ rangle">  and, in our particular case, <img src="https://habrastorage.org/getpro/habr/post_images/8ae/dde/e9d/8aeddee9dfd61a6d22985633a77a782d.svg" alt="C_x, C_y, C_z">  have positive values ‚Äã‚Äã(the plane lies opposite the upper right corner of the pyramid), while <img src="https://habrastorage.org/getpro/habr/post_images/bfa/ab7/15f/bfaab715fafecd9b9668b4b49bf7585a.svg" alt="C_z">  - angle between negative axis direction <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  and the normal vector of our plane.  Consider changing the normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  Coordinates along the negative axis direction <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  depending on the angle between the normal vector of the plane of the <em>near plane</em> and the negative direction of the axis <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  , and the distance from the camera to the <em>near plan</em> . <br><br>  Scalar product <img src="https://habrastorage.org/getpro/habr/post_images/6e4/23b/8cf/6e423b8cf518b151aa8fc3708fa67ebb.svg" alt="\ vec {C} \ cdot \ vec {Q}">  for this case, taking into account <em>Expression</em> (22) will give the following result: <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/8e1/119/494/8e11194948559c61d194cc15615d171c.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/6ec/69e/4c16ec69ef59999924edf9f7b3140759.svg" alt="\ vec {C} \ cdot \ vec {Q} = \ cfrac {rfC_x + tfC_y-n (d-fC_z)} {nf},"></div><br>  and the third row of the transformed projection matrix will take the form <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/35d/ee9/455/35dee945511fd0dccad4654834d5cce0.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/456/7f6/699/4567f66996d0f42fb4d1e977a8448347.svg" alt="\ begin {array} {l} \ vec {M} _3 {^ '} = {\ cfrac {2nf \ langle C_x, C_y, -C_z, -d \ rangle} {rfC_x + tfC_y-n (d-fC_z)} + \ langle 0, 0, 1, 0 \ rangle} \ end {array}."></div><br>  Consider the behavior of the normalized coordinate. <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  in the direction of the front view from the camera for points <img src="https://habrastorage.org/getpro/habr/post_images/625/5c1/afa/6255c1afae4014fee64d7e464bd4432a.svg" alt="\ vec {P} = \ langle 0, 0, P_z, 1 \ rangle">  from a range of values <img src="https://habrastorage.org/getpro/habr/post_images/685/3d5/234/6853d52345dfea8d07c021e5c1ccfc14.svg" alt="P_z \ in [-n, -f]">  : normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  Coordinate for this case will be <br><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/0cc/5af/370/0cc5af3700147a5cb06d53c68bc95414.svg"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/54b/3a0/4a554b3a0e3949a17dbff9245dd72845.svg" alt="z = {\ frac {P_z ^ '} {P_w ^'}} = - \ cfrac {(rfC_x + tfC_y-n (d + fC_z)) P_z-2nfd} {(rfC_x + tfC_y-n (d-fC_z)) P_z} \; ."></div><br>  The last <em>expression</em> is quite suitable for the purposes of numerical research.  An example of such a study can be seen in Fig.  8. The range of normalized values ‚Äã‚Äãintended for the depth buffer narrows greatly with increasing angle between the normal of the plane and the negative direction of the axis. <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  , also significantly degrade the accuracy of the depth buffer can move the <em>near plan</em> in the direction from the camera to the <em>far plan</em> (it is known that too close to the camera <em>near the plan</em> also adversely affects the values ‚Äã‚Äãof the normalized coordinates). <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/33f/20c/54c33f20c47c3fb794124faa2d172114.svg" alt="modified far plane" width="80%"></div><br>  <strong>Fig</strong> .  8. Narrowing the range of normalized <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  -coordinates in the direction of the projection <img src="https://habrastorage.org/getpro/habr/post_images/cbb/711/5be/cbb7115be8485c21415c34d476852054.svg" alt="\ vec {V} = \ langle 0, 0, -1, 0 \ rangle">  , depending on the angle between the normal vector of the <em>near</em> (section) plane and the negative direction of the axis <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  , and the distance from the camera to the <em>near</em> (secant) plane.  Values ‚Äã‚Äãclose to 1 correspond to the situation when the spatial point under study is located near the modified <em>far plan</em> , while the <em>near plan</em> is far enough from the <em>far plan</em> and its normal vector is slightly deviated from the negative axis direction. <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  .  With an increase in the angle and movement of the <em>near plan</em> in the direction from the camera, the range of normalized values <img src="https://habrastorage.org/getpro/habr/post_images/f87/94f/c38/f8794fc38719169aa7908a7e563e27d3.svg" alt="z">  -coordinates are narrowed down to values ‚Äã‚Äãunsuitable for the operation of most <em>depth buffers</em> . <br><br><h2>  Conclusion </h2><br>  The programmer in the process of developing an application often has to find a compromise between speed and realistic rendering.  The technique outlined in this article allows not only to achieve maximum performance on the widest range of devices, but also helps to determine the situation in which it is desirable to edit the scene for its most favorable display. <br><br>  Combining the processes of modifying the pyramid of visibility and testing the operation of the depth buffer for the modified pyramid (or taking into account the observations made above) is the key to the high quality of the final result of the hard work of the programmer. <br><hr><br><h3>  Literature </h3><br>  [one] <a name="Eric"></a>  Eric Lengyel, <em>Oblique View Frustum Depth Projection and Clipping</em> .  <a href="http://www.terathon.com/lengyel/Lengyel-Oblique.pdf">Journal of Game Development, Vol.</a>  <a href="http://www.terathon.com/lengyel/Lengyel-Oblique.pdf">1, No.</a>  <a href="http://www.terathon.com/lengyel/Lengyel-Oblique.pdf">2 (March 2005), pp.</a>  <a href="http://www.terathon.com/lengyel/Lengyel-Oblique.pdf">5‚Äì16.</a> <br><br>  [2] Eric Lengyel, <em>Mathematics for 3D Game Programming and Computer Graphics</em> .  Charles River Media, 2002, p.  103 </div><p>Source: <a href="https://habr.com/ru/post/338434/">https://habr.com/ru/post/338434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338424/index.html">IT work in Barcelona, ‚Äã‚Äãbriefly failed</a></li>
<li><a href="../338426/index.html">Three ideas on how to improve development efficiency: the results of the hackathon for Machine Learning in SberTech</a></li>
<li><a href="../338428/index.html">How we teach AI to help find employees</a></li>
<li><a href="../338430/index.html">REQ Labs 2017. Online conference for business and system analysts</a></li>
<li><a href="../338432/index.html">Uptime day 2: Russian IT companies will talk about how to cope with disasters</a></li>
<li><a href="../338436/index.html">learnopengl. Lessons 3.1 (Assimp) + 3.2 (Mesh class)</a></li>
<li><a href="../338438/index.html">Storage Recycling Analysis</a></li>
<li><a href="../338440/index.html">Library of quick path search on the graph</a></li>
<li><a href="../338442/index.html">Stages of development of the Java Online Projects learning project: how it was, an inside look</a></li>
<li><a href="../338444/index.html">VEDO. External electronic document management what it is and how to choose</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>