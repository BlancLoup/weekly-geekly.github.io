<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize complex MySQL queries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 MySQL is a very controversial product. On the one hand, it has an incomparable speed advantage over other databases on the simplest ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize complex MySQL queries</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  MySQL is a very controversial product.  On the one hand, it has an incomparable speed advantage over other databases on the simplest operations / queries.  On the other hand, it has such an undeveloped (if not to say underdeveloped) optimizer that on complex queries it loses outright. <br><br>  First of all, I would like to limit the range of optimization problems to ‚Äúwide‚Äù and large tables.  Say up to 10m records and up to 20Gb in size, with a large number of variable queries to them.  If there are many millions of records in your table, each 100 bytes in size, and five simple possible queries to it - this article is not for you.  <b>NB: MySQL innodb / percona engine is considered - hereinafter simply MySQL.</b> <a name="habracut"></a><br><br>  Most queries are not very complex.  Therefore, it is very important to know how to build an index for use by the necessary query and / or modify the query so that it uses the already existing indices.  We will look at the work of the optimizer for selecting the index of ordinary queries ( <i>select_type = simple</i> ), without joins, subqueries and unions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We discard the simplest cases for very small tables, for which the optimizer often uses <i>type = all</i> (full view) regardless of the presence of indexes - for example, a classifier with 40 records.  MySQL has an algorithm for using multiple indexes ( <i>index merge</i> ), but this algorithm does not work very often, and only without an <i>order by</i> .  The only sensible way to try to use <i>index merge</i> is to sample cases in different columns with <i>OR</i> . <br><br>  Another departure: it is understood that the reader is already familiar with <i>explain</i> .  Often the query itself is slightly modified by the optimizer, so in order to understand why an index was used or not, you should call <pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extended</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> xxx;</code> </pre>  and then <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">warnings</span></span>;</code> </pre>  which will show the query modified by the optimizer. <br><br><h4>  Covering index - from thick tables to indexes </h4><br>  So the task: let us have a fairly simple request that is performed quite often, but for such a frequent call it is relatively slow.  Let's consider the strategy of reducing our query to <i>using index</i> as the quickest choice. <br><br>  Why <i>using index</i> ?  Yes, MySQL uses only B-tree indexes, but nevertheless MySQL tries to keep indexes as much as possible in memory (and even add adaptive hash indexes on top of them) - all this gives Fabulous MySQL performance gains in relation to other databases.  In addition, the optimizer will often prefer to use, though not the best, but already loaded into the memory index, rather than a better one, but on the disk (for <i>type = index / range</i> ).  From here several conclusions: <br><ul><li>  too heavy indices are evil.  Either they will not be used because they are not yet in memory, or they will not be loaded into memory because this will displace other indices. </li><li>  if the size of the index is comparable to the size of the table, or the set of used indices for various frequent queries significantly exceeds the size of the server memory - no significant optimization is achieved. </li><li>  Nuance - index / sort by TEXT - doom yourself to constant <i>using filesort</i> . </li></ul><br>  One subtle point that you sometimes forget about is that MySQL creates only clustered indexes.  Cluster - essentially indicating not the absolute position of the record in the table, but (conditionally) the record of the primary key, which in turn allows you to extract the record itself.  But MySQL, without further ado, in order to do without the second one, comes in simply - expanding any key to the width of the primary key.  Thus, if you have a <i>primary key (ID), key (A, B, C)</i> in the table, then in reality you have a second key not <i>(A, B, C)</i> , but <i>(A, B, C, ID)</i> .  Hence morality ‚Äî the fat primary key is evil. <br><br>  It is necessary to indicate the difference in the caching of requests in different databases.  If PostgreSQL / Oracle caches query plans (like prepare for some timeout), then MySQL just caches the query string (including the value of the parameters) and stores the result of the query.  That is, if you sequentially select <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> AAA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BBB <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> CCC=DDD</code> </pre>  several times, if <i>DDD</i> does not contain changing functions, and the <i>AAA</i> table has not changed (in the sense of the isolation used), the result will be taken directly from the cache.  Pretty controversial improvement. <br><br>  Thus, we believe that we do not just call the same request several times.  Request parameters change, these tables change.  The best option is to use a covering index.  What index will be covering? <br><ol><li>  First, look at the <i>order by</i> clause.  The used index must begin with the same columns as those mentioned in <i>order by</i> , in the same or completely reverse sorting.  If the sorting is not direct or reverse, the index cannot be used.  There is one thing here ... MySQL still does not support indexes with mixed sorts.  The index is always <i>asc</i> .  So if you have an <i>order by A asc, B desc</i> - say goodbye to <i>using index</i> . </li><li>  Columns that are retrieved must be present in the covering index.  Very often this is an impossible condition due to the infinite growth of the index, which, as we know, is evil.  Therefore, there is a way around this point ‚Äî using <i>self join</i> .  That is, the division of the query on the selection of rows and data retrieval.  First, we select only the primary key columns for a given condition (which is always present in the cluster index), and second, the result is join to the selector of all required columns using this primary key.  Thus, we will have a clean <i>using index</i> in the first select, and <i>eq_ref</i> (the essence of multiple <i>const</i> ) for the second select.  So we get something like: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> AAA,BBB,CCC,DDD <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (PK) ¬´<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> b¬ª</code> </pre></li><li>  Next clause <i>where</i> .  Here, in the worst case, we can iterate over the entire index ( <i>type = index</i> ), but if possible we should strive to use functions that do not go beyond <i>type = range</i> ( <i>&gt;,&gt; =, &lt;, &lt;=, like "xxx%"</i> and so on) .  The index used must include all fields from <i>where</i> , in order to save <i>using index</i> .  As noted above - you can try to use <i>index_merge</i> - but often this is simply not possible with difficult conditions. <br></li></ol><br>  Actually, this is all that can be done for the case when we have only one type of request.  Unfortunately, the MySQL optimizer may not always have a covering index and choose it to execute the query.  Well, in that case it is necessary to help the optimizer with the help of standard <i>use / force index</i> hints. <br><br><h4>  Isolation of thick fields from the covering index - from thick to thin indexes </h4><br>  But what to do if we have requests of several types, or different sorts are required and thick fields ( <i>varchar</i> ) are used?  Just count the size of the <i>varchar (100)</i> field index in a million entries.  And if this field is used in different types of queries - for which we have different covering indexes?  Is it possible to keep in memory only ONE index for this thick field, while maintaining the same (or almost the same) performance in different queries?  So - the last point. <br><ol><li>  Thick and thin fields.  Obviously, having several DIFFERENT options for keys using thick fields is an unaffordable luxury.  Therefore, if possible, we should try to have only one key starting at the thick field.  And here it is appropriate to use some artificial replacement conditions.  That is, replace the condition on the thick field with the join according to the results of this condition.  For example: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> A=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fatB=<span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre>  instead of creating the key <i>key (fatB, A),</i> we will create a thin key <i>key (A)</i> and a thick <i>key (fatB)</i> .  And rewrite the condition in the following way. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temporary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> PK <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fatB=<span class="hljs-string"><span class="hljs-string">'test'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (PK) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> A=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> tmp.PK <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre></li></ol><br>  Consequently, we can have many thin keys for different requests and only one thick <i>fatB</i> field.  Real memory savings, with almost full performance. <br><br><h4>  Task for self-analysis </h4><br>  It is required to create a minimum number of keys (in terms of memory) and optimize queries of the form: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> A,B,C,D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> A=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> B=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> C=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> D <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'test%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> A,C,D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> B=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> C=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> D =<span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> B;</code> </pre>  Suppose queries are not reducible to <i>type = range</i> . <br><br><h5>  Bibliography </h5><br><ol><li>  High Performance MySQL, 2nd Edition <br>  Optimization, Backups, Replication, and More <br>  By Baron Schwartz, Peter Zaitsev, Vadim Tkachenko, Jeremy D. Zawodny, Arjen Lentz, Derek J. Balling <br>  Publisher: O'Reilly Media <br>  Released: June 2008 <br>  Pages: 712 </li><li>  <a href="http://www.mysqlperformanceblog.com/">www.mysqlperformanceblog.com</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/154167/">https://habr.com/ru/post/154167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154141/index.html">HP Dynamic VPN technology. Part 1</a></li>
<li><a href="../154149/index.html">Digest news JetBrains from September 11 to October 9</a></li>
<li><a href="../154151/index.html">New attachments in Yandex.Mail</a></li>
<li><a href="../154155/index.html">Lecture number 02: MSP430. Cities and Registers</a></li>
<li><a href="../154165/index.html">The future of the process, or when the law of Moore "die"?</a></li>
<li><a href="../154169/index.html">Using the capabilities of Wolfram Mathematica in .NET applications</a></li>
<li><a href="../154177/index.html">TeamLab - reboot</a></li>
<li><a href="../154179/index.html">AWS: RDS appeared in the Free Tier package</a></li>
<li><a href="../154181/index.html">Freelancer start working in pairs</a></li>
<li><a href="../154185/index.html">Turning the router into an XBee-to-Ethernet Gateway</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>