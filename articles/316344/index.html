<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Caches for "dummies"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cash through the eyes of the "kettle": 


 Cache is a complex system. Accordingly, at different angles, the result can lie in both the real and imagin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Caches for "dummies"</h1><div class="post__text post__text-html js-mediator-article">  Cash through the eyes of the "kettle": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b90/663/2c3/b906632c395145e68b09f70596400f5f.png"></div><br>  Cache is a complex system.  Accordingly, at different angles, the result can lie in both the real and imaginary regions.  It is very important to understand the difference between what we expect and what it really is. <br><br>  Let's scroll through the full situation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Tl; dr: adding to the cache architecture it is important to clearly realize that the cache can be a means of <b>destabilizing the</b> system under load.  See the end of the article. <br><a name="habracut"></a><br>  Imagine that we have access to a database that returns currency rates.  We ask for <a href="http://rates.example.com/%3Fcurrency1%3DXXX%26currency2%3DXXX">rates.example.com/?currency1=XXX&amp;currency2=XXX</a> and in return we get a plain text course value.  Each 1000 database queries for us, for example, cost 1 eurocent. <br><br>  So, now we want to show on our website the dollar against the euro.  To do this, we need to get a course, so on our site we create an API wrapper for convenient use: <br><br>  For example: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//      :) function get_current_rate($currency1, $currency2) { $api_host = "http://rates.example.com/"; $args = http_build_query(array("currency1"=&gt;$currency1, "currency2"=&gt;$currency2)); $rate = @file_get_contents($api_host."?".$args); if ($rate === FALSE) { return $rate; } else { return (float) $rate; } }</span></span></code> </pre> <br>  And in the templates in the right place we insert something like: <br><br><pre> <code class="php hljs"> {{ get_current_rate(<span class="hljs-string"><span class="hljs-string">"USD"</span></span>,<span class="hljs-string"><span class="hljs-string">"EUR"</span></span>)|format(<span class="hljs-string"><span class="hljs-string">".2f"</span></span>) }} USD/EUR</code> </pre> <br>  (well, or even <code>&lt;?=sprintf(".2f", get_current_rate("USD","EUR"))?&gt;</code> , but this is the last century). <br><br>  A naive implementation does the simplest thing you can think of: for each request from the user, ask the remote system and use the answer directly.  This means that now every 1000 views by users of our page cost us a penny more.  It would seem - pennies.  But the project is growing, we already have 1000 regular users who visit the site every day and browse 20 pages, and this is already 6 euros per month, which turns the site from <a href="https://cloud.google.com/appengine/docs/quotas">free</a> to completely comparable to the payment for the cheapest dedicated virtual servers. <br><br>  <b>This is where His Majesty Cash comes onto the scene.</b> <br><br>  Why should we ask a course for each user for each page refresh, if this information is generally not needed for people so often?  Let's just limit the refresh rate to, for example, every 5 seconds.  Users moving from page to page will still see a new number, and we will pay 1,000 times less. <br><br>  No sooner said than done!  Add a few lines: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_current_rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($currency1, $currency2)</span></span></span><span class="hljs-function"> </span></span>{ $cache_key = <span class="hljs-string"><span class="hljs-string">"rate_"</span></span>.$currency1.<span class="hljs-string"><span class="hljs-string">"_"</span></span>.$currency2; <span class="hljs-comment"><span class="hljs-comment">//   https://cloud.google.com/appengine/docs/php/memcache/ $memcache = new Memcache; $memcache-&gt;addServer("localhost", 11211); $rate = $memcache-&gt;get($cache_key); if ($rate) { return $rate; } else { $api_host = "http://rates.example.com/"; $args = http_build_query(array("currency1"=&gt;$currency1, "currency2"=&gt;$currency2)); $rate = @file_get_contents($api_host."?".$args); if ($rate === FALSE) { return $rate; } else { $memcache-&gt;set($cache_key, (float) $rate, 0, 5); return (float) $rate; } } }</span></span></code> </pre> <br>  This is the most important aspect of the cache: <b>storing the last result</b> . <br><br>  And voila!  The site again becomes almost free for us ... Until the end of the month, when we discover a bill for 4 euros from an external system.  Of course, not 6, but we expected much greater savings! <br><br>  Fortunately, the external system allows you to see charges, where we see bursts of 100 or more requests every 5 seconds during peak attendance. <br><br>  So we got to know the second important aspect of the cache: <b>query deduplication</b> .  The fact is that as soon as the value is outdated, between checking the availability of the result in the cache and storing the new value, all incoming requests actually execute the request to the external system simultaneously. <br><br>  In the case of memcache, this can be implemented, for example, as follows: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_current_rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($currency1, $currency2)</span></span></span><span class="hljs-function"> </span></span>{ $cache_key = <span class="hljs-string"><span class="hljs-string">"rate_"</span></span>.$currency1.<span class="hljs-string"><span class="hljs-string">"_"</span></span>.$currency2; $memcache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memcache(); $memcache-&gt;addServer(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">11211</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $rate = $memcache-&gt;get($cache_key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate == <span class="hljs-string"><span class="hljs-string">"?"</span></span>) { sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rate; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     ,    if ($memcache-&gt;add($cache_key, "?", 0, 5)) { $api_host = "http://rates.example.com/"; $args = http_build_query(array("currency1"=&gt;$currency1, "currency2"=&gt;$currency2)); $rate = @file_get_contents($api_host."?".$args); if ($rate === FALSE) { return $rate; } else { $memcache-&gt;set($cache_key, (float) $rate, 0, 5); return (float) $rate; } } } } }</span></span></code> </pre> <br>  And then, finally, consumption was equal to the expected - 1 request in 5 seconds, the costs were reduced to 2 euros per month. <br><br>  Why 2?  There were 6 without caching for thousands of people, we cached everything, but it decreased only 3 times?  Yes, it was worthwhile to calculate early ... 1 time in 5 seconds = 12 per minute = 72 per hour = 576 per working day = 17 thousand per month, and not everyone goes according to schedule, there are strange people looking late at night ... So it turns out a peak instead of one hundred appeals is one, and in a quiet time - still a request for almost every call passes.  But still, even in the worst case, the bill should be 31 √ó 86400 √∑ 5 = 5.36 euros. <br><br>  So we met with another facet: the cache <b>helps</b> , but <b>does not eliminate the</b> load. <br><br>  However, in our case, people come to the project and go away and at some point start complaining about the brakes: the pages freeze for a few seconds.  It also happens that the site is not responding at all in the morning ... Viewing <a href="https://console.cloud.google.com/appengine%3FserviceId%3Ddefault%26duration%3DP4D">the site console</a> shows that sometimes during the day additional instances are launched.  At the same time, the speed of execution of requests drops to 5-15 seconds per request - because of what it happens. <br><br>  <i>Exercise for the reader: look carefully at the previous code and find the reason.</i> <br><br>  Yes Yes Yes.  Of course, this is in the <code>if ($rate === FALSE)</code> branch <code>if ($rate === FALSE)</code> .  If the external service returned an error, we did not release the lock ... In the sense that "?"  It remained recorded, and everyone is waiting for it to become obsolete.  Well, it's easy to fix: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate === <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>) { $memcache-&gt;delete($cache_key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rate; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br>  By the way, this rake is not only a cache, it is a general aspect of distributed locks: it is important to release locks and have timeouts in order to avoid deadlocks.  If we added "?"  in general, without the lifetime, everything would stop at the first error of communication with the external system.  Unfortunately, memcache does not provide good ways to create distributed locks, the use of a full-fledged database with row-level locks is better, but it was just a lyrical digression, necessary simply because they attacked this rake. <br><br>  So, we fixed the problem, only nothing has changed: the brakes rarely started anyway.  Remarkably, they coincided in time with the newsletter from the external system about the technical work ... <br><br>  Well, let's ... Let's take a brief breather and recalculate what we have already collected, what the cache should be able to do: <br><br><ol><li>  remember the last known result; </li><li>  deduplicate queries when the result is still or is not already known; </li><li>  ensure correct unblocking in case of error. </li></ol><br>  Did you notice?  The cache should provide points 1-2 and for the case of an error!  Initially it seems obvious: you never know what happened, one request fell off, the next one will update.  What will happen if the next one also returns an error?  And the next one?  Here we have received 10 requests, first captured the lock, tried to get the result, fell off, went out.  The following checks - so, there is no lock, there is no value, we follow the result.  Broke off, went out.  And so for everyone.  Well, nonsense!  For a good 10 came, one tried it - everyone fell off.  And let the next one try again! <br><br>  From here: the cache must be able to <b>store a negative result</b> for some time.  Our naive initial assumption essentially implies storing a negative result of 0 seconds (but the transfer of this very negative to all who are already waiting for it).  Unfortunately, in the case of Memcache, the implementation of zero latency is quite problematic (I <i>‚Äôll leave it as a homework to a corrosive reader</i> ; advice: use the <a href="http://php.net/manual/en/memcached.cas.php">CAS</a> mechanism; and yes, you can use Memcache and Memcached in AppEngine). <br><br>  We simply add the preservation of a negative value with 1 second of life: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_current_rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($currency1, $currency2)</span></span></span><span class="hljs-function"> </span></span>{ $cache_key = <span class="hljs-string"><span class="hljs-string">"rate_"</span></span>.$currency1.<span class="hljs-string"><span class="hljs-string">"_"</span></span>.$currency2; $memcache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memcache(); $memcache-&gt;addServer(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">11211</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $flags = <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; $rate = $memcache-&gt;get($cache_key, $flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate == <span class="hljs-string"><span class="hljs-string">"?"</span></span>) { sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($flags !== <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,   ,   , //       ,  false. return $rate; } else { if ($memcache-&gt;add($cache_key, "?", 0, 5)) { $api_host = "http://rates.example.com/"; $args = http_build_query(array("currency1"=&gt;$currency1, "currency2"=&gt;$currency2)); $rate = @file_get_contents($api_host."?".$args); if ($rate === FALSE) { //          $memcache-&gt;set($cache_key, $rate, 0, 1); return $rate; } else { $memcache-&gt;set($cache_key, (float) $rate, 0, 5); return (float) $rate; } } } } }</span></span></code> </pre> <br>  It would seem, <i>well, now</i> everything is already, and you can calm down?  As if not so.  While we were growing up, our favorite external service was also growing, and at some point, it sometimes began to slow down and respond as much as a second ... And what is remarkable - our website began to slow down along with it!  And again for everyone!  But why?  We all cache, in case of errors, we remember the error and thereby release all those who are waiting right away, do not we? <br><br>  ... But no.  Take a closer look at the code again: the request to the external system will be executed as long as <code>file_get_contents()</code> allows.  At the time of the request, everyone else is waiting, so every time the cache becomes obsolete, all threads are waiting for the main execution, and will receive new data only when they arrive. <br><br>  Well, instead of waiting, we can add an <code>else{}</code> branch to the condition around <code>memcache-&gt;add</code> ... True, we should probably return the last known value, yes?  After all, we cache exactly because we agree to get outdated information if there is no fresh information;  So, one more requirement to the cache: <b>let no more than one query slow down</b> . <br><br>  No sooner said than done: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_current_rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($currency1, $currency2)</span></span></span><span class="hljs-function"> </span></span>{ $cache_key = <span class="hljs-string"><span class="hljs-string">"rate_"</span></span>.$currency1.<span class="hljs-string"><span class="hljs-string">"_"</span></span>.$currency2; $memcache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memcache(); $memcache-&gt;addServer(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">11211</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $flags = <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; $rate = $memcache-&gt;get($cache_key, $flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate == <span class="hljs-string"><span class="hljs-string">"?"</span></span>) { sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($flags !== <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rate; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($memcache-&gt;add($cache_key, <span class="hljs-string"><span class="hljs-string">"?"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) { $api_host = <span class="hljs-string"><span class="hljs-string">"http://rates.example.com/"</span></span>; $args = http_build_query(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">"currency1"</span></span>=&gt;$currency1, <span class="hljs-string"><span class="hljs-string">"currency2"</span></span>=&gt;$currency2)); $rate = @file_get_contents($api_host.<span class="hljs-string"><span class="hljs-string">"?"</span></span>.$args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rate === <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      ,    //  .  ,   . $memcache-&gt;set($cache_key, $rate, 0, 1); return $rate; } else { //      _stale_ ,     // - : , ,    //    . $memcache-&gt;set("_stale_".$cache_key, (float) $rate); $memcache-&gt;set($cache_key, (float) $rate, 0, 5); return (float) $rate; } } else { //    ,      ‚Äî //     ,      . //    ,   false,    . return $memcache-&gt;get("_stale_".$cache_key); } } } }</span></span></code> </pre> <br>  So, we won again: even if the external service slows down, it slows down no more than one page ... That is, the average response time is reduced, but users are still a little unhappy. <br><br>  <i>Note:</i> plain PHP by default writes sessions to files, blocking parallel requests.  To avoid this behavior, you can pass the read_and_close parameter to session_start or forcefully close the session after session_close after making all the necessary changes, otherwise not one page, but one user will slow down: since the script updating the value will block opening the session by another request from the same user  When running on AppEngine, <a href="https://cloud.google.com/appengine/docs/php/runtime">storage of sessions in memcache is</a> turned on by default, that is, without locks, so the problem will not be so noticeable. <br><br>  So, users are still unhappy (oh, those users!).  Those who spend the most time on the site still notice these short hangs.  And they are not at all pleased with the realization of the fact that it seldom happens this way, and they simply have no luck.  It is necessary <i>to</i> make the requirement even more stringent <i>for this case</i> : <b>no requests should wait for a response</b> . <br><br>  What can we do in such a question?  We can: <br><br><ol><li>  Trying to perform <a href="http://stackoverflow.com/questions/138374/close-a-connection-early">execution after response</a> tricks, that is, if we have to update the value, we register the handler that will do it after the rest of the script has been executed.  That's just it depends a lot on the application and the execution environment;  The most reliable way is to use <code><a href="http://php.net/fastcgi_finish_request">fastcgi_finish_request</a> ()</code> , which requires setting up the server via php-fpm (respectively, not available for AppEngine). <br><br></li><li>  Make an update in a separate thread (that is, perform <code><a href="http://php.net/pcntl_fork">pcntl_fork()</a></code> or run the script via <code><a href="http://php.net/system">system()</a></code> or something else) - again, it can work for your server, sometimes it even works on some shared hosting, where they are not very concerned about security, but, of course, does not work on services with paranoid security, that is, AppEngine does not fit. <br><br></li><li>  Have a constantly running background process for updating the cache: the process should check with a given periodicity whether the value in the cache becomes outdated, and if the lifetime comes to an end, and the value required during the cache lifetime, updates it.  We will discuss this moment a little later, when we get tired of our poor site with the exchange rate and move on to more fun matters. </li></ol><br>  In essence, keeping data always hot is a bit more complicated than just a few lines of PHP code, so for our simple case we will have to accept the fact that <i>some</i> query will ‚Äúreflect‚Äù regularly (important: not accidental, but some; that is, not <i>random</i> , but <i>arbitrary</i> ).  The applicability of this approach is <b>always</b> important to try on the task! <br><br>  So, our data provider is growing, but not all of its clients read Habr, and therefore they do not use correct caching (if they use it at all) and at some point they start to issue a huge number of requests, because of what the service becomes bad, and occasionally he begins to answer not just slowly, but <i>very slowly</i> .  Up to tens of seconds or more.  Users, of course, quickly discovered that you can press F5 or otherwise reload the page, and it appears instantly - only the page started to rest against free limits again, as processes that just wait for an external response, but consume our resources, constantly began to hang. <br><br>  Among other side effects, the incidence of obsolete courses has become more frequent.  [Hmm ... well, imagine that we are not talking about our case, but about something more complicated, where obsolescence can be seen with the naked eye :) in fact, even in the simple case, there will always be a user who will notice such completely unobvious jambs ]. <br>  See what happens: <br><br><ol><li>  Request 1 has arrived, there is no data in the cache, so we added a token '?'  for 5 seconds and went for the course. </li><li>  After 1 second, query number 2 came, I saw the '?' Marker, I returned the data from the stale record. </li><li>  After 3 seconds, request number 3 arrived, I saw a '?' Marker, returned stale. </li><li>  After 1 second marker '?'  outdated, even though query 1 is still waiting for a response. </li><li>  After another 2 seconds, query number 4 arrived, there is no marker, adds a new marker, and sets off for the course. </li><li>  ... </li><li>  Request 1 received a response, saved the result. </li><li>  Request X came, received the actual response from the cache of the 1st question (and when did the answer come? At the time of the request, or the time of the answer? - no one knows that ...). </li><li>  Request number 4 received an answer, saved the result - and again it is not clear whether this answer was newer or older ... </li></ol><br>  Of course, here we have to set the timeout we need via <code><a href="http://php.net/default_socket_timeout">ini_set("default_socket_timeout")</a></code> or use <code><a href="http://php.net/stream_context_create">stream_context_create</a></code> ... So we come to another important aspect: the <b>cache must take into account the time of receiving values</b> .  There is no general solution for behavior, but, as a rule, the caching time should be longer than the calculation time.  If the calculation time exceeds the cache lifetime, the <b>cache is not applicable</b> .  This is no longer a cache, but <i>predictions</i> that should be stored in a secure storage. <br><br>  So let's summarize.  In the everyday sense of the cache: <br><br><ol><li>  replaces most requests for a known answer; </li><li>  limits the number of requests for obtaining expensive data; </li><li>  makes request time invisible to the user. </li></ol><br>  In reality: <br><br><ol><li>  replaces <i>some</i> requests from the cache life window with stored values ‚Äã‚Äã(the cache can be lost at any time, for example, due to lack of memory or extravagant requests); </li><li>  <i>tries to</i> limit the number of requests (but without special implementation of the limitation of the frequency of outgoing requests, it is really possible to provide only the characteristics of the ‚Äúmaximum 1 outgoing request at one time‚Äù type); </li><li>  the request execution time is visible only to <i>some</i> users (and the ‚Äúlucky ones‚Äù are not evenly distributed). </li></ol><br>  The cache assumes the ‚Äúephemerality‚Äù of the stored data, in connection with which the caching systems are free to handle the lifetime in general and the very fact of the request for data storage: <br><br><ul><li>  cache can be lost at any time.  Even our execution blockers '?'  may be lost if in parallel 10 thousand more users walk around the site, all while saving something (often the time of the last visit to the site) to a session that lies on the same cache server;  after the token is lost (‚Äúcache poisoned‚Äù), the next query again starts the procedure of updating the value in the cache; </li><li>  the faster the request is executed in the remote system, the fewer requests will be deduplicated in the event of cache poisoning. </li></ul><br>  Thus, simply applying the cache, we often lay a mine of deferred action, which will necessarily explode - but not now, but in the future, when the solution will cost much more.  When calculating system performance, it is important to consider without taking into account the reduction in execution time from caching positive responses, otherwise we improve the system behavior <i>at quiet times</i> (when the maximum hit ratio is maximum), and not during peak load / dependency overload (when cache poisoning usually happens). <br><br>  Consider the simplest case: <br><br><ul><li>  We look at the system in a calm state, and we see an average execution time of 0.05 sec. </li><li>  Conclusion: 1 process can serve 20 requests per second, which means that for 100 requests per second 5 processes are enough. </li><li>  That's only if the update time of the request increases to 2 seconds, it turns out: </li><li>  1 process is busy updating (for 2 seconds); </li><li>  During these 2 seconds, we have only 4 processes available = 80 requests per second. </li></ul><br>  And under heavy load, our cache is poisoned, and requests are not cached for 5 seconds, but for 1 second only, which means that we have 2 requests constantly busy (one executes the first request, the second starts updating the cache after a second while the first works), and the residual capacity for maintenance is reduced to 60 requests per second.  That is, the effective capacity from (based on the average) 6000 requests per minute dramatically drops to ~ 3600.  Which means that if the poisoning occurred on 5000 requests per minute, until the load drops from 5000 to 3000, the system is unstable.  That is, any (even peak!) Surge of traffic can potentially cause long-term system instability. <br><br>  Especially it looks great when after the newsletter with any new features almost at the same time comes a wave of users.  A kind of marketing habraeffekt on a regular basis. <br><br>  All this does not mean that the cache can not be used or harmful!  How to properly use the cache to improve the stability of the system and how to recover from the above hysteresis loop, we will talk in the next article, do not switch. </div><p>Source: <a href="https://habr.com/ru/post/316344/">https://habr.com/ru/post/316344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316328/index.html">PKCS # 11 Tokens: Certificates and Private Keys</a></li>
<li><a href="../316332/index.html">Features of the construction of tests and software development used in testing the product on assembly lines</a></li>
<li><a href="../316336/index.html">RamblerElixir # 1</a></li>
<li><a href="../316338/index.html">Attackers promise users free Emirates tickets</a></li>
<li><a href="../316342/index.html">Thin Scrum is better than good Agile</a></li>
<li><a href="../316346/index.html">13 largest providers of mass payments for international business</a></li>
<li><a href="../316348/index.html">3CX offers integrators pre-install 3CX on mini PC</a></li>
<li><a href="../316350/index.html">Employee time tracking: Hard and Hardcore only</a></li>
<li><a href="../316352/index.html">The real truth about comparing CodeSonar and PC-lint</a></li>
<li><a href="../316354/index.html">How I grew up without Kodabra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>