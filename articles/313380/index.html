<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.5 - Shaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We already mentioned shaders in the previous lesson. Shaders are small programs running on a graphics accelerator (hereinafter, we will use the more c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.5 - Shaders</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/1b9/d3e/d44/1b9d3ed44e360a0606d9d6a91b1b38b5.png" align="left" width="300">  We already mentioned shaders in the previous lesson.  Shaders are small programs running on a graphics accelerator (hereinafter, we will use the more common name - GPU).  These programs are executed for each specific section of the graphics pipeline.  If to describe shaders in the simplest way, then shaders are nothing more than programs that transform inputs into outputs.  Shaders are usually isolated from each other, and do not have communication mechanisms between themselves except for the above-mentioned inputs and outputs. </p><br><p>  In the previous lesson we briefly touched on the topic of ‚Äúsurface shaders‚Äù and how to use them.  In this lesson we will look at shaders in more detail and in particular the OpenGL shading language (OpenGL Shading Language). </p><a name="habracut"></a><br><habracut><br><h1>  Menu </h1><br><ol><li>  Getting started <br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <b>Shaders</b> </li></ol></li></ol><br><h3 id="glsl">  GLSL </h3><br><p>  Shaders (as mentioned above, shaders are programs) are programmed in C like GLSL.  It is adapted for use in graphics and provides functions for working with vectors and matrices. </p><br><p>  The shader description begins with an indication of its version, followed by lists of input and output variables, global variables (the keyword uniform), and main functions.  The main function is the starting point of the shader.  Inside this function, you can manipulate the input data, the result of the shader is placed in the output variables.  Do not pay attention to the keyword uniform, we will return to it later. </p><br><p>  Below is a generalized shader structure: </p><br><pre><code class="hljs rust">#version version_number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in_variable_name</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in_variable_name</span></span></span></span>; out <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out_variable_name</span></span></span></span>; uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uniform_name</span></span></span></span>; void main() { <span class="hljs-comment"><span class="hljs-comment">// - , , ,  .. ... //       out_variable_name = weird_stuff_we_processed; }</span></span></code> </pre> <br><p>  The input variables of the vertex shader are called vertex attributes.  There is a maximum number of vertices that can be passed to the shader; this limitation is imposed by the limited hardware capabilities.  OpenGL guarantees the ability to transfer at least 16 4-component vertices, in other words, at least 64 values ‚Äã‚Äãcan be passed to the shader.  However, it should be borne in mind that there are computing devices significantly raise this bar.  Anyway, you can find out the maximum number of input variable vertices that are passed to the shader by referring to the <em>GL_MAX_VERTEX_ATTRIBS</em> attribute. </p><br><pre> <code class="hljs cpp">GLint nrAttributes; glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Maximum nr of vertex attributes supported: "</span></span> &lt;&lt; nrAttributes &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  As a result of the execution of this code, as a result we will see the figure&gt; = 16. </p><br><h3 id="tipy">  Types </h3><br><p>  GLSL, like any other programming language, provides a specific list of variable types, these include the following primitive types: int, float, double, uint, bool.  GLSL also provides two container types: vector and matrix. </p><br><h4 id="vector">  Vector </h4><br><p>  Vector in GLSL is a container containing from 1 to 4 values ‚Äã‚Äãof any primitive type.  A container vector declaration can have the following form (n is the number of elements of the vector): </p><br><p>  vecn (for example, vec4) is a standard vector containing n values ‚Äã‚Äãof type float <br>  bvecn (for example, bvec4) is a vector containing n values ‚Äã‚Äãof type boolean <br>  ivecn (for example, ivec4) is a vector containing n integer values <br>  uvecn (for example, uvecn) is a vector containing n unsigned integer values <br>  dvecn (for example, dvecn) is a vector containing n double values. </p><br><p>  In most cases, the standard vector vecn will be used. </p><br><p>  To access the elements of the vector container, we will use the following syntax: vec.x, vec.y, vec.z, vec.w (in this case, we addressed all elements in order, from first to last).  You can also iterate over RGBA if the vector describes a color, or stpq if the vector describes the coordinates of the texture. </p><br><blockquote>  PS It is allowed to refer to one vector through XYZW, RGBA, STPQ.  No need to take this note as a guide to action, please. <br><br>  PPS In general, nobody forbids to iterate over a vector with the help of an index and an access operator on an index [].  <a href="https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations">https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations#Components</a> </blockquote><p>  From a vector, when accessing data through a point, you can get not only one value, but also a whole vector using the following syntax, which is called <em>swizzling</em> </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> someVec; <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> differentVec = someVec.xyxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> anotherVec = differentVec.zyw; <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> otherVec = someVec.xxxx + anotherVec.yxzy;</code> </pre> <br><p>  To create a new vector, you can use up to 4 literals of the same type or vector, only one rule - in total, we need to get the number of elements we need, for example: to create a vector of 4 elements, we can use two vectors of 2 elements long, or one vector long into 3 elements and one literal.  Also, to create a vector of n elements, it is allowed to specify one value, in this case all elements of the vector will take this value.  It is also allowed to use variables of primitive types. </p><br><pre> <code class="hljs go">vec2 vect = vec2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>); vec4 result = vec4(vect, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); vec4 otherResult = vec4(result.xyz, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre> <br><p>  You may notice that the vector is a very flexible data type and can be used as input and output variables. </p><br><h3 id="in-i-out-peremennye">  In and out variables </h3><br><p>  We know that shaders are small programs, but in most cases they are part of something bigger, for this reason, GLSL has in and out variables that allow you to create a shader ‚Äúinterface‚Äù that allows you to get data for processing and transmit the results to the caller.  Thus, each shader can define for itself input and output variables using the keywords in and out. </p><br><p>  A vertex shader would be extremely inefficient if it did not accept any input data.  By itself, this shader is different from other shaders in that it takes input values ‚Äã‚Äãdirectly from the vertex data.  In order to tell OpenGL how the arguments are organized, we use position metadata so that we can set attributes on the CPU.  We have already seen this technique before: 'layout (location = 0).  The vertex shader, in turn, requires additional specifications in order for us to associate the arguments with vertex data. </p><br><blockquote>  You can omit layout (location = 0), and use the glGetAttributeLocation call to get the location of the vertex attributes. </blockquote><p>  Another exception is that the fragment shader (Fragment shader) must have vec4 output, in other words, the fragment shader must provide as a result a color in RGBA format.  If this is not done, the object will be drawn in black or white. </p><br><p>  Thus, if we are faced with the task of transferring information from one shader to another, then it is necessary to define in the transmitting shader out a variable of this type as with the in variable in the receiving shader.  Thus, if the types and names of variables are the same on both sides, OpenGL will connect these variables together, which will enable us to exchange information between shaders (this is done at the linking stage).  To demonstrate this in practice, we will modify the shaders from the previous lesson so that the vertex shader provides the color for the fragment shader. </p><br><p>  <strong>Vertex shader</strong> </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-comment"><span class="hljs-comment">//     0 out vec4 vertexColor; //      void main() { gl_Position = vec4(position, 1.0); //   vec3  vec4 vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f); //      - . }</span></span></code> </pre> <br><p>  <strong>Fragment shader</strong> </p><br><pre> <code class="hljs dos">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec4 vertexColor; //      (      ) out vec4 <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>; void main() { <span class="hljs-built_in"><span class="hljs-built_in">color</span></span> = vertexColor; }</code> </pre> <br><p>  In these examples, we declared an output vector of 4 elements with the name vertexColor in the vertex shader and an identical vector with the name vertexColor, but only as an input in the fragment shader.  As a result, the output vertexColor from the vertex shader and the input vertexColor from the fragment shader were connected.  Since  we set the vertexColor value in the vertex shader corresponding to the opaque burgundy (dark red color), applying the shader to the object makes it burgundy.  The following image shows the result: </p><br><p><img src="https://habrastorage.org/files/099/dab/707/099dab707878493196a167fc7f97dbf4.png" alt="Result"></p><br><p>  That's all.  We made it so that the value from the vertex shader was obtained by the fragment shader.  Next, we will look at how to transfer information to the shader from our application. </p><br><h4 id="uniforms">  Uniforms </h4><br><p>  Uniforms (we will call them forms) is another way to transfer information from our application running on the CPU to the shader running on the GPU.  Forms are slightly different from vertex attributes.  For a start: forms are global.  The global variable for GLSL means the following: The global variable will be unique for each shader program, and every shader has access to it at any stage in this program.  Second: the value of the form is maintained until it is reset or updated. </p><br><p>  To declare a form in GLSL, the unifrom variable specifier is used.  After the form is declared, it can be used in the shader.  Let's see how to set the color of our triangle using a form: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec4 ourColor; <span class="hljs-comment"><span class="hljs-comment">//        OpenGL. void main() { color = ourColor; }</span></span></code> </pre> <br><p>  We declared the outColor form variable of the vector of 4 elements in the fragment shader and use it to set the output value of the fragment shader.  Since  Since the form is a global variable, its declaration can be made in any shader, which means that we do not need to transfer something from the vertex shader to the fragment shader.  Thus, we do not declare the form in the vertex shader, since  we don't use it there. </p><br><p>  If you declare a form and do not use it in a shader program, the compiler will quietly delete it, which can cause some errors, so keep this information in your head. </p><br><p>  At the moment the form does not contain useful data, because  we didn't put them there, so let's do it.  First we need to know the index, in other words, the location of the form attribute we need in our shader.  Having obtained the value of the attribute index, we can fit the necessary data there.  To clearly demonstrate the performance of this function, we will change the color from time: </p><br><pre> <code class="cpp hljs">GLfloat timeValue = glfwGetTime(); GLfloat greenValue = (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(timeValue) / <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; GLint vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="hljs-string"><span class="hljs-string">"ourColor"</span></span>); glUseProgram(shaderProgram); glUniform4f(vertexColorLocation, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, greenValue, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre> <br><p>  First we get the runtime in seconds by calling glfwGetTime ().  Then we change the value from 0.0 to 1.0 using the sin function and write the result to the greenValue variable. </p><br><p>  After we request the index of the form ourColor using glGetUniformLocation.  This function takes two arguments: the shader program variable and the name of the form defined within this program.  If glGetUniformLocation returned -1, it means that no such form with this name was found.  Our final step is to set the value of ourColor form by using the glUniform4f function.  Notice that the search for a form index does not require a prior call to glUseProgram, but to update the value of the form, you must first call glUseProgram. </p><br><p>  Since OpenGL is implemented using the C language, in which there is no function overload, it is impossible to call functions with different arguments, but OpenGL defines functions for each data type, which are determined by the postfix of the function.  Below are some postfixes: </p><br><p>  f: the function takes a float argument; <br>  i: the function takes an int argument; <br>  ui: the function takes an unsigned int argument; <br>  3f: the function takes three float arguments; <br>  fv: function takes as argument a vector from float. </p><br><p>  Thus, instead of using overloaded functions, we must use a function whose implementation is intended for a specific set of arguments, as indicated by the postfix function.  In the example above, we used the function glUniform ... () specialized to handle 4 arguments of type float, so the full name of the function was glUniform4f () (4f - four arguments of type float). </p><br><p>  Now that we know how to set values ‚Äã‚Äãto forms, we can use them in the rendering process.  If we want to change color over time, then we need to update the shape value every iteration of the rendering cycle (in other words, the color will change on each frame), otherwise our triangle will be the same color if we set the color only once.  In the example below, the new color of the triangle is calculated and updated at each iteration of the rendering cycle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!glfwWindowShouldClose(window)) { <span class="hljs-comment"><span class="hljs-comment">//   glfwPollEvents(); //  //    glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); //    glUseProgram(shaderProgram); //    GLfloat timeValue = glfwGetTime(); GLfloat greenValue = (sin(timeValue) / 2) + 0.5; GLint vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor"); glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); //   glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0); }</span></span></code> </pre> <br><p>  The code is very similar to that used earlier, but now we execute it inside the loop, changing the value of the form at each iteration.  If everything is correct, then you will see the color change of the triangle from green to black and back (if it is not clear, find the image of the sine wave). </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://learnopengl.com/video/getting-started/shaders.mp4" type="video/mp4"></video></div></div></div><br><p>  The full source code of the program that creates such miracles can be found <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-uniform">here</a> . </p><br><p>  As you have already noticed, forms are a very convenient way to exchange data between the shader and your program.  But what if we want to set the color for each vertex?  To do this, we must declare as many forms as there are vertices.  The most successful solution would be to use vertex attributes, which we will now demonstrate. </p><br><p>  More attributes to god of attributes !!! </p><br><p>  In the previous tutorial, we saw how to fill in a VBO, set pointers to vertex attributes, and how to store it all in a VAO.  Now we need to add color information to the vertex data.  To do this, we will create a vector of three float elements.  We will assign the red, green, and blue colors to each of the vertices of the triangle, respectively: </p><br><pre> <code class="cpp hljs">GLfloat vertices[] = { <span class="hljs-comment"><span class="hljs-comment">//  //  0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, //    -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, //    0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f //   };</span></span></code> </pre> <br><p>  Now we have a lot of information to transfer it to the vertex shader, we need to edit the shader so that it gets both vertices and colors.  Note that we set the color locations to 1: </p><br><pre> <code class="hljs dos">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; //       <span class="hljs-number"><span class="hljs-number">0</span></span> layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>; //       <span class="hljs-number"><span class="hljs-number">1</span></span> out vec3 ourColor; //      void main() { gl_Position = vec4(position, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); ourColor = <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>; //   ,     }</code> </pre> <br><p>  Now we do not need the form ourColor, but the output parameter of ourColor will be useful to us for passing the value to the fragment shader: </p><br><pre> <code class="hljs dos">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 ourColor; out vec4 <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>; void main() { <span class="hljs-built_in"><span class="hljs-built_in">color</span></span> = vec4(ourColor, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>f); }</code> </pre> <br><p>  Since  we added a new vertex parameter and updated the VBO memory; we need to configure the vertex attribute pointers.  The updated data in the VBO memory is as follows: </p><br><p><img src="https://habrastorage.org/files/dd7/f8b/50c/dd7f8b50c2b04b8287495d3dd9641bf0.png" alt="VBO Memory Data"></p><br><p>  Knowing the current scheme, we can update the vertex format using the <em>glVertexAttribPointer</em> function: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); //    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3* sizeof(GLfloat))); glEnableVertexAttribArray(1);</span></span></code> </pre> <br><p>  The first few attributes of the glVertexAttribPointer function are fairly simple.  In this example, we use the vertex attribute with position 1. The color consists of three values ‚Äã‚Äãof the fleet type and we do not need normalization. </p><br><p>  Since  we now use two shader attributes, then we should recalculate the step.  To access the next shader attribute (the next x vertex vector) we need to move 6 float elements to the right, 3 for the vertex vector and 3 for the color vector.  Those.  we move 6 times to the right, i.e.  24 bytes to the right. </p><br><p>  Now we understand the shifts.  The first is the vector with the coordinates of the vertex.  A vector with an RGB color value comes after a vector with coordinates, i.e.  after 3 * sizeof (GLfloat) = 12 bytes. </p><br><p>  Running the program you can see the following result: </p><br><p><img src="https://habrastorage.org/files/bc2/a1b/56e/bc2a1b56e53741cb9dbf207ce4f328c5.png" alt="Result"></p><br><p>  The full source code that does this miracle can be found <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-interpolated">here</a> : </p><br><p>  It may seem that the result does not correspond to the work done, because we set only three colors, and not the palette that we see as a result.  This result gives a fragmentary interpolation of a fragment shader.  When we draw a triangle, at the rasterization stage, we get many more areas, and not just the vertices, which we use as the shader arguments.  The rasterizer determines the positions of these areas based on their position on the landfill.  Based on this position, all arguments of the fragment shader are interpolated.  Suppose we have a simple line, at one end it is green, at the other it is blue.  If the fragment shader processes an area that is approximately in the middle, then the color of this area will be chosen so that green will be equal to 50% of the color used in the line, and, accordingly, blue will be equal to 50% percent of blue.  This is exactly what happens on our triangle.  We have three colors, and three vertices, for each of which one of the colors is set.  If you look closely, you can see that red, when you go to blue, first turns purple, which is quite expected.  Fragment interpolation is applied to all attributes of a fragment shader. </p><br><h3 id="oop-v-massy-delaem-svoy-klass-sheydera">  OOP to the masses!  Making your shader class </h3><br><p>  The code that describes the shader, compiles it, and allows you to configure the shader can be very cumbersome.  So let's make our life a bit easier by writing a class that reads our shader from disk, compiling it, linking it, checking for errors, and of course, having a simple and pleasant interface.  Thus, OOP will help us encapsulate all this chaos inside the methods of our class. </p><br><p>  We start the development of our class by declaring its interface and assign all necessary directives to the newly created heading.  The result is something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SHADER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;GL/glew.h&gt;; //  glew  ,       OpenGL class Shader { public: //   GLuint Program; //      Shader(const GLchar* vertexPath, const GLchar* fragmentPath); //   void Use(); }; #endif</span></span></span></span></code> </pre> <br><p>  Let's do well and use ifndef and define directives to avoid recursively executing include directives.  This advice does not apply to OpenGL, but to programming in C ++ as a whole. </p><br><p>  And so, our class will store in itself the identifier.  The shader constructor will take as arguments the pointers to arrays of characters (in other words, the text, and in the context of the class, it would be more appropriate to say - the path to the file with the source code of our shader) containing the path to the files containing the vertex and fragment shaders, represented by plain text.  We will also add the utilitarian Use function, which clearly demonstrates the advantages of using shader classes. </p><br><p>  Read shader file  For reading, we will use standard C ++ streams, putting the result in the lines: </p><br><pre> <code class="cpp hljs">Shader(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLchar* vertexPath, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLchar* fragmentPath) { <span class="hljs-comment"><span class="hljs-comment">// 1.      filePath std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // ,  ifstream     vShaderFile.exceptions(std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::badbit); try { //   vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; //     vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); //   vShaderFile.close(); fShaderFile.close(); //     GLchar vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); } catch(std::ifstream::failure e) { std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl; } const GLchar* vShaderCode = vertexCode.c_str(); const GLchar* fShaderCode = fragmentCode.c_str(); [...]</span></span></code> </pre> <br><p>         (    ,   ,         . , ‚Ä¶      ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2.   GLuint vertex, fragment; GLint success; GLchar infoLog[512]; //   vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); //    -   glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success); if(!success) { glGetShaderInfoLog(vertex, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; }; //     [...] //   this-&gt;Program = glCreateProgram(); glAttachShader(this-&gt;Program, vertex); glAttachShader(this-&gt;Program, fragment); glLinkProgram(this-&gt;Program); //   -   glGetProgramiv(this-&gt;Program, GL_LINK_STATUS, &amp;success); if(!success) { glGetProgramInfoLog(this-&gt;Program, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; } //  ,          . glDeleteShader(vertex); glDeleteShader(fragment);</span></span></code> </pre> <br><p>         Use: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ glUseProgram(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Program); }</code> </pre> <br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Shader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"path/to/shaders/shader.vs"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"path/to/shaders/shader.frag"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(...) { ourShader.Use(); glUniform1f(glGetUniformLocation(ourShader.Program, <span class="hljs-string"><span class="hljs-string">"someUniform"</span></span>), <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); DrawStuff(); }</code> </pre> <br><p>           shader.vs,      shader.frag.  ,       ,     ,    ,  . </p><br><p>   <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-using-object">   </a> , <a href="http://learnopengl.com/code_viewer.php%3Ftype%3Dheader%26code%3Dshader"> </a> , <a href="http://learnopengl.com/code_viewer.php%3Ftype%3Dvertex%26code%3Dgetting-started/basic"> </a>  <a href="http://learnopengl.com/code_viewer.php%3Ftype%3Dfragment%26code%3Dgetting-started/basic"> </a> </p><br><p> <b>:</b> </p><br><p> <b>1.</b>    ,     : <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-exercise1"></a> . </p><br><p> <b>2.</b>                 : <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-exercise2"></a> . </p><br><p> <b>3.</b>             (,       ).  ,   ,    ,      ?: <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/shaders-exercise3"></a> </p></habracut></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313380/">https://habr.com/ru/post/313380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313366/index.html">Sharding - patterns and antipatterns</a></li>
<li><a href="../313370/index.html">Elements of functional programming in C ++: partial application</a></li>
<li><a href="../313372/index.html">Elections 2016. Part 2 is amazing nearby and it is allowed</a></li>
<li><a href="../313374/index.html">JavaScript: includes vs indexOf</a></li>
<li><a href="../313376/index.html">Soviet "Elbrus" - an overview of the architecture</a></li>
<li><a href="../313382/index.html">Virtual server with video card</a></li>
<li><a href="../313384/index.html">Dribbble review number 2 - the most interesting interface designs for the last 2 weeks</a></li>
<li><a href="../313386/index.html">The digest of interesting materials for the mobile developer # 176 (October 17-23)</a></li>
<li><a href="../313390/index.html">Interview with MapR's VP of Technology Strategy</a></li>
<li><a href="../313392/index.html">Pattern Strategy JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>