<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular 1.5: Components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago saw the release of the release of Angular 1.5, which introduces many interesting innovations. Important feature 

 This version is tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular 1.5: Components</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/8bc/360/ba3/8bc360ba3d7f48fb8244112d5a5814e0.png" align="right" width="250"><br>  Not so long ago saw the release of the release of Angular 1.5, which introduces many interesting innovations.  Important feature <br><br>  This version is that it is the first of a series of releases that should smooth the conceptual gap between Angular1.x and Angular2.x.  For people who have the need to conduct projects on Angular now, but in the future we plan to gradually migrate to Angular2, this is very good news. <br><br>  In this article I will try to highlight the main innovations: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Components! </li><li>  Unilateral binding! </li><li>  Multi-slot transquids! </li></ul><br>  A complete list of changes is available in <a href="">the Angular repository</a> .  We are also waiting for a small example of the use of the listed features. <a name="habracut"></a><br><br><h2>  UI components </h2><br>  Perhaps only the lazy one has not heard about the concept of UI components, so this chapter can be skipped.  Or have you not heard?  And, heard but do not fully understand?  Then I apologize, I will explain the essence of the concept, as well as its advantages. <br><br>  By component, we will mean a <a href="https://www.w3.org/TR/custom-elements/">custom element</a> that has some additional behavior and pattern with it.  As an example, recall the <code>video</code> or <code>audio</code> elements.  Of course, they are not "custom" (according to the W3C specification), but they convey the essence well. <br><br>  The idea is far from new and it is called hierarchical decomposition.  It is used to reduce the complexity oochen for a long time.  And why not apply it to the UI of our WEB applications?  We take the UI and divide it into separate blocks - components.  Each component in turn consists of other components.  And those are from others, and so on until we reach the minimum unit ‚Äî standard elements that can be perceived as components without behavior.  If you have worked with Qt, GTK or other GUI frameworks, widgets are components there, so there‚Äôs no way to call the idea new. <br><br>  When choosing the boundaries of each component, we should try to make them as independent as possible from the context of use.  In the UI, the component should not be where it is used, as well as what the components it uses consist of. <br><br><h3>  Interface decomposition </h3><br>  How much should the components be crushed?  This is a question of common sense.  Naturally, to wrap each DOM element in a component is stupid, because at some point we have to stop.  Yet we do it for convenience, and not just.  For example, let's take some application with a simple UI.  Do you know about <a href="http://todomvc.com/">TodoMVC</a> ?  Let's try to separate it into components: <br><br><img src="https://habrastorage.org/files/a60/001/2de/a600012deb89428bb34facfc3dee11f1.png"><br><br>  Immediately I want to note that this option of separation is not the only true one.  Therefore, it is worth explaining where these components come from, and why I decided to separate everything that way. <br><br>  In our application, you can immediately select the elements of the list that describe individual tasks.  There is clearly traced behavior and it is clearly the same.  Let's call them <code>todo-item</code> Having selected this component, we automatically isolate all the behavior of this part of the UI within the framework of this component.  To do separately <code>todo-list</code> does not make sense, since it will be a dummy component, why waste time.  We could stuff the list filtering logic into this component, but this is easier to do at the service layer level. <br><br>  Next we immediately see the <code>todo-header</code> and <code>todo-footer</code> as the <code>todo-header</code> and <code>todo-footer</code> our application.  The <code>todo-header</code> component will be responsible for adding new tasks to the list.  Of course, we could still slightly split this component and put a separate component inside, isolating the logic of adding tasks, and <code>todo-header</code> would only respond to the layout.  Or even more interesting - it will forward the add-through via transclude but ... it is somehow difficult for such a simple application. <br><br>  <code>todo-footer</code> we also will not split up further, because we will have too small components, and working with them will not be so convenient. <br><br>  Any component tree must have a root, a base element describing the entire UI.  We have this <code>todo-app</code> .  It is a kind of entry point describing a specific screen of our application.  But our applications are usually more complicated, and have many screenshots, within which you can select additional screenshots, etc.  It is for this reason that we have all these routers, etc.  But back to this later. <br><br><h3>  Impact on the development process </h3><br>  Since we can isolate the behavior of each component, as well as having a hierarchy of them, we can very easily develop the development into several developers.  Developers will be able to make individual self-contained components, cover them with tests and provide them to other team members. <br><br>  This greatly affects the flexibility of planning, and the phrase "9 women can not give birth to a child in 1 month" does not so well describe the process of developing our application.  By increasing the efficiency of our processes, we can deliver more features to a client in less time, and this is perhaps the most important thing in our work. <br><br>  There is also another aspect that is not very fond of discussing.  This is a segregation of duties between front-end developers and layout makers.  It may sound rough, but it is much more effective to take a couple of cheap web designers and one expensive developer frontend, rather than two expensive developers frontends.  And given the fact that things like BEM did not appear yesterday, it is not a particular problem to achieve a modular layout.  You just need to achieve a certain level of responsibility and understanding from the developers. <br><br>  We can also take out all the component templates from the JS files, and give the maker-ups the opportunity to work as close as possible to the real place of application of the templates, which reduces the risks associated with the interaction of the team.  And the designer does not need to know Angular in order to complete the design.  Alternatively, a frontend developer can provide ready-made components to designers with primitive markup and no styles in advance.  And the maker-ups will already be engaged in fine-tuning. <br><br><h2>  So where does Angular 1.5? </h2><br>  In essence, components are directives that define a new element with its own behavior (isolated in the controller) and a template.  And as everyone knows, Angular has a wildly re-added directive API.  Yes, it is very flexible and allows you to do a lot of things that you usually should not do.  And since we need to maintain backward compatibility, it is not possible to simplify it. <br><br>  That is why for the declaration of components in Angular 1.5, we received a new API: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     } //       const myComponentDefinition = { //  scope + bindToController: true //         bindings: { 'name': '=' }, //      ,      //   `templateUrl` //       //     template: ` &lt;div class="my-component"&gt;{{ $ctrl.name }}&lt;/div&gt; `, //           //   `controllerAs`   //           //    `$ctrl`. controller: MyComponentController } //  HTML5       //    .     my-component angular.module('app').component('myComponent', myComponentDefinition);</span></span></code> </pre> <br>  A full description of the API, as well as a comparison with the directive API, is available <a href="https://code.angularjs.org/1.5.0/docs/guide/component">in the documentation</a> .  Yet it is useful to glance there sometimes. <br><br>  So, we can now divide the UI into separate components, it remains only to deal with their state.  What is the status of the component?  Roughly speaking, this is some kind of data that a component uses to form a view, fill binders, etc.  Where does the component get this data from?  Requests them from the service, or receives through binding, or on the basis of data from the binding requests from the service.  In short, a bunch of options.  But which is better? <br><br><h2>  Stateless vs Stateful components </h2><br>  Facebook folks think that components should be like <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">pure functions</a> .  And UI in this case will be only a composition of these functions.  That is the formula for happiness from Facebook: <br><br> <code>UI = omponents(state)</code> <br> <br>  What does this mean?  This means that the state of the data must be obtained from outside the directives and prokkidyvatsya inside through the binding.  In this way we make the components more predictable.  In the top-level component there will be an entire state for the screen, it will prokidikd the necessary part of the state in the child components and so on. <br><br>  By making the components independent of the source of the state, we untie our hands on how we will receive and store the state.  We can use redux, rx.js, we can use the usual state-mutated approach, we can cache intermediate data, in a word ... we are limited only by our imagination.  This was originally the essence of MVC, which was invented back in the 79th year.  Complete separation of processing and storage logic from the formation logic of their presentation.  Having made this separation, we will not have any problems with the fact that independently change this and that.  And as a bonus, testing each individual component or service becomes very simple. <br><br>  Instead of changing the state directly in the component, it makes sense to ask the services to do this, putting all the responsibility on them.  They, in turn, will have to update the state at the top level, which will eventually update the state of the component that launched the entire chain. <br><br>  Here it is worth mentioning at once that there is a whole mass of tasks when it is not very convenient.  And because you can still a little bit of the state to store and change directly in the controller.  Usually this state is specific to this particular component.  For example - cropping pictures.  Agree, it sounds not very reasonable if we drive the data through the services and back to the component for each cursor offset.  It is better to store such things locally at the component level and ask the service to do something when we do some more explicit actions. <br><br><h2>  Components and routing </h2><br>  If we consider the UI as a hierarchy of components, then each screen will be a branch of our tree, and each nested screen will be another branch, etc.  And within each new branch we can determine the root, and create a component for it.  Deciding which component will be displayed will be decided by our router. <br><br>  In principle, such approaches have existed since the first versions of Angular, it was just not so convenient to do decomposition.  Instead of components, entire states / routes were responsible for isolating individual parts of the UI with their own pattern and behavior embedded in the controllers.  Each separate route can be perceived as a full-fledged component, just very fat.  Starting from the first versions, the developers have proposed the option of using revolvers to make these ‚Äúcomponents‚Äù easier to use.  However, decomposition is still inconvenient, and the sizes of templates and controllers grew rapidly. <br><br>  The guys from the uiRouter team tried to solve this problem by entering nested views, which can be perceived as splitting the UI into separate components, just not obvious.  We can also use resolves to separate the logic of receiving data, and we can also force the update of individual views. <br><br>  Let's go further!  Remove the behavior from the state controller (in essence, remove the controller), replace the template with one component, move the state into it from the resolvers through the binding attributes, and voila - everything is now predictable and easy. <br><br>  In addition to ngRoute and uiRouter, it is also worth looking at the angular-router, which is an adaptation of the angular2 router for the 1.x branch.  In general, we should not forget that soon the world will see the release of <a href="https://github.com/angular-ui/ui-router/tree/1.0.0alpha0">uiRouter 1.0</a> , in which there are also a lot of goodies. <br><br><h2>  $ scope is not needed! </h2><br>  Let's go even further!  <code>$scope</code> not needed!  Well, in the context of directives, it is still needed.  In particular, that would clean up after itself.  But it is not recommended to use it in controllers / services.  I really like the idea of ‚Äã‚Äãadding a rule to eslint that will swear for the presence of <code>$scope</code> somewhere other than the link-functions of the directives.  Instead of using <code>$scope</code> we can use the good old javascript and binding on the attributes of the controllers. <br><br>  This is not something new, the ability to bind values ‚Äã‚Äãto the controller attributes is not new, this opportunity appeared in angular 1.3, but since most of the examples in the documentation, as well as articles use <code>$scope</code> , I think it would be nice to discuss how can you live without it. <br><br>  We already considered the question of binding the controller attributes when we discussed the component APIs.  We now turn to the rest of the cases, when we really want to use <code>$scope</code> .  The first of them, perhaps, will be the use of the <code>$emit/$broadcast/$on</code> event system.  Just do not use them.  They are not accidentally tied to the hierarchy of scopes, and serve precisely for the notification of individual elements that something has happened.  In particular, the use of listeners is usually limited to tracking the <code>$destroy</code> event, on which we must remove everything we left behind and that will not be nailed by the garbage collector.  For example, event handlers on <code>document</code> . <br><br>  Using scop events to organize pub / sub in services, or even worse, tie some application logic to them, this is very bad.  And even though in very rare cases this may be useful, I recommend thinking 10 times before using <code>$scope</code> or <code>$rootScope</code> to implement the event system in your application, it is better to use separate libraries designed for this. <br><br>  Who are we next on the queue?  <code>$apply</code> and <code>$digest</code> .  These methods allow us to synchronize the state after asynchronous operations.  They run the $ digest loop, which collects the changes and starts the handlers.  Use these methods only where the asynchronous operation occurs directly.  And usually we have all this already wrapped in services.  To do something like that in the components is simply unwise.  In extreme cases, use the service <code>$timeout</code> .  If you are working with DOM events, then again there are directives for this, components should not know anything about DOM. <br><br>  Well, for sweet - <code>$watch</code> .  Oh, how wonderful it is when a developer decides to track state changes in the controllers, and even then to debug it.  But what if the top of the data can come to us through the bindings?  Suddenly we want to filter the collection, or something else specific.  Well ... let's think about it.  Values ‚Äã‚Äãmepsya on the properties of our controller.  Unlike the <code>$scope</code> , which is part of the framework, we have all the power over our controller.  Continuing to think ... we also have getters / setters!  This means that we can accurately determine the moment when our data has changed. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ get bindedValue() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$value; } set bindedValue(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$value = value; <span class="hljs-comment"><span class="hljs-comment">//    ,    - //  ,      this.makeSomethingWithNewValue(); } } angular.module('app').component('myComponent', { bindings: { "bindedValue": "=" }, template: `&lt;div&gt;- &lt;/div&gt;`, controller: MyComponent });</span></span></code> </pre> <br>  This is how simple it is.  Actually for this reason, such an interesting concept as <code>Object.observe</code> was excluded drafts of the standard.  Well, still think that we really need <code>$scope</code> ? <br><br><h2>  Unilateral Binding and Isolation </h2><br>  Angular has always been scolded for imposing two-way data binding.  Do not misunderstand, double-sided bindings are not bad, especially when working with complex forms.  But in most cases it would be possible to do one-sided.  It is for this reason that in Angular2 everything is built solely on one-sided binding, and if necessary, two-sided binding, just use a pair of one-sided, acting in opposite directions. <br><br>  But why is everyone so having bilateral binding, especially in the context of components?  As we have said, our components should not be concerned with how components work at lower levels.  And we transfer the necessary part of the state from top to bottom, and in principle, what happens to them further does not concern us.  But in the case of bilateral binding, we can easily lose control over the system, since the internal components can rewrite the state of the external ones.  This is somehow not good.  Let's see an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myValue = <span class="hljs-string"><span class="hljs-string">'take my value'</span></span>; } } angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>).component(<span class="hljs-string"><span class="hljs-string">'myComponent'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;my-nasty-component passed-value="$ctrl.myValue"&gt;&lt;/my-nasty-component&gt; &lt;p&gt;My Value: {{ $ctrl.myValue }}&lt;/p&gt; `</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: MyComponent }); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNastyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passedValue = <span class="hljs-string"><span class="hljs-string">'I\'m touching myself tonight!'</span></span>; } } angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>).component(<span class="hljs-string"><span class="hljs-string">'myNastyComponent'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">bindings</span></span>: { <span class="hljs-attr"><span class="hljs-attr">passedValue</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span> }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;span&gt;Mhahaa!&lt;/span&gt;`</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: MyNastyComponent });</code> </pre> <br>  What do you think, what value will be displayed?  Obviously not what we wanted.  Yes, of course, the example is contrived, but we can do this by chance and then search for the culprit for a long time.  Sometimes it is still worth limiting our capabilities. <br><br>  So, in Angular 1.5, the long-awaited feature appeared: one-way data binding with the isolation of directives' skoupa ( <a href="https://docs.angularjs.org/api/ng/service/%24compile">documentation</a> )!  It acts, as the name tells us, at the expense of forwarding the value from the upper level to the lower level, prohibiting changes to walk in the opposite direction.  Let's correct the example above, for this we just need to change the bindings of our <code>MyNastyComponent</code> : <br><br><pre> <code class="javascript hljs">bindings: { <span class="hljs-attr"><span class="hljs-attr">passedValue</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    },</span></span></code> </pre> <br>  And that's all, now when the controller of our harmful component changes the value of the <code>passedValue</code> property, it does not go up and remains at this level. <br><br>  It is important to note that, even though the entire object is not overwritten at the top level, this does not mean that you cannot change the state.  It is copying of objects that does not occur, only assignment of values ‚Äã‚Äãoccurs. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNastyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passedValue.message = <span class="hljs-string"><span class="hljs-string">'I\'m touching myself tonight!'</span></span>; } }</code> </pre> <br>  In the example above, we change the value of the object field.  And since objects in JS are assigned by reference, it changes everywhere.  You have to put up with this simply because copying objects can kill performance.  Too much price for peace of mind. <br><br>  So, we learned how to decompose UI into separate reusable elements, and also dealt with one-sided bindings.  Just do not forget that we no longer need <code>$scope</code> .  Now it would be impossible to poke it alive.  Or not? <br><br><h2>  Multi-slot trasklyud </h2><br>  Our reusable components are not yet fully reusable.  There is also a whole class of components that differ in their content, and they can be described as similar "wrappers" for different components.  However, these wrappers may also have a behavior.  Let's look at an example from material design.  Suppose we have a need to make many similar screenshots that differ in content but have a common structure: <br><br><img src="https://habrastorage.org/files/b2b/413/427/b2b413427a55469ea3090a83612dc45b.png"><br><br>        ?        "",       - . ,       ,    ?  ,      <br><br>       (transclude  )       .    <a href="https://en.wikipedia.org/wiki/Transclusion"></a> , ,   ,             . , ?  : <br><br><img src="https://habrastorage.org/files/068/cd9/8e9/068cd98e9a344a629629b0a3260368d3.png"><br><br>   .          ,          .  ,          ,       <code>transclude: true</code> ,     ngTransclude   .    <code>transcludeFn</code> ,      <a href="https://www.accelebrate.com/blog/angularjs-transclusion-part-1/"> </a> . <br><br>    ,       .   angular 1.5    - .    .       <code>true</code>   <code>transclude</code>  ,  : <br><br><pre> <code class="javascript hljs">transclude: { <span class="hljs-comment"><span class="hljs-comment">//       , //     //        slotName: 'elementSelector', //     ,      //         optionalSlotName: '?optionalElementSelector' }</span></span></code> </pre> <br>   ,        <code>ngTransclude</code>    : <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"component"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"component-main"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-transclude</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slotName"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"component-main"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-transclude</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"optionalSlotName"</span></span></span><span class="hljs-tag">&gt;</span></span>    ,    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">em</span></span></span><span class="hljs-tag">&gt;</span></span>optionalSlotName<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">em</span></span></span><span class="hljs-tag">&gt;</span></span>   . <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>   ,    ,   .   -      ,     .             .      <code>listView</code> ,       .       , ‚Ä¶     ,         .    -            . :           . <br><br><h2>    ? </h2><br>       .   ‚Äî   ,      .           . <br><br>    <code>ngRepeat</code> , <code>ngShow</code>  <code>ngIf</code>     ,      .   DOM ,      . <br><br>          ,    <code>input</code>  ,       .         ,    <code>require</code> ,      . <br><br>      <code>listView</code> ,     -,          pull-to-refresh.       .            ,         ! <br><br><h2>   </h2><br>    ,         .    ,          ,  ,      ,     .     ,             (          ).       ,         (           ). ,       ? <br><br>      ,        . Stateless    ,          .     ,     ,  .         . <br><br>  ,    Angular   ,     UI .  ,        UI,        DOM,     ,       . <br><br>      ‚Äî   ,     .      ,       ,       e2e .  Angular2    ,             .   1.x    . <br><br> ,       : <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'my component'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> component; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyComponent(); component.someState = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; }); it(<span class="hljs-string"><span class="hljs-string">'sorts collection before render'</span></span>, () =&gt; { expect(component.sortedCollection).toBe.equal([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); }); });</code> </pre> <br> ,   .   Angular .  javascript!     dirty checking-    ,      DOM,    React.    UI   ,      . <br><br>    .        ,           .    ,   <code>angular-mock</code>    <code>$componentController</code> ,           ,      Angular.       (    ) ,       . <br><br><h2>  ? </h2><br>        ,         ,        4-    ‚Ä¶     ,    .     Angular 1.5  Angular2    .        ,    ,  ngUpdate.     ,    Angular2   ,   ,       Angular2. <br><br><h2>  ? </h2><br>  ,     - .            .               ,       : <br><br> <a href="http://run.plnkr.co/plunks/Q7dZ77IOOENzNZX3JHkj/">  </a> <br><br>    ,  ,      <code>$scope.$watch</code>    -   .                ,   ,    ,   .               .   ,       . <br><br>  ! <br></div><p>Source: <a href="https://habr.com/ru/post/277087/">https://habr.com/ru/post/277087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277069/index.html">Neurorevolution in heads and villages</a></li>
<li><a href="../277077/index.html">Near-architecture arguments or the results of a single dispute</a></li>
<li><a href="../277079/index.html">We send messages to Telegram from C #</a></li>
<li><a href="../277081/index.html">From FineReader to data entry solutions: how the direction of DataCapture in ABBYY began</a></li>
<li><a href="../277085/index.html">CodingFuture + Puppet. Part I: network and network filter (cfnetwork + cffirehol)</a></li>
<li><a href="../277089/index.html">Google refuses to flash in advertising</a></li>
<li><a href="../277091/index.html">Security Week 06: bank robbery on the stream, breaking the grid, Poseidon / Amebey / Kianokhet</a></li>
<li><a href="../277093/index.html">Working with USB devices in Android</a></li>
<li><a href="../277097/index.html">UFCS in the programming language D</a></li>
<li><a href="../277099/index.html">Katya, Go, Dcoin and Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>