<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are looking for three times faster: multi-queries and faceted search</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In today's article I‚Äôll tell you about the feature of Sphinx called multi-queries: embedded in it optimization, implementation tn. faceted search, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are looking for three times faster: multi-queries and faceted search</h1><div class="post__text post__text-html js-mediator-article">  In today's article I‚Äôll tell you about the feature of <a href="http://sphinxsearch.com/">Sphinx</a> called multi-queries: embedded in it optimization, implementation tn.  faceted search, and in general how sometimes you can use it to make the search three times faster. <br><br>  But first, 15 seconds of political information (you cannot praise yourself, no one will praise).  This year, Sphinx went to the <a href="http://sf.net/community/cca09/vote/%3Ff%3D486">second round of the Sourceforge Awards 2009</a> in the SysAdmins and Enterprise nominations (it is said that in the nomination Developers didn‚Äôt get quite a bit).  Voting will last another week (until the 20th).  In addition to the working email address, nothing is needed.  Thanks in advance to everyone who will not give us the abyss! <br><br>  And back to the design.  What is multi-requests in general, and where does the promise come from three times faster? <br><a name="habracut"></a><br>  <b>Multi-queries</b> is a mechanism that allows you to send several search queries in one batch. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      API methods that implement the multi-query mechanism are called <b>AddQuery ()</b> and <b>RunQueries ()</b> .  (By the way, the ‚Äúnormal‚Äù Query () method internally uses them: once it calls AddQuery (), and then immediately RunQueries ()).  The AddQuery () method saves the current state of all query settings made by previous API calls and remembers the query.  The settings of an already stored request will not be changed anymore, any API calls will not affect them, so for subsequent requests you can use any other settings (other sorting mode, other filters, etc.).  The RunQueries () method actually sends all stored requests in one packet and returns several results.  There are no restrictions on participating requests.  The number of requests, just in case, is limited by the max_batch_queries directive (added at 0.9.10, a previously fixed number of 32), but this is in general only a check against dead packets. <br><br>  <b>Why use multi-queries?</b>  Generally speaking, it all comes down to performance.  First, by sending requests to searchd in one packet, we always save a little bit of resources and time by sending fewer network packets back and forth.  Secondly, much more importantly, searchd gets the opportunity to do some optimization over the entire batch of requests.  Over time, new optimizations are gradually added, so it makes sense whenever you can send requests in batches - then when updating Sphinx, new batch optimizations will turn on fully automatically.  In the case when no batch optimizations can be applied, the requests will simply be processed one by one, without any visible differences for the application. <br><br>  Why (more precisely when) do NOT use multi-requests?  All queries in the package must be independent, but sometimes this is not the case, and query B may depend on the results of query A. For example, we may want to show search results from an additional index only when nothing is found in the main index.  Or simply choose a different offset in the 2nd set of results depending on the number of matches in the 1st set.  In such cases, you will have to use separate requests (or individual packages). <br><br>  There are two important batch optimizations that you should know about: general query optimization (available starting with version 0.9.8), and optimization of common subtrees (available starting from the development version 0.9.10). <br><br>  <b>General query optimization</b> works like this.  searchd selects from the package all requests that differ only in the sorting and grouping settings, and the full-text part, filters, and so on match - and searches only once.  For example, if in packet 3 queries, the text part is on all ipod nano, but the 1st query selects the 10 cheapest results, the 2nd groups the results by store ID and sorts the stores by rating, and the 3rd query simply selects the maximum price, search ‚Äúipod nano ¬ªWill work only once, but from its results 3 differently sorted and grouped responses will be constructed. <br><br>  The so-called <b>faceted search</b> is a special case for which this optimization is applicable.  In fact, it can be implemented by running several search queries with different settings: one for the main search results, a few more with the same search query, but different grouping settings (top-3 authors, top-5 stores, etc.).  When everything except for sorting and grouping is the same, the optimization is turned on and the speed grows well (example below). <br><br>  <b>Optimizing common subtrees is</b> even more interesting.  It allows searchd to use similarities between different queries inside the package.  Inside all came separate - different!  - full-text queries are revealed common parts, and if they are, the intermediate results of the calculation are cached and divided between requests.  For example, here in this package of 3 requests <br><br><pre> barack obama president
 barack obama john mccain
 barack obama speech
</pre><br><br>  There is a common part of 2 words (‚Äúbarack obama‚Äù), which can be calculated exactly once for all three queries and zakeshirovat.  This is the optimization of common subtrees.  The maximum cache size per packet is strictly limited to the directives subtree_docs_cache and subtree_hits_cache, so that if the common part of ‚Äúi am‚Äù is found in one hundred million documents, the server‚Äôs memory will not end suddenly. <br><br>  Let's return back to optimization about the general requests.  Here is an example of code that runs the same query, but with three different sorting modes: <br>  sorting modes: <br><br><pre> require ("sphinxapi.php");
 $ cl = new SphinxClient ();
 $ cl-&gt; SetMatchMode (SPH_MATCH_EXTENDED2);

 $ cl-&gt; SetSortMode (SPH_SORT_RELEVANCE);
 $ cl-&gt; AddQuery ("the", "lj");
 $ cl-&gt; SetSortMode (SPH_SORT_EXTENDED, "published desc");
 $ cl-&gt; AddQuery ("the", "lj");
 $ cl-&gt; SetSortMode (SPH_SORT_EXTENDED, "published asc");
 $ cl-&gt; AddQuery ("the", "lj");
 $ res = $ cl-&gt; RunQueries ();
</pre><br><br>  How do I know if the optimization worked?  If it worked, in the corresponding lines of the log there will be a field with a ‚Äúmultiplier‚Äù, which shows how many requests were processed together: <br><br><pre> [Sun Jul 12 15: 18: 17.000 2009] 0.040 sec x3 [ext2 / 0 / rel 747541 (0.20)] [lj] the
 [Sun Jul 12 15: 18: 17.000 2009] 0.040 sec x3 [ext2 / 0 / ext 747541 (0.20)] [lj] the
 [Sun Jul 12 15: 18: 17.000 2009] 0.040 sec x3 [ext2 / 0 / ext 747541 (0.20)] [lj] the
</pre><br><br>  Pay attention to "x3", this is it - it means that the request was optimized and processed in the package of 3 requests (including this one).  For comparison, the log looks like this, in which the same requests were sent one by one: <br><br><pre> [Sun Jul 12 15: 18: 17.062 2009] 0.059 sec [ext2 / 0 / rel 747541 (0.20)] [lj] the
 [Sun Jul 12 15: 18: 17.156 2009] 0.091 sec [ext2 / 0 / ext 747541 (0.20)] [lj] the
 [Sun Jul 12 15: 18: 17.250 2009] 0.092 sec [ext2 / 0 / ext 747541 (0.20)] [lj] the
</pre><br><br>  It can be seen that the search time for each query in the case of multi-query improved from 1.5 to 2.3 times, depending on the sorting mode.  In fact, this is not the limit.  For both optimizations, there are cases when the speed improved 3 or more times - and not on synthetic tests, but quite in production.  Optimization of general queries rather well rests on vertical searches for products and online stores, the cache of common subtrees coherently on data mining queries;  but, of course, strictly these areas are not limited to applicability.  For example, you can do a search without any full-text part at all and read several different reports (with different sorting, grouping, etc.) using the same data for one query. <br><br>  What other optimizations can be expected in the future?  It depends on you.  So far, in the long term, a clear optimization has been recorded about identical requests with different sets of filters.  Do you know another frequent pattern that can be cleverly optimized?  Please send! </div><p>Source: <a href="https://habr.com/ru/post/64318/">https://habr.com/ru/post/64318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../64312/index.html">Interview with co-owner of the eTorg group of companies, Boris Preobrazhensky</a></li>
<li><a href="../64313/index.html">How to find $ 1 000 000?</a></li>
<li><a href="../64314/index.html">Greenmob - how can I help the planet?</a></li>
<li><a href="../64315/index.html">Execute sudo while writing</a></li>
<li><a href="../64317/index.html">Writing an applet for GNOME in Python</a></li>
<li><a href="../64319/index.html">Comparison table of the latest smartphones</a></li>
<li><a href="../64320/index.html">Light sensitive fabric as a photosensor</a></li>
<li><a href="../64322/index.html">Tale of the rowers team</a></li>
<li><a href="../64323/index.html">XHTML is dead? Long live XHTML!</a></li>
<li><a href="../64324/index.html">Soundblogging by sounds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>