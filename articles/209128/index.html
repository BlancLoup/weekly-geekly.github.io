<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>But how does multithreading work? Part II: memory ordering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The knowledge of flow management that we received in the past topic , of course, is great, but there are still a lot of questions. For example: ‚ÄúHow d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>But how does multithreading work? Part II: memory ordering</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/42f/afb/92b/42fafb92b3ff5480347a4869a3ec6914.jpg" align="left" title="Java Duke pokes a finger at DiCaprio‚Äôs nose, as if hinting at us: we need to go deeper" alt="   "><br><br>  The knowledge of flow management that we received in the <a href="http://habrahabr.ru/post/143237/">past topic</a> , of course, is great, but there are still a lot of questions.  For example: <i>‚ÄúHow does the happens-before work?‚Äù</i> , <i>‚ÄúIs it true that <code>volatile</code> is a reset of caches?‚Äù</i> , <i>‚ÄúWhy was there any reason to</i> <i>build</i> <i>a memory model?</i>  <i>Was it all normal that something started like that? ‚Äù</i> <br><br>  Like the previous article, this one is built on the principle of ‚Äúfirst briefly describe what should happen in theory, and then go to the source and see how it happens there.‚Äù  Thus, the first part is largely applicable not only to Java, and therefore developers for other platforms may find something useful for themselves. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  <font color="darkred">Theoretical minimum</font> </h1>  The increasing productivity of iron is increasing for a reason.  Engineers who develop, say, processors, come up with a variety of different optimizations that allow you to squeeze even more abstract parrots out of your code.  However, there is no free performance, and in this case the price turns out to be the possible counterintuitiveness of how your code is executed.  There are a lot of various features of iron hidden from us by abstractions.  I recommend to those who have not yet done so, read the <a href="http://javapoint.ru/talks/13/">report by</a> Sergei <a href="https://habrahabr.ru/users/walrus/" class="user_link">Walrus</a> Kuksenko, who is called Quantum Performance Effects, and perfectly demonstrates how unexpectedly your abstractions can flow.  We will not go far for example, and take a look at the caches. <br><br><h2>  <font color="darkgreen">Cache device</font> </h2><br>  A request for ‚Äúmain memory‚Äù is an expensive operation, and even on modern machines it can take hundreds of nanoseconds.  During this time, the processor could have time to perform a lot of instructions.  To avoid obscenity in the form of eternal downtime, used caches.  In simple words, the processor stores right next to itself copies of frequently used main memory contents.  More complicated words about different types of caches and their hierarchies can be read <a href="http://arstechnica.com/gadgets/2002/07/caching/2/">here</a> , and we are more interested in how the relevance of the data in the cache is guaranteed.  And if in the case of a single processor (or a core, the term processor will be used in the future), obviously, there are no problems, then if there are several cores <font color="lightgrey">(YAY MULTITHREADING!)</font> , Questions already begin to arise. <br><blockquote>  How can processor <strong>A</strong> know that processor <strong>B has</strong> changed some value if <strong>A has</strong> it cached? <br><br>  Or, in other words, how to ensure the <strong>coherence of caches?</strong> </blockquote><br>  In order for different processors to have a consistent picture of the world, they must communicate with each other in some way.  The rules that they follow in this communication are called <b>cache coherence protocol</b> . <br><br><h2>  <font color="darkgreen">Cache Coherence Protocols</font> </h2><br>  There are many different protocols, and they vary not only from the manufacturer of iron to the manufacturer of iron, but are constantly evolving even within a single vendor.  However, despite the vastness of the protocol world, most of them have some common points.  Slightly diminishing the commonality, we will consider the <strong>MESI protocol</strong> .  Of course, there are approaches that differ radically from him: for example, <a href="http://www.cs.washington.edu/education/courses/cse471/00au/Lectures/luke_directories.pdf">Directory Based</a> .  However, they are not considered in this article. <br><br>  In MESI, however, each cell in the cache can be in one of four states: <br><ul><li>  <strong>I</strong> nvalid: no value in cache </li><li>  <strong>E</strong> xclusive: the value is only in this cache, and it has not yet been changed. </li><li>  <strong>M</strong> odified: the value is changed by this processor, and it is not yet in the main memory or in the cache of any other processor. </li><li>  <strong>S</strong> hared: value is present in the cache of more than one processor. </li></ul><br><br>  To go out of state, there is a message exchange, the format of which is also part of the protocol.  By the way, it is rather ironic that at such a low level the change of states occurs precisely through the exchange of messages.  Problem, Actor Model Haters? <br><br>  In order to reduce the size of the article and the reader‚Äôs self-study, I will not describe the exchange of messages in detail.  Those interested can get this information, for example, in the wonderful article <a href="http://yandex.ru/yandsearch%3Ftext%3DMemory%2BBarriers%253A%2Ba%2BHardware%2BView%2Bfor%2BSoftware%2BHackers">Memory Barriers: a Hardware View for Software Hackers</a> .  Traditionally, deeper reflections on the topic of <a href="https://habrahabr.ru/users/cheremin/" class="user_link">cheremin</a> can be <a href="http://cheremin.blogspot.com/2012/01/cache-coherency-msi-mesi-mesif-moesi.html">read in his blog</a> . <br><br>  Cleverly skipping the description of the messages themselves, we will make two comments about them.  First, messages are not delivered instantly, with the result that we get latency on state changes.  Secondly, some messages require special processing, resulting in processor downtime.  All this leads to various problems of scalability and performance. <br><br><h3>  Optimizations for MESI and the problems they cause </h3><br><h4>  Store buffers </h4><br>  In order to write something to a memory cell that is in the Shared state, you need to send an Invalidate message and wait for everyone to confirm it.  All this time, the processor will be idle, which is incredibly sad, because the time during which the message will arrive is usually several orders of magnitude higher than is necessary to perform simple instructions.  To avoid such a senseless and merciless loss of CPU time, we invented <strong>Store Buffers</strong> .  The processor places the values ‚Äã‚Äãit wants to write into this buffer and continues to execute the instructions.  And when the necessary Invalidate Acknowledge is received, the data is finally sent to main memory. <br><br>  Of course, there are several underwater rakes.  The first of them are very obvious: if, before the value leaves the buffer, the same processor will try to read it, it will receive something completely different from what it has just written.  This is solved with the help of <strong>Store Forwarding</strong> : it is always checked whether the requested value is in the buffer;  and if it is there, then the value is taken from there. <br><br>  But the second rake is much more interesting.  Nobody guarantees that if the cells were placed in the same order in the store buffer, then they will be written in the same order.  Consider the following piece of pseudocode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ value = <span class="hljs-number"><span class="hljs-number">10</span></span>; finished = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!finished); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> value == <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre><br>  It would seem that could go wrong?  Contrary to how you can think a lot.  For example, if it turns out that by the time the code executes, <code>finished</code> , Cpu0 is in the Exclusive state, and <code>value</code> is in the state, for example, Invalid, then <code>value</code> will leave the buffer later than the <code>finished</code> .  And it is quite possible that Cpu1 will read <code>finished</code> as <code>true</code> , while <code>value</code> will not be equal to 10. This phenomenon is called <strong>reordering</strong> .  Of course, reordering occurs not only in this case.  For example, the compiler for any reason may well swap some instructions. <br><br><h4>  Invalidate Queues </h4><br>  As you can easily guess, store buffers are not infinite, and therefore tend to overflow, as a result of which you still often have to wait for Invalidate Acknowledge.  And they can sometimes run for a very long time if the processor and cache are busy.  This problem can be solved by introducing a new entity: <strong>Invalidate Queue</strong> .  All requests for invalidation of memory cells will be placed in this queue, and acknowledgment will be sent instantly.  In fact, the values ‚Äã‚Äãwill be invalidated when the processor is comfortable.  In this case, the processor promises to behave well, and will not send any messages on this cell as long as it is not disabled.  Feel the catch?  Let's return to our code. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ value = <span class="hljs-number"><span class="hljs-number">10</span></span>; finished = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!finished); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> value == <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre><br><br>  Suppose we were lucky (or we used some kind of secret knowledge), and Cpu0 recorded the memory cells in the order we need.  Does this guarantee that they will fall into the Cpu1 cache in the same manner?  As you could understand, no.  We will also assume that the <code>value</code> cell is now in the Cpu1 cache in the Exclusive state.  The order of the actions taking place then may be: <br><br><table><tbody><tr><td>  # </td><td>  Cpu0 </td><td>  Cpu0: value </td><td>  Cpu0: finished </td><td>  Cpu1 </td><td>  Cpu1: value </td><td>  Cpu1: finished </td></tr><tr><td>  0 </td><td>  <font color="lightgrey">(...)</font> </td><td>  0 (Shared) </td><td>  false (Exclusive) </td><td>  <font color="lightgrey">(...)</font> </td><td>  0 (Shared) </td><td>  (Invalid) </td></tr><tr><td colspan="7"></td></tr><tr><td>  one </td><td><pre> <code class="java hljs">value = <span class="hljs-number"><span class="hljs-number">10</span></span>; - store_buffer(value) ‚Üê invalidate(value)</code> </pre> </td><td>  0 (Shared) <br>  <strong><font color="darkgreen">(10 in store buffer)</font></strong> </td><td>  false (Exclusive) </td></tr><tr><td>  2 </td><td colspan="3"></td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!finished); ‚Üê read(finished)</code> </pre> </td><td>  0 (Shared) </td><td>  (Invalid) </td></tr><tr><td>  3 </td><td><pre> <code class="java hljs">finished = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> </td><td>  0 (Shared) <br>  (10 in store buffer) </td><td>  <strong><font color="darkgreen">true (Modified)</font></strong> </td></tr><tr><td>  four </td><td colspan="3"></td><td><pre> <code class="java hljs">‚Üí invalidate(value) ‚Üê invalidate_ack(value) - invalidate_queue(value)</code> </pre> </td><td>  0 (Shared) <br>  <strong><font color="darkgreen">(in invalidation queue)</font></strong> </td><td>  (Invalid) </td></tr><tr><td>  five </td><td><pre> <code class="java hljs">‚Üí read(finished) ‚Üê read_resp(finished)</code> </pre> </td><td>  0 (Shared) <br>  (10 in store buffer) </td><td>  <strong><font color="darkgreen">true (Shared)</font></strong> </td></tr><tr><td>  6 </td><td colspan="3"></td><td><pre> <code class="java hljs">‚Üí read_resp(finished)</code> </pre> </td><td>  0 (Shared) <br>  (in invalidation queue) </td><td>  <strong><font color="darkgreen">true (Shared)</font></strong> </td></tr><tr><td>  7 </td><td colspan="3"></td><td><pre> <code class="java hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> value == <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> </td><td>  0 (Shared) <br>  (in invalidation queue) </td><td>  true (Shared) </td></tr><tr><td colspan="4"></td><td colspan="3" align="center">  <font color="darkred"><strong>Assertion fails</strong></font> </td></tr><tr><td>  N </td><td colspan="3"></td><td><pre> <code class="java hljs">- invalidate(value)</code> </pre> </td><td>  <strong><font color="darkgreen">(Invalid)</font></strong> </td><td>  true (Shared) </td></tr></tbody></table><br><br>  Multithreading is simple and straightforward, isn't it?  The problem is in steps (4) - (6).  Having received <code>invalidate</code> in (4), we do not execute it, but write it to the queue.  And in step (6) we get a <code>read_response</code> to the <code>read</code> request, which was sent earlier to (2).  However, this does not make us invalidate the <code>value</code> , and therefore assertion falls.  If operation (N) had been completed earlier, then we would still have a chance, but now this damn optimization has broken us all!  But on the other hand, she is so fast and gives us ultra-louitensi ‚Ñ¢!  That's a dilemma.  Iron developers cannot magically know in advance when the use of optimization is permissible, and when it can break something.  And so they pass the problem on to us, adding: ‚ÄúIt's dangerous to go alone.  Take this! ‚Äù <br><br><h3>  <font color="darkgreen">Hardware Memory Model</font> </h3><br>  The magic sword supplied by the developers who went to fight dragons is actually not a sword, but rather the Rules of the Game.  They describe what values ‚Äã‚Äãthe processor can see when they or other processors perform certain actions.  But Memory Barrier is already something much more like a sword.  In our example MESI there are such swords: <br><br><blockquote>  <strong>Store Memory Barrier</strong> (also ST, SMB, smp_wmb) is an instruction that forces the processor to execute all the stores that are already in the buffer, before executing those that follow this instruction </blockquote><br><blockquote>  <strong>Load Memory Barrier</strong> (also LD, RMB, smp_rmb) is an instruction that forces the processor to apply all invalidate ones already in the queue before executing any load instructions </blockquote><br><br>  Having a new weapon at our disposal, we can easily repair our example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ value = <span class="hljs-number"><span class="hljs-number">10</span></span>; storeMemoryBarrier(); finished = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!finished); loadMemoryBarrier(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> value == <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre><br><br>  Great, everything works, we are satisfied!  You can go and write cool productive and correct multi-threaded code.  Although stop ... <br><br><h1>  <font color="darkred">It would seem, where is Java?</font> </h1><br><h2>  <font color="darkgreen">Write Once @ Run Anywhere</font> </h2><br>  All of these various cache coherence protocols, membranes, flushed caches and other platform-specific things should not, in theory, bother those who write Java code.  Java is platform-independent, right?  Indeed, there is no concept of reordering in the Java Memory Model. <blockquote>  <font color="darkred"><b>NB</b> : If this phrase confuses you, do not continue reading the article until you understand why.</font>  <font color="darkred">And read, for example, <a href="http://cheremin.blogspot.ru/2013/02/blog-post_26.html">this</a></font> . </blockquote>  In general, it sounds interesting.  There is no ‚Äúreordering‚Äù concept, but there is reordering itself.  The authorities are clearly hiding something!  But even if we abandon the conspiracy assessment of the surrounding reality, we will remain with curiosity and a desire to know.  Saturate him!  Take a simple class that illustrates our recent example: <sup>[ <a href="">github</a> ]</sup> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSubject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> finished; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ value = <span class="hljs-number"><span class="hljs-number">10</span></span>; finished = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!finished); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> value == <span class="hljs-number"><span class="hljs-number">10</span></span>; } }</code> </pre><br><br>  Traditionally, there are several approaches to finding out what is happening there.  You can have fun with <code>PrintAssembly</code> , you can see what the interpreter does, you can overcome the secret knowledge of those who already know.  You can <a href="http://lesswrong.com/lw/iu/mysterious_answers_to_mysterious_questions/">say with a mysterious look</a> that the caches are dropped there and calm down. <br><br>  Last time we looked at the sish interpreter, <a href="http://habrahabr.ru/post/143237/">which is not really used in production</a> .  This time we will look at how the client compiler (C1) operates.  I used <a href="https://jdk7.java.net/source.html">openjdk-7u40-fcs-src-b43-26_aug_2013</a> for my own purposes. <br><br>  For a person who has not previously opened the source code of OpenJDK (as well as for the one who opened it), it can be a difficult task to find where the necessary actions are performed in them.  One of the easiest ways to do this is to look at the bytecode and find out the name of the instruction you need, and then look for it. <br><br><pre> <code class="java hljs">$ javac TestSubject.java &amp;&amp; javap -<span class="hljs-function"><span class="hljs-function">c TestSubject </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executedOnCpu0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: aload_0 <span class="hljs-comment"><span class="hljs-comment">//    this 1: bipush 10 //    10 3: putfield #2 //     this (value)    (10) 6: aload_0 //    this 7: iconst_1 //    1 8: putfield #3 //     this (finished)    (1) 11: return void executedOnCpu1(); Code: 0: aload_0 //    this 1: getfield #3 //      this (finished) 4: ifne 10 //    ,     10( ) 7: goto 0 //     10: getstatic #4 //     $assertionsDisabled:Z 13: ifne 33 //  assertions ,    33() 16: aload_0 //    this 17: getfield #2 //      this (value) 20: bipush 10 //    10 22: if_icmpeq 33 //      ,    33() 25: new #5 //   java/lang/AssertionError 28: dup //      29: invokespecial #6 //   ( &lt;init&gt;) 32: athrow //  ,      33: return</span></span></code> </pre><br><blockquote>  <font color="darkred"><b>NB</b> : You should not try to determine the exact behavior of the program in runtime by bytecode.</font>  <font color="darkred">After the JIT compiler does its job, things can change very much.</font> </blockquote>  What interesting things can we notice here?  The first little thing that many people forget is that assertions are turned off by default.  You can enable them in <code>-ea</code> using the <code>-ea</code> key.  But it is, nonsense.  What we came here for is the names of the <code>getfield</code> and <code>putfield</code> .  Are you thinking the same thing about me?  <font color="lightgrey">(Of course, Gleb! Just how do we build the Dyson Sphere of bacon, a plunger, and <a href="http://clck.ru/846"><font color="lightgrey">two bras</font></a> ?!)</font> <br><br><h2>  <font color="darkgreen">Down the Rabbit Hole</font> </h2><br>  Drawing attention to the fact that the same instructions are used for both fields, let's see where the information is that the field is <code>volatile</code> .  To store field data, the class <code>share/vm/ci/ciField.hpp</code> .  We are interested in the method <br><table><tbody><tr><td width="60"><pre> <code class="hljs">176</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flags().is_volatile(); }</code> </pre></td></tr></tbody></table>  To find out what C1 does with access to <code>volatile</code> fields, you can find all the uses of this method.  After a little wandering around the dungeons and collecting several Scrolls of Ancient Knowledge, we find ourselves in the file <code>share/vm/c1/c1_LIRGenerator.cpp</code> .  As his name suggests, he is engaged in the generation of the low-level intermediate representation ( <strong>LIR</strong> , Low-Level Intermediate Representation) of our code. <br><br><h3>  C1 Intermediate Representation on the example of <code>putfield</code> </h3><br>  When creating IR in C1, our <code>putfield</code> instruction is eventually processed here.  Consider special actions that are performed for <code>volatile</code> fields and rather quickly come across familiar words: <br><table><tbody><tr><td width="60"><pre> <code class="hljs">1734 1735 1736</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_volatile &amp;&amp; os::is_MP()) { __ membar_release(); }</code> </pre> </td></tr></tbody></table>  Here <code>__</code> is a macro that is expanded in <code>gen()-&gt;lir()-&gt;</code> .  And the <code>membar_release</code> method <code>membar_release</code> defined in <code>share/vm/c1/c1_LIR.hpp</code> : <br><table><tbody><tr><td width="60"><pre> <code class="hljs">1958</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">membar_release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ append(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LIR_Op0(lir_membar_release)); }</code> </pre> </td></tr></tbody></table>  In fact, this line added the membar_release instruction to the intermediate representation of our code.  After this, the following occurs: <br><table><tbody><tr><td width="60"><pre> <code class="hljs">1747 1748 1749</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_volatile &amp;&amp; !needs_patching) { volatile_field_store(value.result(), address, info); }</code> </pre> </td></tr></tbody></table>  The implementation of the <code>volatile_field_store</code> method is already platform dependent.  On x86 ( <code>cpu/x86/vm/c1_LIRGenerator_x86.cpp</code> ), for example, the actions are quite simple: it is checked whether the field is 64-bit, and if so, then Black Magic is used to ensure that the recording is atomic.  Still, remember that in the absence of a <code>volatile</code> , <code>long</code> and <code>double</code> fields <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html">can be written nonatomically</a> ? <br><br>  And finally, at the very end, another membar is placed, this time without release: <br><table><tbody><tr><td width="60"><pre> <code class="hljs">1759 1760 1761</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_volatile &amp;&amp; os::is_MP()) { __ membar(); }</code> </pre> </td></tr><tr><td width="60"><pre> <code class="hljs">1956</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">membar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ append(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LIR_Op0(lir_membar)); }</code> </pre> </td></tr></tbody></table><blockquote>  <font color="grey"><b>NB</b> : I, of course, treacherously concealed some of the actions taking place.</font>  <font color="grey">For example, the manipulations associated with GC.</font>  <font color="grey">Examine them is offered to the reader as an independent exercise.</font> </blockquote><br><br><h3>  Convert IR to assembler </h3><br>  We passed only ST and LD, and here there are new types of barriers.  The fact is that what we saw before is an example of barriers for a low-level MESI.  And we have already moved to a higher level of abstraction, and the terms have changed somewhat.  Suppose we have two types of memory operations: Store and Load.  Then there are four ordered combinations of two operations: Load and Load, Load and Store, Store and Load, Store and Store.  We considered two categories: <strong>StoreStore</strong> and <strong>LoadLoad</strong> - and there are those barriers that we saw, speaking of MESI.  The other two should also be fairly easily digestible.  All <strong>loads</strong> produced prior to the <strong>LoadStore</strong> must complete before any store after.  With <strong>StoreLoad</strong> , respectively, the opposite.  More details about this can be found, for example, in the <a href="http://g.oswego.edu/dl/jmm/cookbook.html">JSR-133 Cookbook</a> . <br><br>  In addition, the concepts of operations with <strong>Acquire</strong> semantics and operations with <strong>Release</strong> semantics are distinguished.  The latter is applicable to write operations, and ensures that any actions with memory going before this operation must complete before it starts.  In other words, the operation with write-release semantics cannot be reorder with any memory operation going to it in the program text.  Such a semantics can provide us with the LoadStore + StoreStore memory barrier combination.  Acquire, as you might guess, has opposite semantics, and can be expressed using the LoadStore + LoadLoad combination. <br><br>  Now we understand which membranes the JVM places.  However, so far we have only seen this in LIR, which, although Low-level, is still not a native code that should generate us a JIT.  Exploring exactly how C1 converts LIR into native code is beyond the scope of this article, so we‚Äôll go straight to the file <code>share/vm/c1/c1_LIRAssembler.cpp</code> without any reservations.  This is where all the transformation of IR into assembler code happens.  For example, in a very sinister line, <code>lir_membar_release</code> considered: <table><tbody><tr><td width="60"><pre> <code class="hljs">665 666 667</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lir_membar_release: membar_release(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> </td></tr></tbody></table>  The called method is already platform dependent, and the source code for x86 is in <code>cpu/x86/vm/c1_LIRAssembler_x86.cpp</code> : <br><table><tbody><tr><td width="60"><pre> <code class="hljs">3733 3734 3735 3736</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LIR_Assembler::membar_release() { <span class="hljs-comment"><span class="hljs-comment">// No x86 machines currently require store fences // __ store_fence(); }</span></span></code> </pre> </td></tr></tbody></table>  Gorgeous!  Thanks to a strict memory model (including TSO - Total Store Order Order), on this architecture, all entries already have release semantics.  But with the second membar everything is a bit more complicated: <br><table><tbody><tr><td width="60"><pre> <code class="hljs">3723 3724 3725 3726</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LIR_Assembler::membar() { <span class="hljs-comment"><span class="hljs-comment">// QQQ sparc TSO uses this, __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad)); }</span></span></code> </pre> </td></tr></tbody></table><br>  Here the macro <code>__</code> takes place in <code>_masm-&gt;</code> , and the <code>membar</code> method lies in <code>cpu/x86/vm/assembler_x86.hpp</code> and looks like this: <br><table><tbody><tr><td width="60"><pre> <code class="hljs">1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">membar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Membar_mask_bits order_constraint)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (os::is_MP()) { <span class="hljs-comment"><span class="hljs-comment">// We only have to handle StoreLoad if (order_constraint &amp; StoreLoad) { // All usable chips support "locked" instructions which suffice // as barriers, and are much faster than the alternative of // using cpuid instruction. We use here a locked add [esp],0. // This is conveniently otherwise a no-op except for blowing // flags. // Any change to this code may need to revisit other places in // the code where this idiom is used, in particular the // orderAccess code. lock(); addl(Address(rsp, 0), 0);// Assert the lock# signal here } } }</span></span></code> </pre> </td></tr></tbody></table>  It turns out that on x86 to write each <code>volatile</code> variable we set an expensive StoreLoad barrier in the form of <code>lock addl $0x0,(%rsp)</code> .  The operation is expensive because it forces us to run the entire Store in a buffer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it gives us the same effect that we expect from </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- all other streams will see at least the value that was relevant at the time of its execution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that read on x86 should be the most common read. </font><font style="vertical-align: inherit;">A cursory inspection of the method </font></font><code>LIRGenerator::do_LoadField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tells us that after reading, as we expected, membar_acquire is set, which looks like this on x86:</font></font><br><table><tbody><tr><td width="60"><pre> <code class="hljs">3728 3729 3730 3731</code> </pre> </td><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LIR_Assembler::membar_acquire() { <span class="hljs-comment"><span class="hljs-comment">// No x86 machines currently require load fences // __ load_fence(); }</span></span></code> </pre> </td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This, of course, does not mean yet that it </font></font><code>volatile read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not introduce any overhead projector as compared with the usual one </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, even though nothing is added to the native code, the presence of a barrier in the IR itself prohibits the compiler from rearranging some instructions. </font><font style="vertical-align: inherit;">(otherwise you can catch </font></font><a href="https://bugs.openjdk.java.net/browse/JDK-7170145"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funny bugs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">There are many other effects from using volatile. </font><font style="vertical-align: inherit;">You can read about it, for example, in </font></font><a href="http://brooker.co.za/blog/2012/09/10/volatile.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2> <font color="darkgreen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check for lice</font></font></font> </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PrintAssembly </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sitting and guessing on the source code is a noble occupation worthy of any self-respecting philosopher. </font><font style="vertical-align: inherit;">However, just in case, we still look in </font></font><code>PrintAssembly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To do this, we add to the experimental rabbit many calls of the necessary methods in the loop, disable inlineing (to make it easier to navigate the generated code) and run in the client VM, without forgetting to enable assertions:</font></font><br><br><pre> <code class="hljs mel">$ java -client -ea -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:MaxInlineSize=<span class="hljs-number"><span class="hljs-number">0</span></span> TestSubject ... # {method} <span class="hljs-string"><span class="hljs-string">'executedOnCpu0'</span></span> <span class="hljs-string"><span class="hljs-string">'()V'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'TestSubject'</span></span> ... <span class="hljs-number"><span class="hljs-number">0x00007f6d1d07405c</span></span>: movl $0xa,<span class="hljs-number"><span class="hljs-number">0xc</span></span>(%rsi) <span class="hljs-number"><span class="hljs-number">0x00007f6d1d074063</span></span>: movb $0x1,<span class="hljs-number"><span class="hljs-number">0x10</span></span>(%rsi) <span class="hljs-number"><span class="hljs-number">0x00007f6d1d074067</span></span>: lock addl $0x0,(%rsp) ;*putfield finished ; - TestSubject::executedOnCpu0@8 (line <span class="hljs-number"><span class="hljs-number">15</span></span>) ... # {method} <span class="hljs-string"><span class="hljs-string">'executedOnCpu1'</span></span> <span class="hljs-string"><span class="hljs-string">'()V'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'TestSubject'</span></span> ... <span class="hljs-number"><span class="hljs-number">0x00007f6d1d061126</span></span>: movzbl <span class="hljs-number"><span class="hljs-number">0x10</span></span>(%rbx),%r11d ;*getfield finished ; - TestSubject::executedOnCpu1@1 (line <span class="hljs-number"><span class="hljs-number">19</span></span>) <span class="hljs-number"><span class="hljs-number">0x00007f6d1d06112b</span></span>: test %r11d,%r11d ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's nice, everything looks exactly as we predicted. </font><font style="vertical-align: inherit;">It remains to check whether, in the absence of </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something, something can go wrong. </font><font style="vertical-align: inherit;">Earlier in his article, </font></font><a href="https://habrahabr.ru/users/theshade/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TheShade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> showed </font></font><a href="http://habrahabr.ru/post/143390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">broken Double-Checked Locking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but we also want to pervert a little, and therefore we will try to break everything ourselves. </font><font style="vertical-align: inherit;">Well, or almost yourself.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstration of breakage without volatile </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem of demonstrating such a re-ording is that, in general, the probability of its origin is not very large, and on some architectures, the HMM will not allow it at all. Therefore, we need to either get hold of the alpha or rely on the compiler reordering. And besides, run everything many, many, many times. It‚Äôs good that we don‚Äôt have to reinvent the wheel. Let's use the wonderful </font></font><a href="http://openjdk.java.net/projects/code-tools/jcstress/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jcstress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utility </font><font style="vertical-align: inherit;">. Speaking quite simply, it repeatedly executes some code and collects statistics on the execution result, doing all the dirty work for us. Including the one that many people don‚Äôt suspect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessary test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has already been written for us </font><font style="vertical-align: inherit;">. More precisely, a little more complicated, but perfectly showing what is happening:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-comment"><span class="hljs-comment">// acq/rel var } @Override public void actor1(State s, IntResult2 r) { sx = 1; sx = 2; sy = 1; sx = 3; } @Override public void actor2(State s, IntResult2 r) { r.r1 = sy; r.r2 = sx; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have two streams: one changes the state, and the second reads the state and stores the result that it saw. The framework for us aggregates the results, and checks them by </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some rules</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We are interested in two results that the second stream can see: </font></font><code>[1, 0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>[1, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In these cases we read </font></font><code>y == 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but at the same time we either did not see any entries in </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>x == 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) at all, or we saw not the latest one at the time of the recording </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is </font></font><code>x == 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. According to our theory, such results should occur. Check it out:</font></font><br><br><pre> <code class="bash hljs">$ java -jar tests-all/target/jcstress.jar -v -t <span class="hljs-string"><span class="hljs-string">".*UnfencedAcquireReleaseTest.*"</span></span> ... Observed state Occurrence Expectation Interpretation [0, 0] 32725135 ACCEPTABLE Before observing releasing write to, any value is OK <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span>. [0, 1] 15 ACCEPTABLE Before observing releasing write to, any value is OK <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span>. [0, 2] 36 ACCEPTABLE Before observing releasing write to, any value is OK <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span>. [0, 3] 10902 ACCEPTABLE Before observing releasing write to, any value is OK <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span>. [1, 0] 65960 ACCEPTABLE_INTERESTING Can <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> the default or old value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span> after <span class="hljs-variable"><span class="hljs-variable">$y</span></span> is observed. [1, 3] 50929785 ACCEPTABLE Can see a released value of <span class="hljs-variable"><span class="hljs-variable">$x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-variable">$y</span></span> is observed. [1, 2] 7 ACCEPTABLE Can see a released value of <span class="hljs-variable"><span class="hljs-variable">$x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-variable">$y</span></span> is observed.</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can see that in 65960 cases out of 83731840 (approximately 0.07%) we saw </font></font><code>y == 1 &amp;&amp; x == 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that it clearly speaks about the reordering that occurred. </font><font style="vertical-align: inherit;">Hooray, you can tie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reader should now have a fairly good understanding of what is happening to answer the questions asked at the beginning of the article.</font></font> I recall: <br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does it happen-before?</font></font></i> </li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is it true that </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a dump of caches?</font></font></i> </li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why bother with any kind of memory model at all?</font></font></i> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, everything fell into place? </font><font style="vertical-align: inherit;">If not, then you should try to delve into the appropriate section of the article again. </font><font style="vertical-align: inherit;">If that doesn't help, welcome to the comments!</font></font><br><br><h1> <font color="darkred"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And one more thing ¬©</font></font></font> </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perform transformations over the source code can not only iron, but the entire execution environment. To comply with JMM requirements, restrictions are imposed on all components where something can change. For example, the compiler may in general reset some instructions, however, many optimizations may be forbidden for him to do JMM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the server compiler (C2) is significantly smarter than C1, which we have reviewed, and some things in it are very different. For example, the semantics of working with memory is absolutely different. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the gut multithreading OpenJDK in many places is used to check</font></font><code>os::is_MP()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allows to improve performance on single-processor machines, without performing some operations. </font><font style="vertical-align: inherit;">If using the Forbidden Arts to force the JVM to think at the start that it is executed on one processor, then it will not last long. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many thanks to the valiant </font></font><a href="https://habrahabr.ru/users/theshade/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TheShade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://habrahabr.ru/users/cheremin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cheremin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://habrahabr.ru/users/artyushov/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artyushov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the fact that they (you | pro) read the article before publication, making sure that I would not bring some kind of nonsense to the masses instead of light, filled with dull jokes and ochepatkami.</font></font></div><p>Source: <a href="https://habr.com/ru/post/209128/">https://habr.com/ru/post/209128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209112/index.html">Simple battle model on Modelica</a></li>
<li><a href="../209116/index.html">Electronic money in Russia will limit</a></li>
<li><a href="../209118/index.html">Using XenServer and other free / opensource in manual testing</a></li>
<li><a href="../209122/index.html">Training course "Data Visualization"</a></li>
<li><a href="../209126/index.html">MathML or Latex - how we implemented a changing salary in calculating salary using MathJax</a></li>
<li><a href="../209130/index.html">Terminal multiplexer overview: tmux and dvtm</a></li>
<li><a href="../209132/index.html">How did the authors of the book and application developers find each other?</a></li>
<li><a href="../209138/index.html">Calculating intersecting intervals in linear and closed namespaces</a></li>
<li><a href="../209140/index.html">About creating an improved JavaScript library for working with the DOM</a></li>
<li><a href="../209144/index.html">Network programming for game developers. Part 1: UDP vs. Tcp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>