<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with JSON in Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Show me a developer who has never had to work with JSON . Due to its simplicity, flexibility and clarity, this data presentation format has gained gre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with JSON in Swift</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/981/a42/3bb981a42b331415b0cf46f24b8e3f6e.png" align="right"><br>  Show me a developer who has never had to work with <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> .  Due to its simplicity, flexibility and clarity, this data presentation format has gained great popularity and is now used everywhere.  Here I am, while experimenting with Swift, I quickly encountered the need to parse JSON data. <br><br>  Actually, the standard Foundation API ‚Äî <a href="https://developer.apple.com/library/ios/documentation/foundation/reference/nsjsonserialization_class/Reference/Reference.html">NSJSONSerialization</a> ‚Äî does an excellent job with the task of direct and inverse JSON conversion from a textual representation into an object model.  Apple has done a serious job to provide direct and reverse interaction between Swift and Objective-C code ( <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">Using Swift with Cocoa and Objective-C</a> ), so using the usual Cocoa API is not only possible in practice, but also convenient and does not look unnatural: <br><br><pre><code class="objectivec hljs">let jsonString = <span class="hljs-string"><span class="hljs-string">"{\"name\":\"John\",\"age\":32,\"phoneNumbers\":[{\"type\":\"home\",\"number\":\"212 555-1234\"}]}"</span></span> let jsonData = jsonString.dataUsingEncoding(<span class="hljs-built_in"><span class="hljs-built_in">NSUTF8StringEncoding</span></span>, allowLossyConversion: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) let jsonObject: AnyObject! = <span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span>.JSONObjectWithData(jsonData, options: <span class="hljs-built_in"><span class="hljs-built_in">NSJSONReadingOptions</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), error: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  But working with the result in a statically typed Swift is inconvenient - a chain of checks and type conversions is required to get any value.  Next, I will consider solutions to this problem, and at the same time we will get acquainted with some features of Swift. <br><a name="habracut"></a><br>  Formally obtained through the NSJSONSerialization JSON representation consists of instances of Foundation types ‚Äî NSNull, NSNumber, NSString, NSArray, NSDictionary.  But <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html">runtime bridging</a> provides full compatibility and interchangeability of these types and the corresponding Swift primitives - numeric types (Int, Double, etc.), String, Array, Dictionary.  Therefore, in the Swift code, we can work with the received object ‚Äúnatively‚Äù.  Suppose we need to check the value of the first phone number.  In Objective-C, it could look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *number = jsonObject[@‚ÄúphoneNumbers‚Äù][<span class="hljs-number"><span class="hljs-number">0</span></span>][@‚Äúnumber‚Äù]; <span class="hljs-built_in"><span class="hljs-built_in">NSAssert</span></span>([<span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span> isEqualToString:number], @‚Äùnumbers should match‚Äù);</code> </pre><br>  By using dynamic typing, navigating the hierarchy of a JSON object causes no problems in Objective-C.  Swift, on the other hand, uses strong static typing, so at each step ‚Äúin depth‚Äù of the hierarchy, you need to use explicit type casts: <br><br><pre> <code class="objectivec hljs">let person = jsonObject! as Dictionary&lt;String,AnyObject&gt; let phoneNumbers = person[<span class="hljs-string"><span class="hljs-string">"phoneNumbers"</span></span>] as Array&lt;AnyObject&gt; let phoneNumber = phoneNumbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] as Dictionary&lt;String,AnyObject&gt; let number = phoneNumber[<span class="hljs-string"><span class="hljs-string">"number"</span></span>] as String assert(number == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  Unfortunately, the current version of the compiler (Xcode 6 beta 2) generates an error for this code - there is a problem with parsing explicit casting expressions with operands using <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html">subscripts</a> .  This can be bypassed through intermediate variables: <br><br><pre> <code class="objectivec hljs">let person = jsonObject! as Dictionary&lt;String,AnyObject&gt; let phoneNumbers : AnyObject? = person[<span class="hljs-string"><span class="hljs-string">"phoneNumbers"</span></span>] let phoneNumbersArray = phoneNumbers as Array&lt;AnyObject&gt; let phoneNumber : AnyObject? = phoneNumbersArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] let phoneNumberDict = phoneNumber as Dictionary&lt;String,AnyObject&gt; let number : AnyObject? = phoneNumberDict[<span class="hljs-string"><span class="hljs-string">"number"</span></span>] let numberString = number as String assert(numberString == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  This option works correctly, but it looks awful of course.  You can combine getting values ‚Äã‚Äãinto one expression using <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html">optional downcasting</a> and <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html">optional chaining</a> : <br><br><pre> <code class="objectivec hljs">let maybeNumber = (((jsonObject as? <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>)?[<span class="hljs-string"><span class="hljs-string">"phoneNumbers"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>)?[<span class="hljs-number"><span class="hljs-number">0</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>)?[<span class="hljs-string"><span class="hljs-string">"number"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> assert(maybeNumber == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  Already better, but such a record is certainly difficult to call convenient ‚Äî for reading and especially for editing. <br><br>  It is clear that this is only a special case of a common problem - the complexity of working with dynamic data structures in languages ‚Äã‚Äãwith strong typing.  There are different approaches to solving this problem, some change the way data is processed.  But for the specific case of parsing JSON objects, I wanted to find a simple solution that meets the following requirements: <br><ul><li>  compactness and readability of the code; </li><li>  minimize the need for using explicit type conversions; </li><li>  the possibility and convenience of ‚Äúdisclosing‚Äù several levels of hierarchy in one expression along a chain; </li><li>  eliminate the possibility of runtime errors due to the mismatch of the JSON structure with the expectations - in such cases the value of the entire expression must be nil; </li><li>  minimize the overhead of CPU and memory resources. </li></ul><br>  First of all, I tried to find and analyze ready-made solutions. <br><br><h5>  Enum representation </h5><br>  Several authors at once suggest a similar approach: <br><ul><li>  <a href="https://github.com/owensd/json-swift">github.com/owensd/json-swift</a> </li><li>  <a href="https://github.com/lingoer/SwiftyJSON">github.com/lingoer/SwiftyJSON</a> </li><li>  <a href="https://github.com/maxpow4h/swiftz/blob/master/swiftz/JSON.swift">github.com/maxpow4h/swiftz/blob/master/swiftz/JSON.swift</a> </li></ul><br>  Consider briefly their device on the example of json-swift: <br><ol><li>  A new enumeration type (enum) ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) is introduced to represent JSON objects. </li><li>  Using the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html">associated values</a> mechanism, primitive Swift types are set to the possible values ‚Äã‚Äãof this enumeration, corresponding to JSON types ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) </li><li>  The main type constructor checks the type of the passed object and returns an instance with the desired enumeration value ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) </li><li>  At the same time for containers (arrays and dictionaries) elements are processed recursively ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) </li><li>  To navigate the JSON hierarchy, subscripts are implemented that return the appropriate elements for arrays and dictionaries ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) </li><li>  For the inverse transformation from JSON enumeration into the corresponding primitive Swift type, <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html">computed properties are used</a> , which return the associated value only in the case of a type match ( <a href="https://github.com/owensd/json-swift/blob/ab5db6f86f52b9340b8eb0feca8d97a4dfcee8f6/JSON/JSON.swift">github</a> ) </li></ol><br>  Transforming the original object model into such a view, we get a convenient interface that can be used to navigate the hierarchy and get the value of the expected type: <br><br><pre> <code class="objectivec hljs">let number = JSON(jsonObject)?[‚ÄúphoneNumbers‚Äù]?[<span class="hljs-number"><span class="hljs-number">0</span></span>]?[‚Äúnumber‚Äù]?.string assert(number == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  Here, the optional chaining mechanism ensures that there are no runtime errors.  When parsing an object with an inappropriate structure, the value of the entire expression will be nil (except when accessed by an index beyond the array boundaries). <br><br>  It turns out that such a solution meets all the stated requirements, except for one.  When it is used, a mandatory recursive traversal of the entire hierarchy of the JSON object and the creation of a new object data representation occur.  Of course, in some cases, such overheads do not play a fundamental role.  But still, as a whole, such a solution cannot be called optimal in terms of the use of CPU and memory resources. <br><br>  A crucial way to solve the problem would be to use such an JSON object representation right at the stage of conversion from a textual representation.  But this approach is already beyond the scope of the task under consideration - convenient work with the native object representation of JSON. <br><br><h5>  Lazy handling </h5><br>  Another approach to solving the full conversion problem is to use ‚Äúlazy‚Äù logic to check and typecast when traversing JSON.  Instead of re-creating the entire JSON hierarchy at once with the values ‚Äã‚Äãof the necessary types, you can do it ‚Äúin depth‚Äù at each step - only for one requested element.  The implementation of just such an approach offers the notorious Mike Ash: <a href="https://gist.github.com/mikeash/f443a8492d78e1d4dd10">gist.github.com/mikeash/f443a8492d78e1d4dd10</a> <br><br>  Unfortunately, with this approach, it will not be possible to present a separate JSON value in the same convenient form (enum + associated values).  But such a solution is obviously more optimal.  At first glance, there is also a small overhead in the form of creating an additional wrapper object at each step deep into the hierarchy.  But these objects are defined as structures (struct Value), so their initialization and use can be well optimized by the Swift compiler. <br><br><h5>  Decision </h5><br>  I still wanted to find a solution that does not use new types, but expands the behavior of standard types as necessary.  Let's take a closer look at the expression with standard syntax <br><br><pre> <code class="objectivec hljs">(((jsonObject as? <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>)?[<span class="hljs-string"><span class="hljs-string">"phoneNumbers"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>)?[<span class="hljs-number"><span class="hljs-number">0</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>)?[<span class="hljs-string"><span class="hljs-string">"number"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span></code> </pre><br>  In fact, the problems here are caused only by transitions to the elements of dictionaries and arrays.  This is because a subscript call ( <code>[1]</code> or <code>[‚Äúnumber‚Äù]</code> ) imposes a requirement on the type of value to which it applies - in our case, we refer to NSDictionary or to NSArray.  Or, on the other hand, the resulting values ‚Äã‚Äãfrom NSArray and NSDictionary are of type AnyObject, which requires a type conversion for use later in the call chain. <br><br>  It turns out that the need for a cast will disappear if we operate with a universal type that initially supports both subscript variants and returns objects of the same type.  In Swift, this definition formally corresponds to the protocol: <br><br><pre> <code class="objectivec hljs">protocol JSONValue { subscript(key: String) -&gt; JSONValue? { get } subscript(index: Int) -&gt; JSONValue? { get } }</code> </pre><br>  Thus, the protocol will determine the JSON value, which can always be accessed via a subscript (with an Int or String parameter).  As a result, you can get either a collection element (if the object is a collection, its type corresponds to the subscript type and an element with such subscript is in the collection), or nil. <br><br>  To work with standard types in this way, you need to ensure that they match the JSONValue.  Swift allows you to add <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">protocol implementations via extensions</a> .  As a result, the whole solution looks like this: <br><br><pre> <code class="objectivec hljs">protocol JSONValue { subscript(<span class="hljs-meta"><span class="hljs-meta">#key: String) -&gt; JSONValue? { get } subscript(#index: Int) -&gt; JSONValue? { get } } extension NSNull : JSONValue { subscript(#key: String) -&gt; JSONValue? { return nil } subscript(#index: Int) -&gt; JSONValue? { return nil } } extension NSNumber : JSONValue { subscript(#key: String) -&gt; JSONValue? { return nil } subscript(#index: Int) -&gt; JSONValue? { return nil } } extension NSString : JSONValue { subscript(#key: String) -&gt; JSONValue? { return nil } subscript(#index: Int) -&gt; JSONValue? { return nil } } extension NSArray : JSONValue { subscript(#key: String) -&gt; JSONValue? { return nil } subscript(#index: Int) -&gt; JSONValue? { return index </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; count &amp;&amp; index &gt;</span></span></span><span class="hljs-meta">= 0 ? JSON(self[index]) : nil } } extension NSDictionary : JSONValue { subscript(#key: String) -&gt; JSONValue? { return JSON(self[key]) } subscript(#index: Int) -&gt; JSONValue? { return nil } } func JSON(object: AnyObject?) -&gt; JSONValue? { if let some : AnyObject = object { switch some { case let null as NSNull: return null case let number as NSNumber: return number case let string as NSString: return string case let array as NSArray: return array case let dict as NSDictionary: return dict default: return nil } } else { return nil } }</span></span></code> </pre><br>  A few notes: <br><ul><li>  to avoid conflict with standard subscripts in NSDictionary and NSArray, subscripts with named parameters are used - #key, #index; </li><li>  A helper function is used to cast arbitrary values ‚Äã‚Äãto the JSONValue type, because standard check and type cast operators <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">work only for protocols marked with the <code>@objc</code> attribute</a> (most likely this is because non- <code>@objc</code> protocol <code>@objc</code> can be added to such Swift types, data about which is not available in runtime); </li><li>  although the code operates on Foundation types, runtime bridging also ensures proper operation with Swift primitives. </li></ul><br>  As a result, to work with JSON, we can use the expression: <br><br><pre> <code class="objectivec hljs">let maybeNumber = JSON(jsonObject)?[key:<span class="hljs-string"><span class="hljs-string">"phoneNumbers"</span></span>]?[index:<span class="hljs-number"><span class="hljs-number">0</span></span>]?[key:<span class="hljs-string"><span class="hljs-string">"number"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> assert(maybeNumber == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  Although this is not the most compact option considered, this solution fully meets all the listed requirements. <br><br><h5>  Alternative option </h5><br>  Based on the same idea, a variant is possible using the protocol with the <code>@objc</code> attribute.  This allows the use of explicit type conversions instead of an auxiliary function, but prohibits the use of subscripts ‚Äî instead, they will have to use conventional methods.  But these methods can be declared as <code>@optional</code> : <br><br><pre> <code class="objectivec hljs">@objc protocol JSON { <span class="hljs-keyword"><span class="hljs-keyword">@optional</span></span> func array(index: Int) -&gt; JSON? <span class="hljs-keyword"><span class="hljs-keyword">@optional</span></span> func object(key: String) -&gt; JSON? } extension <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> : JSON { func array(index: Int) -&gt; JSON? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index &lt; count &amp;&amp; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[index] as? JSON : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } extension <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>: JSON { func object(key: String) -&gt; JSON? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[key] as? JSON } } extension <span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> : JSON {} extension <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> : JSON {} extension <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> : JSON {}</code> </pre><br>  Usage example: <br><br><pre> <code class="objectivec hljs">let maybeNumber = (jsonObject as? JSON)?.object?(‚ÄúphoneNumbers‚Äù)?.array?(<span class="hljs-number"><span class="hljs-number">0</span></span>)?.object?(‚Äúnumber‚Äù) as? <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> assert(maybeNumber == <span class="hljs-string"><span class="hljs-string">"212 555-1234"</span></span>)</code> </pre><br>  Not as compact as the subscripts version.  Someone may be confused by the number of question marks, but on the other hand, each use of it is understandable and carries a meaning. <br><br>  In my opinion, the solutions found meet the specified requirements and look preferable to the other options considered.  And the idea used - the selection of a universal protocol with methods that return optional values ‚Äã‚Äã- can be used for convenient work not only with JSON, but also with other dynamic data structures. <br><br>  Code and usage examples are available on <a href="https://github.com/odnoletkov/OptJSON">github</a> . </div><p>Source: <a href="https://habr.com/ru/post/228949/">https://habr.com/ru/post/228949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228933/index.html">Where data centers live well, or regional features of the IT infrastructure market</a></li>
<li><a href="../228937/index.html">Page-cache, or how RAM and files are interconnected</a></li>
<li><a href="../228939/index.html">The last day of early registration at WebCamp and additional discounts for Habrahabr readers</a></li>
<li><a href="../228941/index.html">New mobile financial service ... any ideas?</a></li>
<li><a href="../228943/index.html">Vidon.me AV200: the revolution or evolution of Android players or what can come out of XBMC if you add DVDFab to it?</a></li>
<li><a href="../228951/index.html">[Translation] Magic methods in PHP</a></li>
<li><a href="../228953/index.html">Spring: Transactional TaskExecutor Implementation</a></li>
<li><a href="../228955/index.html">Learning security: the most popular webinars</a></li>
<li><a href="../228957/index.html">Idris language overview</a></li>
<li><a href="../228959/index.html">Cost Optimization Yota: Attempt # 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>