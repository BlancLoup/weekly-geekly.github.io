<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HashLife on the knee</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After messing around with the three-dimensional game ‚ÄúLife‚Äù, I remembered that for the regular, Konevsky version of this game, there is an algorithm c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HashLife on the knee</h1><div class="post__text post__text-html js-mediator-article">  After messing around <a href="http://habrahabr.ru/blogs/personal/136100/">with the three-dimensional game ‚ÄúLife‚Äù,</a> I remembered that for the regular, Konevsky version of this game, there is an <a href="http://en.wikipedia.org/wiki/Hashlife">algorithm called ‚ÄúHashlife‚Äù</a> .  It is described in several phrases on Wikipedia, and the picture with a comment there (‚Äúconfiguration after 6 octillion generations‚Äù) was enough for me to keep away from this idea: how many resources does this algorithm need?  Is it worth it to take at all? <br><br>  The general idea of ‚Äã‚Äãthe algorithm is as follows. <br><br>  Suppose that we have a square of a field of size N * N (N&gt; = 4 - the power of two).  Then we can uniquely determine the state of its central region of size (N / 2) * (N / 2) in terms of T = N / 4 steps.  If we remember the state of the original square and the result of its evolution in the dictionary, then we will be able next time, having met such a square, to immediately determine what will become of it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose that for squares N * N, we can count the evolution by N / 4 steps.  Suppose we have a square 2N * 2N.  To calculate its development on N / 2 steps, you can do the following. <br><br>  We divide the square into 16 squares with side N / 2.  Let's make one of them 9 squares with side N, for each of them we will find the result of evolution by N / 4 steps.  It turns out 9 squares with side N / 2.  In turn, we will make 4 squares with a side N of them, and for each of them we will find the result of an evolution by N / 4 steps.  The resulting 4 squares with a side of N / 2 will be combined into a square with a side of N - it will be the answer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f9/6f3/150/0f96f3150d56d2ff181b5b0eb4c0e261.png"><br><br><a name="habracut"></a><br><br>  To implement the algorithm, we need to be able to do the following: <br><br><ol><li>  Break the square into four squares; </li><li>  Find the result of the evolution of the square; </li><li>  Find the square consisting of four squares. </li></ol><br><br>  If you look for the result of evolution at the time of building the square, then it is enough to have a structure with 5 fields: <br><br><pre>  class Square {
	 internal Square LB, RB, LT, RT, Res;
 } </pre><br><br>  Then the algorithm of combining four squares into one can be written as: <br><pre> Square Unite (Square a0, Square a1, Square a2, Square a3) {
	 Square res = FindInDictionary (a0, a1, a2, a3);
	 if (res! = null) return res;
 // layer at T = N / 4
	 Square b1 = Unite (a0.RB, a1.LB, a0.RT, a1.LT) .Res;
	 Square b3 = Unite (a0.LT, a0.RT, a2.LB, a2.RB) .Res;
	 Square b4 = Unite (a0.RT, a1.LT, a2.RB, a3.LB) .Res;
	 Square b5 = Unite (a1.LT, a1.RT, a3.LB, a3.RB) .Res;
	 Square b7 = Unite (a2.RB, a3.LB, a2.RT, a3.LT) .Res;
 // layer at T = N / 2	
	 Square c0 = Unite (a0. Res, b1, b3, b4). Res;
	 Square c1 = Unite (b1, a1.Res, b4, b5) .Res;
	 Square c2 = Unite (b3, b4, a2.Res, b7) .Res;
	 Square c3 = Unite (b4, b5, b7, a3.Res) .Res;
	 return AddToDictionary (new Square () {LB = a0, RB = a1, LT = a1, RT = a3, Res = Unite (c0, c1, c2, c3)});
 }
</pre><br><br>  Actually, everything.  Little things left: <br><br>  Stop recursion.  To do this, all 4 * 4 squares are entered into the dictionary and the results of their evolution are 1 step (in fact, only in this place the program requires knowledge of the rules of the game).  For 2 * 2 squares, the evolution by half a step is not calculated, they are marked in some special way. <br><br>  Double the number of evolutionary steps.  In terms of the algorithm, this is the same as double the size of the square containing the original field.  If we want to leave the square in the center, adding zeros to it, you can do this: <br><br><pre>  Square Expand (Square x) {
	 Square c0 = Unite (Zero, Zero, Zero, x.LB);
	 Square c1 = Unite (Zero, Zero, x.RB, Zero);
	 Square c2 = Unite (Zero, x.LT, Zero, Zero);
	 Square c3 = Unite (x.rt, zero, zero, zero);
	 return Unite (c0, c1, c2, c3);
 }
</pre><br>  Here Zero is a special square, all parts and the result of which is equal to itself. <br><br>  And you can simply alternate the actions x = Unite (x, Zero, Zero, Zero) and x = Unite (Zero, Zero, Zero, x).  The original square will be somewhere in the center. <br><br>  Implement a dictionary.  Here I did not find a beautiful solution: I need to search for an object by key, which is 80% of this object (and not only the remaining 20%, but also the object itself must be searched for).  Fumbling with different types of collections, I waved my hand and entered Fortran: I described five integer arrays (LT, RT, LB, RB, Res) and said that the square is determined by an integer ‚Äì index in these arrays.  Indices from 0 to 15 are reserved for squares 2 * 2.  The sixth array, twice as long, is used for hashing. <br><br>  You also need to set the field and read the result - but this is a matter of technology.  Although reading must be careful: if you run Expand more than 63 times, the length of the side of the field will no longer fit into 64 bits. <br><br>  I tried the algorithm on such constructions: <br><br>  "Garbage bin". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b0/d29/d53/0b0d29d53615a8fa39524df99db3da39.png"><br>  It moves at c / 2 speed, reserves a lot of garbage behind it and releases a pair of gliders every 240 steps.  A trillion generations (more precisely, 2 ^ 40) were calculated in 0.73 seconds.  Approximately 120000 squares fell into the dictionary (1500 for each doubling of time), the number of living cells per field was 600 billion. <br>  A fragment of the resulting field looks like this: <br>  <a href="">(2001x2001, 82 KB)</a> <br><br>  "The battle of glider guns" <br><br>  Two glider guns are located at a distance of 800 cells from each other, the flows released by them collide: <br>  <a href="">(T = 2048, 804x504, 11 KB)</a> <br>  Shortly after the collision, gliders fly out of a heap of debris, which first destroy one gun: <br>  <a href="">(T = 4096, 1098x1024, 30 Kb)</a> <br>  And then the second (after which the development quickly ends): <br>  <a href="">(T = 8192, 3146x3252, 190 Kb)</a> <br>  The counting time is 0.84 seconds, the number of elements in the dictionary is about 270,000. <br><br>  "Random Filling" <br><br>  Field 1024 * 1024 is randomly filled with cells with a density of 1/3.  For the algorithm, this is the most difficult case: the configuration stabilizes slowly, and the squares do not begin to repeat immediately. <br>  Here is an example of the development of one of the configurations: <br>  <a href="">(T = 0, 1024x1024, 300 Kb)</a> <br>  <a href="">(T = 1024, 1724x1509, 147 Kb)</a> <br>  <a href="">(T = 2048, 2492x2021, 177 Kb)</a> <br>  <a href="">(T = 4096, 4028x3045, 300 Kb)</a> <br>  <a href="">(T = 8192, 7100x5093, 711 Kb)</a> <br>  The counting time is 14 seconds, the number of elements in the dictionary is about 15 million, about 35,000 points remained on the field. <br><br>  What is unusual about this algorithm?  I would note the following: <br><br><ol><li>  We almost without effort received a program capable of separating empty areas from active ones, tracking active areas and working out their interaction.  If we wrote such an analysis directly, through a multitude of dynamic two-dimensional arrays, the program would be much more complicated. </li><li>  The algorithm not only calculates the state of the field in T steps - it remembers the entire development.  From the result of his work, it is easy to extract the state through any interval T_k = 2 ^ k (how to get the state of the field in time that is not a power of two is a separate question).  At the same time, the whole evolution turns out to be well-packed - again, without special efforts: 2 ^ 40 generations of the garbage bin were packed into 3 MB. </li><li>  Despite the fact that the dictionary is based on the original configuration, its contents are independent of this configuration.  After we finish any calculation, we can use the same dictionary for the new configuration, and save a lot of time with luck (although I have not tried). </li><li>  Formally, the configurations on the plane are presented in the form of 4-trees.  But to analyze the interaction between the extreme points of neighboring branches, we do not explicitly descend to these points, but only descend by 1-2 steps, after which we look for / build a tree suitable for solving our problem.  However, there is nothing unusual here - only that we do not lose time because of the construction of new nodes, but rather, on the contrary. </li><li>  The algorithm never uses the actual size of "atomic" cells, or the number of their states.  The lowest level to which recursion can go down is cells with 16 states, which we perceive as squares 2 * 2.  The space-time at this level (for the algorithm) looks like a face-centered grid (a three-dimensional chessboard, from which only black cells were taken).  The number 16 we came up with on the basis of Conway‚Äôs rules.  It could be any in the algorithm, the main code does not depend on it </li></ol></div><p>Source: <a href="https://habr.com/ru/post/136616/">https://habr.com/ru/post/136616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136608/index.html">Video review of Android applications and games - kedDroid</a></li>
<li><a href="../136609/index.html">Dimensions of CLR objects. Precise definition</a></li>
<li><a href="../136612/index.html">This year in the Moscow metro will appear free Wi-Fi</a></li>
<li><a href="../136613/index.html">Free webinar about innovations in ASP.NET and new Visual Studio 11 for web developers</a></li>
<li><a href="../136615/index.html">CSS framework YAML4 released - now also with HTML5 support</a></li>
<li><a href="../136617/index.html">MegaUpload.com is closed by the FBI, the founders and several other employees are arrested</a></li>
<li><a href="../136619/index.html">A look at the final version of the Playstation Vita with CES</a></li>
<li><a href="../136621/index.html">Anonymous began to avenge Megaupload</a></li>
<li><a href="../136625/index.html">Maximite - Nostalgia with a soldering iron on the times of Radio-86RK and Spectrum</a></li>
<li><a href="../136626/index.html">Collect donations with donateMe (Part II)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>