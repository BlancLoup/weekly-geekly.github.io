<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Harmony collections NOW</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, an article about such wonderful things as Map, WeakMap and Set was already skipping, but in reality the real capabilities of these APIs were...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Harmony collections NOW</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/97e/4c7/345/97e4c7345e25b400bb5599b225e5a46d.png"><br>  On Habr√©, <a href="http://habrahabr.ru/post/151690/">an article</a> about such wonderful things as Map, WeakMap and Set was already skipping, but in reality the real capabilities of these APIs were not disclosed (if I did use the search well). <br>  These APIs are not really implemented anywhere except firefox (it can be included in chrome canary), but even there, until recently, the use of HTMLElement-like objects as keys was not supported.  Polymer, for example, removed only three weeks ago. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigator.userAgent.indexOf(<span class="hljs-string"><span class="hljs-string">'Firefox/'</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><br>  Why are they so good?  In essence, Map / WeakMap can be perceived as ordinary hash objects, only complex objects (Object, Function, Array) can be used as keys, since the binding is not in content, but in memory. <br>  In this way, it becomes possible to bind on the frontend to <br><ul><li>  dom element </li><li>  XHR request </li><li>  File element </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This gives us the opportunity to work without id-schnik elements, do date-binding many times faster, create a crazy alternative implementation of promises, and so on. <br>  We will talk about WeakMap.  Even not so, we will talk about the existing polyfills for WeakMap. <br><br><a name="habracut"></a><br><br>  As for the rest of the elements: <br>  Map is a hash, the keys of which can be both primitives and objects. <br>  Set is a set of unique elements.  It is quite simple to build on top of the Map.  Its most important advantage is the processing of arrays, due to which it is possible to reduce the complexity of the uniq task from O (n ^ 2) to O (n). <br><br>  About what possibilities of working with the DBMS appear on the backend with node.js - I, perhaps, will keep silent, because I am not familiar enough with the node to recommend something authoritatively. <br><br>  The syntax is a bit more complicated than that of a classic object, but it is also quite clear and we read: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>; map.set(someObject, <span class="hljs-string"><span class="hljs-string">'someKey'</span></span>); alert(map.get(someObject)); map.delete(someObject);</code> </pre><br><br>  In several projects, including one of the past versions of <a href="http://habrahabr.ru/company/uprock/blog/192740/">cornerJS</a> , such a decision was justified in terms of brevity and readability of the code, however, due to the fact that one of the polyfills was used, I considered this solution to be very memory-consuming. <br><br>  <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:weak_maps">The implementation of ecmascript.org</a> offers as an option a similar implementation (translated from pseudo-js to a slightly reduced executable, <a href="">full implementation on github</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.WeakMap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyList = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueList = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ <span class="hljs-string"><span class="hljs-string">'get'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, defaultValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = keyList.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = valueList[index]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index === <span class="hljs-number"><span class="hljs-number">-1</span></span> ? defaultValue : value; }, <span class="hljs-string"><span class="hljs-string">'set'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = keyList.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { keyList.push(key); valueList.push(value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { valueList[index] = value; } } <span class="hljs-comment"><span class="hljs-comment">//...( has, delete  clear) }); };</span></span></code> </pre><br><br>  Such an implementation has many problems. <br>  First, memory flows perceptibly: even when an element is deleted, it remains in keyList, and if such a WeakMap is working on a real project, a huge amount of memory can leak to the storage of essentially deleted objects.  GarbageCollector does not work on the element, for it it is considered still existing. <br>  At the engine level, this can be solved, but in any case, the GarbageCollector will still work incorrectly. <br>  Secondly, when there are a lot of elements in keyList, the selection of the latter starts to take really a lot of time in chrome on macbook air 2013, the search for the 1e9th element took more than a second.  The complexity of the problem is O (n), which sometimes significantly affects performance. <br><br>  There is an alternative implementation that solves the problem with the sample rate, reducing the complexity of the task to O (1): <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.WeakMap = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() % <span class="hljs-number"><span class="hljs-number">1e9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'__st'</span></span> + (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1e9</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) + (counter++ + <span class="hljs-string"><span class="hljs-string">'__'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entry = key[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry &amp;&amp; entry[<span class="hljs-number"><span class="hljs-number">0</span></span>] === key) entry[<span class="hljs-number"><span class="hljs-number">1</span></span>] = value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> defineProperty(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: [key, value], <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entry; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (entry = key[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name]) &amp;&amp; entry[<span class="hljs-number"><span class="hljs-number">0</span></span>] === key ? entry[<span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } } } })();</code> </pre><br><br>  However, this does not solve the memory problem, and even makes it worse.  A cyclic reference appears in the memory of each element: key [name] [0] === key.  If you believe open documentation, the garbage collector is not able to catch such scenarios, so that over time, the memory becomes significantly clogged - however, it will take a lot of time. <br>  That is why it is worth using Polymer / X-tags with caution, a lot of which rely on WeakMap (the above is a somewhat abbreviated implementation of them).  For example, the polyfill for MutationObserver relies on it, which is used not only by them, but also by a large number of third-party projects, many of which may not be aware of memory problems in it. <br>  Added a couple more minuses in comparison with fair implementation.  One of them will turn out to be insignificant for the majority: we lose the ability to bind to frozen objects.  The second for some will be quite serious.  This implementation becomes IE9 +.  The first option is so simple that it can work in IE6 + if you connect Array.prototype.indexOf-polyfill (for example, from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">Mozilla</a> ).  Array.prototype.indexOf also appeared in IE9, but at least it can be implemented.  Unlike Object.defineProperty (strictly speaking, IE8 has defineProperty support for DOM elements, but you can't rely on this). <br><br>  As a result, we have either slow work on large volumes of records, or an extra property in a key element (which means, perhaps, even access to it from the outside), problems with some of the iterators, and in any case, memory filled with additional attributes. <br><br>  There is also a WeakMaps implementation in jQuery.  When you request jQuery.data (element, key), you work with one of the WeakMap implementations.  It works a little easier. <br>  Perhaps you've ever seen something like this in your code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.jQuery19104357186993584037 <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre><br><br>  Now you know that this is the id of the element in your own WeakMap from jQuery. <br><br>  When an item is deleted, it is deleted, but we still: <br><ul><li>  not protected from data changes by; </li><li>  not protected from memory leaks for values ‚Äã‚Äã‚Äî keys are deleted, but the values ‚Äã‚Äãassociated with them are stored in memory. </li></ul><br><br>  Here we come to the main part. <br><br>  WeakMap was called this way because they wanted to implement weak reference - a weak link that is not taken into account in the GC, respectively, both the key and the value are deleted when there are no more other records of this key. <br>  In the correct implementation, both the key and the value must be deleted. <br>  But I couldn‚Äôt even imagine that it was possible until I came across a phrase in one of the repositories on the githaba that could not but surprise: <br><blockquote>  Shim for WeakMap with non-leaky O (1) lookup time </blockquote><br>  It relies on Object.defineProperty - which means IE9 + and the impossibility of referencing frozen objects, but the element was not visible on the element, which was a surprise. <br>  The repository itself is here: <a href="https://github.com/Benvie/WeakMap/">https://github.com/Benvie/WeakMap/</a> <br>  I could not resist checking to the extent that this may be true at all. <br><br>  For this, a simple and quick memory snapshot test was made. <br><br><ul><li>  first shot on blank page ( <b>blue arrow</b> ) </li><li>  the second was filmed on the implementation of the polyfill ( <b>yellow arrow</b> ) </li><li>  the third one was shot after creating the elements and putting them into memory ( <b>red arrow</b> ) </li><li>  the fourth one was removed after the remaining references to the elements were removed ( <b>green arrow</b> ) </li></ul><br><br>  fully test code <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ""  1 //  // ""  2 var someStorage = []; var map = new WeakMap; var length = 1e5; // ie    1e4,     1e5      10   . for (var i = 0; i &lt; length; i++) { someStorage[i] = {randomValue: Math.random() * 1e9 &gt;&gt;&gt; 0}; //     ,        -  garbage collector       map.set(someStorage[i], {otherRandomValue: Math.random() * 1e9 &gt;&gt;&gt; 0}) } // ""  3 for (var i = 0; i &lt; length; i++) { someStorage[i] = void 0; } // ""  4</span></span></code> </pre><br><br>  The results are as follows: <br><br>  <b>Chrome 30 (Mac 10.9)</b> <br><img src="http://habrastorage.org/storage3/594/65f/264/59465f2642315e041a70cfc42a2194eb.jpg"><br><br>  <b>Firefox 24 (Mac 10.9)</b> <br><img src="http://habrastorage.org/storage3/199/d2d/022/199d2d02233a2cf52cede56b3b7b1af1.jpg"><br><br>  <b>IE 11 (Win 8.1)</b> <br><img src="http://habrastorage.org/storage3/f01/c0b/863/f01c0b863ef85c0118f1cbd43159b2e0.jpg"><br><br>  I admit honestly - I was shocked when I saw that all the memory that the application took was given away - both as a memory for keys and for values. <br><br>  After that, I decided just in case to make sure that the search time is real O (1).  It turned out to be true. <br><br>  <b>Chrome 30 (Mac 10.9)</b> <br><img src="http://habrastorage.org/storage3/f54/fc0/95b/f54fc095b05731971782f14ba5b43e67.jpg"><br><br>  <b>Firefox 24 (Mac 10.9)</b> <br><img src="http://habrastorage.org/storage3/628/0b2/dd2/6280b2dd2f9e3d72dbe7b8d8cf6787fc.jpg"><br><br>  In the end, it's all true.  WeakMap can really be used in a large number of projects, it provides tremendous potential for data-binding, working with Osprey, creating a large number of plug-ins, and this can be done today, at least we have only every fifth IE8 + project and the rest of IE9 +.  At the same time, WeakMap not only simplifies work with some types of data, but also allows you to increase speed and optimize, and in some cases significantly, work with memory. <br>  The main thing is to choose the right polyfill. <br><br>  By the way, you can make a double polyfill, something like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.weakMap = <span class="hljs-comment"><span class="hljs-comment">//O(1)         } else { window.weakMap = //O(n)  ,     }</span></span></code> </pre><br><br>  Of course, the most interesting thing about this solution is how it works.  The solution is so confusing that in order to understand it, I had to contact the author ( <a href="https://github.com/Benvie/">Brandon Benvie</a> ) and ask him a few questions in order to understand the most confusing details. <br><br>  I do not like to thoroughly climb into someone else's code, but this one was incredibly interesting to implement, and it turned out that it‚Äôs worth exploring, after all, Brandon (author) wrote the ES6 compiler on ES3, created app.js (platform for desktop applications on the node) and implemented a lot of different really complex solutions on JS. <br><blockquote>  Disclaimer: in most examples, the code is slightly shortened for better readability: some checks are removed, some things are inlined.  I do not recommend using the code I quote here in practice, since this is all or a kind of shamanism so that the garbage collector can see that the memory can be freed, or practices that allow the code to work faster, but can easily confuse and frighten the usual average frontend developer. </blockquote><br>  Initially, it can be confusing that all methods return <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ [native code] }</code> </pre><br><br>  No bind is done anywhere, which can transform a normal function into one. <br>  However, everything turned out to be much simpler: the prep method, which is defined as: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prep = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> ? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">)</span></span>{ f.__proto__ = stringifier } : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">)</span></span>{ define(f, stringifier) };</code> </pre><br><br>  makes the object __proto__, which acts as a prototype of a specific element. <br>  stringifier is another function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringifier = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src[<span class="hljs-number"><span class="hljs-number">0</span></span>] + nameOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + src[<span class="hljs-number"><span class="hljs-number">1</span></span>]; };</code> </pre><br><br>  It is set to itself as a toString method (as I understand it - this is done for short code).  As a result, we actually get something like: <br><br><pre> <code class="javascript hljs">a.__proto__ = { <span class="hljs-attr"><span class="hljs-attr">toString</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"function "</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name+<span class="hljs-string"><span class="hljs-string">"() { [native code] }"</span></span> } }</code> </pre><br><br>  By the way, this particular code will not work very well due to the fact that the function name attribute is not available in all JS implementations, it is considered bad practice to use it.  The function should not rely on the environment (including its name) and should work the same way in all conditions. <br>  Just because Function.prototype.name is not in all implementations, in Brandon code the function name is defined as: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nameOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> func ? func.name : toSource.call(func).match(<span class="hljs-regexp"><span class="hljs-regexp">/^\n?function\s?(\w*)?_?\(/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre><br><br>  It was enough to remove define (stringifier, stringifier); so that the code would stop confusing us. <br><br>  So, we need to understand where the keys are stored.  To do this, we set the value, and it falls into the set function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value</span></span></span><span class="hljs-function">)</span></span>{ unwrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).set(key, value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unwrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).get(key); }</code> </pre><br><br>  And here the most interesting begins: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unwrap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weakMap</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.unlock(weakMap).value; }</code> </pre><br><br>  data is an instance of the internal Data class, which in itself is very similar to WeakMap, but it has only two methods, get and set, while all the weakMap itself are stored in one large Data object that stores for each weakMap one data object. <br>  We have meta-WeakMap (if you call things by their proper names), which contains all WeakMaps, each of which already contains key-value pairs for objects. <br><br>  And finally, all the fun in the Data object. <br><br>  First trick: we hide the value from the common set of keys so that it does not fall into any of the iterators.  To do this, we reassign getOwnPropertyNames <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-string"><span class="hljs-string">'getOwnPropertyNames'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwnPropertyNames</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> props = getProps(obj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(obj, globalID)) <span class="hljs-comment"><span class="hljs-comment">//   hasOwnProperty,       - . props.splice(props.indexOf(globalID), 1); return props; } });</span></span></code> </pre><br><br>  As a result, even the debugger of chromium is not aware of the existence of the property: <br><br><img src="http://habrastorage.org/storage3/35f/026/c05/35f026c05e7638a515998ee9f71160e8.jpg"><br><br>  Second trick: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOwn.call(obj, globalID)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[globalID]; <span class="hljs-comment"><span class="hljs-comment">//   Object.isExtensible var store = create(null); defProp(obj, globalID, { value: store }); return store; };</span></span></code> </pre><br><br>  At the output we get a unique object with the value key. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Data</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> puid = createUID(), <span class="hljs-comment"><span class="hljs-comment">//   16-  secret = {}; // -      WeakMap   ,             .      ,      ,     .     ‚Äì   private    Data this.unlock = function(obj){ var store = storage(obj); if (hasOwn.call(store, puid)) return store[puid](secret); var data = Object.create(null, { value: { writable: true, value: undefined } }); Object.defineProperty(store, puid, { value: (function(secret,data){ return function(key){ if(key===secret) return data } })(secret, data) }); return data; } }</span></span></code> </pre><br><br>  The first very interesting line is: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: { <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> } });</code> </pre><br><br>  We create an object, inheriting from null, which gives us a dummy object without any extensions, and then the second argument is passed to the propertiesObject, which allows us to define the values ‚Äã‚Äãwe need via defineProperty.  We explicitly create value, but pass it undefined, solely to ensure that it already exists and is subsequently tested (‚Äúvalue‚Äù in data). <br><br>  The second insanely interesting line: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(store, puid, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secret,data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key===secret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data } })(secret, data) });</code> </pre><br><br>  In essence, we get a function that takes as input a unique, specific dummy object, unique for each WeakMap, and returns the stored value if it corresponds to a private key. <br><br>  In fact, in the original code, it is even more complicated: <br><br><pre> <code class="javascript hljs">defProp(store, puid, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'s'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'return function(k){if(k===s)return l}'</span></span>)(secret, data) });</code> </pre><br><br>  Brandon commented on it like this: <br><blockquote>  Simply performance.  By defining a literal function, you also have all the local variables in scope.  By using `Function` the global object.  The goal was to prevent inadvertently leaking memory.  It would not have been possible to retain this concept. <br></blockquote><br>  In a free and extended translation into Russian: <br><blockquote>  This is done for performance.  Creating a function through function () {}, you bind it to the local osprey - despite the fact that it does not use it in any way.  If you use a debugger, you can see that the entire osp in which it was created is available from inside this function. <br>  The new Function creates a function that works in the global osprey, which removes the binding to the local one.  The task of the implementation was the absence of leaks in the memory, and all that was done there was done primarily for the absence of leaks. </blockquote><br>  As a result, in reality it looks like this in the memory: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {}; map.set(a, [<span class="hljs-string"><span class="hljs-string">'test'</span></span>]) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a[<span class="hljs-string"><span class="hljs-string">'2ql3g5ae6pcwstt9'</span></span>][<span class="hljs-string"><span class="hljs-string">'o6tnzx1xskf39pb9'</span></span>]) &gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(k===s)<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l}</code> </pre><br><br>  where a ['2ql3g5ae6pcwstt9'] is the keystore, which is a dummy object named by a randomly generated globalID that is common to all elements that fall into some kind of weakMap, an object that stores a closure with <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }</code> </pre><br><br>  as a second argument.  In the case of a change in the value, we replace the value, while the object remains inside the closure. <br><br>  All keys are hidden in all possible ways, right up to deleting them from Object.getOwnPropertyNames, due to this we get almost non-existing keys, the existence of which within the code cannot be suspected - they are not listed in iterators and are not issued in any of requests. <br>  As a result, we get IE9 + implementation of WeakMaps with absolutely protected (it is impossible to get access without making modifications inside the code) to open a container with contents that can be easily changed and which is always deleted along with the key, which gives us a really non-flowing WeakMap implementation O (1) complexity and non-rewritable and undeletable with Object.defineProperty with configurable attributes: false, enumerable: false, writable: false (set by default) access keys. <br><br>  Of course, I don‚Äôt like the fact that an attribute for a key is still created, but I don‚Äôt know which solution could be more perfect than this.  One can only admit that Brandon did a great job working with memory and made a decision that should be used in production. <br><br>  I will be glad to hear in the comments ideas for what else you can use Harmony collections and WeakMap in particular, and the attitude to similar APIs in general. <br><br>  <b>UPD.</b>  Brandon explained why (0, eval) ('this') was done at the end.  (0, eval) (‚Äúthis‚Äù) is roughly equivalent to var e = eval;  e ("this").  The fact is that eval always works in the local skop, but if you assign eval to another variable and run it, it will be executed in the global environment. </div><p>Source: <a href="https://habr.com/ru/post/200644/">https://habr.com/ru/post/200644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200620/index.html">Developing angularjs directives is just</a></li>
<li><a href="../200632/index.html">We create the first application on NancyFX. Part Four We continue to work with the modules</a></li>
<li><a href="../200634/index.html">Increase security with two clicks</a></li>
<li><a href="../200640/index.html">Astrophotography in every house</a></li>
<li><a href="../200642/index.html">We attach the Web Map service to the unsuspecting OpenSource database.</a></li>
<li><a href="../200646/index.html">Build Android applications on Travis CI</a></li>
<li><a href="../200652/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 81 (October 27 - November 2, 2013)</a></li>
<li><a href="../200654/index.html">We are refining equipment Turnigy 9x</a></li>
<li><a href="../200658/index.html">Is your disassembler working correctly?</a></li>
<li><a href="../200660/index.html">Service beautiful animated cards LikeShareIt.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>