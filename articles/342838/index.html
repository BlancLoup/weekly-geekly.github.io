<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sparse columns or sparse columns in MS SQL Server. Real experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of our rather large clients, in whose electronic document management system more than 10,000 users work every day at a time, so-called sparse colu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sparse columns or sparse columns in MS SQL Server. Real experience</h1><div class="post__text post__text-html js-mediator-article">  One of our rather large clients, in whose electronic document management system more than 10,000 users work every day at a time, so-called sparse columns or sparse columns were used. <br><br>  The article is an attempt to reduce the prerequisites and the results of applying this functionality (and some other DBMS settings) in a single place. <br><a name="habracut"></a><br><h2>  Problems and background </h2><br>  To dive into the subject a couple of words about the system: the system is a product whose development began in the 2000s.  At the moment, the system is actively developing.  The product has a client-northern architecture with several application servers. <br><br>  Microsoft SQL Server DBMS is used as server side. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Taking into account the fact that the system is no longer ‚Äúnew‚Äù, in the database structure there are corresponding mechanisms / options / objects, the use of which at the current moment looks unreasonable and outdated.  Gradually, there is a rejection of these objects, but there are situations when they are still used. <br><br><h3>  Premise # 1 </h3><br>  At the next performance audit, together with the Customer, we paid attention to the rapid growth of one of the tables (let's call it table X).  The volume of table X is almost over 350 GB (by the way, the volume of the entire database is about ~ 2TB).  The distribution according to the actual data of the table and the indices was as follows: <br><br><ul><li>  data was about 115 GB </li><li>  the rest of the volume ~ 235 GB accounted for indices. </li></ul><br>  Those.  The situation is quite uncommon, when the indexes on the table are about ~ 2 times larger than the data itself.  Those.  we get quite high overhead costs, which in turn negatively affect: <br><br><ul><li>  the duration of the insert / update data in this table (the more indices, the ‚Äúmore expensive‚Äù the operation); </li><li>  the duration of servicing operations (maintenance) of these indices; </li><li>  the duration of the backup and restore the database in case of failure; </li><li>  disk space requirements are increasing in terms of volume. </li></ul><br><h3>  Premise number 2 </h3><br>  In a large way, the DBMS operation can be described as follows: all data is loaded from disks to the buffer pool (cache) before processing.  This reduces the number of disk operations and speeds up the processing of the most frequently used data.  In more detail with the mechanism can be found, for example, in the <a href="https://docs.microsoft.com/ru-ru/sql/database-engine/configure-windows/buffer-pool-extension">article</a> .  The efficiency of using the buffer pool can be indirectly monitored using the Page Life Expectancy counter - the lifetime of the page in the buffer pool. <br><br>  In the interval of several months, they revealed a negative trend in reducing the lifetime of the page in the buffer pool. <br><br>  Inaction could lead to: <br><br><ul><li>  a significant increase in the load on the disk subsystem; </li><li>  increase the duration of user operations. </li></ul><br>  As a result, it was decided to conduct an analysis of the causes. <br><br>  Since the system in these months was not static and was constantly modified, we decided to start the analysis with the contents of the buffer pool.  For this, we used the data of the dynamic view: <a href="https://technet.microsoft.com/ru-ru/library/ms173442(v%3Dsql.110).aspx">sys.dm_os_buffer_descriptors</a> . <br><br>  Request example: <br><br><div class="spoiler">  <b class="spoiler_title">Into_BufferPool</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexes.name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> index_name, objects.name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> object_name, objects.type_desc <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> object_type_description, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> buffer_cache_pages, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) * <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> buffer_cache_used_MB <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_os_buffer_descriptors <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.allocation_units <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> allocation_units.allocation_unit_id = dm_os_buffer_descriptors.allocation_unit_id <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.partitions <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ((allocation_units.container_id = partitions.hobt_id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> (allocation_units.container_id = partitions.partition_id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.objects <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> partitions.object_id = objects.object_id <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.indexes <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> objects.object_id = indexes.object_id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partitions.index_id = indexes.index_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> allocation_units.type <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> objects.is_ms_shipped = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dm_os_buffer_descriptors.database_id = DB_ID() <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> indexes.name, objects.name, objects.type_desc <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br></div></div><br>  With a volume of the buffer pool of ~ 185 GB of the order of 80-90 GB, we compiled the cluster index data of our problem table X. The volume of the rest of the buffer pool was distributed fairly evenly between the indices.  From this it followed that the maximum effect could be obtained by optimizing in some way the data of table X (in this case, we are talking about its clustered index). <br><br><h3>  Premise number 3 </h3><br>  Practice shows the accumulation of large amounts of data in a single table will sooner or later affect the performance, if not all, then at least part of the operations associated with this table.  The situation is non-linearly aggravated with a large number of columns in this table. <br><br>  In addition, when we analyzed table X for data filling, we saw the following picture: for almost all rows, only a certain set of columns was filled (due to which system flexibility and adaptation to specific business requirements are achieved).  What essentially leads again to the low efficiency of data storage and processing, since  some cells do not store information, but nevertheless, space for these cells is reserved (for example, adding an empty column with data type int will increase the cost of storing the table by at least [4 bytes * number of rows in the table]). <br><br><h2>  Solutions / Corrections </h2><br>  Taking into account all the initial data presented above, 4 directions were identified for further development: <br><br><ul><li>  filtered indexes; </li><li>  data compression by means of DBMS (data compression); </li><li>  sparse columns; </li><li>  partitioning table X into several smaller tables. </li></ul><br><h4>  Filtered Indexes </h4><br>  Here is what the official documentation tells us: <br>  <i>‚ÄúThe filtered index is an optimized nonclustered index, particularly suitable for queries that select a well-defined data subset ... A well-designed filtered index improves query performance and also reduces the cost of maintaining and storing indexes compared to full-size indexes</i> . <i>‚Äù</i> <br><br>  If we say a little simpler, then we are talking about the possibility of creating an index only for a part of the data in the table, for example, we can create an index in table X for a specific business case. <br>  But to apply the index, it was necessary to use a new version of the software, in which the database structure was changed, including.  In particular, in the new version, the values ‚Äã‚Äãof the parameters of the client software connection from the DBMS were changed to ON: <br><br><ul><li>  SET <a href="https://msdn.microsoft.com/ru-ru/library/ms188048.aspx">ANSI_NULLS</a> ON; </li><li>  SET <a href="https://msdn.microsoft.com/ru-ru/library/ms174393.aspx">QUOTED_IDENTIFIER</a> ON; </li><li>  SET <a href="https://msdn.microsoft.com/ru-ru/library/ms176056.aspx">CONCAT_NULL_YIELDS_NULL</a> ON. </li></ul><br>  But in our case, the update was planned in six months, and we could not wait so long.  Moreover, it was also not intended to use filtered indexes, since  this made ineffective, for example, using the option of forced parameterization. <br><br><h4>  Data compression </h4><br>  Since the client has installed the DBMS version - 2012, data compression for this version is possible of two types: <br><br><ul><li>  page level compression (page compression); </li><li>  row-level compression. </li></ul><br>  If we consider the version of SQL 2016, there are some <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/data-compression/data-compression">changes</a> , but in our case they were also irrelevant (switching to the next version of SQL on a powerful hardware is quite expensive from a financial point of view).  Therefore, we stopped at the first two in more detail. <br><br>  According to the <a href="https://technet.microsoft.com/en-us/library/dd894051(v%3Dsql.100).aspx">documentation</a> , page-level compression is a more resource-intensive operation for the CPU than line-level compression.  Based on this page-level compression option was dropped immediately. <br><br>  Next was an attempt to use row compression, but the documentation also stumbled upon the mention that even it consumes additional resources.  And since the processor is a very limited resource, this option also had to be abandoned. <br><br><h4>  Sparse columns </h4><br>  Sparse columns are regular columns that have an optimized storage for NULL values.  Sparse columns reduce the space required to store NULL values, but the cost of getting values ‚Äã‚Äãother than NULL increases. <br>  To achieve a positive effect in each particular column, there must be a certain percentage of NULL values.  This percentage depends on the type of data in the column, for example: <br><br><table><tbody><tr><th>  Data type </th><th>  Byte Spare </th><th>  Sparse bytes </th><th>  NULL percentage </th></tr><tr><td>  float </td><td>  four </td><td>  eight </td><td>  64% </td></tr><tr><td>  datetime </td><td>  eight </td><td>  12 </td><td>  52% </td></tr><tr><td>  varchar </td><td>  eight </td><td>  12 </td><td>  52% </td></tr><tr><td>  int </td><td>  2 </td><td>  four </td><td>  60% </td></tr></tbody></table><br>  Moreover, not every column of m.  transferred to sparse.  A list of limitations and incompatibilities is given in the <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/tables/use-sparse-columns">official documentation</a> . <br><br>  Those.  To assess the possibility of transferring to a sparse in a large way, it was necessary to analyze <br><br><ul><li>  presence of restrictions from the documentation on a specific table / column; </li><li>  the real percentage of NULL values ‚Äã‚Äãin these columns; </li></ul><br>  This was helped by a request, the text of which is available at the link below.  The request itself for large volumes takes a long time, it is recommended to indicate the specific table that you need to analyze. <br><br><div class="spoiler">  <b class="spoiler_title">SparseCandidate</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-comment"><span class="hljs-comment">#temp ( ColumnName varchar(50), ColumnID int, TableName varchar(50), TableId int, TypeName varchar(50), IsParse bit, IsNullable bit, NumberOfRow bigint, NumberOfRowNULL bigint, Ratio int) SET NOCOUNT ON INSERT into #temp SELECT DISTINCT sys.columns.name ColumnName, sys.columns.column_id ColumnID, OBJECT_NAME(sys.columns.object_id) AS TableName, sys.columns.object_id TableID, CASE systypes.name WHEN 'sysname' THEN 'nvarchar' ELSE systypes.name END AS TypeName, sys.columns.is_sparse IsParse, sys.columns.is_nullable IsNullable, 0,0,0 FROM sys.columns (NoLock) INNER JOIN systypes (NoLock) ON systypes.xtype = sys.columns.system_type_id WHERE sys.columns.object_id = OBJECT_ID('my_table') -- change table name and systypes.name NOT IN ('geography', 'geometry', 'image', 'ntext', 'text', 'timestamp') and sys.columns.is_sparse = 0 and sys.columns.is_nullable = 1 and sys.columns.is_rowguidcol = 0 and sys.columns.is_identity = 0 and sys.columns.is_computed = 0 and sys.columns.is_filestream = 0 and sys.columns.default_object_id = 0 and sys.columns.rule_object_id = 0 and sys.columns.system_type_id=sys.columns.user_type_id delete tps from #temp tps where exists ( select DISTINCT 'Exists' from sys.columns inner join sys.indexes i on i.object_id = tps.TableId inner join sys.index_columns ic on ic.column_id = tps.ColumnID inner join sys.columns c on c.object_id = tps.TableId and ic.column_id = c.column_id where i.type =1 or i.is_primary_key = 1) select count(*) from #temp delete tps from #temp tps inner join sys.partitions p on p.object_id = tps.TableId where p.data_compression&lt;&gt;0; DECLARE @TableName nvarchar(1000) DECLARE @ColumnName nvarchar(1000) DECLARE @vQuery nvarchar(1000) DECLARE @result1 INT DECLARE @result2 INT DECLARE tables_cursor CURSOR FAST_FORWARD FOR SELECT TableName,ColumnName FROM #temp OPEN tables_cursor FETCH NEXT FROM tables_cursor INTO @TableName,@ColumnName WHILE @@FETCH_STATUS = 0 BEGIN -- Search the number of row in a table SET @vQuery = 'SELECT @result1= COUNT(*) FROM [' + @TableName + ']' EXEC SP_EXECUTESQL @Query = @vQuery , @Params = N'@result1 INT OUTPUT' , @result1 = @result1 OUTPUT -- Search the number of row in a table SET @vQuery = 'SELECT @result2= COUNT(*) FROM [' + @TableName + '] where [' + @ColumnName + '] is null' EXEC SP_EXECUTESQL @Query = @vQuery , @Params = N'@result2 INT OUTPUT' , @result2 = @result2 OUTPUT update #temp set NumberOfRow = @result1,NumberOfRowNULL = @result2,Ratio = (@result2*100/@result1) where ColumnName=@ColumnName and TableName=@TableName FETCH NEXT FROM tables_cursor INTO @TableName,@ColumnName END CLOSE tables_cursor DEALLOCATE tables_cursor --delete from #temp where Ratio&gt;10 select * from #temp --drop table #temp</span></span></code> </pre></div></div><br>  Next, from the resulting list, it is necessary to determine the columns that satisfy our conditions as much as possible (with max NULL values) and change them to sparse.  The change itself is best done in single_user database mode to eliminate the occurrence of long locks.  After converting a column to sparse, you need to perform an index rebuild, only after that you can see the resizing of the table. <br><br>  I emphasize that the use of the mechanism does not increase the load on the processor of the DBMS server (it was checked both in practice and load testing). <br><br>  Perhaps this is one of those rare situations that can be briefly depicted with the following pictures: <br><br><img src="https://habrastorage.org/webt/px/nn/xy/pxnnxyrcourxfdzfo6-zoc2bswo.png"><br><br><h4>  Splitting a table into smaller ones </h4><br>  In this case, the work could also be divided into blocks: <br><br><ul><li>  making changes to the system architecture; </li><li>  modification of all applied development for a new architecture. </li></ul><br>  Both items are quite expensive and the separation of the table was the last in the list of possible optimizations.  All this could be delayed indefinitely. <br><br>  By the way, the implementation of this item is currently not required.  Good or bad in terms of the development of the product as a whole, I think time will tell ... <br><br><h2>  Sparse effect </h2><br>  Well, instead of conclusions, I would like to note in numbers the positive aspects of using sparse columns: <br><br><ol><li>  reduced the volume of the cluster index of table X by ~ 2 times (a similar effect on reducing the volume of MB during the re-creation of nonclustered indexes with key-fields, which were translated into sparse); <br><img src="https://habrastorage.org/webt/zf/7i/-c/zf7i-ciub6xexpzz2cfdbgmaybe.png"><br></li><li>  Based on claim 1, the efficiency of using the buffer pool has increased, since  decreased the amount of data in table X in the buffer pool; <br><br><img src="https://habrastorage.org/webt/rw/xu/g6/rwxug679x_9tinlf0txktv_y7em.png"><br></li><li>  based on p.1-2, the page lifetime in the buffer pool has increased (blue line), and as a result, the load on the disks has decreased (yellow line); <br><br><img src="https://habrastorage.org/webt/d5/z6/xa/d5z6xah7ycw58myk8umqyyubzdw.png"><br></li><li>  reduced the duration of the part of operations associated with large amounts of data sampling, because  increased probability of finding data in the buffer pool; </li></ol><br>  If we reduce the data in the table we get: <br><br><table><tbody><tr><th>  Indicator </th><th>  <nobr>Improvement</nobr> </th><th>  Note </th></tr><tr><td>  Clustered index volume of table X, GB </td><td>  <nobr>2 times</nobr> </td><td>  On disk (HDD) </td></tr><tr><td>  Clustered index size of table X in the buffer pool, GB </td><td>  <nobr>2 times</nobr> </td><td>  In Memory (RAM) </td></tr><tr><td>  Page Life Expectancy, sec </td><td>  <nobr>2 times</nobr> </td><td>  The lifetime of the page in the buffer pool </td></tr><tr><td>  Disk Transfers / sec, iops </td><td>  <nobr>1.6 times</nobr> </td><td>  The number of disk operations.  The load on the storage system is reduced. </td></tr></tbody></table><br><h4>  Sparse restrictions </h4><br>  However, in addition to the advantages, there were also restrictions: <br><br><ol><li>  sparse columns should be updated periodically.  After some time, the distribution of NULL and non-NULL values ‚Äã‚Äãin sparse columns may change and the use of sparse will be unjustified; </li><li>  The number of columns that can be translated in sparse is limited.  In case of exceeding when updating lines, error 576 may occur. </li></ol><br>  Detailed list of restrictions can be found <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/tables/use-sparse-columns">here</a> . <br><br>  If you have read the article to the end, then before performing any of the settings presented above, remember that the author of this article does not bear any responsibility for the possible loss or damage to your data.  Do not forget to make backups. <br><br>  Perhaps someone has already applied the settings described in the article on high-load systems, unsubscribe to what results you came. </div><p>Source: <a href="https://habr.com/ru/post/342838/">https://habr.com/ru/post/342838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342824/index.html">Log4j2 log aggregation by ELK</a></li>
<li><a href="../342826/index.html">Linux operating systems for different tasks</a></li>
<li><a href="../342830/index.html">How the leaders of the storage industry gathered at Prostor in Skolkovo (photo report)</a></li>
<li><a href="../342832/index.html">Avito iOS Meetup: Winter Edition</a></li>
<li><a href="../342834/index.html">PKCS # 11 Cryptographic Tokens: Managing and Accessing Token Objects (Continued)</a></li>
<li><a href="../342840/index.html">Performance in all senses: how did DotNext 2017 Moscow go</a></li>
<li><a href="../342842/index.html">The internal structure and optimization of the webpack bundle</a></li>
<li><a href="../342846/index.html">ENOG'14 - the impact of content locks on the Internet infrastructure</a></li>
<li><a href="../342848/index.html">Using SVG as a Placeholder</a></li>
<li><a href="../342850/index.html">RxPM - reactive implementation of the Presentation Model pattern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>