<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Technologies used in the PVS-Studio code analyzer to search for errors and potential vulnerabilities</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A brief description of the technologies used in the PVS-Studio tool that allow you to effectively detect a large number of error patterns and potentia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Technologies used in the PVS-Studio code analyzer to search for errors and potential vulnerabilities</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Technology and magic"></div><br>  A brief description of the technologies used in the PVS-Studio tool that allow you to effectively detect a large number of error patterns and potential vulnerabilities.  The article describes the implementation of the analyzer for C and C ++ code, but the information provided is also valid for the modules responsible for analyzing C # and Java code. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  There are misconceptions that static code analyzers are fairly simple programs based on the search for code patterns using regular expressions.  This is far from the truth.  Moreover, the identification of the vast majority of errors using regular expressions is simply <a href="https://www.viva64.com/ru/b/0087/">impossible</a> . <br><br>  Misconception arose based on the experience of programmers when working with some tools that existed 10-20 years ago.  The work of tools often really came down to finding dangerous code patterns and functions such as <i>strcpy</i> , <i>strcat</i> , etc.  As a representative of this class of tools can be called <a href="https://github.com/andrew-d/rough-auditing-tool-for-security">RATS</a> . <br><br>  Such tools, although they could be useful, were generally confused and ineffective.  It was from that time that many programmers still have memories that static analyzers are very useless tools that interfere more with work than help it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Time passed, and static analyzers began to be complex solutions that perform in-depth code analysis and find errors that remain in the code even after a careful code review.  Unfortunately, due to the past negative experience, many programmers still consider the static analysis methodology to be useless and are in no hurry to implement it in the development process. <br><br>  In this article I will try to correct the situation a little.  I ask readers to devote 15 minutes of time and get acquainted with the technologies used in the PVS-Studio static code analyzer for error detection.  Perhaps after this you take a fresh look at the static analysis tools and want to apply them in your work. <br><br><h2>  Data Flow Analysis </h2><br>  Data flow analysis allows you to find a variety of errors.  Among them are: going beyond the array boundary, memory leaks, always true / false conditions, dereferencing a null pointer, and so on. <br><br>  Also, data analysis can be used to search for situations when using untested data that came into the program from outside.  An attacker can prepare such a set of input data to make the program function in the way he needs.  In other words, it can use the lack of input control error as a vulnerability.  To search for the use of unverified data in PVS-Studio, the specialized diagnostics <a href="https://www.viva64.com/ru/w/v1010/">V1010 has been</a> implemented and continues to be improved. <br><br>  Data flow analysis is the calculation of the possible values ‚Äã‚Äãof variables at various points in a computer program.  For example, if the pointer is dereferenced, and it is known that at this moment it may be zero, then this is an error, and the static analyzer will report it. <br><br>  Let's look at a practical example of using data flow analysis to find errors.  Before us is a function from the Protocol Buffers (protobuf) project, designed to validate the date. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  The PVS-Studio analyzer detected two logical errors in the function at once and produces the following messages: <br><br><ul><li>  V547 / CWE-571 Expression 'time.month &lt;= kDaysInMonth [time.month] + 1' is always true.  time.cc 83 </li><li>  V547 / CWE-571 Expression 'time.month &lt;= kDaysInMonth [time.month]' is always true.  time.cc 85 </li></ul><br>  Pay attention to the subexpression ‚Äútime.month &lt;1 ||  time.month&gt; 12 ".  If the <i>month</i> value is outside the range [1..12], then the function stops its operation.  The analyzer takes this into account and knows that if the second <i>if</i> statement <i>starts</i> , then the <i>month</i> value exactly lies in the range [1..12].  Similarly, he knows about the range of other variables (year, day, etc.), but they are not interesting to us now. <br><br>  Now let's take a look at two identical access operators to the elements of the array: <i>kDaysInMonth [time.month]</i> . <br><br>  The array is set statically, and the analyzer knows the values ‚Äã‚Äãof all its elements: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Since the months are numbered from 1, the analyzer does not consider 0 at the beginning of the array.  It turns out that a value in the range [28..31] can be extracted from the array. <br><br>  Depending on whether the year is a leap year or not, 1 is added to the number of days. But this is also not interesting for us now.  The comparisons themselves are important: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  The range [1..12] (month number) is compared to the number of days in the month. <br><br>  <i>Bearing in mind</i> that in the first case, the month is always February ( <i>time.month == 2</i> ), we get that the following ranges are compared: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  As you can see, the result of the comparison is always true, which is what the PVS-Studio analyzer warns about.  Indeed, the code contains two identical typos.  The left side of the expression should use the <i>day</i> class member, and not the <i>month</i> at all. <br><br>  The correct code should be: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  The error considered here was also previously described in the article " <a href="https://www.viva64.com/ru/b/0550/">February 31.</a> " <br><br><h2>  Symbolic Execution </h2><br>  In the previous section, the method was considered when the analyzer calculates the possible values ‚Äã‚Äãof variables.  However, to find some errors, knowing the values ‚Äã‚Äãof variables is not necessary.  <a href="https://en.wikipedia.org/wiki/Symbolic_execution">Symbolic Execution</a> implies the solution of equations in symbolic form. <br><br>  I did not find a suitable demo in our <a href="https://www.viva64.com/ru/examples/">database of errors</a> , so we will consider a synthetic code sample. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  The PVS-Studio analyzer issues a V609 / CWE-369 Divide by zero warning.  Denominator 'A - B' == 0. test.cpp 12 <br><br>  The values ‚Äã‚Äãof the variables <i>A</i> and <i>B are</i> unknown to the analyzer.  But the analyzer knows that at the moment of calculating the expression <i>10 / (A - B) the</i> variables <i>A</i> and <i>B</i> are equal.  Therefore, a division by 0 will occur. <br><br>  I said that the values ‚Äã‚Äãof <i>A</i> and <i>B are</i> unknown.  For the general case this is true.  However, if the analyzer sees a function call with specific values ‚Äã‚Äãof the actual arguments, then it will take this into account.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  PVS-Studio analyzer warns of division by zero: V609 CWE-628 Divide by zero.  Denominator 'X' == 0. The 'Div' function processes value '[0..4]'.  Inspect the first argument.  Check lines: 106, 110. consoleapplication2017.cpp 106 <br><br>  A mixture of technologies is already working here: data flow analysis, symbolic execution and automatic annotation of methods (we will look at this technology in the next section).  The analyzer sees that the variable <i>X is</i> used in the <i>Div</i> function as a divisor.  Based on this, a special annotation is automatically <i>generated</i> for the <i>div</i> function.  Further, it is taken into account that the value range [0..4] is passed to the function as the argument <i>X.</i>  The analyzer concludes that a division by 0 should occur. <br><br><h2>  Method Annotations </h2><br>  Our team annotated thousands of functions and classes provided in: <br><br><ul><li>  WinAPI </li><li>  standard library C, </li><li>  Standard Template Library (STL) </li><li>  glibc (GNU C Library) </li><li>  Qt </li><li>  MFC </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  and so on </li></ul><br>  All functions are annotated manually, which allows you to set a lot of characteristics that are important from the point of view of searching for errors.  For example, it is specified that the size of the buffer transferred to the <i>fread</i> function must be no less than the number of bytes to be read from the file.  Also indicated is the relationship between the 2nd, 3rd arguments and the value that the function can return.  It all looks like this: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: markup of functions"></div><br>  Thanks to this annotation, the following code, in which the <i>fread</i> function is used, will immediately reveal two errors. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio warnings: <ul><li>  V512 CWE-119 A call of the fread function will guide you to the buffer.  test.cpp 116 </li><li>  V557 CWE-787 Array overrun is possible.  The value of 'i' index could reach 1000. test.cpp 117 </li></ul><br>  First, the analyzer multiplied the 2nd and 3rd actual argument and calculated that the function can read up to 1000 bytes of data.  In this case, the buffer size is only 100 bytes, and it may overflow. <br><br>  Secondly, since the function can read up to 1000 bytes, the range of possible values ‚Äã‚Äãfor the variable <i>i</i> is [0..1000].  Accordingly, an array may be accessed at an incorrect index. <br><br>  Let's look at another simple example of an error that has become possible due to the markup of the <i>memset</i> function.  Before us is a fragment of the code of the project CryEngine V. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  The PVS-Studio analyzer found a typo: V575 The 'memset' function processes '0' elements.  Inspect the third argument.  crythreadutil_win32.h 294 <br><br>  Jumbled 2nd and 3rd function argument.  As a result, the function processes 0 bytes and does nothing.  The analyzer notices this anomaly and warns programmers about it.  We have previously described this error in the article "The <a href="https://www.viva64.com/ru/b/0417/">long-awaited check of CryEngine V</a> ". <br><br>  The PVS-Studio analyzer is not limited to annotations given by us manually.  In addition, he independently tries to create annotations, studying the functions of the body.  This allows you to find errors of improper use of functions.  For example, the analyzer remembers that a function can return nullptr.  If the pointer that returned this function is used without a preliminary check, the analyzer will warn about it.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Warning: V522 CWE-690 There might be a potential pointer of a potential pointer 'Get ()'.  test.cpp 129 <br><br>  <b>Note.</b>  The search for the error just considered can be approached in the opposite way.  Do not memorize anything, but each time a <i>Get</i> function call is encountered, analyze it knowing the actual arguments.  This algorithm theoretically allows you to find more errors, but it has an exponential complexity.  The time of program analysis grows hundreds or thousands of times, and we consider such an approach a dead end from a practical point of view.  In PVS-Studio, we are developing the direction of automatic annotation of functions. <br><br><h2>  Pattern Matching (pattern-based analysis) </h2><br>  At first glance, pattern matching technology may seem like a search using regular expressions.  In fact, it is not, and everything is much more complicated. <br><br>  First, as I <a href="https://www.viva64.com/ru/b/0087/">said</a> , regular expressions are no good at all.  Secondly, analyzers work not with text lines, but with syntactic trees, which allows to recognize more complex and high-level error patterns. <br><br>  Consider two examples, one simpler and one more complicated.  I found the first error by checking the source code of Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  The PVS-Studio analyzer recognizes the classic error pattern associated with the programmer‚Äôs misconception about the priority of operations in the C ++ language: V593 / CWE-783 Consider reviewing the A = B!  The expression is calculated as the following: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Carefully look at this line: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  The programmer assumes that the assignment is performed at the beginning, and only then the comparison with <i>-1</i> .  In fact, the comparison occurs first.  Classic.  This error is discussed in more detail in the <a href="https://www.viva64.com/ru/b/0579/">article</a> on testing Android (see the ‚ÄúOther errors‚Äù chapter). <br><br>  Now consider a higher-level version of pattern matching. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio warning: V597 CWE-14 The compiler could delete the memset function call, which is used to flush the chunkBuffer buffer.  The RtlSecureZeroMemory () function should be used to erase the private data.  sha1.cpp 189 <br><br>  The essence of the problem lies in the fact that once the buffer has been filled with zeros using the <i>memset</i> function, this buffer is not used anywhere.  When building code with optimization flags, the compiler will decide that this function call is redundant and remove it.  It has the right to this, since from the point of view of the C ++ language, a function call does not have any observable behavior on the program operation.  Immediately after the <i>chunkBuffer</i> buffer is filled, the <i>sha1ProcessChunk</i> function terminates.  Since the buffer is created on the stack, after exiting the function it becomes unavailable for use.  Therefore, from the point of view of the compiler, it makes no sense to fill it with zeros. <br><br>  As a result, private data will remain somewhere on the stack, which can cause trouble.  This topic is discussed in more detail in the article " <a href="https://www.viva64.com/ru/b/0388/">Safe cleaning of private data</a> ". <br><br>  This is an example of a high-level pattern matching.  First, the analyzer must be aware of the existence of this security defect, classified according to the Common Weakness Enumeration as <a href="https://cwe.mitre.org/data/definitions/14.html">CWE-14: Compiler</a> . <br><br>  Secondly, it must find in the code all the places where the buffer is created on the stack, overwritten with the help of the <i>memset</i> function and then not used anywhere else. <br><br><h2>  Conclusion </h2><br>  As you can see, static analysis is a very interesting and useful methodology.  It allows you to eliminate at the earliest stages a large number of errors and potential vulnerabilities (see <a href="https://www.viva64.com/ru/sast/">SAST</a> ).  If you are still not completely absorbed with static analysis, then I invite you to read our <a href="https://www.viva64.com/ru/b/">blog</a> , where we regularly analyze errors found by PVS-Studio in various projects.  You just can not stay indifferent. <br><br>  We will be happy to see your company among <a href="https://www.viva64.com/ru/customers/">our customers</a> and help make your applications better, more reliable and more secure. <br><br><p> <a href="https://www.viva64.com/en/b/0592/"><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="https://www.viva64.com/en/b/0592/">Technologies used in the PVS-Studio code analyzer for finding bugs and potential vulnerabilities</a> . </div><p>Source: <a href="https://habr.com/ru/post/430604/">https://habr.com/ru/post/430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430590/index.html">Germany has developed requirements for home routers</a></li>
<li><a href="../430592/index.html">Client Internet in an isolated QEMU virtual machine using port tunneling through the SPICE channel</a></li>
<li><a href="../430596/index.html">How to prepare a grocery strategy? Product Manager's Guide</a></li>
<li><a href="../430600/index.html">Mars - from chocolate to robots</a></li>
<li><a href="../430602/index.html">Vulnerabilities smart contracts Etherium. Code examples</a></li>
<li><a href="../430606/index.html">Group-IB Webinar: "Forensic Investigation of RDP Artifacts in Windows"</a></li>
<li><a href="../430610/index.html">How to safely get rid of their electronic devices</a></li>
<li><a href="../430612/index.html">As in the 1980s, people downloaded radio games</a></li>
<li><a href="../430614/index.html">Black Friday 2018 at Madrobots</a></li>
<li><a href="../430616/index.html">Workshop "Testing and Monitoring", November 27, Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>