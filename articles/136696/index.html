<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplex Sierpinski</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is intended to familiarize you with the basic mathematical component of computer multidimensional graphics. Using the example of the Sier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplex Sierpinski</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/676/58d/8bd/67658d8bdabd10bb8ec149b54a97ab80.png"><br><br>  This article is intended to familiarize you with the basic mathematical component of computer multidimensional graphics.  Using the example of the Sierpinski <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581">simplex</a> , the article discusses the issues of constructing, moving, projecting and displaying complex multidimensional geometric figures. <br>  There are also pictures, videos, sources, and I assure you that everything is very simple, read, understand. <br><a name="habracut"></a><br>  What is <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA_%25D0%25A1%25D0%25B5%25D1%2580%25D0%25BF%25D0%25B8%25D0%25BD%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">the Sierpinski triangle</a> , and what the <a href="">Sierpinski pyramid is</a> quite understandable.  But what is the Sierpinski simplex?  To begin with, for those who have not read on the wiki what simplex is, I‚Äôll just say that simplex is an n-dimensional tetrahedron (see <a href="http://www.youtube.com/watch%3Fv%3DJp2gnFLQCxs">video</a> ).  Well, the Sierpinski simlex is a kind of fractal, built by analogy with the Sierpinski triangle and tetrahedron. <br><br><h2>  Construction of an equilateral simplex </h2><br>  Do not believe it, but this is the most difficult among all that is in this article (according to my estimates).  But all we need is n points in n-1 dimensional space, equidistant from each other and from the center.  Before reading further, I strongly recommend to think, how would you build such points? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, we are interested in cases where n&gt; = 3, otherwise it‚Äôs just not interesting.  Each n-th point will be built on the basis of all previous ones.  To begin with, we need to build a normal equilateral triangle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a49/cfe/317/a49cfe317b2e2a32e3e9f0c3fc75df0c.png"><br>  In order to add a new point - you need a new dimension (denoted by W).  Entering this measurement, so that the point is equidistant from all other points, set the value of the point P1 for this point P1 along the W axis, and the rest of the points along the W axis as -q2.  The remaining coordinates of the axes for the point Pn are left zero.  What is the result?  With all the points that were - remain at equal distance from each other and from the center, and the new point is equidistant from all the others.  It remains only to choose such q1, q2, so that all points are equidistant from each other, and from the center. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a74/73a/bda/a7473abda1a046b299fb8e6b2355c12b.png"><br>  l - the distance between points is constant, and is calculated after constructing a triangle. <br>  d - distance from points to the center - changes, and is calculated before adding a new point. <br>  The first equation indicates that the distances from the received points to the new ones should be the same. <br>  The second is that the distances to the center should be the same. <br>  Actually, this is how we get an equilateral simplex. <br><br>  Sources: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> c = r * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> l = c * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//distance between points points[0][0] = + 0; points[0][1] = + r; //first point points[1][0] = + c; points[1][1] = - r / 2; //second point points[2][0] = - c; points[2][1] = - r / 2; //3th point for (int i = 3; i &lt;= dimensionalCount; i++) { double d = points[0].distanceToCenter(); double q2 = (l * l - 2 * d * d) / (2 * sqrt(l * l - d * d)); double q1 = sqrt(d * d + q2 * q2); for (int k = 0; k &lt; i; k++) { points[k][i-1] = -q2; //set i-th dimension for all created points points[i][k] = 0; //set all calculated dimension for new point } points[i][i-1] = q1; }</span></span></code> </pre> <br><h2>  Fractal </h2><br>  It is very easy to see that both the triangle (n = 2) and the tetrahedron (n = 3) of Sierpinski are created from the base figure by replacing the base figure with n + 1 of the same, but smaller.  In each of the new figures, one point of the base figure is taken as a basis, the remaining points are the centers of mass of the segments, which include this point.  In principle, everything is very simple and clear. <br><br>  So we write: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QVector&lt;Simplex&gt;&amp; storage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Simplex&amp; current, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> recursionDepth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recursionDepth == maxRecursionDepth) storage.append(current); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= n; i++) { Simplex newTriangle(current.dimensionsCount()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt;= n; k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == k) newTriangle[k] = current[i]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newTriangle[k] = (current[i] + current[k]) / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; } rec(storage, newTriangle, recursionDepth + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre><br>  As you can see, nowhere is there a reliance on the dimension of space, and it works correctly for both 2D and 3D: <br><br><img src="http://habrastorage.org/storage3/5e2/3bb/d45/5e23bbd45f91c3754e80399f3a9ff14f.png"><br><br><img src="http://habrastorage.org/storage3/2d6/b39/a70/2d6b39a70f4c43b44d1180dc4a1cabb8.png"><br><br><h2>  Rotate &amp; Projection </h2><br>  It can be difficult to rotate (quaternions, matrix transformations), but you can simply ... We will do everything simply, sequentially rotate in each two coordinates.  For 2D, this can be perceived as a turn around a point, for 3D - around a straight line, for ND - around (N-2) -dimensional space.  Actually, the rotation formula is calculated very simply: <br><img src="http://habrastorage.org/storage3/0d6/8bd/f52/0d68bdf5210580a70643cdeab303efcd.png"><br><br>  Well, it is programmed even easier: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coordinates.count(); i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; coordinates.count(); k++) { ratio = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> + i * coordinates.count() + k); p1 = temp[i] * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle * ratio) - temp[k] * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle * ratio); p2 = temp[k] * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle * ratio) + temp[i] * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle * ratio); temp[i] = p1; temp[k] = p2; }</code> </pre><br>  Where ratio is the ratio in order for the rotation in different directions to be at different speeds, preferably without looping.  temp [i] is the i-th coordinate of the current point. <br><br>  <b>Projection</b> is the most difficult moment of working with multidimensional spaces.  There are many reasons: <br>  1. No one used to understand multidimensional geometric objects. <br>  2. Optics of physics is silent about this (as far as I know). <br>  3. A bunch of different methods and all overload the picture, and it is unclear what is correct. <br><br>  We take the simplest method - a perspective projection.  We will project the n-dimensional point on the (n-1) space ... Thus, each time lowering the N - we get to the point that the point is already two-dimensional or three-dimensional and can already be displayed. <br><br>  Using the example of 2D to 1D, we will try to calculate the perspective projection formula. <br><img src="http://habrastorage.org/storage3/a97/e0e/f10/a97e0ef10795b94435c27450eaa7bece.png"><br><br>  It can be seen that with the help of 2 coordinates and a certain focus constant one coordinate can be made.  And the formula is very simple, like the code: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = coordinates.count() - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i--) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; i; k++) temp[k] *= focus / (focus + temp[i]);</code> </pre><br>  How is all this correct?  Not at all correctly, never, not a drop!  But judging by what is in the internet, something very similar is used by other programmers.  For example, a <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D1%2581%25D0%25B5%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582">tesseract</a> obtained by this projection method: <br><br><img src="http://habrastorage.org/storage3/9cd/56b/0f5/9cd56b0f5b2ebbc1006d746dea529227.png"><br><br><h2>  Rendering </h2><br>  <b>QPainter</b> is the easiest way, which is to use standard development environment tools to draw everything with normal lines, without lighting, filling triangles, and so on.  In my sources, it is enabled by default, and will work wherever there is Qt (Windows, Linux, Mac OS ...). <br><br>  Actually, this is how the rendering code looks like: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">QPoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">center</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">-&gt;width() / </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">-&gt;height() / </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; foreach(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Simplex&amp; simplex, simplexes) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; simplex.dimensionsCount() + <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; simplex.dimensionsCount() + <span class="hljs-number"><span class="hljs-number">1</span></span>; k++) p.drawLine(simplex[i].to2D(focus, angle) + center, simplex[k].to2D(focus, angle) + center);</code> </pre><br>  As you can see, there is nothing simpler ... But we need to be beautiful, right? <br><br>  <b>OpenGL</b> , <b>DirectX</b> is a progressive method that allows rendering everything in real time beautifully.  But there is a misfortune: without transparency, nothing will be beautiful, and the transparency of these two monsters suggests that you need to render from the far (z -&gt; max) to the close (z -&gt; min).  For this, each frame, the triangles need to be sorted, and in my example they are about 6000. Well, it does not matter, the trouble is that in general it is impossible to determine which triangle is closer and which is farther.  Moreover, when we speak of projection from multidimensional space, we say that the triangles intersect.  As a result, they need to cut and sort each iteration, which is already very difficult ... <br>  I did not implement this method. <br><br>  <b>Ray tracing</b> is what the doctor prescribed.  <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25B9">This technology</a> will allow you to get the picture of the highest quality and has a drawback only in speed.  But, in fact, we don‚Äôt need real time. <br><br>  For tracing, I used <a href="http://ru.wikipedia.org/wiki/POV-Ray">POV-Ray</a> , which was ideally suited for this task only because it can run from the command line, without any GUI there. <br>  To use this miracle, I wrote a certain template, which the program fills with the necessary points, and the output is a ready-for-trace .pov file.  The pattern on a set of points builds triangles and frames, and is very simple in its structure: <br><pre> <code class="tex hljs">#declare ppp = array[&lt;&lt;!!--count of points--!!&gt;&gt;] { &lt;&lt;!!--Main Array of points--!!&gt;&gt; }; #declare i = 0; #while(i &lt; &lt;&lt;!!--count of points--!!&gt;&gt;) #if (vlength(ppp[i] - ppp[i+1])!=0) cylinder{ppp[i], ppp[i+1], 0.2 texture {pigment{color Gray}} } #end #if (vlength(ppp[i] - ppp[i+2])!=0) cylinder{ppp[i], ppp[i+2], 0.2 texture {pigment{color Gray}} } #end #if (vlength(ppp[i+1] - ppp[i+2])!=0) cylinder{ppp[i+1], ppp[i+2], 0.2 texture {pigment{color Gray}} } #end polygon {4 ppp[i], ppp[i+1], ppp[i+2] ,ppp[i] texture { Surface_Texture }} #declare i=i+3; #end</code> </pre><br>  Actually, based on this template, 1000 pictures were made with different turns, of which this video was later made: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/E0BPIVMCJUk%3Ffeature%3Doembed&amp;xid=17259,1500002,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhiIq0EOrjep1O-UeSWfe-SxglmmQw" frameborder="0" allowfullscreen=""></iframe><br>  <a href="https://github.com/TheHorse/SimplexSerpinskii">Sources</a> <br><br>  The article is dedicated to the girls heavy metal band Fight with Fate. </div><p>Source: <a href="https://habr.com/ru/post/136696/">https://habr.com/ru/post/136696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136683/index.html">Achievements in Visual Studio</a></li>
<li><a href="../136684/index.html">Exchange 1C with a client on C # using 1C web services</a></li>
<li><a href="../136691/index.html">New MIT algorithm accelerates fast Fourier transform tenfold</a></li>
<li><a href="../136694/index.html">Uploading images to the server using HTML5 + jQuery + PHP</a></li>
<li><a href="../136695/index.html">Zadolbali!</a></li>
<li><a href="../136701/index.html">Simpliste: just one week</a></li>
<li><a href="../136705/index.html">Adding Scala support with a few clicks to your Android project (Eclipse)</a></li>
<li><a href="../136706/index.html">Saturday Notes: On Dead Languages ‚Äã‚Äãand Living Practice</a></li>
<li><a href="../136708/index.html">Sky Map give in open source, Picnik photo editor close</a></li>
<li><a href="../136709/index.html">Iranian web developer sentenced to death</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>