<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cones stuffed with 15 years of using actors in C ++. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We finish the story begun in the first part . Today we will consider a few more rakes, which happened to occur over the years of using SObjectizer in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cones stuffed with 15 years of using actors in C ++. Part II</h1><div class="post__text post__text-html js-mediator-article"><p>  We finish the story begun <a href="https://habrahabr.ru/post/324420/">in the first part</a> .  Today we will consider a few more rakes, which happened to occur over the years of using <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> in everyday work. </p><br><h1>  We continue to list rakes </h1><br><h2>  People want synchronicity ... </h2><br><p>  The actors in the Model Actors and agents in our SObjectizer communicate through asynchronous messages.  And therein lies one of the reasons for the attractiveness of the Actor Model for certain types of tasks.  It would seem that asynchrony is one of the cornerstones, one of the bonuses, so take advantage of your health and enjoy. </p><br><p>  But no.  In practice, requests quickly began to be made in SObjectizer the possibility of simultaneous interaction of agents.  For a long time I resisted these requests.  But in the end gave up.  I had to add to SObjectizer the <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Synchronous%2520Interaction/">ability to perform a synchronous request from one agent to another</a> . </p><br><p>  It looks like this in the code: </p><br><a name="habracut"></a><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  . struct get_messages final : public so_5::signal_t {}; ... //   ... auto msgs = request_value&lt;std::vector&lt;message&gt;, get_messages&gt;(mbox, so_5::infinite_wait); // ...  . for(const auto &amp; m : msgs) ...</span></span></code> </pre> <br><p>  This shows the call to the request_value function, which makes a synchronous request, suspending the execution of the current thread until the result of the request is received. </p><br><p>  In this case, we send a request of type get_messages to get the vector of message objects in response.  And we will wait for an answer without time limit. </p><br><p>  However, in SObjectizer it is implemented all the same through the message.  Inside the request_value, a message is sent to the target agent, which receives and processes it in the usual way.  Those.  the recipient does not even know that a synchronous request has come to him, for him everything looks like a normal asynchronous message. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collector</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . so_subscribe(mbox).event&lt;get_messages&gt;(&amp;collector::on_get_messages); ... } private : std::vector&lt;messages&gt; collected_messages_; //  ,     get_messages. std::vector&lt;messages&gt; on_get_messages() { std::vector&lt;messages&gt; r; std::swap(r, collected_messages_); return r; } };</span></span></code> </pre> <br>  Those.  inside collector :: on_get_messages, the message receiving agent cannot determine whether it received get_messages as a regular asynchronous message or is part of a synchronous request. <br><br><p>  But under the hood is hidden not very complicated mechanics, built on the basis of std :: promise and std :: future from the standard C ++ 11 library. </p><br><p>  First, when sending a synchronous request to the recipient does not come a regular message, but a tricky one, along with the std :: promise object inside: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">special_message</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::promise&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;messages&gt;&gt; promise_; ... };</code> </pre> <br><p>  This message gets into a special handler that is automatically generated by SObjectizer when subscribing: </p><br><pre> <code class="cpp hljs">collector * collector_agent = ...; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> actual_message_handler = [collector_agent](special_message &amp; cmd) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cmd.promise_.set_value(collector_agent-&gt;on_get_messages()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) { cmd.promise_.set_exception(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::current_exception()); } }; do_special_subscribe&lt;get_messages, special_message&gt;(mbox, actual_message_handler);</code> </pre> <br><p>  This tricky handler calls a user-defined message handler, and then saves the returned value (or an exception thrown outside) to the std :: promise object from the tricky message.  This will trigger std :: future, in which the sender of the request is sleeping.  Accordingly, a return from request_value will occur. </p><br><p>  Obviously, synchronous interaction between agents is a direct way to receive deadlocks.  Therefore, there is a request_value in SObjectizer, but we recommend using it with great care. </p><br><p>  The funny thing for me personally was that very quickly there was a useful use for request_value.  Just in the mechanisms to protect agents from overload.  If this protection is done through the collector / performer pair, then the performer is convenient to apply for the next batch of messages through the request_value.  And since the collector and performer should, in principle, work on different threads, the danger of getting deadlock here is minimized. </p><br><p>  The moral of this story is this: strict adherence to the principles of some theoretical model is good.  But if in practice you are urged to do something that conflicts with these very principles, then it makes sense to listen.  Maybe something useful will come out. </p><br><h2>  Distribution out of the box: everything is not so bright </h2><br><p>  In SObjectizer-4, the developer out of the box was able to create distributed applications.  We had our own protocol on top of TCP / IP, our own way of serializing C ++ data structures. </p><br><p>  On the one hand, it was very cool and cool.  Using simple gestures, messages could be made to automatically fly between the nodes on which parts of the distributed application were running.  SObjectizer took over the serialization and deserialization of data, control of transport channels, reconnections at breaks, etc. </p><br><p>  In general, at first everything was cool. </p><br><p>  But over time, as the range of tasks solved on the SObjectizer-e widened, as the load on applications grew, we had a lot of trouble: </p><br><ul><li>  First, for each type of task it is desirable to have its own protocol.  Because, say, the spread of telemetry, i.e.  the exchange of a large number of small messages, the loss of which is not terrible, is very different from the exchange of large binary files.  For example, an application where you need to share large archives or chunks of video files should use some other protocol than the application in which thousands of messages are transmitted from current air temperature sensors; </li><li>  secondly, the implementation of back-pressure for asynchronous agents is not a simple thing in itself.  And when communication over the network is mixed in here, the situation becomes much worse.  Any delays in the network or braking on one of the nodes leads to the accumulation of large volumes of undelivered messages on the other nodes, and this greatly spoils life; </li><li>  thirdly, the times when large distributed systems could only be written on a single C ++, ended a long time ago.  Today, certain components will be written in other programming languages.  This means interoperability is required.  Which automatically leads to the fact that our own protocol, sharpened for C ++ and SObjectizer, does not help, but hinders the development of distributed applications. </li></ul><br><p>  Therefore, there are no tools to support distribution in SObjectizer-5.  We are looking more towards making it easier for agents to communicate with the outside world through de facto standard protocols.  This is better than inventing your own bikes. </p><br><h2>  Many agents are a problem, not a solution.  SEDA Wei FOREVER! </h2><br><p>  Well, I personally like this topic very much.  For once again emphasize that marketing and common sense can contradict each other :) </p><br><p>  Almost all actor frameworks in their marketing materials necessarily say that actors are lightweight entities and in the application you can create at least one hundred thousand actors, even a million, even ten million actors. </p><br><p>  When an untrained programmer is faced with the ability to create a million actors in a program, he may have to slightly tear down the roof.  This is so tempting - to arrange every activity inside the application in the form of an actor. </p><br><p>  The programmer succumbs to this temptation, begins to create actors for every sneeze and soon discovers that he has tens of thousands or even hundreds of thousands of actors working on his program at the same time ... What can cause at least one of two problems. </p><br><h3>  What's going on inside the application with a million actors? </h3><br><p>  The first problem that can be encountered when creating a large number of actors is the lack of understanding of what is happening in the program, why the program works in the same way and how the program will behave further. </p><br><p>  What I call the bird flock effect happens: the behavior of an individual bird in a flock can be described by a set of several simple rules, but the configuration of the whole flock turns out to be complex and practically unpredictable. </p><br><p>  Similarly, in an application with a large number of agents.  Each agent can work according to simple and understandable rules, but the behavior of the entire application can be complexly predictable. </p><br><p>  For example, some agents will suddenly cease to show signs of life.  It seems like they are, but their work is not visible.  And then suddenly they ‚Äúwake up‚Äù and start working so actively that there are not enough resources for other agents. </p><br><p>  In general, keeping track of what is happening inside an application with ten thousand agents is much more difficult than in an application where only one hundred agents work.  Imagine that you have ten thousand agents and you wanted to know how heavily loaded one of them is.  I think this will be a problem. </p><br><p>  By the way, one of the killer features of Erlang is that Erlang provides tools for introspection.  The developer can at least see what is happening inside his Erlang virtual machine.  How many processes, how much each process eats, what queue sizes, etc.  But Erlang has its own virtual machine and it is possible there. </p><br><p>  If we are talking about C ++, then C ++ frameworks, as far as I know, are very far behind Erlang in this area.  On the one hand, this is objective.  Still, C ++ is compiled into native code and it is much more difficult to monitor pieces of native code.  On the other hand, the implementation of such monitoring is a non-trivial task, requiring considerable effort and investment.  Therefore, it is difficult to expect advanced features in OpenSource frameworks that are developed only on pure enthusiasm. </p><br><p>  So, creating a large number of agents in a C ++ application and not having the same advanced monitoring tools as in Erlang, it is difficult to monitor the application and understand how it works there. </p><br><h3>  Sudden bursts of activity </h3><br><p>  The second possible problem is a sudden surge of activity, when a part of your actors suddenly begin to consume all the available resources. </p><br><p>  Imagine that you have in the application 100 thousand agents.  Each of them initiates an operation and cocks the timer to control the timeout for the operation. </p><br><p>  Suppose some piece of the application began to slow down, the previously started operations began to fall off due to a timeout and the deferred messages about the expiration of timeouts began to come in batches.  For example, within 2 seconds 10 thousand timers worked.  This means calling 10,000 deferred message handlers. </p><br><p>  And here it may turn out that each such handler for some reason spends 10ms.  This means that processing all 10 thousand deferred messages will take 100 seconds.  Even if these messages will be processed in four parallel threads.  But it is still 25 seconds. </p><br><p>  It turns out that part of our application for these 25 seconds stupidly freezes.  And until he processes these same 10 thousand deferred messages, he will not react to anything else. </p><br><h3>  Misfortune never comes alone... </h3><br><p>  The saddest thing is that both of the above problems overlap perfectly.  Due to a sudden burst of activity, we are faced with unplanned behavior of our application, and because of the effect of the bird flock, we cannot understand what is happening.  The application seems to work, but somehow it is not.  And it is not clear what to do with it.  You can, of course, stupidly beat the application and restart it.  But this means the re-creation of 100 thousand agents, their restoration in some state, the renewal of connections to some external services, etc.  Painlessly such a restart, unfortunately, will not do. </p><br><p>  So the ability to create a bunch of agents in your application should not be treated as a way to solve your problems.  And as a way to make yourself even more problems. </p><br><p>  The way out, of course, is simple: you need to get by with fewer agents.  But how to do that? </p><br><h3>  SEDA approach </h3><br><p>  Very well inserts the brains into place familiarity with the approach of <a href="https://en.wikipedia.org/wiki/Staged_event-driven_architecture">SEDA (Staged Event-Driven Architecture)</a> .  In the early 2000s, a small group of researchers developed a Java framework of the same name and with its help proved the viability of the underlying idea: break up the implementation of complex operations into a stage, separate each process‚Äôs flow (or group of threads) for each stage, and organize the interaction between the stages asynchronous message queues. </p><br><p>  Imagine that we need to handle a payment request.  We receive a request, check its parameters, then check the possibility of making a payment for a given client (for example, if he has not exceeded the daily limits on his payments), then we estimate the riskiness of the payment (for example, if a client is from Belarus and the payment is for some reason initiated from Bangladesh then it is suspicious), then we make a debit and form the result of the payment.  Here you can clearly see several stages of processing a single operation. </p><br><p>  The ability to create a million agents in an application pushes us to create one agent for each payment, who himself would consistently perform all the stages.  Those.  he himself would validate the payment parameters, he himself would determine the daily limits and their exceedances, he himself would make inquiries to the fraud monitoring system, etc.  Schematically it might look like this: </p><br><img src="https://habrastorage.org/files/107/0ad/d91/1070add9159f47868353ab71bb210ddb.png"><br><p>  In the case of the SEDA approach, we could have one agent for each stage.  One agent accepts payment requests from customers and forwards them to the second agent.  The second agent checks the request parameters and sends valid requests to the third agent.  The third agent checks the limits, etc.  Schematically, it looks like this: </p><br><img src="https://habrastorage.org/files/11f/941/ca6/11f941ca67464afb915c4a722cbd7625.png"><br><p>  The number of agents is reduced by orders of magnitude.  It is much easier to control these agents.  The protection of such agents from overloads is greatly simplified.  These agents, if they work with the DBMS, have the opportunity to use bulk operations.  Those.  the agent accumulates, say, 1000 messages, then serves them all with 2-3 bulk calls to the database.  We have the opportunity to dose the activity of agents.  For example, if the external fraud monitoring system suddenly falls off and we need to generate 10 thousand negative answers, then we may not immediately send all these 10 thousand answers, but smear them evenly, say, for ten seconds.  Thereby we will protect other parts of the system from overload. </p><br><p>  Additional bonus: if only one agent serves some stage, then the task of prioritizing transaction processing at this stage is considerably simplified.  For example, if you need transactions from online clients to process with a higher priority than scheduled transactions.  In the case of the SEDA approach, this is easier to implement than when an agent is responsible for each transaction. </p><br><p>  At the same time, even within the framework of the SEDA approach, we still enjoy the benefits that the Actor Model gives us.  But we confine ourselves to literally several dozens of actors, instead of tens of thousands. </p><br><h1>  Conclusion </h1><br><p>  In conclusion, I would like to say that the Model Actors is a cool joke, but not a silver bullet at all.  In some tasks, the Model Actor works well, in some it does not work very well, in some it does not work at all. </p><br><p>  But even if the Model of Actors fits the task, it would still be very useful to have a couple of things: </p><br><ul><li>  First, the developer himself must have a head on his shoulders.  If the developer thoughtlessly creates hundreds of thousands of actors in his application, does not think about the problem of overload, has no idea what a spontaneous surge of activity is, etc., then with the Actor Model you can make yourself no less trouble than ‚Äú bare "threads; </li><li>  secondly, it would be good if the actor framework provided the developer with all possible assistance.  In particular, in such things as protecting actors from overloading, error handling and introspection of what is happening inside the application.  That is why we are gradually expanding the functionality of SObjectizer in this direction.  We have already added such things as message limits, exceptions, statistics and monitoring information, and tools for tracing the message delivery mechanism. </li></ul><br><p>  By the way, just the set of such auxiliary tools in the actor framework, in my opinion, is a sign that determines the maturity of the framework.  For it is not so difficult to implement some idea in your framework and show its efficiency.  You can spend a few months of work and get quite a working and interesting tool.  This is all done on pure enthusiasm.  Literally: I liked the idea, wanted and did. </p><br><p>  But equipping what happened with all sorts of aids, like collecting statistics or tracing messages, is already a boring routine for which it‚Äôs not so easy to find time and desire. </p><br><p>  Therefore, my advice to those who are looking for a ready actor framework: pay attention not only to the originality of ideas and the beauty of examples.  Look also at all sorts of auxiliary things that will help you figure out what is happening in your application: for example, find out how many actors are inside now, what are their queue sizes, if the message does not reach the recipient, then where does it go ... If the framework is something like this provides, then it will be easier for you.  If it does not, then you will have more work. </p><br><p>  Well, add from myself: if you wanted to take and make your own actor framework from scratch, which would protect the developer from the rakes discussed above, this is not a good idea.  Occupation is absolutely ungrateful.  Yes, and hardly payable.  This has already been verified.  In humans. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324978/">https://habr.com/ru/post/324978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324964/index.html">Are there stacking in Cisco Nexus switches?</a></li>
<li><a href="../324966/index.html">SAP Business One ERP Solution Features on SAP HANA Platform</a></li>
<li><a href="../324968/index.html">learnopengl. Lesson 1.8 - Coordinate Systems</a></li>
<li><a href="../324970/index.html">Adaptive Email Guide</a></li>
<li><a href="../324974/index.html">Open lecture by Sergei Zykov on April Fools ‚Äôactions in games</a></li>
<li><a href="../324980/index.html">Webinar "Testing applications for vulnerabilities. The practice of building SDLC</a></li>
<li><a href="../324982/index.html">First experience with Google API (for example, ContactsAPI) and OAuth2.0 on pure HTTP</a></li>
<li><a href="../324984/index.html">Basic concepts of the chrono library (C ++)</a></li>
<li><a href="../324986/index.html">Calculation of the correcting FIR filter on the FPGA</a></li>
<li><a href="../324988/index.html">Java implementation of a hashed binary tree</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>