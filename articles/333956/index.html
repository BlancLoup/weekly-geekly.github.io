<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Useful commands and tips when working with Kubernetes through the kubectl console utility</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Foreword : This article is a combination of the translation of two materials from the CoreOS project (see links at the end of the publica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Useful commands and tips when working with Kubernetes through the kubectl console utility</h1><div class="post__text post__text-html js-mediator-article"> <i><b>Translator's Foreword</b> : This article is a combination of the translation of two materials from <a href="http://coreos.com/">the CoreOS project</a> <i>(see links at the end of the publication)</i> on working with the console tool for executing commands on Kubernetes- <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/">kubectl clusters</a> .</i>  <i>The listing provided by the original author for Mac OS X was adapted for Linux, in other listings the YAML formatting was corrected, and for ease of reading all the material, subtitles were added to it.</i> <br><img src="https://habrastorage.org/web/333/09c/284/33309c284f9f4bafb7fe8177fe3849f6.png"><br>  Kubectl is a tool that is familiar to users of Kubernetes and has extensive functionality.  Mastering them takes time, but allows you to see that this is a more powerful tool than many have assumed.  I present a set of tips to improve your capabilities when working with <code>kubectl</code> .  Do not forget to look at the <a href="https://kubernetes.io/docs/user-guide/kubectl-cheatsheet/">cheat sheet</a> in the official documentation section Kubernetes! <a name="habracut"></a><br><br><h2>  Automatic addition to the shell </h2><br>  <code>kubectl</code> has excellent built-in autocompletion for bash and zsh, which makes it much easier to work with commands, flags, and objects like namespaces and subnames.  The documentation has <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">ready-made instructions</a> for its inclusion.  And the GIF animation below shows how autocompletion works: <br><br><img src="https://habrastorage.org/web/553/c58/dc9/553c58dc947b499e81b80f8bff597205.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        Bash source &lt;(kubectl completion bash) # ‚Ä¶           .bashrc mkdir ~/.kube kubectl completion bash &gt; ~/.kube/completion.bash.inc printf "\n# Kubectl shell completion\nsource '$HOME/.kube/completion.bash.inc'\n" &gt;&gt; $HOME/.bashrc source $HOME/.bashrc #  ‚Äî        Zsh source &lt;(kubectl completion zsh)</span></span></code> </pre> <br><h2>  Merging configs with contexts via <code>KUBECONFIG</code> </h2><br>  Kubernetes configuration merging is a popular pattern if you interact with many Kubernetes clusters.  When working with different configs, the concept of context ( <code>context</code> ) is used, indicating the parameters that <code>kubectl</code> will use to search for a specific, target cluster.  But to achieve the desired result with contexts can be difficult.  To simplify your life, use the <code>KUBECONFIG</code> environment <code>KUBECONFIG</code> - it allows you to point to the configuration files that are used during the merge.  More information about <code>KUBECONFIG</code> can be found in the <a href="https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/">official documentation</a> . <br><br>  For example, you have two Kubernetes config for different clusters, and you need to merge them. <br><br>  Config of the first cluster: <br><br><pre> <code class="bash hljs">$ kubectl config view --minify &gt; cluster1-config</code> </pre> <br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: cluster1_ca.crt server: https://cluster1 name: cluster1 contexts: - context: cluster: cluster1 user: cluster1 name: cluster1 current-context: cluster1 kind: Config preferences: {} users: - name: cluster1 user: client-certificate: cluster1_apiserver.crt client-key: cluster1_apiserver.key</code> </pre> <br>  Config of the second cluster: <br><br><pre> <code class="bash hljs">$ cat cluster2-config</code> </pre> <br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: cluster2_ca.crt server: https://cluster2 name: cluster2 contexts: - context: cluster: cluster2 user: cluster2 name: cluster2 current-context: cluster2 kind: Config preferences: {} users: - name: cluster2 user: client-certificate: cluster2_apiserver.crt client-key: cluster2_apiserver.key</code> </pre> <br>  They can be merged using <code>KUBECONFIG</code> .  The advantage of this merge will be the ability to dynamically switch between contexts.  A context is a ‚Äúmap‚Äù (map) that includes the descriptions of the cluster and the user, as well as the name by which the configuration can be referenced for cluster authentication and interaction with it.  The <code>--kubeconfig</code> flag allows you to look at the context for each file: <br><br><pre> <code class="bash hljs">$ kubectl --kubeconfig=cluster1-config config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * cluster1 cluster1 cluster1 $ kubectl --kubeconfig=cluster2-config config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * cluster2 cluster2 cluster2</code> </pre> <br>  Each configuration file has a single context, so they do not conflict with each other.  Merging the two files through <code>KUBECONFIG</code> shows both contexts.  To save the current context, create a new empty file with the name <code>cluster-merge</code> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KUBECONFIG=cluster-merge:cluster-config:cluster2-config dcooley@lynx ~ $ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * cluster1 cluster1 cluster1 cluster2 cluster2 cluster2</code> </pre> <br>  The list of files exported from <code>KUBECONFIG</code> is loaded in a strict order.  Therefore, the context that is selected corresponds to the one specified as <code>current-context</code> in the first config.  Changing the context to <code>cluster2</code> shifts the sign of the current ( <code>*</code> ) to this context in the list, and the <code>kubectl</code> begin to apply to this (second) context: <br><br><pre> <code class="bash hljs">$ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * cluster1 cluster1 cluster1 cluster2 cluster2 cluster2 $ kubectl config use-context cluster2 Switched to context <span class="hljs-string"><span class="hljs-string">"cluster2"</span></span>. $ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE cluster1 cluster1 cluster1 * cluster2 cluster2 cluster2 $ cat cluster-merge</code> </pre> <br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: [] contexts: [] current-context: cluster2 kind: Config preferences: {} users: []</code> </pre> <br>  It remains only to maintain the correct value of <code>current-context</code> .  You can use Kubernetes contexts and merge them in different ways.  For example, you can create a context ( <code>cluster1_kube-system</code> ) that will define the namespace ( <code>kube-system</code> ) for all <code>kubectl</code> executable commands: <br><br><pre> <code class="bash hljs">$ kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context cluster1_kube-system --cluster=cluster1 --namespace=kube-system --user=cluster1 Context <span class="hljs-string"><span class="hljs-string">"cluster1_kube-system"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>. $ cat cluster-merge</code> </pre> <br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: [] contexts: - context: cluster: cluster1 namespace: kube-system user: cluster1 name: cluster1_kube-system current-context: cluster2 kind: Config preferences: {} users: []</code> </pre> <br>  New context can be used like this: <br><br><pre> <code class="bash hljs">$ kubectl config use-context cluster1_kube-system Switched to context <span class="hljs-string"><span class="hljs-string">"cluster1_kube-system"</span></span>. $ kubectl get pods NAME READY STATUS RESTARTS AGE default-http-backend-fwx3g 1/1 Running 0 28m kube-addon-manager-cluster 1/1 Running 0 28m kube-dns-268032401-snq3h 3/3 Running 0 28m kubernetes-dashboard-b0thj 1/1 Running 0 28m nginx-ingress-controller-b15xz 1/1 Running 0 28m</code> </pre> <br><h2>  Learning Kubernetes API </h2><br>  To learn more about the features provided by the Kubernetes API, request the <code>swagger.json</code> file: <br><br><pre> <code class="bash hljs">$ kubectl proxy $ curl -O 127.0.0.1:8001/swagger.json</code> </pre> <br>  You can also go to <code>http://localhost:8001/api/</code> and look at the paths available in Kubernetes API. <br><br>  Since <code>swagger.json</code> is a JSON document, you can view it with <code>jq</code> .  The <code>jq</code> utility is a lightweight JSON file handler that allows you to perform comparisons and other operations.  Read more <a href="https://stedolan.github.io/jq/">here</a> . <br><br>  View <code>swagger.json</code> helps to understand the Kubernetes API.  This is a complex API, the functions in which are divided into groups, which complicates its perception: <br><br><pre> <code class="bash hljs">$ cat swagger.json | jq <span class="hljs-string"><span class="hljs-string">'.paths | keys[]'</span></span> <span class="hljs-string"><span class="hljs-string">"/api/"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/configmaps"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/endpoints"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/events"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/namespaces"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/nodes"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/persistentvolumeclaims"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/persistentvolumes"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/pods"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/podtemplates"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/replicationcontrollers"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/resourcequotas"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/secrets"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/serviceaccounts"</span></span> <span class="hljs-string"><span class="hljs-string">"/api/v1/services"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/apps/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/apps/v1beta1/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/apps/v1beta1/statefulsets"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/autoscaling/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/batch/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/certificates.k8s.io/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/daemonsets"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/deployments"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/horizontalpodautoscalers"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/ingresses"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/jobs"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/networkpolicies"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/replicasets"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/extensions/v1beta1/thirdpartyresources"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/policy/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/policy/v1beta1/poddisruptionbudgets"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/rbac.authorization.k8s.io/"</span></span> <span class="hljs-string"><span class="hljs-string">"/apis/storage.k8s.io/"</span></span> <span class="hljs-string"><span class="hljs-string">"/logs/"</span></span> <span class="hljs-string"><span class="hljs-string">"/version/"</span></span></code> </pre> <br>  The following command describes the APIs that are available in the Kubernetes cluster and to which you have access.  The command in the example below is executed under the administrator user.  If you have <a href="https://kubernetes.io/docs/admin/authorization/rbac/">RBAC</a> access control enabled, the output may differ: <br><br><pre> <code class="bash hljs">$ kubectl api-versions apps/v1beta1 authentication.k8s.io/v1beta1 authorization.k8s.io/v1beta1 autoscaling/v1 batch/v1 batch/v2alpha1 certificates.k8s.io/v1alpha1 coreos.com/v1 etcd.coreos.com/v1beta1 extensions/v1beta1 oidc.coreos.com/v1 policy/v1beta1 rbac.authorization.k8s.io/v1alpha1 storage.k8s.io/v1beta1 v1</code> </pre> <br>  The <code>kubectl explain</code> command helps to better understand what different API components do: <br><br><pre> <code class="bash hljs">$ kubectl explain You must specify the <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> of resource to explain. Valid resource types include: * all * certificatesigningrequests (aka <span class="hljs-string"><span class="hljs-string">'csr'</span></span>) * clusters (valid only <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> federation apiservers) * clusterrolebindings * clusterroles * componentstatuses (aka <span class="hljs-string"><span class="hljs-string">'cs'</span></span>) * configmaps (aka <span class="hljs-string"><span class="hljs-string">'cm'</span></span>) * daemonsets (aka <span class="hljs-string"><span class="hljs-string">'ds'</span></span>) * deployments (aka <span class="hljs-string"><span class="hljs-string">'deploy'</span></span>) * endpoints (aka <span class="hljs-string"><span class="hljs-string">'ep'</span></span>) * events (aka <span class="hljs-string"><span class="hljs-string">'ev'</span></span>) * horizontalpodautoscalers (aka <span class="hljs-string"><span class="hljs-string">'hpa'</span></span>) * ingresses (aka <span class="hljs-string"><span class="hljs-string">'ing'</span></span>) * <span class="hljs-built_in"><span class="hljs-built_in">jobs</span></span> * limitranges (aka <span class="hljs-string"><span class="hljs-string">'limits'</span></span>) * namespaces (aka <span class="hljs-string"><span class="hljs-string">'ns'</span></span>) * networkpolicies * nodes (aka <span class="hljs-string"><span class="hljs-string">'no'</span></span>) * persistentvolumeclaims (aka <span class="hljs-string"><span class="hljs-string">'pvc'</span></span>) * persistentvolumes (aka <span class="hljs-string"><span class="hljs-string">'pv'</span></span>) * pods (aka <span class="hljs-string"><span class="hljs-string">'po'</span></span>) * poddisruptionbudgets (aka <span class="hljs-string"><span class="hljs-string">'pdb'</span></span>) * podsecuritypolicies (aka <span class="hljs-string"><span class="hljs-string">'psp'</span></span>) * podtemplates * replicasets (aka <span class="hljs-string"><span class="hljs-string">'rs'</span></span>) * replicationcontrollers (aka <span class="hljs-string"><span class="hljs-string">'rc'</span></span>) * resourcequotas (aka <span class="hljs-string"><span class="hljs-string">'quota'</span></span>) * rolebindings * roles * secrets * serviceaccounts (aka <span class="hljs-string"><span class="hljs-string">'sa'</span></span>) * services (aka <span class="hljs-string"><span class="hljs-string">'svc'</span></span>) * statefulsets * storageclasses * thirdpartyresources error: Required resource not specified. See <span class="hljs-string"><span class="hljs-string">'kubectl explain -h'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> and examples.</code> </pre> <br>  Try <code>kubectl explain deploy</code> .  The <code>explain</code> command works with different levels of nesting, which allows you to also refer to dependent objects: <br><br><pre> <code class="bash hljs">$ kubectl explain deploy.spec.template.spec.containers.livenessProbe.exec RESOURCE: <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> &lt;Object&gt; DESCRIPTION: One and only one of the following should be specified. Exec specifies the action to take. ExecAction describes a <span class="hljs-string"><span class="hljs-string">"run in container"</span></span> action. FIELDS: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> &lt;[]string&gt; Command is the <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> line to execute inside the container, the working directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> is root (<span class="hljs-string"><span class="hljs-string">'/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the container<span class="hljs-string"><span class="hljs-string">'s filesystem. The command is simply exec'</span></span>d, it is not run inside a shell, so traditional shell instructions (<span class="hljs-string"><span class="hljs-string">'|'</span></span>, etc) won<span class="hljs-string"><span class="hljs-string">'t work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.</span></span></code> </pre> <br><h2>  Operations with hems through <code>kubectl</code> </h2><br>  All the following examples use the Kubernetes API to learn something about the subframes.  One of the ways to get the necessary data is to build a query and understand what its expression will be needed in terms of <code>jsonpath</code> .  For example, you can run <code>kubectl get pods --all-namespaces -o json</code> to see all the output, from which we can then filter the necessary data for an example with sorting pods by time (see below). <br><br>  If you do not have an application running, to familiarize yourself with the examples, you can create pods with the run = shop label and run them as a service on port 80: <br><br><pre> <code class="bash hljs">$ kubectl run shop --replicas=2 --image quay.io/coreos/example-app:v1.0 --port 80 --expose</code> </pre> <br>  Now you can see what we will do with <code>jsonpath</code> .  More information on it can be obtained from the <a href="https://kubernetes.io/docs/user-guide/jsonpath/">official documentation</a> . <br><br><h4>  Filtering the Kubernetes pods by the time they were created </h4><br><pre> <code class="bash hljs">$ kubectl get pods --all-namespaces --sort-by=<span class="hljs-string"><span class="hljs-string">'.metadata.creationTimestamp'</span></span> -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{range .items[*]}{.metadata.name}, {.metadata.creationTimestamp}{"\n"}{end}'</span></span></code> </pre> <br><h4>  Search for Kubernetes pod by label selector and view its logs </h4><br>  Specify the namespace ( <code>your-namespace</code> ) and your request for the presence of a label that will help you find the right pitches, and get the logs of these pitches.  If under not the only one, logs will be obtained from all the pods in parallel: <br><br><pre> <code class="bash hljs">$ ns=<span class="hljs-string"><span class="hljs-string">'&lt;your-namespace&gt;'</span></span> label=<span class="hljs-string"><span class="hljs-string">'&lt;yourkey&gt;=&lt;yourvalue&gt;'</span></span> kubectl get pods -n <span class="hljs-variable"><span class="hljs-variable">$ns</span></span> -l <span class="hljs-variable"><span class="hljs-variable">$label</span></span> -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{range .items[*]}{.metadata.name}{"\n"}{end}'</span></span> | xargs -I {} kubectl -n <span class="hljs-variable"><span class="hljs-variable">$ns</span></span> logs {}</code> </pre> <br><h4>  Search for Kubernetes pod by label selector and connect to it </h4><br>  Specify the namespace ( <code>your-namespace</code> ) and your request for the presence of a label that will help you find the necessary pitches, and connect to it by name (to the first of the found tabs).  Replace the <code>8080</code> for the desired hearth port: <br><br><pre> <code class="bash hljs">$ ns=<span class="hljs-string"><span class="hljs-string">'&lt;your-namespace&gt;'</span></span> label=<span class="hljs-string"><span class="hljs-string">'&lt;yourkey&gt;=&lt;yourvalue&gt;'</span></span> kubectl -n <span class="hljs-variable"><span class="hljs-variable">$ns</span></span> get pod -l <span class="hljs-variable"><span class="hljs-variable">$label</span></span> -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[1].metadata.name}'</span></span> | xargs -I{} kubectl -n <span class="hljs-variable"><span class="hljs-variable">$ns</span></span> port-forward {} 8080:80</code> </pre> <br><h2>  Operations with nodes (nodes) via <code>kubectl</code> </h2><br>  The combination of <code>jq</code> and <code>jq</code> output <code>kubectl</code> allows you to make complex queries, such as filtering all resources by the time they are created. <br><br><h4>  Counting the number of pods in the Kubernetes node </h4><br>  Often, high-level statistics help in debugging.  This command will calculate the number of all pods on each of the nodes: <br><br><pre> <code class="bash hljs">$ kubectl get pods --all-namespaces -o json | jq <span class="hljs-string"><span class="hljs-string">'.items[] | .spec.nodeName'</span></span> -r | sort | uniq -c</code> </pre> <br><h4>  Filtering Nodes by Label </h4><br>  Label queries can also be used for nodes.  This approach is often used for <i>deployments</i> that require certain restrictions.  For more information about selectors, see the output of <code>kubectl explain deployment.spec.selector</code> . <br><br><pre> <code class="bash hljs">$ kubectl get nodes -l <span class="hljs-string"><span class="hljs-string">'master'</span></span> or kubectl get nodes -l <span class="hljs-string"><span class="hljs-string">'!master'</span></span></code> </pre> <br>  You can display all labels using the <code>--show-labels</code> argument for any Kubernetes object: <br><br><pre> <code class="bash hljs">$ kubectl get nodes --all-namespaces --show-labels</code> </pre> <br><h4>  List of all pods for each node </h4><br>  A JSON document is generated with the name of the Kubernetes node and a list of all the titles of the pods running on this node.  Very useful debugging command: <br><br><pre> <code class="bash hljs">$ kubectl get pods --all-namespaces -o json | jq <span class="hljs-string"><span class="hljs-string">'.items | map({podName: .metadata.name, nodeName: .spec.nodeName}) | group_by(.nodeName) | map({nodeName: .[0].nodeName, pods: map(.podName)})'</span></span></code> </pre> <br><h4>  Getting external IP for Kubernetes nodes </h4><br><pre> <code class="bash hljs">$ kubectl get nodes -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{range .items[*]}{.metadata.name} {.status.addresses[?(@.type=="ExternalIP")].address}{"\n"}{end}'</span></span></code> </pre> <br>  <i><b>Note</b> : Read in our blog a translation of another article from CoreOS about working with Kubernetes from the console: ‚Äú <a href="https://habrahabr.ru/company/flant/blog/328648/">Automating SSH access to Kubernetes nodes using Fabric and integration from CoreOS</a> ‚Äù, as well as the note ‚Äú <a href="https://habrahabr.ru/company/flant/blog/330198/">Useful utilities when working with Kubernetes</a> ‚Äù (it contains mostly console tools).</i> <br><br><h2>  Sources </h2><br><ul><li>  <a href="https://coreos.com/blog/kubectl-tips-and-tricks">Kubernetes kubectl Tips and Tricks</a> (Duffie Cooley from CoreOS, May 15, 2017) </li><li>  <a href="https://coreos.com/blog/kubectl-unix-pipes">Kubectl Unix Pipes: Manage Multiple Clusters With Ease</a> (Duffie Cooley from CoreOS, June 8, 2017) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/333956/">https://habr.com/ru/post/333956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333938/index.html">The digest of interesting materials for the mobile # 213 developer (July 17 - 23)</a></li>
<li><a href="../333942/index.html">Using VK Streaming API with Telegram Alert</a></li>
<li><a href="../333948/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ272 (July 17 - 23, 2017)</a></li>
<li><a href="../333950/index.html">Creating stones for games using photogrammetry</a></li>
<li><a href="../333952/index.html">BB84 Quantum Key Distribution Protocol</a></li>
<li><a href="../333958/index.html">Routing incoming calls to 3CX depending on the time of day</a></li>
<li><a href="../333962/index.html">‚ÄúKnow yourself‚Äù: social media mining-projects at ITMO University</a></li>
<li><a href="../333966/index.html">When in Russia to wait for 5G</a></li>
<li><a href="../333970/index.html">Choosing the right HPE Aruba switch for your small or medium business network</a></li>
<li><a href="../333972/index.html">How and why to hide phone numbers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>