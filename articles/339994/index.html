<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flowers, fly and well rehearsed random machine learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous series, I tried to make a reasonable creature out of a fly. In short - did not work. Mucha stubbornly did not want to learn. 



 The ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flowers, fly and well rehearsed random machine learning</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/post/338548/">previous series,</a> I tried to make a reasonable creature out of a fly.  In short - did not work.  Mucha stubbornly did not want to learn. <br><br><img src="https://habrastorage.org/webt/59/e1/fd/59e1fdc3c6ee1309755052.jpeg"><br><br>  The fly was a small simple neural network based on matrix multiplication, sigmoid, and back propagation of the error.  Her teaching was to recognize photos with flowers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let me remind you that inside there are two networks - the first analyzes the pieces of the original image, and the second works with the matrix composed of the results of the first grid. <br><br>  Training took place somehow, there was no result.  Then, having abandoned attempts at training for valid reasons (such as Saturday evening, Sunday night and morning), I still wondered what to do next.  Some possible solutions were outlined at the end of the first article, and continued with them. <br><a name="habracut"></a><br><h2>  Option 1. Another intermediate layer </h2><br>  It was assumed that if you add neurons to a fly, the fly will become a little smarter.  Adding a layer is easy ‚Äî instead of <br><br><pre><code class="python hljs">nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape])</code> </pre> <br>  write <br><br><pre> <code class="python hljs">nn2 = NN([middleShape, (<span class="hljs-number"><span class="hljs-number">40</span></span>, middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">40</span></span>), y.shape])</code> </pre> <br>  The layer was added, the process of learning and calculation became noticeably slower, but not better.  In fact, the result has not changed at all, therefore I do not cite here. <br><br><h2>  Option 2. Use the approach to success as a blank </h2><br>  The idea was to memorize the weights of the synapses of the most successful learning result, and train the network with these weights, and not score with random values, as usual. <br><br>  The synapses in my grid are the contents of the nn.net.syns and nn2.syns attributes for the first and second grids, respectively.  The result was estimated by the number of mistakes made, i.e.  the number of misclassified photographs for the entire sample, including both flowers and non-flowers. <br><br><pre> <code class="python hljs"> minFails = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> lastSyns = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">100</span></span>): nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape]) <span class="hljs-comment"><span class="hljs-comment">#   for f in fl: i = readImage(f, imageSize) nn.learn(i, yy, 2) mid = nn.calc(i) nn2.learn(mid, y, 1000) nextSyns=None fails = 0 failFiles = [] #    for f in all: i = readImage(f, imageSize) mid = nn.calc(i) res = nn2.calc(mid) delta = (y-res) v = round(np.std(delta),3) if v &gt; 0.2 and f in fl: #  -    - fails += 1 failFiles.append(f) elif v&lt;0.2 and f in nofl: #  - -    fails +=1 failFiles.append(f)</span></span></code> </pre><br>  When errors become less, then the current state of the grid is fixed, transferred to initialization: <br><br><pre> <code class="python hljs"> nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (lastSyns <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): nn.net.syns = lastSyns nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape]) <span class="hljs-comment"><span class="hljs-comment">#   #    if minFails == None or fails &lt; minFails: minFails = fails lastSyns = nn.net.syns</span></span></code> </pre><br>  Check <br><br><div class="spoiler">  <b class="spoiler_title">Best score: 4 errors on attempt 25</b> <div class="spoiler_text"> <code>Epoch = 25 <br> flowers\178.jpg res = [[ 0.64 0.89 0.65 0.87]] v = 0.619 <br> flowers\179.jpg res = [[ 0.91 0.2 0.96 0.15]] v = 0.12 <br> flowers\180.jpg res = [[ 0.95 0.1 0.95 0.1 ]] v = 0.074 <br> flowers\182.jpg res = [[ 1. 0. 1. 0.]] v = 0.0 <br> flowers\186-2.jpg res = [[ 0.98 0.05 0.98 0.04]] v = 0.032 <br> flowers\186.jpg res = [[ 0.99 0.01 0.99 0.01]] v = 0.01 <br> flowers\187.jpg res = [[ 0.83 0.48 0.81 0.5 ]] v = 0.335 <br> flowers\190 (2).jpg res = [[ 1. 0. 1. 0.]] v = 0.001 <br> flowers\190.jpg res = [[ 0.96 0.06 0.96 0.05]] v = 0.045 <br> flowers\191.jpg res = [[ 0.97 0.01 0.96 0.01]] v = 0.022 <br> flowers\195.jpg res = [[ 1. 0. 1. 0.]] v = 0.004 <br> flowers\199.jpg res = [[ 0.91 0.16 0.9 0.16]] v = 0.127 <br> flowers\2.jpg res = [[ 0.99 0.01 0.99 0.01]] v = 0.009 <br> flowers\200.jpg res = [[ 0.99 0.01 1. 0.01]] v = 0.009 <br> noflowers\032.jpg res = [[ 0.71 0.73 0.79 0.73]] v = 0.49 <br> noflowers\085.jpg res = [[ 0.87 0.29 0.85 0.32]] v = 0.222 <br> noflowers\088.jpg res = [[ 0.92 0.22 0.94 0.24]] v = 0.15 <br> noflowers\122.JPG res = [[ 0.72 0.68 0.73 0.68]] v = 0.479 <br> noflowers\123.jpg res = [[ 0.74 0.54 0.69 0.6 ]] v = 0.427 <br> noflowers\173.jpg res = [[ 0.43 0.9 0.57 0.9 ]] v = 0.702 <br> noflowers\202.jpg res = [[ 0.99 0. 0.98 0. ]] v = 0.008 <br> noflowers\205.jpg res = [[ 0.34 0.92 0.57 0.81]] v = 0.711 <br> noflowers\cutxml.jpg res = [[ 0.79 0.41 0.79 0.41]] v = 0.309 <br> noflowers\Getaway.jpg res = [[ 0.75 0.65 0.76 0.65]] v = 0.449 <br> noflowers\IMGP1800.JPG res = [[ 0.81 0.55 0.81 0.55]] v = 0.367 <br> noflowers\trq-4.png res = [[ 0.52 0.81 0.54 0.83]] v = 0.644 <br> dy = 1.407 dn = 4.958 <br> fails = 4 ['flowers\\178.jpg', 'flowers\\187.jpg', 'noflowers\\088.jpg', 'noflowers\\202.jpg'] <br> min = 4</code> <br> </div></div><br>  The network has not learned anything again.  What a stupid fly! <br><br>  Although in fact the network still learned something.  If you look at the rejected pictures, you can see that the network has attributed to the flowers a beaten red car strewn with yellow leaves.  With some imagination, it can really be mistaken for a flower. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e1/ed/59e1ed053846c898619163.jpeg"></div><br><br><h2>  Option 3. And what are they just learning there? </h2><br>  The next point of impact was the goal of learning the first network.  The fact is that the accumulated error at the inputs of the second network cannot be transmitted through the outputs of the first one.  Well, how not to convey ... you can transfer, but it is still necessary to program.  And I was too lazy and began to train the first network on a single matrix: <br><br><pre> <code class="python hljs"> yy = np.zeros(middleShape) np.fill_diagonal(yy,<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  \ begin {bmatrix} <br>  1 &amp; 0 &amp; \ cdots &amp; 0 \\ <br>  0 &amp; 1 &amp; \ cdots &amp; 0 \\ <br>  \ cdots &amp; \ cdots &amp; \ cdots &amp; \ cdots \\ <br>  0 &amp; 0 &amp; \ cdots &amp; 1 <br>  \ end {bmatrix} <br>  It looks somewhat artificial, apparently, and interferes with learning.  But what should be the result matrix, I did not know.  Games with synapse copying made me think that a good learning matrix would be nice <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mi>y</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.311ex" height="1.817ex" viewBox="0 -520.7 995 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/339994/&amp;xid=25657,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgamUFc3TDF8dDKLoAAJ37yQmgw1g#MJMATHI-79" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/339994/&amp;xid=25657,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgamUFc3TDF8dDKLoAAJ37yQmgw1g#MJMATHI-79" x="497" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi><mi>y</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> yy </script>  also copy from a successful attempt, so gradually approaching the best result. <br><br>  However, there was a problem - I did not have <i>one</i> sample.  I train the first network on a single matrix, giving various pictures to the input.  For each of them gives a certain matrix of values ‚Äã‚Äãat the output.  Which of the resulting matrices should I take as a sample? <br><br>  Knowing that ‚Äúreal heroes always go around‚Äù, I simply did not do that, but took that same matrix for the sample.  But only added to it a small random error.  And, if the cycle was successful, i.e.  we reach the next minimum of errors, the last sample will be the next target result. <br><br><pre> <code class="python hljs"> yy = np.zeros(middleShape) np.fill_diagonal(yy,<span class="hljs-number"><span class="hljs-number">1</span></span>) minFails = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> lastYY = yy nextYY = yy ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">100</span></span>): ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fl: i = readImage(f, imageSize) nn.learn(i, nextYY, <span class="hljs-number"><span class="hljs-number">2</span></span>) mid = nn.calc(i) nn2.learn(mid, y, <span class="hljs-number"><span class="hljs-number">1000</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all: i = readImage(f, imageSize) mid = nn.calc(i) res = nn2.calc(mid) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> minFails == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fails &lt; minFails: minFails = fails lastYY = nextYY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: nextYY = lastYY +(np.random.random(yy.shape)<span class="hljs-number"><span class="hljs-number">-0.5</span></span>)/<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><br>  Probably, if I were a mathematician, I would hardly have used chance as a teaching tool.  The mathematician would build a theory according to which learning inevitably leads to the expected result through <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/339994/&amp;xid=25657,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgamUFc3TDF8dDKLoAAJ37yQmgw1g#MJMATHI-4E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> N </script>  moves, you only need to calculate the integral over a curvilinear surface in a multidimensional space and take from it the derivative <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/339994/&amp;xid=25657,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgamUFc3TDF8dDKLoAAJ37yQmgw1g#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> x </script>  .  But I am not a mathematician and I can only rely on my non-mathematical expectation that there is a solution somewhere and it is near. <br><br><div class="spoiler">  <b class="spoiler_title">Best score: 4 errors on attempt 79</b> <div class="spoiler_text"> <code>Epoch = 79 <br> flowers\178.jpg res = [[ 0.5 0.13 0.52 0.12]] v = 0.309 <br> flowers\179.jpg res = [[ 0.74 0.06 0.75 0.06]] v = 0.16 <br> flowers\180.jpg res = [[ 0.76 0.07 0.75 0.07]] v = 0.155 <br> flowers\182.jpg res = [[ 0.95 0.03 0.94 0.03]] v = 0.044 <br> flowers\186-2.jpg res = [[ 0.7 0.1 0.71 0.09]] v = 0.193 <br> flowers\186.jpg res = [[ 0.61 0.22 0.6 0.2 ]] v = 0.303 <br> flowers\187.jpg res = [[ 0.45 0.13 0.45 0.13]] v = 0.341 <br> flowers\190 (2).jpg res = [[ 0.84 0. 0.67 0.01]] v = 0.14 <br> flowers\190.jpg res = [[ 0.96 0.06 0.94 0.08]] v = 0.061 <br> flowers\191.jpg res = [[ 0.73 0.13 0.72 0.1 ]] v = 0.194 <br> flowers\195.jpg res = [[ 0.85 0.03 0.88 0.03]] v = 0.08 <br> flowers\199.jpg res = [[ 0.83 0.05 0.84 0.04]] v = 0.102 <br> flowers\2.jpg res = [[ 0.81 0.06 0.81 0.06]] v = 0.125 <br> flowers\200.jpg res = [[ 0.92 0.05 0.93 0.04]] v = 0.057 <br> noflowers\032.jpg res = [[ 0.27 0.12 0.3 0.1 ]] v = 0.416 <br> noflowers\085.jpg res = [[ 0.41 0.14 0.41 0.14]] v = 0.365 <br> noflowers\088.jpg res = [[ 0.37 0.15 0.32 0.15]] v = 0.402 <br> noflowers\122.JPG res = [[ 0.4 0.15 0.4 0.14]] v = 0.373 <br> noflowers\123.jpg res = [[ 0.35 0.14 0.33 0.15]] v = 0.401 <br> noflowers\173.jpg res = [[ 0.33 0.17 0.34 0.17]] v = 0.418 <br> noflowers\202.jpg res = [[ 0.44 0.14 0.45 0.12]] v = 0.342 <br> noflowers\205.jpg res = [[ 0.63 0.06 0.74 0.07]] v = 0.192 <br> noflowers\cutxml.jpg res = [[ 0.52 0.13 0.45 0.13]] v = 0.323 <br> noflowers\Getaway.jpg res = [[ 0.38 0.15 0.38 0.15]] v = 0.386 <br> noflowers\IMGP1800.JPG res = [[ 0.4 0.15 0.4 0.14]] v = 0.371 <br> noflowers\trq-4.png res = [[ 0.19 0.21 0.17 0.28]] v = 0.533 <br> dy = 2.264 dn = 4.522 <br> fails = 4 ['flowers\\178.jpg', 'flowers\\186.jpg', 'flowers\\187.jpg', 'noflowers\\205.jpg'] <br> min = 4</code> <br> </div></div><br>  Here, the network found that the white connector also looks quite like a flower. <br><br><img src="https://habrastorage.org/webt/59/e1/ff/59e1ff69a9d84922189672.jpeg"><br><br>  In general, this connector is considered to be a flower in almost any variant.  Well, this is understandable, they do not give her a sniff. <br><br><h2>  Option 4. And let's combine our brands </h2><br>  The previous versions showed approximately the same results.  By this time I had time to think whether I was doing it at all, and whether I want too much from an unfortunate fly.  But did not stop there. <br><br>  The next option was to use the previous two at the same time - when successful attempts are made to memorize the values ‚Äã‚Äãof synapses <b>And the</b> goal of learning the first matrix <b>AND to</b> use randomness to expand the search. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">100</span></span>): print(<span class="hljs-string"><span class="hljs-string">'Epoch ='</span></span>, epoch) nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (lastSyns <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): nextSyns = lastSyns <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(nextSyns)): rand = (np.random.random(nextSyns[r].shape)<span class="hljs-number"><span class="hljs-number">-0.5</span></span>)/<span class="hljs-number"><span class="hljs-number">20</span></span> nextSyns[r] = nextSyns[r] + rand nn.net.syns = nextSyns nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fl: i = readImage(f, imageSize) nn.learn(i, nextYY, <span class="hljs-number"><span class="hljs-number">2</span></span>) mid = nn.calc(i) nn2.learn(mid, y, <span class="hljs-number"><span class="hljs-number">1000</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> minFails == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fails &lt; minFails: minFails = fails lastSyns = nn.net.syns lastYY = nextYY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: nextYY = lastYY +(np.random.random(yy.shape)<span class="hljs-number"><span class="hljs-number">-0.5</span></span>)/<span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Best score: 2 errors on attempt 38</b> <div class="spoiler_text"> <code>Epoch = 38 <br> flowers\178.jpg res = [[ 0.91 0.26 0.91 0.25]] v = 0.174 <br> flowers\179.jpg res = [[ 0.99 0. 0.99 0. ]] v = 0.005 <br> flowers\180.jpg res = [[ 0.9 0.21 0.89 0.2 ]] v = 0.153 <br> flowers\182.jpg res = [[ 1. 0. 1. 0.]] v = 0.0 <br> flowers\186-2.jpg res = [[ 1. 0.01 0.99 0.01]] v = 0.008 <br> flowers\186.jpg res = [[ 0.91 0.12 0.93 0.07]] v = 0.09 <br> flowers\187.jpg res = [[ 0.83 0.43 0.83 0.44]] v = 0.303 <br> flowers\190 (2).jpg res = [[ 1. 0. 1. 0.]] v = 0.0 <br> flowers\190.jpg res = [[ 1. 0. 1. 0.]] v = 0.001 <br> flowers\191.jpg res = [[ 1. 0. 1. 0.]] v = 0.0 <br> flowers\195.jpg res = [[ 0.99 0. 1. 0. ]] v = 0.004 <br> flowers\199.jpg res = [[ 0.97 0.03 0.98 0.03]] v = 0.029 <br> flowers\2.jpg res = [[ 1. 0. 1. 0.]] v = 0.003 <br> flowers\200.jpg res = [[ 1. 0. 1. 0.]] v = 0.0 <br> noflowers\032.jpg res = [[ 0.88 0.55 0.8 0.67]] v = 0.389 <br> noflowers\085.jpg res = [[ 0.25 0.96 0.27 0.96]] v = 0.848 <br> noflowers\088.jpg res = [[ 0.84 0.42 0.79 0.37]] v = 0.29 <br> noflowers\122.JPG res = [[ 0.68 0.66 0.69 0.66]] v = 0.49 <br> noflowers\123.jpg res = [[ 0.74 0.63 0.71 0.6 ]] v = 0.445 <br> noflowers\173.jpg res = [[ 0.86 0.46 0.76 0.52]] v = 0.343 <br> noflowers\202.jpg res = [[ 0.22 0.92 0.44 0.95]] v = 0.808 <br> noflowers\205.jpg res = [[ 0.8 0.82 0.71 0.88]] v = 0.547 <br> noflowers\cutxml.jpg res = [[ 0.99 0.03 0.97 0.02]] v = 0.022 <br> noflowers\Getaway.jpg res = [[ 0.7 0.65 0.7 0.65]] v = 0.474 <br> noflowers\IMGP1800.JPG res = [[ 0.79 0.5 0.77 0.5 ]] v = 0.36 <br> noflowers\trq-4.png res = [[ 0.77 0.21 0.69 0.07]] v = 0.215 <br> dy = 0.77 dn = 5.231 <br> fails = 2 ['flowers\\187.jpg', 'noflowers\\cutxml.jpg'] <br> min = 2</code> <br> </div></div><br>  2 errors on 28 files = 7% I considered to be a fairly good result, which can not be improved. <br><br><h2>  Run the final photos and conclusions </h2><br>  At the end of the process, I saved the trained grid, or rather the values ‚Äã‚Äãof its synapses for better results, in text files: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(lastSyns)): np.savetxt(<span class="hljs-string"><span class="hljs-string">'syns_save%s.txt'</span></span>%i, lastSyns[i]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(lastSyns2)): np.savetxt(<span class="hljs-string"><span class="hljs-string">'syns2_save%s.txt'</span></span>%i, lastSyns2[i])</code> </pre><br>  Then he drove the network from photographs: <br><br><pre> <code class="python hljs"> StartLearn = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> StartLearn: pictDir = <span class="hljs-string"><span class="hljs-string">'C:\\AllPictures'</span></span> nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) nn.net.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns_save0.txt'</span></span>,ndmin=nn.net.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>].ndim) nn.net.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns_save1.txt'</span></span>,ndmin=nn.net.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>].ndim) nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape]) nn2.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns2_save0.txt'</span></span>,ndmin=nn2.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>].ndim) nn2.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns2_save1.txt'</span></span>,ndmin=nn2.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>].ndim) files = [e.path <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.scandir(pictDir)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: i = readImage(f, imageSize) mid = nn.calc(i) res = nn2.calc(mid) delta = y-res v = round(np.std(delta),<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v &lt;= <span class="hljs-number"><span class="hljs-number">0.3</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Flower'</span></span>,f,v) <span class="hljs-comment"><span class="hljs-comment">## else: ## print('No flower',f, v)</span></span></code> </pre><br>  In general, do not say that she found only flowers.  There were cats, crabs, fireworks, just rocks and groups of people.  And the colors among my photos were just not enough. <br><br>  It can be concluded that, in principle, the network works, just the task for it turned out to be too complicated.  If you look at <a href="http://www.image-net.org/synset%3Fwnid%3Dn11669921">ImageNet</a> , as <a href="https://habrahabr.ru/users/dark_daiver/" class="user_link">Dark_Daiver</a> advised <a href="https://habrahabr.ru/users/dark_daiver/" class="user_link">me</a> in the comment to the previous article, then the colors are too wide to be able to distinguish them with such a simple network. <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nnmat <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PyQt5.QtGui <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PyQt5.QtCore <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> meshandler <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImgNN</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, shape, resultShape = </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">, </span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, imageSize = </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">400</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">400</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.resultShape = resultShape self.w = imageSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] // shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.h = imageSize[<span class="hljs-number"><span class="hljs-number">1</span></span>] // shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] self.net = NN([shape, (<span class="hljs-number"><span class="hljs-number">1</span></span>,shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)]) self.shape = shape self.imageSize = imageSize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">learn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, srcArr, result, cycles)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(cycles): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.w): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.h): a = srcArr[x:x+self.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], y:y+self.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a.shape != (self.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], self.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]): print(a.shape) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> self.net.learn(a, result[x,y], <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, srcArr)</span></span></span><span class="hljs-function">:</span></span> resArr = np.zeros(self.resultShape) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.w): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.h): a = srcArr[x:x+self.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], y:y+self.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a.shape != (self.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], self.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt;= self.resultShape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> y &gt;= self.resultShape[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> res = self.net.calc(a) resArr[x,y] = res[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resArr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">learnFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, file, result, cycles)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.learn(readImage(file, self.imageSize), result, cycles) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, file)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.calc(readImage(file, self.imageSize)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readImageCV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file, imageSize)</span></span></span><span class="hljs-function">:</span></span> img = cv2.imread(file) small = cv2.resize(img, imageSize) hsv = cv2.cvtColor(small, cv2.COLOR_BGR2HSV) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hsv[:,:,<span class="hljs-number"><span class="hljs-number">0</span></span>]/<span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readImageQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file, imageSize)</span></span></span><span class="hljs-function">:</span></span> img = QImage(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> img.isNull(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> img = img.convertToFormat(QImage.Format_Grayscale8) img = img.scaled(imageSize[<span class="hljs-number"><span class="hljs-number">0</span></span>],imageSize[<span class="hljs-number"><span class="hljs-number">1</span></span>],Qt.IgnoreAspectRatio) srcBi = img.bits() srcBi.setsize(img.width() * img.height()) srcBy = bytes(srcBi) srcW, srcH = img.width(), img.height() srcArr = np.recarray((srcH, srcW), dtype=np.uint8, buf=srcBy).view(dtype=np.uint8,type=np.ndarray) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srcArr/<span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readImageCVQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file, imageSize)</span></span></span><span class="hljs-function">:</span></span> img = QImage(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> img.isNull(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> img = img.convertToFormat(QImage.Format_RGB888) img = img.scaled(imageSize[<span class="hljs-number"><span class="hljs-number">0</span></span>],imageSize[<span class="hljs-number"><span class="hljs-number">1</span></span>],Qt.IgnoreAspectRatio) srcBi = img.bits() srcBi.setsize(img.byteCount()) srcBy = bytes(srcBi) srcW, srcH = img.width(), img.height() bp = img.depth() // <span class="hljs-number"><span class="hljs-number">8</span></span> srcArr = np.recarray((srcH, srcW, bp), dtype=np.uint8, buf=srcBy) srcArr = srcArr.view(dtype=np.uint8,type=np.ndarray) hsv = cv2.cvtColor(srcArr, cv2.COLOR_RGB2HSV) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hsv[:,:,<span class="hljs-number"><span class="hljs-number">0</span></span>]/<span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: readImage = readImageCVQ y = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]]) firstShape = (<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) middleShape = (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) imageSize = firstShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]*middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>], firstShape[<span class="hljs-number"><span class="hljs-number">1</span></span>]*middleShape[<span class="hljs-number"><span class="hljs-number">1</span></span>] StartLearn = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> StartLearn: pictDir = <span class="hljs-string"><span class="hljs-string">'C:\\AllPictures'</span></span> nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) nn.net.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns_save0.txt'</span></span>,ndmin=nn.net.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>].ndim) nn.net.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns_save1.txt'</span></span>,ndmin=nn.net.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>].ndim) nn2 = NN([middleShape, (y.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], middleShape[<span class="hljs-number"><span class="hljs-number">0</span></span>]), y.shape]) nn2.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns2_save0.txt'</span></span>,ndmin=nn2.syns[<span class="hljs-number"><span class="hljs-number">0</span></span>].ndim) nn2.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>] = np.loadtxt(<span class="hljs-string"><span class="hljs-string">'syns2_save1.txt'</span></span>,ndmin=nn2.syns[<span class="hljs-number"><span class="hljs-number">1</span></span>].ndim) files = [e.path <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.scandir(pictDir)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: i = readImage(f, imageSize) mid = nn.calc(i) res = nn2.calc(mid) delta = y-res v = round(np.std(delta),<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v &lt;= <span class="hljs-number"><span class="hljs-number">0.3</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Flower'</span></span>,f,v) <span class="hljs-comment"><span class="hljs-comment">## else: ## print('No flower',f, v) else: fl = [e.path for e in os.scandir('flowers')] nofl = [e.path for e in os.scandir('noflowers')] all = fl+nofl yy = np.zeros(middleShape) np.fill_diagonal(yy,1) minFails = None lastSyns = None nextSyns = None lastSyns2 = None lastYY = yy nextYY = yy minDy = None maxDn = None for epoch in range(100): print('Epoch =', epoch) nn = ImgNN(firstShape, resultShape=middleShape, imageSize=imageSize) if not (lastSyns is None): nextSyns = lastSyns for r in range(len(nextSyns)): rand = (np.random.random(nextSyns[r].shape)-0.5)/20 nextSyns[r] = nextSyns[r] + rand nn.net.syns = nextSyns nn2 = NN([middleShape, (y.shape[1], middleShape[0]), y.shape]) for f in fl: i = readImage(f, imageSize) nn.learn(i, nextYY, 2) ## nn.learn(i, yy, 2) mid = nn.calc(i) nn2.learn(mid, y, 1000) nextSyns=None fails = 0 failFiles = [] dy = 0.0 dn = 0.0 for f in all: i = readImage(f, imageSize) mid = nn.calc(i) res = nn2.calc(mid) delta = (y-res) v = round(np.std(delta),3) #v = round(delta.sum(),3) print(f, 'res = ', res.round(2),'v =',v) if f in fl: dy += v if f in nofl: dn += v if v &gt; 0.2 and f in fl: fails += 1 failFiles.append(f) elif v&lt;0.2 and f in nofl: fails +=1 failFiles.append(f) print('dy =',dy,'dn =',dn) if minDy == None or dy &lt; minDy: minDy = dy if maxDn == None or dn &gt; maxDn: maxDn = dn if minFails == None or fails &lt; minFails: minFails = fails lastSyns = nn.net.syns lastSyns2 = nn2.syns lastYY = nextYY else: nextYY = lastYY +(np.random.random(yy.shape)-0.5)/20 print('fails =',fails, failFiles) print('min =',minFails) if minFails &lt;= 1: print('found!') break for i in range(len(lastSyns)): np.savetxt('syns_save%s.txt'%i, lastSyns[i]) for i in range(len(lastSyns2)): np.savetxt('syns2_save%s.txt'%i, lastSyns2[i])</span></span></code> </pre><br></div></div><br>  The source code is also <a href="https://github.com/sshmakov/flynn">posted on github</a> under the MIT license. <br><br><h2>  Bonus  OpenCV and Russian letters in file paths </h2><br>  In the last article I said that the imread function in OpenCV had a problem with reading files with paths in which Russian letters are found.  There is no such problem with QImage from PyQt, but I needed OpenCV to convert the image to the HSV color space and to highlight the chromaticity plane.  Therefore I combined loading of a picture through QImage and transformation through OpenCV. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readImageCVQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file, imageSize)</span></span></span><span class="hljs-function">:</span></span> img = QImage(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> img.isNull(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> img = img.convertToFormat(QImage.Format_RGB888) img = img.scaled(imageSize[<span class="hljs-number"><span class="hljs-number">0</span></span>],imageSize[<span class="hljs-number"><span class="hljs-number">1</span></span>],Qt.IgnoreAspectRatio) srcBi = img.bits() srcBi.setsize(img.byteCount()) srcBy = bytes(srcBi) srcW, srcH = img.width(), img.height() bp = img.depth() // <span class="hljs-number"><span class="hljs-number">8</span></span> srcArr = np.recarray((srcH, srcW, bp), dtype=np.uint8, buf=srcBy) srcArr = srcArr.view(dtype=np.uint8,type=np.ndarray) hsv = cv2.cvtColor(srcArr, cv2.COLOR_RGB2HSV) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hsv[:,:,<span class="hljs-number"><span class="hljs-number">0</span></span>]/<span class="hljs-number"><span class="hljs-number">255</span></span> ... readImage = readImageCVQ</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/339994/">https://habr.com/ru/post/339994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339984/index.html">Case: endless development of the ultimate flash drive or how not to start a startup. Part 1: from idea to product</a></li>
<li><a href="../339986/index.html">VoIP server for a small company (FreePBX 14, Asterisk 15, Ubuntu 16.04) part 1</a></li>
<li><a href="../339988/index.html">A little bit about VIM and IDE</a></li>
<li><a href="../339990/index.html">Plastic: how not to hurt the team by an engraved statuette</a></li>
<li><a href="../339992/index.html">We enter on ‚ÄúMy Circle‚Äù a search for candidates by ‚ÄúHabrahabra‚Äù users</a></li>
<li><a href="../339996/index.html">Ama. Avito. Backend</a></li>
<li><a href="../339998/index.html">TeaVM - a tool to create a web frontend for Java, Kotlin and Scala</a></li>
<li><a href="../340000/index.html">Evil XML with two encodings</a></li>
<li><a href="../340002/index.html">Introduction to frequently used features of ES6. Part 1</a></li>
<li><a href="../340006/index.html">And how do you create singletons in ruby?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>