<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remove objects dump from .Net application memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the topic of interesting on .Net, from which the Java world will chuckle (although it is also possible for them to do this), and C ++ supp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remove objects dump from .Net application memory</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/221/1ce/295/2211ce2957cf45049d2de3316f9cfb92.gif" align="left">  We continue the topic of interesting on .Net, from which the Java world will chuckle (although it is also possible for them to do this), and C ++ supporters say: ‚Äúwhat will they not do to not learn C ++‚Äù. <br><br>  In this note, we will write in essence - a simple kernel kernel memory profile for the .Net platform that will take a dump from the SOH heap (and in the long run from the LOH). <br><br>  To write an article we need the code from the article. <a href="http://habrahabr.ru/company/luxoft/blog/219619/"><img src="https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/219619/">Getting a pointer to an .Net object</a> and <a href="http://habrahabr.ru/company/luxoft/blog/238947/"><img src="https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/238947/">Manual stream cloning</a> (measuring the size of objects). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our goals for today: <br><ul><li>  Learn to iterate a bunch of .Net </li><li>  Learn to find the beginning of the heap .Net </li><li>  Try to test all objects in a foreign domain. </li></ul><br><br>  Link to the project in GitHub: <a href="https://github.com/mumusan/dotnetex"><img src="https://habrastorage.org/files/979/38e/df1/97938edf1170406c842b0613d0c84ae9.png"></a>  <a href="https://github.com/mumusan/dotnetex">DotNetEx</a> <br><div class="spoiler">  <b class="spoiler_title">To begin with, the full list of articles posted on this cycle in Habr√©</b> <div class="spoiler_text"> <a href="http://habrahabr.ru/company/luxoft/blog/247491/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/247491/">We make shipped assemblies: we interact between domains without marshalling</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/219619/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/219619/">Getting a pointer to a .Net object</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/238947/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/238947/">Manual stream cloning.</a>  <a href="http://habrahabr.ru/company/luxoft/blog/238947/">When Assembler + C # or Java = Love</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/239005/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/239005/">Changing the code of system assemblies or "leak". Net Framework 5.0</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/244095/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/244095/">How does decompilation in .Net or Java using the example .Net</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/247433/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/247433/">Continuing to shred CLR: .Net object pool outside SOH / LOH heaps</a> <br> <a href="http://habrahabr.ru/company/luxoft/blog/247447/"><img src="http://http:https://habrastorage.org/files/7d1/9d7/8ab/7d19d78ab896445fb5573b5f5e807ba0.png"></a>  <a href="http://habrahabr.ru/company/luxoft/blog/247447/">Remove objects dump from .Net application memory</a> <br></div></div><br><a name="habracut"></a><br>  Like last time, we will solve problems as they come: <br><ul><li>  <b>Find the beginning of the heap in .Net</b> <br><br>  As we probably know, there are two kinds of heaps in .Net.  This is a heap for small objects and a heap for large objects (&gt; 85K).  They differ primarily in the organization of objects within themselves.  If in SOH objects are allocated one after another, then in LOH everything is based on linked lists and a table of free intervals between occupied areas.  This is what we know.  But the truth is different.  Firstly, SOH cannot be continuous due to the possibility of stumbling upon a busy portion of virtual memory as it expands.  The second - in fact, the fact that objects are allocated continuously one after the other - is a beautiful assumption, since there are pinned objects that cannot be moved, which means that there will be empty gaps during heap compression.  This means that SOH also contains a table of voids.  And in summary, this should mean specifically for us that: (a) there may be several virtual memory zones in the memory that are allocated for the heap, (b) most likely they are allocated via VirtualAlloc, (c) the objects are not continuous, which means our algorithm can't rely on it. <br><br>  To simplify the example, let's take a dump only from the objects in our heap.  In order to do this, we will take a pointer to any object and, using WinApi, VirtualQuery functions will try to get a virtual memory region that was allocated for this heap. <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetManagedHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr heapsOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr lastHeapByte</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     .      var offset = EntityPtr.ToPointer(new object()); var memoryBasicInformation = new WinApi.MEMORY_BASIC_INFORMATION(); unsafe { WinApi.VirtualQuery(offset, ref memoryBasicInformation, (IntPtr)Marshal.SizeOf(memoryBasicInformation)); heapsOffset = (IntPtr)memoryBasicInformation.AllocationBase; lastHeapByte = (IntPtr)((long)offset + (long)memoryBasicInformation.RegionSize); } }</span></span></code> </pre> <br>  Perfectly!  Now we know the room on which to look for objects. <br></li><li>  <b>We test all objects of another domain</b> <br>  In order to do this, we need to understand how to recognize them.  So if we sit with the debugger and study the memory, then we can finally come to the conclusion that the reference to the object points not to the first field of the object, but to a pointer to a table of virtual methods.  Which in fact is not only a table of virtual methods, but methods in general and type descriptions.  After all, we are not in the C ++ world, but in the .Net world, where one can understand for each object, ‚ÄúWho will you be?‚Äù.  But what about SyncBlockIndex, you ask?  And as it turned out, it is ‚Äúin front of‚Äù the object, minus the word size (4 bytes on 32-bit and 8 - on a 64-bit system).  Because the header structure of any object is as follows: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EntityInfo { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SyncBlockIndex; [FieldOffset(<span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MethodTableInfo *MethodTable; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> RefTypeInfo { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EntityInfo BasicInfo; [FieldOffset(<span class="hljs-number"><span class="hljs-number">8</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> fieldsStart; }</code> </pre><br>  Next, let's see how MethodTableInfo looks like: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MethodTableInfo { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Basic Type Info [FieldOffset(0)] public MethodTableFlags Flags; [FieldOffset(4)] public int Size; [FieldOffset(8)] public short AdditionalFlags; [FieldOffset(10)] public short MethodsCount; [FieldOffset(12)] public short VirtMethodsCount; [FieldOffset(14)] public short InterfacesCount; [FieldOffset(16)] public MethodTableInfo *ParentTable; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> [FieldOffset(20)] public ObjectTypeInfo *ModuleInfo; [FieldOffset(24)] public ObjectTypeInfo *EEClass; }</span></span></code> </pre><br>  Here - only a part of all information from this structure.  In fact, it is more extensive.  The EEClass field is important here, which leads to the structure of the type description.  I practically did not study it.  The content looks like this: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ObjectTypeInfo { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectTypeInfo *ParentClass; [FieldOffset(<span class="hljs-number"><span class="hljs-number">16</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MethodTableInfo *MethodsTable; }</code> </pre><br>  Since only the MethodsTable field is important for us, I just found it.  The rest - missed.  Why do we need it?  This is a backward link to MethodsTable, which with its EEClass field refers here. <br><br>  This is not a tricky way, we found a few not accurate, but a perfectly working method for detecting .Net objects.  It looks like this: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCorrectMethodsTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr mt</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mt == IntPtr.Zero) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PointsToAllocated(mt)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PointsToAllocated((IntPtr) ((MethodTableInfo*) mt)-&gt;EEClass)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PointsToAllocated((IntPtr) ((MethodTableInfo*) mt)-&gt;EEClass-&gt;MethodsTable)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IntPtr) ((MethodTableInfo*) mt)-&gt;EEClass-&gt;MethodsTable == mt) || ((IntPtr) ((MethodTableInfo*) mt)-&gt;ModuleInfo == MscorlibModule); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointsToAllocated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == IntPtr.Zero) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !WinApi.IsBadReadPtr(ptr, <span class="hljs-number"><span class="hljs-number">32</span></span>); }</code> </pre><br>  For each pointer, it is checked whether it points to the allocated memory area.  This is the first barrier.  The second barrier is if the theoretical object has the first field pointing to something that we initially interpret as a MethodsTable.  We check that the EEClass field points to the allocated memory area and interpret this pointer as a pointer to an ObjectTypeInfo structure, and then check if the pointer to MethodsTable is equal to our found pointer (is there a backward link?) If all the rules apply, the object is found. <br><br>  It remains only to go through all the memory areas and try to recognize objects there.  I will not lay out this sheet, because there is also a code for registering what was found and displaying it on the screen.  I can only say that the problem is solved, the output link from the program is below. <br><br>  Link to the complete example code: <a href="">GitHub / DotNetEx / AdvSample</a> <br><div class="spoiler">  <b class="spoiler_title">Output of our program, memory dump</b> <div class="spoiler_text"><pre> <code class="bash hljs">00606 : System.String 00583 : System.Object 00277 : System.RuntimeType 00072 : System.Array+SZArrayEnumerator 00046 : System.Char[] 00041 : System.Int32[] 00033 : System.String[] 00032 : System.Object[] 00030 : System.Version 00029 : System.Byte[] 00024 : System.Text.StringBuilder 00023 : System.Collections.Hashtable+bucket[] 00020 : System.Security.PermissionSet 00020 : System.Collections.Hashtable 00020 : System.Reflection.AssemblyName 00014 : System.Reflection.RuntimeAssembly 00014 : System.Security.Permissions.EnvironmentPermission 00013 : System.Collections.Hashtable+SyncHashtable 00012 : System.Globalization.CompareInfo 00012 : System.Collections.Generic.Dictionary`2+Entry[[System.Type, mscorlib, Ve rsion=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Securit y.Policy.EvidenceTypeDescriptor, mscorlib, Version=4.0.0.0, Culture=neutral, Pub licKeyToken=b77a5c561934e089]][] 00011 : System.Globalization.CultureInfo 00010 : System.Collections.ArrayList 00010 : System.Int32 00010 : System.Threading.ThreadStart 00010 : System.Internal.HandleCollector+HandleType 00010 : System.Internal.HandleCollector+HandleType 00009 : System.Security.Permissions.SecurityPermission 00009 : System.EventHandler 00009 : Microsoft.Win32.SafeHandles.SafeRegistryHandle 00009 : Microsoft.Win32.RegistryKey 00008 : System.Threading.Thread 00008 : Microsoft.Win32.SafeHandles.SafeWaitHandle 00008 : System.Security.Policy.EvidenceTypeDescriptor 00008 : System.Runtime.InteropServices.HandleRef 00008 : System.UInt16 00006 : System.Runtime.Remoting.Metadata.SoapTypeAttribute[] 00005 : System.Type[] 00005 : System.Threading.ReaderWriterLock 00005 : System.Reflection.CustomAttributeRecord[] 00005 : System.Globalization.TextInfo 00005 : System.Security.Permissions.EnvironmentStringExpressionSet 00005 : System.WeakReference 00005 : System.Threading.ThreadHelper 00004 : System.Security.FrameSecurityDescriptor 00004 : System.Reflection.RuntimeModule 00004 : System.Reflection.RuntimeConstructorInfo 00004 : System.Guid 00004 : Microsoft.Win32.SafeHandles.SafePEFileHandle 00004 : System.Security.Policy.Evidence 00004 : System.Collections.Generic.Dictionary`2[[System.Type, mscorlib, Version= 4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Security.Poli cy.EvidenceTypeDescriptor, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKey Token=b77a5c561934e089]] 00004 : System.Security.Policy.AssemblyEvidenceFactory 00004 : System.Security.Policy.Evidence+EvidenceUpgradeLockHolder 00003 : System.Security.Util.TokenBasedSet 00003 : System.Globalization.CultureData 00003 : System.Reflection.MemberFilter 00003 : System.Reflection.MethodBase[] 00003 : System.RuntimeType[] 00003 : System.Runtime.Remoting.Lifetime.LeaseLifeTimeServiceProperty 00003 : System.Attribute[] 00003 : System.Threading.ManualResetEvent 00003 : System.IO.PathHelper 00003 : System.Security.Permissions.UIPermission 00002 : System.AppDomainSetup 00002 : System.Security.PermissionToken 00002 : System.Runtime.Remoting.Contexts.IContextProperty[] 00002 : System.Reflection.TypeFilter 00002 : System.Collections.Queue 00002 : System.WeakReference[] 00002 : System.Char 00002 : System.Security.Policy.StrongName[] 00002 : System.Reflection.RuntimeMethodInfo 00002 : System.Threading.SynchronizationContext 00002 : System.Internal.HandleCollector+HandleType[] 00002 : System.Globalization.NumberFormatInfo 00002 : Microsoft.Win32.SystemEvents+SystemEventInvokeInfo[] 00002 : System.Text.EncoderReplacementFallback 00002 : System.IO.UnmanagedMemoryStream 00002 : System.Security.Permissions.FileIOAccess 00002 : System.Security.Util.StringExpressionSet 00001 : System.Exception 00001 : System.OutOfMemoryException 00001 : System.StackOverflowException 00001 : System.ExecutionEngineException 00001 : System.AppDomain 00001 : System.Security.PermissionTokenFactory 00001 : System.Security.PermissionToken[] 00001 : System.Globalization.CalendarData[] 00001 : System.Globalization.CalendarData 00001 : System.__Filters 00001 : System.DefaultBinder 00001 : System.RuntimeType+RuntimeTypeCache+MemberInfoCache`1[[System.Reflection .RuntimeConstructorInfo, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyTo ken=b77a5c561934e089]] 00001 : System.Reflection.RuntimeConstructorInfo[] 00001 : System.Reflection.ConstructorInfo[] 00001 : System.Collections.Generic.List`1[[System.Reflection.MethodBase, mscorli b, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Signature 00001 : System.Reflection.ParameterInfo[] 00001 : System.Int32[][] 00001 : System.Runtime.Remoting.Proxies.ProxyAttribute 00001 : System.Runtime.Remoting.DomainSpecificRemotingData 00001 : System.Runtime.Remoting.Channels.ChannelServicesData 00001 : System.Runtime.Remoting.Activation.LocalActivator 00001 : System.Runtime.Remoting.Activation.ActivationListener 00001 : System.Runtime.Remoting.Contexts.ContextAttribute[] 00001 : System.Runtime.Remoting.Contexts.Context 00001 : System.Runtime.Remoting.Messaging.ConstructorCallMessage 00001 : System.Runtime.Remoting.Metadata.RemotingTypeCachedData 00001 : System.Collections.Generic.Dictionary`2[[System.RuntimeType, mscorlib, V ersion=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Runtim eType, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e0 89]] 00001 : System.Collections.Generic.Dictionary`2+Entry[[System.RuntimeType, mscor lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System. RuntimeType, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c56 1934e089]][] 00001 : System.AttributeUsageAttribute 00001 : System.Runtime.Remoting.Metadata.SoapTypeAttribute 00001 : System.Runtime.Remoting.Activation.ConstructionLevelActivator 00001 : System.Runtime.Remoting.RemotingConfigHandler+RemotingConfigInfo 00001 : System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Versio n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Globalizati on.CultureData, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5 c561934e089]] 00001 : System.Runtime.Remoting.ObjectHandle 00001 : System.Diagnostics.TraceSwitch 00001 : System.Collections.Generic.Dictionary`2[[System.Int16, mscorlib, Version =4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.IntPtr, msco rlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Collections.Generic.GenericEqualityComparer`1[[System.Int16, msco rlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Collections.Generic.ObjectEqualityComparer`1[[System.IntPtr, msco rlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Threading.Mutex 00001 : System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode 00001 : System.Threading.Mutex+MutexCleanupInfo 00001 : System.Threading.Mutex+MutexTryCodeHelper 00001 : System.Threading.EventWaitHandle 00001 : System.Threading.HostExecutionContextManager 00001 : System.Collections.Generic.ObjectEqualityComparer`1[[System.Type, mscorl ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Security.Policy.ApplicationTrust 00001 : System.Security.Policy.PolicyStatement 00001 : System.Collections.Generic.List`1[[System.Security.Policy.StrongName, ms corlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.SZArrayHelper+SZGenericArrayEnumerator`1[[System.Security.Policy. StrongName, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561 934e089]] 00001 : System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Security.Pol icy.StrongName, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5 c561934e089]] 00001 : Microsoft.Win32.Win32Native+OSVERSIONINFO 00001 : Microsoft.Win32.Win32Native+OSVERSIONINFOEX 00001 : System.OperatingSystem 00001 : System.__ComObject 00001 : System.Collections.Queue+SynchronizedQueue 00001 : System.Threading.AutoResetEvent 00001 : System.Threading.ContextCallback 00001 : System.RuntimeMethodInfoStub 00001 : System.RuntimeType+RuntimeTypeCache+MemberInfoCache`1[[System.Reflection .RuntimeMethodInfo, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b 77a5c561934e089]] 00001 : System.Reflection.RuntimeMethodInfo[] 00001 : System.Collections.Generic.List`1[[System.Attribute, mscorlib, Version=4 .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Drawing.SizeF 00001 : System.Drawing.Point 00001 : System.Windows.Forms.Application+ThreadContext 00001 : System.Windows.Forms.WindowsFormsSynchronizationContext 00001 : System.EventArgs 00001 : System.Windows.Forms.NativeMethods+WNDCLASS_D 00001 : Microsoft.Win32.UserPreferenceChangedEventHandler 00001 : System.Random 00001 : System.Collections.Generic.ObjectEqualityComparer`1[[System.Object, msco rlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Versio n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Object[], m scorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] 00001 : Microsoft.Win32.SystemEvents 00001 : System.Runtime.Remoting.Messaging.LogicalCallContext 00001 : System.Text.UTF8Encoding 00001 : Microsoft.Win32.NativeMethods+WNDCLASS 00001 : System.Internal.HandleCollector+HandleType[] 00001 : System.IntPtr[] 00001 : System.Security.Util.URLString 00001 : System.Security.Permissions.FileIOPermission 00001 : System.Security.Util.LocalSiteString 00001 : System.Security.Util.DirectoryString 00001 : Microsoft.Win32.SafeHandles.SafeFileHandle 00001 : System.Text.SBCSCodePageEncoding 00001 : System.Text.InternalEncoderBestFitFallback 00001 : System.Text.InternalDecoderBestFitFallback 00001 : Microsoft.Win32.SafeHandles.SafeViewOfFileHandle 00001 : Microsoft.Win32.SafeHandles.SafeFileMappingHandle 00001 : System.IO.__ConsoleStream 00001 : System.Text.EncoderNLS 00001 : System.IO.StreamWriter+MdaHelper 00001 : System.IO.TextWriter+SyncTextWriter 00001 : System.Diagnostics.Stopwatch 00001 : System.Predicate`1[[System.Int64, mscorlib, Version=4.0.0.0, Culture=neu tral, PublicKeyToken=b77a5c561934e089]] 00001 : System.DBNull Objects total: 2294. Time taken: 437</code> </pre></div></div><br></li><li>  <b>Can I get objects from someone else's domain?</b> <br><br>  Of course!  After all, we are looking at virtual memory.  This time ... And the second ... between the domains there are no boundaries, the objects stand out one after another, even when crossing the domain boundary.  The difference is in the code.  Therefore, it is possible, for example, to pass an object between domains without serialization. <br></li></ul><br> <a href="http://clrium.ru/%3Futm_source%3Dhistory%26utm_medium%3Ddirect%26utm_campaign%3Dhabr"><img src="https://habrastorage.org/getpro/habr/post_images/243/44e/207/24344e20757143d25661a8fbeaa706a3.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/247447/">https://habr.com/ru/post/247447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247435/index.html">Fix frozen buttons on Nexus 4</a></li>
<li><a href="../247437/index.html">Apple Watch emulator in browser</a></li>
<li><a href="../247439/index.html">RackTables. Where to begin?</a></li>
<li><a href="../247441/index.html">IT Cave in the USA</a></li>
<li><a href="../247443/index.html">Eleven content marketing articles that you might have missed in 2014 (part 2)</a></li>
<li><a href="../247449/index.html">Correct polyhedra. Part 1. Trimerie</a></li>
<li><a href="../247451/index.html">Pour beer by thought</a></li>
<li><a href="../247457/index.html">BPMN: Modeling Physical Events</a></li>
<li><a href="../247461/index.html">How to Install Btier on Debian Wheezy</a></li>
<li><a href="../247465/index.html">imarker - commercial SORM-like web analytics already with your provider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>