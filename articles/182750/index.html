<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SlideStackView or extending ViewGroup in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Being engaged in the development of a mail application for Android, we in Mail.Ru often analyze how convenient it is for the end user to navigate with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SlideStackView or extending ViewGroup in Android</h1><div class="post__text post__text-html js-mediator-article">  Being engaged in the development of a mail application for Android, we in Mail.Ru often analyze how convenient it is for the end user to navigate within our program.  I think that it is not worth explaining how important this is, because everyone who uses mobile applications knows without it that a product that does not provide intuitive and fast navigation will lose to those products that have taken care of it.  Convenience and well-designed navigation is what the user will either love your application for, or every time make incredible efforts not to break your phone on the floor. <br><br><a name="habracut"></a>  In our applications, we used the ‚Äúsliding menu‚Äù before it was included in the official ui patterns for Android.  After certain studies in the usability lab, we decided that we need to move forward and improve the side menu to provide the user with the best user experience. <br><br>  So, more to the point.  Instead of such a menu where a fragment with folders and accounts moves along with a swipe of a list of letters, we wanted to make the fragments move in turns, such as a stack of sheets, which we shift to view the next page. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/f41/c84/b23/f41c84b235be70dec43cd0e354bc6ed0.jpg"><br><img src="https://habrastorage.org/storage2/bd2/831/fb2/bd2831fb29991902a8777027dcedb765.jpg"><br><br><img src="https://habrastorage.org/storage2/56a/29e/dd1/56a29edd1ef8c3f05c24cb5c174f22ea.jpg"><br><br>  In addition to how the controller, called SlideStackView, should behave, there were several other requirements from both the development and the product side: <br><br>  1. Each slide must be represented by a fragment. <br>  2. Must be implemented "bouncing over scroll effect" - when the slide as it springs from the edge <br>  3. Vertical lists inside slides should scroll without any behavioral glitches. <br>  4. Save / restore state (position of open slide, etc.) <br><br>  Naturally, before proceeding to the fulfillment of minor requirements, you need to implement the ViewGroup itself, which will manage your children the way we planned. <br><br>  We will go from simple to complex - first we need to decide how we fit into androidFramework, in order, first, not to write a bicycle, and second, to provide the most similar user experience.  The above-mentioned ViewPager will not work, because the slide positioning model is completely different.  Therefore, we look up the hierarchy and stop at the ViewGroup. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SlideStackView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewGroup</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SlideStackView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, AttributeSet attrs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> defStyle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs, defStyle); ... initAttributes(context, attrs); <span class="hljs-comment"><span class="hljs-comment">// we need to draw childs in reverse order setChildrenDrawingOrderEnabled(true); } public SlideStackView(Context context, AttributeSet attrs) { this(context, attrs, android.R.style.Theme_Black); } public SlideStackView(Context context) { this(context, null); }</span></span></code> </pre> <br>  From the special one can only note that we ask you to use non-standard order when drawing our slides.  Here confusion may initially arise.  The thing is that our slides should be numbered from right to left, because  the first is to go with the list of letters (# 0), when we close it, we see the slide with the list of folders (# 1), and the last is the slide with the list of accounts (# 2).  In the numbering of the ViewGroup itself, it is much more convenient to use the usual order - that is, from left to right, both when adding slides, and when drawing them further, positioning, etc.  The point here is not even that it is so accepted, or so it is necessary to write less by one line of code.  In fact, everything depends on the processing of MotionEvent.  When they are transmitted, the array of child'ov is passed in order from 0 to childCount, and since  the upper slide can be superimposed on the lower slide, then we should start walking around our children from the lower to the upper in search of the slide that MotionEvent can process.  I will tell you more about this when we deal with the processing of MotionEvents. <br>  Thus, we very often need this method: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Same as {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #getChildAt(int)} but uses adapter's * slide order in depending on the actual child order * in the view group * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position position of the child to be retrieved * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> view in specified */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> View </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getChildAt(getChildCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - position); }</code> </pre><br><br>  Then in order of rendering, we do not need to change anything: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Use this to manage child drawing order. We should draw * the slide #{lastSlide} (in adapter's data set indexes) first. Then draw * the slide with #{lastSlide - 1} and so on until the slide #0 inclusive * &lt;p&gt; * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChildDrawingOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> childCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//draw the last slide first. /** * __________ * __|0 | * |1 | | * | | | * | |__________| * |__________| */ return /*childCount - */i /*- 1*/; }</span></span></code> </pre><br><br>  Now the fun part.  Of course, we are going to show slides, the number of which can be varied.  In the Android Framework Team decided to use the so-called Adapter for this - an excellent approach, so we will.  And the closest thing to us is exactly the adapter implementation that is used in the ViewPager - we will need additional changes in this adapter, but more on that later. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Used in case we have no valid position or actual position * can not be found. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INVALID_POSITION = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Index of the first element from adapter's data set * added to the layout of the slide stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mFirst; <span class="hljs-comment"><span class="hljs-comment">/** * Current selected slide position in adapter's data set */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mSelected; <span class="hljs-comment"><span class="hljs-comment">/** * A data set adapter that prepares view for the slide stack view * and is responsible for base information about the containing * data set. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SlideStateAdapter mAdapter; <span class="hljs-comment"><span class="hljs-comment">/** * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> DataSetObserver} that indicates about changes in slides * data set */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DataSetObserver mObserver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observer(); <span class="hljs-comment"><span class="hljs-comment">/** * Sets the adapter for providing the SlideStackView with * slides. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> adapter */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SlideStateAdapter adapter)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ mAdapter.unregDataSetObserver(mObserver); mFirst = INVALID_POSITION; mScroller.stopScrolling(); removeAllViews(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(adapter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ mAdapter = adapter; mAdapter.regDataSetObserver(mObserver); } }</code> </pre><br>  Where the Class Observer looks like this to begin with: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSetObserver</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//empty } @Override public void onInvalidated() { //empty } }</span></span></code> </pre><br><br>  Now we have an adapter that serves as a link between what we are going to show and how we will do it. <br><br>  Obviously, one of the key points in this kind of control is how our slides will move within SlideStackView.  This is a fairly voluminous task both for the functionality assigned to it and for the amount of code necessary for the effective implementation of this task.  From here the following decision - to carry out all functionality connected with processing of scrolling in a class which and will be called. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SlideScroller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scroller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnTouchListener</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ScrollingListener mListener; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GestureDetector mGestureDetector; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SlideScroller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, ScrollingListener listener, OnGestureListener gestureListener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mListener = listener; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mGestureDetector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GestureDetector(context, gestureListener); mGestureDetector.setIsLongpressEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public void fling(int velocity){ ... } public void stopScrolling() { ... } @Override public boolean onTouch(View v, MotionEvent event) { ... } void finishScrolling() { ... } boolean isScrolling(){ ... } boolean isJustifying(){ ... } boolean isTouchScrolling(){ ... } }</span></span></code> </pre><br><br>  Now we can safely bring the entire scrolling kitchen into this module, and only inform SlideStackView about the necessary events via ScrollingListener: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollingListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onJustify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  Where does the implementation of any ViewGroup begin?  A ViewGroup is a compiler that, in addition to being able to do a View, can also have other View within itself.  Therefore, the answer to our question is the implementation of the ViewGroup, which begins with the Override methods: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> changed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  where we place our slides: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMeasure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthMeasureSpec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightMeasureSpec)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  and where we measure our slides. <br>  Let's start with the measurement: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMeasure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthMeasureSpec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightMeasureSpec)</span></span></span><span class="hljs-function"> </span></span>{ setMeasuredDimension(getDefaultSize(<span class="hljs-number"><span class="hljs-number">0</span></span>, widthMeasureSpec), getDefaultSize(<span class="hljs-number"><span class="hljs-number">0</span></span>, heightMeasureSpec)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childHeightSize = getMeasuredHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec( childHeightSize, MeasureSpec.EXACTLY); <span class="hljs-comment"><span class="hljs-comment">// Make sure we have created all fragments that we need to have shown. mInLayout = true; fillViewsIn(); mInLayout = false; // measure slides int size = getChildCount(); for (int i = 0; i &lt; size; ++i) { final View child = getChild(i); if (child.getVisibility() != GONE) { int childWidthSize = getMeasuredWidth() - ( getRightEdgeDelta(mFirst + i - 1) + getLeftEdge(mFirst + i)); final int widthSpec = MeasureSpec.makeMeasureSpec( childWidthSize, MeasureSpec.EXACTLY); // LOG.v("Measuring #" + i + " " + child // + ": " + widthSpec); child.measure(widthSpec, mChildHeightMeasureSpec); } } }</span></span></code> </pre><br><br>  Everything is simple - first we set the size for the slide stack based on the specifications that the container gave us.  In mobile mail, the slide stack is the root markup element, so this way we fill the entire accessible area. <br><br>  Since  we don't want our slides to be different in height, then we create a height specification with the MeasureSpec.EXACTLY flag, and a value equal to the measured height of the slide stack. <br><br>  To measure our slides, we naturally need the slides themselves, so we need to make sure that they are already added to the markup.  To do this, call filling the slides from the top to the bottom.  After that we go through the slides, determine their desired width and measure them by calling child.measure (widthSpec, mChildHeightMeasureSpec). <br><br>  The width of a slide is defined as the width of the slide stack minus the padding on the left and right for a particular slide, for example, for a slide with a list of folders. <br><br><img src="http://habrastorage.org/storage2/a00/7b0/a0b/a007b0a0b97671b3edd7ac4e86c1f325.jpg"><br><br>  After we have measured our slides, it remains only to position them correctly: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> changed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ mInLayout = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; fillViewsIn(); mInLayout = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; getChildCount(); i++) { View child = getChild(i); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = i + mFirst; onLayoutChild(child, position, changed); } mDirty.setEmpty(); } <span class="hljs-comment"><span class="hljs-comment">/** * Layouts child at the specified position (in adapter's data set). * Measures the child if needed. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> child a child we are going to layout * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position position of the child in adapter's data set */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> changed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child.getVisibility() != GONE) { LOG.d(<span class="hljs-string"><span class="hljs-string">"onLayoutChild "</span></span> + position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &lt; mSelected &amp;&amp; changed){ closeView(position); LOG.v(<span class="hljs-string"><span class="hljs-string">"close slide at "</span></span> + position); } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LayoutParams lp = (LayoutParams) child.getLayoutParams(); SlideInfo info = getSlideInfo(child); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childLeft = getLeftEdge(position) + info.mOffset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childRight = getRightEdge(position - <span class="hljs-number"><span class="hljs-number">1</span></span>) + info.mOffset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childTop = getTop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lp.needsMeasure) { lp.needsMeasure = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthSpec = MeasureSpec.makeMeasureSpec( childRight - childLeft, MeasureSpec.EXACTLY); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heightSpec = MeasureSpec.makeMeasureSpec( getMeasuredHeight(), MeasureSpec.EXACTLY); child.measure(widthSpec, heightSpec); } <span class="hljs-comment"><span class="hljs-comment">// LOG.v("Positioning #" + position + " " + child + ":" + childLeft // + "," + childTop + " " + child.getMeasuredWidth() + "x" // + child.getMeasuredHeight()); child.layout(childLeft, getTop(), childRight, getBottom()); } }</span></span></code> </pre><br><br>  We first need to make sure that we have already added all the slides that we can show to the markup, and then directly set the position for the slide in each specific position.  It is important to take into account the fact that the newly added slides may not be closed, this should be corrected. <br><br>  Also, if a slide was added after the slide stack was measured, then this slide also needs to be measured. <br><br>  Here SlideInfo is the usual Holder, which contains information about the position and state of the slide. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Simple info holder for the slide item * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> k.kharkov */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SlideInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Describes slide offset relative to the slide stack. * Note that offset value do not describe actual slide * position inside the slide stack but only shows the * offset relative to the left position of the slide. * &lt;p&gt; * This means * &lt;code&gt;getLeftEdge(position) + info.mOffset&lt;/code&gt; * equals to actual offset of the slide relative to * the slide stack view. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Indicates whether the slide is visible to the user * or hidden at near the slide stack side */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> mOpened = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Position of the slide inside the slide stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPosition = INVALID_POSITION; <span class="hljs-comment"><span class="hljs-comment">/** * The drawable to fill space between this slide and the * previous one. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SlideStackView#fillAreaToPrevSlide(Canvas, View) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Drawable mSpace; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SlideInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } }</code> </pre><br><br>  In fact, instead of using SlideInfo separately, it was possible to get along with the successor of the LayoutParams class, which I still used in the future.  At the time of writing, I did not know this and now I have not transferred this information to layoutParams, but I want to do it as soon as possible.  There is nothing criminal in the additional holder, but I support the KISS (Keep It Simple Stupid) approach, and using one object instead of two is noticeably simpler :) <br><br>  So we figured out how to deal with the slides that we have already added to the ViewGroup.  The question that has not yet been addressed is how to add them there.  For this we left the method: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Adds all required views in layout first. * Then adjusts visibility for each child. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> #addViewsInside(int, int) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> #adjustViewsVisibility() */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillViewsIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getChildCount() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ position = getLastVisiblePosition() + <span class="hljs-number"><span class="hljs-number">1</span></span>; View lastView = getChild(position - mFirst - <span class="hljs-number"><span class="hljs-number">1</span></span>); left = lastView.getLeft() - lastView.getScrollX(); } addViewsInside(position, left); adjustViewsVisibility(); }</code> </pre><br><br>  This method finds the last slide and adds the following slides to SlideStackView, if they exist and will be visible to the user.  All this happens like this: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Uses the adapter to add views to the slide stack view. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position last visible position of the view * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> left left coordinate of the last visible slide */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addViewsInside</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapter == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mAdapter.getCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mAdapter.startUpdate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((position &lt;= mSelected + <span class="hljs-number"><span class="hljs-number">1</span></span> || left &gt; getLeft()) &amp;&amp; position &lt; mAdapter.getCount()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFirst == INVALID_POSITION){ mFirst = <span class="hljs-number"><span class="hljs-number">0</span></span>; } LOG.d(<span class="hljs-string"><span class="hljs-string">"addView inside "</span></span> + position + <span class="hljs-string"><span class="hljs-string">" mSelected "</span></span> + mSelected); mAdapter.instantiateItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, position); left = mSelected &gt; position ? getLeftEdge(position) : getRightEdge(position - <span class="hljs-number"><span class="hljs-number">1</span></span>); position ++; } mAdapter.finishUpdate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br><br>  Since we decided to use fragments as our slides, it is better to add slides within a single transaction of fragments. <br><br>  Then we make an adjustment of the initial conditions taking into account the newly added slides and repeat the process of creating the slide until either the slides run out or the slides go beyond the limits of the slide stack's visibility.  If left becomes &lt;= getLeft (), this means that the very last slide we added overlaps the border of the slide stack.  This means that the next slide may be either completely under this slide, or it may be visible to the left, but this area will not fall within the slide stack and the user will not be visible.  And since  the slide will not be visible to the user; <br><br>  ‚ÄúBut where is the addition of the slide itself?‚Äù You ask.  After we call mAdapter.finishUpdate (this);  The adapter starts the transaction and the FragmentManager starts adding fragments to the transferred container (this is the SlideStackView).  The process of adding a fragment is difficult to describe in a nutshell, so we‚Äôll leave this topic to the reader‚Äôs independent consideration :) During the execution of the fragment‚Äôs lifecycle, it will be added to our slide stack via the ViewGroup.addView (View, int, LayoutParams) method;  We will need to make a few adjustments in order to arrange the slide correctly, so we override this method: <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Specifies correct layout parameters for the child and * adds it according the the current {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #mInLayout} * status. * &lt;p&gt; * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ViewGroup.LayoutParams params)</span></span></span><span class="hljs-function"> </span></span>{ LOG.d(<span class="hljs-string"><span class="hljs-string">"Add view from outside "</span></span> + child); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!checkLayoutParams(params)) { params = generateLayoutParams(params); } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LayoutParams lp = (LayoutParams) params; SlideInfo info = getSlideInfo(child); info.mPosition = getChildCount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ info.mSpace = mAdapter.getSpaceDrawable(info.mPosition); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mInLayout) { lp.needsMeasure = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; addViewInLayout(child, <span class="hljs-number"><span class="hljs-number">0</span></span>, params); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.addView(child, <span class="hljs-number"><span class="hljs-number">0</span></span>, params); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.mPosition &lt; mSelected){ closeView(info.mPosition); } }</code> </pre><br><br>  Fill in the required data.  Then we add the stack to the slide depending on whether the slide is added during the layout process or not, and close the slide if its position is less than the position of the slide that is currently active. <br><br>  Naturally, if we add fragments to the slide stack, we need to delete them once.  Deletion behavior is similar to adding, only we look for those slides that are no longer visible to the user and delete them from the ViewGroup using our adapter. <br><br>  In the fillViewsIn () method;  there is a last unreviewed line in which we call the method adjustViewsVisibility; <br><br>  This method, as the name suggests, corrects the visibility of the slides.  This is necessary in order not to waste time on drawing those slides that can not yet be removed from the markup, but are no longer visible to the user.  By itself, adjusting the visibility is very simple - we just set the visibility for the slide through View.setVisibility (int), where we pass either View.VISIBLE or View.INVISIBLE.  The method itself looks a little more complicated, but having understood in principle its work, it becomes all clear. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Sets visibility parameter for each child according * to the actual visibility on the screen. Takes into * account that child shouldn't be invisible if it's * shadow is visible on the screen because it would * prevent from triggering {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #drawChild(Canvas, View, long)} * method over that child. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adjustViewsVisibility</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * init the rect to align right edge if the slide stack view */</span></span> Rect drawingRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(); drawingRect.left = getRight(); drawingRect.top = getTop(); drawingRect.right = getRight(); drawingRect.bottom = getTop() + getHeight(); Rect parent = getChildDrawingRectPositive(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Then union each child drawing rect * with drawingRect of the slide stack * in order to determine when the views * behind the last actually visible view * in the slideStack view and hide all * the following views in order to prevent * re-drawing non-visible views * ________________________________ * | slideStackView __________| * | ____________________| | * || _ _ _ _ | | * ||| | |visible | * || |slide #0 | * ||| hidden slide| | | * || #2 | | * |||_ _ _ _| | | * ||last actual visible | | * ||slide #1 |__________| * ||__________________________| | * |________________________________| */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; getChildCount(); i ++){ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hideNext = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LOG.v("adjustVisibility " + i); View child = getChild(i); Rect childRect = getChildDrawingRectPositive(child); // LOG.v("child.left " + childRect.left + // " drawing.left" + drawingRect.left + // " parent " + parent.toShortString() + // " child" + childRect.toShortString()); if (childRect.left &lt; drawingRect.left &amp;&amp; Rect.intersects(parent, childRect)){ drawingRect.union(childRect); // LOG.d("drawingRect after union with child " + i + " = " + // drawingRect.toShortString()); hideNext = false; } else { // LOG.d("hide view " + i); // LOG.v("child " + childRect.toShortString() + // " drawing " + drawingRect.toShortString() + // " parent " + parent.toShortString()); Rect childShadow = getShadowRect(childRect); if (childShadow.isEmpty()){ hideNext = true; } // if shadow visible - do not hide the slide // and let the shadow to be drawn if (childShadow.left &lt; drawingRect.left &amp;&amp; Rect.intersects(parent, childShadow)){ hideNext = false; } else { hideNext = true; } } // LOG.d("set visibility for child " + i + " = " + // (hideNext ? "Invisible" : "Visible")); child.setVisibility(hideNext ? View.INVISIBLE : View.VISIBLE); } }</span></span></code> </pre><br><br>  I will try step by step as easy as possible to paint the work of this method. <br><br>  The general algorithm looks like this: <br><br>  1. Take the right border of the slide stack (because the rightmost slide is always fully visible and those to the left are overlapped by it. On the contrary, it cannot be.) <br>  2. Go through all the slides and, as it were, add to the occupied area the space inside the slide stack that each slide occupies. <br>  3. At the same time, if the next slide is located either outside the stack, or is completely closed by the slides that lie above it, then we mark it as ‚Äúinvisible‚Äù.  Otherwise, the slide is considered "visible." <br><br>  In the above drawingRect method, this is exactly the area that is already occupied by the slides, and childRect is the area in which the slide is located in a specific position. <br><br>  It remains to make an amendment to the shadow.  We draw the shadow ourselves, so if we do not take into account the space that the shadow will occupy when adjusting the visibility of the slides, we can see unpleasant blinking at the moment when the slides appear / hide behind each other.  The thing is that in the ViewGroup in the process of drawing there is a check whether the child is visible or invisible.  If it is invisible, then the drawChild method (Canvas, View, long) will simply not be called for this child, which is very logical.  Therefore, we need to consider the slide visible even if only a shadow is visible from it.  To do this, we do an additional check and make an amendment at the moment when we decided that the slide is not visible to the user. <br><pre> <code class="java hljs"> Rect childShadow = getShadowRect(childRect); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childShadow.isEmpty()){ hideNext = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if shadow visible - do not hide the slide // and let the shadow to be drawn if (childShadow.left &lt; drawingRect.left &amp;&amp; Rect.intersects(parent, childShadow)){ hideNext = false; } else { hideNext = true; }</span></span></code> </pre><br>  In general, it is important to note, of course, the fact that the entire method of adjustViewsVisibility () is performed for optimization purposes.  After all, we do not want our user's mobile device to perform work that he will not see anyway.  Moreover, unnecessary drawing greatly affects the performance and, consequently, the smoothness of the animation. <br><br>  But just preventing the drawing of those slides that are not visible to the user does not completely solve the problem.  We still have the "overlay" of slides.  This happens at the moment when we move one slide to the side and see from under it part of the next slide.  That is, it turns out that the user sees only part of the slide (or even only the shadow / part of the shadow from it), and we draw the entire slide entirely.  Then, of course, draw another slide on top of it. <br><br>  Personally, I do not know any other way to solve this problem, except for using the Canvas.clipRect (Rect) method.  Thus, we need to determine which part of the slide will be visible to the user in each separate frame, limit the area for drawing on the canvas to the space that will be visible to the user from this slide, and only then draw the slide. <br><br>  The above method of drawing a slide looks like this for me: <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Clips the canvas to the child current bounds plus shadow. * &lt;p&gt; * Draws the shadow as well for each child. * &lt;p&gt; * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> #applyShadowToChild(Canvas, View) */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas, View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> drawingTime)</span></span></span><span class="hljs-function"> </span></span>{ Rect childClip = getChildClipRect(child); <span class="hljs-comment"><span class="hljs-comment">// LOG.d("canvas " + canvas.getClipBounds().toShortString()); // LOG.d("draw Child " + child + " clip = " + childClip.toShortString()); // first // draw spaces between slides fillAreaToPrevSlide(canvas, child); // second // draw shadow for the slide applyShadowToChild(canvas, child); // third // actually draw child try{ canvas.save(); canvas.clipRect(childClip); boolean r = super.drawChild(canvas, child, drawingTime); return r; } finally { canvas.restore(); } }</span></span></code> </pre><br>  It all starts with the fact that we calculate the rectangle for the slide, which will be visible to the user on the screen, then fill the space between the slides (if present), draw the shadow for the slide, and after that we limit the canvas to the calculated childClip, and draw The slide is exactly as defined in the ViewGroup. <br><br>  As you can see - everything is quite simple.  All magic is inside the method of counting the area on which you want to ‚Äútrim‚Äù the canvas. <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Retrieves children's visible position on the screen * without it's shadow. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> child we should retrieve visible bounds for * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> a child's visible bounds */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Rect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChildClipRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child)</span></span></span><span class="hljs-function"> </span></span>{ Rect childClip = getChildDrawingRectPositive(child); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = getPositionForView(child); subtractRectWithChilds(childClip, position); <span class="hljs-comment"><span class="hljs-comment">// LOG.v("child clip " + position + " " + childClip.toShortString()); return childClip; } /** * Changes the specified clip rectangle, to subtract all the * following children from it. * @param childClip initial child rectangle in the screen * @param position child position within adapter's data set * @see #subtractToLeft(Rect, Rect) */ private void subtractRectWithChilds(Rect childClip, int position) { if (position &gt;= 0){ position -= mFirst; for (int i = position - 1; i &gt;= 0; i --){ View c = getChild(i); Rect r = getChildDrawingRectPositive(c); boolean changed = subtractToLeft(childClip, r); if (changed){ // LOG.v("child clipped " + childClip.toShortString()); } } } }</span></span></code> </pre><br>  In the first method, we find the position of the slide inside the slide stack, then we find its position in the indexes of the adapter slide.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, we ‚Äúsubtract‚Äù all unnecessary and return the result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second method is just what ‚Äúsubtracts‚Äù this is the most unnecessary. </font><font style="vertical-align: inherit;">Excess, we believe that part of the slide, which will overlap other slides, which are located to the right (or closer to the beginning in the adapter indexes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to consider a method that directly subtracts one rectangle from another. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately make a reservation that such a subtraction is difficult to make universal, so the methods are written taking into account the fact that all slides are the same height.</font></font><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Same as {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #subtract(Rect, Rect)} method, but processes * the case where source rectangle wasn't changed because it * contains &lt;code&gt;r&lt;/code&gt;. In this case it adjusts &lt;code&gt;r&lt;/code&gt; * from this: * &lt;pre&gt; * _______________________ * | source _________ | * | | r | | * | | | | * | | | | * | | | | * | |_________| | * |_______________________| * &lt;/pre&gt; * * to this: in order to leave only left side of the source rectangle. * &lt;pre&gt; * ___________________________ * | source | r |1px| * | | |&lt;-&gt;| * | | | | * | | | | * | | | | * | | | | * | | | | * |_________|_____________|___| * &lt;/pre&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> source the rectangle we are going to subtract from * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> r the rectangle we are going to subtract from * source * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> &lt;code&gt;true&lt;/code&gt; in case the source rectangle * has been changed. &lt;code&gt;false&lt;/code&gt; otherwise */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtractToLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rect source, Rect r)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> changed = subtract(source, r); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changed &amp;&amp; source.contains(r)){ <span class="hljs-comment"><span class="hljs-comment">// adjust intersected rect manually r.right = source.right + 1; r.top = source.top; r.bottom = source.bottom; changed = subtract(source, r); } return changed; } /** * Subtracts &lt;code&gt;r&lt;/code&gt; from the &lt;code&gt;source&lt;/code&gt;. * Sets &lt;code&gt;r&lt;/code&gt; rectangle to the intersection as well. * @param source * @param r * @return &lt;code&gt;true&lt;/code&gt; if rectangle has been subtracted, * &lt;code&gt;false&lt;/code&gt; otherwise. */ private static boolean subtract(Rect source, Rect r) { if (source.isEmpty() || r.isEmpty()){ return false; } if (r.contains(source)){ // LOG.w("return empty rect"); source.setEmpty(); return true; } if (source.contains(r)){ return false; } if (!r.intersect(source)){ return false; } boolean changed = false; if (source.left == r.left){ source.left = r.right; changed = true; } if (source.right == r.right){ source.right = r.left; changed = true; } if (source.top == r.top){ source.top = r.bottom; changed = true; } if (source.bottom == r.bottom){ source.bottom = r.top; changed = true; } source.sort(); return changed; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In principle, the code inside these methods is quite transparent, and I hope that my ‚Äúdrawings‚Äù bring at least some additional clarity and are understandable not only to me :) </font></font><br><br>  ,    ,       ‚Äì         Rect. ,   .      .         ,      .        ¬´¬ª ,   -     ,     .   ,       .                .         ,     ,    ,    .            ,   ,        . <br><br> ,     ,      ,        ,         . <br><br>       ,       ‚Äì .      ,         .           ,        .  ,   ,     MotionEvent'   ,   ,      -,     . <br><br>         ,          ,      ,    ViewGroup. <br><br>    ‚Äì -           Mail.Ru.            .     ,        . </div><p>Source: <a href="https://habr.com/ru/post/182750/">https://habr.com/ru/post/182750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182738/index.html">Adopted a law on open data</a></li>
<li><a href="../182740/index.html">Automatic installation of the operating system on dedicated servers Selektel</a></li>
<li><a href="../182742/index.html">RADUG + DI = WWDC</a></li>
<li><a href="../182746/index.html">Overview of Windows Workflow Foundation on the example of building an electronic document management system [Part 2]</a></li>
<li><a href="../182748/index.html">Gentle introduction to Coq: inductive definitions</a></li>
<li><a href="../182754/index.html">Skype spam campaign endangered hundreds of thousands of users.</a></li>
<li><a href="../182758/index.html">Windows 8 Technology Conference</a></li>
<li><a href="../182760/index.html">Bunny: We hide traffic in the noise of Wi-Fi</a></li>
<li><a href="../182762/index.html">Legal tax minimization in Ukraine for IT companies</a></li>
<li><a href="../182764/index.html">CONFidence. Again about how cool it is</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>