<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redirecting Functions in Shared ELF Libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all use dynamically-compiled bilieceae. Their capabilities are truly great. First, such a library is loaded into the physical address space only on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Redirecting Functions in Shared ELF Libraries</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage/afe3a628/27e2dc06/9afa147c/33803238.png">  We all use dynamically-compiled bilieceae.  Their capabilities are truly great.  First, such a library is loaded into the physical address space only once for all processes.  Secondly, you can expand the functionality of your program by loading the additional library, which will provide this functionality.  And all this without restarting the program itself.  And the problem of updates is being solved.  For a dynamically composable library, you can define a standard interface and influence the functionality and quality of your main program simply by changing the library version.  Such code reuse methods are even called "plug-in architecture".  But the topic is not about that. <br><br>  By the way, the impatient can all <a href="">download</a> and try right now. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, rarely does a dynamically assembled library rely solely on itself in its implementation, that is, the processor‚Äôs computational capabilities and memory.  Libraries use libraries.  Or, at least, standard libraries.  As, for example, programs on C \ C ++ use the standard C \ C ++ libraries.  The latter, by the way, for convenience are also organized in a dynamically linked form (libc.so and libstdc ++. So).  They themselves are stored in special format files.  My research was conducted for Linux, in which the main format of dynamically composable libraries is ELF (Executable and Linkable Format). <br>  Some time ago I was faced with the need to intercept function calls from one library to another.  Just to process them in a special way.  This is called call forwarding. <br><br><h4>  More about redirection </h4><br>  To begin with, we will formulate the problem on a concrete example.  Suppose we have a program called ‚Äútest‚Äù in C (file test.c) and two shared libraries (files libtest1.c and libtest2.c), with the same content, compiled in advance.  These libraries provide one function at a time: libtest1 () and libtest2 (), respectively.  In their implementation, each of them uses the puts () function from the standard C library. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/089057e3/1cda8de1/abd7ded0/750b9fc1.png"></div><br>  The task is as follows: <br><ol><li>  It is necessary to replace the call to the puts () function for both libraries with a call to the redirected_puts () function implemented in the main program (file test.c), which, in turn, can use the original puts (); <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/3d43fe1c/e8528998/db2c173f/ea240126.png"></div></li><li>  Cancel the changes you have made, that is, make the repeated call to libtest1 () and libtest2 () lead to a call to the original puts (). <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/4f2db377/481f0b54/54b771ad/428a2599.png"></div></li></ol><br>  In this case, changing the code or recompiling the libraries themselves is not allowed, only the main program. <br><br><h4>  Why do you need it? </h4><br>  This example illustrates two very interesting features of this redirection: <br><ol><li>  It is carried out exclusively for a specific dynamically compiled library, and not for the whole process, as when using the dynamic loader LD_PRELOAD environment variable, which allows other modules to safely use the original function; </li><li>  It occurs while the program is running and does not require its restart. </li></ol>  Where can this be applied?  Well, for example, in your program with a bunch of plug-ins, you can intercept their calls to system resources or any other libraries without affecting other plug-ins and the application itself.  Or even do the same thing from your own plug-in to some application. <br>  There is no legal way to solve this problem.  The only option is to deal with the ELF and make the necessary changes in the memory yourself. <br><br>  <b>Go!</b> <br><br><h4>  ELF in brief </h4><br>  The best way to understand ELF is to be patient and read its specification carefully a couple of times, then write a simple program, compile it and examine it in detail using a hex editor comparing what you see with the specification.  This method of research immediately prompts the idea to write some simple parser for ELF, as there will be a lot of routine work.  But do not hurry.  There are already several such utilities.  For the study, we take the files from the previous section: <br><br><h5>  File test.c </h5><br><pre><code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;stdio.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;dlfcn.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">LIBTEST1_PATH</span></span> <span class="hljs-comment"><span class="hljs-comment">"libtest1.so"</span></span> //position dependent code (for <span class="hljs-number"><span class="hljs-number">32</span></span> bit only) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">LIBTEST2_PATH</span></span> <span class="hljs-comment"><span class="hljs-comment">"libtest2.so"</span></span> //position independent code void libtest1(); //from libtest1.so void libtest2(); //from libtest2.so int main() { void *handle1 = dlopen(<span class="hljs-type"><span class="hljs-type">LIBTEST1_PATH</span></span>, <span class="hljs-type"><span class="hljs-type">RTLD_LAZY</span></span>); void *handle2 = dlopen(<span class="hljs-type"><span class="hljs-type">LIBTEST2_PATH</span></span>, <span class="hljs-type"><span class="hljs-type">RTLD_LAZY</span></span>); if (<span class="hljs-type"><span class="hljs-type">NULL</span></span> == handle1 || <span class="hljs-type"><span class="hljs-type">NULL</span></span> == handle2) fprintf(stderr, <span class="hljs-comment"><span class="hljs-comment">"Failed to open \"</span></span>%s\<span class="hljs-comment"><span class="hljs-comment">" or \"</span></span>%s\<span class="hljs-comment"><span class="hljs-comment">"!\n"</span></span>, <span class="hljs-type"><span class="hljs-type">LIBTEST1_PATH</span></span>, <span class="hljs-type"><span class="hljs-type">LIBTEST2_PATH</span></span>); libtest1(); //calls puts() from libc.so twice libtest2(); //calls puts() from libc.so twice puts(<span class="hljs-comment"><span class="hljs-comment">"-----------------------------"</span></span>); dlclose(handle1); dlclose(handle2); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h5>  File libtest1.c </h5><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">libtest1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"libtest1: 1st call to the original puts()"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"libtest1: 2nd call to the original puts()"</span></span>); }</code> </pre><br><h5>  File libtest2.c </h5><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">libtest2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"libtest2: 1st call to the original puts()"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"libtest2: 2nd call to the original puts()"</span></span>); }</code> </pre><br><h4>  What are the parts of ELF? </h4><br>  To answer this question, you need to look inside this file.  For this there are such utilities: <br><ul><li>  readelf is a very powerful tool for viewing the contents of sections of an ELF file </li><li>  objdump - very similar to the previous one, can disassemble sections </li><li>  gdb is indispensable for debugging under Linux, especially for viewing places to be relocated </li></ul>  <b>Relocation</b> is a special term for that place in the ELF file that refers to a symbol from another module.  The static (ld) or dynamic (ld-linux.so.2) linker \ loader directly modifies such places. <br><br>  Any ELF file starts with a special header.  Its structure, as well as the description of many other ELF elements, can be found in the /usr/include/linux/elf.h file.  The header has a special field in which the offset from the beginning of the section header table file is recorded.  Each element of this table describes a section in the ELF.  A section is the smallest indivisible structural element in an ELF file.  When loaded into memory, sections are combined into segments.  Segments are the smallest indivisible parts of an ELF file that can be mapped into memory by the loader (ld-linux.so.2).  Segments are described by a table of segments, the offset of which is also in the ELF file header. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/9188edd2/c9959569/10a83af1/1b7bea4f.png"></div><br>  The most important of them are: <br><ul><li>  .text - contains the module code </li><li>  .data - initialized variables </li><li>  .bss - not initialized variables </li><li>  .symtab - module symbols: functions and static variables </li><li>  .strtab - names for module characters </li><li>  .rel.text - relocations for functions (for statically linked modules) </li><li>  .rel.data - relocations for static variables (for statically linked modules) </li><li>  .rel.plt - the list of elements in the PLT (Procedure Linkage Table) to be relocated during dynamic linking (PLT is used) </li><li>  .rel.dyn - relocations for dynamically linked functions (if PLT is not used) </li><li>  .got - Global Offset Table, contains information about the displacements of relocatable objects </li><li>  .debug - debug info </li></ul>  To compile the above files, run the following commands: <br><pre> <code class="bash hljs">gcc -g3 -m32 -shared -o libtest1.so libtest1.c gcc -g3 -m32 -fPIC -shared -o libtest2.so libtest2.c gcc -g3 -m32 -L<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span> -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.c -ltest1 -ltest2 ‚Äìldl</code> </pre><br>  The first command creates the dynamically compiled library libtest1.so.  The second is libtest2.so.  Pay attention to the ‚ÄìfPIC key.  It causes the compiler to generate a so-called Position Independent Code.  Details in the next section.  The third command creates an executable called test by compiling the test.c file and linking it with the libtest1.so and libtest2.so libraries already created.  The latter are in the current directory, which is reflected in the use of the ‚ÄìL $ PWD key.  The libdl.so layout is required to use the dlopen () and dlclose () functions. <br><br>  To run the program, you must run the following commands: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LD_LIBRARY_PATH=<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:<span class="hljs-variable"><span class="hljs-variable">$LD_LIBRARY_PATH</span></span> ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre><br>  That is, add the path to the current directory to the dynamic linker / loader as a path to search for libraries.  The output of the program we get this: <br><br> <code>libtest1: 1st call to the original puts() <br> libtest1: 2nd call to the original puts() <br> libtest2: 1st call to the original puts() <br> libtest2: 2nd call to the original puts() <br> ----------------------------- <br></code> <br>  Now we will look at sections of the test module.  To do this, run readelf with the ‚Äìa key.  The most interesting of them are listed below: <br><br> <code>ELF Header: <br> Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 <br> Class: ELF32 <br> Data: 2's complement, little endian <br> Version: 1 (current) <br> OS/ABI: UNIX - System V <br> ABI Version: 0 <br> Type: EXEC (Executable file) <br> Machine: Intel 80386 <br> Version: 0x1 <br> Entry point address: 0x8048580 <br> Start of program headers: 52 (bytes into file) <br> Start of section headers: 21256 (bytes into file) <br> Flags: 0x0 <br> Size of this header: 52 (bytes) <br> Size of program headers: 32 (bytes) <br> Number of program headers: 8 <br> Size of section headers: 40 (bytes) <br> Number of section headers: 39 <br> Section header string table index: 36 <br></code> <br>  The standard header of the executable.  The magic sequence is in the first 16 bytes.  The type of module is indicated (in this case, executable, and there is also object (.o) and shared (.so)), architecture (i386), recommended entry point, offsets to segment and section headers and their sizes.  At the very end is the offset in the string table for the section titles. <br><br> <code>Section Headers: <br> [Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br> [ 0] NULL 00000000 000000 000000 00 0 0 0 <br> [ 1] .interp PROGBITS 08048134 000134 000013 00 A 0 0 1 <br> ... <br> [ 5] .dynsym DYNSYM 08048200 000200 000110 10 A 6 1 4 <br> [ 6] .dynstr STRTAB 08048310 000310 0000df 00 A 0 0 1 <br> ... <br> [ 9] .rel.dyn REL 08048464 000464 000010 08 A 5 0 4 <br> [10] .rel.plt REL 08048474 000474 000040 08 A 5 12 4 <br> [11] .init PROGBITS 080484b4 0004b4 000030 00 AX 0 0 4 <br> [12] .plt PROGBITS 080484e4 0004e4 000090 04 AX 0 0 4 <br> [13] .text PROGBITS 08048580 000580 0001fc 00 AX 0 0 16 <br> [14] .fini PROGBITS 0804877c 00077c 00001c 00 AX 0 0 4 <br> [15] .rodata PROGBITS 08048798 000798 00005c 00 A 0 0 4 <br> ... <br> [20] .dynamic DYNAMIC 08049f08 000f08 0000e8 08 WA 6 0 4 <br> [21] .got PROGBITS 08049ff0 000ff0 000004 04 WA 0 0 4 <br> [22] .got.plt PROGBITS 08049ff4 000ff4 00002c 04 WA 0 0 4 <br> [23] .data PROGBITS 0804a020 001020 000008 00 WA 0 0 4 <br> [24] .bss NOBITS 0804a028 001028 00000c 00 WA 0 0 4 <br> ... <br> [27] .debug_pubnames PROGBITS 00000000 0011b8 000040 00 0 0 1 <br> [28] .debug_info PROGBITS 00000000 0011f8 0004d9 00 0 0 1 <br> [29] .debug_abbrev PROGBITS 00000000 0016d1 000156 00 0 0 1 <br> [30] .debug_line PROGBITS 00000000 001827 000309 00 0 0 1 <br> [31] .debug_frame PROGBITS 00000000 001b30 00003c 00 0 0 4 <br> [32] .debug_str PROGBITS 00000000 001b6c 00024e 01 MS 0 0 1 <br> ... <br> [36] .shstrtab STRTAB 00000000 0051a8 000160 00 0 0 1 <br> [37] .symtab SYMTAB 00000000 005920 000530 10 38 57 4 <br> [38] .strtab STRTAB 00000000 005e50 000268 00 0 0 1 <br> Key to Flags: <br> W (write), A (alloc), X (execute), M (merge), S (strings) <br> I (info), L (link order), G (group), x (unknown) <br> O (extra OS processing required) o (OS specific), p (processor specific) <br></code> <br>  Here you can see a list of all sections of the experimental ELF file, their type and the mode of loading into memory (R, W, X and A). <br><br> <code>Program Headers: <br> Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align <br> PHDR 0x000034 0x08048034 0x08048034 0x00100 0x00100 RE 0x4 <br> INTERP 0x000134 0x08048134 0x08048134 0x00013 0x00013 R 0x1 <br> [Requesting program interpreter: /lib/ld-linux.so.2] <br> LOAD 0x000000 0x08048000 0x08048000 0x007f8 0x007f8 RE 0x1000 <br> LOAD 0x000ef4 0x08049ef4 0x08049ef4 0x00134 0x00140 RW 0x1000 <br> DYNAMIC 0x000f08 0x08049f08 0x08049f08 0x000e8 0x000e8 RW 0x4 <br> NOTE 0x000148 0x08048148 0x08048148 0x00020 0x00020 R 0x4 <br> GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 <br> GNU_RELRO 0x000ef4 0x08049ef4 0x08049ef4 0x0010c 0x0010c R 0x1 <br></code> <br>  This is a list of segments - original containers for sections in memory.  The path to the special module - the dynamic linker / loader is also indicated.  That he has to arrange the contents of this ELF file in memory. <br><br> <code>Section to Segment mapping: <br> Segment Sections... <br> 00 <br> 01 .interp <br> 02 .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame <br> 03 .ctors .dtors .jcr .dynamic .got .got.plt .data .bss <br> 04 .dynamic <br> 05 .note.ABI-tag <br> 06 <br> 07 .ctors .dtors .jcr .dynamic .got <br></code> <br>  But how will the distribution of sections by segments at boot time. <br>  But the most interesting section in which information about imported and exported dynamically linked functions is stored is called ‚Äú.dynsym‚Äù: <br><br> <code>Symbol table '.dynsym' contains 17 entries: <br> Num: Value Size Type Bind Vis Ndx Name <br> 0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br> 1: 00000000 0 FUNC GLOBAL DEFAULT UND libtest2 <br> 2: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ <br> 3: 00000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses <br> 4: 00000000 0 FUNC GLOBAL DEFAULT UND dlclose@GLIBC_2.0 (2) <br> 5: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (3) <br> 6: 00000000 0 FUNC GLOBAL DEFAULT UND libtest1 <br> 7: 00000000 0 FUNC GLOBAL DEFAULT UND dlopen@GLIBC_2.1 (4) <br> 8: 00000000 0 FUNC GLOBAL DEFAULT UND fprintf@GLIBC_2.0 (3) <br> 9: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.0 (3) <br> 10: 0804a034 0 NOTYPE GLOBAL DEFAULT ABS _end <br> 11: 0804a028 0 NOTYPE GLOBAL DEFAULT ABS _edata <br> 12: 0804879c 4 OBJECT GLOBAL DEFAULT 15 _IO_stdin_used <br> 13: 0804a028 4 OBJECT GLOBAL DEFAULT 24 stderr@GLIBC_2.0 (3) <br> 14: 0804a028 0 NOTYPE GLOBAL DEFAULT ABS __bss_start <br> 15: 080484b4 0 FUNC GLOBAL DEFAULT 11 _init <br> 16: 0804877c 0 FUNC GLOBAL DEFAULT 14 _fini <br></code> <br>  In addition to other functions necessary for the correct loading / unloading of the program, you can find familiar names: libtest1, libtest2, dlopen, fprintf, puts, dlclose.  For all of them, the type is FUNC and the fact that they are not defined in this module - the section index is marked as UND. <br><br>  The ‚Äú.rel.dyn‚Äù and ‚Äú.rel.plt‚Äù sections are redeployment tables for those .dynsym characters for which relocation is generally necessary when linking. <br><br> <code>Relocation section '.rel.dyn' at offset 0x464 contains 2 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 08049ff0 00000206 R_386_GLOB_DAT 00000000 __gmon_start__ <br> 0804a028 00000d05 R_386_COPY 0804a028 stderr <br> <br> Relocation section '.rel.plt' at offset 0x474 contains 8 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 0804a000 00000107 R_386_JUMP_SLOT 00000000 libtest2 <br> 0804a004 00000207 R_386_JUMP_SLOT 00000000 __gmon_start__ <br> 0804a008 00000407 R_386_JUMP_SLOT 00000000 dlclose <br> 0804a00c 00000507 R_386_JUMP_SLOT 00000000 __libc_start_main <br> 0804a010 00000607 R_386_JUMP_SLOT 00000000 libtest1 <br> 0804a014 00000707 R_386_JUMP_SLOT 00000000 dlopen <br> 0804a018 00000807 R_386_JUMP_SLOT 00000000 fprintf <br> 0804a01c 00000907 R_386_JUMP_SLOT 00000000 puts <br></code> <br>  What is the difference between these tables in terms of dynamic function layout?  This is the topic of the next section. <br><br><h4>  How are shared ELF libraries arranged? </h4><br>  The compilation of the libtest1.so and libtest2.so libraries was somewhat different.  libtest2.so was compiled with the ‚ÄìfPIC key (generate a Position Independent Code).  Let's see how it affected the tables of dynamic symbols for these two modules (use readelf): <br><br> <code>Symbol table '.dynsym' contains 11 entries: <br> Num: Value Size Type Bind Vis Ndx Name <br> 0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br> 1: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ <br> 2: 00000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses <br> 3: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.0 (2) <br> 4: 00000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@GLIBC_2.1.3 (3) <br> 5: 00002014 0 NOTYPE GLOBAL DEFAULT ABS _end <br> 6: 0000200c 0 NOTYPE GLOBAL DEFAULT ABS _edata <br> 7: 0000043c 32 FUNC GLOBAL DEFAULT 11 libtest1 <br> 8: 0000200c 0 NOTYPE GLOBAL DEFAULT ABS __bss_start <br> 9: 0000031c 0 FUNC GLOBAL DEFAULT 9 _init <br> 10: 00000498 0 FUNC GLOBAL DEFAULT 12 _fini <br> <br> Symbol table '.dynsym' contains 11 entries: <br> Num: Value Size Type Bind Vis Ndx Name <br> 0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br> 1: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ <br> 2: 00000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses <br> 3: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.0 (2) <br> 4: 00000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@GLIBC_2.1.3 (3) <br> 5: 00002018 0 NOTYPE GLOBAL DEFAULT ABS _end <br> 6: 00002010 0 NOTYPE GLOBAL DEFAULT ABS _edata <br> 7: 00002010 0 NOTYPE GLOBAL DEFAULT ABS __bss_start <br> 8: 00000304 0 FUNC GLOBAL DEFAULT 9 _init <br> 9: 0000043c 52 FUNC GLOBAL DEFAULT 11 libtest2 <br> 10: 000004a8 0 FUNC GLOBAL DEFAULT 12 _fini <br></code> <br>  So, the dynamic symbol tables for both libraries differ only in the order of the symbols themselves.  It can be seen that both of them use the undefined function puts (), and provide libtest1 () or libtest2 ().  How have relocations changed? <br><br> <code>Relocation section '.rel.dyn' at offset 0x2cc contains 8 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 00000445 00000008 R_386_RELATIVE <br> 00000451 00000008 R_386_RELATIVE <br> 00002008 00000008 R_386_RELATIVE <br> 0000044a 00000302 R_386_PC32 00000000 puts <br> 00000456 00000302 R_386_PC32 00000000 puts <br> 00001fe8 00000106 R_386_GLOB_DAT 00000000 __gmon_start__ <br> 00001fec 00000206 R_386_GLOB_DAT 00000000 _Jv_RegisterClasses <br> 00001ff0 00000406 R_386_GLOB_DAT 00000000 __cxa_finalize <br> <br> Relocation section '.rel.plt' at offset 0x30c contains 2 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 00002000 00000107 R_386_JUMP_SLOT 00000000 __gmon_start__ <br> 00002004 00000407 R_386_JUMP_SLOT 00000000 __cxa_finalize <br></code> <br>  For libtest1.so, the relocation for the puts () function occurs twice in the ‚Äú.rel.dyn‚Äù section.  Let's look at these places directly in the module using a disassembler.  It is necessary to find the libtest1 () function in which the double call to puts () occurs.  Use objdump ‚ÄìD: <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">0000043</span></span>c &lt;libtest1&gt;: <span class="hljs-number"><span class="hljs-number">43</span></span>c: <span class="hljs-number"><span class="hljs-number">55</span></span> push %ebp <span class="hljs-number"><span class="hljs-number">43</span></span>d: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %esp,%ebp <span class="hljs-number"><span class="hljs-number">43</span></span>f: <span class="hljs-number"><span class="hljs-number">83</span></span> ec <span class="hljs-number"><span class="hljs-number">08</span></span> sub $0x8,%esp <span class="hljs-number"><span class="hljs-number">442</span></span>: c7 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> b4 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> movl $0x4b4,(%esp) <span class="hljs-number"><span class="hljs-number">449</span></span>: e8 fc ff ff ff call <span class="hljs-number"><span class="hljs-number">44</span></span>a &lt;libtest1+<span class="hljs-number"><span class="hljs-number">0xe</span></span>&gt; <span class="hljs-number"><span class="hljs-number">44</span></span>e: c7 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> e0 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> movl $0x4e0,(%esp) <span class="hljs-number"><span class="hljs-number">455</span></span>: e8 fc ff ff ff call <span class="hljs-number"><span class="hljs-number">456</span></span> &lt;libtest1+<span class="hljs-number"><span class="hljs-number">0x1a</span></span>&gt; <span class="hljs-number"><span class="hljs-number">45</span></span>a: c9 leave <span class="hljs-number"><span class="hljs-number">45</span></span>b: c3 ret <span class="hljs-number"><span class="hljs-number">45</span></span>c: <span class="hljs-number"><span class="hljs-number">90</span></span> nop <span class="hljs-number"><span class="hljs-number">45</span></span>d: <span class="hljs-number"><span class="hljs-number">90</span></span> nop <span class="hljs-number"><span class="hljs-number">45</span></span>e: <span class="hljs-number"><span class="hljs-number">90</span></span> nop <span class="hljs-number"><span class="hljs-number">45</span></span>f: <span class="hljs-number"><span class="hljs-number">90</span></span> nop</code> </pre><br>  We have two relative CALL instructions (code E8) with operands 0xFFFFFFFC.  A relative CALL with such an operand is meaningless, since, in essence, it transfers control one byte ahead relative to the address of the CALL instruction.  If you look at the relocation offset for puts () in the ‚Äú.rel.dyn‚Äù section, you will find that they apply to the operand of the CALL instruction.  Thus, in both cases of accessing puts (), the bootloader will simply overwrite 0xFFFFFFFC so that the CALL jumps to the correct address of the puts () function. <br>  This is how relocation of type R_386_PC32 works. <br><br>  Now pay attention to libtest2.so: <br><br> <code>Relocation section '.rel.dyn' at offset 0x2cc contains 4 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 0000200c 00000008 R_386_RELATIVE <br> 00001fe8 00000106 R_386_GLOB_DAT 00000000 __gmon_start__ <br> 00001fec 00000206 R_386_GLOB_DAT 00000000 _Jv_RegisterClasses <br> 00001ff0 00000406 R_386_GLOB_DAT 00000000 __cxa_finalize <br> <br> Relocation section '.rel.plt' at offset 0x2ec contains 3 entries: <br> Offset Info Type Sym.Value Sym. Name <br> 00002000 00000107 R_386_JUMP_SLOT 00000000 __gmon_start__ <br> 00002004 00000307 R_386_JUMP_SLOT 00000000 puts <br> 00002008 00000407 R_386_JUMP_SLOT 00000000 __cxa_finalize <br></code> <br>  The call to puts () is mentioned only once, and, moreover, in the ‚Äú.rel.plt‚Äù section.  Let's look at the assembler and debug it: <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">0000043</span></span>c &lt;libtest2&gt;: <span class="hljs-number"><span class="hljs-number">43</span></span>c: <span class="hljs-number"><span class="hljs-number">55</span></span> push %ebp <span class="hljs-number"><span class="hljs-number">43</span></span>d: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %esp,%ebp <span class="hljs-number"><span class="hljs-number">43</span></span>f: <span class="hljs-number"><span class="hljs-number">53</span></span> push %ebx <span class="hljs-number"><span class="hljs-number">440</span></span>: <span class="hljs-number"><span class="hljs-number">83</span></span> ec <span class="hljs-number"><span class="hljs-number">04</span></span> sub $0x4,%esp <span class="hljs-number"><span class="hljs-number">443</span></span>: e8 ef ff ff ff call <span class="hljs-number"><span class="hljs-number">437</span></span> &lt;__i686.get_pc_thunk.bx&gt; <span class="hljs-number"><span class="hljs-number">448</span></span>: <span class="hljs-number"><span class="hljs-number">81</span></span> c3 ac <span class="hljs-number"><span class="hljs-number">1</span></span>b <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> add $0x1bac,%ebx <span class="hljs-number"><span class="hljs-number">44</span></span>e: <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">83</span></span> d0 e4 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x1b30</span></span>(%ebx),%eax <span class="hljs-number"><span class="hljs-number">454</span></span>: <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> mov %eax,(%esp) <span class="hljs-number"><span class="hljs-number">457</span></span>: e8 f8 fe ff ff call <span class="hljs-number"><span class="hljs-number">354</span></span> &lt;puts@plt&gt; <span class="hljs-number"><span class="hljs-number">45</span></span>c: <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">83</span></span> fc e4 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x1b04</span></span>(%ebx),%eax <span class="hljs-number"><span class="hljs-number">462</span></span>: <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> mov %eax,(%esp) <span class="hljs-number"><span class="hljs-number">465</span></span>: e8 ea fe ff ff call <span class="hljs-number"><span class="hljs-number">354</span></span> &lt;puts@plt&gt; <span class="hljs-number"><span class="hljs-number">46</span></span>a: <span class="hljs-number"><span class="hljs-number">83</span></span> c4 <span class="hljs-number"><span class="hljs-number">04</span></span> add $0x4,%esp <span class="hljs-number"><span class="hljs-number">46</span></span>d: <span class="hljs-number"><span class="hljs-number">5</span></span>b pop %ebx <span class="hljs-number"><span class="hljs-number">46</span></span>e: <span class="hljs-number"><span class="hljs-number">5</span></span>d pop %ebp <span class="hljs-number"><span class="hljs-number">46</span></span>f: c3 ret</code> </pre><br>  Operands of CALL instructions are already different and meaningful, which means that they indicate something.  This is no longer just padding.  It is also useful to note that before calling most puts (), writing 0x1FF4 (0x1BAC + 0x448) to the EBX register takes place.  The debugger helps to recognize the initial EBX value of 0x448.  So it will be useful somewhere further.  The address 0x354 leads us to a very interesting section ‚Äú.plt‚Äù, which, like ‚Äú.text‚Äù, is marked as executable.  Here she is: <br><br><pre> <code class="hljs perl">Disassembly of section .plt: <span class="hljs-number"><span class="hljs-number">00000334</span></span> &lt;__gmon_start_<span class="hljs-number"><span class="hljs-number">_</span></span>@plt-<span class="hljs-number"><span class="hljs-number">0x10</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">334</span></span>: ff b3 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> pushl <span class="hljs-number"><span class="hljs-number">0x4</span></span>(%ebx) <span class="hljs-number"><span class="hljs-number">33</span></span>a: ff a3 08 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> jmp *<span class="hljs-number"><span class="hljs-number">0x8</span></span>(%ebx) <span class="hljs-number"><span class="hljs-number">340</span></span>: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> add %al,(%eax) ... <span class="hljs-number"><span class="hljs-number">00000344</span></span> &lt;__gmon_start_<span class="hljs-number"><span class="hljs-number">_</span></span>@plt&gt;: <span class="hljs-number"><span class="hljs-number">344</span></span>: ff a3 0c <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> jmp *<span class="hljs-number"><span class="hljs-number">0xc</span></span>(%ebx) <span class="hljs-number"><span class="hljs-number">34</span></span>a: <span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> $0<span class="hljs-keyword"><span class="hljs-keyword">x</span></span><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span>f: e9 e<span class="hljs-number"><span class="hljs-number">0</span></span> ff ff ff jmp <span class="hljs-number"><span class="hljs-number">334</span></span> &lt;_init+<span class="hljs-number"><span class="hljs-number">0x30</span></span>&gt; <span class="hljs-number"><span class="hljs-number">00000354</span></span> &lt;puts@plt&gt;: <span class="hljs-number"><span class="hljs-number">354</span></span>: ff a3 <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> jmp *<span class="hljs-number"><span class="hljs-number">0x10</span></span>(%ebx) <span class="hljs-number"><span class="hljs-number">35</span></span>a: <span class="hljs-number"><span class="hljs-number">68</span></span> 08 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> $0x8 <span class="hljs-number"><span class="hljs-number">35</span></span>f: e9 d<span class="hljs-number"><span class="hljs-number">0</span></span> ff ff ff jmp <span class="hljs-number"><span class="hljs-number">334</span></span> &lt;_init+<span class="hljs-number"><span class="hljs-number">0x30</span></span>&gt; <span class="hljs-number"><span class="hljs-number">00000364</span></span> &lt;__cxa_finalize@plt&gt;: <span class="hljs-number"><span class="hljs-number">364</span></span>: ff a3 <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> jmp *<span class="hljs-number"><span class="hljs-number">0x14</span></span>(%ebx) <span class="hljs-number"><span class="hljs-number">36</span></span>a: <span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> $0x1<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>f: e9 c<span class="hljs-number"><span class="hljs-number">0</span></span> ff ff ff jmp <span class="hljs-number"><span class="hljs-number">334</span></span> &lt;_init+<span class="hljs-number"><span class="hljs-number">0x30</span></span>&gt;</code> </pre><br>  At the address of interest to us 0x354 we find three instructions.  In the first of these, an unconditional jump occurs at the address pointed to by EBX (0x1FF4) plus 0x10.  Having made simple calculations, we will receive value of the pointer 0x2004.  These addresses fall into the ‚Äú.got.plt‚Äù section. <br><br><pre> <code class="hljs perl">Disassembly of section .got.plt: <span class="hljs-number"><span class="hljs-number">00001</span></span>ff4 &lt;.got.plt&gt;: <span class="hljs-number"><span class="hljs-number">1</span></span>ff4: <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>f <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> %bl,(%edi) ... <span class="hljs-number"><span class="hljs-number">1</span></span>ffe: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> add %al,(%eax) <span class="hljs-number"><span class="hljs-number">2000</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>a dec %edx <span class="hljs-number"><span class="hljs-number">2001</span></span>: <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> add (%eax),%eax <span class="hljs-number"><span class="hljs-number">2003</span></span>: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>a <span class="hljs-number"><span class="hljs-number">03</span></span> add %bl,<span class="hljs-number"><span class="hljs-number">0x3</span></span>(%edx) <span class="hljs-number"><span class="hljs-number">2006</span></span>: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> add %al,(%eax) <span class="hljs-number"><span class="hljs-number">2008</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>a <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> $0x3 ...</code> </pre><br>  The most interesting thing is found when we deny this pointer and, finally, we get the unconditional jump address, equal to 0x35A.  But, this is, in fact, the following instruction!  Why was it necessary to perform such complex manipulations and refer to the ‚Äú.got.plt‚Äù section in order to simply move on to the next instruction?  What is PLT and GOT? <br><br>  <b>PLT (Procedure Linkage Table)</b> is a procedure layout table.  It is present in executable and shared modules.  This is an array of stubs, one for each function imported. <br><br><pre> <code class="hljs perl">PLT[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]: jmp *GOT[n+<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-comment"><span class="hljs-comment">#n @push n as a signal to the resolver jmp PLT[0]</span></span></code> </pre><br>  Calling a function at the PLT [n + 1] address will result in an indirect control transition at the GOT address [n + 3].  On the first call, GOT [n + 3] points back to PLT [n + 1] + 6, which is the PUSH \ JMP sequence to PLT [0].  Passing through PLT [0], the linker uses the stored stack argument to determine 'n' and then resolves the 'n' character.  Then the linker corrects the GOT [n + 3] value so that it points directly to the target subroutine, and eventually calls it.  Each subsequent PLT call [n + 1] will be directed to the target subroutine without such permission of its address via the JMP instruction. <br><br>  The first PLT element is special and is used to jump to the dynamic address resolution code. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">PLT</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">GOT</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GOT</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[2]</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">points</span></span> to resolver()</code> </pre><br>  Control is transferred to the linker code.  The 'n' is already on the stack and the GOT [1] address is added to the same place.  Thus, the linker (located in /lib/ld-linux.so.2) can determine which library requires its services. <br><br>  <b>GOT (Global Offset Table)</b> is a global offset table.  Its first three elements are reserved.  At the first GOT initialization, all its elements that relate to address resolution in the PLT point back to PLT [0]. <br><br>  These special items are: <br><ul><li>  GOT [0] list of items used by the loader </li><li>  GOT [1] pointer to relocation table of this module </li><li>  GOT [2] pointer to the loader code from the ld-linux.so.2 library </li><li>  Got [3] </li><li>  ... followed by auxiliary values ‚Äã‚Äãfor indirectly calling each of the imported functions </li><li>  GOT [3 + M] </li><li>  GOT [3 + M + 1] </li><li>  ... followed by indirect pointers for references to global variables, one for each such character </li></ul>  Each library and executable has its own PLT and GOT. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/addcce52/6cdeb9a7/d911801a/6cf8cf0c.png"></div><br>  This is how relocation of type R_386_JUMP_SLOT, which was used in the library libtest2.so, works.  The remaining types of relocations are static layout, so we will not be useful. <br><br>  In the methods for resolving the call of imported functions, there is a difference between the code that depends on the position of loading into memory and is not dependent on it (PIC). <br><br><h4>  Important conclusions </h4><br>  We make some useful conclusions: <br><ol><li>  All information on imported and exported functions can be obtained in the ‚Äú.dynsym‚Äù section. </li><li>  If the module was compiled in PIC mode (-fPIC key), then calls to imported functions will be made through PLT and GOT, relocation will be made only once for each function and will be used for the first instruction of a specific element in PLT.  Information on the relocation itself can be found in the ‚Äú.rel.plt‚Äù section. </li><li>  If the ‚ÄìfPIC key was not used when compiling the library, then relocations will be performed on the operand of each relative CALL instruction as many times as there are calls to some imported function in the code.  Information on the relocation itself can be found in the ‚Äú.rel.dyn‚Äù section. </li></ol><br>  <i>Note:</i> the compilation key ‚ÄìfPIC is mandatory for the 64-bit architecture.  That is, in 64-bit libraries, the resolution of calls to imported functions is always done through PLT \ GOT.  Plus, on this architecture, the relocations are called ‚Äú.rela.plt‚Äù and ‚Äú.rela.dyn‚Äù. <br><br><h4>  The long-awaited decision </h4><br>  To redirect an imported function in a dynamically composable library, you need to know the following: <br><ol><li>  File system path to this library </li><li>  The virtual address where it was loaded </li><li>  Name of the function being replaced </li><li>  Address of the substitute function </li></ol>  You also need to get the address of the original function in order to perform the reverse redirection and, thus, return everything to its place. <br><br>  The prototype of the redirect function in C comes out as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library_filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library_address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *function_name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *substitution_address)</span></span></span></span>;</code> </pre><br><br><h4>  Redirection algorithm </h4><br>  Here is the algorithm for the redirection function: <br><ol><li>  Open the library file. </li><li>  We remember the symbol index in the ‚Äú.dynsym‚Äù section, whose name corresponds to the name of the function we are looking for. </li><li>  Look through the ‚Äú.rel.plt‚Äù section and look for a relocation for the symbol with the specified index. </li><li>  If such a symbol is found, we retain the original address, then to return it from the function, and write the address of the substitute function to the place specified in the relocation.  This location is calculated as the sum of the library load address in memory and the offset in relocation.  Everything.  The function address has been changed.  Redirection will occur whenever the library calls this function.  Exit the function and return the address of the original. </li><li>  If such a symbol in the ‚Äú.rel.plt‚Äù section is not found, then look for it in the ‚Äúrel.dyn‚Äù section by the same principle.  But, it must be remembered that in the relocations section ‚Äúrel.dyn‚Äù the symbol with the desired index may occur more than once.  Therefore, it is impossible to complete the search cycle after the first redirect.  But the address of the original can be remembered at the first coincidence of the index and no longer calculate - it still does not change. </li><li>  We return the address of the original function or NULL, if the function with the desired name was not found. </li></ol><br>  Below is the code for this function in C: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> *elf_hook(<span class="hljs-type"><span class="hljs-type">char</span></span> const *module_filename, <span class="hljs-type"><span class="hljs-type">void</span></span> const *module_address, <span class="hljs-type"><span class="hljs-type">char</span></span> const *<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">void</span></span> const *substitution) { static size_t pagesize; <span class="hljs-type"><span class="hljs-type">int</span></span> descriptor; //file descriptor <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> shared module Elf_Shdr *dynsym = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, // ".dynsym" section <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> *rel_plt = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, // ".rel.plt" section <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> *rel_dyn = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; // ".rel.dyn" section <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> Elf_Sym *symbol = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; //symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symbol named "name" Elf_Rel *rel_plt_table = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, //<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ".rel.plt" entries *rel_dyn_table = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ".rel.dyn" entries size_t i, name_index = <span class="hljs-number"><span class="hljs-number">0</span></span>, //<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> symbol named "name" <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ".dyn.sym" rel_plt_amount = <span class="hljs-number"><span class="hljs-number">0</span></span>, // amount <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ".rel.plt" entries rel_dyn_amount = <span class="hljs-number"><span class="hljs-number">0</span></span>, // amount <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ".rel.dyn" entries *name_address = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; //address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> relocation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symbol named "name" <span class="hljs-type"><span class="hljs-type">void</span></span> *original = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; //address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the symbol being substituted <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> == module_address || <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> == <span class="hljs-type"><span class="hljs-type">name</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> == substitution) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pagesize) pagesize = sysconf(_SC_PAGESIZE); descriptor = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(module_filename, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( section_by_type(descriptor, SHT_DYNSYM, &amp;dynsym) || //<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> ".dynsym" section symbol_by_name(descriptor, dynsym, <span class="hljs-type"><span class="hljs-type">name</span></span>, &amp;symbol, &amp;name_index) || //actually, we need <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> symbol named "name" <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the ".dynsym" <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> section_by_name(descriptor, REL_PLT, &amp;rel_plt) || //<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> ".rel.plt" (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>-<span class="hljs-type"><span class="hljs-type">bit</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ".rela.plt" (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>-<span class="hljs-type"><span class="hljs-type">bit</span></span>) section section_by_name(descriptor, REL_DYN, &amp;rel_dyn) //<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> ".rel.dyn" (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>-<span class="hljs-type"><span class="hljs-type">bit</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ".rela.dyn" (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>-<span class="hljs-type"><span class="hljs-type">bit</span></span>) section ) { //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> something went wrong free(dynsym); free(rel_plt); free(rel_dyn); free(symbol); <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(descriptor); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original; } //<span class="hljs-keyword"><span class="hljs-keyword">release</span></span> the data used free(dynsym); free(symbol); rel_plt_table = (Elf_Rel *)(((size_t)module_address) + rel_plt-&gt;sh_addr); //init the ".rel.plt" <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> rel_plt_amount = rel_plt-&gt;sh_size / sizeof(Elf_Rel); //<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> its size rel_dyn_table = (Elf_Rel *)(((size_t)module_address) + rel_dyn-&gt;sh_addr); //init the ".rel.dyn" <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> rel_dyn_amount = rel_dyn-&gt;sh_size / sizeof(Elf_Rel); //<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> its size //<span class="hljs-keyword"><span class="hljs-keyword">release</span></span> the data used free(rel_plt); free(rel_dyn); //<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> descriptor <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(descriptor); //now w<span class="hljs-string"><span class="hljs-string">e've got ".rel.plt" (needed for PIC) table and ".rel.dyn" (for non-PIC) table and the symbol'</span></span>s <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rel_plt_amount; ++i) //lookup the ".rel.plt" <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ELF_R_SYM(rel_plt_table[i].r_info) == name_index) //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> the symbol <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> substitute <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ".rel.plt" { original = (<span class="hljs-type"><span class="hljs-type">void</span></span> *)*(size_t *)(((size_t)module_address) + rel_plt_table[i].r_offset); //save the original <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> address *(size_t *)(((size_t)module_address) + rel_plt_table[i].r_offset) = (size_t)substitution; //<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> replace it <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the substitutional break; //the target symbol appears <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ".rel.plt" <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> once } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (original) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original; //we will <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> here <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>-<span class="hljs-type"><span class="hljs-type">bit</span></span> non-PIC module <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rel_dyn_amount; ++i) //lookup the ".rel.dyn" <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ELF_R_SYM(rel_dyn_table[i].r_info) == name_index) //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> the symbol <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> substitute <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ".rel.dyn" { name_address = (size_t *)(((size_t)module_address) + rel_dyn_table[i].r_offset); //<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the relocation address (address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a relative <span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> (<span class="hljs-number"><span class="hljs-number">0xE8</span></span>) instruction<span class="hljs-string"><span class="hljs-string">'s argument) if (!original) original = (void *)(*name_address + (size_t)name_address + sizeof(size_t)); //calculate an address of the original function by a relative CALL (0xE8) instruction'</span></span>s argument mprotect((<span class="hljs-type"><span class="hljs-type">void</span></span> *)(((size_t)name_address) &amp; (((size_t)<span class="hljs-number"><span class="hljs-number">-1</span></span>) ^ (pagesize - <span class="hljs-number"><span class="hljs-number">1</span></span>))), pagesize, PROT_READ | PROT_WRITE); //mark a memory page that contains the relocation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> writable <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; *name_address = (size_t)substitution - (size_t)name_address - sizeof(size_t); //calculate a <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> relative <span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> (<span class="hljs-number"><span class="hljs-number">0xE8</span></span>) instruction<span class="hljs-string"><span class="hljs-string">'s argument for the substitutional function and write it down mprotect((void *)(((size_t)name_address) &amp; (((size_t)-1) ^ (pagesize - 1))), pagesize, PROT_READ | PROT_EXEC); //mark a memory page that contains the relocation back as executable if (errno) //if something went wrong { *name_address = (size_t)original - (size_t)name_address - sizeof(size_t); //then restore the original function address return NULL; } } return original; }</span></span></code> </pre><br>  Full implementation of this feature with test examples is available for <a href="">download</a> . <br><br>  Rewrite our test program: <br><br><pre> <code class="hljs lua">#include &lt;stdio.h&gt; #include &lt;dlfcn.h&gt; #include <span class="hljs-string"><span class="hljs-string">"elf_hook.h"</span></span> #define LIBTEST1_PATH <span class="hljs-string"><span class="hljs-string">"libtest1.so"</span></span> //position dependent code (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> bit only) #define LIBTEST2_PATH <span class="hljs-string"><span class="hljs-string">"libtest2.so"</span></span> //position independent code void libtest1(); //from libtest1.so void libtest2(); //from libtest2.so int hooked_puts(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> const *s) { puts(s); //calls the original puts() from libc.so because our main executable module called <span class="hljs-string"><span class="hljs-string">"test"</span></span> is intact by hook puts(<span class="hljs-string"><span class="hljs-string">"is HOOKED!"</span></span>); } int main() { void *handle1 = dlopen(LIBTEST1_PATH, RTLD_LAZY); void *handle2 = dlopen(LIBTEST2_PATH, RTLD_LAZY); void *original1, *original2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NULL == handle1 || NULL == handle2) fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to open \"%s\" or \"%s\"!\n"</span></span>, LIBTEST1_PATH, LIBTEST2_PATH); libtest1(); //calls puts() from libc.so twice libtest2(); //calls puts() from libc.so twice puts(<span class="hljs-string"><span class="hljs-string">"-----------------------------"</span></span>); original1 = elf_hook(LIBTEST1_PATH, LIBRARY_ADDRESS_BY_HANDLE(handle1), <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, hooked_puts); original2 = elf_hook(LIBTEST2_PATH, LIBRARY_ADDRESS_BY_HANDLE(handle2), <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, hooked_puts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NULL == original1 || NULL == original2) fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Redirection failed!\n"</span></span>); libtest1(); //calls hooked_puts() twice libtest2(); //calls hooked_puts() twice puts(<span class="hljs-string"><span class="hljs-string">"-----------------------------"</span></span>); original1 = elf_hook(LIBTEST1_PATH, LIBRARY_ADDRESS_BY_HANDLE(handle1), <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, original1); original2 = elf_hook(LIBTEST2_PATH, LIBRARY_ADDRESS_BY_HANDLE(handle2), <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, original2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NULL == original1 || original1 != original2) //both pointers should contain hooked_puts() address now fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Restoration failed!\n"</span></span>); libtest1(); //again calls puts() from libc.so twice libtest2(); //again calls puts() from libc.so twice dlclose(handle1); dlclose(handle2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Compile: <br><br><pre> <code class="bash hljs">gcc -g3 -m32 -shared -o libtest1.so libtest1.c gcc -g3 -m32 -fPIC -shared -o libtest2.so libtest2.c gcc -g3 -m32 -L<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span> -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.c elf_hook.c -ltest1 -ltest2 -ldl</code> </pre><br>  And run: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LD_LIBRARY_PATH=<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:<span class="hljs-variable"><span class="hljs-variable">$LD_LIBRARY_PATH</span></span> ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre><br><br>  The output we get the following: <br><br> <code>libtest1: 1st call to the original puts() <br> libtest1: 2nd call to the original puts() <br> libtest2: 1st call to the original puts() <br> libtest2: 2nd call to the original puts() <br> ----------------------------- <br> libtest1: 1st call to the original puts() <br> is HOOKED! <br> libtest1: 2nd call to the original puts() <br> is HOOKED! <br> libtest2: 1st call to the original puts() <br> is HOOKED! <br> libtest2: 2nd call to the original puts() <br> is HOOKED! <br> ----------------------------- <br> libtest1: 1st call to the original puts() <br> libtest1: 2nd call to the original puts() <br> libtest2: 1st call to the original puts() <br> libtest2: 2nd call to the original puts() <br></code> <br>  That indicates the complete implementation of the task set at the very beginning.  Hooray! <br><br><h5>  How to learn the address on which the shared library was loaded? </h5><br>  This very interesting question arises upon careful consideration of the prototype function for redirection.  After some research, I was able to find a way to determine the address of the library load by its handle, which is returned by the dlopen () function.  This is done in such a macro: <br><br> <code>#define LIBRARY_ADDRESS_BY_HANDLE(dlhandle) ((NULL == dlhandle) ? NULL : (void*)*(size_t const*)(dlhandle)) <br></code> <br><br><h5>  How to record and restore the address of the new function? </h5><br>  There is no problem with rewriting addresses that are indicated by relocations from the ‚Äú.rel.plt‚Äù section.  In essence, the operand of the JMP instruction of the corresponding element from the ‚Äú.plt‚Äù section is rewritten.  And the operands of such an instruction are simply addresses. <br><br>  The situation is more interesting with the use of relocations to operands of relative CALL instructions (code E8).  Jump addresses in them are calculated by the formula: <br><br> <code>address_of_a_function = CALL_argument + address_of_the_next_instruction <br></code> <br>  So we can find out the address of the original function.     ,        CALL,      : <br><br> <code>CALL_argument = address_of_a_function - address_of_the_next_instruction <br></code> <br>  ‚Äú.rel.dyn‚Äù   ,   ‚ÄúRE‚Äù,  ,        .       ,            .      mprotect().     ‚Äì   ,  .       .    :         (    ): <br><br> <code>page_address = (size_t)relocation_address &amp; ( ((size_t) -1) ^ (pagesize - 1) ); <br></code> <br> ,    4096 (0x1000)   32-      : <br><br> <code>page_address = (size_t)relocation_address &amp; (0xFFFFFFFF ^ 0xFFF) = (size_t)relocation_address &amp; 0xFFFFF000; <br></code> <br>   ,  ,  sysconf(_SC_PAGESIZE). <br><br><h5>  Usage example </h5><br>      plug-in  Firefox,        , , Adobe Flash plug-in' (libflashplayer.so).  ,     Adobe Flash  Internet   Firefox           plug-in'. <br><br>  <b>Good luck!</b> <br><br><h5>  Related Links </h5><br>     <a href="http://apriorit.com/our-experience/articles/9-sd-articles/181-elf-hook"></a> ,    . <ul><li> <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">www.skyfree.org/linux/references/ELF_Format.pdf</a> </li><li> <a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">en.wikipedia.org/wiki/Executable_and_Linkable_Format</a> </li><li> <a href="http://vxheavens.com/lib/vsc06.html">vxheavens.com/lib/vsc06.html</a> </li><li> <a href="http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html">netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html</a> </li><li> <a href="http://www.slideshare.net/sanjivmalik/dynamic-linker-presentation">www.slideshare.net/sanjivmalik/dynamic-linker-presentation</a> </li><li> <a href="http://www.codeproject.com/KB/cpp/shared_object_injection_1.aspx">www.codeproject.com/KB/cpp/shared_object_injection_1.aspx</a> </li><li> <a href="http://www.linuxjournal.com/article/1060">www.linuxjournal.com/article/1060</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/106107/">https://habr.com/ru/post/106107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../106098/index.html">Free magazine VR-Online</a></li>
<li><a href="../106102/index.html">YouTube 2011 is looking for talented performers</a></li>
<li><a href="../106104/index.html">Samsung Omnia 7 (I8700) Video Release on WP7</a></li>
<li><a href="../106105/index.html">W3C warns: HTML 5 for experiments only!</a></li>
<li><a href="../106106/index.html">Stylish informative advertising Windows Phone 7 from LG</a></li>
<li><a href="../106108/index.html">We opened our first online store in 2003</a></li>
<li><a href="../106110/index.html">"The world is full of interesting things"</a></li>
<li><a href="../106113/index.html">Canon's Uniflow 5 system blocks copying operations using the keywords contained in the document.</a></li>
<li><a href="../106114/index.html">ngmoco bought for $ 400 million</a></li>
<li><a href="../106116/index.html">AutoCAD WS: in the cloud and under iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>