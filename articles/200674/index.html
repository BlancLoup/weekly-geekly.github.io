<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transferring files to Java using √òMQ and JZMQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, we are a small company of like-minded people who are developing a product designed to manage data, regardless of their format and storage m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transferring files to Java using √òMQ and JZMQ</h1><div class="post__text post__text-html js-mediator-article">  Greetings, we are a small company of like-minded people who are developing a product designed to manage data, regardless of their format and storage method - <a href="http://arkstore.org/">ArkStore</a> , in our blog we will try to share the experience that we have accumulated during the course of almost two years of development.  The first article I decided to highlight the IO layer and the product called √òMQ (or ZeroMQ).  I will try to tell you how to start using √òMQ and how it can be used to transfer a large amount of data. <br><a name="habracut"></a><br><h5>  Why √òMQ </h5><br>  During the development of our product, we were faced with the task of ‚Äúhow to ensure reliable transfer of a larger amount of data?‚Äù, While it is desirable that the entire IO layer is completely asynchronous, does not eat a large amount of memory and is simple enough.  Initially, since all of our architecture was built using Akka, we used Spray IO (or Akka IO).  But we encountered a number of problems for which there was no adequate solution, for example, the <a href="http://stackoverflow.com/questions/19469515/akka-connection-abort">bug</a> I discovered forced us to create additional <i>Heartbeat</i> messages or to transmit a large amount of service information. <br><br>  In the end, we decided to look in the direction of message brokers.  <b>ActiveMQ</b> , <b>RabbitMQ</b> and <b>√òMQ</b> .  In principle, all brokers solved the task set before us, but we stopped at √òMQ.  ActiveMQ seemed too heavy, and RabbitMQ brought the master node to the initially distributed architecture (without a clear leader). <br><br>  √òMQ supports three basic data transfer patterns: <br><ul><li>  <b>Request-Reply</b> is the simplest common template, we sent a request to the server and received a response.  Classic client-server model. </li><li>  <b>Publish-Subscribe</b> - in this case, the server (publisher) periodically publishes information for its subscribers.  An example is the sensor, which constantly publishes measurement data for all interested clients. </li><li>  <b>Push-Pull</b> - or <b>Parallel Pipeline</b> , allows us to conduct parallel computing.  The server evenly sends messages containing the work (Push) to machines that can make calculations (workers), machines take these messages (Pull), make calculations and give results to the client (Push) interested in the results of calculations (Pull).  <a href="">Picture</a> </li></ul><br>  More details about these templates and √òMQ can be found in the wonderful <a href="http://zguide.zeromq.org/page:all">manual</a> available on the official website. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, we consider only the first template (Request-Reply). <br><br><h5>  We collect √òMQ and JZMQ </h5><br>  Before we go to the code, we need to build √òMQ itself and the binding libraries (Java Bindings). <br><br><h6>  Linux </h6><br>  For CentOS, the process will look like this (should be slightly different for other * nix OSs). <br><br>  Make sure that we have all the necessary libraries: <br><pre><code class="bash hljs">yum install libtool autoconf automake gcc-c++ make e2fsprogs</code> </pre> <br>  We will take and unzip the latest stable version of the library √òMQ from <a href="http://zeromq.org/intro:get-the-software">the</a> developer‚Äôs <a href="http://zeromq.org/intro:get-the-software">site</a> (at the time of writing 3.2.4). <br><pre> <code class="bash hljs">wget http://download.zeromq.org/zeromq-3.2.4.tar.gz tar -xzvf zeromq-3.2.4.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> zeromq-3.2.4</code> </pre><br>  We assemble and install √òMQ, the libraries will go to the / usr / local / lib directory, we will need it in the future. <br><pre> <code class="bash hljs">./configure make sudo make install sudo ldconfig</code> </pre><br>  After we have collected √òMQ we need to collect JZMQ.  To do this, download the latest version from the GIT repository (master or tag, the last tag at the time of writing - 2.2.2). <br><pre> <code class="bash hljs">wget https://github.com/zeromq/jzmq/archive/v2.2.2.zip unzip jzmq-2.2.2.zip <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jzmq-2.2.2 ./autogen.sh ./configure make sudo make install sudo ldconfig</code> </pre><br>  Libraries will also go to the / usr / lib / local directory.  Why is it important?  The fact is that in order to use native libraries, Java needs to know where we can find them. To do this, we need to specify the java.library.path parameter when starting the program.  There are several ways to do this, we can specify it when the application is <b>launched -Djava.library.path = "/ usr / lib / local"</b> , or <a href="http://habrahabr.ru/post/118027/">install</a> it right while the program is running.  We can also use the default java.library.path.  To find out which values ‚Äã‚Äãare set by default, run the following command: <br><br><pre> <code class="bash hljs">java -XshowSettings:properties</code> </pre><br>  In my case it is: <br><pre> <code class="bash hljs">java.library.path = /usr/java/packages/lib/amd64 /usr/lib64 /lib64 /lib /usr/lib</code> </pre><br>  In order for Java to be able to find native libraries, we just need to transfer our libraries to one of these addresses or link them.  Which approach to choose, choose you personally. <br><br>  To find out where the libraries were installed after make install, you just need to run the following commands: <br><pre> <code class="bash hljs">whereis libzmq whereis libjzmq</code> </pre><br><h6>  Windows </h6><br>  The collected dll files for libzmq can be downloaded from the official <a href="http://zeromq.org/distro:microsoft-windows">site</a> , and <a href="http://zeromq.org/bindings:java">here</a> you can find a guide to collecting JZMQ for Windows.  Unfortunately, I could not build libraries using <i>CMAKE</i> , I had to build libzmq and jzmq using Visual Studio 2013. At the same time, it is important that the libraries themselves be built under the architecture corresponding to your JVM (32 or 64 bit) <br><br>  If libzmq.dll and jzmq.dll are added to the PATH, then the JVM should find them automatically. <br><br><h5>  Program </h5><br>  Wow, we were finally able to install and configure √òMQ and JZMQ on our computer!  It is time to let it go.  As an example, we will try to implement the file transfer protocol described in the <a href="http://zguide.zeromq.org/page:all">manual</a> and slightly improve it. <br><br>  To begin, let us describe the requirements for our protocol: <br><ul><li>  The protocol must transmit data asynchronously, without waiting for each time a response from the client about receiving data. </li><li>  The server must be able to work with a large number of clients (be able to identify the client) </li><li>  At the same time, the protocol should carefully handle the memory of the server, without keeping a large amount of data in memory, this is important for both the client and the server, for example, if the client processes the data much slower than it receives it. </li><li>  The protocol must support the cancellation of data transmission. </li><li>  To enable the client to choose the size of the chunks of data he accepts. </li><li>  Support restart of data transfer (for example, if an error occurred and we want to resume data transfer from a certain place, without transferring the entire file again). </li></ul><br>  Let's prepare one gigabyte of "guaranteed random" ‚Ñ¢ data. <br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/urandom of=testdata bs=1M count=1024</code> </pre><br>  Let's measure how long the OS takes to copy the data.  These figures are fairly approximate, but at least we will have some sort of comparison point. <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches time cp testdata testdata2 real 0m7.745s user 0m0.011s sys 0m1.223s</code> </pre><br>  Let's get down to the code.  Customer: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.coldsnipe.example; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.zeromq.ZFrame; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.zeromq.ZMQ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZMQClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      "" private static final int PIPELINE = 10; //  1  , 250. private static final int CHUNK_SIZE = 250000; private final ZMQ.Context zmqContext; public ZMQClient(ZMQ.Context zmqContext) { this.zmqContext = zmqContext; } @Override public void run() { //  ZMQ.Socket,     DEALER socket try (ZMQ.Socket socket = zmqContext.socket(ZMQ.DEALER)) { //            //  ,   1      (drop)   socket.setLinger(1000); //     TCP  socket.connect("tcp://127.0.0.1:6000"); //  ,  Chunks     int credit = PIPELINE; //    long total = 0; //    (Chunks) int chunks = 0; //      long offset = 0; while (!Thread.currentThread().isInterrupted()) { //     "",     //   while (credit &gt; 0) { socket.sendMore("fetch"); socket.sendMore(Long.toString(offset)); socket.send(Integer.toString(CHUNK_SIZE)); offset += CHUNK_SIZE; credit--; } //       ZFrame zFrame = ZFrame.recvFrame(socket); //   ,   if (zFrame == null) { break; } chunks++; credit++; int size = zFrame.getData().length; total += size; zFrame.destroy(); //         //       if (size &lt; CHUNK_SIZE) { break; } } System.out.format("%d chunks received, %d bytes %n", chunks, total); } } }</span></span></code> </pre><br>  The client connects to the server and sends requests for data.  Each message consists of several parts. <br><ol><li>  The command is what we want from the server, in this case there is only one command, <b>fetch</b> is to receive data. </li><li>  Command parameters (if present) - in the case of <b>fetch,</b> this is the indent from the beginning of the file and the size of the piece of data. </li></ol><br>  The client sends these commands to ‚Äúcredit‚Äù, which means that the client will send as many fetch commands as he has ‚Äúcredit‚Äù left.  Credit increases only if the client has successfully processed the data.  In the example, the client does nothing with the data, but we can add a processor to save the data or simulate work using sleep, even if the client processes the data very slowly, there will be no more than ten pieces of data in its queue, 250kb each.  Thus, the client will not be idle while waiting for new data from the server. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.coldsnipe.example; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.zeromq.ZFrame; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.zeromq.ZMQ; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.FileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZMQServer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ZMQ.Context zmqContext; <span class="hljs-comment"><span class="hljs-comment">//         private final Path filePath; public ZMQServer(ZMQ.Context zmqContext, Path filePath) { this.zmqContext = zmqContext; this.filePath = filePath; } @Override public void run() { try { File file = filePath.toFile(); if (!file.exists()) { throw new RuntimeException("File does not exists: " + filePath); } //    , Router   identity , //         try (FileChannel fileChannel = FileChannel.open(filePath)) { try (ZMQ.Socket socket = zmqContext.socket(ZMQ.ROUTER)) { //      localhost  6000  socket.bind("tcp://*:6000"); socket.setLinger(1000); while (!Thread.currentThread().isInterrupted()) { //   -  identity frame ZFrame identity = ZFrame.recvFrame(socket); assert identity != null; //    String command = socket.recvStr(); if (command.equals("fetch")) { //     fetch,   offset     String offsetString = socket.recvStr(); long offset = Long.parseLong(offsetString); String chunkSizeString = socket.recvStr(); int chunkSize = Integer.parseInt(chunkSizeString); int currentChunkSize = chunkSize; //   offset +       //     ,      offset    if (file.length() &lt; (offset + chunkSize)) { currentChunkSize = (int) (file.length() - offset); } if (currentChunkSize &gt; 0) { ByteBuffer byteBuffer = ByteBuffer.allocate(currentChunkSize); fileChannel.read(byteBuffer, offset); byteBuffer.flip(); byte[] bytes = new byte[currentChunkSize]; byteBuffer.get(bytes); //     ZFrame frameToSend = new ZFrame(bytes); //        identity // ,     identity.send(socket, ZFrame.MORE); frameToSend.send(socket, 0); } } } } } } catch (IOException e) { throw new RuntimeException(e); } } }</span></span></code> </pre><br>  Our server can transfer only one file (the link to which it received at startup) and respond to just one command - <b>fetch</b> .  He can distinguish between clients, but clients can only get one single file.  How to improve it, I will write a little lower, but for now the test and measurement results. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.coldsnipe.example; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.Test; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.zeromq.ZMQ; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.URL; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Paths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZMQExampleTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDataExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ZMQ.Context,    1!      //          ZMQ.Context zmqContext = ZMQ.context(1); //     final URL fileUrl = ZMQExampleTest.class.getClassLoader().getResource("testdata"); assert fileUrl != null; Path filePath = Paths.get(fileUrl.toURI()); //        ,     //       long startTime = System.nanoTime(); Thread clientThread = new Thread(new ZMQClient(zmqContext)); Thread serverThread = new Thread(new ZMQServer(zmqContext, filePath)); clientThread.start(); serverThread.start(); clientThread.join(); long estimatedTime = System.nanoTime() - startTime; float timeForTest = estimatedTime / 1000000000F; System.out.format("Elapsed time: %fs%n", timeForTest); //    ,     //          . zmqContext.term(); } }</span></span></code> </pre><br>  Our test starts ZMQ.Context, starts the client and server, and measures the time needed to transfer data.  On the context I want to say separately.  It is the context that is the hidden conductor who controls our sockets inside the process and decides how and when to send the data.  Therefore, a simple rule follows from this - <b>one context per process</b> . <br><br>  Run the test and look at the result. <br><pre> <code class="bash hljs">4295 chunks received, 1073741824 bytes Elapsed time: 1.429522s</code> </pre><br>  Reading one gigabyte took 1.42 seconds.  It's hard for me to say how good this indicator is, but compared to the same Spray IO, √òMQ works 30-40% faster, and the IO load is close to 100% (Spray 85-90), the CPU load is lower by almost a third . <br><br><h5>  We improve the protocol </h5><br>  While our protocol knows only one command, it is enough for a test, but in real conditions we want our server to be able to transfer many different files and provide service information for the client.  To do this, we introduce two new commands: <br><ul><li>  <b>get</b> - a message that the client wants to receive data, must contain what data we want to receive </li><li>  <b>end</b> - the message is sent after the client has finished receiving data, indicates that the server can release the resources associated with the transmitted file. </li></ul><br>  Message handlers in this case might look like this. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(command.equals(<span class="hljs-string"><span class="hljs-string">"get"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// ID  String id = socket.recvStr(); //       BigInteger identityString = new BigInteger(identity.getData()); DataBlob dataBlob = blobMap.get(identityString); if (dataBlob!= null){ //      ,   DataBlob dataBlob.closeSource(); blobMap.remove(identityString); } //     DataBlob dataBlob = dataProvider.getBlob(id); if (dataBlob == null) { log.error("Received wrong get call on server socket, ID [{}]", id); } else { //   ,        DataHeader dataHeader = new DataHeader(id, dataBlob.getSize()); byte[] bytesToSend = FrameHeaderEncoder.encode(dataHeader); ZFrame frameToSend = new ZFrame(bytesToSend); //   DataBlob   blobMap.put(new BigInteger(identity.getData()), dataBlob); //    identity.send(socket, ZFrame.MORE); frameToSend.send(socket, 0); } } else if (command.equals("end")){ BigInteger identityString = new BigInteger(identity.getData()); //  DataBlob    DataBlob dataBlob = blobMap.remove(identityString); if (dataBlob != null) { dataBlob.closeSource(); } }</span></span></code> </pre><br>  In order for us to work with many files, we added new objects to the server. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataBlob </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dataId)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataBlob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String dataId; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, String dataId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dataId= dataId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getData(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDataId; } }</code> </pre><br>  The class implementing DataProvider manages data retrieval, the getBlob method returns us a new DataBlob which is essentially a link to a resource. <br><br>  The implementation of the DataBlob for a file may look like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileDataBlob</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataBlob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FileChannel fileChannel; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileDataBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, String dataId, Path filePath)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(size, dataId); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileChannel = FileChannel.open(filePath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataBlobException(e); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getData(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) { ByteBuffer byteBuffer = ByteBuffer.allocate(length); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fileChannel.read(byteBuffer, position); byteBuffer.flip(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; byteBuffer.get(bytes); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataBlobException(e); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fileChannel.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataBlobException(e); } } }</code> </pre><br>  By adding these two methods, we allow the client to choose which data the client wants to receive and inform the client about the size of the requested data.  We can further improve the protocol, for example, add the ability to send multiple files in a row, add Heartbeat to identify dead clients and free up resources, etc. <br><br><h5>  Conclusion </h5><br>  In the course of this article, I wanted to show how we can use √òMQ in Java.  Currently, in our project, √òMQ is the main message broker, not only for files but also for metadata, showing fairly good results (problems associated with it have not yet been observed). <br><br>  In the next articles I will try to talk about other technologies used in <a href="http://arkstore.org/">ArkStore</a> , while <a href="http://akka.io/">Akka</a> and the Semantic Web are next in line.  Thank you for your attention, I hope the read was at least useful to someone! </div><p>Source: <a href="https://habr.com/ru/post/200674/">https://habr.com/ru/post/200674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200662/index.html">Option of conditional routing in AngularJS</a></li>
<li><a href="../200664/index.html">Why typeof null === 'object'?</a></li>
<li><a href="../200666/index.html">DIY dimmer for modern skilled hands</a></li>
<li><a href="../200668/index.html">Power Management through Mikrotik + Windows Phone</a></li>
<li><a href="../200670/index.html">Optimize long list performance in AngularJS</a></li>
<li><a href="../200676/index.html">Google webmaster - Statistics for the author</a></li>
<li><a href="../200680/index.html">We buy Nexus 5 through Google Play</a></li>
<li><a href="../200682/index.html">API for the Russian public initiative. Step 1: data collection and analysis</a></li>
<li><a href="../200684/index.html">Motorola RAZR V3 - status symbol. How did one clamshell conquer the world</a></li>
<li><a href="../200686/index.html">RSA Security has announced the availability of the NSA-backdoor in their products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>