<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bash scripts, part 8: awk data processing language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bash scripts: start 
 Bash scripts, part 2: loops 
 Bash scripts, part 3: command line options and keys 
 Bash scripts, part 4: input and output 
 Bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bash scripts, part 8: awk data processing language</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="https://habrahabr.ru/company/ruvds/blog/325522/">Bash scripts: start</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/325928/">Bash scripts, part 2: loops</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326328/">Bash scripts, part 3: command line options and keys</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326594/">Bash scripts, part 4: input and output</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326826/">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327248/">Bash scripts, part 6: functions and library development</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327530/">Bash scripts, part 7: sed and word processing</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327754/">Bash scripts, part 8: awk data processing language</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327896/">Bash scripts, part 9: regular expressions</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328346/">Bash scripts, part 10: practical examples</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328436/">Bash scripts, part 11: expect and automate interactive utilities</a> </blockquote><br> <a href="https://habrahabr.ru/company/ruvds/blog/327754/"><img src="https://habrastorage.org/files/803/892/bfe/803892bfe548499aa763df324d40fd01.png"></a> <br><br>  Last time, we talked about the <a href="https://habrahabr.ru/company/ruvds/blog/327530/">sed</a> streaming editor and looked at a lot of text processing examples using it.  Sed is capable of solving many problems, but it also has limitations.  Sometimes you need a more advanced data processing tool, something like a programming language.  In fact, such a tool is awk. <br><a name="habracut"></a><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  The awk utility, or more precisely GNU awk, compared to sed, takes data stream processing to a higher level.  Thanks to awk, we have a programming language at our disposal, rather than a rather modest set of commands given to the editor.  Using the awk programming language, you can do the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Declare variables for data storage. </li><li>  Use arithmetic and string operators to work with data. </li><li>  Use structural elements and control constructs of the language, such as the if-then operator and cycles, which allows for the implementation of complex data processing algorithms. <br></li><li>  Create formatted reports. </li></ul><br>  If we talk only about the ability to create formatted reports that are easy to read and analyze, this is very useful when working with log files that may contain millions of records.  But awk is much more than a reporting tool. <br><br><h2>  <font color="#3AC1EF">Awk call features</font> </h2><br>  The awk call scheme looks like this: <br><br><pre><code class="hljs delphi">$ awk options <span class="hljs-keyword"><span class="hljs-keyword">program</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span></code> </pre> <br>  Awk treats incoming data as a set of records.  Entries are sets of fields.  Simplified, if you do not take into account the possibility of setting up awk and talk about some quite plain text, the lines of which are separated by newline characters, the entry is a string.  A field is a word in a string. <br><br>  Consider the most commonly used awk command line switches: <br><br><blockquote>  <code>-F fs</code> - allows you to specify a delimiter character for fields in the record. <br>  <code>-f file</code> - specifies the name of the file from which to read the awk script. <br>  <code>-v var=value ‚Äî</code> allows you to declare a variable and set its default value, which will be used by awk. <br>  <code>-mf N</code> - sets the maximum number of fields to be processed in the data file. <br>  <code>-mr N ‚Äî</code> sets the maximum record size in the data file. <br>  <code>-W keyword</code> - allows you to set the compatibility mode or awk alert level. </blockquote><br>  The real power of awk is hidden in the part of the call command that is marked above as <code>program</code> .  It points to an awk-script file written by a programmer and intended for reading data, processing it and outputting results. <br><br><h2>  <font color="#3AC1EF">Reading awk scripts from the command line</font> </h2><br>  The awk scripts that can be written directly on the command line are in the form of command texts enclosed in curly braces.  In addition, since awk assumes that the script is a text string, it must be enclosed in single quotes: <br><br><pre> <code class="hljs swift">$ awk '{<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"Welcome to awk command tutorial"</span></span>}'</code> </pre> <br>  Let's run this command ... And nothing will happen. The point here is that we did not specify the data file when we called awk.  In this situation, awk waits for data from <a href="https://habrahabr.ru/company/ruvds/blog/326594/">STDIN</a> .  Therefore, the execution of such a command does not lead to immediately observed effects, but this does not mean that awk does not work - it is waiting for input data from <code>STDIN</code> . <br><br>  If you now type something into the console and press <code>Enter</code> , awk will process the entered data using the script specified when it was started.  Awk processes the text from the input stream line by line; in this way it looks like sed.  In our case, awk does nothing with the data, it only, in response to each new line it receives, displays the text specified in the <code>print</code> command. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a1/9a9/4ca/5a19a94cad5893fc2194fb599cad5422.png"></div><br>  <i><font color="#999999">The first start of awk, displaying the specified text</font></i> <br><br>  Whatever we enter, the result in this case will be the same - the text output. <br>  In order to complete awk, you must pass it the end-of-file (EOF, end-of-file) character.  You can do this by using the keyboard shortcut <code>CTRL + D</code> <br><br>  It is not surprising if this first example seemed to you not particularly impressive.  However, the most interesting is ahead. <br><br><h2>  <font color="#3AC1EF">Positional variables that store field data</font> </h2><br>  One of the main functions of awk is the ability to manipulate data in text files.  This is done by automatically assigning a variable to each element in the line.  By default, awk assigns the following variables to each data field it finds in the record: <br><br><ul><li>  <code>$0 ‚Äî</code> represents the entire line of text (write). </li><li>  <code>$1 ‚Äî</code> first field. </li><li>  <code>$2 ‚Äî</code> second field. </li><li>  <code>$n ‚Äî</code> n-th field. </li></ul><br>  Fields are extracted from text using the delimiter character.  By default, these are whitespace characters like spaces or tabs. <br><br>  Consider the use of these variables in a simple example.  Namely, we will process a file containing several lines (this file is shown in the figure below) using the following command: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/b80/d4a/cf0b80d4a6ddb34d0b2f15c7ea54557a.png"></div><br>  <i><font color="#999999">Output to the console the first field of each line</font></i> <br><br>  The variable used here is <code>$1</code> , which allows you to access the first field of each line and display it on the screen. <br><br>  Sometimes, some files use something other than spaces or tabs as field separators.  We mentioned above the awk <code>-F</code> key, which allows you to specify the separator required for processing a specific file: <br><br><pre> <code class="hljs ruby">$ awk -<span class="hljs-symbol"><span class="hljs-symbol">F:</span></span> <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/803/3b1/2bf8033b122fdf3960311ebb80a67779.png"></div><br>  <i><font color="#999999">Specifying the delimiter character when calling awk</font></i> <br><br>  This command prints the first line elements contained in the <code>/etc/passwd</code> .  Since colons are used as delimiters in this file, this particular character was passed to awk after the <code>-F</code> key. <br><br><h2>  <font color="#3AC1EF">Using multiple commands</font> </h2><br>  An awk call with one word processing command is a very limited approach.  Awk allows you to process data using multi-line scripts.  In order to send an awk multi-line command when calling it from the console, you need to separate its parts with a semicolon: <br><br><pre> <code class="hljs swift">$ echo <span class="hljs-string"><span class="hljs-string">"My name is Tom"</span></span> | awk '{$<span class="hljs-number"><span class="hljs-number">4</span></span>=<span class="hljs-string"><span class="hljs-string">"Adam"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>}'</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8c/5b9/292/a8c5b92921519f181cd5b2383956ffcb.png"></div><br>  <i><font color="#999999">Calling awk from the command line passing a multi-line script to it</font></i> <br><br>  In this example, the first command writes the new value to the variable <code>$4</code> , and the second displays the entire line. <br><br><h2>  <font color="#3AC1EF">Reading the awk script from a file</font> </h2><br>  Awk allows you to store scripts in files and reference them using the <code>-f</code> .  Prepare a file <code>testfile</code> , in which we write the following: <br><br><pre> <code class="hljs perl">{<span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $1 <span class="hljs-string"><span class="hljs-string">" has a  home directory at "</span></span> $6}</code> </pre> <br>  Call awk, specifying this file as a command source: <br><br><pre> <code class="hljs ruby">$ awk -<span class="hljs-symbol"><span class="hljs-symbol">F:</span></span> -f testfile /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0b/532/a2f/b0b532a2f0c6597bb533bda90c747217.png"></div><br>  <i><font color="#999999">Calling awk with a script file</font></i> <br><br>  Here we derive from the <code>/etc/passwd</code> names of users who fall into the <code>$1</code> variable, and their home directories, which fall into <code>$6</code> .  Notice that the script file is set with the <code>-f</code> key, and the field separator, a colon in our case, with the <code>-F</code> key. <br><br>  The script file may contain many commands, while each of them is enough to write a new line, put a semicolon after each is not required. <br>  Here is what it might look like: <br><br><pre> <code class="hljs mel">{ <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> = <span class="hljs-string"><span class="hljs-string">" has a  home directory at "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $1 <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> $6 }</code> </pre> <br>  Here we store the text used when outputting the data received from each line of the file being processed in a variable, and use this variable in the <code>print</code> command.  If you reproduce the previous example, writing this code to the file <code>testfile</code> will <code>testfile</code> the same thing. <br><br><h2>  <font color="#3AC1EF">Execution of commands before data processing begins.</font> </h2><br>  Sometimes you need to perform some actions before the script starts processing records from the input stream.  For example, create a report header or something similar. <br><br>  To do this, you can use the keyword <code>BEGIN</code> .  The commands that follow <code>BEGIN</code> will be executed before data processing begins.  In its simplest form, it looks like this: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>}'</code> </pre> <br>  And here is a slightly more complicated example: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"The File Contents:"</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>}' myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/282/673/c50282673675bee9a49dfd9b6dfe32ea.png"></div><br>  <i><font color="#999999">Execution of commands before data processing begins.</font></i> <br><br>  At first awk executes the <code>BEGIN</code> block, after which the data is processed.  Be careful with single quotes using similar constructs on the command line.  Notice that both the <code>BEGIN</code> block and the thread processing commands are one line in the awk view.  The first single quote delimiting this string is before <code>BEGIN</code> .  The second is after the closing brace of the data processing command. <br><br><h2>  <font color="#3AC1EF">Execution of commands after the end of data processing</font> </h2><br>  The <code>END</code> keyword allows you to specify the commands to be executed after the end of data processing: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"The File Contents:"</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-type"><span class="hljs-type">END</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"End of File"</span></span>}' myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a32/206/c12/a32206c12e4c7628696cb62aed26b775.png"></div><br>  <i>The results of the script, in which there are blocks BEGIN and END</i> <br><br>  After completing the output of the file contents, awk executes the <code>END</code> block commands.  This is a useful feature, with its help, for example, you can create a basement report.  Now we will write a script with the following content and save it in a <code>myscript</code> file: <br><br><pre> <code class="hljs perl">BEGIN { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"The latest list of users and shells"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" UserName \t HomePath"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"-------- \t -------"</span></span> FS=<span class="hljs-string"><span class="hljs-string">":"</span></span> } { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $1 <span class="hljs-string"><span class="hljs-string">" \t "</span></span> $6 } END { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"The end"</span></span> }</code> </pre> <br>  Here, in the <code>BEGIN</code> block, the heading of the tabular report is created.  In the same section, we specify the delimiter character.  After the end of the file processing, thanks to the <code>END</code> block, the system will inform us that the work is finished. <br><br>  Run the script: <br><br><pre> <code class="hljs ruby">$ awk -f myscript  /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/109/070/4fb/1090704fb0f7853ce09f4fdc7d813c9d.png"></div><br>  <i><font color="#999999">Processing the / etc / passwd file with an awk script</font></i> <br><br>  All that we talked about above is only a small part of the awk capabilities.  We continue the development of this useful tool. <br><br><h2>  <font color="#3AC1EF">Built-in variables: setting data processing</font> </h2><br>  The awk utility uses built-in variables that allow you to customize the data processing process and give access to both the processed data and some information about it. <br><br>  We have already considered positional variables - <code>$1</code> , <code>$2</code> , <code>$3</code> , which allow us to extract field values; we worked with some other variables.  In fact, they are quite a lot.  Here are some of the most commonly used: <br><blockquote>  <code>FIELDWIDTHS ‚Äî</code> space <code>FIELDWIDTHS ‚Äî</code> separated list of numbers that defines the exact width of each data field, taking into account field separators. <br>  <code>FS</code> is a variable you already know that allows you to specify a field separator character. <br>  <code>RS ‚Äî</code> variable that allows you to specify a record separator character. <br>  <code>OFS ‚Äî</code> a field separator in the output of an awk script. <br>  <code>ORS ‚Äî</code> separator records on the output of the awk-script. </blockquote><br>  By default, the <code>OFS</code> variable is configured to use a space.  It can be installed as needed for data output purposes: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{<span class="hljs-type"><span class="hljs-type">FS</span></span>=<span class="hljs-string"><span class="hljs-string">":"</span></span>; <span class="hljs-type"><span class="hljs-type">OFS</span></span>=<span class="hljs-string"><span class="hljs-string">"-"</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-number"><span class="hljs-number">6</span></span>,$<span class="hljs-number"><span class="hljs-number">7</span></span>}' /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/f85/5d8/a92f855d88053f7a0538abc1c3b57600.png"></div><br>  <i><font color="#999999">Setting the output field separator</font></i> <br><br>  The <code>FIELDWIDTHS</code> variable allows <code>FIELDWIDTHS</code> to read records without using the field separator character. <br><br>  In some cases, instead of using a field delimiter, the data within the records is located in columns of constant width.  In such cases, it is necessary to set the <code>FIELDWIDTHS</code> variable so that its contents correspond to the data presentation features. <br><br>  When the <code>FIELDWIDTHS</code> variable is <code>FIELDWIDTHS</code> awk will ignore the <code>FS</code> variable and find the data fields according to the width information specified in <code>FIELDWIDTHS</code> . <br><br>  Suppose there is a <code>testfile</code> file containing such data: <br><br><pre> <code class="hljs css">1235<span class="hljs-selector-class"><span class="hljs-selector-class">.9652147</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.91</span></span> 927<span class="hljs-selector-tag"><span class="hljs-selector-tag">-8</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.365217</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.27</span></span> 36257<span class="hljs-selector-class"><span class="hljs-selector-class">.8157492</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span></code> </pre> <br>  It is known that the internal organization of this data corresponds to the 3-5-2-5 pattern, that is, the first field is 3 characters wide, the second is 5, and so on.  Here is a script that allows you to parse such records: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{<span class="hljs-type"><span class="hljs-type">FIELDWIDTHS</span></span>=<span class="hljs-string"><span class="hljs-string">"3 5 2 5"</span></span>}{<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-number"><span class="hljs-number">2</span></span>,$<span class="hljs-number"><span class="hljs-number">3</span></span>,$<span class="hljs-number"><span class="hljs-number">4</span></span>}' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9b/46c/4ae/b9b46c4ae70cc3c2cb2db7107dcdf48e.png"></div><br>  <i><font color="#999999">Using the FIELDWIDTHS variable</font></i> <br><br>  Let's look at what the script displays.  The data is parsed taking into account the value of the variable <code>FIELDWIDTHS</code> , as a result, the numbers and other characters in the lines are broken according to the specified width of the fields. <br><br>  The variables <code>RS</code> and <code>ORS</code> define the order in which records are processed.  By default, <code>RS</code> and <code>ORS</code> set to a newline character.  This means that awk takes each new line of text as a new record and displays each record from a new line. <br><br>  Sometimes it happens that the fields in the data stream are distributed over several lines.  For example, suppose there is such a file named <code>addresses</code> : <br><br><pre> <code class="hljs lisp">Person Name <span class="hljs-number"><span class="hljs-number">123</span></span> High Street (<span class="hljs-number"><span class="hljs-number">222</span></span>) <span class="hljs-number"><span class="hljs-number">466</span></span><span class="hljs-number"><span class="hljs-number">-1234</span></span> Another person <span class="hljs-number"><span class="hljs-number">487</span></span> High Street (<span class="hljs-number"><span class="hljs-number">523</span></span>) <span class="hljs-number"><span class="hljs-number">643</span></span><span class="hljs-number"><span class="hljs-number">-8754</span></span></code> </pre> <br>  If you try to read this data, provided that <code>FS</code> and <code>RS</code> set to default values, awk will consider each new line as a separate entry and highlight the fields based on spaces.  This is not what we need in this case. <br><br>  In order to solve this problem, you need to write a newline character in <code>FS</code> .  This will indicate to awk that each line in the data stream is a separate field. <br><br>  In addition, in this example, you need to write an empty string in the <code>RS</code> variable.  Notice that in the file, data blocks for different people are separated by a blank line.  As a result, awk will treat blank lines as record delimiters.  Here's how to do it all: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{<span class="hljs-type"><span class="hljs-type">FS</span></span>=<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-type"><span class="hljs-type">RS</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-number"><span class="hljs-number">3</span></span>}' addresses</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/3e5/28d/5f03e528de8e4355a16769871035e46d.png"></div><br>  <i><font color="#999999">The results of setting variables RS and FS</font></i> <br><br>  As you can see, awk, thanks to these variable settings, treats lines from a file as fields, and empty lines become separators of records. <br><br><h2>  <font color="#3AC1EF">Built-in variables: information about the environment</font> </h2><br>  In addition to the built-in variables that we already talked about, there are others that provide information about the data and the environment in which awk works: <br><blockquote>  <code>ARGC</code> is the number of command line arguments. <br>  <code>ARGV</code> is an array with command line arguments. <br>  <code>ARGIND</code> - the index of the current file being processed in the array <code>ARGV</code> . <br>  <code>ENVIRON</code> is an associative array with environment variables and their values. <br>  <code>ERRNO</code> is a system error code that may occur when reading or closing input files. <br>  <code>FILENAME</code> is the name of the input data file. <br>  <code>FNR</code> is the current record number in the data file. <br>  <code>IGNORECASE</code> - if this variable is set to a non-zero value, the case is ignored during processing. <br>  <code>NF</code> is the total number of data fields in the current record. <br>  <code>NR</code> is the total number of records processed. </blockquote><br>  The <code>ARGC</code> and <code>ARGV</code> variables allow you to work with command line arguments.  In this case, the script passed by awk does not fall into the array of arguments <code>ARGV</code> .  Let's write this script: <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'BEGIN{print ARGC,ARGV[1]}'</span></span> myfile</code> </pre> <br>  After its launch, you can find out that the total number of command line arguments is 2, and under the index 1 in the array <code>ARGV</code> recorded the name of the file being processed.  In the array element with index 0 in this case will be ‚Äúawk‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/15a/bfd/2e815abfd2b87f1a83cbebddba6d4d19.png"></div><br>  <i><font color="#999999">Work with command line parameters</font></i> <br><br>  The variable <code>ENVIRON</code> is an associative array with environment variables.  Let's try it out: <br><br><pre> <code class="hljs swift">$ awk ' <span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-type"><span class="hljs-type">ENVIRON</span></span>[<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-type"><span class="hljs-type">ENVIRON</span></span>[<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>] }'</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94a/e22/cac/94ae22cacf533cf05ce5a8c6cbb0d816.png"></div><br>  <i><font color="#999999">Work with environment variables</font></i> <br><br>  Environment variables can be used without reference to <code>ENVIRON</code> .  You can do this, for example, as follows: <br><br><pre> <code class="hljs bash">$  <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> | awk -v home=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span> <span class="hljs-string"><span class="hljs-string">'{print "My home is " home}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/b55/80e/50cb5580ee7438efd090b326d5af3a15.png"></div><br>  <i><font color="#999999">Working with environment variables without using ENVIRON</font></i> <br><br>  The variable <code>NF</code> allows you to access the last data field in the record without knowing its exact position: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{<span class="hljs-type"><span class="hljs-type">FS</span></span>=<span class="hljs-string"><span class="hljs-string">":"</span></span>; <span class="hljs-type"><span class="hljs-type">OFS</span></span>=<span class="hljs-string"><span class="hljs-string">":"</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-type"><span class="hljs-type">NF</span></span>}' /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/da6/d74/619da6d74f1e59ed5c94800d58b817f2.png"></div><br>  <i><font color="#999999">An example of using the variable NF</font></i> <br><br>  This variable contains the numeric index of the last data field in the record.  You can access this field by placing a <code>$</code> sign in front of the <code>NF</code> . <br><br>  The variables <code>FNR</code> and <code>NR</code> , although they may seem similar, are actually different.  Thus, the <code>FNR</code> variable stores the number of records processed in the current file.  The variable <code>NR</code> stores the total number of records processed.  Consider a couple of examples, passing the same file to awk twice: <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{<span class="hljs-type"><span class="hljs-type">FS</span></span>=<span class="hljs-string"><span class="hljs-string">","</span></span>}{<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"FNR="</span></span><span class="hljs-type"><span class="hljs-type">FNR</span></span>}' myfile myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/0b2/528/2450b252839c00764accd771336fe518.png"></div><br>  <i><font color="#999999">FNR variable investigation</font></i> <br><br>  Transferring the same file twice is equivalent to transferring two different files.  Note that <code>FNR</code> reset at the beginning of processing each file. <br><br>  Now let's look at how the <code>NR</code> variable behaves in this situation: <br><br><pre> <code class="hljs swift">$ awk ' <span class="hljs-type"><span class="hljs-type">BEGIN</span></span> {<span class="hljs-type"><span class="hljs-type">FS</span></span>=<span class="hljs-string"><span class="hljs-string">","</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"FNR="</span></span><span class="hljs-type"><span class="hljs-type">FNR</span></span>,<span class="hljs-string"><span class="hljs-string">"NR="</span></span><span class="hljs-type"><span class="hljs-type">NR</span></span>} <span class="hljs-type"><span class="hljs-type">END</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"There were"</span></span>,<span class="hljs-type"><span class="hljs-type">NR</span></span>,<span class="hljs-string"><span class="hljs-string">"records processed"</span></span>}' myfile myfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/981/4bd/85c/9814bd85ce8fc22a2299f3ce35cd813e.png"></div><br>  <i><font color="#999999">Difference of NR and FNR Variables</font></i> <br><br>  As you can see, <code>FNR</code> , as in the previous example, is reset at the beginning of processing each file, but <code>NR</code> , when moving to the next file, saves the value. <br><br><h2>  <font color="#3AC1EF">Custom variables</font> </h2><br>  Like any other programming language, awk allows a programmer to declare variables.  Variable names can include letters, numbers, underscores.  However, they cannot begin with a digit.  You can declare a variable, assign a value to it and use it in the code like this: <br><br><pre> <code class="hljs sql">$ awk ' <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>=<span class="hljs-string"><span class="hljs-string">"This is a test"</span></span> print <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> }<span class="hljs-string"><span class="hljs-string">'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/711/503/950/71150395079a584116811d6635023259.png"></div><br>  <i><font color="#999999">Work with user variable</font></i> <br><br><h2>  <font color="#3AC1EF">Conditional operator</font> </h2><br>  Awk supports the standard <code>if-then-else</code> format in many programming languages.  A single-line version of the operator is an <code>if</code> keyword followed by, in parentheses, the checked expression, and then the command to be executed if the expression is true. <br><br>  For example, there is such a file named <code>testfile</code> : <br><br><pre> <code class="hljs">10 15 6 33 45</code> </pre> <br>  Let's write a script that prints numbers from this file greater than 20: <br><br><pre> <code class="hljs swift">$ awk '{<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($<span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>}' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/877/e32/bfa877e321ef62fba8c76da8e967d751.png"></div><br>  <i><font color="#999999">Single line if statement</font></i> <br><br>  If you need to execute several statements in the <code>if</code> block, you need to enclose them in braces: <br><br><pre> <code class="hljs swift">$ awk '{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($<span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) { x = $<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x } }' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/c0b/8db/8e1c0b8db9cffa7428dda1af8bf3ebcb.png"></div><br>  <i><font color="#999999">Execution of several commands in the if block</font></i> <br><br>  As already mentioned, the awk conditional operator can contain an <code>else</code> block: <br><br><pre> <code class="hljs swift">$ awk '{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($<span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) { x = $<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = $<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x }}' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c53/ec3/762/c53ec3762242952c072e9277b5d97593.png"></div><br>  <i><font color="#999999">Conditional statement with an else block</font></i> <br><br>  The <code>else</code> branch can be part of a single-line record of a conditional statement, including only one line with the command.  In this case, after the <code>if</code> branch, immediately before the <code>else</code> , you need to put a semicolon: <br><br><pre> <code class="hljs swift">$ awk '{<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($<span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>}' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e00/2f0/a1a/e002f0a1a7d37436714f9f5fc93c8c73.png"></div><br>  <i><font color="#999999">Conditional statement containing if and else branches written in one line</font></i> <br><br><h2>  <font color="#3AC1EF">While loop</font> </h2><br>  The <code>while</code> allows you to iterate over the data sets by checking the condition that stops the loop. <br><br>  Here is the file <code>myfile</code> , the processing of which we want to organize using a loop: <br><br><pre> <code class="hljs">124 127 130 112 142 135 175 158 245</code> </pre> <br>  Let's write this script: <br><br><pre> <code class="hljs swift">$ awk '{ total = <span class="hljs-number"><span class="hljs-number">0</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { total += $i i++ } avg = total / <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"Average:"</span></span>,avg }' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/qUE7sqkjSz-nGb4j4dYU15V0M9eLPXSuztbbmFCsjPzJEXRL-xosMnw2fdMd_4YAv_5fFnvt3Pijrggt_nt0vmoLzzfycbI8Uhh57lNMPu0TSYN-Y-mTWKozYoxrqy5Uz3jHDkcRnumMMnQUkw"></div><br>  <i><font color="#999999">Data processing in a while loop</font></i> <br><br>  The <code>while</code> enumerates the fields of each record, accumulating their sum in the variable <code>total</code> and increasing each variable by 1 counter variable <code>i</code> .  When <code>i</code> reaches 4, the condition at the entrance to the cycle will be false and the cycle will end, after which the remaining commands will be executed - the calculation of the average value for the numeric fields of the current record and the output of the found value. <br><br>  In <code>while</code> loops, you can use the <code>break</code> and <code>continue</code> commands.  The first allows you to complete the cycle ahead of time and proceed to the execution of commands located after it.  The second allows, without completing the end of the current iteration, to the next. <br><br>  Here‚Äôs how the <code>break</code> command works: <br><br><pre> <code class="hljs swift">$ awk '{ total = <span class="hljs-number"><span class="hljs-number">0</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { total += $i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> i++ } avg = total / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"The average of the first two elements is:"</span></span>,avg }' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://lh3.googleusercontent.com/0VV0H2jGWnzz9I7z7GaQskjeH7qhM06ut-ssXOOA0HODAF5Tp801r9YD7j2xLQlAtJpBUwGkacfB7tz2SH4ZFcR2j-zRl6KNUZMGhVeZgv8t2PEvK2r4CQ8DfLkYGqf7_RJRtrYj20i-NMKn3w"></div><br>  <i><font color="#999999">Break command in a while loop</font></i> <br><br><h2>  <font color="#3AC1EF">Cycle for</font> </h2><br>  For loops are used in many programming languages.  Supports them and awk.  We solve the problem of calculating the average value of numeric fields using this cycle: <br><br><pre> <code class="hljs swift">$ awk '{ total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { total += $i } avg = total / <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">"Average:"</span></span>,avg }' testfile</code> </pre> <br><div style="text-align:center;"><img src="https://lh3.googleusercontent.com/hmsFRQrUjqzTNGTmOf42XfHPjerCVY3y8EWViFKrXFBkugCrKSmgz0ei_JK3LSkOfqQDgok0iqOGgRk3LUKdhbLXNP_7iyxjOe_2hi-iObr1QxrMIWkWvYizkxUPXTiirZetpmn4vL2kBqFHvg"></div><br>  <i><font color="#999999">Cycle for</font></i> <br><br>  The initial value of the counter variable and the rule for its change in each iteration, as well as the condition for loop termination, are specified at the beginning of the loop, in parentheses.  As a result, we do not need, in contrast to the case with the <code>while</code> , to increment the counter ourselves. <br><br><h2>  <font color="#3AC1EF">Formatted data output</font> </h2><br>  The <code>printf</code> command in awk allows you to output formatted data.  It allows you to customize the appearance of the output data through the use of templates, which may contain text data and format specifiers. <br><br>  The format specifier is a special character that specifies the type of output and how it should be output.  Awk uses format specifiers as pointers to insert data from variables passed to <code>printf</code> . <br><br>  The first specifier corresponds to the first variable, the second specifier corresponds to the second, and so on. <br><br>  Format specifiers are written as: <br><br><pre> <code class="hljs mel">%[modifier]<span class="hljs-keyword"><span class="hljs-keyword">control</span></span>-letter</code> </pre> <br>  Here are some of them: <br><blockquote>  <code>c</code> - perceives the number passed to it as an ASCII character code and outputs this character. <br>  <code>d</code> - displays a decimal integer. <br>  <code>i</code> is the same as <code>d</code> . <br>  <code>e</code> - displays a number in exponential form. <br>  <code>f</code> - displays a floating point number. <br>  <code>g</code> - displays the number either in exponential notation or in floating point format, depending on how it is shorter. <br>  <code>o</code> - displays the octal number representation. <br>  <code>s</code> - displays a text string. </blockquote><br>  Here's how to format the output using <code>printf</code> : <br><br><pre> <code class="hljs scala">$ awk <span class="hljs-symbol"><span class="hljs-symbol">'BEGIN</span></span>{ x = <span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-number"><span class="hljs-number">100</span></span> printf <span class="hljs-string"><span class="hljs-string">"The result is: %e\n"</span></span>, x }'</code> </pre> <br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/32PdPiqkHvNTKbPq6tfVcEyb9se3YI54X_UA2yJbOWlJ5KYJfxTFTWTaXALHOIWO-WD5Bn79Q7b0c6wW6gUnL83WaqKxMvv8z3OGeZh5WEiLRbEYK0DHXfUtQMSPkykZsOhIpH5M2-wARhCvYw"></div><br>  <i><font color="#999999">Formatting output with printf</font></i> <br><br>  Here, as an example, we display a number in an exponential notation. ,    ,     ,      <code>printf</code> . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>    awk   <a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html"> </a> .  ,     ,     . , ,   ,      awk-: <br><blockquote> <code>cos(x)</code> ‚Äî  <code>x</code> ( <code>x</code>   ). <br> <code>sin(x)</code> ‚Äî  <code>x</code> . <br> <code>exp(x)</code> ‚Äî  . <br> <code>int(x)</code> ‚Äî    . <br> <code>log(x)</code> ‚Äî  . <br> <code>rand()</code> ‚Äî         0 ‚Äî 1. <br> <code>sqrt(x)</code> ‚Äî    <code>x</code> . </blockquote><br>     : <br><br><pre> <code class="hljs ruby">$ awk <span class="hljs-string"><span class="hljs-string">'BEGIN{x=exp(5); print x}'</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/wFI2nUqVLj0duMPEafJs2MtGk7oETB1zCsm53GTzG30l5UjYDWb3igdtB_DULzzN8Mu40_XdSUoZj9egx-nCl11ct_-hcukCfcAVQ-CvD5qUCflo_h8CfVYvNZyWG6DNRJOg4QWW_huMOioX9Q"></div><br> <i><font color="#999999">   </font></i> <br><br><h2> <font color="#3AC1EF"> </font> </h2><br> Awk   <a href="https://www.gnu.org/software/gawk/manual/html_node/String-Functions.html"> </a> .       . , ,  <code>toupper</code> : <br><br><pre> <code class="hljs swift">$ awk '<span class="hljs-type"><span class="hljs-type">BEGIN</span></span>{x = <span class="hljs-string"><span class="hljs-string">"likegeeks"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> toupper(x)}'</code> </pre> <br><div style="text-align:center;"><img src="https://lh4.googleusercontent.com/1ef4HRdqEbczINRJIehv3fZ4737nmYjqj7BcDKnEIw9oQlV_KQEbn2QSGXsCT79jV6AHJify_Ik0RtTQiXTlO802hycQdkx4dLN_nJV4AeRX-zsGsu8JUSKszyfxZUq2daDZ-fYd752qViDdFQ"></div><br> <i>   toupper</i> <br><br>    ,      ,   . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>        awk.      ,  : <br><br><pre> <code class="hljs dos">$ awk ' function myprint() { printf "The user %s has home <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> %s\n", $<span class="hljs-number"><span class="hljs-number">1</span></span>,$<span class="hljs-number"><span class="hljs-number">6</span></span> } BEGIN{<span class="hljs-built_in"><span class="hljs-built_in">FS</span></span>=":"} { myprint() }' /etc/passwd</code> </pre> <br><div style="text-align:center;"><img src="https://lh5.googleusercontent.com/BTkYWVuNkMUnAHf4hA1ZksVnjTd68TMa6Drb04hnCqa8IxjR4TBTyA_r6u5CNz6fWCEy32nJIOV9J4Aj1gFqDXaeL8IjOZD76aj4cOBTfUi_Zp6kjlQ_LzoFFDiRV8NWuTVmV5bnJtn-9yHvqA"></div><br> <i>  </i> <br><br>       <code>myprint</code> ,   . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>     awk.     ,       . <br><br>     ,    ,    ,       ,   ,   - ,    ,   ‚Ä¶ , , <a href="https://www.gnu.org/software/gawk/manual/html_node/index.html">The GNU Awk User's Guide</a> .       ,       1989- (  awk, ,   1977-). ,     awk   ,            ,    .   , ,     .         bash-   sed  awk. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  Dear readers! ,      awk. ,      ? </div><p>Source: <a href="https://habr.com/ru/post/327754/">https://habr.com/ru/post/327754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327744/index.html">Jubilee PYCON RUSSIA will be held July 16-17</a></li>
<li><a href="../327746/index.html">Building flexible PHP applications</a></li>
<li><a href="../327748/index.html">Forecasting in the supply chain: in search of the philosopher's stone</a></li>
<li><a href="../327750/index.html">Failover Evolution in PostgreSQL: Time Travel</a></li>
<li><a href="../327752/index.html">System engineering and management 2.0: how to get the profession of the future</a></li>
<li><a href="../327760/index.html">Data security in the development of mobile applications</a></li>
<li><a href="../327762/index.html">Biometric authentication technology - a European perspective</a></li>
<li><a href="../327766/index.html">Cultural Embedded at IT Global Meetup In St. Petersburg</a></li>
<li><a href="../327768/index.html">From two tuning forks from Lissajous experiments to a single elliptical level gauge tube with a step of centuries and everything in Python</a></li>
<li><a href="../327780/index.html">Handbook "beekeeper" or answer questions on the EFM8 Bee microcontrollers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>