<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Out of scope</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My development as a programmer began in 2005 and continues to this day. 
 Undoubtedly, many readers will be able to boast a more extensive experience,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Out of scope</h1><div class="post__text post__text-html js-mediator-article">  My development as a programmer began in 2005 and continues to this day. <br>  Undoubtedly, many readers will be able to boast a more extensive experience, but the speech <br>  will talk about something else.  My professional growth superimposed on an interesting period - <br>  Improving the culture of programming in runet, if you can call it that. <br>  Professionals have always been, but today the average programmer <br>  in any case in the field of best pracices) is incomparably higher than it was then. <br><br>  And this in itself is not bad, concerns are caused by the trend itself which led to <br>  similar result.  With its continuation, we can seriously face the same <br>  the problem that started it all - namely with the govnokod, but this time <br>  shitty-sanctioned, covered by a variety of abstractions, and sometimes by these <br>  abstractions and being.  Yes, yes, today we again criticize overinering. <a name="habracut"></a><br><br>  The concept of patterns is not new, the idea of ‚Äã‚Äãnot inventing your bike is filled <br>  it is accepted to sprinkle ashes on the head and repent as if <br>  doom trial.  It‚Äôs enough to read about 5 design books to <br>  understand what is now fashionable and how to write code.  The catch is in another - even after reading <br>  25 books you do not understand when you need to write some code.  To some extent you can learn <br>  looking at older comrades who give ideas on when to apply <br>  this or that decision, while the train of thought that led to such a decision again <br>  remains behind the scenes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, a beginner, at best, has a certain card in his head that describes <br>  when you can use anything, and the map is rather limited.  And woe to the newcomer, <br>  if it turns out to be impressionable, and the result will be excellent - a person can <br>  appear favorite pattern.  And he can carefully carry this pattern over the years, sculpt <br>  him in the most bizarre places, and thus causing sincere surprise and <br>  genuine hatred of colleagues. <br><br><br><h5>  A brief excursion into minority rights </h5><br>  You do not like TDD?  Do you like to write procedural code?  Not using EJB? <br>  Ai-ai-ai, how about you only the earth under your feet does not burn.  Any society is divided into <br>  groups, and if you are not ready to join one group, then you will be happily counted as <br>  other.  As elsewhere, where biological logic underlies the logic of behavior <br>  patterns, there is competition between groups.  Some of the groups <br>  wins the honorary prize of the Law of Possession of the Absolute Truth, the rest <br>  declared enemies of the human race, in the best case funny fringe. <br><br>  All, in general, understand this, just look at any post on Habr√©, dedicated <br>  overinering - it will be missed, but in the comments you can see it with <br>  ten kilobytes of demagogy on why all the same author is wrong.  But do nothing <br>  it is impossible - everyone who wants to go against the existing order of things will either <br>  ignored or ridiculed.  The situation is aggravated by the fact that those authorities <br>  could have supported the protest with their name, as a rule, they are not interested in this - <br>  they are already sitting in dust-free positions, where the rules of the Perfect Code are in principle <br>  work, and they no longer care that in the next segment of soft-building people <br>  break spears in disputes on the topic "how to correctly write code." <br><br>  Until the trend reversal from ‚Äúwrite perfect code‚Äù to ‚Äúwrite code, <br>  solving the current problem ", we are doomed to write famously at the interviews test code with <br>  the implementation of the pattern that it did not occur to us to use even in the <br>  a terrible dream, and then, after finding a job, it is no less famously to stamp tests, <br>  testing nothing to achieve the coveted 100% code coverage. <br><br>  The funny thing is that there are people who are ready to argue sincerely and ardently on the topic <br>  what kind of implementation of a pattern under one name or another should be, <br>  omitting the fact that the name they argue about is merely a convention for <br>  a person who has decided to record his personal experience under this name.  The most <br>  sad that there are those who listen to the previous ones and, sadly shaking their heads, <br>  they replied that they could not understand the definition correctly, promising to become <br>  it is better.  But healthy self-criticism cannot be replaced by unhealthy self-flagellation, and <br>  they don't get any better. <br><br><br><h5>  On top of Olympus </h5><br>  Martin Fowler is our king, father and god.  We all honor him as a person <br>  ruler on the hands of countless hordes of novice programmers, and in many ways <br>  determined the worldview of a whole generation of IT shnik.  We probably never <br>  We will learn how and why it became a measure of code goodness.  Perhaps his books have become that <br>  the very stub for the flow of substandard programmers who have poured into the industry before <br>  moment until the dotcom bubble burst.  Or maybe he is really the first to <br>  systematized everything that was accumulated in terms of designing programs to that <br>  of time.  All this is a matter of days gone by. <br><br>  And today we have a set of recommendations that have become the unspoken rules of good <br>  tones in development.  Perhaps these rules are good, let's try to delineate their boundaries. <br>  application: <br><br>  1) Languages ‚Äã‚Äãwith static typing - primarily C ++ and Java. <br><br>  2) Large software products created on the basis of interchangeability <br>  programmers involved in the project. <br><br>  3) Software products designed for further development and long-term <br>  escort. <br><br>  4) software designed for fairly stringent reliability requirements - corporate <br>  solutions in general. <br><br>  It seems to be normal conditions, covering a considerable share of the software market.  The problem is in <br>  that the rest of the market is covered in such talmudas ... no way.  Yes she is just <br>  ignored, or rather it would be more correct to say that the approaches described in the books <br>  just not suitable for other products. <br><br><br><h5>  Black market </h5><br>  Meanwhile, if you look closely, you can see a huge number of small and <br>  medium projects that do not fit the conditions described above.  Here and <br>  dominance of scripting languages, and teams with timlid, which is not so easy <br>  you will throw out, because the rest of the juniors were recruited in favor of the minimum budget, and <br>  now and then working for the idea and ghostly options that promise to be good <br>  addition to scholarships, and vague projections regarding the development of the project. <br><br>  A considerable amount of industry-specific software does not change over the years - programs are simply <br>  serve technical processes for which they were created, and changes made to them - <br>  purely cosmetic.  Of course, the code located there often leaves much to be desired. <br>  better, but it is quite expandable within the framework of the requirements that are put to it. <br><br>  Even more graceful, the uncertainty of the future software can come forward when <br>  whether it will develop is determined by how quickly it can enter the market and <br>  discourage investment to obtain funds for further development.  Abstraction not <br>  always significantly increase the amount of code, but always increase its time <br>  writing.  Surely there is a toy (received from the start a huge <br>  funding) and excessively successful startups who can afford such <br>  luxury as writing in all parameters charitable code.  And it's great - should <br>  there are happy programmers somewhere on earth.  But should not be considered such <br>  projects as a pattern. <br><br>  Fault tolerance is more a matter of preference.  We understand that our <br>  programs should work stably.  The question is how stable.  Everything, that <br>  written by us, written to solve some problem.  And if in the formulation of this problem <br>  it is not required to provide 100% fault tolerance, then most likely it‚Äôs really not <br>  need  Everything has a price - you have to pay for fault tolerance, spend time on <br>  creation of wrappers, checks, backup systems.  And ultimately our task is not <br>  create a completely unkillable system, and make the cost of raising <br>  reliability of the system turned out to be less than the costs caused by its downtime  Sounds <br>  blasphemous, but when soberly considered the way it is. <br><br>  Many small projects are interesting because it is more important for them to be handed over to <br>  deadlines than meet the requirements of quality.  Yes it's sad yes it is <br>  wrong, yes it can lead to sad consequences in the future, but such <br>  the model is viable and common.  Honorable Programming Masters, <br>  rubbing hands in anticipation of the work of rewriting this govnokoda to <br>  normal mind, refuse to be aware that if it were not for this <br>  if the project was able to run, then there would be no work for them.  Have <br>  they do not understand that the money that the customer is willing to pay them now, <br>  appeared as a result of a poorly working piece of govnokod. <br><br>  By the way, it is from this market segment that they begin their professional career almost <br>  all programmers.  And they have tips on their head, one more wonderful than the other.  But <br>  the reality is that following these tips at this stage of their development and when <br>  Participation in such projects is a direct road to failure.  The paradox of the situation is that <br>  those who can really follow good practices in this market segment or not <br>  work, or do not need at all because of high prices.  And those who can not yet <br>  effectively play the role of a "good programmer", on the contrary, they are in every possible way present <br>  in the labor market in this segment and are actively shypnayutsya for non-compliance <br>  covenants of perfect code. <br><br>  This is not to say that beginners are advised to use patterns, testing, <br>  extensible by malice, no.  All these advisers sincerely wish them <br>  well, without noticing that the tasks they solve are somewhat different. <br>  The application of good practices here will not give positive feedback, they simply do not <br>  suitable for solving the tasks set here.  Cooking in a pot of small and medium <br>  projects and trying to write perfect code, the beginner is doomed again and again to break <br>  deadlines and do what no one needs. <br><br>  Yes, what a sin to confess, your humble servant in due time flunked with honor 2 <br>  multi-month project on freelance, exceeding all imaginable terms, as well as in disgrace <br>  was thrown out with two jobs due to low productivity.  The reason is simple - I <br>  tried to do everything according to the mind. <br><br><br><h5>  Industry-scale obscurantism </h5><br>  Every novice programmer is faced with the dilemma of two chairs.  Training, <br>  according to the laws of logic of our universe, perhaps in two ways - by accepting <br>  information necessary to achieve the goal, on faith, or by checking all <br>  possible options to achieve the goal of finding the right one.  And both options <br>  turn out not to be perfect. <br><br>  Learning the information available is a good way if we know that it is <br>  authentic.  And she‚Äôs credible, she‚Äôs damn sure, I‚Äôm ready to agree that <br>  the authors of the design books used all the advice given to them in their <br>  projects.  I just do not believe that our programmer will fall structurally identical <br>  project, and also that a novice programmer will be allowed to work on structurally <br>  an identical project, at least at the level where it will decide which <br>  approaches to use it ... <br><br>  By the way, how to check the accuracy of the information given in such books?  Only <br>  hitting the realm of assumptions that the code will change this way or that way.  Any <br>  a sophomore will be able to give counter-examples to the examples described in the books, <br>  which will be laconic and efficient, while solving the same problem. <br><br>  It‚Äôs almost impossible to falsify any good practice. <br>  makes you think of accepting it as an infallible truth that answers the question <br>  about how to write programs.  These practices in certain cases increase <br>  the likelihood that in the event of a possible code extension you will avoid some <br>  problems.  No more. <br><br>  The second option is an independent search for a solution.  Attitudes toward such people <br>  to put it mildly negative, and more often - contempt.  The negative goes for two reasons: <br>  Firstly, a public opinion has been formed, stating that a person is not <br>  using best practices is not a person at all, and secondly, studying at <br>  your experience will inevitably make mistakes.  As a rule, these errors notice <br>  his more experienced colleagues, for whom such flaws - and really baby talk. <br><br>  The trouble is that the formalization of the process of learning programming <br>  absent, even in the heads of those who have gone through this process.  For example you <br>  held programmer, try while designing the next module or <br>  how many serious classes to ask the question "why" for each of its actions, <br>  try from the point of view of logic to justify the sequence of your actions, so <br>  so that one thing clearly follows from the other. <br><br>  To save your time, I will say that you will not succeed.  If it works, then <br>  your stubbornness is worthy of all praise, this post you read is not worthy, <br>  close it.  In the process of creating an architecture, you do not operate with knowledge, but rather <br>  by experience.  You can‚Äôt jump above your head creating a book-based architecture until <br>  until you come to the need for such constructions yourself.  But you can <br>  cheat the interviewer on the interview, using the opposite statement. <br><br><br><h5>  Heuristic powerlessness </h5><br>  In the magical land of milk rivers and pink unicorns dying from renal <br>  failure due to the absence of other moisture, people are always able to remove from <br>  general private  Unfortunately, they suffer the same fate as unicorns, therefore <br>  to get to our world with you they do not have time to bring it into it <br>  sacred knowledge.  Therefore, almost all people are not capable on the basis of knowledge <br>  something common, abstract, to bring private, except when it comes to <br>  simple and unambiguous things.  Software design is not. <br><br>  I searched in vain and for a long time for people who would be able to read a gang of four, and <br>  then build abstractions and successfully apply them in your code.  If anything, talking about people <br>  without experience.  If anything, singleton does not count.  Something in my head does not allow to take and produce <br>  piece abstractions in the image and likeness of the read: either the person does not understand <br>  why it is done and as a result abstraction creates more problems than it solves, or it <br>  honestly admits to himself that he does not see where this can be stuck.  Perhaps there are those who <br>  I am capable of such a way of learning, but I have never met them.  And you? <br><br>  According to my observations, the withdrawal of the general from the particular is a much more feasible task, <br>  that everyone copes with.  Yes, I'm talking about the case when a person himself comes to <br>  Patterns beating on a rake.  And that opens the book just to understand <br>  as is commonly called what he learned from experience.  If he so nothing <br>  I found out by the time the book was opened, then no approach would work anymore. <br><br>  Knowledge at the level of a formal description of the subject is often insufficient for successful <br>  its application.  They must be embedded in logical chains at the fact level, <br>  which should not just be learned, but felt.  Usually such an understanding <br>  comes in the process of practice (less often - when, in a few months or years you <br>  feel that something in my head fell into place and you are ready to use it). <br>  And regardless of whether the programmer read about the patterns or not.  If tasks <br>  will show the ineffectiveness of his current approach, then he will come to a decision <br>  which will work better.  It doesn't matter how he calls it in his head.  To explain <br>  the resulting pattern to another programmer is a minute thing.  And besides, if <br>  description of the pattern is formed in the brain of each programmer on those examples with <br>  whom he dealt with, then, even having a general definition, two people using him, <br>  They will talk about quite different things, which again makes it binding to the official <br>  junk patterns. <br><br>  I even take the liberty to say that if programmers are constantly <br>  they use in their work the official names of patterns, and moreover are limited <br>  Only these names, without discussing the logic associated with them, then most likely it‚Äôs <br>  either yesterday's students, or avid Java lovers, where the use of patterns <br>  to circumvent the limitations of the language is the essence of routine. <br><br><br><h5>  Embrace the immensity </h5><br>  All practices aimed at creating extensible code go away from the subject <br>  areas in the range of assumptions that this code will be maintained and expanded.  AND <br>  this is the greatest difference between programming and any other engineering <br>  activities - usually, if the unit does not have enough power or functions, then <br>  replace with another unit, more suitable. <br><br>  The unspoken programming principle states that instead of creating <br>  again, it is better to expand or change the existing one.  The benefit of technology allows.  TO <br>  technology allows the word and upgrade physical devices to achieve them <br>  necessary functions.  However, for some reason this is not being done.  For certain reasons <br>  purely economic nature. <br><br>  Having two approaches - rewriting from scratch and expanding the finished one, we are used to <br>  the fact that the second option is better is less labor intensive.  While forgetting that: <br><br>  a) in the case of crookedly written non-extensible code, we get great difficulties with <br>  adding functionality <br><br>  b) in the case of creating an expandable code, the cost of rewriting is laid down already <br>  at the stage of the initial writing of the code <br><br>  Labor costs will be in both cases, the only question is when they are more.  And precisely <br>  An experienced programmer should know the answer to this question.  Experienced <br>  An architect can give a task to write a shit, but with one condition - no one <br>  should know about it. <br><br><br><h5>  Application area </h5><br>  You can not find a place for years due to the fact that you can not find a place <br>  practices that you read about, but this most likely does not mean that something is not with you <br>  So.  No matter how many patterns you know and use, it‚Äôs just that you can <br>  apply them to the place.  I am generally convinced that the amount of knowledge of a good designer <br>  can be mastered in a couple of months, but to learn how to apply them correctly <br>  it will take years. <br><br>  In case you are not working on a system containing at least dozens of strongly <br>  related classes (and there are a lot of such systems), you do not need to bother your head <br>  better to make an orgy of various abstractions so that then it all looks <br>  like light erotica.  You generally can be a good programmer and never <br>  plunge into such a project, traveling between small projects and systems with <br>  low connectivity. <br><br>  If you still want to understand who uses it and why, then study the code <br>  large projects in Java, C #, C ++.  In particular, it will be useful to programmers on <br>  scripting languages, because so you can clearly see the difference in approach <br>  To programming on, for example, Java and Python.  In any case, even if you find <br>  the implementation of a particular pattern should not be taken to heart, <br>  patterns are usually born or selected within a specific project.  So that <br>  chances are high that what you see there cannot be applied in your current <br>  project. <br><br>  If the authorities require you to write the "correct code" - write!  Are you either true <br>  do not yet understand what is wrong with your professional level, and then it is useful for you <br>  will do as they say, but if your timlid is an ideological person, do not argue <br>  with him, to an ordinary programmer, his faith cannot be destroyed, and then he will not be kicked <br>  you. <br><br><br><h5>  What to do? </h5><br>  To think, to think well before you use something that you do not understand.  If a <br>  it seems unnecessary to you, it may indeed be so.  If you see that <br>  tests are necessary for your program as a dog's side pocket - do not write them, you don't care <br>  you can‚Äôt write them to benefit.  If you are familiar with <br>  the list of patterns, and then with horror found that in your code for the last couple <br>  At best, 3-4 years have found shelter at best, but otherwise you are satisfied with your <br>  code, and with its maintenance there are no problems, then leave everything as it is. <br><br>  And, of course, remember that people's ability to aggressive rhetoric is always back <br>  proportional to their evidence base.  And every time you will be in quality <br>  argument to use some approach to appeal to a hypothetical situation, <br>  the probability of occurrence of which is suspiciously small, just remember when <br>  conditions grandmother can become a grandfather. <br><br></div><p>Source: <a href="https://habr.com/ru/post/178035/">https://habr.com/ru/post/178035/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178023/index.html">The network has a 128-year-old voice recording of Alexander Bell</a></li>
<li><a href="../178027/index.html">Working with Group Policy Preferences: Managing INI Files</a></li>
<li><a href="../178029/index.html">GlowingPlant: Glowing plants for home</a></li>
<li><a href="../178031/index.html">More than a man</a></li>
<li><a href="../178033/index.html">Zyxel N4100 - Access Point ... with printer</a></li>
<li><a href="../178037/index.html">As I wrote Pacman'a, and what came of it. Part 1</a></li>
<li><a href="../178039/index.html">Impressions after the first year of undergraduate studies in Canada</a></li>
<li><a href="../178049/index.html">Serious design serious sites. Part 2. Visualization</a></li>
<li><a href="../178053/index.html">Facebook bought Parse backend for third-party mobile apps</a></li>
<li><a href="../178055/index.html">Viber vulnerability allows to bypass Android-smartphone lock</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>