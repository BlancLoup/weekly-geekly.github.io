<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of using and testing C ++ code on microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It so happened that the main language for working with microcontrollers is C. Many large projects are written on it. But life does not stand still. Mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of using and testing C ++ code on microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/38e/0cb/e8e/38e0cbe8e4c0498cadd1c9a0d51a0a6f.png" align="left" width="150">  It so happened that the main language for working with microcontrollers is C. Many large projects are written on it.  But life does not stand still.  Modern development tools have long allowed the use of C ++ in the development of software for embedded systems.  However, this approach is still quite rare.  Not so long ago, I tried to use C ++ when working on the next project.  I will tell you about this experience in this article. <br><br><a name="habracut"></a><br><br><h4>  Introduction </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most of my work with microcontrollers is associated with C. At first, this was customer requirements, and then it became just a habit.  At the same time, when it came to applications for Windows, C ++ was used there first, and then C # in general. <br><br>  There have been no questions about C or C ++ for a long time.  Even the release of the next version of Keil's MDK from Cilar C ++ for ARM didn't bother me too much.  If you look at Keil demo projects, everything is written in C. At that, C ++ is moved to a separate folder along with Blinky-project.  CMSIS and LPCOpen are also written in C. And if ‚Äúeveryone‚Äù uses C, then there are some reasons. <br><br>  But a lot has changed. Net Micro Framework.  If anyone does not know, then this is the implementation of .Net that allows you to write applications for C # microcontrollers in Visual Studio.  More details on him can be found in <a href="https://geektimes.ru/search/%3Ftarget_type%3Dposts%26q%3D%255B.net%2520micro%2520framework%255D%26order_by%3Ddate">these</a> articles. <br><br>  So, .Net Micro Framework is written using C ++.  Impressed by this, I decided to try to write another C ++ project.  I‚Äôll say right away that I haven‚Äôt found any clear arguments in favor of C ++, but there are some interesting and useful points in this approach. <br><br><h4>  What is the difference between C and C ++ projects? </h4><br><br>  One of the biggest differences between C and C ++ is that the second is an object-oriented language.  Well-known encapsulation, polymorphism and inheritance are commonplace here.  C is a procedural language.  There are only functions and procedures, and modules are used for the logical grouping of the code (pair .h + .c).  But if you look at how C is used in microcontrollers, you can see the usual object-oriented approach. <br><br>  Let's look at the code for working with LEDs from the Keil example for MCB1000 ( <i>Keil_v5 \ ARM \ Boards \ Keil \ MCB1000 \ MCB11C14 \ CAN_Demo</i> ): <br><br>  LED.h: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __LED_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __LED_H </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LED Definitions */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_NUM 8 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of user LEDs */</span></span></span><span class="hljs-meta"> extern void LED_init(void); extern void LED_on (uint8_t led); extern void LED_off (uint8_t led); extern void LED_out (uint8_t led); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><br>  LED.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LPC11xx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC11xx definitions */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LED.h"</span></span></span><span class="hljs-meta"> const unsigned long led_mask[] = {1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 0, 1UL &lt;&lt; 1, 1UL &lt;&lt; 2, 1UL &lt;&lt; 3, 1UL &lt;&lt; 4, 1UL &lt;&lt; 5, 1UL &lt;&lt; 6, 1UL &lt;&lt; 7 }; /*---------------------------------------------------------------------------- initialize LED Pins *----------------------------------------------------------------------------*/ void LED_init (void) { LPC_SYSCON-&gt;SYSAHBCLKCTRL |= (1UL &lt;&lt; 6); /* enable clock for GPIO */ /* configure GPIO as output */ LPC_GPIO2-&gt;DIR |= (led_mask[0] | led_mask[1] | led_mask[2] | led_mask[3] | led_mask[4] | led_mask[5] | led_mask[6] | led_mask[7] ); LPC_GPIO2-&gt;DATA &amp;= ~(led_mask[0] | led_mask[1] | led_mask[2] | led_mask[3] | led_mask[4] | led_mask[5] | led_mask[6] | led_mask[7] ); } /*---------------------------------------------------------------------------- Function that turns on requested LED *----------------------------------------------------------------------------*/ void LED_on (uint8_t num) { LPC_GPIO2-&gt;DATA |= led_mask[num]; } /*---------------------------------------------------------------------------- Function that turns off requested LED *----------------------------------------------------------------------------*/ void LED_off (uint8_t num) { LPC_GPIO2-&gt;DATA &amp;= ~led_mask[num]; } /*---------------------------------------------------------------------------- Output value to LEDs *----------------------------------------------------------------------------*/ void LED_out(uint8_t value) { int i; for (i = 0; i &lt; LED_NUM; i++) { if (value &amp; (1&lt;&lt;i)) { LED_on (i); } else { LED_off(i); } } }</span></span></span></span></code> </pre><br><br>  If you look closely, you can bring an analogy with the PLO.  LED is an object with one public constant, constructor, 3 public methods and one private field: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> led_mask[] = {<span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1U</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LED_NUM=<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LED(); <span class="hljs-comment"><span class="hljs-comment">// LED_init void on (uint8_t led); void off (uint8_t led); void out (uint8_t led); }</span></span></code> </pre><br><br>  Despite the fact that the code is written in C, it uses the paradigm of object programming.  The .C file is an object that allows you to encapsulate the mechanisms for implementing public methods inside, described in the .h file.  That's just not inheritance here, so polymorphism too. <br><br>  Most of the code in the projects that I met was written in the same style.  And if the PLO approach is used, why not use a language that fully supports it?  At the same time, when switching to C ++, by and large, only the syntax will change, but not the design principles. <br><br>  Consider another example.  Suppose we have a device that uses a temperature sensor connected via I2C.  But a new revision of the device came out and the same sensor is now connected to SPI.  What to do?  It is necessary to support the first and second revisions of the device, which means that the code must flexibly take into account these changes.  In C, you can use the predefinement #define to avoid writing two almost identical files.  for example <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> ‚Äúi2c.h‚Äù #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> ‚Äúspi.h‚Äù #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> void TEMPERATURE_init() { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV1 I2C_int() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV2 SPI_int() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><br>  and so on. <br><br>  In C ++ you can solve this problem a little more elegantly.  Make an interface <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITemperature</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  and make 2 implementations <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Temperature_I2C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ITemperature { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Temperature_SPI</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ITemperature { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  And then use this or that implementation depending on the revision: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemperatureGetter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ITemperature* _temperature; pubic: Init(ITemperature* temperature) { _temperature = temperature; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _temperature-&gt;GetValue(); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV1 Temperature_I2C temperature; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REV2 Temperature_SPI temperature; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> TemperatureGetter tGetter; void main() { tGetter.Init(&amp;temperature); }</span></span></code> </pre><br><br>  It seems that the difference is not very big between the code in C and C ++.  The object-oriented version looks even more cumbersome.  But it allows you to make a more flexible solution. <br><br>  When using C, there are two main solutions: <br><br><ul><li>  Use #define as shown above.  This option is not very good because it ‚Äúblurs‚Äù the responsibility of the module.  It turns out that he is responsible for several revisions of the project.  When there are many such files, it becomes rather difficult to maintain them. </li><li>  Make 2 modules, just like with C ++.  There is no ‚Äúblurring‚Äù here, but the use of these modules is complicated.  Since they do not have a single interface, the use of each method from this pair must be framed in #ifdef.  This impairs readability and, therefore, maintainability of the code.  And the higher the abstraction will need to raise the place of separation, the more cumbersome the code will turn out.  At the same time, it is necessary to think over the names of functions for each module so that they do not overlap, which is also fraught with a deterioration in the readability of the code. </li></ul><br><br>  Using polymorphism gives a more beautiful result.  On the one hand, each class solves a clear atomic problem, on the other hand, the code is not littered and easy to read. <br><br>  ‚ÄúBranching‚Äù the code on the revision will still have to be done in the first and second cases, but the use of polymorphism makes it easier to transfer the branching location between program layers, without overloading the code with unnecessary #ifdef. <br><br>  Using polymorphism makes it even easier to make an even more interesting decision. <br>  Suppose there was a new revision, in which there are both temperature sensors. <br><br>  The same code with minimal changes allows you to choose your SPI and I2C implementation in real time, simply using the Init (&amp; temperature) method. <br><br>  The example is very simplified, but in a real project I used the same approach to implement the same protocol across two different physical data transfer interfaces.  This made it easy to make the choice of the interface in the device settings. <br><br>  However, with all the above, the difference between using C and C ++ is not very big.  The advantages of C ++ related to OOP are not so obvious and are from the category of ‚Äúan amateur‚Äù.  But using C ++ in microcontrollers has quite serious problems. <br><br><h4>  What is dangerous about using C ++? </h4><br><br>  The second important difference between C and C ++ is memory usage.  C language is mostly static.  All functions and procedures have fixed addresses, and the work with the heap is carried out only when necessary.  C ++ is a more dynamic language.  Usually its use implies active work with the allocation and release of memory.  This is C ++ and dangerous.  There are very few resources in microcontrollers, so control over them is important.  Uncontrolled use of RAM is fraught with damage to the data stored there and such "miracles" in the program that does not seem to anyone.  Many developers faced such problems. <br><br>  If you take a closer look at the examples above, it can be noted that classes do not have constructors and destructors.  This is done because they are never dynamically created. <br><br>  When using dynamic memory (and when using new), the malloc function is always called, which allocates the required number of bytes from the heap.  Even if you think over everything (although it is very difficult) and will control the use of memory, you may face the problem of its fragmentation. <br><br>  Pile can be represented as an array.  For example, select 20 bytes for it: <br><img src="https://habrastorage.org/files/05a/c96/6c5/05ac966c58a744058f06c0552789825c.png"><br><br>  Each time memory is allocated, the entire memory is viewed (from left to right or from right to left - this is not so important) for the presence of a specified number of unallocated bytes.  And these bytes should all be located next: <br><img src="https://habrastorage.org/files/72d/0bf/e62/72d0bfe6220048a487dddf81032082fb.png"><br><br>  When memory is no longer needed, it returns to its original state: <br><img src="https://habrastorage.org/files/05a/c96/6c5/05ac966c58a744058f06c0552789825c.png"><br><br>  It is very easy for this to happen when there are enough free bytes, but they are not located in a row.  Let 10 zones with 2 bytes each be allocated: <br><img src="https://habrastorage.org/files/a26/7b6/698/a267b6698df2402aaab7340b86b1357d.png"><br><br>  Then 2,4,6,8,10 zones will be released: <br><img src="https://habrastorage.org/files/ad6/b46/3af/ad6b463af9804994ad77c1e20e039426.png"><br><br>  Formally, half of the entire heap remains free (10 bytes).  However, it is still impossible to allocate a memory area of ‚Äã‚Äã3 bytes in size, since there are no 3 free cells in a row in the array.  This is called memory fragmentation. <br><br>  And to deal with this on systems without memory virtualization is quite difficult.  Especially in large projects. <br><br>  This situation can be easily emulated.  I did this in Keil mVision on an LPC11C24 microcontroller. <br><br>  Set the heap size to 256 bytes: <br><img src="https://habrastorage.org/files/928/56b/179/92856b179a9e4165b8c476fe40870c25.png"><br><br>  Suppose we have 2 classes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; class foo { private: int32_t _pr1; int32_t _pr2; int32_t _pr3; int32_t _pr4; int32_t _pb1; int32_t _pb2; int32_t _pb3; int32_t _pb4; int32_t _pc1; int32_t _pc2; int32_t _pc3; int32_t _pc4; public: foo() { _pr1 = 100; _pr2 = 200; _pr3 = 300; _pr4 = 400; _pb1 = 100; _pb2 = 200; _pb3 = 300; _pb4 = 400; _pc1 = 100; _pc2 = 200; _pc3 = 300; _pc4 = 400; } ~foo(){}; int32_t F1(int32_t a) { return _pr1*a; }; int32_t F2(int32_t a) { return _pr1/a; }; int32_t F3(int32_t a) { return _pr1+a; }; int32_t F4(int32_t a) { return _pr1-a; }; }; class bar { private: int32_t _pr1; int8_t _pr2; public: bar() { _pr1 = 100; _pr2 = 10; } ~bar() {}; int32_t F1(int32_t a) { return _pr2/a; } int16_t F2(int32_t a) { return _pr2*a; } };</span></span></span></span></code> </pre><br><br>  As you can see, the bar class will occupy more memory than foo. <br>  14 instances of the class bar are placed in a heap and the instance of the class foo does not fit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ foo *f; bar *b[<span class="hljs-number"><span class="hljs-number">14</span></span>]; b[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">12</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">13</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> foo(); }</code> </pre><br><br>  If you create only 7 bar instances, then foo will also be created normally: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ foo *f; bar *b[<span class="hljs-number"><span class="hljs-number">14</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//b[0] = new bar(); b[1] = new bar(); //b[2] = new bar(); b[3] = new bar(); //b[4] = new bar(); b[5] = new bar(); //b[6] = new bar(); b[7] = new bar(); //b[8] = new bar(); b[9] = new bar(); //b[10] = new bar(); b[11] = new bar(); //b[12] = new bar(); b[13] = new bar(); f = new foo(); }</span></span></code> </pre><br><br>  However, if you first create 14 instances of bar, then delete 0,2,4,6,8,10 and 12 instances, then memory cannot be allocated for foo because of heap fragmentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ foo *f; bar *b[<span class="hljs-number"><span class="hljs-number">14</span></span>]; b[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">12</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); b[<span class="hljs-number"><span class="hljs-number">13</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bar(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b[<span class="hljs-number"><span class="hljs-number">12</span></span>]; f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> foo(); }</code> </pre><br><br>  It turns out that you cannot fully use C ++, and this is a significant minus.  From an architectural point of view, C ++, although superior to C, is insignificant.  As a result, the transition to C ++ does not bring significant benefits (although there are no large negative points either).  Thus, due to the small difference, the choice of language will remain just the personal preference of the developer. <br>  But for myself I found one significant positive point in using C ++.  The fact is that with the right approach, C ++ code for microcontrollers can be fairly easily covered by unit tests in Visual Studio. <br><br><h4>  A big plus of C ++ is the ability to use Visual Studio. </h4><br><br>  For me personally, the topic of testing code for microcontrollers has always been quite complicated.  Naturally, the code was checked in various ways, but the creation of a full-fledged automatic testing system always required huge costs, since it was necessary to assemble a hardware stand and write a special firmware for it.  Especially when it comes to a distributed IoT system consisting of hundreds of devices. <br><br>  When I started writing a project in C ++, I immediately wanted to try to shove the code in Visual Studio and use Keil mVision only for debugging.  Firstly, Visual Studio has a very powerful and convenient code editor, and secondly, Keil mVision doesn‚Äôt have a convenient integration with version control systems, and in Visual Studio it‚Äôs all worked out to automatism.  Thirdly, I had a hope that at least part of the code will succeed in covering with unit tests, which are also well supported in Visual Studio.  And fourthly, this is the appearance of Resharper C ++, a Visual Studio extension for working with C ++ code, thanks to which many potential errors can be avoided in advance and the code style can be monitored. <br><br>  Creating a project in Visual Studio and connecting it to the version control system did not cause any problems.  But with the unit tests had to tinker. <br><br>  Classes that are abstracted from the hardware (for example, protocol parsers) were rather easily tested.  But I wanted more!  In my projects for working with peripherals, I use Keil header files.  For example, for LPC11C24, this is LPC11xx.h.  These files describe all the necessary registers in accordance with the CMSIS standard.  Directly the definition of a specific register is made via #define: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LPC_I2C_BASE (LPC_APB0_BASE + 0x00000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LPC_I2C ((LPC_I2C_TypeDef *) LPC_I2C_BASE )</span></span></code> </pre><br><br>  It turned out that if you correctly redefine the registers and make a couple of stubs, then the code that uses the peripherals can be compiled into VisualStudio.  Moreover, if you make a static class and specify its fields as addresses of registers, you get a full-fledged microcontroller emulator, which allows you to fully test even work with peripherals: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LPC11xx.h&gt; class LPC11C24Emulator { public: static class Registers { public: static LPC_ADC_TypeDef ADC; public: static void Init() { memset(&amp;ADC, 0x00, sizeof(LPC_ADC_TypeDef)); } }; } #undef LPC_ADC #define LPC_ADC ((LPC_ADC_TypeDef *) &amp;LPC11C24Emulator::Registers::ADC)</span></span></span></span></code> </pre><br><br>  And then do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined ( _M_IX86 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"..\Emulator\LPC11C24Emulator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LPC11xx.h&gt; #endif</span></span></span></span></code> </pre><br><br>  Thus, it is possible to compile and test all the project code for microcontrollers in VisualStudio with minimal changes. <br><br>  In the process of developing a project in C ++, I wrote over 300 tests covering both purely hardware aspects and code abstracted from hardware.  In this case, about 20 rather serious errors were found in advance, which, due to the size of the project, it would not be easy to detect without automatic testing. <br><br><h4>  findings </h4><br><br>  To use or not to use C ++ when working with microcontrollers is a rather complicated question.  Above, I showed that, on the one hand, the architectural advantages of a full-fledged OOP are not so great, and the impossibility of full-fledged work with a bunch is quite a big problem.  Given these aspects, there is not much difference between C and C ++ for working with microcontrollers, the choice between them may well be justified by the personal preferences of the developer. <br><br>  However, I managed to find a big positive moment of using C ++ in working with Visaul Studio.  This allows you to significantly increase the reliability of development due to the full-fledged work with version control systems, the use of full-fledged unit tests (including peripheral tests) and other benefits of Visual Studio. <br><br>  I hope my experience will be useful and will help someone to improve the efficiency of their work. <br><br>  <b>Update</b> : <br>  In the comments to the English <a href="http://www.codeproject.com/Articles/1081708/Cplusplus-and-microcontrollers-using-and-testing">version of</a> this article gave useful links on this topic: <br><br><ul><li>  Meeting C ++ 2015 Lightning Talks: Odin Holmes - special function register abstraction <a href="https://www.youtube.com/watch%3Fv%3DAKAYc9ZFBhk">www.youtube.com/watch?v=AKAYc9ZFBhk</a> </li><li>  Meeting C ++ 2015: John Hinke - Deeply embedded C ++ <a href="https://www.youtube.com/watch%3Fv%3DTYqbgvHfxjM">www.youtube.com/watch?v=TYqbgvHfxjM</a> </li><li>  Meeting C ++ 2014: Wouter van Ooijen - Objects?  No thanks.  <a href="https://www.youtube.com/watch%3Fv%3Dk8sRQMx2qUw">www.youtube.com/watch?v=k8sRQMx2qUw</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/390837/">https://habr.com/ru/post/390837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../390827/index.html">"Warned - armed" or what you need to know about a stroke, even if you are young</a></li>
<li><a href="../390829/index.html">Tim Cook once again confirms the hardness of their positions, 51% of Americans surveyed support the FBI</a></li>
<li><a href="../390831/index.html">Oil magnates create a group to attack electric vehicles</a></li>
<li><a href="../390833/index.html">Overview of the OCZ Trion 100 SSD</a></li>
<li><a href="../390835/index.html">Opera Presto updated to version 12.18</a></li>
<li><a href="../390839/index.html">Bryansk doctors were forbidden to work with social networks and foreign communication services</a></li>
<li><a href="../390841/index.html">In the case of the Playpen child pornography site, a judge ordered the FBI to disclose a hacking technique. Tor</a></li>
<li><a href="../390843/index.html">Project "Eye" Part 16</a></li>
<li><a href="../390845/index.html">Bb-mobile Topol 'LTE 8-inch ‚ÄúThermonuclear‚Äù Tablet Review</a></li>
<li><a href="../390849/index.html">US customs officials began to remove the biometrics of people crossing the US border on foot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>