<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Efficient data structures for PHP 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP has only one data structure to manage everything. array - complex, flexible, hybrid, combines the behavior of list and linked map . But we use it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Efficient data structures for PHP 7</h1><div class="post__text post__text-html js-mediator-article"> PHP has only one data structure to manage everything.  <code>array</code> - complex, flexible, hybrid, combines the behavior of <code>list</code> and <code>linked map</code> .  But we use it for everything, because PHP adheres to a <b>pragmatic approach</b> : to have an extremely correct, sensible and realistic way of solving a problem, coming from practical, not theoretical, reasoning.  <code>array</code> allows you to do work, although there are so many about it in lectures on computer science.  But, unfortunately, complexity comes with flexibility. <br><br>  The latest PHP release has caused a lot of excitement in the community.  We could not wait to start using <a href="http://php.net/manual/en/migration70.new-features.php">new features</a> and feel the taste of <a href="https://www.reddit.com/r/PHP/comments/3q2brz/how_is_php_7_twice_as_fast/">~ 2x performance gains</a> .  One of the reasons why this happened is that the <a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">structure of the <code>array</code> been reworked</a> .  But arrays still adhere to the principle ‚Äúoptimized for everything;  optimized for nothing, ‚Äúnot everything is perfect, there is room for improvement. <br><br><blockquote>  What about <a href="http://php.net/manual/en/spl.datastructures.php">SPL data structures?</a> </blockquote>  Unfortunately ... they are terrible.  Previously, to PHP7, they offered some advantages, but now we have reached the point when using SPL has no practical meaning. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Why can't we just fix and improve them? </blockquote>  Yes, we could, but I believe that their design and implementation are so poor that it would be better to find a more modern replacement. <br><blockquote>  <b><i>"SPL data structures are horribly designed."</i></b> <br>  - <i>Anthony Ferrara</i> <br></blockquote><br><hr>  <b>Introduction</b> : <code>php-ds</code> is an extension for PHP7 that adds data structures.  This post briefly covers the behavior, performance, and benefits of each.  Also at the end you will find a list of answers to the expected questions. <br><br>  <b>Github</b> : <a href="https://github.com/php-ds">https://github.com/php-ds</a> <br>  <b>Namespace:</b> <code>Ds\</code> <br>  <b>Interfaces:</b> <code>Collection</code> , <code>Sequence</code> , <code>Hashable</code> <br>  <b>Classes:</b> <code>Vector</code> , <code>Deque</code> , <code>Stack</code> , <code>Queue</code> , <code>PriorityQueue</code> , <code>Map</code> , <code>Set</code> <br><a name="habracut"></a><hr><br><h2>  Collection </h2><br>  <code>Collection</code> is a basic interface that covers the common functionality: <code>foreach</code> , <code>echo</code> , <code>count</code> , <code>print_r</code> , <code>var_dump</code> , <code>serialize</code> , <code>json_encode</code> , and <code>clone</code> . <br><br><h2>  Sequence <i>(Sequence)</i> </h2><br>  <code>Sequence</code> describes the behavior of elements organized into a single, linear dimension.  In some languages, such a structure is called a <code>List</code> .  Like an <code>array</code> that uses incremental keys, with the exception of some features: <br><br><ul><li>  Values ‚Äã‚Äãshould <b>always</b> be indexed as <code>[0, 1, 2, ‚Ä¶, size - 1]</code> </li><li>  Retrieving or appending updates the index of all consecutive values. </li><li>  Supports access to values ‚Äã‚Äãonly from the index <code>[0, size - 1]</code> </li></ul><br><h4>  Use cases </h4><br><ul><li>  Wherever you would like to use <code>array</code> as a list (without keys) </li><li>  More effective alternative to <code>SplDoublyLinkedList</code> and <code>SplFixedArray</code> </li></ul><br><h2>  Vector </h2><br>  <code>Vector</code> is a <code>Sequence</code> that combines values ‚Äã‚Äãinto a continuous buffer, increasing and decreasing automatically.  This is the most efficient sequential data structure, since the element index is a direct reflection of its index in the buffer, and an increase in the vector will not affect the performance in any way. <br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/154438958&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhPSXFjqKA9cGHzhXi0dVWXLSdnBg" width="560" height="315" frameborder="0" title="Vector" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><h4>  Strengths </h4><br><ul><li>  Very small memory consumption </li><li>  Very fast iterations </li><li>  <code>get</code> , <code>set</code> , <code>push</code> and <code>pop</code> have <code>O(1)</code> complexity </li></ul><br><h4>  disadvantages </h4><br><ul><li>  <code>insert</code> , <code>remove</code> , <code>shift</code> and <code>unshift</code> have complexity <code>O(n)</code> </li></ul><br><blockquote>  The number one structure in Photoshop was Vectors. <br>  - <b>Sean Parent</b> , <a href="https://youtu.be/sWgDk-o-6ZE%3Ft%3D21m52s">CppCon 2015</a> <br></blockquote><br><h2>  Deque <i>(doubly connected queue)</i> </h2><br>  <code>Deque</code> (pronounced ‚Äúdeck‚Äù) is a sequence of values ‚Äã‚Äãcombined into a continuous buffer that increases and decreases automatically.  The name is a common abbreviation for <i>double-ended queue</i> .  Used inside <code>Ds\Queue</code> . <br><br>  Two pointers used to track the head and tail.  The presence of pointers allows you to change the end and beginning of the buffer without having to move other elements to free up space.  This makes <code>shift</code> and <code>unshift</code> so fast that even <code>Vector</code> cannot compete with that. <br><br>  Accessing the value by index requires the calculation of the corresponding position in the buffer: <code>((head + position) % capacity)</code> . <br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/154438012&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhh6PuPBzfYt628uK074pNxJrxMgtg" width="560" height="315" frameborder="0" title="Deque" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><h4>  Strengths </h4><br><ul><li>  Very small memory consumption </li><li>  <code>get</code> , <code>set</code> , <code>push</code> , <code>pop</code> , <code>shift</code> and <code>unshift</code> have complexity <code>O(1)</code> </li></ul><br><h4>  disadvantages </h4><br><ul><li>  <code>insert</code> , <code>remove</code> have complexity <code>O(n)</code> </li><li>  Buffer capacity must be a power of two ( <code>2‚Åø</code> ) </li></ul><br>  The following benchmark shows the total elapsed time and memory used for <code>push</code> 2 <code>push</code> random numbers operation.  <code>array</code> , <code>Ds\Vector</code> and <code>Ds\Deque</code> work quickly, but <code>SplDoublyLinkedList</code> consistently shows a result <b>more than 2 times worse</b> . <br><br>  <code>SplDoublyLinkedList</code> allocates memory for each value separately, which is why an expected increase in memory occurs.  <code>array</code> and <code>Ds\Deque</code> in their implementation, allocate memory in portions to maintain sufficient volume for 2‚Åø elements.  <code>Ds\Vector</code> has a growth factor of 1.5, which entails an increase in the number of memory allocations, but less consumption in general. <br><img src="https://habrastorage.org/files/2ba/dcd/509/2badcd509c714317be94608dc14e3756.gif"><br><img src="https://habrastorage.org/files/1d6/1b5/5a0/1d61b55a0b5745ed9ced6bd6de23cca8.gif"><br>  The following benchmark shows the time taken to <code>unshift</code> <b>single element</b> in a sequence of 2 <code>unshift</code> values.  The time required to set the values ‚Äã‚Äãis not taken into account. <br><br>  The graph shows that <code>array_unshift</code> has <code>O(n)</code> complexity: whenever the sample size doubles, the time required for <code>unshift</code> .  This is due to the fact that each numerical index in the range <code>[1, size - 1]</code> must be updated. <br><img src="https://habrastorage.org/files/196/721/612/1967216121354a8a80018e7ffe0f4dd1.gif"><br>  But <code>Ds\Vector::unshift</code> also <code>O(n)</code> , so why is it much faster?  Note that <code>array</code> stores each value in a <code>bucket</code> along with its key and hash.  Therefore, you have to check each item and update the hash if the index is numeric.  In fact, <code>array_unshift</code> allocates a new array for this and replaces the old one when all values ‚Äã‚Äãare copied. <br><br>  In the vector, the index of a value is a direct mapping of its index in the buffer, so all we need to do is move each value in the range [1, size - 1] to the right by one position.  This is done with just one <code>memmove</code> operation. <br><br>  <code>Ds\Deque</code> and <code>SplDoublyLinkedList</code> in turn, are very fast, because the sample size does not affect the time for <code>unshift</code> , i.e.  its complexity will be <code>O(1)</code> . <br><br>  The next test shows how much memory is used for 2‚Åø <code>pop</code> operations.  In other words when resizing from 2‚Åø to zero <br><br>  The interesting thing is that the <code>array</code> always holds the allocated memory, even if its size is significantly reduced.  <code>Ds\Vector</code> and <code>Ds\Deque</code> allow you to reduce the allocated resources by half if their size falls below a quarter of their current potential.  <code>SplDoublyLinkedList</code> frees the memory after each deletion from the sample, so we can observe a linear decrease. <br><img src="https://habrastorage.org/files/368/17e/ec9/36817eec937046e3a12ae8b9c5d2ecad.gif"><br><h2>  Stack </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA">Stack</a> - is a collection organized according to the principle <i>‚Äúlast arrived - first exited‚Äù</i> or <i>‚ÄúLIFO‚Äù (last in - first out)</i> , allowing access only to the value at the top of the structure.  You can think of it as a dynamic-capacity <a href="">gun shop</a> . <br><br>  <code>Ds\Stack</code> uses the inside of <code>Ds\Vector</code> . <br><br>  <code>SplStack</code> inherited from SplDoublyLinkedList, so performance will be equivalent to comparing <code>Ds\Vector</code> to <code>SplDoublyLinkedList</code> from previous tests.  Let's look at the time it takes to perform 2‚Åø <code>pop</code> operations, resizing from 2‚Åø to zero. <br><img src="https://habrastorage.org/files/949/501/6ea/9495016ea23647cbb0907c275e97e337.gif"><br><h2>  Queue </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">A queue</a> is a data type with a paradigm of access to the elements <i>‚Äúfirst come, first come out‚Äù</i> <i>(‚ÄúFIFO‚Äù, ‚ÄúFirst In - First Out‚Äù)</i> .  This collection allows you to access items in the order they are added.  Its name speaks for itself, imagine the structure as a line of people standing in line at the cashier in the store. <br><br>  <code>Ds\Queue</code> uses inside of itself <code>Ds\Deque</code> .  <code>SplQueue</code> inherited from <code>SplDoublyLinkedList</code> , so performance will be equivalent to comparing <code>Ds\Deque</code> with <code>SplDoublyLinkedList</code> shown in the previous benchmark. <br><br><h2>  PriorityQueue <i>(priority queue)</i> </h2><br>  The priority queue is very similar to the simple queue.  Items are placed in the queue with the specified priority and the value with the highest priority will always be in front.  Direct queue search with priority is very destructive, it will be a sequential call to <code>pop</code> operations, which is a very costly operation. <br><br>  The priority queue implementation uses <i>max-heap</i> . <br><br>  The principle of <i>‚Äúfirst come, first come out‚Äù is</i> preserved for values ‚Äã‚Äãwith the same priority, so that a group of values ‚Äã‚Äãwith equal priority can be considered as a normal queue. <br><br>  And what about performance?  The next benchmark shows the time and memory required for <code>push</code> 2‚Åø random numbers with a random priority in the queue.  The same random numbers will be used for each of the tests.  A random priority is also generated for the <code>Queue</code> , although it is not used. <br><br>  This is probably the most significant of all benchmarks.  <code>Ds\PriorityQueue</code> works <b>more than twice as fast</b> as <code>SplPriorityQueue</code> and uses only <b>5%</b> of its memory - this is <b>20 times more efficient memory solution</b> . <br><br>  But how?  How can such a big difference <code>SplPriorityQueue</code> when the <code>SplPriorityQueue</code> uses a similar internal structure?  It all comes down to how values ‚Äã‚Äãare paired with priority.  <code>SplPriorityQueue</code> allows you to use any type of value to use as a variable, this leads to the fact that in each pair the priority takes <b>32 bytes</b> . <br><br>  <code>Ds\PriorityQueue</code> only supports integer priorities, so <b>24 bytes are</b> allocated to each pair.  But this is still not enough difference to explain the result. <br><br>  If you look at the <a href="">source code of <code>SplPriorityQueue::insert</code></a> , you will notice that it <b>initializes the array</b> to <b>store the priority value pair</b> . <br><br>  Since  the array has a minimum capacity of 8, then <code>zval + HashTable + 8 * (Bucket + hash) + 2 * zend_string + (8 + 16) byte string payloads</code> is actually allocated for each pair <code>zval + HashTable + 8 * (Bucket + hash) + 2 * zend_string + (8 + 16) byte string payloads</code> <i>=</i> <code>16 + 56 + 36 * 8 + 2 * 24 + 8 + 16</code> <i>=</i> <i><b>432 bytes</b></i> (64 bits). <br><br><h4>  "So ... why is the array?" </h4><br>  <code>SplPriorityQueue</code> uses the same internal <code>SplMaxHeap</code> structure, which requires the value to be a <code>zval</code> type.  The obvious (but inefficient) way to create a <code>zval</code> pair is that  <code>zval</code> itself is used as an <code>array</code> . <br><img src="https://habrastorage.org/files/919/64d/c52/91964dc52a0f4de4b17e034efc27a363.gif"><br><img src="https://habrastorage.org/files/e1c/76b/bde/e1c76bbde06341c8966449e94c918723.gif"><br><h2>  Hashable </h2><br>  An interface that allows objects to <b>be used as keys</b> .  This is an alternative to <code>spl_object_hash</code> , which determines an object into a hash based on its <code>handle:</code>  This means that two objects that would be considered equal when comparing would not have an equal hash, since  they are not the same instance. <br><br>  <code>Hashable</code> introduces only two methods: <code>hash</code> and <code>equals</code> .  Many other languages ‚Äã‚Äãsupport this initially: in Java, <code>hashCode</code> and <code>equals</code> , or in Python, <code>___hash___</code> and <code>__eq__</code> .  There were several RFCs adding this behavior to PHP, but none of them were accepted. <br><br>  All structures will return <code>spl_object_hash</code> if the keys of the objects stored in them do not implement <code>Hashable</code> in themselves. <br><br>  Data structures that work with the <code>Hashable</code> interface: <code>Map</code> and <code>Set</code> . <br><br><h2>  Map <i>(Associative array)</i> </h2><br>  <code>Map</code> is a sequential collection of key-value pairs, almost identical to <code>array</code> in a similar context.  <b>Keys can be of any type</b> , the only condition is uniqueness.  When you add the key again, the values ‚Äã‚Äãare replaced. <br><br>  As in the <code>array</code> , the insertion order is preserved. <br><br><h4>  Strengths </h4><br><ul><li>  Performance and memory efficiency are <b>almost identical to</b> <code>array</code> </li><li>  Automatic release of memory when reducing the size </li><li>  Keys and values ‚Äã‚Äãcan be of any type, including objects </li><li>  Supports work with objects that implement the <code>Hashable</code> interface </li><li>  <code>put</code> , <code>get</code> , <code>remove</code> and <code>containsKey</code> have complexity <code>O(1)</code> </li></ul><br><h4>  disadvantages </h4><br><ul><li>  Cannot be converted to an <code>array</code> if there are object keys. </li><li>  It is not possible to access values ‚Äã‚Äãby index (position) </li></ul><br>  The next benchmark shows that the performance and efficiency of memory between the <code>array</code> and <code>Ds\Map</code> identical.  However, the <code>array</code> will always keep the allocated memory when <code>Ds\Map</code> , in turn, will free up memory if the size falls below a quarter of its potential. <br><img src="https://habrastorage.org/files/90f/7b8/bca/90f7b8bca4014552bc5cc22f069f0ce4.gif"><br><img src="https://habrastorage.org/files/114/3a8/3fd/1143a83fd94946f09d02afb4299db7dc.gif"><br><h2>  Set <i>(Set)</i> </h2><br>  <code>Set</code> is a collection of <b>unique values</b> .  The tutorials will tell you that in the <code>Set</code> structure, the values ‚Äã‚Äãare unordered, unless the implementation provides otherwise.  Take for example Java, <code>java.util.Set</code> is an interface with two main implementations: <code>HashSet</code> and <code>TreeSet</code> .  <code>HashSet</code> provides <code>O(1)</code> complexity for <code>add</code> and <code>remove</code> , a <code>TreeSet</code> provides a sorted dataset, but <code>add</code> and <code>remove</code> complexity increases to <code>O(log n)</code> . <br><br>  <code>Set</code> uses the same internal structure as <code>Map</code> , also based on <code>array</code> .  This means that <code>Set</code> can be sorted in <code>O(n * log(n))</code> when needed, otherwise it is as simple as <code>Map</code> and <code>array</code> . <br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/154441519&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjM76sD2QCWb__PK5STzEKObRKkvQ" width="560" height="315" frameborder="0" title="Set" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><h4>  Strengths </h4><br><ul><li>  <code>add</code> , <code>remove</code> and <code>contains</code> have complexity <code>O(1)</code> </li><li>  Supports work with objects that implement the <code>Hashable</code> interface </li><li>  It supports <b>any type of values</b> ( <code>SplObjectStorage</code> only supports objects). </li><li>  It has the equivalent of bitwise logical operations ( <code>intersection</code> , <code>difference</code> , <code>union</code> , <code>exclusive or</code> ) </li></ul><br><h4>  disadvantages </h4><br><ul><li>  Does not support <code>push</code> , <code>pop</code> , <code>insert</code> , <code>shift</code> or <code>unshift</code> </li><li>  <code>get</code> has complexity <code>O(n)</code> if there are remote values ‚Äã‚Äãbefore indexing, otherwise - <code>O(1)</code> </li></ul><br>  The next benchmark shows the time spent adding 2‚Åø new instances of <code>stdClass</code> .  It shows that <code>Ds\Set</code> <b>slightly faster</b> than <code>SplObjectStorage</code> , and uses <b>about half as much</b> memory. <br><img src="https://habrastorage.org/files/7a8/47b/83e/7a847b83efb341d38831d423cbbefd87.gif"><br><img src="https://habrastorage.org/files/3bc/ff9/3c7/3bcff93c73524f78ad59d0149dc91b68.gif"><br>  A common way to create an array with unique values ‚Äã‚Äãis <code>array_unique</code> , which creates a new <code>array</code> containing only unique values.  But it is important to keep in mind that the <b>values ‚Äã‚Äãin the array are not indexed</b> , <code>in_array</code> is a linear search with complexity <code>O(n)</code> .  <code>array_unique</code> works only with values, excluding keys, each checking for the presence of an array value is a linear search, which gives us a total of <code>O(n¬≤)</code> complexity in time and <code>O(n)</code> memory consumption. <br><img src="https://habrastorage.org/files/0fa/3de/a2d/0fa3dea2d045418b88fc30060b186764.gif"><br><h2>  Answers to expected questions and opinions </h2><br><h4>  Are there any tests? </h4><br>  Now about <b>2600 tests</b> .  It is possible that some tests are redundant, but I would prefer to indirectly check the same thing twice than not to check at all. <br><br><h4>  Documentation?  API reference? </h4><br>  At the time of this writing, there is still no complete documentation, but it will appear along with the first stable release. <br><br>  However, there are some <a href="https://github.com/php-ds/ds/tree/master/php/include"><b>well-documented stub files</b></a> . <br><br><h4>  Can we see how the benchmarks are arranged?  Is there something about them? </h4><br>  All benchmarks were run on the standard <code>PHP 7.0.3</code> build for <b>2015 Macbook Pro</b> .  Results may vary by version and platform. <br><br><h4>  Why are <code>Stack</code> , <code>Queue</code> , <code>Set</code> and <code>Map</code> not interfaces? </h4><br>  I do not believe that there is a need for any alternative implementation.  3 interfaces and 7 classes - this is a good balance between pragmatism and specialization. <br><br><h4>  When should I use <code>Deque</code> instead of <code>Vector</code> ? </h4><br>  If you know for sure that you will not use <code>shift</code> and <code>unshift</code> , use <code>Vector</code> .  For convenient typehipping, you can specify as a type of <code>Sequence</code> . <br><br><h4>  Why are all classes finalized? </h4><br>  The <code>php-ds</code> API design applies the <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">‚ÄúComposition over inheritance</a> . <br><br>  SPL structures are a good example of how inheritance can be misused.  For example, <code>SplStack</code> extends <code>SplDoublyLinkedList</code> , which supports random access by index, <code>shift</code> and <code>unshift</code> - so technically it is not a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA">stack</a> . <br><br>  The Java collection framework also has several interesting cases where inheritance creates ambiguity.  <code>ArrayDeque</code> has three methods for adding elements: <code>add</code> , <code>addLast</code> and <code>push</code> .  This is not bad, because  <code>ArrayDeque</code> implements <code>Deque</code> and <code>Queue</code> , which explains the simultaneous presence of <code>addLast</code> and <code>push</code> .  However, all three methods at once, doing the same thing, cause confusion and inconsistency. <br><br>  The old <code>java.util.Stack</code> extended <code>java.util.Vector</code> , thereby stating that ‚Äúa more complete and consistent set of LIFO operations is provided by the <code>Deque</code> interface and its implementations,‚Äù but <code>Deque</code> includes the <code>addFirst</code> and <code>remove(x)</code> methods that should not be part of the <code>stack</code> structure by API. <br><br><h4>  Just because these structures have disjoint methods does not mean that we cannot do this. </h4><br>  In fact, this is a fair observation, but I still think that composition is more suitable for building data structures.  They are designed to be self-contained, like an <code>array</code> .  You cannot inherit from an <code>array</code> , it forces you to develop your own API around you, using it only to store actual data. <br><br>  Inheritance would also cause unnecessary complexity in the internal implementation. <br><br><h4>  Why do we also need the <code>ds</code> class in the global namespace? </h4><br>  It provides an alternative syntax: <br><img src="https://habrastorage.org/files/8c7/7d6/06b/8c77d606b90f41c589e1b7427ada159c.gif"><br><h4>  Why is there no <i>Linked List</i> ? </h4><br>  The <code>LinkedList</code> class actually appeared first, it seemed like a good start.  But in the end I decided to remove it when I realized that it could not compete with <code>Vector</code> or <code>Deque</code> in any case.  The two main reasons for possible support are: <b>allocation of overhead</b> and <b>locality of links</b> . <br><br>  In the linked list, we add or remove the reserved memory for the structure element <i>(node)</i> whenever a value is added or removed.  A node contains two pointers (in the case of a doubly linked list) to refer to the previous and next nodes.  Both structures, <code>Vector</code> and <code>Deque</code> , allocate a buffer of memory in advance, so there is no need to do it so often.  They also do not need additional pointers to know what the value is before and what after, thereby reducing overhead costs. <br><br><h4>  Will a coherent list use less memory?  is there no buffer? </h4><br>  Only when the collection is very small.  The upper limit of the amount of memory for a <code>Vector</code> is <code>(1.5 * (size - 1)) * zval</code> bytes, at least * 10 * zval *.  In a doubly linked list, it will be used <code>(size * (zval + 8 + 8))</code> .  Therefore, a coherent list will use less memory than <code>Vector</code> only when its size is less than 6 elements. <br><br><h4>  Ok ... the coherent list uses more memory, but why is it slow? </h4><br>  Linked nodes have poor <b><i>spatial locality</i></b> .  This means that the physical location of the node in memory may be far from adjacent nodes.  Thus, iterations over a coherent list jump through memory instead of using the processor cache.  <code>Vector</code> and <code>Deque</code> significant advantage: the elements are physically next to each other. <br><br><blockquote>  ¬ªIncomplete data in structures is the root of all the evils of performance.  Specifically, please say no to linked lists. " <br>  "There is almost nothing more harmful than what you can do to kill all the advantages of modern microprocessors than using a coherent list" <br>  - Chandler Carruth ( <a href="https://youtu.be/fHNmRkzxHWs%3Ft%3D34m42s">CppCon 2014</a> ) </blockquote><br><h4>  PHP is a language for web development - performance is not important. </h4><br>  <b>Performance should not be your top priority</b> .    , , , ,    .    ,   <i>¬´ ¬ª</i> . <br><br>    ,     ,        -: <br><br><ul><li> <a href="http://fabien.potencier.org/print-vs-echo-which-one-is-faster.html">print vs echo, which one is faster?</a> </li><li> <a href="http://fabien.potencier.org/the-php-ternary-operator-fast-or-not.html">The PHP Ternary Operator: Fast or not?</a> </li><li> <a href="http://www.phpbench.com/">The PHP Benchmark: setting the record straight</a> </li><li> <a href="https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html">Disproving the Single Quotes Performance Myth</a> </li></ul><br>       ,     PHP7 -  .     ‚Äî        PHP5. <br><br>        .     API  -        . <b>  </b> ,        . <br><hr><br> <b></b> : <a href="https://twitter.com/rudi_theunissen">Twitter</a> , <a href="https://www.reddit.com/r/PHP/comments/44qsco/efficient_data_structures_for_php_7/">Reddit</a> , <a href="http://chat.stackoverflow.com/rooms/11/php">Room 11</a> <br> <b> </b> : <a href="https://github.com/php-ds">github.com/php-ds</a> <br> <b>:</b> <a href="https://github.com/php-ds/benchmarks">github.com/php-ds/benchmarks</a> </div><p>Source: <a href="https://habr.com/ru/post/280262/">https://habr.com/ru/post/280262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280248/index.html">Vivaldi builds you might not have noticed</a></li>
<li><a href="../280250/index.html">Quick start 1C Trade management for Kazakhstan (Trade and Warehouse)</a></li>
<li><a href="../280254/index.html">Experience starting AHCI in VxWorks653</a></li>
<li><a href="../280256/index.html">Wearable Smart Gateway - wearable device for emergency services</a></li>
<li><a href="../280258/index.html">The digest of interesting materials for the mobile # 146 developer (March 21-27)</a></li>
<li><a href="../280264/index.html">5 tips for preparing your application for multiwindow mode in Android N</a></li>
<li><a href="../280266/index.html">Casual workouts for Swift</a></li>
<li><a href="../280268/index.html">Russian neural network chatbot</a></li>
<li><a href="../280270/index.html">Parsim HTML in C ++ and Gumbo</a></li>
<li><a href="../280272/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ204 (March 21 - 27, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>