<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Zig programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first commentary on the wonderful article Subjective Vision of an Ideal Programming Language was the reference to the Zig programming language . N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Zig programming language</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  The first commentary on the wonderful article <a href="https://habr.com/post/435300/">Subjective Vision of an Ideal Programming Language</a> was the reference to <a href="http://ziglang.org/">the Zig programming language</a> .  Naturally, it became interesting what kind of language it is that claims to be a niche C ++, D and Rust.  I looked - the language seemed nice and somewhat interesting.  Nice C-like syntax, original approach to error handling, built-in coroutines.  This article is a brief overview of the <a href="https://ziglang.org/documentation/master/">official documentation</a> interspersed with your own thoughts and impressions from the launch of code samples. <br><a name="habracut"></a><br><h2>  Getting started </h2><br>  Compiler installation is quite simple; for Windows, just unpack the distribution kit into some kind of folder.  We make a text file hello.zig in the same folder, paste the code from the document there and save it.  Assembly is performed by the command <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  after which hello.exe appears in the same directory. <br><br>  In addition to the assembly, the unit-testing mode is available; for this, the code uses test blocks, and the assembly and running of tests is done by 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  The first oddities </h3><br>  The compiler does not support line wrapping (\ r \ n).  Of course, the fact that the line breaks in each system (Win, Nix, Mac) are some kind of their own is wildness and a relic of the past.  But there's nothing you can do about it, so just choose for example in Notepad ++ the desired format for the compiler. <br><br>  The second oddity, which I stumbled upon by accident - tabs are not supported in the code!  Only spaces.  Sometimes it happens :) <br><br>  However, this is honestly written in the documentation - the truth is at the very end. <br><br><h3>  Comments </h3><br>  Another oddity - Zig does not support multi-line comments.  I remember that in ancient turbo pascal everything was done correctly - nested multiline comments were supported.  Apparently, since then, no language developer has mastered such a simple thing :) <br><br>  But there are documenting comments.  Start with ///.  Must be in certain places - in front of the corresponding objects (variables, functions, classes ...).  If they are somewhere else, a compilation error.  Not bad. <br><br><h3>  Variable declaration </h3><br>  Done in the now fashionable (and ideologically correct) style, when you first write a keyword (const or var), then a name, then an optional type, and then an initial value.  Those.  automatic type inference is available.  Variables must be initialized - if you do not specify an initial value, there will be a compilation error.  However, there is a special value undefined, which can be explicitly used to set uninitialized variables. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Console output </h3><br>  For experiments, we need console output - all examples use this method.  In the area of ‚Äã‚Äãplug-ins prescribed <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  and in the code it is written like this: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  There are some bugs in the compiler, which he honestly reports when trying to output an integer or floating point number in this way: <br><blockquote>  error: compiler bug: it must be casted.  <a href="https://github.com/ziglang/zig/issues/557">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Data types </h2><br><h3>  Primitive types </h3><br>  The type names are taken from Rust (i8, u8, ... i128, u128), there are also special types for binary compatibility with C, 4 types of floating point types (f16, f32, f64, f128).  There is a bool type.  There is a type of zero length void and a special noreturn, which I will discuss below. <br><br>  You can also construct integer types of any length in bits from 1 to 65535. The type name begins with the letter i or u, and then the length is written in bits. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  However, I did not manage to display this value on the console - during the compilation process, an error occurred in LLVM. <br><br>  In general, this is an interesting decision, although ambiguous (IMHO: it‚Äôs right to support precisely long numeric literals at the compiler level, but it‚Äôs not very good naming of types, it‚Äôs better to do it honestly through the template type).  And why the limit is 65535?  Do libraries like GMP seem to impose such restrictions? <br><br><h3>  String literals </h3><br>  These are arrays of characters (without a terminating zero at the end).  For literals with a terminating zero, the prefix 'c' is used. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Like most languages, Zig supports standard escape sequences and the insertion of Unicode characters through their codes (\ uNNNN, \ UNNNNNN where N is a hexadecimal number). <br>  Multiline literals are formed using two backslashes at the beginning of each line.  No quotes are required.  That is, some attempt to make raw lines, but IMHO is unsuccessful - the advantage of raw lines is that you can insert any piece of text into the code from anywhere - and ideally you don‚Äôt change anything, but here you‚Äôll have to add \\ at the beginning of each line. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Integer literals </h3><br>  All as in si-like languages.  I am very pleased that the octal literals use the prefix 0o, and not just zero as in C.  Binary literals with the prefix 0b are also supported.  Floating point literals can be hexadecimal (as is done in <a href="https://gcc.gnu.org/onlinedocs/gcc/Hex-Floats.html">the GCC extension</a> ). <br><br><h3>  Operations </h3><br>  Of course, there are standard arithmetic, logical and bitwise C operations.  Abbreviated operations are supported (+ =, etc.).  Instead of &amp;&amp; and ||  keywords and and or are used.  An interesting point - additionally supported operations with guaranteed overflow semantics (wraparound semantics).  They look like this: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  In this case, the usual arithmetic operations do not guarantee overflow and their results in the case of overflow are considered undefined (and for constants, compilation errors are generated).  IMHO is a bit strange, but apparently made of some deep considerations of compatibility with the semantics of the C language. <br><br><h3>  Arrays </h3><br>  Array literals look like this: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  Strings are arrays of characters, as in C.  Indexing is a classic square brackets.  The operations of addition (concatenation) and multiplication of arrays are provided.  A very interesting thing, and if everything is clear with concatenation, then multiplication - I waited until someone implements it, and I waited :) In Assembler (!) There is a dup operation that allows you to generate repetitive data.  Now in Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Pointers </h3><br>  The syntax is similar to C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  For dereferencing (taking values ‚Äã‚Äãon the pointer), an unusual postfix operation is used: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  Pointer type is explicitly set by setting an asterisk in front of the type name. <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Slices (slices) </h3><br>  A data structure built into the language that allows reference to an array or part of it.  Contains a pointer to the first element and the number of elements.  It looks like this: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  It seems to be taken from Go, not sure.  And also I'm not sure if it was worth building it into the language, despite the fact that the implementation in such an OOP language of such a thing is quite elementary. <br><br><h3>  Structures </h3><br>  An interesting way to declare a structure is to declare a constant, the type of which is automatically displayed as ‚Äútype‚Äù (type), and that is what is used as the name of the structure.  And the structure itself (struct) "nameless." <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  The name cannot be set in the usual way in C-like languages, but the compiler displays the name of the type according to certain rules - in particular, in the above case it will be the same as the "type" constant. <br><br>  In general, the language does not guarantee the order of fields and their alignment in memory.  If guarantees are needed, then ‚Äúpacked‚Äù structures should be used. <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Initialization - in the style of sishnyh designists: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Structures may have methods.  However, placing a method in a structure is simply using the structure as a namespace;  unlike C ++, no implicit this arguments are passed. <br><br><h3>  Transfers </h3><br>  In general, the same as in C / C ++.  There are some convenient built-in means of accessing meta-information, for example, the number of fields and their names, implemented by syntax macros built into the language (which are called builtin functions in the documentation). <br><br>  For "binary compatibility with C" provides some extern enums. <br><br>  To specify the type that should be the basis of the listing, the following construction is used: <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  where u8 is the base type. <br>  Enumerations can have methods like structures (i.e. use the name of the enumeration as a namespace). <br><br><h3>  Unions </h3><br>  As I understand it, the union in Zig is an algebraic type-sum, i.e.  contains a hidden tag field that identifies which of the join fields is ‚Äúactive.‚Äù  ‚ÄúActivation‚Äù of another field is performed by complete reassignment of the whole union.  Example from documentation <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Associations can also explicitly use enums for a tag. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  Associations, like enumerations and structures, can also provide their own namespace for methods. <br><br><h3>  Optional Types </h3><br>  Zig has built-in support for optionals.  A question mark is added in front of the type name: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Interestingly, one thing is implemented in Zig, the possibility of which I suspected, but I was not sure whether it was right or not.  Pointers are made compatible with optionals without adding an additional hidden field (‚Äútag‚Äù), which stores the sign of the validity of the value;  null is used as an invalid value.  Thus, the reference types represented in Zig by pointers do not even require additional memory for ‚Äúoptionalness‚Äù.  In this case, the assignment of the usual pointers to null is prohibited. <br><br><h3>  Types of errors </h3><br>  Similar to optional types, but instead of a boolean tag ("really-invalid"), an enumeration element is used that corresponds to the error code.  The syntax is similar to optionals, an exclamation mark is added instead of a question mark.  Thus, these types can be used, for example, to return from functions: either the result object of the successful operation of the function is returned, or an error with the corresponding code.  Error Types are an important part of the Zig language error handling system, more details in the Error Handling section. <br><br><h3>  Void type </h3><br>  Variables of type void and operations with them are possible in Zig. <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  no code is generated for such operations;  This type is mainly useful for metaprogramming. <br><br>  There is also a c_void type for C compatibility. <br><br><h2>  Control Operators and Functions </h2><br>  These include: blocks, switch, while, for, if, else, break, continue.  To group the code using standard braces.  Just as in C / C ++, blocks are used to limit the scope of variables.  Blocks can be viewed as expressions.  There is no goto in the language, but there are labels that can be used with the break and continue operators.  By default, these operators work with cycles, but if the block has a label, you can use it. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  The switch statement differs from the switch in that it does not have ‚Äúfallthrough‚Äù, i.e.  only one condition is executed (case) and the switch is exited.  The syntax is more compact: instead of the case, the arrow "=&gt;" is used.  Switch can also be considered as an expression. <br><br>  The while and if statements are generally the same as in all C-like languages.  The for statement is more like foreach.  All of them can be considered as expressions.  Of the new features, while and for, as well as if, can have an else block, which is executed if there has been no iteration of the loop. <br><br>  And here it is time to talk about one common feature for the switch, while, which is in some way borrowed from the concept of foreach cycles - ‚Äúcapturing‚Äù variables.  It looks like this: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Here, the while argument is a kind of ‚Äúsource‚Äù of data that can be optional, for for an array or slice, and in a variable located between two vertical lines there is a ‚Äúunwrapped‚Äù value ‚Äî that is,  the current element of the array or slice (or a pointer to it), the internal value of an optional type (or a pointer to it). <br><br><h3>  Operators defer and errdefer </h3><br>  The deferred operator borrowed from Go.  It works the same way - the argument of this operator is executed when leaving the scope in which the operator is used.  Additionally, an errdefer operator is provided, which works if an error type is returned from the function with an active error code.  This is part of the original error handling system in Zig. <br><br><h3>  Unreachable operator </h3><br>  Element of contract programming.  A special keyword that is put where control should not come under any circumstances.  If it does come there, then in the Debug and ReleaseSafe modes, a panic is generated, and in ReleaseFast the optimizer throws out these branches completely. <br><br><h3>  noreturn </h3><br>  Technically, it is a type that is compatible with any other type in expressions.  This is possible due to the fact that there will never be a return of this type of object.  Since in Zig operators are expressions, we need a special type for expressions that will never be evaluated.  This happens when the right-hand side of the expression irrevocably transfers control somewhere outside.  These include break, continue, return, unreachable, infinite loops and functions that never return a control.  For comparison, a call to a normal function (returning control) is not a noreturn operator, because control, though transferred outside, will be returned to the call point sooner or later. <br><br>  Thus, such expressions become possible: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  The variable a gets the value returned by the if / else operator.  For this, the parts (and if and else) must return an expression of the same type.  The if part returns bool, the else part is of type noreturn, which is technically compatible with any type, as a result, the code is compiled without errors. <br><br><h3>  Functions </h3><br>  The syntax is classical for languages ‚Äã‚Äãof this type: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  In general, the functions look pretty standard.  So far I have not noticed signs of first-class functions, but my acquaintance with the language is very superficial, I can be wrong.  Although perhaps this is not done yet. <br><br>  Another interesting feature is that in Zig, you can only ignore returned values ‚Äã‚Äãexplicitly with the underscore _ <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  The reflection is provided, allowing to receive various information on function <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Code execution at compile time </h2><br>  Zig provides the most powerful opportunity - the execution of code written in zig during compilation.  In order for the code to be executed at compile time, it is enough to enclose it in a block with the comptime keyword.  The same function can be called both at compile time and at run time, which allows you to write universal code.  Of course, there are some limitations associated with different contexts of the code.  For example, in the documentation in a variety of examples, comptime is used for compile-time checks: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  But of course the power of this operator is far from being fully disclosed.  Thus, the description of the language provides a classic example of the effective use of syntax macros - the implementation of a function similar to printf, but which parses the format string and performs all the necessary types of arguments at the compilation stage. <br><br>  Also, the word comptime is used to specify the parameters of the compile-time functions, which is similar to the C ++ template functions. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Error processing </h2><br>  In Zig, an original error-handling system was developed.  This can be called ‚Äúexplicit exceptions‚Äù (in this language, explicitness is generally one of the idioms).  This is also similar to return codes in Go, but everything is different. <br><br>  The Zig error handling system is based on special enumerations for implementing custom error codes (error) and ‚Äútypes-errors‚Äù built on their basis (an algebraic type-sum combining the return type of a function and an error code). <br><br>  Error enumerations are announced in the same way as ordinary enumerations: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  However, all error codes get values ‚Äã‚Äãgreater than zero;  also, if you declare a code with the same name in two enums, it will receive the same value.  However, implicit conversions between different error enumerations are prohibited. <br><br>  The keyword anyerror means an enumeration that includes all error codes. <br><br>  Like optional types, the language supports the formation of error types using special syntax.  The type! U64 is the abbreviated form of anyerror! U64, which in turn means a union (variant), including the type u64 and the type anyerror (as I understand it, code 0 is reserved for the absence of an error and the validity of the data field, the remaining codes are proper error codes). <br><br>  The catch keyword allows you to catch the error and turn it into a default value: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  So, if an error occurs in the parseU64 function that returns the type! U64, then catch will ‚Äúcatch‚Äù it and return the default value of 13. <br><br>  The try keyword allows you to ‚Äúforward‚Äù an error to the upper level (that is, to the level of the calling function).  View Code <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  equivalent to this: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Here the following happens: parseU64 is called, if an error is returned from it - it is intercepted by the catch operator, in which the error code is extracted using the ‚Äúcapture‚Äù syntax, placed in the err variable, which is returned via! Void to the calling function. <br><br>  Also, the errdefer operator described earlier applies to error handling.  Code that is an errdefer argument is executed only if the function returns an error. <br><br>  Some more features.  Using the operator ||  you can merge error sets <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  Zig also provides the ability to trace errors.     stack trace,      ,          try       . <br><br>  ,     Zig     ,       C++,      Go.  ,        ‚Äî  4 ,        ;   ‚Äî    .    ++,        -    .     ‚Äî      . <br><br><h2>  </h2><br>  Zig   .  ,      async,         (  ,   ). <br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br> async     promise-&gt;T ( T ‚Äî   ).       . <br><br>       suspend, resume  cancel.   suspend        .    suspend,         . <br><br> resume    promise-&gt;T       ,     . <br><br> cancel   . <br><br>          (  )  .   : <br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="image"><br><br>  ( )  ‚Äî  await.   ,   ,  ,   (,    ).          ,      : <br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="image"><br><br><h2>   </h2><br> builtin functions ‚Äî    ,          . ,      ¬´  ¬ª,         . builtin'      (sizeOf, tagName, TagType, typeInfo, typeName, typeOf),      (import).      builtin' C/C++ ‚Äî     ,     sqrt, popCount, slhExact  ..  ,          . <br><br><h3>   </h3><br>        .      ,     ,              . ++ ,   ,       ,         -        . Rust ,      ,    . D ‚Äî  ,     ,          Java,      -     .   Zig ‚Äî    .  ,         . </div><p>Source: <a href="https://habr.com/ru/post/435872/">https://habr.com/ru/post/435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435862/index.html">Hall of Fame Consumer Electronics: Stories of the Best Gadgets of the Last 50 Years, Part 4</a></li>
<li><a href="../435864/index.html">Mapping Netty Requests</a></li>
<li><a href="../435866/index.html">Release IT: a new platform for launching products and services at the SXSW 2019 festival</a></li>
<li><a href="../435868/index.html">Slush 2018. Day preview</a></li>
<li><a href="../435870/index.html">Cybernetic orchestra. Orchestration of Docker containers with .NET Core applications in the cloud</a></li>
<li><a href="../435874/index.html">How to save your and other people's time at the interviews, or a little bit about the errors of HR</a></li>
<li><a href="../435876/index.html">Detailed setting of the browser Firefox</a></li>
<li><a href="../435878/index.html">Amateur in opensource - lessons learned for 3 years</a></li>
<li><a href="../435880/index.html">Changing the schema of PostgreSQL tables without long locks. Yandex lecture</a></li>
<li><a href="../435882/index.html">Review of Xiaomi Mi Box S and a small comparison with Mi Box 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>