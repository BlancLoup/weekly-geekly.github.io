<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL 9.4 What's New?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! The release of PostgreSQL 9.4 is not far off and it will be useful to go over some of the innovations introduced in this version. The articl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL 9.4 What's New?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e4d/bbf/55f/e4dbbf55fe4b41a6be0500fe74f738f1.png"><br><br>  Good day!  The release of PostgreSQL 9.4 is not far off and it will be useful to go over some of the innovations introduced in this version.  The article will cover (for the most part, the client model): <br><br><ul><li>  <a href="https://habr.com/ru/post/234909/">changes in autoupdate views</a> </li><li>  <a href="https://habr.com/ru/post/234909/">change in materialized views</a> </li><li>  <a href="https://habr.com/ru/post/234909/">ALTER SYSTEM command to set configuration parameters</a> </li><li>  <a href="https://habr.com/ru/post/234909/">the WITH ORDINALITY option for functions returning a rowset</a> </li><li>  <a href="https://habr.com/ru/post/234909/">new features for aggregated data</a> </li><li>  <a href="https://habr.com/ru/post/234909/">GIN and GiST index enhancements</a> </li><li>  <a href="https://habr.com/ru/post/234909/">improved output from the EXPLAIN command</a> </li><li>  <a href="https://habr.com/ru/post/234909/">warming up the cache</a> </li><li>  <a href="https://habr.com/ru/post/234909/">triggers for external tables</a> </li><li>  <a href="https://habr.com/ru/post/234909/">changes for json and new jsonb data type</a> </li></ul><br><a name="habracut"></a><br><a name="autoupdatable_views"></a><br><h5>  <b>Changes in auto-update views</b> </h5><br>  Auto-renewable views ( <i>autoupdatable views</i> ) are views on which you can perform <b>DML</b> operations.  Conditions for such performances: <br><ul><li>  only one entity (table or view) in the <b>FROM</b> list </li><li>  no operators <b>WITH</b> , <b>DISTINCT</b> , <b>GROUP BY</b> , <b>HAVING</b> , <b>LIMIT</b> and <b>OFFSET</b> </li><li>  lack of operations on <b>UNION</b> , <b>INTERSECT</b> and <b>EXCEPT</b> sets </li><li>  functions and operators are not applied to fields </li></ul><br>  These views were provided in PostgreSQL 9.3.  In version 9.4 made some additions to them.  One of them removes the restriction related to the fact that in this view there can be no fields to which functions or operators are applied (in 9.3, if there is at least one such field field, the view becomes non-auto-updating).  In 9.4, there is an opportunity to work with the other fields.  We illustrate this with an example. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Create a reference book and build on it a simple auto-update view: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, author <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> pk_book_id PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> uk_book <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, author ) ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> book ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, author, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( <span class="hljs-string"><span class="hljs-string">' ‚Ññ1'</span></span>, <span class="hljs-string"><span class="hljs-string">' . .'</span></span>, <span class="hljs-number"><span class="hljs-number">2010</span></span> ), ( <span class="hljs-string"><span class="hljs-string">' ‚Ññ2'</span></span>, <span class="hljs-string"><span class="hljs-string">' . .'</span></span>, <span class="hljs-number"><span class="hljs-number">2011</span></span> ), ( <span class="hljs-string"><span class="hljs-string">' ‚Ññ3'</span></span>, <span class="hljs-string"><span class="hljs-string">' . .'</span></span>, <span class="hljs-number"><span class="hljs-number">2012</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vw_book <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.id, b.name, b.author, b.year, ( b.year &gt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span> ) - <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_new <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> book b;</code> </pre> <br>  Update the data: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   ,     UPDATE vw_book SET name = ' ‚Ññ10' WHERE name = ' ‚Ññ1'; -- ,  is_new   UPDATE vw_book SET is_new = false WHERE name = ' ‚Ññ3'; -- ,   SELECT * FROM vw_book b; --    ,     SELECT c.column_name, ( is_updatable = 'YES' ) AS is_updatable FROM information_schema.columns c WHERE c.table_name = 'vw_book' ORDER BY ordinal_position;</span></span></code> </pre><br>  For auto-updated views, the <b>WITH CHECK OPTION</b> option has become available.  Its meaning is that, with <b>INSERT</b> and <b>UPDATE</b> , a check will be added to the view that the added or modified data is not limited to the <b>WHERE</b> condition in the view.  For example, we have a presentation in which old books are selected and it is necessary to prohibit the addition of new books through this presentation: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  ,         CREATE OR REPLACE VIEW vw_book_archive AS SELECT b.id, b.name, b.author, b.year FROM vw_book b WHERE b.is_new = false WITH CHECK OPTION; -- ,     year    INSERT INTO vw_book_archive ( name, author, year ) VALUES ( ' ‚Ññ100', ' . .', 2014 ); --   INSERT INTO vw_book_archive ( name, author, year ) VALUES ( ' ‚Ññ100', ' . .', 2010 );</span></span></code> </pre><br>  Further, the views announced with the <i>security_barrier</i> option no longer cease to be auto-updating.  Consider <i>security_barrier in</i> more detail. <br><br>  Add a field to the books where the promotion code will be located: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    DELETE FROM book; INSERT INTO book ( id, name, author, year ) VALUES ( 1, ' ‚Ññ1', ' . .', 2010 ), ( 2, ' ‚Ññ2', ' . .', 2011 ), ( 3, ' ‚Ññ3', ' . .', 2012 ); --   ALTER TABLE book ADD COLUMN promotion_code text; --    UPDATE book SET promotion_code = 'CODE_' || id;</span></span></code> </pre><br>  Let's create a view that returns books (excluding a certain secret book) and their promotional codes, as well as a function that displays the name of the book and its code through RAISE NOTICE: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vw_book_list <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> book b <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.name != <span class="hljs-string"><span class="hljs-string">' ‚Ññ1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> fn_book_promotion_code ( p_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, p_code <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RAISE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span> <span class="hljs-string"><span class="hljs-string">'Book "%" has code "%"'</span></span>, p_name, p_code; RETURN true; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">COST</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><br>  Let's make a sample from this view (while calling <i>fn_book_promotion_code</i> to display the promotion code of the book) and look at the query plan: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, promotion_code <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vw_book_list l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fn_book_promotion_code ( l.name, l.promotion_code ); <span class="hljs-comment"><span class="hljs-comment">--   : --  ‚Ññ2 CODE_2 --  ‚Ññ3 CODE_3 --   : -- NOTICE: Book " ‚Ññ2" has code "CODE_2" -- NOTICE: Book " ‚Ññ3" has code "CODE_3" EXPLAIN ANALYZE SELECT name, promotion_code FROM vw_book_list l WHERE fn_book_promotion_code ( l.name, l.promotion_code ); -- Seq Scan on book b (cost=0.00..1.79 rows=1 width=23) (actual time=0.185..0.217 rows=2 loops=1) Filter: ((name &lt;&gt; ' ‚Ññ1'::text) AND fn_book_promotion_code(name, promotion_code)) Rows Removed by Filter: 1 Planning time: 0.064 ms Execution time: 0.229 ms</span></span></code> </pre><br>  Note that the lines are read sequentially, the filter first checks the match of the name of the book, and then the <i>fn_book_promotion_code</i> function is <i>called</i> .  Let us now try to reduce the cost of calling functions and observe what has changed in the query results and query plan: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> fn_book_promotion_code ( p_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, p_code <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RAISE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span> <span class="hljs-string"><span class="hljs-string">'Book "%" has code "%"'</span></span>, p_name, p_code; RETURN true; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">COST</span></span> <span class="hljs-number"><span class="hljs-number">0.01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, promotion_code <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vw_book_list l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fn_book_promotion_code ( l.name, l.promotion_code ); <span class="hljs-comment"><span class="hljs-comment">--   : --  ‚Ññ2 CODE_2 --  ‚Ññ3 CODE_3 --      : -- NOTICE: Book " ‚Ññ1" has code "CODE_1" -- NOTICE: Book " ‚Ññ2" has code "CODE_2" -- NOTICE: Book " ‚Ññ3" has code "CODE_3" EXPLAIN ANALYZE SELECT name, promotion_code FROM vw_book_list l WHERE fn_book_promotion_code ( l.name, l.promotion_code ); -- Seq Scan on book b (cost=0.00..1.04 rows=1 width=23) (actual time=0.215..0.240 rows=2 loops=1) Filter: (fn_book_promotion_code(name, promotion_code) AND (name &lt;&gt; ' ‚Ññ1'::text)) Rows Removed by Filter: 1 Planning time: 0.064 ms Execution time: 0.254 ms</span></span></code> </pre><br>  Since the cost of calling a function is meager, the scheduler first calls it and then checks the name of the book.  That, respectively, allows you to find out the code of the secret book.  To prevent this situation, the vw_book_list view should be created with the <i>security_barrier</i> option: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vw_book_list <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> ( security_barrier = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> book b <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.name != <span class="hljs-string"><span class="hljs-string">' ‚Ññ1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, promotion_code <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vw_book_list l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fn_book_promotion_code ( l.name, l.promotion_code ); <span class="hljs-comment"><span class="hljs-comment">--  : --  ‚Ññ2 CODE_2 --  ‚Ññ3 CODE_3 --  : -- NOTICE: Book " ‚Ññ2" has code "CODE_2" -- NOTICE: Book " ‚Ññ3" has code "CODE_3" EXPLAIN ANALYZE SELECT name, promotion_code FROM vw_book_list l WHERE fn_book_promotion_code ( l.name, l.promotion_code ); -- Subquery Scan on l (cost=0.00..1.06 rows=1 width=23) (actual time=0.078..0.106 rows=2 loops=1) Filter: fn_book_promotion_code(l.name, l.promotion_code) -&gt; Seq Scan on book b (cost=0.00..1.04 rows=2 width=52) (actual time=0.009..0.010 rows=2 loops=1) Filter: (name &lt;&gt; ' ‚Ññ1'::text) Rows Removed by Filter: 1 Planning time: 0.069 ms Execution time: 0.122 ms</span></span></code> </pre><br>  Now the scheduler selected the filter with the function call as a separate subquery.  The <i>vw_book_list view</i> remains auto-updating: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vw_book_list <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> promotion_code = <span class="hljs-string"><span class="hljs-string">'CODE_555'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">' ‚Ññ2'</span></span>;</code> </pre><br><a name="materialized_views"></a><br><h5>  <b>Changes in materialized views</b> </h5><br>  The main problem of the materialized views, which appeared in PostgreSQL 9.3, was that during the process of updating the view an exclusive ( <b>ACCESS EXCLUSIVE</b> ) lock was used, making it impossible to query the view.  In 9.4, for the <b>REFRESH MATERIALIZED VIEW</b> <b>command, the CONCURRENTLY</b> option has been <b>added</b> with which the update of the materialized view uses an <b>EXCLUSIVE</b> lock, compatible with <b>ACCESS SHARE</b> concurrency locks arising from <b>SELECT</b> queries.  Behind the scenes, with this update, a temporary version of this view is created, then a comparison is made and, for differences, the corresponding <b>INSERT</b> and <b>DELETE</b> commands are executed.  This approach requires the creation of <b>UNIQUE INDEX</b> for one or more fields of the materialized view.  Let's look at it in action: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   CREATE TABLE author ( id serial NOT NULL, first_name text NOT NULL, last_name text NOT NULL, CONSTRAINT pk_author_id PRIMARY KEY ( id ), CONSTRAINT uk_author_name UNIQUE ( first_name, last_name ) ); --   CREATE TABLE publication ( id serial NOT NULL, author_id integer NOT NULL, name text NOT NULL, CONSTRAINT pk_publication_id PRIMARY KEY ( id ), CONSTRAINT fk_publication_author_id FOREIGN KEY ( author_id ) REFERENCES author ( id ), CONSTRAINT uk_publication_name UNIQUE ( author_id, name ) ); --   INSERT INTO author ( first_name, last_name ) VALUES ( '', '' ); --  id = 1 INSERT INTO author ( first_name, last_name ) VALUES ( '', '' ); --  id = 2 INSERT INTO publication ( author_id, name ) VALUES ( 1, ' ‚Ññ' || generate_series ( 1, 1000000 ) || ')' ); INSERT INTO publication ( author_id, name ) VALUES ( 2, ' ' ), ( 2, '  ' ); ‚Äì-      CREATE MATERIALIZED VIEW mvw_publication AS SELECT p.id, a.first_name || ' ' || a.last_name AS author_name, p.name FROM publication p INNER JOIN author a ON a.id = p.author_id; CREATE UNIQUE INDEX idx_mvw_publication_id ON mvw_ publication ( id ); --    REFRESH MATERIALIZED VIEW CONCURRENTLY mvw_publication; ‚Äì-   ... ‚Äì-     (  ) SELECT * FROM mvw_publication; ‚Äì-   SELECT l.mode FROM pg_locks l INNER JOIN pg_class c ON c.oid = l.relation WHERE .relname = 'mvw_publication';</span></span></code> </pre><br><a name="alter_system"></a><br><h5>  <b>ALTER SYSTEM command to set configuration parameters</b> </h5><br>  This command allows you to change server configuration parameters via an SQL query.  Unlike the <b>SET</b> and <i>set_config commands</i> , which <i>affect the</i> session (or transaction), the change will be permanent.  In fact, the parameter is added to the $ PGDATA / postgresql.auto.conf file, which is read by the server (when starting or receiving a <b>SIGHUP</b> signal) after reading postgresql.conf.  Examples of this command: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   ALTER SYSTEM SET log_min_duration_statement = '1min'; --   ALTER SYSTEM SET log_min_duration_statement TO '2min'; --   ALTER SYSTEM SET log_min_duration_statement TO DEFAULT;</span></span></code> </pre><br><a name="with_ordinality"></a><br><h5>  <b>WITH ORDINALITY option for returning rowsets</b> </h5><br>  For the <i>unnest</i> function (and other functions that return a rowset), the <b>WITH ORDINALITY</b> option is added, which displays the order of the string.  Also, in unnest you can now list several arrays, each of which will be a separate column: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span>[<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'dog'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span>[<span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>, <span class="hljs-string"><span class="hljs-string">'Lili'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDINALITY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ( cat, dog, mouse ); <span class="hljs-comment"><span class="hljs-comment">-- : -- cat Tom 1 -- dog Jack 2 -- mouse Lili 3 --      SELECT *, row_number() OVER () AS i FROM unnest ( ARRAY['cat', 'dog', 'mouse'], ARRAY['Tom', 'Jack', 'Lili'] ) AS t ( cat, dog, mouse );</span></span></code> </pre><br><a name="aggregate_funcs"></a><br><h5>  <b>New features for aggregated data</b> </h5><br>  The standard functions-aggregates ( <i>sum</i> , <i>avg</i> , <i>corr</i> , etc.) added functions for ordered sets and sets of hypothetical series: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   CREATE TABLE salary AS SELECT ( random ( ) * 100 + 2000 )::int AS value FROM generate_series ( 1, 100 ); --     SELECT mode() WITHIN GROUP ( ORDER BY value DESC ) FROM salary; --  ,       SELECT percentile_disc ( 0.5 ) WITHIN GROUP ( ORDER BY value ) FROM salary; -- ,     (       ) SELECT percentile_cont ( 0.5 ) WITHIN GROUP ( ORDER BY value ) FROM salary; --     ( 1 / n  1) SELECT s.value, cume_dist ( 2026 ) WITHIN GROUP ( ORDER BY value ) FROM salary s GROUP BY s.value;</span></span></code> </pre><br>  There is also an option for filtering data that will fall into aggregation functions: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  ,    2050 SELECT avg ( s.value ) FILTER ( WHERE s.value &gt;= 2050 ) FROM salary s; --    CASE WHEN ‚Ä¶ SELECT avg ( CASE WHEN s.value &gt;= 2050 THEN s.value ELSE NULL END ) FROM salary s;</span></span></code> </pre><br><a name="gin_gist"></a><br><h5>  <b>GIN and GiST index improvements</b> </h5><br>  <b>GIN</b> indices (with multiple fields) used for full-text search are now faster and take up less space.  <b>GiST</b> has <b>added</b> support for the <b>inet</b> and <b>cidr types</b> : <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  IP- CREATE TABLE machine ( ip cidr ); INSERT INTO machine ( ip ) VALUES ( '192.168.1.1'::cidr ), ( '192.168.1.10'::cidr ), ( '192.168.2.11'::cidr ); --     CREATE INDEX idx_machine_ip ON machine USING GiST ( ip inet_ops ); --    192.168.1.0/24 SELECT * FROM machine WHERE ip &amp;&amp; '192.168.1.0/24'::cidr;</span></span></code> </pre><br><a name="explain"></a><br><h5>  <b>Improved EXPLAIN command output</b> </h5><br>  In the output of the <b>EXPLAIN</b> command, if there is grouping, a column is displayed by which data is grouped.  In addition, the <i>planning time</i> for the query plan is now displayed: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.value, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> ( * ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> salary s <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> s.value <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> ( * ) &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- HashAggregate (cost=2.75..3.60 rows=68 width=4) (actual time=0.045..0.053 rows=26 loops=1) Group Key: value Filter: (count(*) &gt;= 2) Rows Removed by Filter: 42 -&gt; Seq Scan on salary s (cost=0.00..2.00 rows=100 width=4) (actual time=0.007..0.015 rows=100 loops=1) Planning time: 0.042 ms Execution time: 0.082 ms</span></span></code> </pre><br>  If <i>bitmap heap scan is used</i> , then how many blocks are matched ( <i>exact</i> ) and how many are missing ( <i>lossy</i> ): <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    INSERT INTO salary ( value ) SELECT ( random ( ) * 10000 + 1000 )::int AS value FROM generate_series ( 1, 1000000 ); CREATE INDEX idx_salary_value ON salary ( value ); SET work_mem = '64kB'; EXPLAIN ANALYZE SELECT * FROM salary s WHERE s.value BETWEEN 2010 AND 2020; -- Bitmap Heap Scan on salary s (cost=28.83..2739.72 rows=1210 width=4) (actual time=0.370..17.824 rows=1030 loops=1) Recheck Cond: ((value &gt;= 2010) AND (value &lt;= 2020)) Rows Removed by Index Recheck: 96457 Heap Blocks: exact=486 lossy=429 -&gt; Bitmap Index Scan on idx_salary_value (cost=0.00..28.53 rows=1210 width=0) (actual time=0.286..0.286 rows=1030 loops=1) Index Cond: ((value &gt;= 2010) AND (value &lt;= 2020)) Planning time: 0.098 ms Execution time: 17.920 ms SET work_mem = '32MB'; EXPLAIN ANALYZE SELECT * FROM salary s WHERE s.value BETWEEN 2010 AND 2020; -- Bitmap Heap Scan on salary s (cost=28.83..2739.72 rows=1210 width=4) (actual time=0.283..1.214 rows=1030 loops=1) Recheck Cond: ((value &gt;= 2010) AND (value &lt;= 2020)) Heap Blocks: exact=915 -&gt; Bitmap Index Scan on idx_salary_value (cost=0.00..28.53 rows=1210 width=0) (actual time=0.157..0.157 rows=1030 loops=1) Index Cond: ((value &gt;= 2010) AND (value &lt;= 2020)) Planning time: 0.076 ms Execution time: 1.269 ms</span></span></code> </pre><br><a name="prewarm"></a><br><h5>  <b>Warming up cache</b> </h5><br>  In the new <b>pg_prewarm</b> extension, a function of the same name is available, with the help of which the necessary entity is <b>forcedly</b> loaded into the cache (system OS or PostgreSQL).  Let's see how this happens. <br><br>  First, install the extension and create a test table: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION pg_prewarm; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">big</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_to_string ( array_agg ( tx ), <span class="hljs-string"><span class="hljs-string">''</span></span> ) || <span class="hljs-string"><span class="hljs-string">'#'</span></span> || generate_series ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> || generate_series ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> x ) t; <span class="hljs-comment"><span class="hljs-comment">--     ALTER SYSTEM SET shared_buffers = '256MB';</span></span></code> </pre><br>  Now, stop the PostgreSQL server, flush the OS caches to disk and start the server again (there may be other commands in your OS): <br><pre> <code class="bash hljs">/etc/init.d/postgresql-9.4 stop sync /etc/init.d/postgresql-9.4 start</code> </pre><br>  Let‚Äôs look at the test table, observing where the data comes from: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   EXPLAIN ( ANALYZE, BUFFERS ) SELECT * FROM big; -- Seq Scan on big (cost=0.00..76047.00 rows=5000000 width=8) (actual time=0.013..448.978 rows=5000000 loops=1) Buffers: shared read=26047 Planning time: 0.081 ms Execution time: 689.083 ms --   EXPLAIN ( ANALYZE, BUFFERS ) SELECT * FROM big; -- Seq Scan on big (cost=0.00..76047.00 rows=5000000 width=8) (actual time=0.044..449.973 rows=5000000 loops=1) Buffers: shared hit=32 read=26015 Planning time: 0.027 ms Execution time: 692.045 ms --   EXPLAIN ( ANALYZE, BUFFERS ) SELECT * FROM big; -- Seq Scan on big (cost=0.00..76047.00 rows=5000000 width=8) (actual time=0.044..449.973 rows=5000000 loops=1) Buffers: shared hit=32 read=26015 Planning time: 0.027 ms Execution time: 692.045 ms</span></span></code> </pre><br>  It is clearly seen that since there is still nothing in the cache, the data is read from the disk ( <i>shared read</i> ), but with each subsequent request the cache is filled ( <i>shared hit</i> ). <br><br>  Stop the PostgreSQL server again, reset the OS cache and start the server.  And again we will look at the <b>EXPLAIN</b> result, but before that, fill the cache with the data from the test table: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  26047  SELECT pg_prewarm ( 'big' ); EXPLAIN ( ANALYZE, BUFFERS ) SELECT * FROM big; -- Seq Scan on big (cost=0.00..76047.00 rows=5000000 width=8) (actual time=0.007..407.269 rows=5000000 loops=1) Buffers: shared hit=26047 Planning time: 0.129 ms Execution time: 642.834 ms</span></span></code> </pre><br>  All data is already in the cache. <br><a name="foreign_table_triggers"></a><br><h5>  <b>Triggers for external tables</b> </h5><br>  PostgreSQL 9.3 introduced the <b>postgres_fdw</b> extension, which allows read / write access to tables located in another database, the so-called <i>foreign tables</i> .  In 9.4 it is now possible to create triggers for them. <br><br>  Create an external table: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   test0 CREATE TABLE city ( country text NOT NULL, name text NOT NULL, CONSTRAINT uk_city_name UNIQUE ( country, name ) ); --   test1 CREATE EXTENSION postgres_fdw; --    CREATE SERVER fdb_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS ( host 'localhost', port '5432', dbname 'test0' ); --   CREATE USER MAPPING FOR PUBLIC SERVER fdb_server OPTIONS ( password 'pwd' ); --    CREATE FOREIGN TABLE fdb_city ( country text, name text ) SERVER fdb_server OPTIONS ( table_name 'city' );</span></span></code> </pre><br>  Create a trigger that prohibits adding a city called N / A and check it: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   test1 CREATE OR REPLACE FUNCTION tfn_city_change ( ) RETURNS trigger AS $BODY$ BEGIN IF ( NEW.name = 'N/A' ) THEN RAISE EXCEPTION 'City with name "N/A" not allowed'; END IF; RETURN NEW; END $BODY$ LANGUAGE plpgsql VOLATILE; CREATE TRIGGER tr_city_change BEFORE INSERT ON fdb_city FOR EACH ROW EXECUTE PROCEDURE tfn_city_change ( ); --   INSERT INTO fdb_city ( country, name ) VALUES ( 'USA', 'New York' ); --     INSERT INTO fdb_city ( country, name ) VALUES ( 'USA', 'N/A' );</span></span></code> </pre><br>  But in the test0 database, this trigger is ‚Äúnot visible‚Äù, which allows you to specify any city names: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   test0 --   INSERT INTO city ( country, name ) VALUES ( 'Italy', 'N/A' );</span></span></code> </pre><br><a name="json"></a><br><h5>  <b>Changes for json and new jsonb data type</b> </h5><br>  Undoubtedly, the new <i>jsonb</i> type was the most anticipated innovation in PostgreSQL 9.4.  Syntactically, it does not differ from <i>json</i> , but the data is stored in an expanded binary format, which slows down the addition of new data, but ensures high processing speed.  In general, it is better to store JSON in <i>jsonb</i> . <br><br>  For <i>jsonb it</i> is possible to create indexes ( <b>GIN</b> , <b>btree</b> and <b>hash</b> ).  The <b>GIN</b> has two operator classes for it: <br><ul><li>  standard (jsonb_ops) - supports the @&gt;,?,? &amp; and? operators | </li><li>  jsonb_path_ops - supports the @&gt; operator </li></ul><br>  Although the operator class <i>jsonb_path_ops</i> supports only one operator, it is more productive and, as a rule, takes up less space for the same data than <i>jsonb_ops</i> . <br><br>  New features for working with JSON include (for <i>jsonb</i> type, respectively, jsonb_ *): <br><ul><li>  json_array_elements_text - expanding a JSON array into a set of values ‚Äã‚Äãwith type text </li><li>  json_array_elements_text - roll up values ‚Äã‚Äãinto a JSON array </li><li>  json_object - building a JSON object from a text array </li><li>  json_typeof - information about the type of JSON value </li></ul><br>  JSON and PostgreSQL types have this relationship (equivalent for <i>null is</i> not, since NULL in PostgreSQL has different semantics): <br><table><tbody><tr><th>  JSON type </th><th>  PostgreSQL type </th></tr><tr><td>  string </td><td>  text </td></tr><tr><td>  number </td><td>  numeric </td></tr><tr><td>  boolean </td><td>  boolean </td></tr></tbody></table><br>  Let's try to work with JSON: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   CREATE TABLE book ( id serial NOT NULL, name text NOT NULL, params jsonb NOT NULL DEFAULT '{}' ); --   INSERT INTO book ( name, params ) SELECT ' #' || tx, ( '{ "pages": ' || 500 + ( tx % 500 ) || CASE tx % 1000 WHEN 0 THEN ', "gold_edition": true' ELSE '' END || ' }' )::jsonb FROM ( SELECT generate_series ( 1, 1000000 ) x ) t; --  ""  SELECT count ( * ) FROM book WHERE params @&gt; '{ "gold_edition": true }'::jsonb; --       SELECT count ( * ) &gt; 0 FROM book WHERE name = ' #1' AND params ? 'pages'; --     SELECT params -&gt; 'pages' FROM book WHERE name = ' #11'; --   "pages" SELECT jsonb_typeof ( params -&gt; 'pages' ) FROM book WHERE name = ' #11'; --   CREATE INDEX idx_book_params ON book USING gin ( params jsonb_path_ops );</span></span></code> </pre><br>  Operators @&gt;?  and some others are specific to the <i>jsonb</i> type.  A more detailed review of <i>jsonb</i> and performance testing draws on a separate article. <br><br>  The article did not consider server improvements (in particular, related to SSL, VACUUM and backgound_workers).  See changelog for more information.  In conclusion, we would like to note that PostgreSQL is confidently moving both in relational and in NoSQL directions.  Gradually, new features are added, which are improved in the next versions, which is good news. <br><br>  Useful links: <br><ul><li>  <a href="http://www.postgresql.org/docs/9.4/static/release-9-4.html">Release 9.4</a> </li><li>  <a href="http://www.pgcon.org/2014/schedule/attachments/318_pgcon-2014-vodka.pdf">CREATE INDEX ... USING VODKA</a> </li></ul><br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/234909/">https://habr.com/ru/post/234909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234895/index.html">Overview of some versatile LabVIEW virtual instruments to help the developer (with source code)</a></li>
<li><a href="../234899/index.html">PHP 5.6.0 Final Release Released</a></li>
<li><a href="../234901/index.html">NAND Flash Analytics</a></li>
<li><a href="../234905/index.html">Scaling backwards: Yandex's BEM methodology on small projects</a></li>
<li><a href="../234907/index.html">Site analysis. Where to get the data?</a></li>
<li><a href="../234913/index.html">A new version of the distribution for the creation of a pfSense 2.1.5 firewall has been released.</a></li>
<li><a href="../234915/index.html">Samsung has introduced a new smart watch Gear S c OS Tizen and 3G-module</a></li>
<li><a href="../234917/index.html">Gentleman's Set for Amazon Kindle Paperwhite</a></li>
<li><a href="../234919/index.html">Synchronizer for the exchange of encrypted files between the CyberSafe program and cloud resources</a></li>
<li><a href="../234923/index.html">New Microsoft update KB2993651 can also cause BSOD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>