<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to CQRS + Event Sourcing: Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, I started with the basics of CQRS + Event Sourcing. This time I propose to continue and look at ES in more detail. 

 In the exam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to CQRS + Event Sourcing: Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/146429/">last article,</a> I started with the basics of CQRS + Event Sourcing.  This time I propose to continue and look at ES in more detail. <br><br>  In the <a href="https://github.com/AlexShkor/CQRS-Event-Sourcing-Sample--ASP.NET-MVC-">example</a> that I posted with my <a href="http://habrahabr.ru/post/146429/">previous article, the</a> magic of Event Sourcing was hidden behind the abstraction of IRepository and the two methods IRepository.Save () and IRepository.GetById &lt;&gt; (). <br>  In order to understand in more detail what is happening, I decided to talk about the process of saving and loading the aggregate from the Event Store using the example of the <a href="https://github.com/Lokad/lokad-iddd-sample">Lokad IDDD Sample</a> project from Rinat Abdulin.  He has a direct appeal to the Event Store in the application services, without additional abstractions, so everything looks very clear.  Application Service is an analogue of CommandHandler, but which handles all commands of one unit.  This approach is very convenient and we also switched to it in one project. <br><a name="habracut"></a><br><h4>  Applicationservice <br></h4><br>  The IApplicationService interface is extremely simple. <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IApplicationService</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICommand cmd</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  In the Execute method, we pass any commands and we hope that the service will redirect them to the desired handler. <br><br>  Since Rinat in the example has only one Customer unit, the service is also only one CustomerApplicationService.  Actually, therefore, there is no need to make any logic in the base class.  An excellent solution for example in my opinion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The Execute method transfers the command processing to one of the overloads of the When method that matches the signature.  The implementation of the Execute method is very simple using speakers, and there is no need to run on reflection on all methods. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICommand cmd</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pass command to a specific method named when // that can handle the command ((dynamic)this).When((dynamic)cmd); }</span></span></code> </pre><br>  Let's start with the creation command - CreateCustomer. <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreateCustomer</span></span> : <span class="hljs-title"><span class="hljs-title">ICommand</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CustomerId Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Currency Currency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Create {0} named '{1}' with {2}"</span></span>, Id, Name, Currency); } }</code> </pre><br>  In a real project, you will most likely have a message queue between the UI and the ApplicationService, but for an example, Rinat limited himself to directly passing the command to the service's uplink object (see class ApplicationServer). <br>  After the CreateCustomer command gets into the Execute method, it is redirected to the When method. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">When</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CreateCustomer c</span></span></span><span class="hljs-function">)</span></span> { Update(c.Id, a =&gt; a.Create(c.Id,c.Name, c.Currency, _pricingService, DateTime.UtcNow)); }</code> </pre><br>  In the Update method, we pass an aggregate aydishka and an action that calls the method of changing the state of the aggregate.  In general, in my opinion, it is better not to do the Create method of the aggregate, but to create another constructor, since calling the Create method in this context looks a bit strange.  We seem to create an aggregate, but for some reason we pass the Create method as a method of changing the state.  With the designer so would not have happened. <br><br>  Let's go back to the Update method, the next task is to 1) load all events for the current aggregate, 2) create an aggregate and restore its state using loaded events, 3) execute the transferred Action Action execute on the aggregate and 4) save new events if they exist. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomerId id, Action&lt;Customer&gt; execute</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Load event stream from the store EventStream stream = _eventStore.LoadEventStream(id); // create new Customer aggregate from the history Customer customer = new Customer(stream.Events); // execute delegated action execute(customer); // append resulting changes to the stream _eventStore.AppendToStream(id, stream.Version, customer.Changes); }</span></span></code> </pre><br><br><h4>  Recovery condition </h4><br>  In the example that I showed in the last article, the state of the aggregate was stored as private fields in the aggregate class.  This is not very convenient if you want to add snapshots, because  you have to somehow suck up the state every time or use reflection.  Rinat has a much more convenient approach ‚Äî for the state, a separate CustomerState class, which makes it possible to take out projection methods from the aggregate and it is much easier to save and load snapshots, although they are not in the example. <br>  As you can see, the list of events of the same unit is transferred to the constructor of the unit, as it is not difficult to guess, in order for it to restore its state. <br>  The unit in turn delegates the restoration of the state to the CustomerState class. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Aggregate state, which is separate from this class in order to ensure, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> that we modify it ONLY by passing events. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> readonly CustomerState _state; public Customer(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEvent&gt;</span></span></span><span class="hljs-comment"> events) { _state = new CustomerState(events); }</span></span></code> </pre><br>  I will give the code for the entire CustomerState class, I‚Äôll only remove a few When projection methods. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> This is the state of the customer aggregate. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It can be mutated only by passing events to it. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class CustomerState { public string Name { get; private set; } public bool Created { get; private set; } public CustomerId Id { get; private set; } public bool ConsumptionLocked { get; private set; } public bool ManualBilling { get; private set; } public Currency Currency { get; private set; } public CurrencyAmount Balance { get; private set; } public int MaxTransactionId { get; private set; } public CustomerState(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEvent&gt;</span></span></span><span class="hljs-comment"> events) { foreach (var e in events) { Mutate(e); } } ... public void When(CustomerCreated e) { Created = true; Name = e.Name; Id = e.Id; Currency = e.Currency; Balance = new CurrencyAmount(0, e.Currency); } public void When(CustomerRenamed e) { Name = e.Name; } public void Mutate(IEvent e) { // .NET magic to call one of the 'When' handlers with // matching signature ((dynamic) this).When((dynamic)e); } }</span></span></code> </pre><br>  As you can see in the constructor, we forychem run on the transmitted events and transfer them to the Mutate method, which in turn sets them further into a suitable projection method. <br>  You may notice that all properties have a private setter method, which guarantees that the state from the outside can be changed only by passing the corresponding event. <br><br>  Condition restored, now you can and try to change it.  Go back a little to the state change method.  Since I started to deal with the CreateCustomer command, then the aggregate will have a look at the Create method. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomerId id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Currency currency, IPricingService service, DateTime utc</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_state.Created) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"Customer was already created"</span></span>); Apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerCreated { Created = utc, Name = name, Id = id, Currency = currency }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bonus = service.GetWelcomeBonus(currency); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bonus.Amount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) AddPayment(<span class="hljs-string"><span class="hljs-string">"Welcome bonus"</span></span>, bonus, utc); }</code> </pre><br>  Here is the place to check our business rules, since we have access to the current state of the unit.  We have a business rule that Customer can only be created once (although there is also a technical limitation), so when we try to call Create on an already created aggregate, we throw an exception. <br>  If all business rules are satisfied, then we pass the CustomerCreated event to the Apply method.  The Apply method is very simple, it only sends the event to the state object and adds it to the list of current changes. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IList&lt;IEvent&gt; Changes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IEvent&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> CustomerState _state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEvent e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pass each event to modify current in-memory state _state.Mutate(e); // append event to change list for further persistence Changes.Add(e); }</span></span></code> </pre><br>  In most cases, one operation with an aggregate accounts for one event.  But just in the case of the Create method, there may be two events. <br>  After we passed the CustomerCreate event to the Apply method, we can add a welcome bonus to the current customer, if the business rule is satisfied that the bonus amount should be greater than zero.  In this case, the aggregation method AddPayment is called, which does not reduce any checks, but simply triggers the CustomerPaymentAdded event. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPayment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CurrencyAmount amount, DateTime utc</span></span></span><span class="hljs-function">)</span></span> { Apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerPaymentAdded() { Id = _state.Id, Payment = amount, NewBalance = _state.Balance + amount, PaymentName = name, Transaction = _state.MaxTransactionId + <span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUtc = utc }); }</code> </pre><br>  Now we have to save new events and publish them in the Read model.  I suspect that the next line does it. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// append resulting changes to the stream _eventStore.AppendToStream(id, stream.Version, customer.Changes);</span></span></code> </pre><br>  Make sure ... <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppendToStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IIdentity id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> originalVersion, ICollection&lt;IEvent&gt; events</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = IdentityToString(id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = SerializeEvent(events.ToArray()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { _appendOnlyStore.Append(name, data, originalVersion); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(AppendOnlyStoreConcurrencyException e) { <span class="hljs-comment"><span class="hljs-comment">// load server events var server = LoadEventStream(id, 0, int.MaxValue); // throw a real problem throw OptimisticConcurrencyException.Create(server.Version, e.ExpectedStreamVersion, id, server.Events); } // technically there should be a parallel process that queries new changes // from the event store and sends them via messages (avoiding 2PC problem). // however, for demo purposes, we'll just send them to the console from here Console.ForegroundColor = ConsoleColor.DarkGreen; foreach (var @event in events) { Console.WriteLine(" {0} r{1} Event: {2}", id,originalVersion, @event); } Console.ForegroundColor = ConsoleColor.DarkGray; }</span></span></code> </pre><br>  Well, almost pleased.  Events are serialized and saved in the append only store (we are not going to delete and change them).  But instead of sending them to the read-model (to the presentation level), Rinat simply displays them to the console. <br>  However, for example, this is enough. <br>  If you want to see how it all will work with the message queue, you can see <a href="https://github.com/AlexShkor/CQRS-Event-Sourcing-Sample--ASP.NET-MVC-">an example</a> on the github from my previous article.  I changed it a bit and also introduced part of the Event Sourcing infrastructure to the solution.  In this example, I want to show how you can add snapshots. <br><br><h4>  Snapshots </h4><br>  Snapshots are needed to take intermediate pictures of the state of the unit.  This allows us not to load the entire stream of aggregate events, but only those that occurred after we made the last snapshot. <br>  So look at the implementation. <br>  In the UserCommandHandler class, there is an Update method very similar to the one that Rinat has, but for me it still saves and loads snapshots.  Snapshots do every 100 versions. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SnapshotInterval = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><br>  First we bring up a snapshot from the repository, then we load the stream of events that occurred after we made this snapshot.  Then we transfer all this to the designer of the unit. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Action&lt;UserAR&gt; updateAction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snapshot = _snapshotRepository.Load(userId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startVersion = snapshot == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : snapshot.StreamVersion + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = _eventStore.OpenStream(userId, startVersion, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserAR(snapshot, stream); updateAction(user); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> originalVersion = stream.GetVersion(); _eventStore.AppendToStream(userId, originalVersion, user.Changes); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newVersion = originalVersion + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVersion % SnapshotInterval == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _snapshotRepository.Save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Snapshot(userId, newVersion,user.State)); } }</code> </pre><br>  In the constructor, we are trying to get the state from the snapshot or create a new state if there is no snapshot.  On the received state we lose all the missing events, and as a result we get the current version of the aggregate. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserAR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Snapshot snapshot, TransitionStream stream</span></span></span><span class="hljs-function">)</span></span> { _state = snapshot != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? (UserState) snapshot.Payload : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserState(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transition <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> stream.Read()) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transition.Events) { _state.Mutate((IEvent) @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.Data); } } }</code> </pre><br>  After the manipulations with the unit, we check whether the unit version is multiple to the interval through which we make snapshots, and if so, then save the new snapshot to the repository.  To get the state of the aggregate from UserCommandHandler, we had to set the internal getter property of the State for it. <br><br>  That's all, now we have snapshots, which allowed us to restore the state of the unit much faster if it has a lot of events. <br><br><h4>  Feedback </h4><br>  If you are interested in the topic CQRS + ES, please do not hesitate to ask questions in the comments.  You can also write to me in Skype if there is no aka on Habr√©.  Recently, a fellow from Chelyabinsk tapped me on Skype, and thanks to his questions, I had many ideas for the next article.  Since I now have more free time at my disposal, I plan to write them more often. </div><p>Source: <a href="https://habr.com/ru/post/149464/">https://habr.com/ru/post/149464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149448/index.html">Nokia Data Gathering: dealing with drought with a mobile phone</a></li>
<li><a href="../149449/index.html">The path of collapse of the viroid ribozyme or news from fronts using RNAInSpace software was obtained.</a></li>
<li><a href="../149450/index.html">Dynamic mat. functions in C ++</a></li>
<li><a href="../149454/index.html">I fell in love with DelegateClass</a></li>
<li><a href="../149458/index.html">InfiniteWP: manage all sites on WP from one panel</a></li>
<li><a href="../149465/index.html">New Energia version released</a></li>
<li><a href="../149468/index.html">Who answers you in QA. Browser Extension</a></li>
<li><a href="../149470/index.html">Calculation of derivatives using C ++ templates</a></li>
<li><a href="../149471/index.html">Digia intends to strengthen collaboration with KDE and discuss future Qt development with the community</a></li>
<li><a href="../149472/index.html">uTorrent will show ads (non-switchable option)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>