<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do pythonists read Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you encountered the fact that sometimes you need to quickly understand what a piece of code does in a certain unfamiliar language? If the languag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How do pythonists read Haskell</h1><div class="post__text post__text-html js-mediator-article">  Have you encountered the fact that sometimes you need to quickly understand what a piece of code does in a certain unfamiliar language?  If the language is similar to what you are used to, you can usually guess the purpose of most of the code - even if you are not very familiar with all the features of the language. <br>  With Haskell, things are different, because its syntax looks very different than the syntax of traditional languages.  But, in fact, the difference is not so great - you just need to look at the right angle.  Here is a quick, mostly incorrect, and, I hope, useful guide on how Pythonista interprets Haskell code.  By the end, you will be able to understand the following piece (part of the code is omitted after the ellipsis): <br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runCommand</span></span> env cmd state = ... retrieveState = ... saveState state = ... main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> args &lt;- getArgs <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (actions, nonOptions, errors) = getOpt <span class="hljs-type"><span class="hljs-type">Permute</span></span> options args opts &lt;- foldl (&gt;&gt;=) (return startOptions) actions when (null nonOptions) $ printHelp &gt;&gt; throw <span class="hljs-type"><span class="hljs-type">NotEnoughArguments</span></span> command &lt;- fromError $ parseCommand nonOptions currentTerm &lt;- getCurrentTerm <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = <span class="hljs-type"><span class="hljs-type">Environment</span></span> { envCurrentTerm = currentTerm , envOpts = opts } saveState =&lt;&lt; runCommand env command =&lt;&lt; retrieveState</code> </pre> <br><a name="habracut"></a><br><h2>  Types </h2><br>  Ignore everything after <code>::</code> (and also ignore <code>type</code> , <code>class</code> , <code>instance</code> and <code>newtype</code> ).  Some swear types help them understand the code.  If you are completely new, things like <code>Int</code> and <code>String</code> may help, but <code>LayoutClass</code> like <code>LayoutClass</code> and <code>MonadError</code> not.  Do not worry about them. <br><h2>  Arguments </h2><br>  <code>fabc</code> translated to <code>f(a, b, c)</code> .  Haskell omits brackets and commas.  One consequence of this is that sometimes we need parentheses for the arguments: <code>fa (b1 + b2) c</code> translated to <code>f(a, b1 + b2, c)</code> . <br><h2>  Dollar symbol </h2><br>  Since complex expressions like <code>a + b</code> are quite common, and Haskelers <i>do</i> not like brackets, the dollar symbol is used to avoid them: <code>f $ a + b</code> equivalent to <code>f (a + b)</code> and is translated <code> f(a + b)</code> .  You can think of <code>$</code> giant left parenthesis, which automatically closes at the end of the line (and you don‚Äôt have to write anymore))))), hurray!) In particular, you can nest them, and each will create a nesting level: <code>f $ gx $ hy $ a + b</code> is equivalent to <code>f (gx (hy (a + b)))</code> and is translated as <code>f(g(x,h(y,a + b))</code> (although some consider it a bad practice). <br>  Sometimes you can see this option: <code>&lt;$&gt;</code> (with angle brackets).  You can consider it the same as <code>$</code> .  <code>&lt;*&gt;</code> Also occurs - pretend that it is a comma, and <code>f &lt;$&gt; a &lt;*&gt; b</code> translated to <code>f(a, b)</code> . <br><h2>  Reverse apostrophes </h2><br>  <code>x `f` y</code> translates to <code>f(x,y)</code> .  The thing between apostrophes is a function, usually binary, and arguments on the right and left. <br><h2>  Equals symbol </h2><br>  Two values ‚Äã‚Äãare possible.  At the beginning of a block of code, it means that you simply define a function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doThisThing</span></span> abc = ...</code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThisThing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br>  Next to the keyword, <code>let</code> acts as an assignment operator: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> a = b + c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...</code> </pre>  ==&gt; <pre> <code class="python hljs">a = b + c ...</code> </pre> <br><br><h2>  Left arrow </h2><br>  It also works as an assignment operator: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> &lt;- createEntry x</code> </pre>  ==&gt; <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> = createEntry(x)</code> </pre> <br>  Why don't we use the equal sign?  Witch.  (More precisely, <code>createEntry x</code> has side effects. More precisely, it means that the expression is monadic. But this is all a witch. Don't pay attention to it yet.) <br><br><h2>  Right arrow </h2><br>  It's Complicated.  We return to them later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Keyword <code>do</code> </h2><br>  Noises  You can ignore.  It gives some information - that there will be side effects below, but you will never see the difference in Python. <br><br><h2>  Return </h2><br>  Noises  Also ignore.  (You will never see the <code>return</code> used to control execution.) <br><br><h2>  Point </h2><br> <code>f . g $ a + b</code>  <code>f . g $ a + b</code> translated to <code>f(g(a + b))</code> .  In fact, in a Python program, you are more likely to see something like the following: <br><pre> <code class="python hljs">x = g(a + b) y = f(x)</code> </pre>  But Haskell programmers are allergic to unnecessary variables. <br><br><h2>  Operators and tying fish </h2><br>  You can meet things like <code>=&lt;&lt;</code> , <code>&gt;&gt;=</code> , <code>&lt;=&lt;</code> and <code>&gt;=&gt;</code> .  Simply, these are some more ways to get rid of intermediate variables: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSomething</span></span> &gt;&gt;= doSomethingElse &gt;&gt;= finishItUp</code> </pre>  ==&gt; <pre> <code class="python hljs">x = doSomething() y = doSomethingElse(x) finishItUp(y)</code> </pre> <br>  Sometimes a Haskell programmer decides that it is more beautiful to do it in a different direction, especially if somewhere in the variable a value is assigned to: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">z</span></span> &lt;- finishItUp =&lt;&lt; doSomethingElse =&lt;&lt; doSomething</code> </pre>  ==&gt; <br><pre> <code class="python hljs">x = doSomething() y = doSomethingElse(x) z = finishItUp(y)</code> </pre> <br>  The most important thing is to do the reverse engineering of what is happening, looking at the definitions of <code>doSomething</code> , <code>doSomethingElse</code> and <code>finishItUp</code> : this will give a hint that it ‚Äúflows‚Äù by ‚Äúfish‚Äù.  If you do this, you can read <code>&lt;=&lt;</code> and <code>&gt;=&gt;</code> same way (in fact, they perform the composition of functions, like <code>.</code> ).  Read <code>&gt;&gt;</code> like a semicolon (i.e., no assignment): <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSomething</span></span> &gt;&gt; doSomethingElse</code> </pre>  ==&gt; <pre> <code class="python hljs">doSomething() doSomethingElse()</code> </pre> <br><br><h2>  Partial application </h2><br>  Sometimes Haskell programmers call a function, but do not pass enough arguments.  Do not be afraid, most likely, they organized the transfer of the remaining arguments elsewhere.  Ignore, or look for functions that accept anonymous functions as arguments.  Common suspects: <code>map</code> , <code>fold</code> (and its variants), <code>filter</code> , composition operator <code>.</code>  , fish operator ( <code>=&lt;&lt;</code> , etc).  This often happens with numeric operators: <code>(+3)</code> translated to <code>lambda x: x + 3</code> . <br><br><h2>  Control operators </h2><br>  Rely on instincts: these operators do exactly what you think!  (Even if you think they should not work like this).  So, if you see: <code>when (x == y) $ doSomething x</code> , read as "Soon <code>x</code> is equal to <code>y</code> , call <code>doSomething</code> with argument <code>x</code> ". <br>  Ignore the fact that you cannot actually translate this in <code>when(x == y, doSomething(x))</code> (here doSomething will be called anyway).  Actually, it will be more accurate <code>when(x == y, lambda: doSomething x)</code> , but it may be more convenient to consider <code>when</code> construction of a language. <br>  <code>if</code> and <code>case</code> are keywords.  They work the way you expect. <br><br><h2>  Right Arrow (for real!) </h2><br>  The arrows to the right have nothing to do with the arrows to the left.  Think of them as colons: they are always somewhere near the <code>case</code> keyword and the backslash (which declares lambda: <code>\x -&gt; x</code> translated into <code>lambda x: x</code> ). <br>  Pattern matching using <code>case</code> is a pretty nice feature, but it's hard to explain in this post.  Perhaps the simplest approximation is the <code>if..elif..else</code> chain with variable assignments: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">case</span></span> moose <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Foo</span></span> xyz -&gt; x + y * z <span class="hljs-type"><span class="hljs-type">Bar</span></span> z -&gt; z * <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(moose, Foo): x = moose.x <span class="hljs-comment"><span class="hljs-comment"># ! y = moose.y z = moose.z return x + y * z elif isinstance(moose, Bar): z = moose.z return z * 3 else: raise Exception("Pattern match failure!")</span></span></code> </pre> <br><br><h2>  Wrapping </h2><br>  You can distinguish the machining function by the fact that it starts with <code>with</code> .  They work like context management in Python: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withFile</span></span> <span class="hljs-string"><span class="hljs-string">"foo.txt"</span></span> <span class="hljs-type"><span class="hljs-type">ReadMode</span></span> $ \h -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ...</code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"foo.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> h: ...</code> </pre> <br>  (You can learn backslash. Yes, it is lamba. Yes, <code>withFile</code> is a function. Yes, you can define your own.) <br><br><h2>  Exceptions </h2><br>  <code>throw</code> , <code>catch</code> , <code>catches</code> , <code>throwIO</code> , <code>finally</code> , <code>handle</code> and all other similar functions work exactly as you would expect.  This, however, can look funny, because these are all functions, not keywords, with all that it implies.  For example: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">trySomething</span></span> x `catch` \(e :: <span class="hljs-type"><span class="hljs-type">IOException</span></span>) -&gt; handleError e</code> </pre>  === <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">catch</span></span> (trySomething x) (\(e :: <span class="hljs-type"><span class="hljs-type">IOException</span></span>) -&gt; handleError e)</code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: trySomething(x) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IOError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: handleError(e)</code> </pre> <br><br><h2>  Maybe </h2><br>  If you see <code>Nothing</code> , you can think of it as <code>None</code> .  So <code>isNothing x</code> checks that <code>x is None</code> .  What is the opposite of Nothing?  <code>Just</code> .  For example, <code>isJust x</code> verifies that <code>x is not None</code> . <br>  You can see a lot of noise associated with <code>Just</code> and <code>None</code> processing in the right order.  One of the most common cases: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybe</span></span> someDefault (\x -&gt; ...) mx</code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mx <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: x = someDefault <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: x = mx ...</code> </pre> <br>  Here is a specific option for the case when null is an error: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybe</span></span> (error <span class="hljs-string"><span class="hljs-string">"bad value!"</span></span>) (\x -&gt; ...) x</code> </pre>  ==&gt; <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"bad value!"</span></span>)</code> </pre> <br><br><h2>  Records </h2><br>  Work as expected, however Haskell allows you to create unnamed fields: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NoNames</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NoNames</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WithNames</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WithNames</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firstField</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">secondField</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br>  Thus, <code>NoNames</code> will be represented in Python with a tuple <code>(1, 2)</code> , and <code>WithNames</code> will be represented by the following class: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithNames</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, firstField, secondField)</span></span></span><span class="hljs-function">:</span></span> self.firstField = firstField self.secondField = secondField</code> </pre> <br>  In this simple way, <code>NoNames 2 3</code> translated to <code>(2, 3)</code> , and <code>WithNames 2 3</code> or <code>WithNames { firstField = 2, secondField = 3 }</code> to <code>WithNames(2, 3)</code> . <br>  The fields are somewhat different.  The most important thing is to remember that the Haskelers put the names of their fields in front of the variable, whereas you are most likely accustomed to putting them after.  So <code>field x</code> translates to <code>x.field</code> .  How to write <code>x.field = 2</code> ?  Well, actually, you can't do that.  Although you can copy: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> $ x { field = <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre>  ==&gt; <pre> <code class="python hljs">y = copy(x) y.field = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y</code> </pre> <br>  Or you can create it from scratch by replacing x with the name of the data structure (it starts with a capital letter).  Why do we only allow copying structures?  Because Haskell is a pure language;  but ignore it.  Just another haskell fad. <br><br><h2>  List expressions </h2><br>  Initially they came from the Miranda-Haskell family!  They only have a bit more characters. <br><pre> <code class="haskell hljs">[ x * y | x &lt;- xs, y &lt;- ys, y &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ]</code> </pre>  ==&gt; <pre> <code class="hljs objectivec">[ x * y <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xs <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ys <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ]</code> </pre> <br>  Also, it turns out that Haskelers often prefer to write list expressions in a multi-line form (perhaps, they think that this is easier to read).  It looks like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">do</span></span> x &lt;- xs y &lt;- ys guard (y &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) return (x * y)</code> </pre> <br>  So, if you see a left arrow and it does not seem like side effects are expected, this is probably a list expression. <br><br><h2>  More characters </h2><br>  Lists work just like you in Python: <code>[1, 2, 3]</code> - and in fact a list of three elements.  A colon, as in <code>x:xs</code> , means creating a list with <code>x</code> in front and <code>xs</code> at the end ( <code>cons</code> , for Lisp fans.) <code>++</code> - concatenation of lists, <code>!!</code>  - appeal by index.  Reverse slash means <code>lambda</code> .  If you see a symbol that you don‚Äôt understand, try searching it in <a href="http://haskell.org/hoogle/">Hoogle</a> (yes, it works with symbols!). <br><br><h2>  Still noises </h2><br>  The following functions may be noise, and may be ignored: <code>liftIO</code> , <code>lift</code> , <code>runX</code> (for example, <code>runState</code> ), <code>unX</code> (for example, <code>unConstructor</code> ), <code>fromJust</code> , <code>fmap</code> , <code>const</code> , <code>evaluate</code> , exclamation mark before the argument ( <code>f !x</code> ) , <code>seq</code> , lattice character (eg <code>I# x</code> ). <br><br><h2>  Putting it all together </h2><br>  Let's go back to the source code snippet: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runCommand</span></span> env cmd state = ... retrieveState = ... saveState state = ... main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> args &lt;- getArgs <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (actions, nonOptions, errors) = getOpt <span class="hljs-type"><span class="hljs-type">Permute</span></span> options args opts &lt;- foldl (&gt;&gt;=) (return startOptions) actions when (null nonOptions) $ printHelp &gt;&gt; throw <span class="hljs-type"><span class="hljs-type">NotEnoughArguments</span></span> command &lt;- fromError $ parseCommand nonOptions currentTerm &lt;- getCurrentTerm <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = <span class="hljs-type"><span class="hljs-type">Environment</span></span> { envCurrentTerm = currentTerm , envOpts = opts } saveState =&lt;&lt; runCommand env command =&lt;&lt; retrieveState</code> </pre> <br><br>  With the help of guesswork, we can get this translation: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env, cmd, state)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> args = getArgs() (actions, nonOptions, errors) = getOpt(Permute(), options, args) opts = **mumble** <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nonOptions <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: printHelp() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotEnoughArguments command = parseCommand(nonOptions) currentTerm = getCurrentTerm() env = Environment(envCurrentTerm=currentTerm, envOpts=opts) state = retrieveState() result = runCommand(env, command, state) saveState(result)</code> </pre> <br>  It‚Äôs not bad for a shallow understanding of Haskell syntax (there is one obviously not translatable piece that requires knowledge of what convolution is ( <i>actually, Python has a built-in function of reduce - approx. Translator</i> ). Not all Haskell code deals with convolutions; I repeat, not worry about it too much!) <br>  Most of the things that I called ‚Äúnoises‚Äù have, in fact, very deep reasons behind them, and if you are wondering what is behind them, I recommend learning to write in Haskell.  But if you only read, these rules, I think, are more than enough. <br>  <i>PS</i> If you really wonder what <code>foldl (&gt;&gt;=) (return startOptions) action</code> : implements the <a href="http://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B5%25D0%25BF%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_%25D0%25BE%25D0%25B1%25D1%258F%25D0%25B7%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9">chain of duty</a> pattern.  Hell yes. <br><br>  <i>PPS from translator:</i> <a href="https://habrahabr.ru/users/graninas/" class="user_link">Graninas</a> helped me with the translation of some terms </div><p>Source: <a href="https://habr.com/ru/post/132969/">https://habr.com/ru/post/132969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132960/index.html">What is your wasp on the main phone?</a></li>
<li><a href="../132961/index.html">Augmented reality is the opposite.</a></li>
<li><a href="../132962/index.html">Oracle Certified Professional Java Programmer Exam Preparation - Part 1</a></li>
<li><a href="../132963/index.html">Hosts Commander - console hosts editor for Windows and Linux</a></li>
<li><a href="../132967/index.html">Applications</a></li>
<li><a href="../132973/index.html">Testing ICQ Web Clients</a></li>
<li><a href="../132974/index.html">Kodorebus or strategy pattern on .Net 4.0</a></li>
<li><a href="../132975/index.html">Extend conky functionality: add function to display MPD track date</a></li>
<li><a href="../132976/index.html">Conversion function stdClass to SimpleXml</a></li>
<li><a href="../132977/index.html">DasKeyboard Ultimate S Review (Perhaps the first in several years)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>