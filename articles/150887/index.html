<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Setting up equipment at an early stage of booting with ACPI (using FreeBSD as an example)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, when CardBus and FireWire (IEEE 1394) were still relatively ‚Äúin use‚Äù, many laptop manufacturers used Texas Instruments PCIXX21 and PC...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Setting up equipment at an early stage of booting with ACPI (using FreeBSD as an example)</h1><div class="post__text post__text-html js-mediator-article"> A few years ago, when CardBus and FireWire (IEEE 1394) were still relatively ‚Äúin use‚Äù, many laptop manufacturers used Texas Instruments PCIXX21 and PCIXX11 controllers in their products: one small chip supported not only the interfaces mentioned, but also many popular standards for removable memory cards. <br><br>  Such a chip (namely, PCI7411) stands in my NEC Versa S950.  In my time, this little-known laptop even preferred the ThinkPad-series almost exclusively due to <em>better</em> support of FreeBSD (equipment in general and sleep mode in particular) - I specially tested it in Novosibirsk Tehnositi before buying.  For a long time, I did not use the built-in card reader, out of habit by doing it with USB whistles.  But I recently discovered that FreeBSD still does not support it.  And if five or six years ago it could have been explained by the lack of a normal driver for these controllers (I had to <a href="http://www.sashi.de/en/freebsd/sdhci/index.html">download</a> and build something myself), now I knew for sure that they were supported out of the box in FreeBSD by the <code>sdhci(4)</code> driver, what is directly stated on the manual page (and later confirmed by reading the source code). <br><br>  I slowly began to google on this topic, and the picture began to emerge gloomy.  It turned out that there are quite a few ‚Äúlucky ones‚Äù like me.  Many have posted <code>dmesg</code> and <code>pciconf -lv</code> mailing lists and forums, <code>pciconf -lv</code> trackers (for example, OpenBSD PR i386 / 5843), but no one has offered a solution.  Moreover, having actually put an end to the question, Alexander Motin, the author of the <code>sdhci(4)</code> driver, <a href="http://forums.freebsd.org/showpost.php%3Fp%3D67884%26postcount%3D4">wrote</a> on the forum in 2010 that the TI did not give documentation for the chip, which means that if the manufacturer configured the chip incorrectly, and setting it up via BIOS is not provided, do something difficult.  In turn, Theo de Raadt closed down i386 / 5843 with the words: <em>‚ÄúWe do what we can.</em>  <em>This undoubted bit undocumented bits.</em>  <em>We've strugged before to find this information, and failed.</em>  <em>If you can find some documentation, we would be thrilled. "</em> <br><a name="habracut"></a><br>  In desperation, I downloaded from the Ubuntu LiveCD.  And I was very surprised that the card reader works in Linux.  So ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Bad googled </h2><br>  It turns out that back in 2006, Alex Dubov wrote a Linux driver for TI FlashMedia readers.  I downloaded the <a href="http://svn.berlios.de/svnroot/repos/tifmxx/trunk/driver/">source code</a> and began to study it, hoping to subsequently refine <code>sdhci(4)</code> or even to sport the whole driver.  First of all, I looked at the list of supported PCI vendor / device ids in order to compare it with ‚Äúour‚Äù driver.  It turned out to be small: <br><br><pre> <code class="xml hljs">$ cat linux/pci_ids.h #define PCI_VENDOR_ID_TI 0x104c #define PCI_DEVICE_ID_TI_XX21_XX11_FM 0x8033 #define PCI_DEVICE_ID_TI_XX12_FM 0x803b #define PCI_DEVICE_ID_TI_XX20_FM 0xac8f</code> </pre> <br>  The number 0x8033 is already familiar to me from the output of <code>pciconf -lv</code> on my laptop (chip = <b>0x8033</b> 104c): <br><br><pre> <code class="xml hljs">none3@pci0:6:7:3: class=0x018000 card=0x83191033 chip=0x8033104c rev=0x00 hdr=0x00 vendor = 'Texas Instruments (TI)' device = 'PCIxx11/21 Integrated FlashMedia Controller' class = mass storage</code> </pre> <br>  This is the same card reader that does not work on FreeBSD, but works on Linux.  And here is a piece of code from <code>sdhci.c</code> (FreeBSD): <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sdhci_device</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> model; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> subvendor; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *desc; u_int quirks; } sdhci_devices[] = { { <span class="hljs-number"><span class="hljs-number">0x08221180</span></span>, <span class="hljs-number"><span class="hljs-number">0xffff</span></span>, <span class="hljs-string"><span class="hljs-string">"RICOH R5C822 SD"</span></span>, SDHCI_QUIRK_FORCE_DMA }, { <span class="hljs-number"><span class="hljs-number">0xe8221180</span></span>, <span class="hljs-number"><span class="hljs-number">0xffff</span></span>, <span class="hljs-string"><span class="hljs-string">"RICOH SD"</span></span>, SDHCI_QUIRK_FORCE_DMA }, { <span class="hljs-number"><span class="hljs-number">0xe8231180</span></span>, <span class="hljs-number"><span class="hljs-number">0xffff</span></span>, <span class="hljs-string"><span class="hljs-string">"RICOH R5CE823 SD"</span></span>, SDHCI_QUIRK_LOWER_FREQUENCY }, { <span class="hljs-number"><span class="hljs-number">0x8034104c</span></span>, <span class="hljs-number"><span class="hljs-number">0xffff</span></span>, <span class="hljs-string"><span class="hljs-string">"TI XX21/XX11 SD"</span></span>, SDHCI_QUIRK_FORCE_DMA },</code> </pre> <br>  You may notice that the device identifier TI XX21 / XX11 SD (0x803 <font color="green"><b>4</b></font> 104c) is similar to mine (0x803 <font color="red"><b>3</b></font> 104c) with one digit accuracy.  In addition, I noticed that CardBus (0x8031104c) and FireWire (0x8032104c) controllers not only have similar id's, but also PCI selectors of all devices differ only in the function number, and they all have the same device: <br><br><pre> <code class="xml hljs">none1@pci0:6:7:0: class=0x060700 card=0x83191033 chip=0x8031104c rev=0x00 hdr=0x02 vendor = 'Texas Instruments (TI)' device = 'PCIxx21/x515 Cardbus Controller' class = bridge subclass = PCI-CardBus none2@pci0:6:7:2: class=0x0c0010 card=0x83191033 chip=0x8032104c rev=0x00 hdr=0x00 vendor = 'Texas Instruments (TI)' device = 'OHCI Compliant IEEE-1394 FireWire Controller' class = serial bus subclass = FireWire</code> </pre> <br>  Recalling Sasha Motin‚Äôs words that the chip actually implements both controllers (SDHCI and FlashMedia), I began to search more purposefully, and soon came across <a href="http://forums.freebsd.org/showthread.php%3Ft%3D31831">another post</a> , and then a <a href="http://lists.freebsd.org/pipermail/freebsd-mobile/2009-August/011721.html">message</a> in the freebsd-mobile @ e- <a href="http://lists.freebsd.org/pipermail/freebsd-mobile/2009-August/011721.html">mail</a> about a similar (but a little other) problem on HP NC6220.  A working solution was not offered anywhere, but, unlike most discussions, which boiled down to stupid tips like ‚Äútry the latest driver‚Äù or trivial ‚Äúsorry, but it looks like you're in flight,‚Äù now, at least, it became clear that The configuration of the chip is somehow displayed in the PCI function dump (which means it may be possible to change it), and the main thing is that the documentation is available: <a href="http://www.webcon.ca/~imorgan/tifm21/scpu022a.pdf">PCIXXX21 / PCIXXX11 Implementation Guide</a> .  And here I was really interested. <br><br>  Looking ahead, I would say that the most surprising thing is that people, having dug up almost a datasheet for a ‚Äúnaughty‚Äù chip, stopped just a step away from solving the problem.  I never found any recipe for how to use the documentation correctly (which prompted me to write this post).  But first things first. <br><br>  PCIXXX21 / PCIXXX11 Implementation Guide - a document of 117 pages for hardware designers based on these controllers.  It does not make sense to analyze it in detail;  the most important thing that I learned from it: the controller actually implements five functions: CardBus, 1394, FlashMedia, SD Host and SmartCard;  The initial configuration is usually taken from the EEPROM.  The main configuration register, the General Control Register (section 12.4.28, p. 65), is located at 1Eh-1Fh in ROM (we are only interested in the zero byte, because it is the chip functions that are masked) and corresponds to the PCI offset 86h of the zero function devices.  Now - <br><br><h2>  For the cause </h2><br>  First, let's see what the <code>pciconf(8)</code> utility tells us about the PCI configuration space ‚Äúhead‚Äù (zero) function of the chip, that is, in the terminology of FreeBSD, the <code>pci0:6:7:0</code> selector.  For the sake of brevity, I will not give a dump of all 256 bytes, and I will confine myself only to those of interest to us, at offset 86h: <br><br><pre> <code class="xml hljs"># pciconf -rb pci0:6:7:0 0x86 d3</code> </pre> <br>  Interesting.  We look at the tablet on the 65th pdf page, we see that the three in the lower nibble (nibble) is equal to the typical value of the bits responsible for top level arbitration, SmartCard socket power control and OHCI 1394, it interests us a little.  But the top nibl just masks (turns on and off) the logic of the other controllers (I don‚Äôt include the entire table again, to save space): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/af3/b69/184/af3b6918413305b681ab285f28c1f080.png" width="673" height="334" alt="scpu022a.pdf section 12.4.28"></div><br><br>  0xD is 1101, i.e.  The DISABLE_SC, <b>DISABLE_SD</b> and DISABLE_SKTB bits are set, and the DISABLE_FM bit is cleared.  Therefore, in order to ‚Äúrevive‚Äù the SD Host controller, we, logically, need to reset DISABLE_SD (enable), and DISABLE_FM, on the contrary, set (disable).  Mask 1011 corresponds to the value 0xB, i.e.  in fact, we need to change byte <b>0xD3</b> to <b>0xB3</b> .  The problem, however, is that it must be done strongly in advance, before the chip is initialized, or rather, before it determines which controllers to include.  Once the system has booted, changing the configuration is useless: all devices are already ‚Äúin service‚Äù.  And here we come to the rescue <br><br><h2>  ACPI </h2><br>  What ACPI is and why it is needed, I will not explain: it goes beyond the topic, besides, Habr√© already had a good <a href="http://habrahabr.ru/post/128449/">post</a> on this topic.  In this case, the question is important for us: is it possible to patch DSDT before chip initialization so that it turns on the desired controller (SD Host) and turns off the unnecessary one for which we do not have a driver (FlashMedia). <br><br>  Let's see what we have tools for debugging and outputting information within the interpreter ("virtual machine") ACPI.  The <a href="http://www.acpi.info/spec.htm">ACPI specification</a> (Section 19.5.25, p. 733) mentions a special <code>Debug</code> object that the operating system must ‚Äúconvey‚Äù to the user.  In FreeBSD, the system variable <code>debug.acpi.enable_debug_objects</code> is responsible for this, which must be set to one: <br><br><pre> <code class="xml hljs"># sysctl debug.acpi.enable_debug_objects=1 debug.acpi.enable_debug_objects: 0 -&gt; 1</code> </pre> <br>  Now we can write arbitrary lines in <code>Debug</code> , and the FreeBSD kernel will output them to the console.  It remains to figure out how to get ACPI to issue information of interest to us on demand.  To begin, let us sdampim and disassemble the DSDT of the laptop, and study it: <br><br><pre> <code class="xml hljs"># acpidump -dt &gt; s950.asl</code> </pre> <br>  I decided to find a method that is called through some external influence (or internal, but periodic, such as polling the battery), while practically without affecting the work of the hardware.  Studying the DSDT code, I came across a curious piece: <br><br><pre> <code class="vala hljs">Method (_Q0C, <span class="hljs-number"><span class="hljs-number">0</span></span>, NotSerialized) { If (\_SB.PCI0.PEGA) { \_SB.PCI0.PEGP.VGA.SWIH () } Else { Store (<span class="hljs-number"><span class="hljs-number">0x01</span></span>, TLST) HKDS (<span class="hljs-number"><span class="hljs-number">0x0A</span></span>) } }</code> </pre> <br>  Nowhere else is the <code>\_SB.PCI0.PEGP.VGA.SWIH</code> method called, and its name hints that this is some kind of display switching.  On the keyboard of many laptops, one of the function keys in combination with the Fn-modifier switches the video output from the internal display to the external one.  On my "versa" this is F3.  Let's try to modify the method code as follows: <br><br><pre> <code class="diff hljs"> Method (_Q0C, 0, NotSerialized) { + Store ("Fn-F3 pressed", Debug) If (\_SB.PCI0.PEGA) {</code> </pre> <br>  Rebuild ASL: <br><br><pre> <code class="xml hljs"># iasl s950-patched.asl Intel ACPI Component Architecture ASL Optimizing Compiler version 20101013-32 Copyright (c) 2000 - 2010 Intel Corporation ASL Input: s950-patched.asl - 7749 lines, 280987 bytes, 2840 keywords AML Output: /tmp/acpidump.aml - 24863 bytes, 640 named objects, 2200 executable opcodes Compilation complete. 0 Errors, 0 Warnings, 0 Remarks, 958 Optimizations # cp /tmp/acpidump.aml /root/s950-patched.aml</code> </pre> <br>  In order for FreeBSD to use our table when booting, we <code>/boot/loader.conf</code> add <code>/boot/loader.conf</code> following lines to / boot / <code>/boot/loader.conf</code> : <br><br><pre> <code class="xml hljs">acpi_dsdt_load="YES" acpi_dsdt_name="/root/s950-patched.aml"</code> </pre> <br>  If everything is done correctly, and our calculation was justified, then when we press Fn-F3, we will see on the console the kernel messages (high brightness) that the Fn-F3 key was pressed.  Now that we are more or less able to interact with ACPI, it's time to try <br><br><h2>  To get to the register 86h </h2><br>  The physical address spaces of various devices (RAM, I / O ports, expansion cards, CMOS, IPMI, etc.) are mapped into the ACPI namespace as so-called.  operational regions (OperationRegion), inside of which bit fields (Field) are usually allocated, consisting of one or several named ‚Äúvirtual registers‚Äù, or field units (paragraph 19.5.96, p. 782 specifications).  An OperationRegion for our controller might look like this: <br><br><pre> <code class="vala hljs">OperationRegion (PCIC, PCI_Config, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>) Field (PCIC, AnyAcc, NoLock, Preserve) { Offset (<span class="hljs-number"><span class="hljs-number">0x86</span></span>), <span class="hljs-comment"><span class="hljs-comment">// General Control Register   86h TLA, 2, // Top level arbitration SCSP, 1, // SmartCard socket power OHCI, 1, // Disable OHCI 1394 controller function SKTB, 1, // Disable CardBus socket B FM, 1, // Disable FlashMedia function SD, 1, // Disable SD host controller function SC, 1, // Disable SmartCard function }</span></span></code> </pre> <br>  Or even easier, if not all 256 bytes are declared in the <code>OperationRegion</code> , but only the one that interests us, and not to allocate individual bits in the configuration register: <br><br><pre> <code class="vala hljs">OperationRegion (PCIC, PCI_Config, <span class="hljs-number"><span class="hljs-number">0x86</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>) Field (PCIC, AnyAcc, NoLock, Preserve) { GCR0, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-comment"><span class="hljs-comment">// General Control Register (Byte 0) }</span></span></code> </pre> <br>  It is easy to see that such a definition in itself is useless: it is not tied to any device, being in essence just a structure from one byte at a known offset.  Devices in DSDT are specified via the <code>Device</code> keyword (paragraph 19.5.30, p. 735);  the aggregate of all devices is a sort of tree.  So, all PCI devices are most often inside the <code>\_SB.PCI0</code> device space, which corresponds to the root PCI bus (usually there is one such bus, but theoretically they can be up to 256 in one PCI domain). <br><br>  To identify a device on the bus, you must set its address in the form (device &lt;&lt; 16) |  function.  In our case (remember the output of <code>pciconf -lv</code> ?) Function = 0, device = 7, bus = 6. That is, the device, apparently, should look something like this: <br><br><pre> <code class="vala hljs">Device (XX11) { Name (_ADR, <span class="hljs-number"><span class="hljs-number">0x00070000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// pci0:6:7:0 }</span></span></code> </pre> <br>  All right, but where did the sixth tire come from?  And where is she in DSDT?  Let's look at the kernel boot log ( <code>dmesg</code> ): <br><br><pre> <code class="dos hljs">$ dmesg | grep pci6 pci6: &lt;ACPI PCI bus&gt; on pcib4 pci6: &lt;bridge, PCI-CardBus&gt; <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> device <span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> (no driver attached) pci6: &lt;serial bus, FireWire&gt; <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> device <span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> (no driver attached) pci6: &lt;mass storage&gt; <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> device <span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span> (no driver attached) pci6: &lt;network&gt; <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> device <span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> (no driver attached) $ dmesg | grep pcib4 pcib4: &lt;ACPI PCI-PCI bridge&gt; <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> device <span class="hljs-number"><span class="hljs-number">30</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> on pci0 pci6: &lt;ACPI PCI bus&gt; on pcib4</code> </pre> <br>  It turns out, <code>pci6</code> is an additional, ‚Äúvirtual‚Äù bus on a PCI-PCI bridge.  She got number 6 (as well as 4 for the bridge) because FreeBSD distributed the devices that way.  Inside the DSDT, of course, there are no six tires and four bridges.  Bridge - <code>Device (PCIB)</code> - there is exactly one, as expected.  Fully our description should look like this (I give a short version, without decomposing the register into separate bits): <br><br><pre> <code class="vala hljs">Scope (\_SB.PCI0.PCIB) { Device (XX11) { Name (_ADR, <span class="hljs-number"><span class="hljs-number">0x00070000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// pci0:6:7:0 OperationRegion (PCIC, PCI_Config, 0x86, 0x01) Field (PCIC, AnyAcc, NoLock, Preserve) { GCR0, 8, } } }</span></span></code> </pre> <br>  Now we can replace our debugging code in the <code>_Q0C</code> method <code>_Q0C</code> something more meaningful: <br><br><pre> <code class="diff hljs"> Method (_Q0C, 0, NotSerialized) { + Store (Concatenate("GCR0 = 0x", \_SB.PCI0.PCIB.XX11.GCR0), Debug) If (\_SB.PCI0.PEGA) {</code> </pre> <br>  Reassemble ASL, reboot, click Fn-F3.  If we did everything right, then we should see the same value that we previously read through <code>pciconf(8)</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/a4c/307/c22/a4c307c22ce4dd6a2c279a48866abbe0.png" width="720" height="400" alt="vanilla pciconf -lv"></div><br><br>  <em>(The implementation of the function to write the register value directly to the video memory is left to the reader as an easy exercise.)</em> <br><br>  It remains for us to answer the most important question: will it be possible to change the register value and make the chip configure itself as we need? <br><br>  The ACPI standard defines a special method for initializing devices, <code>_INI</code> (Section 6.5.1, p. 349).  Let's add the following code to our device: <br><br><pre> <code class="vala hljs">Method (_INI) { Store (<span class="hljs-number"><span class="hljs-number">0xB3</span></span>, GCR0) <span class="hljs-comment"><span class="hljs-comment">/*     : Store (0x01, FM) Store (0x00, SD) */</span></span> }</code> </pre> <br>  We compile ASL, copy the resulting AML file to <code>/root/s950-patched.aml</code> , reboot again.  We look at <br><br><h2>  Result </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/2f1/986/6ce/2f19866ceba77e60a4055e01014913d4.png" width="720" height="400" alt="pciconf -lv after patch"></div><br><br>  First of all, note that the controller 0x803 <font color="red"><b>3</b></font> 104c (FlashMedia) disappeared from the <code>pciconf -lv</code> , but 0x803 <font color="green"><b>4</b></font> 104c (SD Host) appeared.  Load the necessary kernel modules, insert the card and try to mount it: <br><br><pre> <code class="xml hljs"># kldload sdhci mmc mmcsd # ls /dev/mmcsd0* /dev/mmcsd0 /dev/mmcsd0s1 # mount -t msdosfs /dev/mmcsd0s1 /mnt/tmp # ls /mnt/tmp/DCIM/100CANON IMG_0403.JPG IMG_0424.JPG IMG_0450.JPG IMG_0494.JPG IMG_0515.JPG IMG_0406.JPG IMG_0425.JPG IMG_0451.JPG IMG_0498.JPG IMG_0517.JPG IMG_0407.JPG IMG_0427.JPG IMG_0452.JPG IMG_0499.JPG IMG_0518.JPG IMG_0409.JPG IMG_0429.JPG IMG_0453.JPG IMG_0500.JPG IMG_0520.JPG IMG_0410.JPG IMG_0430.JPG IMG_0467.JPG IMG_0501.JPG IMG_0522.JPG IMG_0412.JPG IMG_0439.JPG IMG_0473.JPG IMG_0506.JPG IMG_0525.JPG IMG_0413.JPG IMG_0440.JPG IMG_0474.JPG IMG_0507.JPG IMG_0526.JPG IMG_0414.JPG IMG_0445.JPG IMG_0475.JPG IMG_0508.JPG IMG_0534.JPG IMG_0415.JPG IMG_0447.JPG IMG_0478.JPG IMG_0510.JPG IMG_0535.JPG IMG_0421.JPG IMG_0448.JPG IMG_0492.JPG IMG_0512.JPG IMG_0537.JPG IMG_0423.JPG IMG_0449.JPG IMG_0493.JPG IMG_0514.JPG IMG_0538.JPG # tar cf /dev/null /mnt/tmp/DCIM/100CANON ; echo $? tar: Removing leading '/' from member names 0</code> </pre> <br>  It seems everything works, well, nice.  You can remove the debugging code from DSDT and <s>enjoy life to</s> use the card reader. </div><p>Source: <a href="https://habr.com/ru/post/150887/">https://habr.com/ru/post/150887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150881/index.html">Withdraw money from PayPal to the card: Instructions for Dummies</a></li>
<li><a href="../150882/index.html">Levels for Sokoban</a></li>
<li><a href="../150883/index.html">Who owns the downloaded music after your death?</a></li>
<li><a href="../150884/index.html">GoDaddy's radical decision to fight conservatives</a></li>
<li><a href="../150885/index.html">Automatic connection of css and js files in Yii</a></li>
<li><a href="../150888/index.html">ASN.1 in simple terms (part 3, final)</a></li>
<li><a href="../150890/index.html">Wicked Good XPath: Fast Xpath on Javascript</a></li>
<li><a href="../150892/index.html">Delphi Ecosystem</a></li>
<li><a href="../150894/index.html">Anatomy of public procurement legislation</a></li>
<li><a href="../150895/index.html">DARPA Shows Silicone "Chameleon"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>