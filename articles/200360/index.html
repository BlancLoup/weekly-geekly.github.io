<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SQLite: create a "hot" backup data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SQLite has a mechanism for creating a backup database ‚Äúon the fly‚Äù. Many developers do not know about this for some reason. This mechanism is primitiv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SQLite: create a "hot" backup data</h1><div class="post__text post__text-html js-mediator-article">  SQLite has a mechanism for creating a backup database ‚Äúon the fly‚Äù.  Many developers do not know about this for some reason.  This mechanism is primitive, but it is suitable for many situations.  In this article, we would like to discuss this most built-in backup capability, and also propose an architecture for our own backup mechanism.  Well, or at least give a direction in which to move, if you need to arrange a complex replication of data. <br><br><a name="habracut"></a><br><br>  Generally speaking, you need to start with the simplest option.  The SQLite database is a single file (by default, the <i>DELETE</i> log mode).  The application can regularly complete all transactions, close all connections to the database and simply copy the database file to the backup.  If the database file is less than 100 MB in size, this action on a modern computer will take a couple of seconds.  And it can be accelerated - read the file into memory (take a "snapshot"), allow work with the database and, in a separate thread, slowly, drop the contents into a file on disk.  Many have enough of this, surprisingly enough. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Online Backup API </h5><br>  However, the base in memory is not copied in this way.  So, <a href="http://sqlite.org/c3ref/backup_finish.html">Online Backup API</a> .  This is the SQLite API for creating a backup on the fly.  Everything is arranged quite simply.  The <i>sqlite3_backup_init</i> function starts the backup process: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">sqlite3_backup *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqlite3_backup_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( sqlite3 *pDest, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*     */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *zDestName, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*    */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sqlite3 *pSource, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*     */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *zSourceName </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*    */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>;</code> </pre> <br><br>  In the parameters, the connection objects are transferred to the source database and the destination database (as the value of the alias, the <i>‚Äúmain‚Äù</i> for the main database, the <i>‚Äútemp‚Äù</i> for the temporary one, or used for connection via the <i>ATTACH</i> operator) are transmitted.  The object of the backup management is returned (if 0 is returned, then the error must be viewed in the connection to the destination database), which must be passed to the remaining API functions as the first parameter.  Now you can make a reservation that is made page by page.  To copy a portion of the <i>nPage</i> pages (or all, if <i>nPage</i> = -1), call the function <i>sqlite3_backup_step</i> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqlite3_backup_step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sqlite3_backup *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nPage)</span></span></span></span>;</code> </pre><br>  If this function <i>returns SQLITE_DONE</i> , then the backup is complete, all pages are copied.  If <i>SQLITE_OK, SQLITE_BUSY, SQLITE_LOCKED</i> codes are received, then the copying is not completed, but it can be continued normally - the <i>sqlite3_backup_step ()</i> function must also be called <i>.</i>  Other return codes indicate an error has occurred.  If <i>SQLITE_DONE</i> code is <i>received</i> , then <i>sqlite3_backup_finish ()</i> should be called <i>:</i> <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqlite3_backup_finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sqlite3_backup *p)</span></span></span></span>;</code> </pre><br>  and sleep peacefully, enjoying a successful backup.  The following functions are used to obtain information about the current backup status: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqlite3_backup_remaining</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sqlite3_backup *p)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    int sqlite3_backup_pagecount(sqlite3_backup *p); //   </span></span></code> </pre><br>  The whole <i>Src</i> base backup algorithm in <i>Dst</i> blocks on the <i>SOME_PAGE_COUNT</i> pages on the pseudocode a la pascal looks like this: <br><br><pre> <code class="delphi hljs"> Backup = sqlite3_backup_init(Dst, <span class="hljs-string"><span class="hljs-string">'main'</span></span>, Src, <span class="hljs-string"><span class="hljs-string">'main'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Backup = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Abort; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sqlite3_backup_step(Backup, SOME_PAGE_COUNT) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> SQLITE_DONE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; SQLITE_OK, SQLITE_BUSY, SQLITE_LOCKED: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Abort; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>, sqlite3_backup_remaining(Backup) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> sqlite3_backup_pagecount(Backup), <span class="hljs-string"><span class="hljs-string">'%'</span></span>); Sleep(SOME_TIME); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> false; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> sqlite3_backup_finish(Backup) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  When using this API, SQLite does not lock the source database in any way.  You can not only read, but also update the data.  What happens if we copy portions ( <i>nPage</i> &gt; 0, i.e., not all pages at once in one call to <i>sqlite3_backup_step ())</i> and the base has changed?  Restart copy!  Transparent for us, SQLite will start copying pages from the very beginning of the database.  In other words, if the source database is changing rapidly, there is a chance not to wait until the backup is complete.  There is some good news.  If the source database is changed through the same connection to it as the reservation (even if from another thread), SQLite will transparently duplicate the changes to the destination base and the backup will not restart. <br><br>  Advantages of SQLite Online Backup API - the source database is not blocked for reading and, if it is updated through a single connection, then writing to the database does not interfere.  What to do if the database is very large and is often updated from different applications?  It was the turn to think about creating a data replication system.  Actually, nothing new will be invented here - with the help of triggers, we track what records have changed and keep a history of changes.  We use the fact that any table contains a column <i>ROWID</i> , which contains a unique record number.  Regularly transfer changes to another database.  Just show how it is done in detail. <br><br><h5>  Simple data replication scheme </h5><br>  So, in the source database you need to create a table of records of affected records: <br><br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> system_replicate_table(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> system_replicate_record(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) );</code> </pre><br>  To enable replication on the <i>Foo</i> table, add it to the <i>system_replicate_table</i> : <br><br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> system_replicate_table(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Foo'</span></span>);</code> </pre><br>  and create replication triggers for it: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTrigger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Operation, TableName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result := Format(<span class="hljs-string"><span class="hljs-string">'CREATE TRIGGER IF NOT EXISTS system_trigger_%s_replicate_%s AFTER %s ON %s FOR EACH ROW BEGIN '</span></span>, [ TableName, Operation, Operation, TableName ]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operation = <span class="hljs-string"><span class="hljs-string">'INSERT'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Operation = <span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result := result + Format(<span class="hljs-string"><span class="hljs-string">'INSERT OR IGNORE INTO system_replicate_record(name, id) VALUES("%s", NEW.ROWID); '</span></span>, [ TableName ]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operation = <span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Operation = <span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result := result + Format(<span class="hljs-string"><span class="hljs-string">'INSERT OR IGNORE INTO system_replicate_record(name, id) VALUES("%s", OLD.ROWID); '</span></span>, [ TableName ]); result := result + <span class="hljs-string"><span class="hljs-string">' END; '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Execute( CreateTrigger(<span class="hljs-string"><span class="hljs-string">'INSERT'</span></span>, <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>) ); Execute( CreateTrigger(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>) ); Execute( CreateTrigger(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>, <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>) );</code> </pre><br>  Triggers are simple.  They add the <i>ROWID of the</i> affected table entries to <i>system_replicate_record</i> (read <i>NEW</i> and <i>OLD</i> in SQLite triggers by yourself), if they are not already there.  So, we include replication on tables, interesting to us, and we start to work with initial base.  Data changes are tracked by triggers.  At some point (by the time interval or by the number of records in <i>system_replicate_record</i> ) we perform data replication, that is, we transfer the changes.  How to replicate changed records from table <i>Foo</i> to destination database?  This is the most difficult part of replication.  We will use the <i>sqlite_master</i> system table, which contains the SQL of all database objects.  This SQL is an object creation statement (i.e. for the table Foo there will be ‚ÄúCREATE TABLE Foo (...)‚Äù). <br><br><h5>  The algorithm for copying the table <i>Foo</i> , if it is not already in the database <i>Dst</i> . </h5><br>  <b>1)</b> Get SQL tables: <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sqlite_master <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tbl_name = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-string"><span class="hljs-string">'table'</span></span>;</code> </pre><br>  and execute it in the destination database ‚Äúas is‚Äù (we simply transfer to the execute method the connections to the destination database). <br>  <b>2)</b> Select all records and transfer data (how exactly we transfer a little later): <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Foo</code> </pre><br>  <b>3)</b> If indices and triggers are also required to be transferred, then we also execute SQL in the destination database, which we obtain as follows (we exclude system indices and triggers): <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sqlite_master <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tbl_name = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = "index" <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = "trigger") <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'system_%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'sqlite_%'</span></span></code> </pre><br><h5>  The replication algorithm of the table <i>Foo</i> from the <i>Src</i> base to the <i>Dst</i> base. </h5><br>  <b>1)</b> If there is no <i>Foo</i> table in <i>Dst</i> , then copy it there from <i>Src</i> (see above) and go to <b>5)</b> <br>  <b>2)</b> Otherwise, select the <i>ROWID of the</i> affected records: <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sqlite_replicate_record <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>;</code> </pre><br>  and combine them separated by a comma into a long string R, i.e.  should get in R something like <i>"123,256,334,4700, ..."</i> . <br>  <i>(Do not even think about performing this operation by adding lines! Select the buffer and expand it as necessary. It is also a good idea to remember that the <i>ROWID</i> is an 8 byte integer with a sign)</i> . <br>  <b>3)</b> Delete these records from the <i>Foo</i> table in the <i>Dst</i> database: <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [Foo] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;   R&gt;);</code> </pre><br>  <b>4)</b> select data from <i>Foo</i> in the <i>Src</i> database and copy (a little later about the actual copying of data) to the <i>Dst</i> database: <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [Foo] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> system_replicate_record <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>);</code> </pre><br>  <b>5)</b> Clean the replication table in the <i>Src</i> database: <br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sqlite_replicate_record <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>;</code> </pre><br>  It remains for us to understand - how to copy the data.  It requires a little more programmer shamanism.  Records are selected by the following request: <br><br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rowid</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [Foo] [ <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ... ]</code> </pre><br>  This is the only way to ensure that the <i>ROWID</i> is retrieved (and will have the name "ROWID").  For each extracted record we form the SQL insert statement (in UTF-8 encoding): <br><pre> <code class="hljs markdown"> INSERT INTO [<span class="hljs-string"><span class="hljs-string">Foo</span></span>](<span class="hljs-link"><span class="hljs-link">&lt;&gt;</span></span>) VALUES(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name"></span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>)</code> </pre><br>  You should bypass all the columns in the selected record and add the column name to the " <i>&lt;names&gt;</i> " part, and the value to the " <i>&lt;values</i> &gt;" part, separated by commas.  The column name should be framed '[' and ']'.  The value should be represented as a SQL literal.  As you know, SQLite has the following types of values: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">SQLITE_INTEGER</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">SQLITE_FLOAT</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">SQLITE_TEXT</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">SQLITE_BLOB</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">SQLITE_NULL</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  We need to learn how to get each in the form of an SQL literal.  The literal <i>SQLITE_NULL</i> is <b>‚Äúnull‚Äù</b> .  The literal <i>SQLITE_INTEGER</i> is a string representation of an integer (64 bits), 1234567890: <b>"1234567890"</b> .  The literal SQLITE_FLOAT is a string representation of a real number with a dot as the separator of the fractional and integer parts, 123.456789: <b>"123.456789"</b> .  To turn a string ( <i>SQLITE_TEXT</i> ) into a literal, double all single quotes in it and frame the resulting single quotes, "Hello, Mc'Duck": <b>"'Hello, Mc''Duck'"</b> .  Stay <i>BLOB</i> .  The <i>SQLITE_BLOB</i> (binary data) literals in SQLite have the form <b>"x'A0B1C2 ... '"</b> , where "A0" is the hex code of the first byte, "B1" is the hex code of the second byte, etc. <br><br>  That's all.  We described the simplest working version of data replication, in which the record is copied in its entirety.  There is a field for optimization, of course.  It will be useful to wrap all changes in the <i>Dst</i> database into a transaction.  When forming the insert statement, the part with column names can be created once and reused. <br><br>  The architecture does not support schema replication.  If you change the source table by adding fields to it, this will break its replication.  You must either delete the table in the destination database (so that it is completely copied again), or complicate replication by adding schema synchronization.  The same considerations apply to newly created indices and triggers. <br><br>  Ps.  Use a <a href="http://sqlitedog.com/ru/idx.html">modern manager</a> to administer the SQLite database. </div><p>Source: <a href="https://habr.com/ru/post/200360/">https://habr.com/ru/post/200360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200352/index.html">RESTful web API</a></li>
<li><a href="../200354/index.html">Custom Annotation Preprocessor - the creation of Android-based applications and configuration in IntelliJ IDEA</a></li>
<li><a href="../200356/index.html">Development of client-server infrastructure in javascript (part 2 - server and location)</a></li>
<li><a href="../200358/index.html">Mobile Internet in Russia and the world: platforms, consumption, trends</a></li>
<li><a href="../20036/index.html">Three wise men</a></li>
<li><a href="../200362/index.html">Moving to Fusion Drive (Mac OS X Mavericks)</a></li>
<li><a href="../200364/index.html">Experience from Yandex. How to make your report for autotests</a></li>
<li><a href="../200366/index.html">Selecting and editing custom primitives in MultiCAD.NET</a></li>
<li><a href="../20037/index.html">How to guess the number fastest?</a></li>
<li><a href="../200376/index.html">Publish Ruby, Python, Node.js, Perl and Java web applications to Azure Cloud Services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>