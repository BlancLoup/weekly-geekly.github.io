<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mini AI Cup # 3: Writing a Top Bot</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the beginning of autumn, the contest for writing bots Mini AI Cup # 3 (aka Mad Cars) was completed, in which participants had to fight on typewrite...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mini AI Cup # 3: Writing a Top Bot</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/uk/nd/_2/uknd_2qxbi4b0qt85hqcoxgvt7i.png"></p><br><p>  At the beginning of autumn, the contest for writing bots <a href="https://aicups.ru/">Mini AI Cup # 3</a> (aka Mad Cars) was completed, in which participants had to fight on typewriters.  The participants argued a lot about what would work and what would not be, ideas from simple ifs to learning neural networks were expressed and tested, but the top places were taken by the guys with the so-called ‚Äúsimulation‚Äù.  Let's try to figure out what it is, compare the solutions for the 1st, 3rd and 4th places and discuss other possible solutions. </p><a name="habracut"></a><br><h1 id="diskleymer">  Disclaimer </h1><br><p>  The article was written in collaboration with <a href="https://habr.com/users/DragoonXen/">Alexey Dichkovsky (Commandos)</a> and <a href="https://habr.com/users/kswaldemar">Vladimir Kiselev (Valdemar)</a> . </p><br><p>  For those who just want to read about the decisions of the winners, I advise you to immediately start from the point "Simulation". </p><br><h1 id="postanovka-zadachi">  Formulation of the problem </h1><br><p>  This time, the mechanics of the world looked a lot like the mobile game Drive Ahead: players were given a car with a button on it;  the task is to push the button of the enemy faster than he does.  If nobody wins over 600 game ticks, the card starts to sink into a pile of garbage, which can also press a button.  In other words, you need to protect your button from enemies, the outside world and heaps of garbage (vitally, yes).  Each player was given 5 lives, the game went from 5 to 9 rounds, until someone ended their lives.  Each round was held on a random map and typewriters, the same for both participants.  In total there were 6 different cards and 3 types of cars - a total of 18 different combinations. </p><br><p> Each round is divided into tiki.  A tick is one move, like in chess.  The only difference is that both players walk at the same time.  There are competitions where everyone moves in turns, or you can do the action only once in several moves and <a href="http://russianaicup.ru/">select units with a frame</a> . <br>  Each tick bot comes a state of the world and is given the opportunity to perform 3 actions: <code></code> , <code></code> , <code></code> .  These actions force the car to go in one of the directions, and if it does not touch the wheels of the earth, it gives a slight rotation to the whole body (a bit of arcade physics).  After both opponents have chosen an action, a simulation of the game world starts, a new state is considered and sent to the players.  In case someone pushed the button, the round ends and the next one starts.  It's simple, but there are nuances. </p><br><p>  More complete rules can be found <a href="">here</a> .  A game finals see <a href="https://aicups.ru/round/6/">here</a> . </p><br><h1 id="obschee-opisanie-resheniya">  General description of the solution </h1><br><p>  Most of the bots writing competitions are very similar: there are a finite number of ticks (there is approximately 1500 maximum for one round), there are a finite number of possible actions, you need to choose a sequence of actions to be better than your opponents.  A little later, let us return to what it means to be better, but for now let's deal with how to deal with the main problem - a huge number of options: at the start we have one initial state, then each machine can move in three different ways that gives us 9 different combinations for two machines, by the 1500 move it will be already 9 ^ 1500 different combinations ... Which is a little more than we would like if we plan to have time to sort through them during the Universe existence. </p><br><p>  This is where we come to what <strong>simulation is</strong> .  This is not some kind of algorithm, but simply the re-creation of the rules of the game with sufficient or complete accuracy so that you can sort out the solutions.  Of course, we will go through not all the solutions, but only a part of them.  The search algorithm will be used for this - in the tree of the game states we are looking for the best for us.  There are a lot of algorithms (from minimax to MCTS), each has its own nuances.  It is best to familiarize yourself with what decisions were written by participants in past competitions in AI.  This will give a basic understanding of the conditions under which the algorithms work, and under which not.  There are many references for this in a <a href="https://github.com/core2duo/RHC-AI">special repository</a> . </p><br><p>  When choosing an algorithm should be considered: </p><br><ul><li>  time limit for 1 tick (here I miscalculated strongly this year, but I was able to stay in 3rd place); </li><li>  number of players.  For example, if there are three players, it will be difficult to use a minimax; </li><li>  simulation accuracy, because  this may allow reuse of old calculations; </li><li>  "branching" of the state tree (is it possible to calculate all possible states at least 10 moves ahead); </li><li>  common sense - do not start writing MCTS if the competition lasts 4 hours. </li></ul><br><p>  In this competition, 1 tick was given about 10-13ms (2 minutes for the whole game).  During this time, the bot had to read the data, make a decision and send a command to move.  This was enough to simulate about 500-1000 moves.  Enumerate all the states will not work.  The simplest search algorithm can look like a comparison of three options for movement: "50 ticks go left", "50 ticks go right", "50 ticks press stop".  And no matter how simple it may sound, it is not very far from the decision of the winner. </p><br><p>  Since  we count only 50 moves ahead, which in most cases does not count to the end of the game, then we need <strong>an evaluation function</strong> that tells how good and bad the state of the world is for us.  Most often it is built on heuristics and understanding what is important for victory.  For example, in the 2014 Russian AI Cup competition there were races, but it was possible to win and be the last to arrive if you earn more bonus points.  Hence, the evaluation function should stimulate the collection of points at the same time as fast movement on the highway.  The estimate can be calculated only for the last simulation state (after 50 ticks) or as the sum of the estimates of intermediate states.  Often, the estimate "fades out" in time, so that states that occur earlier are more affected.  Since  we can not predict the enemy for sure, and future options are less likely to happen, we will not rely heavily on them.  Also, this technique causes the bot to quickly perform its tasks, rather than postpone everything until later.  But it is worth noting that the bot will be less risky for the sake of subsequent benefits. </p><br><p>  Since we are going to predict the state of the world in response to our actions, then we need to somehow simulate the behavior of enemies.  There is nothing difficult and there are a couple of common options: </p><br><ul><li>  <strong>Stub or heuristics</strong> <br>  It is written simple logic of behavior, where the enemy simply does nothing, or chooses actions based on simple heuristics (for example, you can use your first versions of the strategy or simply repeat the opponent‚Äôs previous move). </li><li>  <strong>Use the same algorithm as for yourself.</strong> <br>  First we try to find the best actions for the enemy (against our best set of actions from the last move, or against the stub), and then we are looking for the best action for ourselves, using the behavior that we found for the enemy.  Here the bot will try to resist cunning enemies.  Such logic does not work well at the start of the competition, since  Many bots are still very weak, and your decision will be too cautious with them. </li><li>  <strong>Other</strong> <br>  The same minimax enumerates all the moves of the players at the same time, and he simply does not need heuristics. </li></ul><br><p>  If you implement all the above steps, you will most likely get a very good bot, especially if you manage to find a good evaluation function.  But, looking through the fights, it is possible to notice that in certain situations he behaves strangely.  Correcting the evaluation function for these situations can be difficult, or there is a high risk of breaking another logic.  Here crutches and ifs come to the rescue.  Yes, the last days of the competition often boil down to writing crutches and ifs to correct the flaws in some specific conditions.  Personally, I don‚Äôt like this part very much, but I‚Äôve noticed many times that crutches in the finals can affect the location of places in the top ten, which means one unwritten if can cost you a prize (my heart hurts when I write these words, I I also love beautiful algorithms and solutions). </p><br><p>  <strong>Q: Is it possible to do without simulation at all?</strong> <br>  <em>A: Yes, you can use solutions on heuristics (decision trees, lots of ifs, etc.).</em>  <em>There is a good <a href="https://habr.com/post/173187/">article</a> with AI architectures on heuristics.</em> </p><br><p>  <strong>Q: How much better is the use of simulation approaches on heuristics?</strong> <br>  <em>A: It all depends on the task.</em>  <em>For example, here some combinations of cards and machines could be hard-coded with ifs and always win (or a draw).</em>  <em>However, often the simulation finds solutions that are difficult to think of yourself, or it is difficult to implement heuristics.</em>  <em>In this competition, when you turn over another machine, the solutions on the simulations put their wheels on the enemy's wheel, which turned off the flag "in the air", which means the enemy could not use body rotation and turn back on the wheels.</em>  <em>But the decision did not reflect on the meaning of this; it simply found options where the enemy would quickly fall onto the roof and press its button.</em> </p><br><p><img src="https://habrastorage.org/webt/in/i4/wk/ini4wk8qqxl7dfzdzlcegwpmyyq.gif"></p><br><p>  <strong>Q: Neural networks and RL?</strong> <br>  <em>A: No matter how popular it is, in solutions of bots such solutions rarely show themselves well.</em>  <em>Although neural networks do not need to be simulated, because</em>  <em>they can simply produce an action based on the input parameters of the current state, they still need to somehow learn, and for this they often have to write a simulator to drive games by the thousands locally.</em>  <em>Personally, I believe that they have the potential.</em>  <em>Perhaps they can solve part of the problem, or use it in conditions of very limited response time.</em> </p><br><p>  <strong>Note</strong> <br>  <em>Regarding the finite number of possible actions, it is worth clarifying that sometimes it is allowed to "smoothly" adjust a parameter.</em>  <em>For example, not just go ahead, but by some percentage of power.</em>  <em>In this case, the ‚Äúlimbs‚Äù of the number of outputs is easy to achieve simply by using several values, for example, 0%, 25%, 50%, 75% and 100%.</em>  <em>Most often just two are enough: "fully on" and "completely off."</em> </p><br><h1 id="simulyaciya">  Simulation </h1><br><p>  In this competition, the ready <a href="https://chipmunk-physics.net/">chipmunk physics</a> engine was used.  The expectations of the organizers were that he is old, time-tested and has many wrappers so that everyone can incorporate it into their decision ... </p><br><p>  In the harsh reality, the engine produced different values ‚Äã‚Äãeach time, which made it difficult for it to restart to miscalculate the move options.  The problem was solved ‚Äúin the forehead‚Äù - my memory allocator was written in C and the piece of memory with the state of the world was copied entirely.  Such an allocator put an end to the possibility of writing solutions in languages ‚Äã‚Äãother than C ++ (in fact, this was possible, but it would be very laborious and the allocator would still have to write in C).  In addition, the accuracy of prediction was influenced by the order of adding elements to the game world, which required a very accurate copy of the code used by the organizers for rendering games.  But he was already in Python.  The final nail in the coffin of other programming languages ‚Äã‚Äãwas that the engine is old and contains many optimizations that cannot be exactly recreated during the competition to get your trimmed version of the physics simulation. </p><br><p>  As a result, the engine, which was supposed to give all participants equal conditions for the simulation of moves, became the most difficult obstacle for this.  Man overcame it. The first 7 leaderboard places were taken exclusively by the guys who made an accurate simulation, which may serve as some proof of its importance in such competitions. </p><br><p>  With the exception of a couple of participants who were able to climb inside the chipmunk and optimize the copying of its state, the others had a simulation of approximately equal performance (which made the competition a bit more interesting, because you know that the struggle is for the solution algorithm, and not "who will count the moves more"). </p><br><h1 id="algoritm-poiska-i-predskazanie-protivnika">  Algorithm of search and prediction of the enemy </h1><br><p>  From this point begins a separate description of the solutions.  The description of the algorithms will be conducted on behalf of its author. </p><br><h3 id="vladimir-kiselev-valdemar-4-mesto">  Vladimir Kiselev (Valdemar) 4 place </h3><br><p>  A random search (Monte Carlo) was used to search the solution space.  The algorithm is as follows: </p><br><ol><li>  We initialize the genome - a sequence of actions (left, right, stop) for 60 ticks with random data. </li><li>  We take the best genome found </li><li>  Randomly change one of the actions </li><li>  Using the evaluation function, we get a number - an indicator of how good the new genome is. </li><li>  If you have a better solution, then update the best solution. </li><li>  Repeat again with paragraph 2 </li></ol><br><p>  My simulator gave out ~ 100k simulations of the world in 1 second, considering that there is an average of ~ 12ms per tick, we get 1200 actions per tick.  That is, for 1 tick we manage to complete a full cycle about 20 times. </p><br><p>  To find the optimal solution of such a number of iterations is clearly not enough.  Therefore, the idea of ‚Äã‚Äã‚Äústretching‚Äù actions was implemented: instead of the genome of 60 moves, we will operate on a chain of 12 ‚Äústretched‚Äù moves - we believe that each action lasts 5 ticks in a row. <br>  Plus: Improving the quality of mutations by reducing the length of the genome, a simulation can also be run every 5 ticks and check 100 genomes instead of 20 (to avoid falls over the time limit, eventually stopped at 70). <br>  Minus: Stretching actions can lead to non-optimal solutions (for example, swinging on the bumper, instead of a stable rack) </p><br><p>  It should be noted techniques that have significantly improved the quality of the algorithm: </p><br><ul><li>  We carry out random initialization only on the first tick, all the rest of the time we reuse the best found solution with a shift of 1 turn (the action on the 2nd tick is shifted to the 1st, etc., the random action is added to the end).  This greatly improves the quality of the search, because otherwise the algorithm ‚Äúforgets‚Äù what it was going to do on the last tick and meaninglessly twitches in different directions. </li><li>  At the beginning of the turn, we make more intensive changes (changing the genome 2 or 3 times instead of one) in the hope of getting out of a local maximum (similarity of temperature in the method of simulating annealing). <br>  The intensity was selected manually: the first 30 iterations make 3 mutations, the next 10 by 2, then by 1. </li><li>  It is very important to predict the actions of the enemy.  To the detriment of time to search for your own solution, we launch a random search by the enemy, for 20 iterations, then 50 for ourselves, using the information on the opponent‚Äôs optimal moves. <br>  The best decision of the opponent is also reused on the next move with an offset.  At the same time, during the search for the solution of the enemy, the genome from the last move is used as my intended actions. </li></ul><br><p>  During the competition, I actively used tools for local development, which allowed us to quickly find bugs and focus on the weak points of the strategy: </p><br><ul><li>  local arena - the launch of many matches against the previous version; </li><li>  visualizer for debugging behavior; </li><li>  script for collecting statistics on matches from the site - allows you to understand on which maps and machines most often occur defeats. </li></ul><br><blockquote>  <strong>mortido:</strong> <br>  It is risky to count every 5 ticks, especially if the enemy moves away from the options you predicted.  On the other hand, in this game world for 5 ticks, not much happened. <br>  Also, in my decision, I, nevertheless, added random combinations of each tick, but I won‚Äôt say exactly how this affected the decision. <br><br>  <strong>Commandos:</strong> <br>  Changing a couple of actions with such a number of simulations does not seem to be very meaningful, because very little changes occur in one action.  But when stretching one action by 5 ticks, the meaning seems to be getting bigger. <br>  I also do not like the idea itself - we take the best set and try to rule it somewhere in the beginning.  It seems to me illogical that the change of the first tics will leave the subsequent ones at least relatively adequate. </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto">  Alexander Kiselev (mortido) 3 place </h3><br><p>  Armed with articles from the winners of other contests, I decided to use a genetic algorithm.  It turned out, however, something similar to a random search or even an imitation of annealing, but more on that later. </p><br><p>  Encode the solution with an array of 40 numbers, where -1, 0 and 1 correspond to the movement of <code></code> , <code></code> and <code></code> . </p><br><p>  At the beginning of each round, I considered how much time I had spent for the entire game, considered a new time limit based on how many more rounds there would be, and I considered each round a duration of 1200 ticks.  So  Initially, I tried to spend no more than 11ms per move, but I could ‚Äúroam‚Äù a little at the end if the previous rounds were faster than 1200 ticks. </p><br><blockquote>  <strong>Valdemar:</strong> <br>  Interestingly, this chip has worsened my game.  It turned out that it is always better to spend 20-30ms than first 11, and at the end 60 </blockquote><p>  A third of this time I was looking for the best move of the enemy, the rest was spent on calculating my own decision.  When searching for a move for an enemy, my behavior was modeled as the best from the last move, shifted by 1 tick.  Those.  as if I continue to act according to the plan made in the last tick, and he is trying to resist me. </p><br><p>  The search for the solution itself was the same for both itself and the opponent: </p><br><ol><li>  We take the decision from the last move and move it by 1 move (which we have already done) </li><li>  Throwing in the population of random solutions until we fill it all </li><li>  We simulate all the solutions and expose the fitness using the evaluation function.  We remember the best. </li><li>  While there is time for calculations <br><ol><li>  Hint, always add 1 mutation of the current best solution to the population, remember it if it is better </li><li>  As long as there is a place in the new population and the time for calculations is not exceeded (you can get out on the floor of the populated population) <br><ol><li>  We take two different individuals and leave with the best fitness - mom </li><li>  We take two different individuals and leave with the best fitness - dad (should not coincide with my mother) </li><li>  We cross them </li><li>  Mutated if <code>RND &lt;  </code> </li><li>  We simulate the decision and remember it if it is the best. </li></ol></li></ol></li></ol><br><p>  As a result, we will return a sequence of actions that is considered optimal.  The first move in it is sent as a bot action.  Unfortunately, in my plan there was a serious drawback, since  the number of simulations that can be done for a tick was very small (including due to the long evaluation function), then on the competition server 4 the item was performed only 1 time, and for the enemy it wasn‚Äôt completely performed at all.  This made the algorithm look more like a random search or annealing imitation (since we had time to mutate one time solution from the last move).  It was already too late to change something, and we managed to keep 3rd place. </p><br><p>  The implementation of the crossing, mutation, and generation of initial random solutions is important, because  depends on what decisions will be checked, and the full random is not as good as it might seem at first glance (it will work, but it will take much more options to sort through). </p><br><p>  In the final version, the generation of random solutions occurred in segments, which excluded the solutions "jerking" in one place: </p><br><ol><li>  A random team was selected. </li><li>  For the entire solution length (40 moves) <br><ol><li>  Write the current command to the cell. </li><li>  With a probability of 10%, we change the current command to a random one. </li></ol></li></ol><br><p>  A similar technology also involved a mutation ‚Äî a random segment of the solution was replaced with a random command.  Crossing occurred by choosing the point to which the decision was taken from 1 parent, and then from the 2nd. </p><br><p>  I liked that we use all the time available to us to find the best solution.  And it‚Äôs not scary if the solution is not the best - we can improve it on the next tick, because  optimization turns out "smeared" in time.     ,        .  ,      -  ,    .           ,           </p><br><blockquote> <strong>Valdemar:</strong> <br>   1     , ,             . <br><br> <strong>Commandos:</strong> <br>    ‚Äî   -        . <br>         ‚Äî    ,     .         ,     ‚Ä¶      ,        .    "    ‚Äù.         -. </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto">   (Commandos) 1  </h3><br><p>        (  ),   <strong>n</strong>  <strong>m</strong>  .    3^2=9 .       <strong>m</strong> + <strong>n</strong>      40 . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">|----------- n  -----------|---------- m  --------| |   ...   |   ...   |</code> </pre> <br><p>          :     ,  ,  .      (   ). </p><br><p>       <strong>n</strong>  <strong>m</strong> ,          .       ,     . </p><br><p>        : </p><br><ol><li>     ,       (       ,   ): <br><ul><li>   ,     ,   ,     . </li><li>       ,      ,   .           .                .            ,       ,      ,     . </li><li>         .   ;        (           ). </li></ul></li><li>       <strong>n</strong>  <strong>m</strong>  .      ,    .1,      ,          .     -  (    )  ,        ‚Äî        ,      ; </li><li>             .   ,     ‚Äî      .    ,       (       ). </li></ol><br><blockquote> <strong>Valdemar:</strong> <br> ,       2    .    .         ,    . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <strong>mortido:</strong> <br>  Great!   ,       .    .  ,   2    ,   40-60       .  ,        3   . <br> n + m == const ? </blockquote><p>   .  <code>n + m != const</code> ,              .      ,  .  -   . </p><br><h1 id="funkciya-ocenki">   </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-1">   (Valdemar) 4  </h3><br><p>   ,       . ,    (  , ,   ..)    [0..1]. <br>           .     :   ,        . <br>            ,    ,      :      ,          . </p><br><p> ,   : </p><br><ul><li>    ‚Äî    70  180  (  :         ). <br>       ,       . </li><li>       0..500 </li><li>   ‚Äî  [2pi, pi/4]   [0, 1] </li><li>    ‚Äî    ,       (    ),   (  ,      ,        ) </li><li>   ‚Äî ,      ,     ,           . <br>      ,  ,       . </li><li>  ‚Äî     .          . </li><li>     Y   ‚Äî    . </li><li>           </li></ul><br><p>  ,       2           , . </p><br><p>           . </p><br><p>         : </p><br><ul><li>  ‚Äú‚Äù      ,       </li><li>  ‚Äú  ‚Äù        ,   ,        . </li></ul><br><blockquote> <strong>mortido:</strong> <br>    , ..      ,     . <br><br> <strong>Commandos:</strong> <br>      ,      .    -  </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-1">   (mortido) 3  </h3><br><p>        ,      chipmunk.              .     ,      ,     ,   ,   .        . </p><br><p>                    3   <del>  </del>   . </p><br><p>   ,        ( ,     ,   ): </p><br><ul><li>   .          ,  ,        (       ,     ); </li><li>    ,    ‚Äî       ,     ;      ,     1  ; </li><li>   ; </li><li>      (    ,  ); </li><li>       (   ‚Äú+‚Äù,    ‚Äú-‚Äù); <br> -     (   ‚Äú+‚Äù,    ‚Äú-‚Äù);   ,     ,      ,          ; <br>   30    ,       ,      (   ); </li><li>  ,         . </li></ul><br><p>  ,        ,         (,            ,     ) </p><br><blockquote> <strong>Valdemar:</strong> <br>         .    ,     ‚Äú  ,     ,    ‚Äù     ,      (     ..)     . </blockquote><p>  ,    ,        .    . </p><br><blockquote> <strong>Commandos:</strong> <br>   ,   ,   ‚Äú‚Äù‚Ä¶      ?              ,   ‚Äú‚Äù . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-1">   (Commandos) 1  </h3><br><p>      <code>SquaredWheelsBuggy</code> ,      ..  ,       .     Buggy   ,          ,          (         /). <br> : </p><br><ol><li>   ; </li><li>     ;         ‚Äî ,     ,   1  0; ..        ; </li><li>     .        ;          10      (            ); </li><li>             (       ,    ); </li><li>     (,          ); </li><li>       ‚Äî -    ,   ; </li><li> /     ;       ,       ‚Äî   ;             . </li></ol><br><p>  1-5      ,   .   2     ‚Äú  ‚Äù. </p><br><blockquote> <strong>Valdemar:</strong> <br>     ,        .       ,      . <br><br> <strong>mortido:</strong> <br>      ,     10 . </blockquote><br><h1 id="kostyli-i-ify">   IF' </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-2">   (Valdemar) 4  </h3><br><p>      ,            if'.         3    ,         ,           . ,        ,         -. <br>  :      ,    ‚Äú‚Äù   ‚Äî      ,   - ,           (  ,   ) ‚Äî   . </p><br><p>     : </p><br><ul><li>     .      ,        . </li><li>      ‚Äî     ,                  . </li><li>   .      ‚Äú  ‚Äù      . <br>      ,        ,         . <br>                ,      ,      . </li></ul><br><p>        ,    :     .   ,       ,   if'     . </p><br><blockquote> <strong>mortido:</strong> <br>     ,       .            . <br><br> <strong>Commandos:</strong> <br>   if'.   ,    ,    ‚Ä¶          ,     ,     . </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-2">   (mortido) 3  </h3><br><p>              - . </p><br><p>     3  .    .         .  ‚Äú‚Äù,                  .        ,      ,    . </p><br><p>          ,     ‚Äú‚Äù   .       .     ,        , ,      -  .        .     ,       , ..    . </p><br><p>    ,      ,  ,     ,           ,       .     ‚Ä¶         .    -       ‚Äî  ,     (      ,     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>    ,     .          .        ‚Äú‚Äù ,       if'.  ,           ‚Äî             . </blockquote><p>          ,       +      . ,       . </p><br><blockquote> <strong>Commandos:</strong> <br>   ‚Ä¶  ,  -   ‚Äî   ,      ,   .        ,     ,                . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-2">   (Commandos) 1  </h3><br><p>         .      (,     ,    ).         (  )   /. </p><br><p>    pill carcass map        ,       ,             (         ).      island map,      ,     . </p><br><p>             island hole  buggy.    /      ,     ,      (  ).       ‚Äî    .  ,          ,    .   SquaredWheelBuggy           .    ,      ,      ,    .  ,   ‚Ä¶    ,      ,     . </p><br><p>    (Pill map, Bus)                 ,        (     /  100% ). </p><br><p>         pill hubble map.    <a href="https://aicups.ru/session/487392/"></a> <a href="https://aicups.ru/session/487387/"></a> ,   <a href="https://aicups.ru/session/487396/"></a> <a href="https://aicups.ru/session/487402/"></a> (    ),     .       . </p><br><p>               ‚Äî         ,   ... </p><br><p>       ,     .                ,    .          (     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>   ,          ‚Äî        .   ,     . <br><br> <strong>mortido:</strong> <br>     ,     ‚Äú‚Äù  . </blockquote><br><h1 id="emocii">  </h1><br><blockquote> <strong>Valdemar:</strong> <br>     .           ,      .    (   )      . <br>                  .  ‚Äú‚Äù,      ,          , ,  :) <br>  ,  mailru  ,     . <br><br> <strong>mortido:</strong> <br>        :               ,          ‚Ä¶   ,      ,       (      ).     ,     3   ,    ,   ‚Ä¶      . <br><br> <strong>Commandos:</strong> <br> -     ,     . , ,   ,  .    ‚Ä¶       .         ‚Äî     ,      . <br>     ‚Äî       ++.       .       ,       .     1  <del>       </del>     -. </blockquote><br><h1 id="itak">  </h1><br><p> ,           .    ,              .      ,      ,        <a href="https://t.me/aicups"> </a> . </p><br><p>   <a href="https://habr.com/users/sannikovdmitry/"></a>  Mail.Ru Group   . </p><br><h1 id="bonus">  Bonus </h1><br><p>  <a href="https://github.com/kswaldemar/aicup-madcars">Valdemar</a> <br>  <a href="https://github.com/mortido/mini-ai-cup-3">mortido</a> <br> <a href="https://github.com/core2duo/RHC-AI">   </a> </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/bz/b8/cd/bzb8cdwabur3c-7qbcwzmjokx0o.gif"></p><br><p><img src="https://habrastorage.org/webt/tw/nw/cw/twnwcwndcdjglzq2hhuh0ulxohc.gif"></p><br><p><img src="https://habrastorage.org/webt/ib/jh/vq/ibjhvquma8mwq6meckt2qzteicy.gif"></p><br><p><img src="https://habrastorage.org/webt/4e/eg/c9/4eegc9jvtcg-0namubh_9cqx2ok.gif"></p><br><p><img src="https://habrastorage.org/webt/4f/uw/w8/4fuww8dcs4-fx4nuar8bcur0lpm.gif"></p><br><p><img src="https://habrastorage.org/webt/fz/q3/6u/fzq36ufo15jgjwbd9ev_cnc6mso.gif"></p><br><p><img src="https://habrastorage.org/webt/og/55/dt/og55dtgv4ohguhiucwhn0qwqiak.gif"></p></div></div></div><p>Source: <a href="https://habr.com/ru/post/430466/">https://habr.com/ru/post/430466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430454/index.html">I'm surrounded by idiots or how to work in a team</a></li>
<li><a href="../430456/index.html">Legal PMI Project Management Books</a></li>
<li><a href="../430458/index.html">Multilayer Graphene Superconductor: Study of Flat Zones</a></li>
<li><a href="../430460/index.html">Trojan Penguin: Making a Virus for Linux</a></li>
<li><a href="../430462/index.html">In Russia, there was a bill to provide users of social networks to an unlimited circle of people. Social networks against</a></li>
<li><a href="../430468/index.html">We raise citizens' consciousness</a></li>
<li><a href="../430470/index.html">Why keeping the context on the client's account is fair and profitable</a></li>
<li><a href="../430472/index.html">Seamless DECT-network do it yourself</a></li>
<li><a href="../430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../430476/index.html">NCBI Genome Workbench: Scientific Research Under Threat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>