<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript without loops</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I wrote that indentation can be considered an indicator of the complexity of the code (albeit rather coarse). The indents themselves are neutral,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript without loops</h1><div class="post__text post__text-html js-mediator-article">  Once I <a href="http://jrsinclair.com/articles/2017/indentation-is-the-enemy-less-complex-javascript/">wrote</a> that indentation can be considered an indicator of the complexity of the code (albeit rather coarse).  The indents themselves are neutral, since they are only a means of text formatting, but the whole point is that they are used to select specific program blocks, for example, control structures.  While reading the code and bumping into the indent, the programmer has to take into account what the indent indicates, to keep in mind the context in which the allocated block exists.  This, of course, is repeated if another special fragment appears in the indented portion of the code. <br><br>  If you don‚Äôt pay attention to the content of the texts, here‚Äôs how a complex code usually looks, the sections of which look like the letters ‚ÄúV‚Äù lying on its side, and a simple code whose block, if not taking into account the different lengths of lines, looks like a rectangle. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/322850/"><img src="https://habrastorage.org/getpro/habr/post_images/673/12a/d7f/67312ad7f4fd83a676ec9fc9d05691d6.png"></a> <br>  <i><font color="#999999">The more indents, the more difficult the code is.</font></i> <br><a name="habracut"></a><br>  Constructions that need to be indented will always be in the code, there is no question of completely getting rid of them.  However, we are able to reduce the complexity of the programs that we write, due to the rational choice of abstractions for solving the problems we face. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Take, for example, arrays.  Traditionally for their processing use various types of cycles.  The concepts of "array" and "cycle" are inextricably linked in the minds of many programmers.  However, the cycle is a very ambiguous design.  Here is what Louis Atenzio writes about cycles in his book <a href="https://www.manning.com/books/functional-programming-in-javascript">Functional Programming in JavaScript</a> : ‚ÄúA loop is a hard control construct that is not easy to reuse and difficult to dock with other operations.  In addition, the use of cycles means the appearance of a code that changes with each iteration. ‚Äù <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/864/5e6/9c18645e630249a48b26ce0f2e82eb07.png"><br>  <i><font color="#999999">Is it possible to get rid of cycles?</font></i> <br><br>  The cycle is one of the main structural control structures, and, in fact, we are not going to say that cycles are evil, from which we must get rid of.  Our main goal is to reduce the complexity of our own code by minimizing the use of cycles when processing arrays.  Is it possible?  We offer to find out together. <br><br><h2>  <font color="#3AC1EF">Cycles</font> </h2><br>  We have already said that control structures, such as cycles, complicate the code.  But why is this so?  Take a look at how cycles work in javascript. <br><br>  In JS, there are several ways to organize loops.  In particular, one of the basic types of cycles is <code>while</code> .  Before going into details, let's get a little ready.  Namely, we will create a function and an array with which we will work. <br><br><pre> <code class="hljs lua">// oodlify :: String -&gt; String <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oodlify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.replace(/[aeiou]/g, <span class="hljs-string"><span class="hljs-string">'oodle'</span></span>); } const <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> = [   <span class="hljs-string"><span class="hljs-string">'John'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Paul'</span></span>,   <span class="hljs-string"><span class="hljs-string">'George'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Ringo'</span></span>, ];</code> </pre> <br>  So, there is an array, each element of which we are going to process using the <code>oodlify</code> function.  If you use the <code>while</code> to solve this problem, you get the following: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = input.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = input[i];   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);   output.push(newItem);   i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Notice that we use the counter <code>i</code> to track the current processed element of the array.  It is necessary to initialize it with zero and increment by one in each iteration of the loop.  In addition, you need to compare it with the length of the array, with <code>len</code> , in order to know when to stop working. <br><br>  This template is so common that in JavaScript there is a simpler way to organize a similar construct - the <code>for</code> loop.  Such a cycle will solve the same problem as follows: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = input.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = input[i];   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);   output.push(newItem); }</code> </pre> <br>  The <code>for</code> loop is a useful design, since thanks to it all standard auxiliary operations with the counter are moved to the top of the block.  Using <code>while</code> , it is easy to forget about the need to increment counter <code>i</code> , which will start an infinite loop.  Definitely, the <code>for</code> loop is much more convenient than the <code>while</code> .  But let's slow down and take a look at what our code is trying to achieve.  We want to process, using the <code>oodlify()</code> function, each element of the array and put what we have got into the new array.  By itself, the counter used to access the elements of the array does not interest us. <br><br>  This pattern of working with arrays, which involves performing certain actions with each element, is quite common.  As a result, ES2015 has a new loop design that allows you to forget about the meter.  This is the <code>for‚Ä¶of</code> loop of <code>for‚Ä¶of</code>  In each iteration of such a loop, the next element of the array is provided.  It looks like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> input) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);   output.push(newItem); }</code> </pre> <br>  The code looks much cleaner.  Please note that there is neither a counter nor a comparison operation.  With this approach, it is not even necessary to refer to a specific element of the array by index.  The <code>for‚Ä¶of</code> loop takes all the auxiliary operations. <br><br>  If we complete the study of ways to work with arrays and apply <code>for‚Ä¶of</code> loops everywhere instead of <code>for</code> loops, this will be a good step forward by simplifying the code.  But ... we can go further. <br><br><h2>  <font color="#3AC1EF">Array Transformation</font> </h2><br>  The <code>for‚Ä¶of</code> loop looks much cleaner than the <code>for</code> loop, but with it there are quite a few auxiliary elements in the code.  So, you need to initialize the <code>output</code> array and call the <code>push()</code> method at each iteration of the loop.  The code can be made even more compact and expressive, but before doing this, let's expand the demo task a bit.  What if you need to process two arrays using the <code>oodlify()</code> function? <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fellowship = [   <span class="hljs-string"><span class="hljs-string">'frodo'</span></span>,   <span class="hljs-string"><span class="hljs-string">'sam'</span></span>,   <span class="hljs-string"><span class="hljs-string">'gandalf'</span></span>,   <span class="hljs-string"><span class="hljs-string">'aragorn'</span></span>,   <span class="hljs-string"><span class="hljs-string">'boromir'</span></span>,   <span class="hljs-string"><span class="hljs-string">'legolas'</span></span>,   <span class="hljs-string"><span class="hljs-string">'gimli'</span></span>, ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> band = [   <span class="hljs-string"><span class="hljs-string">'John'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Paul'</span></span>,   <span class="hljs-string"><span class="hljs-string">'George'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Ringo'</span></span>, ];</code> </pre> <br>  The obvious solution is to use two cycles and process arrays in them: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bandoodle = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> band) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);   bandoodle.push(newItem); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> floodleship = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> fellowship) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);   floodleship.push(newItem); }</code> </pre> <br>  It is a working option.  And the code that works is much better than the code that does not solve the task set for it.  But two very similar code fragments are not particularly well consistent with the principle of <a href="https://en.wikipedia.org/wiki/Don%2527t_repeat_yourself">DRY</a> software development.  The code can be refactored in order to reduce the number of repetitions. <br><br>  Following this idea, we create the following function: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oodlifyArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = [];   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> input) {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newItem = oodlify(item);       output.push(newItem);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bandoodle = oodlifyArray(band); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> floodleship = oodlifyArray(fellowship);</code> </pre> <br>  It looks much better, but what if there is another function with which we also want to process the elements of the arrays? <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">izzlify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[aeiou]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">'izzle'</span></span>); }</code> </pre> <br>  Now the <code>oodlifyArray()</code> function does not help.  However, if we create another similar function, this time <code>izzlufyArray()</code> , we will repeat it again.  Nevertheless, let's create such a function and compare it with <code>oodlifyArray()</code> : <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oodlifyArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span></span> {   let <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = [];   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let item of <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) {       let newItem = oodlify(item);       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.push(newItem);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">izzlifyArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span></span> {   let <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = [];   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let item of <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) {       let newItem = izzlify(item);       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.push(newItem);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre> <br>  These two functions are incredibly similar.  Maybe we can generalize the pattern they follow?  Our goal is this: ‚ÄúThere is an array and a function.  We need to get a new array, in which the results of processing each of the elements of the original array will be recorded using the function ‚Äù.  This kind of array processing is called ‚Äúmapping‚Äù or ‚Äútransformation‚Äù (mapping in English terminology).  Functions that perform such operations are usually called ‚Äúmap‚Äù.  This is how our version of this function looks like: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, a)</span></span></span></span> {   let <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = [];   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let item of a) {       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.push(f(item));   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre> <br>  Although the cycle is now in a separate function, it did not work out at all.  If you go to the end and try to do without cyclic structures at all, you can write a recursive version of the same thing: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, a)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a.length === 0)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">; }   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[f(a[0]</span></span></span><span class="hljs-function">)].</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(map(f, a.slice(1)</span></span></span><span class="hljs-function">)); }</span></span></code> </pre> <br>  Recursive solution looks very elegant.  Just a couple of lines of code and a minimum of indents.  But recursive implementations of algorithms are usually used with great care, in addition, they are characterized by poor performance in old browsers.  And, in fact, we do not need to write the function of implementing the display operation ourselves, unless there is a valid reason.  What our <code>map</code> function does is a task so common that JavaScript has a built-in <code>map()</code> method.  If you use this method, the code will be like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bandoodle     = band.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(oodlify); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> floodleship   = fellowship.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(oodlify); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bandizzle     = band.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(izzlify); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fellowshizzle = fellowship.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(izzlify);</code> </pre> <br>  Please note that there are no indents or cycles at all.  Of course, when processing data, somewhere in the depths of JavaScript, cycles can be used, but this is not our concern.  Now the code turned out to be both compressed and expressive.  In addition, it is easier. <br><br>  Why is this code easier?  It may seem like the question is stupid, but think about it.  Is it simpler because it is shorter?  Not.  Compact code is not a sign of simplicity.  It is easier because with this approach we have divided the task into parts.  Namely, there are two functions that work with strings: <code>oodlify</code> and <code>izzlify</code> .  These functions should not know anything about arrays or loops.  There is another function - <code>map</code> , which works with arrays.  At the same time, she does not care at all what type of data is in the array, or what we want to do with this data.  It simply performs any function passed to it, passing it the elements of the array.  Instead of mixing everything, we separated the processing of strings and the processing of arrays.  That is why the final code was simpler. <br><br><h2>  <font color="#3AC1EF">Array Convolution</font> </h2><br>  So, the <code>map</code> function is very useful, but it does not overlap all the options for processing arrays that use loops.  It is good in cases when, on the basis of a certain array, you need to create a new one having the same length.  But what if we need, for example, to stack all the elements of a numeric array?  Or if you need to find the shortest line in the list?  Sometimes it is required to process an array and, in fact, form a single value based on it. <br><br>  Consider an example.  Suppose there is a list of objects, each of which represents a superhero: <br><br><pre> <code class="hljs pgsql">const heroes = [   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Hulk'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">90000</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Spider-Man'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">25000</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Hawk Eye'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">136</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thor'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">100000</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Black Widow'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">136</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Vision'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">5000</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Scarlet Witch'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">60</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Mystique'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">120</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Namora'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">75000</span></span>}, ];</code> </pre> <br>  We must find the strongest hero.  In order to do this, you can use the <code>for‚Ä¶of</code> loop: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> strongest = {<span class="hljs-attr"><span class="hljs-attr">strength</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hero.strength &gt; strongest.strength) {       strongest = hero;   } }</code> </pre> <br>  All things considered, this code is not so bad.  We loop around the array, storing the object of the strongest of the viewed characters in the <code>strongest</code> variable.  In order to see more clearly the pattern of working with an array, let's imagine that we still need to figure out the total strength of all the characters. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> combinedStrength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   combinedStrength += hero.strength; }</code> </pre> <br>  In each of these two examples there is a working variable that is initialized before starting the loop.  Then, in each iteration, one element of the array is processed and the variable is updated.  In order to isolate the scheme of work even better, we move the operations performed inside the cycles into a function and rename the variables in order to emphasize the similarity of the actions performed. <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greaterStrength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">champion, contender</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (contender.strength &gt; champion.strength) ? contender : champion; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addStrength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tally, hero</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tally + hero.strength; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialStrongest = {<span class="hljs-attr"><span class="hljs-attr">strength</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> working = initialStrongest; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   working = greaterStrength(working, hero); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strongest = working; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialCombinedStrength = <span class="hljs-number"><span class="hljs-number">0</span></span>; working = initialCombinedStrength; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   working = addStrength(working, hero); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combinedStrength = working;</code> </pre> <br>  If everything is rewritten as shown above, the two cycles are very similar.  The only thing that distinguishes them is the functions they call and the initial values ‚Äã‚Äãof the variables.  In both cycles, the array collapses to one value.  In English terminology, such an operation is called ‚Äúreducing‚Äù.  Therefore, we create a <code>reduce</code> function that implements the detected pattern. <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, initialVal, a</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> working = initialVal;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a) {       working = f(working, item);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> working; }</code> </pre> <br>  It should be noted that, as in the case of the <code>map</code> function template, the <code>reduce</code> function template is so widely distributed that JavaScript provides it as an embedded method of arrays.  Therefore, your method, if there is no special reason for this, is not necessary to write.  Using the standard method, the code will look like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strongestHero = heroes.reduce(greaterStrength, {strength: <span class="hljs-number"><span class="hljs-number">0</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combinedStrength = heroes.reduce(addStrength, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  If you look at the final result, you may find that the resulting code is not much shorter than what it was before, the savings are quite small.  If we used the <code>reduce</code> function, written by ourselves, then, in general, the code would have turned out more.  However, our goal is not to write short code, but to reduce its complexity.  So, have we reduced the complexity of the program?  I can say that reduced.  We have separated the loop code from the code that processes the elements of the array.  As a result, individual sections of the program have become more independent.  The code is easier. <br><br>  At first glance, the <code>reduce</code> function may seem rather primitive.  Most examples of using this function demonstrate simple things, like the addition of all the elements of numeric arrays.  However, it is not said anywhere that the value that the <code>reduce</code> returns should be of a primitive type.  This can be an object or even another array.  When I first realized it, it struck me.  You can, for example, write an implementation of a mapping or filtering an array using <code>reduce</code> .  I suggest you try it yourself. <br><br><h2>  <font color="#3AC1EF">Array Filtering</font> </h2><br>  So, there is a <code>map</code> function to perform operations on each element of the array.  There is a <code>reduce</code> function, which allows you to compress the array to a single value.  But what if you need to extract only some of its elements from an array?  To explore this idea, expand the list of superheroes, add some additional data there: <br><br><pre> <code class="hljs pgsql">const heroes = [   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Hulk'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">90000</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'m'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Spider-Man'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">25000</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'m'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Hawk Eye'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">136</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'m'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thor'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">100000</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'m'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Black Widow'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">136</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'f'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Vision'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">5000</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'m'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Scarlet Witch'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">60</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'f'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Mystique'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">120</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'f'</span></span>},   {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Namora'</span></span>, strength: <span class="hljs-number"><span class="hljs-number">75000</span></span>, sex: <span class="hljs-string"><span class="hljs-string">'f'</span></span>}, ];</code> </pre> <br>  Now suppose that there are two tasks: <br><br><ol><li>  Find all the female characters. </li><li>  Find all the heroes whose strength exceeds 500. </li></ol><br>  It is quite possible to approach the solution of these problems using the good old cycle of <code>for‚Ä¶of</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> femaleHeroes = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hero.sex === <span class="hljs-string"><span class="hljs-string">'f'</span></span>) {       femaleHeroes.push(hero);   } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> superhumans = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hero.strength &gt;= <span class="hljs-number"><span class="hljs-number">500</span></span>) {       superhumans.push(hero);   } }</code> </pre> <br>  In general, it looks quite decent.  But here the repeating pattern is visible to the naked eye.  In fact, the cycles are exactly the same, they differ only in <code>if</code> blocks.  What if to take out these blocks in functions? <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFemaleHero</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hero</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (hero.sex === <span class="hljs-string"><span class="hljs-string">'f'</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSuperhuman</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hero</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (hero.strength &gt;= <span class="hljs-number"><span class="hljs-number">500</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> femaleHeroes = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFemaleHero(hero)) {       femaleHeroes.push(hero);   } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> superhumans = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heroes) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isSuperhuman(hero)) {       superhumans.push(hero);   } }</code> </pre> <br>  Functions that return only <code>true</code> or <code>false</code> sometimes called predicates.  We use the predicate to decide whether to save the next value from the <code>heroes</code> array in the new array. <br><br>  The way we rewrote the code made it longer.  But, after the selection of predicate functions, it became better to see the repeating sections of the program.  Create a function that allows you to get rid of these repetitions: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predicate, arr</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> working = [];   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate(item)) {           working = working.concat(item);       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> working; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> femaleHeroes = filter(isFemaleHero, heroes); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> superhumans  = filter(isSuperhuman, heroes);</code> </pre> <br>  Here, as is the case with the built-in <code>map</code> and <code>reduce</code> functions, JavaScript has the same thing that we wrote here, in the form of the standard <code>filter</code> method of the <code>Array</code> object.  Therefore, it is not necessary to write your own function, without any obvious need.  Using standard tools, the code will look like this: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> femaleHeroes = heroes.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>(isFemaleHero); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> superhumans  = heroes.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>(isSuperhuman);</code> </pre> <br>  Why is such an approach much better than using a <code>for‚Ä¶of</code> loop?  Think about how this can be used in practice.  We have a task of the form: "Find all the heroes who ...".  As soon as it became clear that the problem can be solved using the standard <code>filter</code> function, the work is simplified.  All that is needed is to inform this function exactly which elements interest us.  This is done through the writing of one compact function.  You do not have to worry about handling arrays, nor about additional variables.  Instead, we write a tiny predicate function and the problem is solved. <br><br>  And, as is the case with other functions that work with arrays, the use of <code>filter</code> allows you to express more information in a smaller amount of code.  You do not need to read the entire standard loop code in order to understand what we are filtering.  Instead, everything you need to understand is described directly when the method is called. <br><br><h2>  <font color="#3AC1EF">Search in arrays</font> </h2><br>  Filtering is a very useful operation.  But what if you need to find only one superhero from the list?  Let's say we're interested in the Black Widow.  The <code>filter</code> function can be used to solve this problem: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBlackWidow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hero)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hero.name === 'Black Widow')</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blackWidow</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heroes</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isBlackWidow)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[0]</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  The main problem here is that this solution is not very effective.  The <code>filter</code> method scans every element of an array.  However, it is known that in the array only one hero is called Black Widow, which means that you can stop after this hero is found.  At the same time, predicate functions are convenient to use.  Therefore, we write a <code>find</code> function that finds and returns the first matching element: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predicate, arr</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate(item)) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item;       }   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blackWidow = find(isBlackWidow, heroes);</code> </pre> <br>  Here, again, I must say that JavaScript has a built-in function that does exactly what you need: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blackWidow = heroes.find(isBlackWidow);</code> </pre> <br>  As a result, as before, we managed to express our idea more concisely.  Using the built-in <code>find</code> function, the task of searching for a specific element comes down to one question: ‚ÄúBy what sign can we determine that the search element was found?‚Äù You don‚Äôt need to worry about details. <br><br><h2>  <font color="#3AC1EF">About the reduce and filter functions</font> </h2><br>  Readers have noticed that it is inefficient to double-pass through the list of characters in the above examples to the <code>reduce</code> and <code>filter</code> functions.  Using the spread operator from ES2015 allows you to conveniently combine two functions that are used to fold an array into one.  Here is a modified code snippet that allows you to traverse the array only once: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processStrength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({strongestHero, combinedStrength}, hero)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strongestHero</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greaterStrength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strongestHero, hero)</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combinedStrength</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addStrength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(combinedStrength, hero)</span></span></span><span class="hljs-function">,   }; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> {</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strongestHero</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combinedStrength</span></span></span><span class="hljs-function">} = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heroes</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(processStrength, {strongestHero: {strength: 0}, combinedStrength: 0})</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  I can not help but notice that this version will be a little more difficult than the one in which the array was passed through twice, but if the array is huge, reducing the number of passes through it can be very useful.  In any case, the <a href="http://bigocheatsheet.com/">order of complexity of the</a> algorithm remains O (n). <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  I suppose the functions presented here are a great example of why thoughtfully chosen abstractions bring benefits and look good in code.  Suppose we use built-in functions wherever possible.  In each case, the following is obtained: <br><br><ol><li>  We get rid of loops, which makes the code more compressed and, most likely, easier to read. <br></li><li>  The pattern used is described using the appropriate name of the standard method.  That is - <code>map</code> , <code>reduce</code> , <code>filter</code> , or <code>find</code> . <br></li><li>  The scale of the task is reduced.  Instead of self-writing code to handle an array, you only need to specify the standard function to do something with the array. <br></li></ol><br>  Please note that in each case compact pure functions are used to solve the problem. <br><br>  In fact, if you think about all this, you can come to a conclusion that, at the first moment, seems surprising.  It turns out that if you use only the four array patterns described above, you can remove almost all loops from the JS code.  After all, what is done in almost every loop written in JavaScript?  It either processes or constructs an array, or both.  In addition, in JS there are other <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array">standard functions</a> for working with arrays, you can easily study them yourself.  Getting rid of loops almost always allows you to reduce the complexity of programs and write code that is easier to read and maintain. <br><br>  Dear JavaScript developers, do you have some standard features in mind that allow you to improve the code by getting rid of any common "custom-made" constructions? </div><p>Source: <a href="https://habr.com/ru/post/322850/">https://habr.com/ru/post/322850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322836/index.html">Simple, modern MVC framework for PHP to develop websites from scratch</a></li>
<li><a href="../322840/index.html">Unsafe continues to live in Java 9</a></li>
<li><a href="../322842/index.html">Minimalism in game design: examples, tips and ideas. Part two</a></li>
<li><a href="../322844/index.html">A quick guide to how to access opensource: who needs it, why and how</a></li>
<li><a href="../322846/index.html">Corporate software navigator: there is always a choice</a></li>
<li><a href="../322852/index.html">The state wants to know about all purchases in stores and cafes: analysis of the new law on online cash registers</a></li>
<li><a href="../322854/index.html">How to check database availability by external service</a></li>
<li><a href="../322856/index.html">Mythical PCM Capture Extraction Tool: extract sound without contacting TAC</a></li>
<li><a href="../322858/index.html">Top key threats, strong trends and promising technologies. Gartner forecasts for the next few years</a></li>
<li><a href="../322860/index.html">Catch in 30 minutes and other records Social Media Support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>