<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing the Microsoft Office localization file format</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever noticed that the AGGREGATE function in Excel for the second set of arguments has an incorrect argument description? In fact, in the seco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing the Microsoft Office localization file format</h1><div class="post__text post__text-html js-mediator-article">  Have you ever noticed that the AGGREGATE function in Excel for the second set of arguments has an incorrect argument description?  In fact, in the second set, the descriptions of the arguments are interspersed from the second and first sets.  This bug is accurately reproduced in Excel 2010, 2013. I wondered why this was happening, because Microsoft cannot carelessly treat the interface of one of its main products.  The result was a complete parsing of the MS Office localization file format. <br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/829/2c9/79a/8292c979ae3e465b8ec3fc4a924300ab.jpg"></div><br clear="all"><a name="habracut"></a><br><h1>  Variant in the forehead </h1><br>  After a brief search for descriptions of the function arguments for the contents of the files in the office folder, the file <i>c: \ Program Files \ Microsoft Office \ Office15 \ 1033 \ XLINTL32.DLL was found</i> .  Where 1033 is the LCID of the localization language ( <a href="http://msdn.microsoft.com/en-us/goglobal/bb896001.aspx">for details, see msdn</a> ). <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/ecf/bb7/41e/ecfbb741e6844b5e8a17a6c5866ab5c7.png"></div><br clear="all">  From a quick glance it became clear that, in principle, I found what I was looking for.  The argument descriptions for the AGGREGATE function for both variants in the file were correct.  It turned out that Excel incorrectly parses its own localization file.  Then it was decided to write your Excel localization files parser, or at least to understand the format of the MS Office localization files. <br><br>  For a start, it was decided to write a parser of only descriptions of arguments and functions, as a quick glance at the file that is presented above gave the impression that the format is quite simple - the exclamation mark between the text serves as an exclamation mark, and you can understand what text means . <br><br>  As a result, after a slightly thoughtful reading of the file, the following scheme for describing arguments and functions was revealed: <ol><li>  All the descriptions are written in some proprietary order of functions for Excel, which did not coincide with the order of functions described in the specification for the xls format. </li><li>  Each function description is written in the following form: ‚Äú!‚Äù + Comma separated descriptions of function arguments + [‚Äú!‚Äù + Second set of arguments, if any] + ‚Äù!!‚Äù + description of the function itself + ‚Äù!‚Äù + Argument descriptions, separated by ‚Äú ! ‚Äù </li><li>  Not all functions have a description, there are even completely empty functions that are written in the file like this: !!!  - that's all. </li></ol><br>  According to this scheme, a parser was quickly written, which coped quite well with its work, but there were several problems: <ol><li>  Between the descriptions of some functions, and specifically between the descriptions for the functions numbered 249 and 250, as well as between 504 and 505 there were incomprehensible kryakozyabry, and then again the normal descriptions: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/78d/e62/764/78de62764d14401e883c767fd857743e.png"></div><br clear="all"></li><li>  Descriptions of some functions did not fit the selected scheme and had to write crutches for them. </li><li>  It is not clear which function belongs to which description. </li><li>  The offset of the beginning of the block of descriptions of functions for different localizations was different, and we had to recognize this offset with our hands and enter it into the dictionary in the parser.  What kind of automation can we talk about here? </li><li>  In some localizations, the descriptions were in UTF-8 format, in other UTF-16, somewhere in general half of the descriptions were on UTF-8, the other on UTF-16. </li></ol><br>  But in principle, with a large number of dirty hacks, it was possible to pull out descriptions of functions for almost all localizations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Go down deeper </h1><br>  It remains to solve the problem of which function belongs to which description.  To do this, I again began searching for the contents of files in MS Office folders, only this time I was looking for the names of the functions.  And I was lucky: next to the file XLINTL32.DLL with descriptions of functions lay the file XLLEX.DLL, in which there was something similar to the names of the functions: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/ae1/504/76a/ae150476a4c84eaaa166c5d628c56e55.png"></div><br clear="all">  Only they went all somehow in a row and without gaps.  And if for the English language it was still possible to disassemble this text with hands into separate names of functions, then for Arabic or Thai just so I could not do it. <br>  In principle, it became clear that it was time to understand the format of the Excel localization files, or to score on this matter and go to bed.  The first was chosen. <br><br>  At first I noticed that both function descriptions and function names are stored in dll files in a resource with the name "1" and type "234".  Thoughtful study of the resource dump from the XLLEX.DLL file (this is the one with the names of the functions) led me to the following discovery: between the sections with normal text there are areas with krakozybrami, which must bear a certain meaning.  Then it was decided to study these sites more deeply using WinHEX and a calculator.  Take the plot krakozyabrov that go in front of the site with the names of functions: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/e71/c9c/9ca/e71c9c9caf7e46148200bea5ef145800.png"></div><br clear="all">  The first two bytes: 01 00 - I still do not know what they mean.  The second two bytes are 56 02 - if you turn them over 0256, and if you also convert them from hex to decimal, you will get 598. Exactly as many function names below in the block of meaningful text.  This is already pleased.  Look further: the following pairs of bytes, if swapped, are like an increasing sequence.  So it is, these bytes are the offset of the description of a separate function from the end of the gib block.  In fact, the screenshot from the XLLEX.DLL file shows that the first function is COUNT - 5 bytes (0005h-0000h), the second - IF - 2 bytes (0007h-0005h), the third - ISNA - 4 bytes (000Bh-0007h) . <br><br>  This is all very well, but how to determine where the block of cracks begins, in which the lengths of the names of the functions are given.  Indeed, in each localization, this block has its own offset.  Then I began to dig the header of the resource dump from the XLLEX.DLL file. <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/22f/a31/a39/22fa31a390254d8eab1c2cf15b1dfb28.png"></div><br clear="all">  The first 4 bytes are the size of the resource.  Further, I was interested in the bytes that are located at offset 33h 34h - their value - 0256 - exactly the same as the number of function names written in the file.  In addition, every 17 bytes is repeated 03h, and the last 4 bytes in the area selected in the screenshot - 0E 6F 00 00 just equal to the number equal to the size of the resource = the size of the selected area + 4 + 4 - 1. That is, in fact, this the size of that part of the file where the data is. <br>  Now you can write out all the bytes that are between duplicate 03h and group them a little: <table><tbody><tr><td>  03 </td><td>  0F05 </td><td>  00000000 </td><td>  0000 </td><td>  9E1C0000 </td><td>  00000000 </td></tr><tr><td>  03 </td><td>  5602 </td><td>  00000000 </td><td>  0100 </td><td>  51150000 </td><td>  9E1C0000 </td></tr><tr><td>  03 </td><td>  0601 </td><td>  00000000 </td><td>  0200 </td><td>  A00A0000 </td><td>  EF310000 </td></tr><tr><td>  03 </td><td>  0404 </td><td>  00000000 </td><td>  0300 </td><td>  E6310000 </td><td>  8F3C0000 </td></tr><tr><td>  03 </td><td>  3100 </td><td>  00000000 </td><td>  0400 </td><td>  99000000 </td><td>  756E0000 </td></tr></tbody></table>  After a long search of different variants, what these bytes may denote, the following pattern was highlighted: <ul><li>  1 byte is a block type (types 02, 03, 04 are normal lines in office files, 01 is similar to the WordBasic function table, there all the description goes as a function name and an index for each function). </li><li>  2 bytes - the number of elements in the block. </li><li>  4 bytes - I do not know.  In all files that I watched, this value is always 0, it can be reserved. </li><li>  2 bytes - the sequence number of the block. </li><li>  4 bytes - block size </li><li>  4 bytes - the offset of the block from the end of the block description, in the case of our file from 7Ah. </li></ul>  Plot where data is recorded on where a block starts, its size, etc.  I called the map blocks.  For the introduction of terms, I mentally split the file into three sections: the header, the block map, the actual text blocks (which consist of the block description and the data itself). <br><br><h1>  Understand encodings </h1><br>  In principle, this data is already enough to make an automatic parser for the XLLEX.DLL file and pull out the names of all functions in all languages ‚Äã‚Äãand a lot of other information.  But one problem arose in the process: only a very small part of the localizations stored data in UTF-8 format.  Most of the data is stored in some completely incomprehensible formats: each character is encoded with 1 byte with some offset relative to the table of this language in UTF-8.  For example, Cyrillic "C" and "H" were recorded as A1 and A7, and in the UTF8 table they have the numbers D0A1 and D0A7, but the "p" was written as C0, although it should be D180. <br><br>  To solve this problem, I first, naturally, tried to understand how Excel itself translates strings from such an incomprehensible encoding at least in UTF-8.  To do this, it was necessary to compare the block descriptions for several languages, I took the Russian localization and English: <br><br>  Begin the description of the block for the English localization: <ul><li>  English: 0100 5602 0500 ... (the second two bytes, as we found out above - the number of elements in the block, the third two bytes - the length of the first element (COUNT function - 5 bytes) ...) </li><li>  Russian: 0184 5602 0400 ... (the second two bytes are the number of elements, the third two bytes are the length of the first element (the COUNT function is 4 bytes) ...) </li></ul>  As you can see, the descriptions differ only in the first two bytes.  Moreover, among the localizations there are those where the text was recorded in two-byte Unicode LE.  In such files, the description was: 0000 5602 ... <br><br>  From this, some conclusions were made: the first two bytes in the block description are encoding.  If the first byte = 0, then the text in this block is written in Unicode LE, and everything is simple.  If the first byte of the encoding = 01, then you need to look at the second byte.  If the second byte = 00, then the text is encoded in a simple UTF-8 encoding; here, too, do not break your head.  But what if the second byte is not 0? <br><br>  At first, I simply compiled a dictionary: the value of the second byte is the offset in the UTF-8 table.  It quickly bored me, and I began to look for a pattern.  It soon became clear that the offset in the UTF-8 table can be defined as: offset = (byte2-80h) * 4 + C0h.  The only problem is that for some groups of codings C0h had to be changed to another number. <br><br>  As a result, the text conversion functions began to look like this: <div class="spoiler">  <b class="spoiler_title">C # code</b> <div class="spoiler_text"><pre><code class="hljs go">#region Convert <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GetCharSize(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blockIndex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Convert(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blockIndex) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> encodingByte1 = block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> encodingByte2 = block2Encoding[blockIndex][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(encodingByte1 == <span class="hljs-number"><span class="hljs-number">0</span></span> || encodingByte1 == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Convert0000(array); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(encodingByte2 &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConvertFromUTF8(array, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xC2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = encodingByte2 - <span class="hljs-number"><span class="hljs-number">0x80</span></span>; d *= <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> byte1; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> byte2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d &lt; <span class="hljs-number"><span class="hljs-number">0x20</span></span>) { byte1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; byte2 = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-number"><span class="hljs-number">0xC0</span></span> + d); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d &lt; <span class="hljs-number"><span class="hljs-number">0x40</span></span>) { byte1 = <span class="hljs-number"><span class="hljs-number">0xE0</span></span>; byte2 = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-number"><span class="hljs-number">0xA0</span></span> + (d - <span class="hljs-number"><span class="hljs-number">0x20</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { d -= <span class="hljs-number"><span class="hljs-number">0x40</span></span>; byte1 = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-number"><span class="hljs-number">0xE1</span></span> + d / <span class="hljs-number"><span class="hljs-number">0x40</span></span>); byte2 = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-number"><span class="hljs-number">0x80</span></span> + d % <span class="hljs-number"><span class="hljs-number">0x40</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConvertFromUTF8(array, byte1, byte2); } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] ConvertFromUTF8(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> byte1, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> byte2) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; result = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(); foreach(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b in array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b &lt;= <span class="hljs-number"><span class="hljs-number">0xFF</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>) result.Add(b); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte1 != <span class="hljs-number"><span class="hljs-number">0</span></span>) result.Add(byte1); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> d = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (byte2 + (b - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">0xBF</span></span>); result.Add(d); d = b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b &gt;= <span class="hljs-number"><span class="hljs-number">0xC0</span></span>) { d = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (b - <span class="hljs-number"><span class="hljs-number">0xC0</span></span> + <span class="hljs-number"><span class="hljs-number">0x80</span></span>); } result.Add(d); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Convert0000(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.Convert(Encoding.Unicode, Encoding.UTF8, array); } #endregion</code> </pre> </div></div><br><h1>  We dig up the essence </h1><br>  After all this, it was possible to precisely and correctly pull out all the localized text from the XLLEX.DLL file, but this method was completely unsuitable for the file with the descriptions of the functions and arguments of XLINTL32.DLL.  Here I had to start everything from the very beginning, but it was already easier. <br><br>  To begin with, in the XLINTL32.DLL file I tried to find something already familiar and similar to the data from the XLLEX.DLL file.  The familiar picture began at offset 0459h: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/07a/07f/c53/07a07fc53c034248bcc46c22b6f9ddbc.png"></div><br clear="all"><br>  Those.  since 04B1h there were block descriptions, the same as in the XLLEX.DLL file, but above this offset everything was somehow incomprehensible.  And not all the text from the resource obeyed the rules, which were derived from parsing the XLLEX.DLL file. <br><br>  It was decided later on those blocks that I have already learned to recognize are called blocks of the second type, and those that I do not know how yet are blocks of the first type, since  they went in the XLINTL32.DLL file above the blocks of the second type. <br><br>  The text of the first type blocks began almost immediately after the end of the second type block map, it remains to find where the first type block map is located in the file, and how to define a text delimiter in the first type blocks.  This block was selected for study: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/d2c/823/782/d2c823782e114b58a32df95110a19d9e.png"></div><br clear="all"><br>  It clearly shows the following lines: ‚ÄúCut, copy, and paste‚Äù, ‚ÄúPrint‚Äù, ‚ÄúFor charts‚Äù, etc.  In addition, a ‚Äúcharacteristic‚Äù ladder of zeros and increasing values ‚Äã‚Äãis visible in hex codes.  The first two values ‚Äã‚Äãin this ladder are 46h and 6Eh - the difference between them in the decimal form is 40, since  the text is explicitly set in Unicode LE, then the length ‚ÄúCut, copy, and paste‚Äù will be 20 * 2 = 40. Converges.  Check another pair of values: 78h-6Eh = 10/2 = 5 - exactly the length of ‚ÄúPrint‚Äù.  Let's rewrite beautifully all bytes from the 07BE66h offset to the beginning of the meaningful text: <br>  00 46000000 <br>  00 6E000000 <br>  00 78000000 <br>  ... <br>  FF E2020000 <br><br>  The total length of the resulting statement is 07BEABh - 07BE66h + 1 = 46h - somewhere it already was.  It turns out that the descriptions of the elements in the first type block look like this: 1 byte element type, 4 bytes - the offset of the element relative to the beginning of this block.  As it turned out later, the types of elements in the block of the first type are 00h - plain text in Unicode, 0Ah - some strange krakozyabry, FFh - the last element in this block. <br><br>  Now the last thing remains: deal with the resource header and find out how the offsets are determined for all blocks. <br><br>  To begin with, I remembered that the description of all blocks of the second type ends at offset 0A67h, and begins at offset 0459h, the total length of the description of blocks of the second type is 0A67h-0459h + 1 = 060Fh, and at address 0455h lies a four-byte number 060Bh: 060Bh + 4 = 060Fh .  It turns out that at the address 455h the length of the section describing the blocks of the second type is recorded. <br><br>  In order to understand how the displacements of blocks of the first type from the beginning of the resource are described, it was decided to compile for each block of the first type the offset table of the beginning of this block and its length. <br><br>  The first block of the first type begins where the descriptions of the blocks of the second type end - 0A68h. <table><tbody><tr><th>  Bias </th><th>  Length </th></tr><tr><td>  0A68h </td><td>  011Ah </td></tr><tr><td>  0B82h </td><td>  00CEh </td></tr><tr><td>  0C50h </td><td>  0148h </td></tr></tbody></table>  And between the beginning of the resource and the offset 0455h there were bytes, very reminiscent of the increasing sequence: <br><br clear="all"><div style="text-align:center;"><img src="https://habrastorage.org/files/fd8/ffd/079/fd8ffd079824424e98ba77e659715279.png"></div><br clear="all"><br>  Let's try to subtract from 01E8h (offset 25h) the number 011Ah (offset 21h): 01E8h-011Ah = CEh, just the length of the second block.  For fun: subtract 0330h (offset 29h) from 01E8h (offset 25h): 0330h-01E8 = 0148h, and 011Ah looks like the length of the first block.  It turns out that descriptions of offsets of blocks of the first type come from offset 1Dh.  They are recorded in the form of offsets of the beginning of the block from the end of the descriptions of the blocks of the second type (or the beginning of the section with the contents of the blocks - as convenient as possible).  It remains to understand that the bytes are between 04h and 1D.  If we subtract 1D (the beginning of the description of the displacements of the first type blocks) and 0455h (the offset for which the description length of the second type blocks is stored, that is, the descriptions of the first type blocks end): 0455h-1D = 0438h, such a number lies at the offset 19h.  What is located in the remaining twenty-one bytes between 04h and 19h is a mystery to me.  Yes, and really did not want to understand, because  in all office localization files this offset is the same. <br><br>  My program for reading localization files of Microsoft Office: <a href="https://yadi.sk/d/DvCTOdj6eAvDe">Link to Ya.Disk</a> <br><br>  UPD: 1/16/2016 <br>  It turned out that blocks of the first type are sometimes encoded with an additional dictionary, which is written to the very end of the file.  Apparently this is done to reduce the file size, because  A dictionary can contain many letters in one byte.  Actually, the link is now updated source code. <br><br><div class="spoiler">  <b class="spoiler_title">Short file structure specification</b> <div class="spoiler_text">  4 bytes - resource size <br>  21 bytes - not fame <br>  4 bytes - the number of blocks of type 1 * 4 = the number of bytes, which describes the map of blocks of type 1 <br>  * Begin of the description of the map of blocks of the first type * <br>  4 bytes - offset of type 1 block from the end of block description.  The difference between two adjacent values ‚Äã‚Äãis the length of a block of type 1. <br>  * The end of the description of the map of blocks of the first type * <br>  4 bytes - the number of bytes used to describe a block map of type 2 = number of blocks of type 2 * 17 bytes <br>  * Begin to describe the map of blocks of the second type * <br>  1 byte - block type <br>  2 bytes - the number of elements in the block 2 types <br>  4 bytes - I do not know.  In my opinion it is always 0, it can be reserved. <br>  2 bytes - the ordinal number of block 2 <br>  4 bytes - the length of the block of the second type <br>  4 bytes - offset of the second type block from the end of the block description <br>  * The end of the description of the map of blocks of the second type * <br>  4 bytes - data length for type 2 blocks <br>  * Blocks of the first type * <br>  1 byte - type of element - FD - this element is the last in this block, if 00 is plain text in Unicode, if 0A is xs. <br>  4 bytes - the offset of the element relative to the beginning of this block <br>  Further elements <br>  * End of blocks of the first type * <br>  * Blocks of the second type * <br>  1 byte - the first byte of the encoding <br>  1 byte - the second byte of the encoding <br>  2 bytes - the number of elements in the block <br>  * Map of elements of the block of the second type * <br>  2 bytes - offset relative to the beginning of the block elements.  Starts with the second element.  If the offset gets over the FFFF, then after the offset two more bytes are added = how many times the FFFF should be taken. <br>  * The end of the map of the elements of the block of the second type * <br>  * End of blocks of the second type * <br><br>  ******************** <br>  By encodings: <br>  Encoding is defined as: <br>  if the second byte == 0, then this is a simple Unicode Little Endian. <br>  if the second byte == 1, then the elements are encoded in UTF8 and the offset can be determined by the first byte. <br>  ******************** <br>  Blocks of the second type are several more types. <br>  2, 3, 4 - regular lines <br>  1 - it looks like a WordBasic table, at the beginning there is a table of some indexes (maybe indexes of WordBasic functions) <br></div></div><br><h1>  It is interesting </h1><br>  Among the names of Excel functions, there are those that are not described anywhere in the documentation, and you cannot use them in formulas.  Why are their names localized for me is still a mystery.  Here are some of these features: <ul><li>  GOTO (reference); </li><li>  HALT (cancel_close); </li><li>  ECHO (logical); </li><li>  WINDOWS (type_num, match_text); </li><li>  INPUT (message_text, type_num, title_text, default, x_pos, y_pos, help_ref); </li><li>  ADD.TOOLBAR (bar_name, tool_ref). </li></ul>  If anyone knows how to use them - write in the comments. <br><br><h1>  PS </h1><br>  During the long winter holidays I was even more boring, and I set out to determine how Excel calculates the height of the line based on the font.  After several dozen hours spent in OllyDbg and IDA, almost 2000 lines of C # code were generated, which give 100% line height match with Excel for all fonts, their sizes and parameters.  In addition, several interesting features of Excel internals were found, but this topic is already for a separate article. </div><p>Source: <a href="https://habr.com/ru/post/248597/">https://habr.com/ru/post/248597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248585/index.html">Simple container</a></li>
<li><a href="../248587/index.html">Reports for NORD POS. Part 2</a></li>
<li><a href="../248589/index.html">The first step on the path to daily planning, or where does the meat grinder?</a></li>
<li><a href="../248591/index.html">Using the DSP coprocessor DM8168 using the C6Accel framework</a></li>
<li><a href="../248593/index.html">Opensource lifeguard for cats, dogs and other animals in PHP</a></li>
<li><a href="../248599/index.html">"Durov, return the wall" or "Habrahabr + Geektimes + Megamind" in one tape</a></li>
<li><a href="../248601/index.html">Lovers of Ruby and Coffeescript - another bike?</a></li>
<li><a href="../248605/index.html">Piloting cloud-based MongoDB via VanillaJS or how to make a private todo list for 15 minutes for free</a></li>
<li><a href="../248607/index.html">Data-mining in 40 lines or with whom and against whom you are at the same time</a></li>
<li><a href="../248609/index.html">Announced Zend Framework 3 Roadmap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>