<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel programming using computational graph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are applications that are well implemented as a messaging system. Anything can be a message in a broad sense - data blocks, control "signals", e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel programming using computational graph</h1><div class="post__text post__text-html js-mediator-article">  There are applications that are well implemented as a messaging system.  Anything can be a message in a broad sense - data blocks, control "signals", etc.  The logic consists of the nodes that process messages, and the connections between them.  Such a structure is naturally represented by a graph, along the edges of which the messages processed in nodes ‚Äúflow‚Äù.  The most well-established name for such a model is a computational graph. <br><br>  With the help of a computational graph, it is possible to establish dependencies between tasks and, to some extent, programmatically implement the ‚Äúdataflow architecture‚Äù. <br><br>  In this post I will describe how to implement such a model in C ++ using the <a href="http://threadingbuildingblocks.org/">Intel Threading Building Blocks</a> library (Intel TBB), namely the class tbb :: flow :: graph. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/509/186/e56/509186e561e7563c4ec5f71709dda868.png"><br><a name="habracut"></a><br><h3>  What is Intel TBB and class tbb :: flow :: graph </h3><br>  Intel Threading Building Blocks is a C ++ template library for parallel programming.  It is distributed free of charge in an open source implementation, but there is also a commercial version.  Binary format is available for Windows *, Linux * and OS X *. <br><br>  In TBB there are many ready-made algorithms, structures and data structures that are ‚Äúsharpened‚Äù for use in parallel computing.  In particular, there are constructions that allow to implement the computational graph, which will be discussed. <br><br>  The graph, as is known, consists of vertices (nodes) and edges.  The computing graph tbb :: flow :: graph also consists of nodes (node), edges (edges) and an object of the entire graph. <br><br><img src="https://habrastorage.org/storage2/a47/4c1/957/a474c1957fba901b5c45dc3c2b4eea01.png"><br><br>  Nodes of the graph have interfaces of the sender and the recipient, control messages or perform some functions.  The edges connect the nodes of the graph and are the "channels" of message transfer. <br><br>  The body of each node is represented by the TBB task and can be executed in parallel with the others, if there are no dependencies between them.  In TBB, many parallel (or all) algorithms are built on tasks ‚Äî small work items (instructions) that are executed by worker threads.  There can be dependencies between tasks, they can be dynamically redistributed between threads.  Through the use of tasks, you can achieve optimal granularity and load balancing on the CPU, as well as build higher-level parallel constructions based on them - such as tbb :: flow :: graph. <br><br><h3>  The easiest dependency graph </h3><br>  A graph consisting of two vertices connected by one edge, one of which prints ‚ÄúHello‚Äù, and the second one ‚ÄúWorld‚Äù can be schematically represented as: <br><br><img src="https://habrastorage.org/storage2/56f/838/5c3/56f8385c373be4d654b947856f2e9aab.png"><br><br>  And in the code it will look like this: <br><br><pre><code class="hljs rust">#include &lt;iostream&gt; #include &lt;tbb/flow_graph.h&gt; int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *argv[]) { tbb::flow::graph g; tbb::flow::continue_node&lt; tbb::flow::continue_msg &gt; h( g, []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tbb::flow::continue_msg &amp; ) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello "</span></span>; } ); tbb::flow::continue_node&lt; tbb::flow::continue_msg &gt; w( g, []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tbb::flow::continue_msg &amp; ) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"World\n"</span></span>; } ); tbb::flow::make_edge( h, w ); h.try_put(tbb::flow::continue_msg()); g.wait_for_all(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Here an object of the graph g and two nodes of the type continue_node are created - h and w.  These nodes receive and transmit a message like continue_msg - internally control message.  They are used to build dependency graphs, when the node body is executed only after a message is received from its predecessor. <br><br>  Each of the continue_node executes some conditionally useful code ‚Äî the ‚ÄúHello‚Äù and ‚ÄúWorld‚Äù stamp.  Nodes are joined by an edge using the make_edge method.  Everything, the structure of the computational graph is ready - you can run it for execution by sending it a message using the try_put method.  Next, the graph works, and, to make sure that all its tasks are completed, we wait using the wait_for_all method. <br><br><h3>  Simple message passing graph </h3><br>  Imagine that our program should calculate the expression x <sup>2</sup> + x <sup>3</sup> for x from 1 to 10. Yes, this is not the most difficult computational task, but it is quite suitable for demonstration. <br><br>  Let's try to present the calculation of the expression in the form of a graph.  The first node will take the x values ‚Äã‚Äãfrom the incoming data stream and send it to the nodes that are cube and square.  The exponentiation operations are independent of each other and can be executed in parallel.  To smooth out possible imbalances, they transmit their result to the buffer nodes.  Next comes the unifying node that delivers the results of the exponentiation of the summing node, on which the calculation ends: <br><br><img src="http://habrastorage.org/storage2/329/669/9ca/3296699ca74a7a1ad5234a8df1193a63.jpg"><br><br>  Code of the graph: <br><br><pre> <code class="hljs vbscript">#include &lt;tbb/flow_graph.h&gt; #include &lt;windows.h&gt; using namespace tbb::flow; struct square { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> operator()(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> v) { printf(<span class="hljs-string"><span class="hljs-string">"squaring %d\n"</span></span>, v); Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); return v*v; } }; struct cube { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> operator()(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> v) { printf(<span class="hljs-string"><span class="hljs-string">"cubing %d\n"</span></span>, v); Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); return v*v*v; } }; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> sum { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> &amp;my_sum; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: sum( <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> &amp;s ) : my_sum(s) {} <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> operator()( std::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; v ) { printf(<span class="hljs-string"><span class="hljs-string">"adding %d and %d to %d\n"</span></span>, std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(v), std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(v), my_sum); my_sum += std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(v) + std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(v); return my_sum; } }; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> argc, char *argv[]) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; graph g; broadcast_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; input (g); function_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; squarer( g, unlimited, square() ); function_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; cuber( g, unlimited, cube() ); buffer_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; square_buffer(g); buffer_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; cube_buffer(g); join_node&lt; std::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt;, queueing &gt; <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(g); function_node&lt;std::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt;,<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; summer( g, serial, sum(result) ); make_edge( input, squarer ); make_edge( input, cuber ); make_edge( squarer, square_buffer ); make_edge( squarer, input_port&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>) ); make_edge( cuber, cube_buffer ); make_edge( cuber, input_port&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>) ); make_edge( <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>, summer ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) input.try_put(i); g.wait_for_all(); printf(<span class="hljs-string"><span class="hljs-string">"Final result is %d\n"</span></span>, result); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  The Sleep (1000) function has been added to visualize the process (example compiled on Windows, use equivalent calls on other platforms).  Then everything is like in the first example - we create nodes, combine them with edges and start them for execution.  The second parameter in function_node (unlimited or serial) determines how many instances of the node body can be executed in parallel.  A node of type join_node determines the readiness of input data / messages at each input, and when both are ready, it sends them to the next node in the form of std :: tuple. <br><br><h3>  Solving the problem of "dining philosophers" with tbb :: flow :: graph </h3><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25B4%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D1%2585_%25D1%2584%25D0%25B8%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BE%25D1%2584%25D0%25BE%25D0%25B2">From Wikipedia</a> : <br>  <i>The Problem of the Dining Philosophers is a classic example used in computer science to illustrate synchronization problems in the design of parallel algorithms and techniques for solving these problems.</i> <br><br>  In the task several philosophers sit at the table, and can either eat or think, but not at the same time.  In our version, philosophers eat noodles with chopsticks - to eat you need two sticks, but there is one for each: <br><br><img src="http://habrastorage.org/storage2/2b2/e01/e79/2b2e01e7962f0b28bcda9286de1f196a.png"><br><br>  In such a situation, a deadlock can occur (for example, if each philosopher grabs his wand, so synchronization of actions between diners is required). <br><br>  Let's try to present a table with philosophers in the form of tbb :: flow :: graph.  Each philosopher will be represented by two nodes: join_node for capturing rods and function_node for accomplishing the ‚Äúeat‚Äù and ‚Äúthink‚Äù tasks.  Place for the sticks on the table is implemented through queue_node.  In queue queue_node can be no more than one stick, and if it is there - it is available for capture.  The graph will look like this: <br><br><img src="http://habrastorage.org/storage2/c19/b01/829/c19b018297ef19759ae530b00409af62.png"><br><br>  The main function with some constants and header files: <br><br><pre> <code class="hljs mel">#include &lt;windows.h&gt; #include &lt;tbb/flow_graph.h&gt; #include &lt;tbb/task_scheduler_init.h&gt; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tbb::<span class="hljs-keyword"><span class="hljs-keyword">flow</span></span>; const char *names[] = { <span class="hljs-string"><span class="hljs-string">"Archimedes"</span></span>, <span class="hljs-string"><span class="hljs-string">"Aristotle"</span></span>, <span class="hljs-string"><span class="hljs-string">"Democritus"</span></span>, <span class="hljs-string"><span class="hljs-string">"Epicurus"</span></span>, <span class="hljs-string"><span class="hljs-string">"Euclid"</span></span>, <span class="hljs-string"><span class="hljs-string">"Heraclitus"</span></span>, <span class="hljs-string"><span class="hljs-string">"Plato"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pythagoras"</span></span>, <span class="hljs-string"><span class="hljs-string">"Socrates"</span></span>, <span class="hljs-string"><span class="hljs-string">"Thales"</span></span> }; ‚Ä¶. <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_threads = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_philosophers = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( argc &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) num_threads = atoi(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( argc &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ) num_philosophers = atoi(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( num_threads &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || num_philosophers &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || num_philosophers &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> ) exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); tbb::task_scheduler_init init(num_threads); graph g; printf(<span class="hljs-string"><span class="hljs-string">"\n%d philosophers with %d threads\n\n"</span></span>, num_philosophers, num_threads); std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt; queue_node&lt;chopstick&gt; * &gt; places; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_philosophers; ++i ) { queue_node&lt;chopstick&gt; *qn_ptr = new queue_node&lt;chopstick&gt;(g); qn_ptr-&gt;try_put(chopstick()); places.push_back( qn_ptr ); } std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt; philosopher &gt; philosophers; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_philosophers; ++i ) { philosophers.push_back( philosopher( names[i], g, places[i], places[(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)%num_philosophers] ) ); g.run( philosophers[i] ); } g.wait_for_all(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_philosophers; ++i ) philosophers[i].check(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  After processing the command line parameters, the library is initialized by creating an object of the type tbb :: task_scheduler_init.  This allows you to control the moment of initialization and manually set the number of handler threads.  Without this, initialization will take place automatically.  Next, create an object of the graph g.  The ‚Äúplace for the sticks‚Äù queue_node is placed in std :: vector, and in each queue is placed along the stick. <br><br>  Then philosophers are created in a similar way and placed in std :: vector.  The object of each philosopher is transferred to the run function of the graph object.  The class philosopher will contain operator (), and the run function allows you to execute this functor in a task that is a child of the root object of the graph object g.  So we can wait for the execution of these tasks during the call to g.wait_for_all (). <br><br>  Class philosopher: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> think_time = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eat_time = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_times = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chopstick</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">philosopher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> queue_node&lt; chopstick &gt; chopstick_buffer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> join_node&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;chopstick,chopstick&gt; &gt; join_type; philosopher( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name, graph &amp;the_graph, chopstick_buffer *left, chopstick_buffer *right ) : my_name(name), my_graph(&amp;the_graph), my_left_chopstick(left), my_right_chopstick(right), my_join(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> join_type(the_graph)), my_function_node(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), my_count(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(num_times)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *my_name; graph *my_graph; chopstick_buffer *my_left_chopstick; chopstick_buffer *my_right_chopstick; join_type *my_join; function_node&lt; join_type::output_type, continue_msg &gt; *my_function_node; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *my_count; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_body</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eat_and_think</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">think</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_my_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br>  Each philosopher has a name, pointers to the object of the graph and to the left and right sticks, the join_node node, the function_node function node and the my_count counter, counting how many times the philosopher thought and ate. <br><br>  operator () (), called by the graph's run function, is implemented so that the philosopher thinks first and then attaches himself to the graph. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> philosopher::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()() { think(); make_my_node(); }  think  eat    : <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> philosopher::think() { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s thinking\n"</span></span>, my_name ); Sleep(think_time); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s done thinking\n"</span></span>, my_name ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> philosopher::eat() { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s eating\n"</span></span>, my_name ); Sleep(eat_time); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s done eating\n"</span></span>, my_name ); }</code> </pre> <br>  The make_my_node method creates a functional node, and binds both it and join_node with the rest of the graph: <br><br><pre> <code class="hljs php">void philosopher::make_my_node() { my_left_chopstick-&gt;register_successor( input_port&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(*my_join) ); my_right_chopstick-&gt;register_successor( input_port&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(*my_join) ); my_function_node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> function_node&lt; join_type::output_type, continue_msg &gt;( *my_graph, serial, node_body( *this ) ); make_edge( *my_join, *my_function_node ); }</code> </pre> <br>  Note that the graph is created dynamically - the edge is formed using the register_successor method.  It is not necessary to first completely create the structure of the graph, and then launch it for execution.  In TBB, it is possible to change this structure on the fly, even when the graph is already running ‚Äî to remove and add new nodes.  This adds even more flexibility to the concept of a computational graph. <br><br>  The node_body class is a simple functor that calls the philosopher :: eat_and_think () method: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> node_body { philosopher &amp;my_philosopher; public: node_body( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">philosopher</span></span></span><span class="hljs-class"> &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> ) : my_philosopher(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) { } void operator()( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">philosopher</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">join_type</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">output_type</span></span></span><span class="hljs-class"> ) { my_philosopher.eat_and_think(); } };</span></span></code> </pre> <br>  The eat_and_think method calls the eat () function and decrements the counter.  Then the philosopher puts his wands on the table and thinks.  And if he has eaten and has thought the proper number of times, he gets up from the table - he breaks off his join_node connection with the graph by the remove_successor method.  Here again, the dynamic structure of the graph is visible - part of the nodes is removed while the rest continue to work. <br><br><pre> <code class="hljs php">void philosopher::eat_and_think( ) { eat(); --(*my_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*my_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { my_left_chopstick-&gt;try_put( chopstick() ); my_right_chopstick-&gt;try_put( chopstick() ); think(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { my_left_chopstick-&gt;remove_successor( input_port&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(*my_join) ); my_right_chopstick-&gt;remove_successor( input_port&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(*my_join) ); my_left_chopstick-&gt;try_put( chopstick() ); my_right_chopstick-&gt;try_put( chopstick() ); } }</code> </pre> <br>  In our graph there is an edge from queue_node (place for the wand) to the philosopher, or rather its join_node.  And in the opposite direction there is no.  However, the eat_and_think method can call try_put to put the wand back into the queue. <br><br>  At the end of the main () function, for each philosopher, the check method is called, which verifies that the philosopher has eaten and thought the correct number of times and does the necessary ‚Äúcleaning‚Äù: <br><br><pre> <code class="hljs perl">void philosopher::check() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *my_count != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"ERROR: philosopher %s still had to run %d more times\n"</span></span>, my_name, *my_count); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s done.\n"</span></span>, my_name); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> my_function_node; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> my_join; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> my_count; }</code> </pre> <br>  Deadlock in this example does not happen due to the use of join_node.  This type of node creates a std :: tuple from the objects received from both inputs.  In this case, the input data is not consumed immediately upon receipt.  join_node first waits for data to appear on both inputs, then tries to reserve them in turn.  If this operation is successful - only then they are ‚Äúconsumed‚Äù and std :: tuple is created from them.  If the reservation of at least one input ‚Äúchannel‚Äù did not work out - those that are already reserved are released.  Those.  if a philosopher can grab one wand, but the second is busy, he will let go of the first one and wait, without blocking the neighbors in vain. <br><br>  This example of the dining philosophers demonstrates several possibilities of the TBB graph: <br><ul><li>  Use join_node to synchronize access to resources </li><li>  Dynamic graphing - nodes can be added and removed during operation </li><li>  No single points of entry and exit, the graph may have loops </li><li>  Using the graph run function </li></ul><br><h3>  Types of nodes </h3><br>  tbb :: flow :: graph provides a fairly wide range of node options.  They can be divided into four groups: functional (functional), buffering, combining and dividing, and others.  List of node types with symbols: <br><br><img src="http://habrastorage.org/storage2/4a9/9b6/a51/4a99b6a5163b47bf19a56733396ebd32.png"><br><br><h3>  Conclusion </h3><br>  With the help of the graph implemented in Intel TBB, you can create complex and interesting logic of a parallel program, sometimes called "unstructured parallelism".  The computational graph allows you to organize dependencies between tasks, build applications based on the transfer of messages and events. <br><br>  The structure of the graph can be both static and dynamic - nodes and edges can be added and removed on the fly.  You can combine individual subgraphs in a large graph. <br><br>  Most of the material is based on the English publications of my overseas colleagues. <br><br>  For those interested, try: <br><br>  Download Intel Threading Building Blocks Library (Open Source Version): <br>  <a href="http://threadingbuildingblocks.org/">http://threadingbuildingblocks.org</a> <br><br>  Commercial version of Intel TBB (not functionally different): <br>  <a href="http://software.intel.com/en-us/intel-tbb">http://software.intel.com/en-us/intel-tbb</a> <br><br>  English blogs about tbb :: flow :: graph: <br>  <a href="http://software.intel.com/en-us/tags/17218">http://software.intel.com/en-us/tags/17218</a> <br>  <a href="http://software.intel.com/en-us/tags/17455">http://software.intel.com/en-us/tags/17455</a> </div><p>Source: <a href="https://habr.com/ru/post/157735/">https://habr.com/ru/post/157735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157725/index.html">Runetology (172): Mikhail Tokovinin, amoCRM project manager, co-founder of QSOFT</a></li>
<li><a href="../157727/index.html">Math can bring physical suffering</a></li>
<li><a href="../157729/index.html">Making TDD a habit: problems and implementation</a></li>
<li><a href="../157731/index.html">Imagine Cup 2013: Games Competition!</a></li>
<li><a href="../157733/index.html">A new type of wind generator produces electricity without blades.</a></li>
<li><a href="../157737/index.html">AOL comes out of the crisis and is rapidly gaining momentum</a></li>
<li><a href="../157739/index.html">"Poster": The History of the Russian Internet</a></li>
<li><a href="../157743/index.html">Prefix to the router (USB HUB + USB HDD + UPS)</a></li>
<li><a href="../157745/index.html">Updated Maps of Mars by Google</a></li>
<li><a href="../157747/index.html">Friday post good or how Samsung builds an online school of solar energy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>