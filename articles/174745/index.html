<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You can not just take and look at the background page</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The whole thing - in the security policy, similar to the cross-domain. The access to the pages of other tabs or to the background extension page is de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You can not just take and look at the background page</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/922/71c/b9c/92271cb9c8cd7a34f95a621f2fca53c9.jpg" align="right">  The whole thing - in the security policy, similar to the cross-domain.  The access to the pages of other tabs or to the background extension page is deliberately limited, because they are considered to be pages of other domains, they are not allowed to directly access the scripting environment, like other windows and frames.  The message mechanism ‚Äúsaves‚Äù as with cross-domain access between frames, as well as in access to extension pages (background, settings, popup, ...). <br><br>  In the browser extension, Google Chrome (and Chromium) is the most important in terms of functions - the background page.  It has a special URL of the form chrome-extension: // ciegcibjokpkcklhgbpnmnikpkmkhbjk /, where the long domain name is a random name created in the depths of the browser, which is also called the extension directory somewhere in the operating system folder.  From the content script (similar to userscripts executed on the browser page), you can access the files and images of the extension.  But you can not perform many functions, the path to which lies through the background page: arrange storage, belonging to the group of real domain names;  store extension settings common to the entire extension.  You just need to get <s>to Mordor</s> to the background page.  However, it is impossible to do this just by the URL. <br><a name="habracut"></a><br><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/4a0/62b/f65/4a062bf6537ea6c92d435be85f008f1d.png" align="left">  <i>This description is not on the pages of the documentation for Chrome.</i>  <i>Rather, it exists, but for ‚Äúa few other‚Äù methods and objects, which in fact means no, until corrected.</i>  <i>The behavior of the described messaging objects is confirmed by several examples in the responses to StackOverflow.</i>  <i>It‚Äôs tiring to search for answers each time with scattered examples, therefore, in order to put an end to this confusion, let them be gathered in one place here.</i>  <i>All 4 combinations of direct and callbacks are enumerated so that there are always working patterns before them.</i> <i><br><br></i>  <i>For testing and demonstration, you need to copy or create 3 files (manifest.json, script.js, background.js), create a test extension in developer mode in Chrome, and look at the messages in the 2-page console - the browser window with the embedded script. js and background (see background background.js console - by clicking on the link ‚ÄúCheck viewing modes: _generated_background_page.html‚Äù in chrome: // extensions /).</i>  <i>The same will work in some ready-made extension, if 2 fragments of the codes from the article are arranged in pages and executed.</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>On Habr√©, a similar problem was solved for practical purposes in <a href="http://habrahabr.ru/post/159145/">habrahabr.ru/post/159145</a> , November 2012 - the same sources of knowledge that were tacitly corrected and used.</i>  <i>On the Internet in Russian, a similar task was described in an <a href="http://comp-sandbox.ru/2012/06/28/obmen-soobshheniyami-mezhdu-veb-stranitse/">article</a> from June 2012. Here is described the mechanism that is used to solve such problems, given that it is performed in Google Chrome browser extension scripts.</i> </blockquote><br>  If the pages in windows and frames of the same domain are accessed directly (as the window of another scripting environment), the background page, as well as other tabs and browser pages, act as pages of foreign domains.  We can send messages to them, implementing the pattern of weakly connected procedures, and we can only transfer to them <i>objects that can be serialized</i> ‚Äî no DOM, environments, or other complex objects. <br><br>  To the background page is, because of what to strive for.  It performs functions that are unthinkable in a script or user script.  There - not only memory, common to all pages.  There is the implementation of many interfaces described on <a href="http://developer.chrome.com/extensions/api_index.html">developer.chrome.com/extensions/api_index.html</a> , and <a href="http://developer.chrome.com/extensions/experimental.html">more</a> is expected in the future.  In a scant messaging interface, there are callback functions that, when given, are executed in the calling function, on the side of their environment, but with a result parameter that the other side passed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/6c7/548/c886c75484eac6f2d5df15f1251ef8ec.png" align="left">  All this is a slightly modified interface of the Javascript environment <i>postMessage</i> , created not so long ago in browsers for solving problems of cross-domain access regulation.  It is usually used to communicate scripts between windows and frames and remains the only convenient means of communication if the page domains are different.  Previously, to solve this problem, a ‚Äúcrutch‚Äù under the code name <a href="http://learn.javascript.ru/ajax-iframe-xdomain">‚Äúwindow.name‚Äù was used</a> , using the keywords of the objects used.  It works now, but it is complex and, obviously, slow compared to the postMessage method that came to replace it.  Recall how the usual <a href="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">postMessage</a> mechanism works, because it is based on data exchange mechanisms in Chrome extension. <br><br><h3>  Interface postMessage (cross-browser, IE8 +) </h3><br>  The page initiating the message creates a custom event ‚Äúmessage‚Äù - makes sending a message, and it <b><u>does not from its own domain</u></b> , but from the one it wants to access.  (in IE8 there is a restriction - address only to the parent window of the frame). <br><pre><code class="javascript hljs">otherWindow.postMessage(message, targetOrigin); <span class="hljs-comment"><span class="hljs-comment">//message -    __  //targetOrigin -     otherWindow,  " "</span></span></code> </pre> <br>  If the domain name is guessed, the message will be sent.  To receive it, a couple of conditions must be met in the otherWindow window: <br>  1) there is an event handler; <br>  2) the handler ‚Äúwaits‚Äù for the message from the sending domain and checks this through the second argument. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if(event.origin !== 'URL_-') // , , 'http://example.org' return; ...// event.data,  message  .postMessage ...// event.source - -  ,  //       }, false);</span></span></code> </pre><br><br><h3>  Send a message from the window to the background page (Chrome) </h3><br>  In extensions, the basis (postMessage) was slightly reworked by adding callbacks and automating domain checks.  It has become more convenient than if to collect the transfer of the message from the bricks.  At the very end, we give the code on the standard postMessage, using the available tools to show that there is no magic in the following described <i>sendMessage</i> or <i>sendRequest</i> - this is just a wrapper.  But postMessage could not be executed due to insufficient extension rights to create a frame with a special protocol ‚Äúchrome-extension: // *‚Äù, about which the manifest file format also does not know anything <s>, and the matter sank in bureaucratic delays</s> .  This is the answer to the question of why they had to invent their own exchange functions. <br><br><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/86f/ee9/3b9/86fee93b9d6021428170992f5204732f.png" align="left">  These examples can be seen, checked and investigated their behavior from the <b>installation page of the Chrome extension</b> : <a href="http://spmbt.kodingen.com/bgMessageXmp/index.htm">spmbt.kodingen.com/bgMessageXmp/index.htm</a> .  If the extension is not installed, clicks on 5 links report the absence of the extension.  After installation (in the extension - only 3 required files) the clicks start to perform the examples described below. <br><br>  <i>How to install</i> : 1) download the archive, 2) unpack (or install immediately), 3) on chrome: // extensions / go into ‚Äúdeveloper mode‚Äù, 4) execute ‚ÄúLoad unpacked extension ...‚Äù by selecting a directory from the archive, 5) refresh the page from which the extension was loaded.  5 links are ready for examples.  After the execution, it is enough to remove the script using chrome: // extensions /.  <i>This sample script can be used as a framework for testing or writing extensions.</i>  <i>For this article, he helped debug scripts from the text and eliminate typos from them.</i> </blockquote><br>  <b>Example 1</b> <br>  If you need <b>to send from a tab to a background page</b> and finish there, a simple message format is used: <br><pre> <code class="javascript hljs"> chrome.extension.sendMessage(<span class="hljs-string"><span class="hljs-string">'   '</span></span>);</code> </pre><br>  A message is received in the background or any other page: <br><pre> <code class="javascript hljs">chrome.extension.onMessage.addListener(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(request==<span class="hljs-string"><span class="hljs-string">'   '</span></span>) <span class="hljs-comment"><span class="hljs-comment">//,        console.log('1. : ', request); });</span></span></code> </pre><br><br>  <b>Example 2</b> <br>  This pair of functions is adapted for exchanging a return message.  Add parameters from the script: <br><pre> <code class="javascript hljs">chrome.extension.sendMessage(<span class="hljs-string"><span class="hljs-string">' backMsg'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">backMessage</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'2.    :'</span></span>, backMessage); });</code> </pre><br>  from background page: <br><pre> <code class="javascript hljs">chrome.extension.onMessage.addListener(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, sender, f_callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(request==<span class="hljs-string"><span class="hljs-string">' backMsg'</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//,        console.log('2.   : ', request); f_callback('backMsg'); //  } });</span></span></code> </pre><br>  f_callback - executed <u>in a script</u> (not in the background page), but with the parameter specified in the background one. <br>  The sender object has the form: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> highlighted: <span class="hljs-literal"><span class="hljs-literal">true</span></span> id: <span class="hljs-number"><span class="hljs-number">34</span></span> <span class="hljs-comment"><span class="hljs-comment">//id  ()  incognito: false index: 0 pinned: false selected: true status: "complete" title: "HabrAjax by spmbt" //document.title url: "http://spmbt.kodingen.com/habrahabr/habrAjax/index.htm" //location.href windowId: 1 //id   }</span></span></code> </pre><br>  Thus, from it something is known about the one who sent the message.  Now we will not use the values ‚Äã‚Äãfrom sender, but it is possible to track from which tab or window a message came, send changes to other content scripts, if they are in other tabs. <br>  <i><b>(end of example 2)</b></i> <br><br>  If you need to transfer something more complicated - there is no problem to build a hash or an array instead of a string.  Passing a hash instead of a set of arguments - in general, a more advanced form of exchange - takes 1 argument, is easier to read, since it is self-documented with keys, hash values ‚Äã‚Äãare rearranged and deleted elementarily - there is no need to remember the order and worry about missing values. <br><br>  With the technique of replacing an argument with a hash, 3 arguments are enough for everything, and each of them performs its own role.  Going further, they could be replaced with 1 argument, with the keys {request: ..., sender: ..., callback: f () {...}};  why didn't you?  Apparently, they considered that 3 arguments are still such a gentleman's limit, which is not shameful to offer for memorization (and for further decoding).  In addition, symbols are spent on self-documentation.  When there are 2‚Äì3 arguments, the choice leans towards positional arguments. <br><br>  For example, you need to send not only the name of the command, but also a hash with the data.  We write from the script: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data =<span class="hljs-string"><span class="hljs-string">'From page '</span></span>; chrome.extension.sendMessage({<span class="hljs-attr"><span class="hljs-attr">cmd</span></span>:<span class="hljs-string"><span class="hljs-string">'exec1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:{<span class="hljs-attr"><span class="hljs-attr">data1</span></span>: data, <span class="hljs-attr"><span class="hljs-attr">dataX</span></span>: d+<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">backMessage</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">backMessage</span></span></span><span class="hljs-function">); }});</span></span></code> </pre><br>  from background page: <br><pre> <code class="javascript hljs">chrome.extension.onMessage.addListener(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, sender, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(request.cmd ==<span class="hljs-string"><span class="hljs-string">'exec1'</span></span>){ callback(<span class="hljs-string"><span class="hljs-string">'backMsg'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  console.log('Tis message in background page printed after' +' receive of data1 = ', request.h.data1, '; URL= ',sender.url); });</span></span></code> </pre><br>  Shorten frequent calls from content pages: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inBg = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cmd, h, f_back</span></span></span><span class="hljs-function">)</span></span>{ h.cmd = cmd; chrome.extension.sendMessage(h, f_back); }); ... inBg(<span class="hljs-string"><span class="hljs-string">'exec1'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">data1</span></span>: data, <span class="hljs-attr"><span class="hljs-attr">dataX</span></span>: d+<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... });</code> </pre><br><br>  <i>(For <i>some reason, there is</i> no third callback provided ... The management is transferred only 2 times.)</i> <br><br><h3>  We send the message from the background page to the window (Chrome) </h3><br>  <b>Example 3</b> <br>  If there is an <b>inverse task</b> , send a message from the background page to, say, the active tab: <br>  in the background we write: <br><pre> <code class="javascript hljs">chrome.tabs.getSelected(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tab</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     chrome.tabs.sendRequest(tab.id,{msg:"msg01"}); //   });</span></span></code> </pre><br>  in content: <br><pre> <code class="javascript hljs">chrome.extension.onRequest.addListener(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   background console.log('3.   :', req.msg); //   });</span></span></code> </pre><br>  Is it important that in the first case we used a pair of <b>sendMessage-onMessage</b> , and in the second - <b>sendRequest-onRequest</b> ?  No, any method works, as long as it is from the same pair. <br><br>  <b>Example 4</b> <br>  If you need to send a message with a reverse callback, in the background we write: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inBack = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tabId, cmd, h, f_back</span></span></span><span class="hljs-function">)</span></span>{ h.cmd = cmd; chrome.tabs.sendMessage(tabId, h, f_back); }; chrome.tabs.getSelected(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tab</span></span></span><span class="hljs-function">)</span></span>{ inBack(tab.id,<span class="hljs-string"><span class="hljs-string">'exec0'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">dat</span></span>:<span class="hljs-string"><span class="hljs-string">'h'</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">backMessage</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'4.    : '</span></span>, backMessage); }); });</code> </pre><br>  On the content page: <br><pre> <code class="javascript hljs">chrome.extension.onMessage.addListener(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, sender, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(request.cmd ==<span class="hljs-string"><span class="hljs-string">'exec0'</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// console.log('4.  :', request.dat); callback('12w3'); } });</span></span></code> </pre> <br><br>  It runs, as you can see - everything that was described in the documentation, but for a slightly different object (chrome.runtime), on <a href="http://developer.chrome.com/extensions/messaging.html">developer.chrome.com/extensions/messaging.html</a> , and chrome.runtime does not work in this task - it has no method sendMessage <br><br><h3>  Transfer to standard postMessage (failed) </h3><br>  Despite the negative result, this transfer attempt will tell you why the developers had to deal with their own data transfer functions in extensions, despite the presence of <i>postMessage</i> . <br><br>  One of the few special extension methods that is executable in the content script is <i>chrome.extension.getURL ('path')</i> .  It returns the path to the expansion resources.  Having opened it, we will receive expansion resources (but not to directories) - pictures and texts from it.  A different domain will play its role here too: in order to get the texts into the environment of the page script, you need to do Ajax cross-domain.  Or it is easier to do - get the texts through the domain wall message mechanism. <br><br>  <b>Example 5</b> <br>  Let's transfer the message using the defined protocol ("chrome-extension:") with the domain (something like "// ciegcibjokpkcklhgbpnmnikpkmkhbjk"). <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bgUrl = chrome.extension.getURL(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bgUrl); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br>  But not everything is simple.  There is no access to the background page for the content script.  The method is: <br><pre> <code class="javascript hljs">chrome.extension.getBackgroundPage();</code> </pre><br>  But there is no access: <br>  <font color="#cc6666">Uncaught Error: "getBackgroundPage" can only be used in extension processes.</font>  <font color="#cc6666">See the content scripts documentation for more details.</font> <br>  Commando is not discouraged.  For a simple exchange, you need to create a frame.  Nothing prevents to create a frame. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ifr = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'iframe'</span></span>); ifr.id =<span class="hljs-string"><span class="hljs-string">'ifr1'</span></span>; ifr.src = bgUrl; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(ifr);</code> </pre><br>  An error occurred: <br>  <font color="#cc6666">Denying load of <a href="http://chrome-extension//ciegcibjokpkcklhgbpnmnikpkmkhbjk/">chrome-extension: // ciegcibjokpkcklhgbpnmnikpkmkhbjk /</a> .</font>  <font color="#cc6666">Resources must be listed in the web_accessible_resources.</font> <br>  Add permission to the manifest (and with chrome.extension.sendMessage this was not needed). <br>  "Permissions": ["chrome-extension: // *", ...] <br>  An error occurred on chrome: // extensions /: <br>  <font color="#cc6699">At installation of the extension, warnings occurred:</font> <font color="#cc6699"><br></font>  <font color="#cc6699">Permission 'chrome-extension: //' is unknown or URL pattern is malformed.</font> <br>  If access was not denied, it would remain <br><pre> <code class="javascript hljs">ifr.postMessage(<span class="hljs-string"><span class="hljs-string">'Yep'</span></span>, bgUrl.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/$/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) );</code> </pre><br>  and in the background - <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'origin: '</span></span>, ev.origin); },!<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  This example can be completed - he showed that access through the regular function was closed for other reasons - because of the need to view background pages in frames, which, apparently, was unacceptable for security (in ‚Äúmanifest_version‚Äù: 2).  Therefore, in Chrome extensions, but also for reasons of syntax optimization and bidirectional communication, special messaging methods were invented. <br><br>  The example showed that there are no special tricks in sending messages to the background page.  But we need special permissions, which we do not have for extensions.  The closed part of the methods of the chrome.extension object does it calmly, but does not give it to others.  (You need to try to do it again via sandbox.html - whether it will allow you to create a frame with a background page in it.) <br><br>  <a href="http://spmbt.kodingen.com/bgMessageXmp/index.htm">On the installation of a test extension and a test page.</a> </div><p>Source: <a href="https://habr.com/ru/post/174745/">https://habr.com/ru/post/174745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174735/index.html">Automated integration testing of an ASP.NET application</a></li>
<li><a href="../174737/index.html">Ultra-high-speed optical communications set a new energy efficiency record</a></li>
<li><a href="../174739/index.html">Update KB2670838 causes problems in Firefox</a></li>
<li><a href="../174741/index.html">Rusmode - a solution to the problem with the Russian layout</a></li>
<li><a href="../174743/index.html">Installing applications with .EXE installers using GPO</a></li>
<li><a href="../174749/index.html">BOINC distributed computing is now available for Android devices.</a></li>
<li><a href="../174751/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ50 (March 23 - 29, 2013)</a></li>
<li><a href="../174765/index.html">Digital lenses from Intel & Mail.Ru Group - look at the world in a new way!</a></li>
<li><a href="../174769/index.html">Server on NetWare 3.12 with uptime of 16.5 years</a></li>
<li><a href="../174771/index.html">Do you pay by SMS?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>