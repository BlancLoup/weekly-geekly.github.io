<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Not a single spring boot: review alternatives</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently, there is no shortage of frameworks for creating microservices in Java and Kotlin. 

 The article discusses the following: 
 Title  Version ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Not a single spring boot: review alternatives</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/al/mw/1g/almw1ghoqrvuf2nbw_awcwqvqe4.png"><br><br>  Currently, there is no shortage of frameworks for creating microservices in Java and Kotlin. <br><br>  The article discusses the following: <br><div class="scrollable-table"><table><tbody><tr><th>  Title </th><th>  Version </th><th>  Year of first release </th><th>  Developer </th></tr><tr><td>  <a href="https://helidon.io/">Helidon SE</a> </td><td>  1.1.1 </td><td>  2019 </td><td>  Oracle </td></tr><tr><td>  <a href="https://ktor.io/">Ktor</a> </td><td>  1.2.1 </td><td>  2018 </td><td>  JetBrains </td></tr><tr><td>  <a href="https://micronaut.io/">Micronaut</a> </td><td>  1.1.3 </td><td>  2018 </td><td>  Object Computing </td></tr><tr><td>  <a href="https://spring.io/projects/spring-boot">Spring boot</a> </td><td>  2.1.5 </td><td>  2014 </td><td>  Pivotal </td></tr></tbody></table></div><a name="habracut"></a><br>  Based on them, four services have been created that can interact with each other using the HTTP API using the Service Discovery pattern implemented using <a href="https://www.consul.io/">Consul</a> .  Thus, they form a heterogeneous (at the level of frameworks) microservice architecture (hereafter referred to as ISA): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/tv/mv/kp/tvmvkpurtljgpl3yhxhtpmse4_g.png"><br><br>  Define a set of requirements for each service: <br><br><ul><li>  technology stack: <br><br><ul><li>  JDK 12; </li><li>  Kotlin; </li><li>  Gradle (Kotlin DSL); </li><li>  JUnit 5. </li></ul></li><li>  functionality (HTTP API): <br><br><ul><li><code>GET /application-info{?request-to=some-service-name}</code> <br>  Returns some basic information about microservice (name, framework, year of release of the framework);  when specifying the name of one of the four microservices in the <code>request-to</code> parameter to its HTTP API, a similar request is executed that returns basic information; </li><li> <code>GET /application-info/logo</code> <br>  Returns an image. </li></ul></li><li>  implementation: <br><br><ul><li>  configuration using the configuration file; </li><li>  use dependency injection; </li><li>  tests that test the HTTP API. </li></ul></li><li>  MSA: <br><br><ul><li>  using the Service Discovery pattern (registration with Consul, accessing the HTTP API of another microservice by its name using client load balancing); </li><li>  uber-jar artifact formation. </li></ul></li></ul><br>  Next, we consider the implementation of microservice on each of the frameworks and compare the parameters of the resulting applications. <br><br><h3>  Helidon service </h3><br>  The development framework was created in Oracle for internal use, subsequently becoming open-source.  There are two development models based on this framework: Standard Edition (SE) and MicroProfile (MP).  In both cases, the service will be a regular Java SE program.  Learn more about the differences on <a href="https://github.com/oracle/helidon/wiki/FAQ">this</a> page. <br><br>  In short, Helidon MP is one of the implementations of Eclipse <a href="https://microprofile.io/">MicroProfile</a> , which makes it possible to use multiple APIs, as previously known to Java EE developers (for example, JAX-RS, CDI), and newer ones (Health Check, Metrics, Fault Tolerance etc.).  In the variant Helidon SE, the developers were guided by the principle of ‚ÄúNo magic‚Äù, which is expressed, in particular, in the smaller number or complete absence of annotations necessary to create the application. <br><br>  Helidon SE is selected for microservice development.  Among other things, it lacks the means to implement Dependency Injection, so <a href="https://insert-koin.io/">Koin was</a> used to implement dependencies.  The following is the class containing the main method.  To implement Dependency Injection, the class is inherited from <i>KoinComponent</i> .  First, Koin starts, then the required dependencies are initialized and the <code>startServer()</code> method is called, where an object of the <i>WebServer</i> type is created, to which the application configuration and routing setup are passed;  after start the application is registered in Consul: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> HelidonServiceApplication : KoinComponent { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.currentTimeMillis() startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoProperties: ApplicationInfoProperties <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = applicationInfoProperties.name startServer(applicationInfoService, consulClient, serviceName, startTime) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">, consulClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Consul</span></span></span></span><span class="hljs-function"><span class="hljs-params">, serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, startTime: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: WebServer { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serverConfig = ServerConfiguration.create(Config.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"webserver"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server: WebServer = WebServer .builder(createRouting(applicationInfoService)) .config(serverConfig) .build() server.start().thenAccept { ws -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> durationInMillis = System.currentTimeMillis() - startTime log.info(<span class="hljs-string"><span class="hljs-string">"Startup completed in </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$durationInMillis</span></span></span><span class="hljs-string"> ms. Service running at: http://localhost:"</span></span> + ws.port()) <span class="hljs-comment"><span class="hljs-comment">// register in Consul consulClient.agentClient().register(createConsulRegistration(serviceName, ws.port())) } return server }</span></span></code> </pre> <br>  Routing is configured as follows: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Routing.builder() .register(JacksonSupport.create()) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info"</span></span>, Handler { req, res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = req.queryParams() .first(<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>) .orElse(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) }) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info/logo"</span></span>, Handler { req, res -&gt; res.headers().contentType(MediaType.create(<span class="hljs-string"><span class="hljs-string">"image"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>)) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.getLogo()) }) .error(Exception::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span></span>{ req, res, ex -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Exception:"</span></span>, ex) res.status(Http.Status.INTERNAL_SERVER_ERROR_500).send() } .build()</code> </pre> <br>  The application uses the config in <a href="https://en.wikipedia.org/wiki/HOCON"><u>HOCON</u></a> format: <br><br><pre> <code class="json hljs">webserver { port: <span class="hljs-number"><span class="hljs-number">8081</span></span> } application-info { name: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2019</span></span> } }</code> </pre> <br>  For configuration, it is also possible to use files in the formats JSON, YAML and properties (more <a href="https://helidon.io/docs/latest/">here</a> ). <br><br><h3>  Ktor service </h3><br>  The framework is written in Kotlin.  A new project can be created in several ways: using the build system, <a href="https://start.ktor.io/">start.ktor.io</a> or the plug-in to IntelliJ IDEA (more <a href="https://ktor.io/quickstart/">here</a> ). <br><br>  As in Helidon SE, Ktor is missing the DI ‚Äúout of the box‚Äù, so before starting the server using Koin, dependencies are introduced: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> koinModule = module { single { ApplicationInfoService(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { ApplicationInfoProperties() } single { MicronautServiceClient(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { Consul.builder().withUrl(<span class="hljs-string"><span class="hljs-string">"http://localhost:8500"</span></span>).build() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server = embeddedServer(Netty, commandLineEnvironment(args)) server.start(wait = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br>  The modules necessary for the application are specified in the configuration file (only the HOCON format is possible; for more information on configuring the Ktor server <a href="https://ktor.io/servers/configuration.html">here</a> ), the contents of which are presented below: <br><br><pre> <code class="kotlin hljs">ktor { deployment { host = localhost port = <span class="hljs-number"><span class="hljs-number">8082</span></span> watch = [io.heterogeneousmicroservices.ktorservice] } application { modules = [io.heterogeneousmicroservices.ktorservice.module.KtorServiceApplicationModuleKt.module] } } application-info { name: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span> }</code> </pre> <br>  In Ktor and Koin, the term ‚Äúmodule‚Äù is used, with different meanings.  In Koin, a module is an analogue of the application context in the Spring Framework.  The Ktor module is a user-defined function that accepts an object of type <i>Application</i> and can configure pipeline, set features ( <i>features</i> ), register routes, process <br>  requests and so on: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Application.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isTest()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() registerInConsul(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).name, consulClient) } install(DefaultHeaders) install(Compression) install(CallLogging) install(ContentNegotiation) { jackson {} } routing { route(<span class="hljs-string"><span class="hljs-string">"application-info"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = call.parameters[<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>] call.respond(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) } static { resource(<span class="hljs-string"><span class="hljs-string">"/logo"</span></span>, <span class="hljs-string"><span class="hljs-string">"logo.png"</span></span>) } } } }</code> </pre> <br>  This code snippet configures the routing of requests, in particular, the static resource <code>logo.png</code> .  Ktor-service may contain features.  A feature is a functionality that is embedded in the request-response <i>pipeline</i> ( <i>DefaultHeaders, Compression,</i> and others in the example code above).  You can implement your own features, for example, below is the code implementing the Service Discovery pattern in combination with client load balancing based on the Round-robin algorithm: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsulFeature</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consulClient: Consul } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Feature : HttpClientFeature&lt;Config, ConsulFeature&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceInstanceIndex: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = AttributeKey&lt;ConsulFeature&gt;(<span class="hljs-string"><span class="hljs-string">"ConsulFeature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = ConsulFeature(Config().apply(block).consulClient) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(feature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ConsulFeature</span></span></span></span><span class="hljs-function"><span class="hljs-params">, scope: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { scope.requestPipeline.intercept(HttpRequestPipeline.Render) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = context.url.host <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceInstances = feature.consulClient.healthClient().getHealthyServiceInstances(serviceName).response <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedInstance = serviceInstances[serviceInstanceIndex] context.url.apply { host = selectedInstance.service.address port = selectedInstance.service.port } serviceInstanceIndex = (serviceInstanceIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) % serviceInstances.size } } } }</code> </pre> <br>  The main logic is in the <code>install</code> method: during the <i>Render</i> request phase (which runs before the <i>Send</i> phase), the name of the called service is first determined, then the <code>consulClient</code> queried for a list of instances of this service, after which the instance defined using the Round-robin algorithm is called.  Thus, the following call becomes possible: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getApplicationInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ApplicationInfo = runBlocking { httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;ApplicationInfo&gt;(<span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$serviceName</span></span></span><span class="hljs-string">/application-info"</span></span>) }</code> </pre> <br><h3>  Micronaut service </h3><br>  Micronaut is developed by the creators of the <a href="https://grails.org/">Grails</a> framework and is inspired by the experience of building services using Spring, Spring Boot and Grails.  The framework is a polyglot, supporting the languages ‚Äã‚Äãof Java, Kotlin and Groovy;  <a href="https://github.com/micronaut-projects/micronaut-core/issues/675">may</a> be Scala support.  Dependencies are introduced at compile time, which results in less memory consumption and faster application launch compared to Spring Boot. <br><br>  The main class has the following form: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MicronautServiceApplication { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { Micronaut.build() .packages(<span class="hljs-string"><span class="hljs-string">"io.heterogeneousmicroservices.micronautservice"</span></span>) .mainClass(MicronautServiceApplication.javaClass) .start() } }</code> </pre> <br>  Some components of the application based on Micronaut are similar to their counterparts in the application on Spring Boot, for example, below is the controller code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller( value = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/application-info"</span></span></span><span class="hljs-meta">, consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON] )</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@Get</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">, produces = [MediaType.IMAGE_PNG])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Kotlin support in Micronaut is based on the <a href="https://kotlinlang.org/docs/reference/kapt.html">kapt</a> compiler <a href="https://kotlinlang.org/docs/reference/kapt.html">plugin</a> (more <a href="https://docs.micronaut.io/latest/guide/index.html">here</a> ).  The assembly script is configured as follows: <br><br><pre> <code class="kotlin hljs">plugins { ... kotlin(<span class="hljs-string"><span class="hljs-string">"kapt"</span></span>) ... } dependencies { kapt(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... kaptTest(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... }</code> </pre> <br>  The following shows the contents of the configuration file: <br><br><pre> <code class="json hljs">micronaut: application: name: micronaut-service server: port: <span class="hljs-number"><span class="hljs-number">8083</span></span> consul: client: registration: enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> application-info: name: ${micronaut.application.name} framework: name: Micronaut release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre> <br>  Configuring microservice is also possible with JSON, properties and Groovy file formats (more details <a href="https://docs.micronaut.io/latest/guide/index.html">here</a> ). <br><br><h3>  Spring Boot service </h3><br>  The framework was created to simplify the development of applications using the Spring Framework ecosystem.  This is achieved through auto-configuration mechanisms when libraries are connected.  Below is the controller code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"application-info"</span></span></span><span class="hljs-meta">], produces = [MediaType.APPLICATION_JSON_UTF8_VALUE])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"request-to"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@GetMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">], produces = [MediaType.IMAGE_PNG_VALUE])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Microservice is configured with a YAML format file: <br><br><pre> <code class="json hljs">spring: application: name: spring-boot-service server: port: <span class="hljs-number"><span class="hljs-number">8084</span></span> application-info: name: ${spring.application.name} framework: name: Spring Boot release-year: <span class="hljs-number"><span class="hljs-number">2014</span></span></code> </pre> <br>  It is also possible to use properties files for configuration (more <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">here</a> ). <br><br><h3>  Launch </h3><br>  The project runs on JDK 12, although, probably, on the 11th version, too, you only need to change the <code>jvmTarget</code> parameter in the <code>jvmTarget</code> scripts: <br><br><pre> <code class="kotlin hljs">withType&lt;KotlinCompile&gt; { kotlinOptions { jvmTarget = <span class="hljs-string"><span class="hljs-string">"12"</span></span> ... } }</code> </pre> <br>  Before launching microservices, you need to <a href="https://www.consul.io/docs/install/index.html">install</a> Consul and <a href="https://learn.hashicorp.com/consul/getting-started/agent">start</a> an agent - for example, like this: <code>consul agent -dev</code> . <br><br>  Microservice launch is possible from: <br><br><ul><li>  IDE <br>  IntelliJ IDEA users can see something like the following: <br><img src="https://habrastorage.org/webt/n3/u_/hy/n3u_hy7_z5ut65ryaetvsw2znci.png"><br></li><li>  console <br>  To do this, go to the project folder and execute: <br><br><pre> <code class="plaintext hljs">java -jar helidon-service/build/libs/helidon-service-all.jar java -jar ktor-service/build/libs/ktor-service-all.jar java -jar micronaut-service/build/libs/micronaut-service-all.jar java -jar spring-boot-service/build/libs/spring-boot-service.jar</code> </pre> <br></li></ul><br>  After starting all microservices on <code>http://localhost:8500/ui/dc1/services</code> you will see: <br><br><img src="https://habrastorage.org/webt/qi/lm/bv/qilmbv1op4a6xgy6b31tnsfjpmm.png"><br><br><h3>  API Testing </h3><br>  As an example, the results of testing the Helidon service API are given: <br><br><ol><li> <code>GET http://localhost:8081/application-info</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info?request-to=ktor-service</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2018</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info/logo</code> <br> <br>  Returns an image. </li></ol><br>  You can test an arbitrary microservice API using <a href="https://www.getpostman.com/">Postman</a> ( <a href="">collection of</a> requests), IntelliJ IDEA <a href="http-client-in-product-code-editor.html">HTTP client</a> ( <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/http-request.">collection of</a> requests), browser or another tool.  In the case of using the first two clients, you must specify the port of the called microservice in the corresponding variable (in Postman it is in the <i>menu of the collection -&gt; Edit -&gt; Variables</i> , and in the HTTP Client - in the environment variable specified in <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/">this</a> file), and when testing method 2) The API also needs to specify the name of the microservice requested ‚Äúunder the hood‚Äù.  The answers will be similar to those given above. <br><br><h3>  Comparison of application parameters </h3><br>  <b><i>Artifact size</i></b> <br>  In order to preserve the simplicity of setting up and launching applications in assembly scripts, no transitive dependencies were excluded, therefore the size of the Spring Boot uber-JAR service significantly exceeds the size of its counterparts in other frameworks (because when using starters, not only the necessary dependencies are imported; if desired, the size can be significantly reduced): <br><div class="scrollable-table"><table><tbody><tr><th>  Microservice </th><th>  Artifact size, MB </th></tr><tr><td>  Helidon service </td><td align="right">  16.6 </td></tr><tr><td>  Ktor service </td><td align="right">  20.9 </td></tr><tr><td>  Micronaut service </td><td align="right">  16.5 </td></tr><tr><td>  Spring Boot service </td><td align="right">  42.7 </td></tr></tbody></table></div><br>  <b><i>Start time</i></b> <br>  The launch time of each application is intermittent and falls into a certain ‚Äúwindow‚Äù;  The table below shows the start time of the artifact without any additional parameters: <br><div class="scrollable-table"><table><tbody><tr><th>  Microservice </th><th>  Start time, seconds </th></tr><tr><td>  Helidon service </td><td align="right">  2.2 </td></tr><tr><td>  Ktor service </td><td align="right">  1.4 </td></tr><tr><td>  Micronaut service </td><td align="right">  4.0 </td></tr><tr><td>  Spring Boot service </td><td align="right">  10.2 </td></tr></tbody></table></div><br>  It is worth noting that if you ‚Äúclean‚Äù an application on Spring Boot from unnecessary dependencies and pay attention to setting up the application launch (for example, scan only the necessary packages and use lazy initialization of bins), you can significantly reduce the launch time. <br><br>  <b><i>Stress Testing</i></b> <br>  <a href="https://gatling.io/">Gatling</a> and Scala <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/load_testing/load-test.scala">script</a> were used for testing.  The load generator and the service being tested were run on the same machine (Windows 10, 3.2 GHz quad-core processor, 24 GB RAM, SSD).  The port of this service is specified in the Scala script. <br><br>  For each microservice is determined: <br><br><ul><li>  the minimum amount of heap memory ( <code>-Xmx</code> ) required to run a healthy (responding to) microservice </li><li>  the minimum amount of heap memory required to pass the load test 50 users * 1000 requests </li><li>  the minimum amount of heap memory required to pass the load test 500 users * 1000 requests </li></ul><br>  Under the passage of the load test is understood that the microservice answered all requests for any time. <br><div class="scrollable-table"><table><tbody><tr><th rowspan="2">  Microservice </th><th colspan="3">  The minimum amount of heap-memory, MB </th></tr><tr><th>  To start the service </th><th>  For load <br>  50 * 1000 </th><th>  For load <br>  500 * 1000 </th></tr><tr><td>  Helidon service </td><td align="right">  9 </td><td align="right">  9 </td><td align="right">  eleven </td></tr><tr><td>  Ktor service </td><td align="right">  eleven </td><td align="right">  eleven </td><td align="right">  13 </td></tr><tr><td>  Micronaut service </td><td align="right">  13 </td><td align="right">  13 </td><td align="right">  17 </td></tr><tr><td>  Spring Boot service </td><td align="right">  22 </td><td align="right">  23 </td><td align="right">  25 </td></tr></tbody></table></div><br>  It is worth noting that all microservices use the HTTP server Netty. <br><br><h3>  Conclusion </h3><br>  The task was to create a simple service with the HTTP API and the ability to function in ISA - it was possible to perform on all the frameworks under consideration.  It's time to take stock and consider their pros and cons. <br><br>  <b><i>Helidoun</i></b> <br><br>  <font color="#808080">Standard Edition</font> <br><ul><li>  pros <br><ul><li>  application settings <br>  By all measures showed good results; </li><li>  ‚ÄúNo magic‚Äù <br>  The framework justified the principle stated by the developers: to create an application, only one abstract was required ( <code>@JvmStatic</code> - for the Java-Kotlin interop). </li></ul></li><li>  minuses <br><ul><li>  micromimography <br>  Some components necessary for industrial development are missing out of the box, for example, dependency injection and Service Discovery implementation. </li></ul></li></ul><br>  <font color="#808080">Microprofile</font> <br>  Microservice was not implemented on this framework, so I‚Äôll note only a couple of points I know: <br><br><ul><li>  pros <br><ul><li>  implementation of Eclipse MicroProfile <br>  In essence, MicroProfile is Java EE optimized for ISA.  Thus, firstly, you get access to the whole variety of Java EE API, including that developed specifically for ISA, secondly, you can change the implementation of MicroProfile to any other (Open Liberty, WildFly Swarm, etc.) . </li></ul></li><li>  additionally <br><ul><li>  on <a href="https://start.microprofile.io/">MicroProfile Starter</a> you can create from scratch a project with the necessary parameters by analogy with similar tools for other frameworks (for example, <a href="https://start.spring.io/">Spring Initializr</a> ).  At the time of publication of the article Helidon implements MicroProfile 1.2, whereas the latest version of the specification is 3.0. </li></ul></li></ul><br>  <b><i>Ktor</i></b> <br><br><ul><li>  pros <br><ul><li>  lightness <br>  Allows you to connect only those functions that are directly needed to perform the task; </li><li>  application settings <br>  Good results in all respects. </li></ul></li><li>  minuses <br><ul><li>  ‚ÄúSharpened‚Äù under Kotlin, that is, develop in Java, it seems, is possible, but not necessary; </li><li>  microframework (see similar item for Helidon SE). </li></ul></li><li>  additionally <br>  On the one hand, the framework development concept is not part of the two most popular Java development models (Spring-like (Spring Boot / Micronaut) and Java EE / MicroProfile), which can lead to: <br><br><ul><li>  problem finding specialists; </li><li>  Increased time to complete tasks compared to Spring Boot due to the need to explicitly configure the required functionality. </li></ul><br>  On the other hand, dissimilarity to ‚Äúclassic‚Äù Spring and Java EE allows you to look at the development process from a different angle, perhaps more consciously. </li></ul><br>  <b><i>Micronaut</i></b> <br><br><ul><li>  pros <br><ul><li>  Aot <br>  As previously noted, the AOT allows you to reduce the start time and memory consumed by the application compared to its counterpart on the Spring Boot; </li><li>  Spring-like development model <br>  Programmers with Spring development experience will not take long to master this framework; </li><li>  application settings <br>  Good results for all parameters; </li><li>  polyglot <br>  Support at the first-class level citizen languages ‚Äã‚ÄãJava, Kotlin, Groovy;  may be Scala support.  In my opinion, this can positively affect the growth of the community.  By the way, in June 2019 Groovy ranks 14th in the <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a> programming language popularity rating, soaring from the 60th a year earlier, thus being in the honorable second place among the JVM-languages; </li><li>  The <a href="https://micronaut-projects.github.io/micronaut-spring/latest/guide/index.html">Micronaut for Spring</a> project allows, among other things, changing the execution environment of an existing Spring Boot application to Micronaut (with restrictions). </li></ul></li></ul><br>  <b><i>Spring boot</i></b> <br><br><ul><li>  pros <br><ul><li>  platform maturity and ecosystem <br>  The ‚Äúevery day‚Äù framework.  For most everyday tasks, there is already a solution in the programming paradigm of Spring, that is, in the way that many programmers are used to.  The development is simplified by the concepts of starters and auto configurations; </li><li>  the presence of a large number of specialists in the labor market, as well as a significant knowledge base (including documentation and answers to Stack Overflow); </li><li>  perspective <br>  I think many will agree that in the near future, Spring will remain the leading development framework. </li></ul></li><li>  minuses <br><ul><li>  application settings <br>  The application on this framework was not among the leaders, however, some parameters, as noted earlier, can be optimized independently.  It is also worth recalling the presence of the <a href="https://github.com/spring-projects/spring-fu">Spring Fu</a> project in active development, the use of which makes it possible to reduce these parameters. </li></ul></li></ul><br>  You can also highlight common problems associated with new frameworks that Spring Boot lacks: <br><br><ul><li>  less developed ecosystem; </li><li>  a small number of specialists with experience with these technologies; </li><li>  more time to complete tasks; </li><li>  unclear perspectives. </li></ul><br>  The frameworks considered belong to different weight categories: Helidon SE and Ktor are <a href="https://en.wikipedia.org/wiki/Microframework">microframes</a> , Spring Boot is a full-stack framework, Micronaut, rather, also full-stack;  another category is MicroProfile (for example, Helidon MP).  Microfrim functionality is limited, which can slow down the execution of tasks;  To clarify the possibility of implementing a particular functionality based on a development framework, I recommend that you familiarize yourself with its documentation. <br><br>  I don‚Äôt dare to judge whether this or that framework will ‚Äúshoot‚Äù in the near future, so in my opinion, for now, it‚Äôs best to continue to monitor developments using the existing development framework for solving work tasks. <br><br>  At the same time, as was shown in the article, new frameworks win Spring Boot on the considered parameters of the received applications.  If any of these parameters are critically important for one of your microservices, then perhaps you should pay attention to the frameworks that showed the best results.  However, we should not forget that Spring Boot, firstly, continues to improve, and secondly, it has a huge ecosystem and a significant number of Java programmers are familiar with it.  There are other frameworks that are not covered in this article: Javalin, Quarkus, etc. <br><br>  You can view the project code on <a href="https://github.com/rkudryashov/heterogeneous-microservices">GitHub</a> .  Thank you for attention! <br><br>  PS: Thank you <a href="https://habr.com/ru/users/artglorin/" class="user_link">artglorin</a> for help in preparing the article. </div><p>Source: <a href="https://habr.com/ru/post/456376/">https://habr.com/ru/post/456376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456366/index.html">How I was creating the LED HEART box</a></li>
<li><a href="../456368/index.html">Perform public and private transactions on the JPMorgan Quorum blockchain using Web3</a></li>
<li><a href="../456370/index.html">QoS implementation in Qsan storage</a></li>
<li><a href="../456372/index.html">SimbirSoft invites IT-specialists to the Summer Intensive-2019</a></li>
<li><a href="../456374/index.html">Plasma Cash blockchain status data structures</a></li>
<li><a href="../456380/index.html">Open Day at the Faculty of Programming in Netology</a></li>
<li><a href="../456382/index.html">Collaboration and automation in the frontend. What we have learned for 13 schools</a></li>
<li><a href="../456386/index.html">Open libraries for visualizing audio content</a></li>
<li><a href="../456388/index.html">Diagram of the development of diagnostic capabilities in PVS-Studio</a></li>
<li><a href="../45639/index.html">jsForms: update test system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>