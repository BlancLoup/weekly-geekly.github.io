<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book ‚ÄúPerfect Algorithm. Graph Algorithms and Data Structures "</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, habrozhiteli! Algorithms are the heart and soul of computer science. You can‚Äôt do without them, they are everywhere - from network routing and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book ‚ÄúPerfect Algorithm. Graph Algorithms and Data Structures "</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/piter/blog/461039/"><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="image"></a>  Hello, habrozhiteli!  Algorithms are the heart and soul of computer science.  You can‚Äôt do without them, they are everywhere - from network routing and genomics calculations to cryptography and machine learning.  The ‚ÄúPerfect Algorithm‚Äù will turn you into a real pro who will set tasks and masterfully solve them both in life and at an interview when hiring any IT company. <br><br>  In the second book, Tim Rafgarden, an algorithm guru, talks about graph search and its application, the shortest path search algorithm, and the use and implementation of some data structures: heaps, search trees, hash tables, and the Bloom filter. <br><br>  This post presents an excerpt from Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  What is this book about </h3><br>  The second part of the book ‚ÄúThe Perfect Algorithm‚Äù is an introductory course on the basics of literacy on the following three topics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Graph search and applications</b> .  Graphs model a number of different types of networks, including road, communication, social networks and networks of dependencies between tasks.  Graphs can be complex, but there are some incredibly fast primitives to talk about graph structure.  We'll start with linear-time graph search algorithms, from applications ranging from network analysis to building a sequence of operations. <br><br>  <b>The shortest paths</b> .  In the shortest path problem, the goal is to calculate the best route in the network from point A to point B. This task has obvious applications, such as calculating traffic routes, and also occurs in disguised form in many other universal tasks.  We will generalize one of our graph search algorithms and come to the famous Dijkstra shortest path search algorithm. <br><br>  <b>Data structures</b> .  This book will make you a highly educated user of several different data structures designed to support an evolving set of objects with their associated keys.  The main goal is to develop an intuition about which data structure is right for your application.  Additional sections provide guidelines for implementing these data structures from scratch. <br><br>  First, we discuss heaps that can quickly identify a stored object with the smallest key, and are also useful for sorting, implementing a priority queue, and implementing Dijkstra's almost linear-temporal algorithm.  Search trees maintain the complete ordering of keys on stored objects and support an even wider range of operations.  Hash tables are optimized for ultrafast search operations and are widespread in modern programs.  We also look at the Bloom filter, a close relative of the hash table, which uses less space due to random errors. <br><br>  You can familiarize yourself with the contents of the book in more detail in the ‚ÄúConclusions‚Äù sections, which complete each chapter and identify the most important points.  Sections of the book, marked with an asterisk, are the most advanced in terms of the level of information presented.  If the book is designed for a superficial familiarization with the topic, then the reader can skip them without losing the integrity of the written. <br><br>  <b>Topics covered in three other parts</b> .  The first part of the book ‚ÄúPerfect Algorithm.  Fundamentals ‚Äùcovers asymptotic notations (the O-large and its close relatives notation),‚Äú divide and conquer ‚Äùalgorithms and the main recurrence relation theorem ‚Äî the main method, randomized quick sorting and its analysis, and linear-temporal selection algorithms.  The third part deals with greedy algorithms (planning, minimal spanning trees, clustering, Huffman codes) and dynamic programming (backpack problem, sequence alignment, shortest paths, optimal search trees).  The fourth part is devoted to NP-completeness, what it means for an algorithm designer, and strategies for solving computationally insoluble problems, including heuristic analysis and local search. <br><br><h3>  12.5.  Bloom Filters: The Basics </h3><br>  Bloom filters are close relatives of hash tables.  They are very compact, but instead periodically make mistakes.  This section describes how Bloom filters are good and how they are implemented, while section 12.6 sets out a compromise curve between the amount of space used by the filter and its error rate. <br><br><h3>  12.5.1.  Supported Operations </h3><br>  The reason for the existence of Bloom filters is essentially the same as that of a hash table: superfast insert and view operations, thanks to which you can quickly remember what you saw and what didn‚Äôt.  Why should we be bothered by a different data structure with the same set of operations?  Because Bloom filters are preferable to hash tables in applications in which space is worth its weight in gold, and a random error is not an obstacle to the transaction. <br><br>  Like hash tables with open addressing, Bloom filters are much easier to implement and imagine in the mind when they support only the Insert and View operations (and without the Delete operation).  We will focus on this case. <br><br><blockquote>  BLOOM FILTERS: SUPPORTED OPERATIONS <br><br>  View: with the key k, return ‚Äúyes‚Äù if k was previously inserted into the Bloom filter, and ‚Äúno‚Äù otherwise. <br>  Paste: add a new key k to the Bloom filter. </blockquote><br>  Bloom filters are very spatially efficient;  typically they may require only 8 bits per insert.  This is quite unbelievable, since 8 bits is completely insufficient to remember even a 32-bit key or pointer to an object!  For this reason, the View operation in the Bloom filter returns only the answer ‚Äúyes‚Äù / ‚Äúno‚Äù, whereas in the hash table, this operation returns a pointer to the desired object (if it is found).  That is why the Insert operation now accepts only the key, and not the (pointer to) object. <br><br>  Unlike all other data structures that we studied, Bloom filters can be wrong.  There are two types of errors: false negatives when the View operation returns ‚Äúfalse‚Äù even if the requested key has already been inserted previously, and false statements (or triggers) when the View operation returns ‚Äútrue‚Äù, although the requested key has not yet been inserted in the past .  In section 12.5.3 we will see that the basic Bloom filters never suffer from false negatives, but they can have ‚Äúphantom elements‚Äù in the form of false statements.  Section 12.6 shows that the frequency of false claims can be controlled by adjusting the use of space accordingly.  A typical implementation of a Bloom filter may have an error rate of about 1% or 0.1%. <br><br>  The execution times for the Insert and View operations are as fast as in the hash table.  And even better, these operations are guaranteed to be performed in constant time, regardless of the implementation of the Bloom filter and data set1.  However, the implementation and data set affect the filter error rate. <br><br>  To summarize the advantages and disadvantages of Bloom filters over hash tables: <br><br><blockquote>  BLOOM FILTER AGAINST HASH TABLES <br><br>  1. Pros: more spatially effective. <br><br>  2. Pros: guaranteed permanent-time operations for each data set. <br><br>  3. Cons: cannot store pointers to objects. <br><br>  4. Cons: more complex deletions compared to a hash table with a clutch. <br><br>  5. Cons: non-zero probability of a false statement. </blockquote><br>  The list of indicators for the basic Bloom filters is as follows. <br><br>  Table 12.4.  Basic Bloom filters: supported operations and their execution time.  The dagger sign (‚Ä†) indicates that the View operation has a controllable but nonzero probability of false statements <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="image"></div><br>  Bloom filters should be used instead of hash tables in applications in which their advantages matter and their disadvantages are not an obstacle to the transaction. <br><br><blockquote>  WHEN TO USE THE BLOOM FILTER <br><br>  If an application requires a quick search with a dynamically evolving set of objects, space is worth its weight in gold and an acceptable small number of false claims, then the Bloom filter is usually the preferred data structure. </blockquote><br><h3>  12.5.2.  Applications </h3><br>  Next, there are three uses with repeated scans, where saving space can be important, and false statements are not an obstacle to the transaction. <br><br>  Spellcheckers.  Back in the 1970s, Bloom filters were used to implement spell checkers - spellcheckers.  At the pre-processing stage, each word in the dictionary is inserted into the Bloom filter.  Spelling of a document comes down to one operation. Look at a word in a document, marking any words for which this operation returns "no." <br><br>  In this appendix, a false statement corresponds to an invalid word that the spellchecker inadvertently accepts.  Such mistakes did not make spellcheckers ideal.  However, in the early 1970s, space was worth its weight in gold, so using Bloom filters at that time was a win-win strategy. <br><br>  <b>Prohibited passwords</b> .  An old application that remains valid to this day tracks forbidden passwords - passwords that are too common or too easy to guess.  Initially, all forbidden passwords are inserted into the Bloom filter;  additional forbidden passwords can be inserted later, as needed.  When a user tries to set or reset his password, the system searches for the proposed password in the Bloom filter.  If the search returns ‚Äúyes‚Äù, then the user is prompted to try again with a different password.  Here, a false statement is translated into a strong password, which the system rejects. <br><br>  Provided that the error rate is not too high, say no more than 1% or 0.1%, this does not matter much.  From time to time, some users will need one additional attempt to find a password acceptable to the system. <br><br>  <b>Internet routers</b> .  A number of today's mind-blowing applications of Bloom filters take place deep in the Internet, where data packets go through streaming routers.  There are many reasons why a router might want to quickly recall what it saw in the past.  For example, the router may want to find the source IP address of the packet in the list of blocked IP addresses, track the contents of the cache in order to avoid spurious cache views, or keep statistics that help identify a denial of service network attack.  The packet arrival rate requires superfast views, and the limited memory of the router makes space worth its weight in gold.  These applications are directly managed by the Bloom Filter. <br><br><h3>  12.5.3.  Implementation </h3><br>  Looking inside the Bloom filter, you can see an elegant implementation.  The data structure supports an n-bit string or, equally, an array A of length n in which each element is 0 or 1. (All elements are initialized to zero.) This structure also uses m hash functions h1, h2, ..., hm , each mapping the universe U of all possible keys to the set {0, 1, 2, ..., n - 1} of positions in the array.  The parameter m is proportional to the number of bits used by the Bloom filter for insertion, and, as a rule, is a small constant (for example, 5). <br><br>  Whenever a key is inserted into a Bloom filter, each of the m hash functions sets a flag, setting the corresponding bit of array A to 1. <br><br><blockquote>  BLOOM FILTER: INSERT (ON KEY) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  For example, if m = 3 and h1 (k) = 23, h2 (k) = 17 and h3 (k) = 5, inserting k causes the 5th, 17th and 23rd bits of the array to be set equal 1 (Fig. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="image"></div><br>  In the View operation, the Bloom filter searches for the fingerprint that might remain after insert k. <br><br><blockquote>  BLOOM FILTER: VIEW (KEY KEY) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª</code> </pre> </blockquote><br>  Now we can see why Bloom filters cannot suffer from false negatives.  When the key k is inserted, the corresponding m bits are set to 1. During the lifetime of the Bloom filter, the bits can change their value from 0 to 1, but not vice versa.  Thus, these m bits remain 1 forever.  Each subsequent View k operation is guaranteed to return the correct yes answer. <br><br>  We can also see how false statements arise.  Suppose that m = 3 and the four keys k1, k2, k3, k4 have the following hash values: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="image"></div><br>  Suppose we insert k1, k2, k3 and k4 into a Bloom filter (Figure 12.6).  These three inserts lead to a total of nine bits being set equal to 1, including three bits in the fingerprint of key k1 (5, 17 and 23).  At this point, the Bloom filter can no longer distinguish whether or not key k1 has been inserted.  Even if k1 was not inserted into the filter, the search will return ‚Äúyes‚Äù, which is a false statement. <br><br>  Intuitively, we can assume that with an increase in the size n of the Bloom filter, the number of overlays between the fingerprints of different keys should decrease, which, in turn, leads to a smaller number of false statements.  But the primary goal of the Bloom filter is to save space.  Is there a middle ground where both n and the frequency of false statements are simultaneously small?  The answer is not obvious and requires some mathematical analysis undertaken in the next section. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="image"></div><br><br>  ¬ªMore details on the book can be found on <a href="https://www.piter.com/collection/best/product/sovershennyy-algoritm-grafovye-algoritmy-i-struktury-dannyh%3F_gs_cttl%3D120%26gs_direct_link%3D1%26gsaid%3D82744%26gsmid%3D29789%26gstid%3Dc">the publisher‚Äôs website</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544611272/978544611272_X.pdf">Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544611272/978544611272_p.pdf">Excerpt</a> <br><br>  For Khabrozhiteley 20% discount on the coupon - <b>Algorithms</b> <br>  Upon payment of the paper version of the book, an electronic book is sent by e-mail. </div><p>Source: <a href="https://habr.com/ru/post/461039/">https://habr.com/ru/post/461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461029/index.html">A lake of marketing data - from monstrous tables to reports and visualizations</a></li>
<li><a href="../461031/index.html">We connect online maps to the navigator on the smartphone. Part 1 - standard raster maps</a></li>
<li><a href="../461033/index.html">Where does this config come from? [Debian / Ubuntu]</a></li>
<li><a href="../461035/index.html">Instructive episodes from the series Silicon Valley (Season 1)</a></li>
<li><a href="../461037/index.html">And here I am ‚Äúreal‚Äù</a></li>
<li><a href="../461041/index.html">Rounded or acute-angled?</a></li>
<li><a href="../461043/index.html">Conflict management in a team - balancing act or a vital necessity?</a></li>
<li><a href="../461045/index.html">Extracts from Rosreestr through FSIS USRN and python. Part 1 - Sample</a></li>
<li><a href="../461047/index.html">To write or not to write. Letters to authorities during events</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - He who seeks is not forced to wander</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>