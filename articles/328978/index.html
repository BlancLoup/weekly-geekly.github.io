<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How and why to create a NginX module - theory, practice, profit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vasily Soshnikov ( Mail.Ru ) 
 Today I will tell you about how to create nginx-modules and, most importantly, try to answer why it should be done. Thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How and why to create a NginX module - theory, practice, profit</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/760/792/436/760792436590dea41e59e7c8cf3505ba.jpg"><br><br><h2>  Vasily Soshnikov ( <a href="https://habrahabr.ru/company/mailru/">Mail.Ru</a> ) </h2><br>  Today I will tell you about how to create nginx-modules and, most importantly, try to answer why it should be done.  This is not always necessary, but there is a certain range of tasks that can be solved on the side of nginx. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/e91/b91/651/e91b91651c49f778ccafe285bf05d153.png"><br><br>  Here is a brief our plan.  First, I will introduce the course of the matter, talk about the architecture of nginx.  Second, I will try to immediately answer some frequently asked questions, because very often people working at Mail.ru come to me and ask the same questions, and I decided to just bring them out in a small FAQ.  Right away, so that there is a better understanding of what will happen next. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The most interesting part is anatomy.  I will talk about how to create nginx-modules, what types there are, talk a little about the pitfalls, but without all the subtleties, because, you know, nginx is a very complex technology, there are 1000 nuances, 1000 subtleties.  And I will try to answer the questions: ‚ÄúWhy create them ?,‚Äú Why do we create them in Mail.ru? ‚ÄùAnd‚Äú Why did I create them, working not in Mail.ru? ‚Äù. <br><br>  Also last night I decided to write examples, literally templates of nginx-modules, which you can just take and use.  At the end I will give a reference.  Because my comrades told me that without this my presentation is incomplete. <br><br>  Let's start with the ‚ÄúIntroduction‚Äù part and frequently asked questions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/970/694/45b9706949a34621860fa6a9d49ad2c5.png"><br><br>  The first is the nginx architecture.  I always associate it with a matryoshka.  In fact, the way it is.  There is a certain core in which there is all basic API from which it is possible to blind everything that you want.  In this case, http was cast, upstreams was made from http, and also a scripting engine.  And the mail engine, which works with the mail, is also based on the core.  Modules that are already written for http are made on the http core.  Those.  You understand, this is such a matryoshka, there is a base - this is a core, there are layers below and below.  And moreover, the lower the layer, the, as a rule, more than any modules.  You understand that for http there are a lot of modules, and all of them are based just on the http core, and of the features of nginx. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cd/494/fcb/1cd494fcb35857c5c76d3a24fc4ea27c.png"><br><br>  And one of the most frequently asked questions is about the nginx memory model.  Nginx uses pool.  It must always be remembered.  And we must take the correct pool.  Many people make a frequent mistake and try to nail their buffers to the connection, and a keep-alive connection can live for a very long time.  You understand that such buffers will accumulate as long as the connection is alive, and nginx can simply leak.  Therefore, you should always choose the correct pool.  If we want to just save some buffer for the lifetime of the request, it is more logical to nail it to the request, rather than to the connection. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N_8Zk281vNE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You also need to remember that these pools are periodically cleaned and they have their own life-times.  In principle, they are all quite logical, connection lives within a connection, request - within a request, the config is always alive and periodically held.  There are also many other contexts, but a little further about them. <br><br>  Also try to use nginx locators inside nginx.  A reference to the API is at the top.  Why is it necessary to use them?  a) they are faster;  b) they are easier to debug if you use Valgrind for nginx.  True, in life I did not debug nginx buffers.  It was not necessary, because the pool, if everything is done correctly and everything is calculated, it works fine. <br><br>  But there is such a situation, for example, I recently had when I had to use standard malloc, alloc, reallock.  Why?  Because in nginx there is no reallock.  This is a big problem.  If you have some kind of library that uses reallock, then you just can‚Äôt replace these allocation functions in the library.  Here, a good example is Yajil.  Basically, I figured out how to do this, if someone is familiar with Pascal strings, you can simply allocate 4 more nails and nail them into this piece of memory.  And use for reallocation the usual nginx'ovskiy allock. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a94/578/8bd/a945788bde22c0ff7080a264ddcf04d7.png"><br><br>  And this example is nginx_conf_s.  This is its internal structure.  Here you can see just this link on the pool.  In this case, if you allocate something within the framework of the config, you will have to live as long as the config is alive.  And in nginx, the config always lives until you clean it with handles.  But there are different configs there, about this, too, a little further.  So you have to remember, you should always look at the structure you want to nail, and approximately understand where it lives.  And after some time you will have it all on the machine, but first you need to follow it very clearly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6b/662/0c7/d6b6620c740a591de2028306557c08d3.png"><br><br>  And now very briefly about what is in nginx, and how its structure in the repository is arranged.  At the top of the API, and below - what is there.  The first is that in nginx there are a lot of data structures, and try to use them, because: a) they already know about nginx pools;  b) this is the most native way to use it with nginx data types, because in nginx almost all data types are either typedef of system types or their own structures. <br><br>  Also in the nginx core you can find the OS with the API, naturally wrapped in the facade.  This can be useful if you are no longer writing your own http-module on nginx, but, let's say, some kind of your own TCP-module, this is also possible.  Because http is made on the basis of core and it can be expanded, if desired, somehow.  Also there you can find a state-machine, which is responsible for file-file descriptor, and many other useful functions, like logging, working with scripts and configs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/5fe/c8a/4725fec8a9a7ac498d32101d67acc083.png"><br><br>  And now the most interesting and most painful, or rather, the most unknown.  This is how nginx modules are organized, what types they are.  Since I am limited in time, I decided to tell only about the three main ones.  And then about the most, probably interesting - it's about upstream.  In short, because it is really a topic for a separate report. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f5/51f/0b8/3f551f0b828d18904a5aa437ddb618a1.png"><br><br>  Therefore, today we will consider only 3 main modules - these are Handlers, Filters and Proxies.  Proxies in short.  In fact, there are many other types of modules, as I said, because http, in fact, is also a module, based on the core.  But we will not go into such nuances, because it is very long and, again, this is a topic for a separate report. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/608/956/477/6089564773d533354cb6f6dbfd3b2d24.png"><br><br>  Everything in nginx is subject to one pattern.  This is the Chain of responsibility pattern.  In other words, your request from the user goes through the http module, the http module starts some sequence - the chain of modules.  And if they all worked well, the user will receive a good answer, if not, then an error will result.  The closest analogy is this line of code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a18/902/290/a18902290ca3b979433c710b3642e384.png"><br><br>  I thought it would be a perfect analogy, I hope, I am right.  Everyone understands this line?  This is essentially a bash.  We get something, we take the first line along the delimeter;  doing a variety and counting words.  The principle of operation of the nginx-module is very similar to this.  Those.  If the pipe breaks, the whole chain will fly away from you, and you will get an error in the bash.  Also there are signals, etc.  Nginx has all the same, so all nginx modules should be treated that way. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/645/03e/b2f/64503eb2fe503aa7200fb2880f9213b5.png"><br><br>  Also, if you dig a little deeper, you can find that in addition to the fact that this chain, this chain is broken into phases.  In nginx there are a lot of phases, each phase is called at a certain point in time under certain conditions, all handlers within the phase are traversed, after which the switching takes place with the result of the execution of that phase into another phase.  In principle, this drawing illustrates this.  We have a certain set of modules in phase, we go through, we get the result, we go to the next phase. <br><br>  And here are the phases that are now available in nginx_http: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/a80/34f/c6ca8034fceb0f5083d5f4401e71ac8d.png"><br><br>  They are self-speaking, I think, there are no questions here.  Those.  server_rewrite, search config, rewrite normal, content_phase. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01c/d8f/598/01cd8f598878f379d96d5ebddb44e8d5.png"><br><br>  And now we proceed directly to how modules are developed.  It is to those things that must be done for each module. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b91/b5d/0d2/b91b5d0d22660995ed953ff6d81a52b0.png"><br><br>  First, any module in nginx starts with a config.  In nginx there is a certain way of naming such structures for your module and for any other modules and even for internal nginx.  It is to use such a naming convention, i.e.  ngx_http shows that we are doing something for http now.  Next is the name of your module - it could be anything.  And accordingly, one of the types of config - main, server, loc - and _conf. <br><br><blockquote>  <font color="gray">By the way, we posted in open access the video of the last five years of the conference of developers of high-loaded systems <a href="http://www.highload.ru/">HighLoad ++</a> .</font>  <font color="gray">Watch, learn, share and subscribe to <a href="https://www.youtube.com/user/profyclub">the YouTube channel</a> .</font> </blockquote><br>  Everyone remembers nginx_config?  This one is from there.  There is main - this is the most global scoop, there is a server, a beta server, and there is a location.  Location if - also consider the location, only specific.  In fact, these configs and these structures may be merged at different stages, i.e.  nothing prevents you from making this structure so that it is present both in main, in the server, in the location and in the location if, nothing.  All that is needed is to write one function and set a bit-mask defined.  More on this later. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/198/78e/7c119878e7e27d03b9fb119d779c27cf.png"><br><br>  Directives.  There are directives in the nginx config.  And, accordingly, when you develop your module, you should understand that you must give some kind of pen to administrators and users.  In nginx, there is a special structure for this - ngx_command_s.  I put all the references on the API here, so you can then just see, there is nothing complicated there.  And here, in essence, all that is present is the name.  The name is how your directive is presented in nginx config.  This is the type, and it is the mask that this directive is.  Those.  it is present in the location, in the main conf, server conf.  Callback exists to parse the value of this variable.  There is a large set of ready-made callbacks.  For example, if we use ngx_string, and we just need to save a line, then we should not implement this callback, but take already ready from nginx.  And then a few system fields, I will tell about them on the next slide. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/5f5/96b/3f35f596b4471eb957a22e570cb58851.png"><br><br>  Suppose we create a module called MODULE_NAME.  Here, we have a certain variable, a regular integer, and we want to transfer this integer to the config.  All we need is to declare such a structure in this array.  If we had many different variables, we would have many elements of this array.  And so, as I said, this mask, here in this case, this bitmap says that one argument is taken.  Here that this directive may be present in the location of the kofig, server config, and in the main config.  If I still wanted to have a location if, I would have to add another piece of this mask. <br><br>  Accordingly, it is a nginx-function, it exists for parsing the usual ones.  This is specifically to save time so that this function is not performed every time.  offsetof simply indicates where this field is located in our structure, this is the good old C-shny hack.  I will not focus on it, because, in fact, in this context it should be taken as given.  Those.  he does not carry a semantic load. <br><br>  And this array ends with the usual ngx_null_command - a marker indicating that the array has ended.  Because in nginx almost everything that you declare inside your module is static, and it is externalized somewhere, because now there are two ways in nginx how to develop modules ‚Äî this is either compiled with nginx or the load module, but more on that later.  In this case, it must be remembered that for the time being everything will be static, and that a final marker is needed, because it goes through this array to the end, to this marker. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cc/ad5/536/3ccad553651eeb2035ca596c8265d810.png"><br><br>  Here, we created some directives, it all works well for us, but now we need to do install inside nginx, create a config and its merge.  For this there is such a structure as ngx_http_module_t.  It is also quite simple, there are several stages of installation, this is preconfiguration, this is before any postconfiguration configuration occurs, as well as several other functions, which are described in more detail in the next slide. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/789/c8c/5e2/789c8c5e2068998fda6ae6f603385cdc.png"><br><br>  We, for example, want that what we announced earlier, our directive should be correct at the location.  All that needs to be done for this is to hammer into our two callbacks that we ourselves declared inside our module, and using ngx_palloc to preallocate our config.  And make it merge.  In nginx, if this is a primitive type that nginx understands, there is already a large set of functions to merge any variables.  If this is your own some type, say, you have some very tricky line that needs to be parsed, say xml, and you want to write it in a separate structure, then you will need to describe the function and merge, and the set of such a variable and pass it to the callback.  And at the stage of merge config in this function, you can do some additional checks and say that such an error has occurred.  Here you can also log in and do something else. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/221/a05/9ed221a0541b63336a0e3caf67e3842d.png"><br><br>  Everything, we have a merjitsya config, we received directives.  Now the most interesting thing is how to tell nginx that our module has appeared?  For this, there is ngx_module_t - this is a special type.  And, again, it is declared a static inside our object builder, i.e.  ordinary variable.  You describe, transfer the context, these commands that we have formed, and additional callbacks are also possible for more flexible control.  Those.  suppose if we want some specific action on the init master, on the way out of our master, etc.  Here, in principle, I think everything is also clear, there are no questions.  Just extra knobs for control.  For example, why is this needed?  Let's think about it, if our module used shared memory, we would definitely want to unlock it when exiting and killing a thread.  For this and there are these pens - for additional action. <br><br>  Proceeding from this point, I think everyone understood, or they already know how to create nginx modules.  All that needs to be done is, in essence, to describe several static variables and declare several callbacks and that's it.  And our module will pick up.  But, that's not all, now the most important nuance is how to add a handler to the phases and how to make filters.  Just in order for us to call our functions on some events inside nginx. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b7/ae8/5fa/1b7ae85fada4d6e55046a8c3597b1d70.png"><br><br>  And now we will talk about it.  About handlers and filters.  These are two different entities. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b6/9e8/734/2b69e8734f1a08860e09ce6989278573.png"><br><br>  I'll get back to the phases just in case.  Phases cause a certain point in time, cause a certain chain, end the chain and go to the next phase, and so on until all the phases have passed, or the phase is not interrupted.  And just handlers work with phases.  Those.  What is a handler?  You can bind any function to any of these phases.  And now I will show you how this is done. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa8/33a/658/aa833a6583c463a54f43f87845af9d86.png"><br><br>  As you remember, with us when declaring a module we could transfer additional pens.  Suppose here at postconfiguration, i.e.  when we have already completed the directives, we received variables, filled them, we must do if we want to add some phase, add a function during initialization and, accordingly, describe the following in this function - what we get, as you can see, the content of the phases from nginx core config, because it's all in the http core lives.  And just add your function there with the usual array_push.  And everything, at us this function will be caused on content. <br><br>  In other words, what is content phase?  When someone returns an answer, we have content phases jerking, and we can do anything there, say, we can count the number of words in the response from the server or additionally compress it with some kind of our own algorithm.  And every time when someone returns the answer, be it a file, be it something else, this function will be called.  In it, we can already work with the http-request, pull out the data we need, add something there, or, conversely, delete it.  And so we can do with each phase.  The main thing to remember is that all phases are called at different times.  In other words, if you need to work with content, you do not need to add your handler to the log phase.  Because the log phase occurs when you need to write something, roughly speaking.  There you can, on the contrary, collect some additional statistics, if you are interested in this phase.  And in this phase you need to process content. <br><br>  By the way, I remembered a good example.  The last time I did the content phase, I had to generate a picture on the fly for the counter at top.mail.ru.  Here is a good example.  Those.  I just did nothing, I just generated this new image depending on the query parameters, depending on the counter id, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd2/042/5c6/fd20425c686414436df028e6be3aba83.png"><br><br>  Filters.  This is a slightly different entity.  What are filters?  Remember our chain?  Filters are, in fact, a simple, simply-connected list of some filters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/92c/4a6/93292c4a6bb849423dd7ca36e229291c.png"><br><br>  And all you need to do to add your own handler to a specific filter is to simply take the nginx static variable called top_header_filter, add your handler there and that‚Äôs it.  In this case, this is our header_filter, and your handler will be called each time at some time during the processing of the headers. <br><br>  Good practical example.  We need to set our cookies for the counter and check.  All you need to do is add a new header filter and check out the headers that come in and somehow convert to a normal cookie.  This is a good example of why this is used. <br><br>  Another good example of why this is used.  Everyone knows such a directive as add_header, a standard nginx directive.  She uses these headers. <br><br>  Those.  it can do anything with http headers.  And the whole installation always looks like this.  In fact, there is still a body, I forgot about it.  He has the same ideology, the same list, but it works at the stage of content processing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3f/2d2/b1b/c3f2d2b1bf1cf7afa29d2853d21bc87c.png"><br><br>  And the most interesting.  Our structure is request.  If you ever develop for nginx, this structure will become your best friend.  You will often go to this code, perhaps you will forget something about it so that you can jump on it quickly.  She is huge, you need to know her.  There are a lot of nuances.  Therefore, if you want to develop something, get acquainted with this structure, there is nothing complicated there, you just need to read and understand.  It keeps the connection itself, the headers that came from the user, which are gone to the user, she keeps all handler handlers in her, her own pool, which works on this request.  She also stores the body.  Moreover, when you need to deduct guaranteed whole body, or send guaranteed ... because nginx is all pipe, in fact, it works all the time as pipe, it can not accumulate to the end.  If you need to send something exactly guaranteed, you need to call special functions and use a specific request.  More precisely, the specific structure of the request that came to your handler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/10a/f43/cfa10af438417a4e5893f9e347bda934.png"><br><br>  And here we come to the most interesting and most difficult moment of nginx - this is the chain buffer.  In nginx, any work with any buffer is a chain buffer.  This is, in fact, a single-linked list of buffers.  It is very tricky, it can be in a file, it can be shared memory, it can be read only memory, it can be temporary memory.  I thought that I would not go into the chain buffer, because there are so many nuances.  The main thing that you need to know about it is that your message can come, but in general the body, not in one piece, it can come in buffers, in small-small pieces.  This is especially important when you are developing upstream.  Because in the upstream you may come in 4K or even in byte, if you need to parse it all, you will need to make some kind of tricky parser that works with chains.  In the examples in the read me I will give a reference later, I dropped about two such upstream ones, who would be interested in how to implement a stream parser inside nginx.  Because there is still such an important rule - nginx can not be blocked.  You have one worker.  Even if there is a ThreadPool, it is rare for them who use it, if you blocked this worker for a long time, you lost a lot of rps.  This, too, must always be remembered. <br><br>  And back again, after this lyrical digression, to the Chain buffer.  In principle, the whole structure looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/7fb/0dd/0dc7fb0ddb33577548100fe9022bd5d3.png"><br><br>  Those.  we have a position, last, if this file is file_pos, tags and a bunch of flags.  And, in principle, all these comments are now taken from nginx.  They must be remembered.  Imagine, in your filter or your handler, a piece of memory has come to anything, which is marked that it cannot be modified, then you do not have the right to modify such content.  You have to copy it yourself, change it as you want, and give it away.  Therefore, these flags must be constantly checked. <br><br>  Or another good example.  Many modules that I wrote do not work with chain buffer if there is a checkmark in_file.  Because I wanted there was such a requirement that it work quickly.  If, God forbid, nginx starts to pull from a file, from its cache or from somewhere else, then it all dies.  Therefore, in this case, it is very logical to check the chain buffer for the fact that it is not in_file, if you do not need it, and write to the admin in the log: "Friend, remove the buffer size, please."  This is also a good structure with which you should make friends. <br><br>  And here is an example, this is me from my upstream module. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c65/b50/395/c65b50395079f63f5f39cbe542c11c88.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I wrote 6 modules for nginx. </font><font style="vertical-align: inherit;">Only one opensource, and I showed the code from it. </font><font style="vertical-align: inherit;">What I told you.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here, however, the upstream chain buffer is used, not the requester buffer, but the logic is the same. </font><font style="vertical-align: inherit;">What you just need to check the flags and these flags need to somehow definitely respond. </font><font style="vertical-align: inherit;">This is a sample code that now works for many. </font><font style="vertical-align: inherit;">Here, in particular, tp_transcode is a streaming parser, which I did for a long time and painfully. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e1/ff5/70f/0e1ff570f11d6c9e60f1f9926b0beb94.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we got to the Proxies. </font><font style="vertical-align: inherit;">About proksyah, as I said, or upstream, or load-balancers, I do not know how to properly characterize them, because they are all similar to tz. </font><font style="vertical-align: inherit;">implementation. </font><font style="vertical-align: inherit;">Therefore, I will tell only the very idea why this exists. </font><font style="vertical-align: inherit;">But without details, because there are so many nuances.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/34f/2c2/9b6/34f2c29b6a83ecc27219dba6b28be6f7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basically, what is upstream? This is a proxy pass. What does a proxy pass do? In fact, everything that he does, in a chain-mode, gives data to backends, can balance them according to different rules. Nothing prevents you from screwing any protocol there. Suppose we have some kind of daemon that works on the protobuff; nothing prevents nginx from balancing it with the protocol conversion.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the entrance - http, https with some kind of json or even raw protobuf. And you can convert it to a clean protobuf and give it to the application server or to any other protocol. This is the whole idea of ‚Äã‚Äãupstream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, in fact, upstream is a ready-made API inside nginx, which allows you to: a) easily configure such balancing by key, say, some other criteria; b) make backups, i.e. in case all upstreams have fallen off, it will follow a different url. And a lot of different pens for upstream. How many files can be, what timeouts, etc. And everything is available out of the box. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I didn‚Äôt have time to add an example of how to do upstreames, but I‚Äôll finish it and post it by reference, which I‚Äôll give. I hope I clearly explained what upstream is and what can be done with it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in addition, if you do not need conversions to another protocol, you can use them for custom balancing. </font><font style="vertical-align: inherit;">However, in my opinion, now it is not required, because there is OpenResty, and there is an excellent directive balancer_by_lua, i.e. </font><font style="vertical-align: inherit;">balancing can be written on lua with any custom logic, I do not know, even go to the radish, however, it all dies under load, but this can be done. </font><font style="vertical-align: inherit;">Dies-dies.</font></font> Checked.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried, my CPU took off at the ceiling, perhaps because of the lua-lines, I suspect because there is balancing on the url when I tried. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/01f/a16/f8e/01fa16f8eee81081ac93859690e363e1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the most sensitive issue was that tons of copies were broken on it, thousands of admins wept, thousands of developers swore at admins. </font><font style="vertical-align: inherit;">This is deployment.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4dd/e41/c83/4dde41c830ec804d140ee1f8efe91ef3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I forgot to say about the assembly first. Here is a new way to build. In nginx it has recently changed. I did not show the old one, and I did not write a single word about it. I just took from my repository what the typical configuration of this conf, nginx looks like, to add a module. In essence, this is bash, or shell. It just describes a few variables on the shell and that's it. You can even link a C ++ runtime here instead of this static library if you want. This is no problem. Moreover, to be honest, I linked to nginx ++ runtime. This is no problem. The main thing is that the expection in nginx does not penetrate from the pros, because nginx will smash into shchi. Because C is not very friendly with the positives. Here we simply describe what and where it lies.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5a/7cc/4ae/b5a7cc4aee8d218286cefa3bd0c4c99b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then we just fill in these variables, as I wrote above, nginx-variables, and call the auto-module. The module is located inside the nginx repository, where you can see it. This is a new build method and you need to use it, because the old build method will not be soon, as soon as everyone moves to fresh nginx.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/421/e6d/803/421e6d803041b38c10e6b9f39a8a19df.png"><br><br>  Delivery.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here it is a sore subject, and I waited for it long and hard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For probably three years, all the time we just build our nginx with a bunch of modules and just deploy it. The main thing is separate from the system nginx paths. This is very important, because some wake-up admin will want to put a nginx with the status, write apt-get install nginx and completely put your server. Therefore it is very important. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus, we have several projects where there are several completely different nginx modules. It happened, because these are different projects inside mail.ru. And I do not know why it is not to unite, there are no contradictions, it just happened. And we have come to that, we just break up by the name of the project on the way, where we put all this. This is actually pain and suffering, but now it is.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second way, which appeared relatively recently, is, however, non-working so far - it is possible to load SO'shki in nginx. Why is it non-working? Because nginx checks the fingerprint of this SO's binary. And in order for it to accept this module, you have a large number of nginx build flags and your module must match. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I have figured out a way to solve this. Here we have, let's say, the Debian system, and there we can pull out the information with which flags nginx was compiled. And nothing prevents your module from assembling with the same flags, and then packing it. I have not tried to put it on rails, but now I think in this direction, because loading modules is easier. But it is now more painful, because there is a problem with the fingerprint. It seems like the guys are trying to solve it, if you believe their wiki.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the second option, it is less popular, at least inside mail.ru, maybe in reality it is popular. This is a docker. People take the usual nginx, the usual ways and just make docker image out of it, put it on the server and launch it. I do not know how common this is, but people use it here. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/eff/0d6/dfaeff0d6503018de00e7d4327b8fe49.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now, probably, the most provocative thing - why create them? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4e/db7/afc/c4edb7afcaabd5a712c970e43c135d73.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The answer to the forehead is because there are always new technologies, new ones. If you want to contribute your part to the nginx contribution, albeit from the side, you can add some cool feature to nginx or add a new technology inside nginx. Let's say http 3.0 appears, it will be a new module.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/12d/c79/acf12dc79dac31940978c53451d56046.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, this is my argument, which often resulted in many disputes "Why do I need an nginx-module?". </font><font style="vertical-align: inherit;">This is what many use - nginx ReverseProxy - to balance into some advantages, which all they do is tell nginx or the client how to work.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in such a situation it is more logical, when there are no states, nothing, instead of ReverseProxy, to write an nginx-module, especially in high-loaded projects. </font><font style="vertical-align: inherit;">Of course, if you have some kind of application, it‚Äôs already harder, but, again, you have to look at the task. </font><font style="vertical-align: inherit;">And so we went to the solution of business problems.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa2/cb4/e08/fa2cb4e082aee028f57cd54b4eeaa9ff.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a typical example, these were my 3 penultimate modules for the top mail.ru. Before that, we had an ordinary http-server there, written by hands, no one knows when it was written, it was almost impossible to maintain it, it was constantly breaking down, there were problems, etc. And it was a volitional decision - just take and rewrite all the logic in nginx. Make several modules. A module that distributes cookies, a module that generates a JS file that gives up the counter, and two additional image modules special for this project. 4 modules even turned out.</font></font><br><br>  What is he doing?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it receives this data from the user, forms a line and asynchronously it logs to disk. After that, these logs are raised by the counter and counted. When I made these modules on nginx, we got better on the CPU, as it turned out. Finally, the SSL wound up correctly, because before that it worked incorrectly. It's hard to make kosher SSL inside your application. It hurts. Especially check it out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, a good example, statistic analytics. Fits perfectly. There are no states, there are cookies, as a rule, all your states are stored by the user. There is an atomic increment, if you have such logic, it is simply done.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5f/69a/4f6/f5f69a4f6b9fa1367355a05f75515db3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertising systems. Generally perfect case. Here either OpenResty, or directly on the nginx-module to write, depends on your needs. Because it is a classic of the genre, I will not even add there. There are almost no states at all, you need some kind of mapka or shared memory between nginx and your demon, which will already have all the connections. Generally, the ideal case. But I'm not sure about OpenResty, to be honest.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e28/053/aab/e28053aab9d2a1d727c4aa4e9e2c024f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And protocol conversion. </font><font style="vertical-align: inherit;">Admittedly, people, we all have http, we all have browsers, etc. </font><font style="vertical-align: inherit;">And when we write heaps of a binary protocol, it all pours out of us, that somewhere there is http, then why do we need extra layers? </font><font style="vertical-align: inherit;">You can just write upstream, which will convert http to X protocol. Everything is quite simple and in fact it is not so difficult. </font><font style="vertical-align: inherit;">This is actually my work in the evenings 2 weeks. </font><font style="vertical-align: inherit;">I think you will have about the same amount of it. </font><font style="vertical-align: inherit;">Moreover, it was still a heavy protocol with strange handshakes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here is the </font></font><a href="https://github.com/dedok/nginx-tutorials"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On examples that promised, there are 3 examples, a little bit of references on a couple of upstream'ov. </font><font style="vertical-align: inherit;">There is a very primitive code, literally 100 lines of code, everything that I said is there, plus it makes additional logic. </font><font style="vertical-align: inherit;">For example, Word Count on the body when filtering, the substitution of content, etc.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it can be copied and even indulged. </font><font style="vertical-align: inherit;">There is a special make file, there is an instruction on how to build it. </font><font style="vertical-align: inherit;">I will try to expand this and write a comment in the code.</font></font><br><br><h3>  Contacts </h3><br>  ‚Üí <a href="https://github.com/dedok">github</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://twitter.com/vasayso"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitter</font></font></a> <br><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This report is a transcript of one of the best speeches at a professional conference of developers of </font></font><a href="http://www.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dnginx.module"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> systems </font><a href="http://www.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dnginx.module"><font style="vertical-align: inherit;">Highload ++</font></a><font style="vertical-align: inherit;"> , specifically, the ‚ÄúBackend‚Äù section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our opinion, the report " </font></font><a href="http://junior.highload.ru/2017/abstracts/2545%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dnginx.module"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxy HTTP requests by web accelerator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " will be </font><font style="vertical-align: inherit;">an excellent addition to this material </font><font style="vertical-align: inherit;">, which visitors of </font></font><a href="http://junior.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dnginx.module"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++ Junior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can hear in three weeks </font><font style="vertical-align: inherit;">and read Habr's readers in a few months.</font></font><br><br></font> <ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How HTTP proxying works without cache; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are persistent connections and how do they differ from HTTP keep alive; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How, when and how many connections can set up an HTTP accelerator with upstream; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What becomes of the requests that are waiting for the queue to be sent to the upstream connection, but upstream is out of the box and resets the connection every 100 requests; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is HTTP pipelining, and how it is used by modern HTTP accelerators; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are nonidempotent requests, and why you need to worry about them.</font></font><br></li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/328978/">https://habr.com/ru/post/328978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328966/index.html">How are developed industry and specialized solutions for 1C: ERP</a></li>
<li><a href="../328970/index.html">Building a modular architecture of the application on Forwarding decorators (author's translation)</a></li>
<li><a href="../328972/index.html">Nice to meet you. LANIT</a></li>
<li><a href="../328974/index.html">Top designs by Behance users</a></li>
<li><a href="../328976/index.html">Scheduling: myths and reality. Yandex experience</a></li>
<li><a href="../328980/index.html">When you need a corporate app store</a></li>
<li><a href="../328984/index.html">Open broadcast DotNext 2017 Piter: Jon Skeet, Sasha Goldshtein and Andrey Akinshin live</a></li>
<li><a href="../328986/index.html">Breaking words into elements of the periodic table</a></li>
<li><a href="../328988/index.html">How to choose a reliable data center provider: seven success factors</a></li>
<li><a href="../328990/index.html">Tours in exploratory testing. Personal translation from D. Whittaker's book "Software Research Testing"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>