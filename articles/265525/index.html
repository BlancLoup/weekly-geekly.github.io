<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Resource Binding in Microsoft DirectX 12</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On March 20, 2014, Microsoft announced the release of the DirectX * 12 conference at the Game Developers Conference. By reducing redundant processing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Resource Binding in Microsoft DirectX 12</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/198/868/11b/19886811b90c442e874bd27c2a55ceb5.png"><br>  On March 20, 2014, Microsoft announced the release of the DirectX * 12 conference at the Game Developers Conference. By reducing redundant processing of resources, DirectX 12 will contribute to more efficient operation of applications and reduce power consumption, which will make it possible to play longer on mobile devices without recharging. <br>  At the SIGGRAPH 2014 conference, Intel experts <a href="https://software.intel.com/en-us/blogs/2014/08/11/siggraph-2014-directx-12-on-intel">measured the</a> power consumption of the CPU when running a simple demo with asteroids on a Microsoft Surface * Pro 3 tablet. You can switch the demo application from API DirectX 11 to API DirectX 12 by pressing a button.  This demo application draws a huge amount of asteroids in space at a fixed personnel speed.  When using the DirectX 12 API API, the power consumption of the CPU is more than doubled compared to DirectX 11 **.  The device operates in a less intensive thermal mode and is able to work longer from the battery.  In typical gaming scenarios, all unused CPU power can be spent on improving physics, artificial intelligence, path finding algorithms, or other tasks with an intense load on the CPU.  Thus, the game becomes more powerful in functionality or more economical in terms of electricity consumption. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Instruments</font> </h2><br>  The development of games based on DirectX 12 requires the following. <br><ul><li>  Windows * 10 </li><li>  DirectX 12 SDK </li><li>  Visual Studio * 2013 </li><li>  DirectX 12 compatible GPU drivers </li></ul><br>  If you are a game developer, try <a href="https://onedrive.live.com/survey%3Fresid%3DA4B88088C01D9E9A!107%26authkey%3D!AFgbVA2sYbeoepQ">participating in the Microsoft DirectX Early Access Program</a> . <br>  After accepting the conditions of the DirectX Early Access Program, you will receive instructions for installing the SDK and drivers for GPs. <br><br><h2>  <font color="#0071c5">Overview</font> </h2><br>  From a higher level perspective, compared to DirectX 10 and DirectX 11, the architecture of DirectX 12 is different in managing states, tracking and managing resources in memory. <br>  In DirectX 10, state objects have appeared to set up a group of states at run time.  In DirectX 12, state-of-the-art (PSO) objects have appeared, which serve as even larger state objects along with shaders.  This article discusses changes in working with resources;  the grouping of states in the PSO will be described in further articles. <br>  In DirectX 11, the system was responsible for predicting and tracking resource usage, which limited the ability to create applications with large-scale use of DirectX 11. In DirectX 12, the programmer (not the system and not the driver) is responsible for processing the following three usage models. <br><br>  <b>1. Resource Binding</b> <br>  DirectX 10 and 11 tracked resource bindings to the graphics pipeline in order to maintain resources already released by the application, since unfinished GP operations could refer to these resources.  In DirectX 12, the system does not track resource bindings.  The application, that is, the programmer, should be involved in managing the life cycle of objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>2. Resource Binding Analysis</b> <br>  DirectX 12 does not track resource snapping to determine if resource switching has occurred.  For example, an application can write a rendering target using a render target view (RTV), and then read this render target as a texture using a shader resource view (SRV).  In API DirectX 11, the GP driver had to ‚Äúknow‚Äù when such a switch of resources took place in order to avoid conflicts when reading, changing and writing data in memory.  In DirectX 12, you must identify and track all resource switching using separate API calls. <br><br>  <b>3. Synchronize mapped memory</b> <br>  In DirectX 11, the driver handles synchronization of mapped memory between the CPU and the GP.  The system analyzed resource bindings to see if rendering delays are required because the resource mapping that was mapped for CPU access has not yet been canceled.  In DirectX 12, an application must handle the synchronization of CPU and GP access to resources.  A single mechanism to synchronize memory access requests an event to wake up a thread when processing is completed in the GP. <br>  Moving these resource utilization models into applications required a new set of programming interfaces capable of supporting the widest set of GPU architectures. <br>  Later in this article, new resource binding mechanisms are described, the first of which are descriptors. <br><br><h2>  <font color="#0071c5">Descriptors</font> </h2><br>  Descriptors describe resources stored in memory.  A descriptor is a data block that describes an object for a GP in an "opaque" format intended for GP.  Some stretch handles can be seen as a replacement for the former system of ‚Äúviews‚Äù in DirectX 11. In addition to various types of DirectX 11 descriptors, such as shader resource representation (SRV) and unordered access representation (UAV), other types of descriptors appeared in DirectX 12, for example, samplers and constant buffer representation (CBV). <br>  For example, SRV chooses which base resource to use, which set of embossed maps and array slices, and in what format to interpret the memory.  The SRV descriptor must contain the virtual address of the Direct3D * resource (which may be a texture) in the GP.  The application must ensure that the base resource is not destroyed and is not inaccessible due to non-residency. <br>  In fig.  Figure 1 shows the handle of the "view" texture. <br><br><img src="https://habrastorage.org/files/dfc/5d4/185/dfc5d41857e7479886598c121c08a8bf.png"><br>  <i>Figure 1. Shader resource representation in the handle [used with permission ¬© Microsoft Corporation]</i> <br><br>  To create a shader resource representation in DirectX 12, use the following structure and device method Direct3D. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D3D12_SHADER_RESOURCE_VIEW_DESC</span></span></span><span class="hljs-class"> {</span></span> DXGI_FORMAT Format; D3D12_SRV_DIMENSION ViewDimension; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { D3D12_BUFFER_SRV Buffer; D3D12_TEX1D_SRV Texture1D; D3D12_TEX1D_ARRAY_SRV Texture1DArray; D3D12_TEX2D_SRV Texture2D; D3D12_TEX2D_ARRAY_SRV Texture2DArray; D3D12_TEX2DMS_SRV Texture2DMS; D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray; D3D12_TEX3D_SRV Texture3D; D3D12_TEXCUBE_SRV TextureCube; D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray; D3D12_BUFFEREX_SRV BufferEx; }; } D3D12_SHADER_RESOURCE_VIEW_DESC; interface ID3D12Device { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateShaderResourceView</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_opt_ ID3D12Resource* pResource, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> D3D12_SHADER_RESOURCE_VIEW_DESC* pDesc, _In_ D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</span></span></span></span>; };</code> </pre> <br><br>  An example SRV code might look something like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// create SRV D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc; ZeroMemory(&amp;srvDesc, sizeof(D3D12_SHADER_RESOURCE_VIEW_DESC)); srvDesc.Format = mTexture-&gt;Format; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D; srvDesc.Texture2D.MipLevels = 1; mDevice-&gt;CreateShaderResourceView(mTexture.Get(), &amp;srvDesc, mCbvSrvDescriptorHeap-&gt;GetCPUDescriptorHandleForHeapStart());</span></span></code> </pre><br><br>  This code creates an SRV for a two-dimensional texture and specifies its format and virtual address of the GP.  The final argument for <i>CreateShaderResourceView</i> is the handle heap token that was allocated before calling this method.  Descriptors are usually stored in heaps of descriptors, which are described in more detail in the next section. <br>  Note.  You can also transfer some types of descriptors to the GP using the so-called root parameters (taking into account the driver versions).  See below for details. <br><br><h2>  <font color="#0071c5">Heaps of descriptors</font> </h2><br>  A bunch of descriptors can be viewed as one allocated amount of memory for several descriptors.  Different types of heaps can contain one or more types of descriptors.  The following types are currently supported. <br><br><pre> <code class="cpp hljs">Typedef <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> D3D12_DESCRIPTOR_HEAP_TYPE { D3D12_CBV_SRV_UAV_DESCRIPTOR_HEAP = <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D12_SAMPLER_DESCRIPTOR_HEAP = (D3D12_CBV_SRV_UAV_DESCRIPTOR_HEAP + <span class="hljs-number"><span class="hljs-number">1</span></span>) , D3D12_RTV_DESCRIPTOR_HEAP = ( D3D12_SAMPLER_DESCRIPTOR_HEAP + <span class="hljs-number"><span class="hljs-number">1</span></span> ) , D3D12_DSV_DESCRIPTOR_HEAP = ( D3D12_RTV_DESCRIPTOR_HEAP + <span class="hljs-number"><span class="hljs-number">1</span></span> ) , D3D12_NUM_DESCRIPTOR_HEAP_TYPES = ( D3D12_DSV_DESCRIPTOR_HEAP + <span class="hljs-number"><span class="hljs-number">1</span></span> ) } D3D12_DESCRIPTOR_HEAP_TYPE;</code> </pre><br><br>  There is a heap type for CBV, SRV and UAV descriptors.  There are also types for working with render target views (RTV) and depth format views (DSV). <br>  The following code creates a bunch of descriptors for nine descriptors, each of which can be of type CBV, SRV, or UAV. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// create shader resource view and constant buffer view descriptor heap D3D12_DESCRIPTOR_HEAP_DESC descHeapCbvSrv = {}; descHeapCbvSrv.NumDescriptors = 9; descHeapCbvSrv.Type = D3D12_CBV_SRV_UAV_DESCRIPTOR_HEAP; descHeapCbvSrv.Flags = D3D12_DESCRIPTOR_HEAP_SHADER_VISIBLE; ThrowIfFailed(mDevice-&gt;CreateDescriptorHeap(&amp;descHeapCbvSrv, __uuidof(ID3D12DescriptorHeap), (void**)&amp;mCbvSrvDescriptorHeap));</span></span></code> </pre><br><br>  The first two entries in the heap description are the number of descriptors and the types of descriptors that can be on this heap.  The third parameter, <i>D3D12_DESCRIPTOR_HEAP_SHADER_VISIBLE,</i> describes this heap of descriptors as visible to the shader.  You can use heaps of descriptors that are invisible to the shader, for example, for intermediate storage of descriptors in the CPU or for RTV that are not available for selection from inside the shaders. <br>  This code sets a flag that causes a bunch of descriptors to become visible to the shader, but there is another level of indirect addressing.  A shader can ‚Äúsee‚Äù a bunch of descriptors through the descriptor table (there are also root descriptors that do not use tables; for more details, see below). <br><br><h2>  <font color="#0071c5">Descriptor tables</font> </h2><br>  The main purpose of the heap of descriptors is to allocate the necessary amount of memory to store all the descriptors for rendering in the greatest possible amount, say for one frame or more <br>  Note.  When switching between heaps of descriptors, cleaning of the GP conveyor can occur, depending on the equipment used.  Therefore, it is necessary to minimize operations for switching between heaps of descriptors or to combine them with other operations, in which the conveyor is still cleaned. <br><br>  The descriptor table points to a bunch of descriptors using offset.  Instead of forcing the graphics pipeline to always scan the entire heap, switching descriptor tables will allow you to change the set of resources used by this shader at no significant cost.  At the same time, the shader does not have to search for resources in the heap space. <br>  In other words, an application can use several descriptor tables pointing to the same heap for different shaders, as shown in Fig.  2 <br><br><img src="https://habrastorage.org/files/a94/142/de1/a94142de16d64e02bf312b020fba6adb.png"><br>  <i>Figure 2. Different shaders point to a bunch of descriptors using several descriptor tables</i> <br><br>  The following code example creates descriptor tables for the SRV and sampler that are visible to the pixel shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// define descriptor tables for a SRV and a sampler for pixel shaders D3D12_DESCRIPTOR_RANGE descRange[2]; descRange[0].Init(D3D12_DESCRIPTOR_RANGE_SRV, 1, 0); descRange[1].Init(D3D12_DESCRIPTOR_RANGE_SAMPLER, 1, 0); D3D12_ROOT_PARAMETER rootParameters[2]; rootParameters[0].InitAsDescriptorTable(1, &amp;descRange[0], D3D12_SHADER_VISIBILITY_PIXEL); rootParameters[1].InitAsDescriptorTable(1, &amp;descRange[1], D3D12_SHADER_VISIBILITY_PIXEL);</span></span></code> </pre><br><br>  At the same time, the descriptor table is visible only to the pixel shader;  This restriction is set using the <i>D3D12_SHADER_VISIBILITY_PIXEL</i> flag.  The following listing defines the different levels of descriptor table visibility. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> D3D12_SHADER_VISIBILITY { D3D12_SHADER_VISIBILITY_ALL = <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D12_SHADER_VISIBILITY_VERTEX = <span class="hljs-number"><span class="hljs-number">1</span></span>, D3D12_SHADER_VISIBILITY_HULL = <span class="hljs-number"><span class="hljs-number">2</span></span>, D3D12_SHADER_VISIBILITY_DOMAIN = <span class="hljs-number"><span class="hljs-number">3</span></span>, D3D12_SHADER_VISIBILITY_GEOMETRY = <span class="hljs-number"><span class="hljs-number">4</span></span>, D3D12_SHADER_VISIBILITY_PIXEL = <span class="hljs-number"><span class="hljs-number">5</span></span> } D3D12_SHADER_VISIBILITY;</code> </pre><br><br>  If you specify a flag that sets visibility to all, the arguments will be passed to all stages of the shader, although visibility is set only once. <br>  A shader can discover resources using descriptor tables, but first the shader must ‚Äúlearn‚Äù about these descriptor tables using the root parameter in the root signature. <br><br><h2>  <font color="#0071c5">Root Signature and Parameters</font> </h2><br>  The root signature stores the root parameters used by shaders to discover the resources to which access is required.  These parameters exist in the form of a binding space at the list of commands for a set of resources that the application must make available to shaders. <br>  Root arguments may be as follows. <br><ul><li>  Descriptor tables.  As described above, they contain an offset and the number of descriptors on the heap. </li><li>  Root Handles.  Directly in the root parameter, you can store only a small number of descriptors.  At the same time, the application no longer needs to place these descriptors on the heap of descriptors, indirect addressing is eliminated. </li><li>  Root constants.  These are constants provided by shaders directly, without the need to work with root descriptors and descriptor tables. </li></ul><br>  To achieve optimal performance, applications typically sort the root parameters by decreasing the frequency of changes. <br>  All root parameters, such as descriptor tables, root descriptors and root constants, are combined into a list of commands, and the driver will manage their versions on behalf of the application.  In other words, whenever any of the root parameters change in between the render or send calls, the hardware will update the version number of the root signature.  When any argument changes, each render or send call gets a unique complete set of root parameter states. <br>  Root descriptors and root constants reduce the level of indirect addressing of the GP upon access;  descriptor tables allow access to larger amounts of data, but the level of indirect addressing increases.  Due to the higher level of indirect addressing when using descriptor tables, the application can initialize the contents before sending the list of commands for execution.  In addition, the 5.1 shader model, supported by all DirectX 12 hardware, allows shaders to dynamically index all specified descriptor tables.  Therefore, the shader can select the desired descriptor from the descriptor table during the execution of the shader.  An application can simply create one large table of descriptors and always use an index (for example, using a material identifier) ‚Äã‚Äãto obtain the desired descriptor. <br><br>  The performance of different architectures may vary when using large sets of root constants and root descriptors compared to using descriptor tables.  For this reason, you need to optimally adjust the relationship between root parameters and descriptor tables, depending on the target hardware platforms. <br>  A perfectly balanced application can use a combination of all types of bindings: root constants, root descriptors, descriptor tables for descriptors received on the fly as rendering calls are made, and also dynamic indexing of large descriptors tables. <br><br>  In the following code, the two descriptor tables mentioned above are stored as root parameters in the root signature. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// define descriptor tables for a SRV and a sampler for pixel shaders D3D12_DESCRIPTOR_RANGE descRange[2]; descRange[0].Init(D3D12_DESCRIPTOR_RANGE_SRV, 1, 0); descRange[1].Init(D3D12_DESCRIPTOR_RANGE_SAMPLER, 1, 0); D3D12_ROOT_PARAMETER rootParameters[2]; rootParameters[0].InitAsDescriptorTable(1, &amp;descRange[0], D3D12_SHADER_VISIBILITY_PIXEL); rootParameters[1].InitAsDescriptorTable(1, &amp;descRange[1], D3D12_SHADER_VISIBILITY_PIXEL); // store the descriptor tables int the root signature D3D12_ROOT_SIGNATURE descRootSignature; descRootSignature.Init(2, rootParameters, 0); ComPtr&lt;ID3DBlob&gt; pOutBlob; ComPtr&lt;ID3DBlob&gt; pErrorBlob; ThrowIfFailed(D3D12SerializeRootSignature(&amp;descRootSignature, D3D_ROOT_SIGNATURE_V1, pOutBlob.GetAddressOf(), pErrorBlob.GetAddressOf())); ThrowIfFailed(mDevice-&gt;CreateRootSignature(pOutBlob-&gt;GetBufferPointer(), pOutBlob-&gt;GetBufferSize(), __uuidof(ID3D12RootSignature), (void**)&amp;mRootSignature));</span></span></code> </pre><br>  All shaders in the PSO must be compatible with the root signature specified with this PSO object;  otherwise, the PSO object will not be created. <br>  The root signature must be set for the list of commands or package.  To do this, we call: <br><br>  1 commandList-&gt; SetGraphicsRootSignature (mRootSignature); <br>  After setting the root signature, you need to define a set of bindings.  In the example above, this is done with the following code. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// set the two descriptor tables to index into the descriptor heap // for the SRV and the sampler commandList-&gt;SetGraphicsRootDescriptorTable(0, mCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); commandList-&gt;SetGraphicsRootDescriptorTable(1, mSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());</span></span></code> </pre><br>  The application must set the appropriate parameters in each of the two cells of the root signature before issuing a render call or a send call.  For example, in the first cell, there is now a handle to the marker that matches the index of a bunch of descriptors with the SRV handle, and in the second cell there is a table of descriptors that maps on the index a bunch of descriptors to the sampler handle. <br>  An application can change, for example, the binding of the second cell in the interval between rendering calls.  This means that the second render call requires only the binding of the second cell. <br><br><h2>  <font color="#0071c5">Putting the components together</font> </h2><br>  The large code snippet below shows all the mechanisms used to bind resources.  This application uses only one texture, and this code provides a sampler and SRV for this texture. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// define descriptor tables for a SRV and a sampler for pixel shaders D3D12_DESCRIPTOR_RANGE descRange[2]; descRange[0].Init(D3D12_DESCRIPTOR_RANGE_SRV, 1, 0); descRange[1].Init(D3D12_DESCRIPTOR_RANGE_SAMPLER, 1, 0); D3D12_ROOT_PARAMETER rootParameters[2]; rootParameters[0].InitAsDescriptorTable(1, &amp;descRange[0], D3D12_SHADER_VISIBILITY_PIXEL); rootParameters[1].InitAsDescriptorTable(1, &amp;descRange[1], D3D12_SHADER_VISIBILITY_PIXEL); // store the descriptor tables in the root signature D3D12_ROOT_SIGNATURE descRootSignature; descRootSignature.Init(2, rootParameters, 0); ComPtr&lt;ID3DBlob&gt; pOutBlob; ComPtr&lt;ID3DBlob&gt; pErrorBlob; ThrowIfFailed(D3D12SerializeRootSignature(&amp;descRootSignature, D3D_ROOT_SIGNATURE_V1, pOutBlob.GetAddressOf(), pErrorBlob.GetAddressOf())); ThrowIfFailed(mDevice-&gt;CreateRootSignature(pOutBlob-&gt;GetBufferPointer(), pOutBlob-&gt;GetBufferSize(), __uuidof(ID3D12RootSignature), (void**)&amp;mRootSignature)); // create descriptor heap for shader resource view D3D12_DESCRIPTOR_HEAP_DESC descHeapCbvSrv = {}; descHeapCbvSrv.NumDescriptors = 1; // for SRV descHeapCbvSrv.Type = D3D12_CBV_SRV_UAV_DESCRIPTOR_HEAP; descHeapCbvSrv.Flags = D3D12_DESCRIPTOR_HEAP_SHADER_VISIBLE; ThrowIfFailed(mDevice-&gt;CreateDescriptorHeap(&amp;descHeapCbvSrv, __uuidof(ID3D12DescriptorHeap), (void**)&amp;mCbvSrvDescriptorHeap)); // create sampler descriptor heap D3D12_DESCRIPTOR_HEAP_DESC descHeapSampler = {}; descHeapSampler.NumDescriptors = 1; descHeapSampler.Type = D3D12_SAMPLER_DESCRIPTOR_HEAP; descHeapSampler.Flags = D3D12_DESCRIPTOR_HEAP_SHADER_VISIBLE; ThrowIfFailed(mDevice-&gt;CreateDescriptorHeap(&amp;descHeapSampler, __uuidof(ID3D12DescriptorHeap), (void**)&amp;mSamplerDescriptorHeap)); // skip the code that uploads the texture data into heap // create sampler descriptor in the sample descriptor heap D3D12_SAMPLER_DESC samplerDesc; ZeroMemory(&amp;samplerDesc, sizeof(D3D12_SAMPLER_DESC)); samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_WRAP; samplerDesc.MinLOD = 0; samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; samplerDesc.MipLODBias = 0.0f; samplerDesc.MaxAnisotropy = 1; samplerDesc.ComparisonFunc = D3D12_COMPARISON_ALWAYS; mDevice-&gt;CreateSampler(&amp;samplerDesc, mSamplerDescriptorHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // create SRV descriptor in the SRV descriptor heap D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc; ZeroMemory(&amp;srvDesc, sizeof(D3D12_SHADER_RESOURCE_VIEW_DESC)); srvDesc.Format = SampleAssets::Textures-&gt;Format; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D; srvDesc.Texture2D.MipLevels = 1; mDevice-&gt;CreateShaderResourceView(mTexture.Get(), &amp;srvDesc, mCbvSrvDescriptorHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // writing into the command list // set the root signature commandList-&gt;SetGraphicsRootSignature(mRootSignature); // other commands here ... // set the two descriptor tables to index into the descriptor heap // for the SRV and the sampler commandList-&gt;SetGraphicsRootDescriptorTable(0, mCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); commandList-&gt;SetGraphicsRootDescriptorTable(1, mSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());</span></span></code> </pre><br><br><h2>  <font color="#0071c5">Static samplers</font> </h2><br>  So, we saw how to create a sampler using a heap of descriptors and a table of descriptors.  But there is another way to use samplers in the application.  Since many applications require only a limited set of samplers, static samplers can be used as the root argument. <br>  Currently, the root signature is as follows. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D3D12_ROOT_SIGNATURE</span></span></span><span class="hljs-class"> {</span></span> UINT NumParameters; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> D3D12_ROOT_PARAMETER* pParameters; UINT NumStaticSamplers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> D3D12_STATIC_SAMPLER* pStaticSamplers; D3D12_ROOT_SIGNATURE_FLAGS Flags; <span class="hljs-comment"><span class="hljs-comment">// Initialize struct void Init( UINT numParameters, const D3D12_ROOT_PARAMETER* _pParameters, UINT numStaticSamplers = 0, const D3D12_STATIC_SAMPLER* _pStaticSamplers = NULL, D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_NONE) { NumParameters = numParameters; pParameters = _pParameters; NumStaticSamplers = numStaticSamplers; pStaticSamplers = _pStaticSamplers; Flags = flags; } D3D12_ROOT_SIGNATURE() { Init(0,NULL,0,NULL,D3D12_ROOT_SIGNATURE_NONE);} D3D12_ROOT_SIGNATURE( UINT numParameters, const D3D12_ROOT_PARAMETER* _pParameters, UINT numStaticSamplers = 0, const D3D12_STATIC_SAMPLER* _pStaticSamplers = NULL, D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_NONE) { Init(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags); } } D3D12_ROOT_SIGNATURE;</span></span></code> </pre><br><br>  The set of static samplers can be defined independently of the root parameters in the root signature.  As mentioned above, the root parameters define the binding space, where you can provide arguments at runtime, while static samplers are by definition unchanged. <br>  Since root signatures can be created in HLSL, static samplers can also be created there.  Currently, an application can have no more than 2032 unique static samplers.  This is slightly less than the next power of two, and allows drivers to use some space for internal use. <br>  The static samplers defined in the root signature are independent of the samplers selected by the application to be placed in the heap of descriptors, so both mechanisms can be used simultaneously. <br><br>  If the sampler selection is completely dynamic and is unknown at the time of shader compilation, the application should manage the samplers in a heap of descriptors. <br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  DirectX 12 maintains full control over resource usage models.  The application developer is responsible for allocating memory in heaps of descriptors, for describing resources in descriptors, and for addressing a shader by index to heaps of descriptors through descriptor tables, which, in turn, are ‚Äúexpanded‚Äù for the shader using root signatures. <br>  Moreover, using root signatures, you can define a customizable parameter space for shaders using the following four types of components in any combination: <br><ul><li>  root constants; </li><li>  static samplers; </li><li>  root descriptors; </li><li>  descriptor tables. </li></ul><br>  The task is to select the desired form of binding for the respective types of resources and the frequency of their update. <br><br><h2>  <font color="#0071c5">Links and useful materials</font> </h2><br><ul><li>  <a href="http://blogs.msdn.com/b/directx/">Microsoft DirectX Blog</a> </li><li>  <a href="https://twitter.com/DirectX12">DirectX 12 on Twitter</a> </li><li>  <a href="https://software.intel.com/en-us/articles/console-api-efficiency-performance-on-pcs">Direct3D * 12 - efficiency and performance of console APIs on the PC</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/265525/">https://habr.com/ru/post/265525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265513/index.html">Creative attempt to hack the site: write on behalf of Roskomnadzor</a></li>
<li><a href="../265515/index.html">Unusual divorce under the guise of Roskomnadzor</a></li>
<li><a href="../265517/index.html">Making a paranoiac messenger on Webix and DataBoom</a></li>
<li><a href="../265519/index.html">Armory - plugin for IntelliJ IDEA</a></li>
<li><a href="../265523/index.html">Industrial video surveillance: we remove technological data from cameras and predict emergency situations</a></li>
<li><a href="../265527/index.html">Single-threaded Android WebView</a></li>
<li><a href="../265529/index.html">Basic principles of virtualization on the fingers</a></li>
<li><a href="../265531/index.html">Emacs: we train the cursor</a></li>
<li><a href="../265533/index.html">Dell ASM vs. Cisco UCS: How We Tested Infrastructure Automation</a></li>
<li><a href="../265537/index.html">OTRS 4.0.10. We put on Ubuntu + AD + Kerberos + SSO (Part Two)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>