<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go language: rehabilitation of imperative programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtually all modern programming languages ‚Äã‚Äãinclude object-oriented features in one form or another, however, the authors of the Go language tried to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go language: rehabilitation of imperative programming</h1><div class="post__text post__text-html js-mediator-article">  Virtually all modern programming languages ‚Äã‚Äãinclude object-oriented features in one form or another, however, the authors of the Go language tried to limit themselves to the imperative paradigm as much as possible.  This should not come as a surprise, considering that one of the authors of the language is <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25BE%25D0%25BC%25D0%25BF%25D1%2581%25D0%25BE%25D0%25BD,_%25D0%259A%25D0%25B5%25D0%25BD">Ken Thompson</a> (the developer of UNIX and C).  Such a strongly pronounced imperative language can introduce an experienced object-oriented programmer to some confusion and sow doubts about the possibility of solving modern problems in such a language. <br><br>  This article is designed to help programmers who are interested in Go, to understand the imperative features of the language.  In particular, help implement key design patterns.  In addition, there will be some interesting solutions implemented in Go itself, its standard library and toolkit, which will pleasantly surprise many. <br><a name="habracut"></a><br><h1>  Introduction: Types, Structures, and Variables </h1><br>  As in many imperative programming languages ‚Äã‚Äã(C / Algol / Pascal, etc.), structure is a key entity.  Structures are defined in Go as follows: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Email <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br>  In addition to structures, similarly, you can declare aliases: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserAlias User <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Number <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserName <span class="hljs-keyword"><span class="hljs-keyword">string</span></span></code> </pre><br>  To create a variable containing an instance of a structure, there are several ways to proceed: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var user0 User //       user1 := User{} //    user2 := make(User, 1) user3 := &amp;User{} //         nil var user4 *User</span></span></code> </pre><br>  The names of the structure fields during initialization can be omitted while maintaining the declaration sequence: <br><br><pre> <code class="go hljs">u1 := User{Name: <span class="hljs-string"><span class="hljs-string">"Jhon"</span></span>, Email: <span class="hljs-string"><span class="hljs-string">"jhon@example.or"</span></span>, Age: <span class="hljs-number"><span class="hljs-number">27</span></span>} u2 := User{<span class="hljs-string"><span class="hljs-string">"Jhon"</span></span>, <span class="hljs-string"><span class="hljs-string">"jhon@example.or"</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>}</code> </pre><br>  Since  Go has a built-in garbage collector, then there is no difference between the variables instantiated directly or via a link. <br>  The exit of the link from the zone of visibility does not lead to a memory leak, and the variable instantiated by value is not released if at least one link exists, including  out of scope. <br>  Those.  The following code is absolutely safe, even though similar constructions in C / C ++ can lead to fatal consequences: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Planet <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetThirdPlanetByRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Planet</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> planet Planet planet.Name = <span class="hljs-string"><span class="hljs-string">"Earth"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;planet } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetThirdPlanetByVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Planet</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> planet *Planet planet = &amp;Planet{Name: <span class="hljs-string"><span class="hljs-string">"Earth"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *planet }</code> </pre><br><br><h1>  Interfaces and anonymous fields instead of inheritance </h1><br>  There is no habitual inheritance in Go, however, if we consider inheritance as a transfer mechanism for <i>a) belonging to a certain type, b) passing certain behavior and c) transferring basic fields</i> , then anonymous fields and interfaces can be attributed to such inheritance mechanisms. <br><br>  Anonymous fields allow you to avoid duplication of field descriptions in structures.  So, for example, if there is a certain User structure, and based on this structure, you need to make some more specific: Buyer Buyer and Cashier cashier, then the fields for new structures can be borrowed from User as follows: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buyer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { User Balance <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> Address <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Cashier <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { User InsurenceNumber <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre><br>  Despite the fact that User is not related by ‚Äúfamily ties‚Äù and nothing will say that Buyer is an heir from User, the fields of the User structure will also be available in Buyer / Cashier. <br><br>  On the other hand, it is now necessary to implement methods for User / Buyer / Cashier separately, which is not very convenient, since  leads to gigantic duplication. <br>  Instead, methods that implement the same behavior can be converted to functions that take a common interface as an argument.  An example would be the method of sending a message to the SendMail mail (text string).  Since  the only thing that is required from each of the structures is Email, it is enough to make an interface with the requirement for the GetEmail method. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserWithEmail <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetEmail() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *UserWithEmail, text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { email := u.GetEmail() <span class="hljs-comment"><span class="hljs-comment">//    email } func main() { //  users      users := []UserWithMail{User{}, Buyer{}, Cashier{}} for _, u := range users { SendEmail(u, "Hello world!!!") } }</span></span></code> </pre><br><br><h1>  Encapsulation </h1><br>  There are no access modifiers in Go.  The availability of a variable, structure, or function depends on the identifier. <br>  Go exports only those entities whose identifier satisfies both conditions: <br><br><ol><li>  The identifier begins with a capital letter (Unicode class "Lu") </li><li>  The identifier is declared in the package block (that is, it is not nested anywhere), or is the name of a method or field </li></ol><br>  In other words, to hide an identifier it is enough to name it with a small letter. <br><br><h1>  Type Dispatch </h1><br>  In fact, Go has no ad-hoc polymorphism, no parametric polymorphism (i.e., Java generics and c ++ templates) and no explicit polymorphism of subtypes. <br>  In other words, it is impossible to define two functions with the same name and different signatures in the same module, as well as it is impossible to make a common method for different types. <br>  Those.  all of the following constructs in Go are illegal and lead to compilation errors: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { } <span class="hljs-comment"><span class="hljs-comment">//   "Foo redeclared in this block", ..    func Foo(value float64) { } type Base interface{ Method() } //   "invalid receiver type Base (Base is an interface type)", ..      func (b *Base) Method() { }</span></span></code> </pre><br>  However, Go has two mechanisms that allow you to emulate polymorphic behavior. <br>  This is, firstly, dynamic type dispatching, and secondly, duck typing. <br><br>  So any object in Go can be reduced to type interface {}, which allows passing variables of arbitrary type to the function: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Foo(<span class="hljs-number"><span class="hljs-number">123</span></span>) Foo(<span class="hljs-string"><span class="hljs-string">"abs"</span></span>) }</code> </pre><br>  Since  interface {} cannot have its own methods, then in order to return access to the type there is a special construction of the switch type: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> t := v.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   t   int case string: //   t   string default: //   } }</span></span></code> </pre><br><br><h1>  Variable Lifetime Management </h1><br>  In Go, there are no constructors and destructors.  In order to create an instance of a complex structure, special functions begin with New, for example: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, email </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, age </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;User{name, email, age} }</code> </pre><br>  The presence of such a constructor function does not limit the ability to create an instance of the structure directly.  However, this approach is used even in the standard Go library and helps to systematize code in large applications. <br><br>  Situations with destructors in Go are much more difficult, since  similar functionality similar to that found in C ++ cannot be fully implemented. <br><br>  If you need to release resources, you can make the Release method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Resource)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// release resources }</span></span></code> </pre><br><br>  Of course, this method will not be called by itself if the variable goes out of scope or in the case of an exception, as it does in C ++ (besides, there are no exceptions in Go).  In such situations, it is proposed to use the mechanism of <a href="http://blog.golang.org/defer-panic-and-recover">defer, panic and recover</a> .  For example, the Release method can be delayed using the defer directive: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { r := NewResource() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Release() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := r.DoSomething1(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := r.DoSomething2(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := r.DoSomething3(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } }</code> </pre><br>  This allows you to free up resources after calling the Foo function, regardless of the scenario. <br>  The behavior of defer is always predictable and is described by three rules: <br><br><ol><li>  Arguments of the deferred function are calculated at the moment when the defer structure is formed; </li><li>  Deferred functions are called in the order ‚Äúlast entered - first out‚Äù after returning the message of the framing function; </li><li>  Deferred functions can read and modify named return values. </li></ol><br>  As replacement of exceptions, the built-in <b>panic</b> and <b>recover</b> functions are: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"something is wrong"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Recovered in Bar: "</span></span>, r) } }() Bar() fmt.Prinln(<span class="hljs-string"><span class="hljs-string">"this message will not be printed on panic inside Bar"</span></span>) }</code> </pre><br>  Panic causes all framing functions to terminate, so the only way to stop the spread of panic is to call the recover () function.  By combining the use of defer-expressions and panic / recover functions, you can achieve the same security that is achieved in object-oriented languages ‚Äã‚Äãusing try / catch constructs.  In particular, to prevent the leakage of resources and the unexpected end of the program. <br><br>  If the moment of the destruction of an instance of a structure is unpredictable, then the only way in Go to release resources is to use the <b>SetFinalizer</b> function from the standard runtime package.  It allows you to catch the moment of release of the instance by the garbage collector. <br><br><h1>  Design Patterns </h1><br>  So, the described mechanisms allow solving the same problems as <i>inheritance, encapsulation, and polymorphism are</i> solved in object-oriented programming.  The presence of duck typing, coupled with interfaces, represents almost the same possibilities as regular inheritance in object-oriented languages.  This is well illustrated by the implementation of some key classic design patterns given below. <br><br><h2>  Singleton - Singleton </h2><br>  In Go, there is no static modifier, when a static variable is required, it is put into the package body.  The Singleton pattern is built on this decision in the simplest case: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Singleton <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//         var instance *Singleton func GetSingletonInstance() *Singleton { if instance == nil { instance = &amp;Singleton{} } return instance }</span></span></code> </pre><br><br><h2>  Abstract factory.  Factory method.  Builder - Abstract factory.  Factory method.  Builder </h2><br>  All three patterns are based on the implementation of some abstract interface that allows you to manage the creation of specific products through the implementation of their own methods, the creators.  The interface declaration might look like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AbstractProduct <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//   type AbstractFactory interface { CreateProduct1() AbstractProduct CreateProduct2() AbstractProduct } //   type AbstractCreator interface { FactoryMethod() AbstractProduct } //  type AbstractBuilder interface { GetResult() AbstractProduct BuildPart1() BuildPart2() }</span></span></code> </pre><br>  The implementation of one-to-one methods of concrete structures corresponds to the implementation in object-oriented programming. <br><br>  Examples can be viewed on github: <br><br>  <a href="">Abstract Factory</a> ; <br>  <a href="">Factory method</a> ; <br>  <a href="">The builder</a> . <br><br><h2>  Prototype - Prototype </h2><br>  Very often, the Prototype pattern is simply replaced with a superficial copy of the structure: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> struct{ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } func main(){ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">proto</span></span></span><span class="hljs-class"> := &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">{"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Hello</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">World</span></span></span><span class="hljs-class">!"} copied := &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">{} //   *copied = *proto if copied != proto { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Println</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copied</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span><span class="hljs-class">) } }</span></span></code> </pre><br><br>  In the general case, the problem is solved in the classical way, through the creation of an interface with the Clone method: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Prototype <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Clone() Prototype }</code> </pre><br><br>  An example implementation can be viewed on github: <a href="">Prototype</a> . <br><br><h2>  RAII </h2><br>  The use of the RAII pattern is complicated by the lack of a destructor, so in order to get a more or less acceptable behavior, you need to use the runtime.setFinalizer function to which the pointer to the method that releases the previously used resources is passed. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Resource <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resource</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//     runtime.SetFinalizer(r, Deinitialize) return r } func Deinitialize(r *Resource) { //    }</span></span></code> </pre><br><br>  Example of implementation: <br><br>  <a href="">RAII</a> . <br><br><h2>  Adapter.  Decorator.  Bridge.  Facade - Adapter.  Bridge.  Decorator.  Facade </h2><br>  All four patterns are very similar, are constructed in a similar way, so it suffices to give only the implementation of the adapter: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RequiredInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { MethodA() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Adaptee <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a *Adaptee)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Adapter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Impl Adaptee } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a *Adapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a.Impl.MethodB() }</code> </pre><br><br><h2>  Linker - Composite </h2><br>  The linker is even easier to implement, since  only two interfaces Composite (describing the structural behavior) and Component (describing the user functions) are sufficient: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Component <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetName() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Composite <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Add(c Component) Remove(c Component) GetChildren() []Component }</code> </pre><br>  An example of the implementation of the pattern: <a href="">Linker</a> . <br><br><h2>  Chain of responsibility </h2><br>  The pattern is very common in Go, though it is implemented mainly through anonymous handler functions.  They can be found in large numbers, for example, in the <a href="http://golang.org/src/pkg/net/">net / http</a> package of the standard library.  In the classic version, the pattern looks like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Handle(msg Message) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConcreteHandler <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { nextHandler Handler } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h *ConcreteHandler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg Message)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> == <span class="hljs-string"><span class="hljs-string">"special_type"</span></span> { <span class="hljs-comment"><span class="hljs-comment">// handle msg } else if next := h.nextHandler; next != nil { next.Handle(msg) } }</span></span></code> </pre><br><br>  Example implementation: <a href="">chain of responsibility</a> . <br><br><h1>  Nice features go </h1><br>  As it was shown, practically all classical design patterns can be reproduced in the language.  However, this is not the main advantage of the language.  Support for multithreading based on goroutine, data feeds between threads, support for anonymous functions and context closure, easy integration with C-libraries, as well as a powerful standard package library are also very important.  All this is worth a separate careful consideration, which of course goes beyond the scope of the article. <br><br>  No less surprising are other innovations in the language that relate more to the infrastructure of the language than to the language itself.  However, they will be appreciated by every experienced programmer. <br><br><h2>  Built-in package manager with git, hg, svn and bazaar support </h2><br>  In Go, everything is divided into packages, just like in Java, everything is divided into classes.  The main package, from which the program starts, should be called main.  Each package is usually a more or less independent part of the program, which is included in the main via import.  For example, to use the standard math package, just enter <b>import ‚Äúmath‚Äù</b> .  The repository address can also act as a package path.  A simple OpenGL program might look like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> glfw <span class="hljs-string"><span class="hljs-string">"github.com/go-gl/glfw3"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err glfw.ErrorCode, desc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v: %v\n"</span></span>, err, desc) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { glfw.SetErrorCallback(errorCallback) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !glfw.Init() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't init glfw!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> glfw.Terminate() window, err := glfw.CreateWindow(<span class="hljs-number"><span class="hljs-number">640</span></span>, <span class="hljs-number"><span class="hljs-number">480</span></span>, <span class="hljs-string"><span class="hljs-string">"Testing"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } window.MakeContextCurrent() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> !window.ShouldClose() { <span class="hljs-comment"><span class="hljs-comment">//Do OpenGL stuff window.SwapBuffers() glfw.PollEvents() } }</span></span></code> </pre><br><br>  In order to download all the dependencies, it is enough to run go get from the project directory. <br><br><h2>  Local Go documentation </h2><br>  It is always possible to read the documentation from the command line using the godoc command.  For example, to get a description of the Sin function from the math package, just enter the command godoc math sin: <br><br><pre> <code class="bash hljs">$ godoc math Sin func Sin(x float64) float64 Sin returns the sine of the radian argument x. Special cases are: Sin(¬±0) = ¬±0 Sin(¬±Inf) = NaN Sin(NaN) = NaN</code> </pre><br><br>  You can also run the golang.com server clone on the local machine, if the Internet for some reason was unavailable: <br><br><pre> <code class="bash hljs">$ godoc -http=:6060</code> </pre><br><br>  Read more about <a href="https://golang.org/cmd/godoc/">godoc</a> . <br><br><h2>  Refactoring and formatting from the command line </h2><br>  Sometimes it is required to make uniform changes in the code, for example, renaming with a pattern or correct homogeneous mathematical expressions.  For this, the gofmt tool is provided: <br><br><pre> <code class="hljs vbscript">gofmt -r <span class="hljs-comment"><span class="hljs-comment">'bytes.Compare(a, b) == 0 -&gt; bytes.Equal(a, b)'</span></span></code> </pre><br><br>  Replace all expressions of the form bytes.Compare (a, b) with bytes.Equal (a, b).  Even if the variables will be called differently. <br><br>  You can also use gofmt to simplify common expressions with the -s flag.  This flag is similar to the following substitutions: <br><br><pre> <code class="hljs go">[]T{T{}, T{}} -&gt; []T{{}, {}} s[a:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s)] -&gt; s[a:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, _ = <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> v {...} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> v {...}</code> </pre><br><br>  You can also use gofmt to save the code style in the project.  Read more about <a href="https://golang.org/cmd/gofmt/">gofmt</a> <br><br><h2>  Unit testing and benchmarks </h2><br>  Go comes with a special package for testing <a href="http://golang.org/pkg/testing/">testing</a> .  To create tests for the package, it is enough to make the file of the same name with the suffix "_testing.go".  All tests and benchmarks start with Test or Bench: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestTimeConsuming</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> testing.Short() { t.Skip(<span class="hljs-string"><span class="hljs-string">"skipping test in short mode."</span></span>) } ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) } }</code> </pre><br><br>  To run the tests, use the go test utility.  Using it, you can run tests, measure coverage, run benchmarks, or run a pattern test.  Using the example of the <a href="https://github.com/kreshikhin/gopatterns">gopatterns</a> project created to describe and check the patterns of this article, it looks like this: <br><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v === RUN TestAbstractFactory --- PASS: TestAbstractFactory (0.00 seconds) === RUN TestBuilder --- PASS: TestBuilder (0.00 seconds) === RUN TestChain --- PASS: TestChain (0.00 seconds) === RUN TestComposite --- PASS: TestComposite (0.00 seconds) === RUN TestFactoryMethod --- PASS: TestFactoryMethod (0.00 seconds) === RUN TestPrototype --- PASS: TestPrototype (0.00 seconds) === RUN TestRaii --- PASS: TestRaii (1.00 seconds) === RUN TestSingleton --- PASS: TestSingleton (0.00 seconds) PASS ok gopatterns 1.007s $ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -cover PASS coverage: 92.3% of statements <span class="hljs-variable"><span class="hljs-variable">$go</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run <span class="hljs-string"><span class="hljs-string">"Raii"</span></span> === RUN TestRaii --- PASS: TestRaii (1.00 seconds) PASS ok gopatterns 1.004s</code> </pre><br><br><h1>  Conclusion </h1><br>  So, despite the fact that Go and is built on an imperative paradigm, nevertheless, it has enough funds to implement the classic design patterns.  In this regard, it is not inferior to popular object-oriented languages.  At the same time, such things as the built-in package manager, support for unit tests at the level of the infrastructure of the language, the built-in means of refactoring and documenting the code noticeably distinguish the language among competitors, since  such things are usually implemented by the community. <br><br>  All this, even without looking at the goroutine, channels, interface with native libraries. <br><br>  In general, Go showed that imperative and structured programming does not go down in history.  A modern language that meets the main trends in software development can be built on the basis of an imperative paradigm, no worse than on the basis of an object-oriented or functional paradigm. </div><p>Source: <a href="https://habr.com/ru/post/240917/">https://habr.com/ru/post/240917/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240907/index.html">Blend4Web, an open platform for creating three-dimensional web applications</a></li>
<li><a href="../240909/index.html">Symfony2 Step Form with SyliusFlowBundle</a></li>
<li><a href="../240911/index.html">Missing maps: as a human genome decoding project, only for cities</a></li>
<li><a href="../240913/index.html">Virtual networks: VXLAN and VMware NSX</a></li>
<li><a href="../240915/index.html">We are preparing Debian to transfer the clock October 26, 2014</a></li>
<li><a href="../240919/index.html">Project management tools and methodology on the example of a startup pivot</a></li>
<li><a href="../240921/index.html">Verve 2: an electronic designer of smart devices for beginners + the opportunity to learn the basics of electronics</a></li>
<li><a href="../240923/index.html">Features of the reflection of DDoS attacks and the history of attacks on one large bank</a></li>
<li><a href="../240927/index.html">Update 3! A series of 24 laboratory work on the development, testing and lifecycle management software for Visual Studio 2013</a></li>
<li><a href="../240929/index.html">How CPU works: an interactive tutorial for beginners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>