<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript tail recursion emulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If someone else doesn‚Äôt know what tail recursion is, here‚Äôs a simple example of a method that adds natural numbers from 1 to n (n‚â•0) in the forehead: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript tail recursion emulation</h1><div class="post__text post__text-html js-mediator-article">  If someone else doesn‚Äôt know what tail recursion is, here‚Äôs a simple example of a method that adds natural numbers from 1 to n (n‚â•0) in the forehead: <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n,acc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n===<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,acc+n); }</code> </pre> <br>  Initially, the function is called with the parameter acc = 0.  If n is not zero, the method calls itself with other parameters and returns the result.  The compiler (or interpreter, or virtual machine) can understand that the current function call in the stack is no longer needed, erase it and replace it with the next one.  Thus, recursion does not cause stack growth.  Strictly speaking, a tail call is not required to refer to the current function: any other call can also be a tail call.  The main condition: calling a function and returning its result must be the last actions in the current function.  For example, in such an implementation of the tail-recursion method there is no, because after the call, addition is still happening: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n===<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n+add(n<span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre> <br>  For a number of reasons, tail recursion is not supported in JavaScript (discussion on this topic is on <a href="http://stackoverflow.com/questions/3660577/are-any-javascript-engines-tail-call-optimized">StackOverflow</a> ).  Therefore, a call like add (100000.0) ends with an exception.  At Habr√© <a href="http://habrahabr.ru/post/167033/">attempts</a> were <a href="http://habrahabr.ru/post/167033/">made</a> to solve this problem through setTimeout, but it does not look very fair and not very beautiful.  A more elegant solution for the Python language was <a href="http://habrahabr.ru/post/158385/">proposed</a> using the " <a href="http://en.wikipedia.org/wiki/Tail_call">springboard</a> ".  A similar approach for javascript is reviewed <a href="http://www.eriwen.com/javascript/cps-tail-call-elimination/">here</a> .  But I wanted it to work quickly and so that the function could be written just like in the example above.  See what you can do. <br><a name="habracut"></a><br>  In this article we will consider a limited, but rather popular case, when a function calls the tail method only to itself (it can call any other functions, but their calls will not be optimized).  Thus, instead of calling again, you just need to replace the values ‚Äã‚Äãof the arguments with new ones and go to the beginning of the current function.  There is no goto operator in JavaScript, but you can always wrap a function in such a block: <br><pre> <code class="javascript hljs">$tail$label:<span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { &lt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Then go to the beginning of the function using <code>continue $tail$label</code> .  How to replace a function call with such a transition?  The easy way that came to mind is to replace the function of another, which throws an exception.  Then you can catch it and rewrite the parameters.  It will look something like this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n,acc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n===<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,acc+n); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>($tail$ex) { n = $tail$ex[<span class="hljs-number"><span class="hljs-number">0</span></span>]; acc = $tail$ex[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } }</code> </pre>  As you can see, instead of ourselves, we now call a nested function that throws an exception.  We gracefully catch it, rewrite the arguments and move on to the next iteration of the loop (even the label was not useful). <br><br>  But I don‚Äôt want to write this every time, the task was simply to write.  How to remake a simple function in this?  We decompile the source code of the function (using toString), correct it and compile it back using eval like this: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.prototype.tail = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> funcStr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.toString.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramsPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">'('</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramsEndPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">')'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyEndPos = funcStr.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = funcStr.substring(<span class="hljs-string"><span class="hljs-string">"function"</span></span>.length, paramsPos).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s*/g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = funcStr.substring(paramsPos+<span class="hljs-number"><span class="hljs-number">1</span></span>, paramsEndPos).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s*/g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = funcStr.substring(bodyPos+<span class="hljs-number"><span class="hljs-number">1</span></span>, bodyEndPos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramPassString = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;args.length; i++) paramPassString += args[i]+<span class="hljs-string"><span class="hljs-string">"=$tail$ex["</span></span>+i+<span class="hljs-string"><span class="hljs-string">"];"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newBody = <span class="hljs-string"><span class="hljs-string">"function "</span></span>+name+<span class="hljs-string"><span class="hljs-string">"() {throw arguments;} while(true) {try{"</span></span>+body+ <span class="hljs-string"><span class="hljs-string">"return;}catch($tail$ex) {"</span></span>+paramPassString+<span class="hljs-string"><span class="hljs-string">"}}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"var $tail$function = function "</span></span>+name+<span class="hljs-string"><span class="hljs-string">"("</span></span>+args.join(<span class="hljs-string"><span class="hljs-string">","</span></span>)+<span class="hljs-string"><span class="hljs-string">") {\n"</span></span>+ newBody+<span class="hljs-string"><span class="hljs-string">"};$tail$function"</span></span>); }</code> </pre> <br><br>  First, in the source text of the function, its name, arguments and body are searched.  Then additional lines are generated before and after the body, after which everything is going back to the function.  This approach has the following limitations: <br><ul><li>  The function must have a name; </li><li>  The function should call itself exclusively in the tail mode; </li><li>  The call itself should not be in the try-catch block (in principle, this follows from the previous one). </li></ul><br>  Thus, while add (100000.0) drops, add.tail () (100000.0) counts everything perfectly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what is the price of such a decision?  For ease of profiling, add a time function to the Function prototype: <br><div class="spoiler">  <b class="spoiler_title">Function.prototype.time = function (n) {...}</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.prototype.time = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(ex) { error = ex; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()-start; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> funcStr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.toString.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyEndPos = funcStr.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = funcStr.substring(bodyPos+<span class="hljs-number"><span class="hljs-number">1</span></span>, bodyEndPos).replace(<span class="hljs-regexp"><span class="hljs-regexp">/^\s*/</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s*$/</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Code: "</span></span>+body+<span class="hljs-string"><span class="hljs-string">"; error: "</span></span>+error+<span class="hljs-string"><span class="hljs-string">"; time="</span></span>+time/n); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Code: "</span></span>+body+<span class="hljs-string"><span class="hljs-string">"; result: "</span></span>+result+<span class="hljs-string"><span class="hljs-string">"; time="</span></span>+time/n); }</code> </pre> </div></div><br>  The function takes as the argument the number of starts and averages the time.  Let's add such tests: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addTail = add.tail(); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>);</code> </pre> <br>  Now run all this stuff in Google Chrome 25 and see a disappointing result: <br><pre> <code class="hljs pgsql">Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); result: <span class="hljs-number"><span class="hljs-number">50005000</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.102</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); error: RangeError: Maximum <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> stack size exceeded; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.162</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); result: <span class="hljs-number"><span class="hljs-number">50005000</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">2.392</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); result: <span class="hljs-number"><span class="hljs-number">5000050000</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">24.826</span></span></code> </pre> <br>  Although we are no longer limited to the number of iterations, but the performance decrease of 24 times cannot please.  What else can be done? <br><br>  To do without obviously slow things (exceptions and arguments appeals), you have to get into the very body of the function that we are changing.  Here, of course, ideally, you should write a JavaScript parser (you can <a href="">use jslint.js</a> ).  But to illustrate the idea, regular expressions will also go, although they will require code in a certain format. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.prototype.tail2 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> funcStr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.toString.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramsPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">'('</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paramsEndPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">')'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyPos = funcStr.indexOf(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyEndPos = funcStr.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = funcStr.substring(<span class="hljs-string"><span class="hljs-string">"function"</span></span>.length, paramsPos).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s*/g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = funcStr.substring(paramsPos+<span class="hljs-number"><span class="hljs-number">1</span></span>, paramsEndPos).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s*/g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = funcStr.substring(bodyPos+<span class="hljs-number"><span class="hljs-number">1</span></span>, bodyEndPos); body = body.replace(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">"return\\s+"</span></span>+name+<span class="hljs-string"><span class="hljs-string">"\\s*\\((.+?)\\);"</span></span>, <span class="hljs-string"><span class="hljs-string">"g"</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">match,argsStr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passArgs = argsStr.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;args.length; i++) result+=<span class="hljs-string"><span class="hljs-string">"var $tail$arg"</span></span>+i+<span class="hljs-string"><span class="hljs-string">"="</span></span>+passArgs[i]+<span class="hljs-string"><span class="hljs-string">";"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;args.length; i++) result+=args[i]+<span class="hljs-string"><span class="hljs-string">"="</span></span>+<span class="hljs-string"><span class="hljs-string">"$tail$arg"</span></span>+i+<span class="hljs-string"><span class="hljs-string">";"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{"</span></span>+result+<span class="hljs-string"><span class="hljs-string">"continue $tail$label;}"</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newBody = <span class="hljs-string"><span class="hljs-string">"$tail$label:while(true) {"</span></span>+body+<span class="hljs-string"><span class="hljs-string">"return;}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"var $tail$function = function "</span></span>+name+<span class="hljs-string"><span class="hljs-string">"("</span></span>+args.join(<span class="hljs-string"><span class="hljs-string">","</span></span>)+<span class="hljs-string"><span class="hljs-string">") {"</span></span>+newBody+<span class="hljs-string"><span class="hljs-string">"};$tail$function"</span></span>); }</code> </pre> <br>  Here we make every occurrence of a string like <code>return &lt; &gt;(val1, val2, ..., valN)</code> into a block, where we assign new values ‚Äã‚Äãto the arguments through intermediate variables, and then call continue.  At once I will make a reservation that the code is very naive and will easily break if you have additional brackets or, for example, the?: Operator in the return expression. <br><br>  Test: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addTail2 = add.tail2(); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail2(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail2(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)}).time(<span class="hljs-number"><span class="hljs-number">500</span></span>);</code> </pre>  The results are impressive: <br><pre> <code class="hljs pgsql">Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail2(<span class="hljs-number"><span class="hljs-number">10000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); result: <span class="hljs-number"><span class="hljs-number">50005000</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.022</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addTail2(<span class="hljs-number"><span class="hljs-number">100000</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); result: <span class="hljs-number"><span class="hljs-number">5000050000</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.222</span></span></code> </pre> <br>  It has become even faster than the original!  Of course, now we save on function calls. <br><br>  What else to test?  Take the original function to find the Fibonacci numbers from the <a href="http://www.eriwen.com/javascript/cps-tail-call-elimination/">above article</a> : <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpsFib</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, prev, cur, _return</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _return(cur); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFib(--n, cur, cur + prev, _return); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpsFibTail = cpsFib.tail(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpsFibTail2 = cpsFib.tail2(); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFib(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, identity)}).time(<span class="hljs-number"><span class="hljs-number">5000</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFibTail(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, identity)}).time(<span class="hljs-number"><span class="hljs-number">5000</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFibTail2(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, identity)}).time(<span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Results: <br><pre> <code class="hljs pgsql">Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFib(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>); result: <span class="hljs-number"><span class="hljs-number">2.159968028316171e+271</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.0222</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFibTail(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>); result: <span class="hljs-number"><span class="hljs-number">2.159968028316171e+271</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.3436</span></span> Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFibTail2(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>); result: <span class="hljs-number"><span class="hljs-number">2.159968028316171e+271</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.0036</span></span></code> </pre> <br>  If we take the implementation from the article, it will turn out like this: <br><pre> <code class="hljs pgsql">Code: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpsFib.tco(<span class="hljs-number"><span class="hljs-number">1300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>); result: <span class="hljs-number"><span class="hljs-number">2.159968028316171e+271</span></span>; <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.187</span></span></code> </pre> <br>  Faster than our version with exceptions, but still 8 times slower than the usual recursive form and 52 times slower than our optimized form. <br><br>  I do not know whether such things can be useful in real projects, but for fun, why not.  In any case, you should pay attention to the possibility of regeneration of JavaScript source code.  This is usually used by viruses and obfuscators, but it is likely that this tool can also be used for other purposes. </div><p>Source: <a href="https://habr.com/ru/post/173447/">https://habr.com/ru/post/173447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173431/index.html">Zpower: ultra compact? ultra expensive!</a></li>
<li><a href="../173433/index.html">Development Prospects: Singularity and "Reasonable Governance"</a></li>
<li><a href="../173437/index.html">Creating a single Exchange Address Book for two or more Active Directory forests</a></li>
<li><a href="../173443/index.html">Cacti: Monitoring SMART</a></li>
<li><a href="../173445/index.html">Russian look at Tech Peaks: how to get the opportunity to run your startup in Trento</a></li>
<li><a href="../173453/index.html">Git for Photos. Large Git Repositories</a></li>
<li><a href="../173455/index.html">Poll on the specifics of testing when developing applications for Android?</a></li>
<li><a href="../173459/index.html">Tumbler Sites, or Welcome to the FailOver Conference on April 4</a></li>
<li><a href="../173461/index.html">We return privacy or big brother watching me on the standard settings. Part 1. Browser and Google services settings</a></li>
<li><a href="../173463/index.html">The price of skeletons in the closet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>