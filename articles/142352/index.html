<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The most correct safe printf</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the cut, you will find a fascinating story about how I was very upset, getting to know the user literals (from the new standard), but at the sam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The most correct safe printf</h1><div class="post__text post__text-html js-mediator-article">  Under the cut, you will find a fascinating story about how I was very upset, getting to know the user literals (from the new standard), but at the same time I still implemented the above function, and also figured out the <b>constexpr</b> , and later also rehabilitated those literals . <a name="habracut"></a><br><br><h4>  Story </h4><br>  Back in 2009, myths about upcoming user literals appeared that allow you to do absolutely everything, namely, parsing a string at compile time.  (By the way, thanks to <a href="http://habrahabr.ru/users/ikalnitsky/" class="user_link">ikalnitsky</a> for the <a href="http://habrahabr.ru/post/140357/">appetite</a> - I recommend to look before reading.) I mean their version, which is with the template.  But it was not there.  The patterned implementation is allowed for digital literals only.  This means that during the compilation in this way you can only parse the numbers. <br><br><h4>  The plot.  First steps towards a solution </h4><br>  Then I was upset.  But googling, I learned that it is possible to parse a string without templates during compilation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, part of the solution to safe <b>printf</b> . <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormatSupportedType</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SUPPORTED_TYPE(C, T) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; struct FormatSupportedType&lt; T &gt; { \ constexpr static bool supports(char c) { return c == C; } } SUPPORTED_TYPE('c', char); SUPPORTED_TYPE('d', int); template&lt; std::size_t N &gt; constexpr bool checkFormatHelper(const char (&amp;format)[N], std::size_t current) { return current &gt;= N ? true : format[current] != '%' ? checkFormatHelper( format, current + 1 ) : format[current + 1] == '%' ? checkFormatHelper( format, current + 2 ) : false; } template&lt; std::size_t N, class T, class... Ts &gt; constexpr bool checkFormatHelper(const char (&amp;format)[N], std::size_t current, const T&amp; arg, const Ts &amp; ... args) { return current &gt;= N ? false : format[current] != '%' ? checkFormatHelper( format, current + 1, arg, args... ) : (format[current] == '%' &amp;&amp; format[current + 1] == '%') ? checkFormatHelper( format, current + 2, arg, args... ) : FormatSupportedType&lt; T &gt;::supports(format[current + 1]) &amp;&amp; checkFormatHelper( format, current + 2, args... ); } template&lt; std::size_t N, class... Ts &gt; constexpr bool checkFormat(const char (&amp;format)[N], const Ts &amp; ... args) { return checkFormatHelper( format, 0, args... ); } int main() { static_assert( checkFormat("%c %d\n", 'v', 1), "Format is incorrect" ); }</span></span></span></span></code> </pre> <br>  The logic of the work, I think, is very clear: we look through the possible options and, depending on the relationship between types and characters, we return the result.  To check for the existence of support and symbol compliance, an additional class is used.  As a result, at compile time we can verify the format correctness (if it is of course known at the compilation stage).  Next, using the classic <b>printf</b> print the result. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">safe_printf</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> (&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">format</span></span></span><span class="hljs-class">)[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( checkFormat(format, args... ), <span class="hljs-string"><span class="hljs-string">"Format is incorrect"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( format, args... ); }</code> </pre><br>  But my gcc-4.7 does not want to eat it!  I suddenly decided to be upset again, but the inspiration came.  To go further we need to understand <b>constexpr</b> .  Below, I think the most interesting part of the article. <br><br><h4>  The climax.  Understanding <b>constexpr</b> </h4><br>  What happened before?  There used to be a compilation stage and an execution stage, it should also be noted (although everyone knows this) that typing occurs at the compilation stage. <br>  What is now?  Now there is <b>constexpr</b> , which allows you to perform functions at the compilation stage - some kind of pun comes out.  We need to introduce clarifying definitions: we will consider not just compilation and execution, but compilation and execution of specific parts of the program (in our case, functions, because it is still possible to use objects during compilation).  For example, ‚Äúcompilation of function f‚Äù, ‚Äúexecution time of function f‚Äù, ‚Äúcompilation of the whole project‚Äù, ‚Äúproject execution time‚Äù. <br>  That is, now the compilation stage of the entire project has crashed on compiling and executing various project units.  Consider an example <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> N + n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = f&lt;i0&gt;(i0); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = f&lt;i1&gt;(i1); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(i2 == <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre><br>  At once I will say that it compiles <s>but does nothing useful</s> .  Let's take a closer look at the process of compiling the function <b>main ()</b> .  First, the variable <b>i0 is</b> assigned a value, then this variable is used to calculate the value of the variable <b>i1</b> , but in order to calculate it we need to execute the function <b>f &lt;i0&gt; (i0)</b> , but for this we need to compile it, and for compilation it needs the value <b>i0</b> .  Similarly with <b>f &lt;i1&gt; (i1)</b> .  That is, we have the following: The process of compiling the function <b>main ()</b> contains a sequential compilation of the function <b>f &lt;1&gt; (int)</b> , then its execution, then a compilation of the function <b>f &lt;2&gt; (int)</b> , and, accordingly, its execution. <br>  What happens?  The function designated as <b>constexpr</b> behaves like the most common function.  Let's look at the function <b>f</b> : <b>N</b> known at the stage of its compilation, and <b>n</b> - at the stage of its execution. <br><br><h4>  The outcome.  Implementing a secure <b>printf</b> </h4><br>  That's why it didn't want to compile! <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">safe_printf</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">format</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( checkFormat(format, args... ), <span class="hljs-string"><span class="hljs-string">"Format is incorrect"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( format, args... ); }</code> </pre><br>  <b>static_assert is</b> resolved at the compilation stage of the <b>safe_printf</b> function, and the <b>format</b> will be known only at the time of its execution (even if for some other thing at this moment there is a compilation stage). <br>  And how to get around this?  Neither how, or insert the format characters into the template parameters so that they are visible at the compilation stage (and as we remember, using custom literals does not allow for this) or recall that when all super cool, powerful and invincible C + tools + (and even C ++ 11) become helpless, macros appear on the scene! <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> safe_printf(FORMAT, ...) \ static_assert(checkFormat( FORMAT, __VA_ARGS__ ), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Format is incorrect"</span></span></span><span class="hljs-meta">); \ printf(FORMAT, __VA_ARGS__) int main() { safe_printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%c %d\n"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'v'</span></span></span><span class="hljs-meta">, 1); }</span></span></code> </pre><br>  Victory! <br><br><h4>  Decoupling - what really happened or shove unpicked </h4><br>  As usual, we first show a happy ending, and then how it all turned out.  Below is the correct implementation of a secure <b>printf</b> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateLiteral</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... FORMAT, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">safe_printf_2</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateLiteral</span></span></span><span class="hljs-class">&lt;FORMAT...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> format[] = {FORMAT... , <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( checkFormat(format, args... ), <span class="hljs-string"><span class="hljs-string">"Format is incorrect"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( format, args... ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ safe_printf_2(_(<span class="hljs-string"><span class="hljs-string">"%c %d\n"</span></span>), <span class="hljs-string"><span class="hljs-string">'v'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br>  That is, a variable is passed to the function, the TYPE of which is of interest to us (and NOT the value), and the arguments that need to be output.  It remains to implement a mechanism for turning a literal into a template.  Ideally, it would be cool if in the context in which there is a literal there would still be a <a href="http://en.wikipedia.org/wiki/Variadic_template">pack of</a> indices for this literal (something like enumerate), so that it could be repacked later, that is, <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>... INDXs &gt; <span class="hljs-comment"><span class="hljs-comment">//... TemplateLiteral&lt;"some literal"[INDXs]...&gt; //...</span></span></code> </pre><br>  But the length of the literal and the length of the <b>pack</b> 'a must match, and since the <b>pack</b> can only be entered from the outside, then the literal must be passed outside, and if it is passed outside (but there is NO mechanism to insert it into the template as a parameter), then it is passed as simple the function argument is therefore not known at the compilation stage of the function in which it should wrap itself in the template, since templates are types, and types are compilation - in short, it is impossible. <br>  But remember again about macros.  You can ask <b>boost :: preprocessor to</b> generate a list of numbers.  Of course, their number will be static, and it can only be changed at the preprocessing stage.  It is also necessary to provide that the taking of an element by index from the literal at the compilation stage is controlled; therefore, it is necessary to provide some kind of protective mechanism, and, also, it will be necessary to clean the end of the line.  It is also necessary to check whether the string is all captured, i.e.  Has the programmer entered a literal that is too long?  Below is the code. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateLiteral</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//       ; //      ,    template&lt; std::size_t LEN, char CHAR, char... CHARS &gt; struct TemplateLiteralTrim { private: //      //   - ,       template&lt; bool, class, char... &gt; struct Helper; template&lt; char... C1, char... C2 &gt; struct Helper&lt; false, TemplateLiteral&lt;C1...&gt;, C2... &gt; { //  , static_assert(sizeof...(C1) == LEN, "Literal is too large"); typedef TemplateLiteral&lt;C1...&gt; Result; }; template&lt; char... C1, char c1, char c2, char... C2 &gt; struct Helper&lt; true, TemplateLiteral&lt;C1...&gt;, c1, c2, C2... &gt; { typedef typename Helper&lt; (bool)c2, TemplateLiteral&lt;C1..., c1&gt;, c2, C2...&gt;::Result Result; }; public: typedef typename Helper&lt;(bool)CHAR, TemplateLiteral&lt;&gt;, CHAR, CHARS..., '\0' &gt;::Result Result; }; template&lt; class T, std::size_t N &gt; constexpr inline std::size_t sizeof_literal( const T (&amp;)[N] ) { return N; } //      N-   template&lt; std::size_t M &gt; constexpr inline char getNthCharSpec( std::size_t N, const char (&amp;literal)[M] ) { return N &lt; M ? literal[N] : '\0'; } #define GET_Nth_CHAR_FOR_PP(I, N, LIT) ,getNthCharSpec(N, LIT) //      //      , // -      , //    #define TEMPLATE_LITERAL_BASE(MAX, LIT) \ (typename TemplateLiteralTrim&lt; sizeof_literal(LIT) - 1 \ BOOST_PP_REPEAT(MAX, GET_Nth_CHAR_FOR_PP, LIT) &gt;::Result()) // MAX_SYM         #define TEMPLATE_LITERAL(LITERAL) TEMPLATE_LITERAL_BASE(MAX_SYM, LITERAL) int main() { //  safe_printf_2(TEMPLATE_LITERAL("%c %d\n"), 'v', 2); }</span></span></code> </pre><br>  By the way, it was very interesting for me to look at <b>boost :: preprocessor</b> - I didn‚Äôt imagine what they could do (such as arithmetic operations).  So macros are really terrible power. <br><br><h4>  Unreleased frames.  Rehabilitation of user literals </h4><br>  The time has come to show why I started to respect them (literals).  Once upon a time, about two years ago, I learned about tuples.  They seemed to me very comfortable, BUT the tuples were from Python, Nemerl and Haskell.  And when I found out about C ++ tuples, I was very upset with <b>std :: get &lt;N&gt; (tuple)</b> - fu as cumbersome, I thought, and since then I wanted to develop a mechanism for getting the element, but through the operator of square brackets.  And this is where custom literals came to the rescue. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number2Type</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tupless</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tupless</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">):</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts...&gt;(args...) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N &gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](Number2Type&lt;N&gt;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts...&gt;())) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N &gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](Number2Type&lt;N&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts...&gt;())) &amp; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chars_to_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>)[N], <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> current = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> acc = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (current &gt;= N || <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[current] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? acc : chars_to_int(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, current + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> * acc + <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[current] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Cs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>() -&gt; Number2Type&lt;chars_to_int((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Cs)]){Cs..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>})&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; <span class="hljs-comment"><span class="hljs-comment">//      }; int main() { tupless&lt;char, int, float&gt; t('x', 10, 12.45); safe_printf_2(TEMPLATE_LITERAL("%c %d %f"), t[0_t], t[1_t], t[2_t]); }</span></span></code> </pre><br>  What's so interesting?  Well, first of all, in order not to write the type twice, which returns a literal (namely, the type is interesting to us), an empty initialization list was used, and the compiler will try to bring it to an object of the desired type and insert the constructor there itself. <br>  This user literal is very interesting because its type is directly dependent on the value, i.e.  for example, the literal type <b>2_t</b> would be <b>Number2Type &lt;2&gt;</b> .  So here, I hope everyone will be comfortable. <br>  It would, of course, be nice to add it to the standard library ... <br><br>  <b>UPDATE:</b> it is better to <a href="http://habrahabr.ru/post/142352/">use the function</a> instead of the macro. <br><br>  <b>UPDATE:</b> Transfer the topic to "Abnormal programming", I think it will be more comfortable here. </div><p>Source: <a href="https://habr.com/ru/post/142352/">https://habr.com/ru/post/142352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142347/index.html">GeoIP and Django</a></li>
<li><a href="../142348/index.html">Google Earth adds pictures from balloons</a></li>
<li><a href="../142349/index.html">Terraria: or write games correctly</a></li>
<li><a href="../142350/index.html">* .Docx templates using Groovy scriptlets</a></li>
<li><a href="../142351/index.html">Functional programming for all</a></li>
<li><a href="../142353/index.html">What should we build a ‚Äúsmart‚Äù product?</a></li>
<li><a href="../142356/index.html">Project Lombok, or declare war on a boilerplate</a></li>
<li><a href="../142358/index.html">How to get money from an investor without an iron and a rubber truncheon?</a></li>
<li><a href="../142359/index.html">NFC + metronchiki = great benefit</a></li>
<li><a href="../142360/index.html">Management of sharing and likes on Khabryaks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>