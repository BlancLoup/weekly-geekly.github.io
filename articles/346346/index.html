<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 5: Custom Logins (Edition 2018)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="blog.miguelgrinberg.com 
 Miguel grinberg 



 <<< previous next >>> 


 This article is a translation of the fifth part of the new edition of Miguel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 5: Custom Logins (Edition 2018)</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="http://blog.miguelgrinberg.com/" title="blog.miguelgrinberg.com">blog.miguelgrinberg.com</a> </p><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p>  <a href="https://habrahabr.ru/post/346344/">&lt;&lt;&lt; previous</a> <a href="https://habrahabr.ru/post/346348/">next &gt;&gt;&gt;</a> </p><br><p>  This article is a translation of the fifth part of the new edition of Miguel Greenberg‚Äôs textbook, the issue of which the author plans to complete in May 2018. <a href="https://habrahabr.ru/post/193242/" title="Previous translation">The previous translation</a> has long since lost its relevance. </p><br><hr><br><p>  This is the fifth edition of the Flask Mega-Tutorial series, in which I will tell you how to create a user login subsystem. </p><a name="habracut"></a><br><p>  For reference, below is a list of articles in this series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/topic/edit/346346/"><strong>Chapter 5: User Logins (This article)</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354322/"><strong>Chapter 21: User Notifications</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354752/"><strong>Chapter 22: Background Tasks</strong></a> </li><li>  <a href="https://habrahabr.ru/post/358152/"><strong>Chapter 23: Application Programming Interfaces (APIs)</strong></a> </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work on this blog, or simply do not have the patience to wait for a week of the article, I (Miguel Greenberg) offer a full version of this guide a packed e-book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  In <strong>Chapter 3,</strong> you learned how to create a user login form, and in <strong>Chapter 4,</strong> you learned how to work with a database.  In this chapter, you will learn how to combine topics from these two chapters to create a simple user login system. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="heshirovanie-paroley">  Password Hashing </h2><br><p> In <strong>chapter 4, the</strong> user-defined model was assigned the <code>password_hash</code> field, which is not yet used.  The purpose of this field is to save the user password hash that will be used to verify the password entered by the user during the registration process.  <em>Password hashing</em> is a complex topic that should be left to security experts, but there are several easy-to-use libraries that implement all of this logic so that it can be called up from an application. </p><br><p>  One of the packages that implement password hashing is <a href="http://werkzeug.pocoo.org/">Werkzeug</a> , which you may have seen in the pip output when installing Flask.  Since this is a dependency, Werkzeug is already installed in your virtual environment.  The following Python shell session demonstrates how to hash a password: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; from werkzeug.security import generate_password_hash &gt;&gt;&gt; hash = generate_password_hash('foobar') &gt;&gt;&gt; hash 'pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f18cd2175f'</code> </pre> <br><p>  In this example, the foobar password is converted to a long coded string through a series of cryptographic operations that do not have any inverse operation, which means that the person receiving the hashed password cannot use it to obtain the original password.  As an additional measure, if you have the same password several times, you will get different results, so it is not possible to determine whether two users have the same password by viewing their hashes. </p><br><p>  The verification process is performed with the second function from Werkzeug as follows: </p><br><pre> <code class="bash hljs"> &gt;&gt;&gt; from werkzeug.security import check_password_hash &gt;&gt;&gt; check_password_hash(<span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>, <span class="hljs-string"><span class="hljs-string">'foobar'</span></span>) True &gt;&gt;&gt; check_password_hash(<span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>, <span class="hljs-string"><span class="hljs-string">'barfoo'</span></span>) False</code> </pre> <br><p>  The verification function accepts the hash code of the password that was previously generated and the password entered by the user during login.  The function returns the value <code>True</code> if the password provided by the user matches the hash, otherwise <code>False</code> . </p><br><p>  All password hashing logic can be implemented as two new methods in the user model: </p><br><blockquote>  <code>app/models.py</code> : Password Hashing and Verification </blockquote><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> werkzeug.security <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generate_password_hash, check_password_hash <span class="hljs-comment"><span class="hljs-comment"># ... class User(db.Model): # ... def set_password(self, password): self.password_hash = generate_password_hash(password) def check_password(self, password): return check_password_hash(self.password_hash, password)</span></span></code> </pre> <br><p>  Using these two methods, a user object can now perform a secure password check without having to store the original passwords.  Here is an example of using these new methods: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; u = User(username='susan', email='susan@example.com') &gt;&gt;&gt; u.set_password('mypassword') &gt;&gt;&gt; u.check_password('anotherpassword') False &gt;&gt;&gt; u.check_password('mypassword') True</code> </pre> <br><h2 id="vvedenie-v-flask-login">  Introduction to Flask-Login </h2><br><p>  In this chapter, I will introduce you to the very popular Flask extension called Flask-Login.  This extension controls the user's login status, so that, for example, users can log in to the application, and then go to different pages while the application ‚Äúremembers‚Äù that the user is logged in.  It also provides ‚Äúremember me‚Äù functionality that allows users to stay logged in even after the browser window is closed.  To be ready for this chapter, you can start by installing Flask-Login in your virtual environment: </p><br><pre> <code class="plaintext hljs">(venv) $ pip install flask-login</code> </pre> <br><p>  As with other extensions, Flask-Login must be created and initialized immediately after the application instance in app / <strong>init</strong> .py.  So this extension is initialized: </p><br><blockquote>  <code>app/__init__.py</code> : Flask-Login initialization </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_login import LoginManager app = Flask(__name__) # ... login = LoginManager(app) # ...</code> </pre> <br><h2 id="podgotovka-user-model-dlya-flask-login">  Preparing User Model for Flask-Login </h2><br><p>  The Flask-Login extension works with the user model of the application and expects that it will implement certain properties and methods.  This approach is good because as long as these necessary elements are added to the model, Flask-Login has no other requirements, so, for example, it can work with custom models based on any database system. </p><br><p>  Below are the four required items: </p><br><ul><li>  <code>is_authenticated</code> : a property that is <code>True</code> if the user has valid credentials or <code>False</code> otherwise. </li><li>  <code>is_active</code> : property that returns <code>True</code> if the user account is active or <code>False</code> otherwise. </li><li>  <code>is_anonymous</code> : a property that returns <code>False</code> for ordinary users, and <code>True</code> if the user is anonymous. </li><li>  <code>get_id()</code> : method that returns the unique identifier of the user as a string (unicode if Python 2 is used). </li></ul><br><p>  I can easily implement all four, but since the implementations are fairly generic, Flask-Login provides the <em>mixin</em> class <code>UserMixin</code> , which includes common implementations that are suitable for most classes of custom models.  Here is how the <em>mixin</em> class is added to the model: </p><br><blockquote>  <code>app/models.py</code> : Flask-Login user mixin class </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_login import UserMixin class User(UserMixin, db.Model): # ...</code> </pre> <br><h2 id="polzovatelskiy-zagruzchik">  Custom loader </h2><br><p>  Flask-Login keeps track of a registered user by storing his unique identifier in <em>a</em> Flask <em>user session</em> assigned to each user who connects to the application.  Each time a logged in user goes to a new page, Flask-Login retrieves the user ID from the session and then loads that user into memory. </p><br><p>  Since Flask-Login does not know anything about databases, it needs the help of the application when loading the user.  For this reason, the extension expects the application to configure a user loader function that can be called to load a user with an identifier.  This feature can be added in the <em>app / models.py module</em> : </p><br><blockquote>  <code>app/models.py</code> : Flask-Login user loader function </blockquote><br><pre> <code class="plaintext hljs">from app import login # ... @login.user_loader def load_user(id): return User.query.get(int(id))</code> </pre> <br><p>  A custom bootloader is registered in Flask-Login using the <code>@login.user_loader</code> decorator.  The identifier that Flask-Login passes to the function as an argument will be a string, so for databases using numeric identifiers, you need to convert the string to an integer, as you can see above <code>int(id)</code> . </p><br><h2 id="vhod-polzovateley-v-sistemu">  User Login </h2><br><p>  Let's move on to the login function, which, as you remember, implemented a fake login, which only gave the <code>flash()</code> message.  Now that the application has access to the user database and knows how to create and verify password hashes, this browsing function can be completed ( <code>\microblog\app\routes.py</code> ). </p><br><blockquote>  <code>app/routes.py</code> : Login view function logic </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_login import current_user, login_user from app.models import User # ... @app.route('/login', methods=['GET', 'POST']) def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.username.data).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title='Sign In', form=form)</code> </pre> <br><p>  The top two lines in the <code>login()</code> function deal with a strange situation.  Imagine that you have a user who is logged in and navigates to the URL of your application.  Clearly, this is a mistake, so I do not want to allow this.  The <code>current_user</code> variable comes from Flask-Login and can be used at any time to get a user object.  The value of this variable can be a user object from the database (which Flask-Login reads via the callback of the user loader presented above), or a special anonymous user object if the user has not logged in yet.  Remember those properties that Flask requires in a user object?  One of them was <code>is_authenticated</code> , which is very useful to check if the user is registered or not.  When the user is already logged in, I simply redirect him to the <em>index</em> page. </p><br><p>  Instead of calling flash (), which I used earlier, I can now log in to the user's system for real.  The first step is to load the user from the database.  The username came with a submit form, so I can query the database to find the user. </p><br><p>  To do this, I use the <code>filter_by()</code> method of the SQLAlchemy query object.  The result of <code>filter_by()</code> is a query that includes only objects that have a matching username.  Since I know that there will be only one or zero result, I will complete the query by calling <code>first()</code> , which will return the user object if it exists, or <code>None</code> if it is not.  In <strong>Chapter 4,</strong> you saw that when you call the <code>all()</code> method in a query, the query is executed, and you get a list of all the results that match that query.  The <code>first()</code> method is another used way to execute a query when you need only one result. </p><br><p>  If I received a match for the username that was provided, I can verify that the password, which also came with the form, is valid.  This is done by calling the <code>check_password()</code> method defined above.  This will lead to the hash password stored by the user, and determine whether the password entered in the form matches the hash or not.  So now I have two possible error conditions: the username may be invalid, or the password may be incorrect for the user.  In any of these cases, I scroll through the message and redirect back to the login prompt so that the user can try again. </p><br><p>  If the username and password are correct, I call the <code>login_user()</code> function, which comes from Flask-Login.  This function will register the user at the time of login, so this means that on any future pages to which the user goes, the <code>current_user</code> variable will be set for this user. </p><br><p>  To complete the login process, I simply redirect the newly registered user to the <em>index</em> page. </p><br><h2 id="vyhod-iz-sistemy">  Sign Out </h2><br><p>  Obviously, you will need to offer users the ability to exit the application.  This can be done using the <code>logout_user()</code> Flask-Login function.  Here‚Äôs what the exit function looks like: </p><br><blockquote>  <code>app/routes.py</code> : Logout view function </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_login import logout_user # ... @app.route('/logout') def logout(): logout_user() return redirect(url_for('index'))</code> </pre> <br><p>  I can make the ‚Äú <code>login</code> ‚Äù link in the navigation bar automatically switch to the ‚Äú <code>logout</code> ‚Äù link after the user has logged in.  This can be done using a conditional expression in the <em>base.html</em> template: </p><br><blockquote>  <code>app/templates/base.html</code> : Conditional login and logout links </blockquote><br><pre> <code class="plaintext hljs">&lt;div&gt; Microblog: &lt;a href="{{ url_for('index') }}"&gt;Home&lt;/a&gt; {% if current_user.is_anonymous %} &lt;a href="{{ url_for('login') }}"&gt;Login&lt;/a&gt; {% else %} &lt;a href="{{ url_for('logout') }}"&gt;Logout&lt;/a&gt; {% endif %} &lt;/div&gt;</code> </pre> <br><p>  The <code>is_anonymous</code> property is one of the attributes that Flask-Login adds to user objects through the UserMixin class.  The expression <code>current_user.is_anonymous</code> will return <code>True</code> only if the user does not log in. </p><br><h2 id="trebovanie-k-polzovatelskomu-vhodu">  User Login Requirement </h2><br><p>  Flask-Login provides a very useful feature that forces users to register before they can view certain pages of the application.  If a user who has not logged in tries to view a secure page, Flask-Login automatically redirects the user to the login form and only after completing the login process, redirects to the page that the user wanted to view. </p><br><p>  In order for this function to be implemented, Flask-Login needs to know what a viewing function is that processes logins.  This can be added to <em>app / <strong>init</strong> .py:</em> </p><br><pre> <code class="plaintext hljs"># ... login = LoginManager(app) login.login_view = 'login'</code> </pre> <br><p>  The ‚Äúlogin‚Äù value above is the name of the function (or end point) for logging on to the system.  In other words, the name you will use in the <code>url_for()</code> call to get the URL. </p><br><p>  The Flask-Login method protects the browsing function from anonymous users using a decorator called <code>@login_required</code> .  When you add this decorator to the view function under the <code>@app.route</code> decorators from Flask, the function becomes secure and does not allow access to users who are not authenticated.  Here's how the decorator can be applied to the application's index view function: </p><br><blockquote>  <code>app/routes.py</code> : @login_required decorator </blockquote><br><pre> <code class="plaintext hljs">from flask_login import login_required @app.route('/') @app.route('/index') @login_required def index(): # ...</code> </pre> <br><p>  It remains to implement redirection from a successful login to the page to which the user wanted to access.  When a non-logged-in user accesses the viewing function protected by the <code>@login_required</code> decoder, the decorator is about to redirect to the login page, but this redirection will include additional information so that the application can then return to the first page.  If the user goes, for example, to <em>/ index</em> , the <code>@login_required</code> handler intercepts the request and redirects to <code>/login</code> , but it adds the query string argument to this URL, making the full URL <em>/ login? Next = / index</em> .  <code>next</code> query string argument is set to the original URL, so the application can use this to redirect after logging in. </p><br><p>  Here is a snippet of code that shows how to read and process the <code>next</code> query string argument: </p><br><blockquote>  <code>app/routes.py</code> : Redirect to "next" (next) page </blockquote><br><pre> <code class="plaintext hljs">from flask import request from werkzeug.urls import url_parse @app.route('/login', methods=['GET', 'POST']) def login(): # ... if form.validate_on_submit(): user = User.query.filter_by(username=form.username.data).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) next_page = request.args.get('next') if not next_page or url_parse(next_page).netloc != '': next_page = url_for('index') return redirect(next_page) # ...</code> </pre> <br><p>  Immediately after the user has logged in, by calling the <code>login_user()</code> function from <em>Flask-Login</em> , you will get the value of the <code>next</code> argument in the query string.  Flask contains a request variable containing all the information that the client sent with the request.  In particular, the attribute <code>request.args</code> provides the contents of the query string in a friendly dictionary format.  In fact, there are three possible cases that must be considered in order to determine where to redirect after a successful login: </p><br><ul><li>  If the login URL does not have the following argument, the user is redirected to the index page. </li><li>  If the login URL includes the <code>next</code> argument, which is set to a relative path (or, in other words, a URL without a part of the domain), then the user is redirected to that URL. </li><li>  If the login URL includes the <code>next</code> argument, which is set to a full URL that includes the domain name, the user is redirected to the index page. </li></ul><br><p>  The first and second cases do not require explanation.  The third case is to make the application more secure.  An attacker can insert a URL to a malicious site in the <code>next</code> argument, so the application redirects only the URL, which ensures that the redirection remains on the same site as the application.  To determine if the URL is relative or absolute, I analyze it with the <em>Werkzeug</em> <code>url_parse()</code> function, and then check whether the <code>netloc</code> component is <code>netloc</code> or not. </p><br><h2 id="otobrazhenie-voshedshego-v-sistemu-polzovatelya-v-shablonah">  Display the logged in user in the templates </h2><br><p>  Do you remember that in <strong>Chapter 2</strong> I created a fake user to help me develop the application home page before the user subsystem was created?  Well, now the application has real users, so now I can remove the fake ones and start working with real ones.  Instead of fake ones, you can use Flask-Login-s current_user in the template: </p><br><blockquote>  <code>app/templates/index.html</code> : Passing the current user to the template </blockquote><br><pre> <code class="plaintext hljs">{% extends "base.html" %} {% block content %} &lt;h1&gt;Hi, {{ current_user.username }}!&lt;/h1&gt; {% for post in posts %} &lt;div&gt;&lt;p&gt;{{ post.author.username }} says: &lt;b&gt;{{ post.body }}&lt;/b&gt;&lt;/p&gt;&lt;/div&gt; {% endfor %} {% endblock %}</code> </pre> <br><p>  And I can remove the <code>user</code> argument in the <code>view</code> function ( <em>microblog \ app \ routes.py</em> ): </p><br><blockquote>  app / routes.py: Do not pass user to template anymore </blockquote><br><pre> <code class="plaintext hljs">@app.route('/') @app.route('/index') def index(): # ... return render_template("index.html", title='Home Page', posts=posts)</code> </pre> <br><p>  It seems the right time has come to test the input and output operability.  Since user registration is still missing, the only way to add a user to the database is through the Python shell, so run the <code>flask shell</code> and enter the following commands to register the user: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; u = User(username='susan', email='susan@example.com') &gt;&gt;&gt; u.set_password('cat') &gt;&gt;&gt; db.session.add(u) &gt;&gt;&gt; db.session.commit()</code> </pre> <br><p>  If you start the application and try to access <code>http:// localhost:5000/</code> or <code>http://localhost:5000/index</code> , you will be immediately redirected to the login page.  And after completing the login procedure, using the credentials of the user that you added to your database, you will be returned to the original page, in which you will see a personalized greeting. </p><br><h2 id="registraciya-polzovatelya">  User registration </h2><br><p>  The last part of the functionality I‚Äôm going to build in this chapter is the registration form so that users can register via the web form.  Let's start by creating a web form class in <em>app / forms.py</em> : </p><br><pre> <code class="plaintext hljs">from flask_wtf import FlaskForm from wtforms import StringField, PasswordField, BooleanField, SubmitField from wtforms.validators import ValidationError, DataRequired, Email, EqualTo from app.models import User # ... class RegistrationForm(FlaskForm): username = StringField('Username', validators=[DataRequired()]) email = StringField('Email', validators=[DataRequired(), Email()]) password = PasswordField('Password', validators=[DataRequired()]) password2 = PasswordField( 'Repeat Password', validators=[DataRequired(), EqualTo('password')]) submit = SubmitField('Register') def validate_username(self, username): user = User.query.filter_by(username=username.data).first() if user is not None: raise ValidationError('Please use a different username.') def validate_email(self, email): user = User.query.filter_by(email=email.data).first() if user is not None: raise ValidationError('Please use a different email address.')</code> </pre> <br><p>  In this new form, there are several interesting things related to verification.  First, for the email field, I added a second validator after DataRequired, called <em>Email</em> .  This is another validator (in the original ‚Äústock validator‚Äù, i.e. it is more correct to translate it as built-in, standard) that comes with WTForms, which guarantees that what the user enters in this field corresponds to the structure of the email address. </p><br><p>  Since this is a registration form, it is usually customary to ask the user to enter the password twice to reduce the risk of typographical errors.  For this reason, I have <code>password</code> and <code>password2</code> .  In the second password field, another standard <em>EqualTo</em> validator is <em>used</em> , which verifies that its value is identical to the value for the first password field. </p><br><p>  I also added two methods to this class: <code>validate_username()</code> and <code>validate_email()</code> .  When you add any methods that match the <code>validate_&lt;_&gt;</code> pattern, WTForms accepts them as custom validators and calls them in addition to the standard validators.  In this case, I want to make sure that the username and e-mail address entered by the user are not yet in the database, so these two methods query the database, expecting that there will be no results.  In case the result exists, a validation error is triggered by a call to <em>ValidationError</em> . ,      ,  ,         . </p><br><p>      -,    HTML-,       <em>app/templates/register.html</em> .     ,     : </p><br><pre> <code class="plaintext hljs">{% extends "base.html" %} {% block content %} &lt;h1&gt;Register&lt;/h1&gt; &lt;form action="" method="post"&gt; {{ form.hidden_tag() }} &lt;p&gt; {{ form.username.label }}&lt;br&gt; {{ form.username(size=32) }}&lt;br&gt; {% for error in form.username.errors %} &lt;span style="color: red;"&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{ form.email.label }}&lt;br&gt; {{ form.email(size=64) }}&lt;br&gt; {% for error in form.email.errors %} &lt;span style="color: red;"&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{ form.password.label }}&lt;br&gt; {{ form.password(size=32) }}&lt;br&gt; {% for error in form.password.errors %} &lt;span style="color: red;"&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{ form.password2.label }}&lt;br&gt; {{ form.password2(size=32) }}&lt;br&gt; {% for error in form.password2.errors %} &lt;span style="color: red;"&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt; {% endblock %}</code> </pre> <br><p>        ,       ,   : </p><br><pre> <code class="plaintext hljs">&lt;p&gt;New User? &lt;a href="{{ url_for('register') }}"&gt;Click to Register!&lt;/a&gt;&lt;/p&gt;</code> </pre> <br><p> , ,     ,       <em>app/routes.py</em> : </p><br><pre> <code class="plaintext hljs">from app import db from app.forms import RegistrationForm # ... @app.route('/register', methods=['GET', 'POST']) def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegistrationForm() if form.validate_on_submit(): user = User(username=form.username.data, email=form.email.data) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash('Congratulations, you are now a registered user!') return redirect(url_for('login')) return render_template('register.html', title='Register', form=form)</code> </pre> <br><p>   ,      .    ,      . ,    <code>if validate_on_submit()</code> ,     ,    ,           ,      . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/739/afd/926/739afd9265644988690702d4e6f15c3f.png"></p><br><p>  <a href="https://habrahabr.ru/post/346344/">&lt;&lt;&lt; previous</a> <a href="https://habrahabr.ru/post/346348/">next &gt;&gt;&gt;</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346346/">https://habr.com/ru/post/346346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346336/index.html">Rust: ‚ÄúUnsafe Abstractions‚Äù</a></li>
<li><a href="../346338/index.html">Using the inverse Laplace transform to analyze the dynamic links of control systems</a></li>
<li><a href="../346340/index.html">Flask Mega-Tutorial, Part 2: Patterns (Edition 2018)</a></li>
<li><a href="../346342/index.html">Flask Mega-Tutorial, Part 3: Web Forms (Edition 2018)</a></li>
<li><a href="../346344/index.html">Flask Mega-Tutorial, Part 4: Database (edition 2018)</a></li>
<li><a href="../346348/index.html">Flask Mega-Tutorial, Part 6: Profile page and avatars (edition 2018)</a></li>
<li><a href="../346350/index.html">As a researcher hacked his own computer and became convinced of the reality of the most serious vulnerability in the history of processors</a></li>
<li><a href="../346352/index.html">Useful materials on SAN</a></li>
<li><a href="../346354/index.html">Touch or not: What are the cash registers of stores today?</a></li>
<li><a href="../346358/index.html">The book "Deep learning. Immersion in the world of neural networks "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>