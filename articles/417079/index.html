<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Package Manager for Kubernetes - Helm: Past, Present, Future</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : With this article we open the cycle of publications about the package manager for Kubernetes, which we actively use in our daily work - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Package Manager for Kubernetes - Helm: Past, Present, Future</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: With this article we open the cycle of publications about the package manager for Kubernetes, which we actively use in our daily work - Helm.</i>  <i>The original author of the material is Matt Butcher - one of the founders of the Helm project, who works on open source projects at Microsoft and has written 8 technical books (in particular, ‚ÄúGo in Practice‚Äù).</i>  <i>However, the article is supplemented with our (in some places - extensive) comments, and soon will be further expanded with new notes on a more practical Helm.</i>  <i><b>UPDATE</b> (09/03/2018): continued - ‚Äú <a href="https://habr.com/company/flant/blog/420437/">Practical familiarity with the package manager for Kubernetes - Helm</a> ‚Äù.</i> <br><br><img src="https://habrastorage.org/webt/ff/1x/js/ff1xjsnvdlnfinirlwb-0p42tlo.png"><br><br>  In June, Helm <a href="https://www.cncf.io/blog/2018/06/01/cncf-to-host-helm/">moved</a> from the status of the leading project Kubernetes to the Cloud Native Computing Foundation (CNCF).  CNCF is becoming the parent organization for the best-of-its-kind open source cloud native tools.  Therefore, it is a great honor for Helm to become part of such a fund.  And our first significant project under the auspices of CNCF is truly ambitious: we create Helm 3. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  A brief history of Helm </h2><br>  Helm originally appeared as the open source project of the company Deis.  It was modeled in the likeness of <a href="https://brew.sh/">Homebrew</a> <i>(package manager for macOS - <b>approx. Transl.</b> )</i> , And the challenge for Helm 1 was a lightweight opportunity for users to quickly install their first workloads on Kubernetes.  The official announcement of Helm was held at the first KubeCon San Francisco conference in 2015. <br><br>  <i><b>Note</b></i>  <i><b>Transl .:</b> From the first version, which was called dm (Deployment Manager), YAML syntax was chosen to describe Kubernetes resources, and <a href="http://jinja.pocoo.org/">Jinja templates</a> and Python scripts were supported when writing configurations.</i> <br><br>  <i>A simple web application template could look like this:</i> <br><br><div class="spoiler">  <b class="spoiler_title">Yaml</b> <div class="spoiler_text"><pre><code class="plaintext hljs">resources: - name: frontend type: github.com/kubernetes/application-dm-templates/common/replicatedservice:v1 properties: service_port: 80 container_port: 80 external_service: true replicas: 3 image: gcr.io/google_containers/example-guestbook-php-redis:v3 - name: redis type: github.com/kubernetes/application-dm-templates/storage/redis:v1 properties: null</code> </pre> </div></div><br>  <i>When describing the components of the application being rolled out, the name of the used template and the necessary parameters of this template are indicated.</i>  <i>In the example above, the <code>frontend</code> and <code>redis</code> use templates from the official repository.</i> <br><br>  <i>Already in this version, you can use resources from the general knowledge base, create your own template repositories and build complex applications using template parameters and nesting.</i> <br><br>  <i>The architecture of Helm 1 consists of three components.</i>  <i>The following diagram illustrates the relationship between them:</i> <br><br><img src="https://habrastorage.org/webt/66/f8/l_/66f8l_blo_rfzohvo1wpobchuzg.png"><br><br><ol><li>  <i><code>Manager</code> performs the function of a web server (communication with clients occurs via the REST API), manages deployments in the Kubernetes cluster and is used as a data warehouse.</i> </li><li>  <i>The <code>expandybird</code> component leads the user configurations to a flat form, i.e.</i>  <i>applies Jinja templates and runs Python scripts.</i> </li><li>  <i>After receiving the flat configuration, the <code>resourcifier</code> makes the necessary calls to kubectl and returns the status and error messages to the <code>manager</code> , if any.</i> </li></ol><br>  <i>To understand the features of the first version of Helm, I‚Äôll give you a help on the <code>dm</code> command</i> : <div class="spoiler">  <b class="spoiler_title">Help output from dm</b> <div class="spoiler_text"><pre> <code class="bash hljs">Usage: ./dm [&lt;flags&gt;] &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt; [(&lt;template-name&gt; | &lt;deployment-name&gt; | (&lt;configuration&gt; [&lt;import1&gt;...&lt;importN&gt;]))] Commands: expand Expands the supplied configuration(s) deploy Deploys the named template or the supplied configuration(s) list Lists the deployments <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster get Retrieves the supplied deployment manifest Lists manifests <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment or retrieves the supplied manifest <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the form (deployment[/manifest]) delete Deletes the supplied deployment update Updates a deployment using the supplied configuration(s) deployed-types Lists the types deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster deployed-instances Lists the instances of the named <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster templates Lists the templates <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry (specified with --registry) registries Lists the registries available describe Describes the named template <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry getcredential Gets the named credential used by a registry setcredential Sets a credential used by a registry createregistry Creates a registry that holds charts Flags: -apitoken string Github api token that overrides GITHUB_API_TOKEN environment variable -binary string Path to template expansion binary (default <span class="hljs-string"><span class="hljs-string">"../expandybird/expansion/expansion.py"</span></span>) -httptest.serve string <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non-empty, httptest.NewServer serves on this address and blocks -name string Name of deployment, used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deploy and update commands (defaults to template name) -password string Github password that overrides GITHUB_PASSWORD environment variable -properties string Properties to use when deploying a template (eg, --properties k1=v1,k2=v2) -regex string Regular expression to filter the templates listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a template registry -registry string Registry name (default <span class="hljs-string"><span class="hljs-string">"application-dm-templates"</span></span>) -registryfile string File containing registry specification -service string URL <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment manager (default <span class="hljs-string"><span class="hljs-string">"http://localhost:8001/api/v1/proxy/namespaces/dm/services/manager-service:manager"</span></span>) -serviceaccount string Service account file containing JWT token -stdin Reads a configuration from the standard input -timeout int Time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds to <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> response (default 20) -username string Github user name that overrides GITHUB_USERNAME environment variable --stdin requires a file name and either the file contents or a tar archive containing the named file. a tar archive may include any additional files referenced directly or indirectly by the named file.</code> </pre></div></div><br>  <i>Now back to the original text about the history of Helm ...</i> <br><br>  A few months later, we joined forces with the Kubernetes Deployment Manager team from Google and started working on Helm 2. The goal was to keep Helm easy to use by adding the following to it: <br><br><ol><li>  chart templates <i>("chart" - an analogue of the package in the Helm ecosystem - <b>approx. transl.</b> )</i> for customization; </li><li>  management within the cluster for teams; </li><li>  full repository of charts; </li><li>  stable and signed package format; </li><li>  strong commitment to semantic versioning and maintaining backward compatibility from version to version. </li></ol><br>  To achieve these goals, a second component has been added to the Helm ecosystem.  It was Tiller, located inside the cluster, which provided for the installation and management of the Helm charts. <br><br>  <i><b>Note</b></i>  <i><b>Perev .:</b> Thus, in the second version of Helm, the only component left in the cluster is responsible for the installation life cycle ( <a href="https://docs.helm.sh/glossary/">release</a> ), and the preparation of configurations is transferred to the Helm client.</i> <br><br>  <i>If the cluster reboot using the first version of Helm resulted in a complete loss of service data (because they were stored in RAM), then in Helm 2 all data is stored in <code>ConfigMaps</code> , i.e.</i>  <i>resources inside Kubernetes.</i>  <i>Another important step was the transition from the synchronous API (where each request was blocking) to the use of asynchronous gRPC.</i> <br><br>  Since the release of Helm 2 in 2016, the Kubernetes project has experienced explosive growth and the emergence of significant new opportunities.  Role-based access control (RBAC) has been added.  Presented many new types of resources.  Inventory third party resources (Custom Resource Definitions, CRD).  And most importantly, the best practices have appeared.  Passing through all these changes, Helm continued to serve the needs of Kubernetes users.  But it became obvious to us that the time had come to make major changes to it so that the needs of this developing ecosystem would continue to be met. <br><br>  So we came to Helm 3. Next, I will talk about some of the innovations that appear on the roadmap of the project. <br><br><h2>  Welcome lua </h2><br>  In Helm 2, we presented the templates.  Early in the development of Helm 2, we supported the Go, Jinja templates, clean Python code, and we even had a prototype of support for ksonnet.  But the presence of multiple engines for templates has created more problems than it has solved.  Therefore, we have come to choose one. <br><br>  Go templates had four advantages: <br><br><ol><li>  library <a href="https://godoc.org/text/template">built into Go</a> ; </li><li>  patterns are executed in a tightly sandboxed environment; </li><li>  we could insert <a href="https://docs.helm.sh/chart_template_guide/">arbitrary functions and objects</a> into the engine; </li><li>  They worked well with YAML. </li></ol><br>  Although we saved the Helm interface to support other template engines, the Go templates have become our default standard.  And the next few years of experience showed how engineers from many companies created thousands of charts using Go templates. <br><br>  And we found out about their disappointments: <br><br><ol><li>  The syntax is difficult to read and poorly documented. </li><li>  Language problems, such as immutable variables, intricate data types, and restrictive in-scope rules, have turned simple things into complex ones. </li><li>  The inability to define functions within templates has further complicated the creation of reusable libraries. </li></ol><br>  The most important thing is that using the template language, we essentially ‚Äúcut off‚Äù Kubernetes objects to their string representation.  (In other words, template developers had to manage Kubernetes resources as text documents in YAML format.) <br><br><h2>  Work on objects, not pieces of YAML </h2><br>  Again and again we heard from users a request for the ability to inspect and modify Kubernetes resources as objects, not strings.  At the same time, they were adamant that, whatever the path of realization we choose for this, it should be easy to learn and well maintained in the ecosystem. <br><br>  After months of research, we decided to provide a built-in scripting language that can be packed into a sandbox and customized.  Among the 20 leading languages ‚Äã‚Äãthere was only one candidate who met the requirements: <a href="https://www.lua.org/home.html">Lua</a> . <br><br>  In 1993, a group of Brazilian IT engineers created a lightweight scripting language to integrate into their tools.  Lua has a simple syntax, it is widely supported and has long been featured in the list of the <a href="https://redmonk.com/sogrady/2018/03/07/language-rankings-1-18/">top 20 languages</a> .  It is supported by IDE and text editors, there are many manuals and teaching books.  We would like to develop our solution on such an already existing ecosystem. <br><br>  Our work on Helm Lua is still at the concept proof stage, and we expect a syntax that is both familiar and flexible.  Comparing the old and new approaches, you can see where we are going. <br><br>  Here is the <a href="">example of</a> the Alpine hearth template in Helm 2: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: {{ template "alpine.fullname" . }} labels: heritage: {{ .Release.Service }} release: {{ .Release.Name }} chart: {{ .Chart.Name }}-{{ .Chart.Version }} app: {{ template "alpine.name" . }} spec: restartPolicy: {{ .Values.restartPolicy }} containers: - name: waiter image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}" imagePullPolicy: {{ .Values.image.pullPolicy }} command: ["/bin/sleep", "9000"]</code> </pre> <br>  In this simple template, you can immediately see all the built-in template directives, such as <code>{{ .Chart.Name }}</code> . <br><br>  And here is the definition of the same presentation in the preliminary version of the Lua code: <br><br><pre> <code class="lua hljs">unction create_alpine_pod(_) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pod = { apiVersion = <span class="hljs-string"><span class="hljs-string">"v1"</span></span>, kind = <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, metadata = { name = alpine_fullname(_), labels = { heritage = _.Release.Service <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"helm"</span></span>, release = _.Release.Name, chart = _.Chart.Name .. <span class="hljs-string"><span class="hljs-string">"-"</span></span> .. _.Chart.Version, app = alpine_name(_) } }, spec = { restartPolicy = _.Values.restartPolicy, containers = { { name = waiter, image = _.Values.image.repository .. <span class="hljs-string"><span class="hljs-string">":"</span></span> .. _.Values.image.tag, imagePullPolicy = _.Values.image.pullPolicy, command = { <span class="hljs-string"><span class="hljs-string">"/bin/sleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"9000"</span></span> } } } } } _.resources.add(pod) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  It is not necessary to examine each line of this example in order to understand what is happening.  It is immediately evident that in the code it is defined under.  But instead of using YAML strings with embedded template directives, we define it as an object in Lua. <br><br><h2>  Let's cut this code </h2><br>  Since we are working directly with objects (instead of manipulating a large glob of text), we can take full advantage of scripting.  The possibilities of creating shared libraries that appear here look really attractive.  And we hope that by submitting specialized libraries (or by allowing the community to create them), we can reduce the code above to something like this: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pods = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"mylib.pods"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_alpine_pod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span></span> myPod = pods.new(<span class="hljs-string"><span class="hljs-string">"alpine:3.7"</span></span>, _) myPod.spec.restartPolicy = <span class="hljs-string"><span class="hljs-string">"Always"</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set any other properties _.Manifests.add(myPod) end</span></span></code> </pre> <br>  This example uses the ability to work with the definition of a resource as an object that is easy to set properties, while maintaining the brevity and readability of the code. <br><br><h2>  Templates ... Lua ... Why not all together? </h2><br>  Although templates are not so wonderful for all tasks, they still have certain advantages.  Go templates are a stable technology with an established user base and many existing charts.  Many chart developers claim they like writing templates.  Therefore, we are not going to remove template support. <br><br>  Instead, we want to allow both templates and Lua to be used simultaneously.  Lua scripts will have access to the Helm templates both before and after rendering, which will allow advanced chart developers to perform complex transformations on existing charts, while retaining the simple ability to create Helm charts with templates. <br><br>  We are very excited about supporting Lua scripts, but at the same time getting rid of a significant part of the Helm architecture ... <br><br><h2>  Saying goodbye to tiller </h2><br>  During the development of Helm 2, we introduced Tiller as a component of integration with the Deployment Manager.  Tiller played an important role for teams working on the same cluster: he made it possible to interact with the same set of releases for many different administrators. <br><br>  However, Tiller worked as a giant sudo server, issuing a wide range of rights to everyone who has access to Tiller.  And our default installation scheme was permissive configuration.  Therefore, DevOps and SRE engineers had to learn additional steps to install Tiller in multi-tenant category clusters. <br><br>  Moreover, with the emergence of CRD, we could no longer reliably rely on Tiller to maintain state or function as a central hub for information on the Helm release.  We could only store this information in the form of separate records in Kubernetes. <br><br>  The main goal of Tiller can be achieved without Tiller itself.  Therefore, one of the first decisions taken at the planning stage of Helm 3 was a complete rejection of Tiller. <br><br><h2>  Security enhancement </h2><br>  Without Tiller, the Helm security model is radically simplified.  User authentication is delegated to Kubernetes.  And authorization too.  Helm rights are defined as Kubernetes rights (via RBAC), and cluster administrators can restrict Helm rights at any level of detail required. <br><br><h2>  Releases, ReleaseVersions and State Storage </h2><br>  In the absence of Tiller, to maintain the state of various releases within the cluster, we need a new way for all customers to interact (release management). <br><br>  For this, we have submitted two new entries: <br><br><ol><li>  <code>Release</code> - for a specific installation of a specific chart.  If we do <code>helm install my-wordpress stable/wordpress</code> , a release called <code>my-wordpress</code> will be created and maintained throughout the life of this WordPress installation. </li><li>  <code>ReleaseVersion</code> - with each update of the Helm chart you need to consider what has changed and whether the change was successful.  <code>ReleaseVersion</code> bound to a release and stores only records with information about updates, rollbacks and deletions.  When we run <code>helm upgrade my-wordpress stable/wordpress</code> , the original <code>Release</code> object will remain the same, but a <code>ReleaseVersion</code> child object will appear with information about the update operation. </li></ol><br>  <code>Releases</code> and <code>ReleaseVersions</code> will be stored in the same namespaces as chart objects. <br><br>  With these features, Helm user teams will be able to track Helm installation records in a cluster without the need for Tiller. <br><br><h2>  But wait, that's not all! </h2><br>  In this article I tried to talk about some of the major changes in Helm 3. However, this list is not at all complete.  <a href="">The Helm 3 plan</a> includes other changes, such as improvements in the chart format, improvements in performance for the chart repositories, and a new event system that can be used by chart developers.  We are also making efforts to define what Eric Raymond called <a href="http://www.itprotoday.com/open-source/eric-s-raymond-keeping-bazaar-secure-and-functional">archeology code</a> , clearing the code base and updating components that have lost their relevance in the last three years. <br><br>  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: Paradox, but the package manager Helm 2, if <code>install</code> or <code>upgrade</code> successful, i.e.</i>  <i>having release in the <code>success</code> state does not guarantee that the application resources have been successfully rolled out (for example, there are no errors like <code>ImagePullError</code> ).</i>  <i>Perhaps the new event model will allow adding additional hooks for resources and better control of the rollout process - we will soon find out about it.</i> <br><br>  With the addition of Helm to CNCF, we are inspired not only by Helm 3, but also by the <a href="https://github.com/kubernetes-helm/chartmuseum">Chart Museum</a> , the wonderful utility <a href="https://github.com/kubernetes-helm/chart-testing">Chart Testing</a> , the <a href="https://github.com/kubernetes/charts">official chart repository</a> and other projects sponsored by Helm at CNCF.  We believe that good package management for Kubernetes is just as important for a cloud-based cloud ecosystem as good package managers for Linux are. <br><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/company/flant/blog/420437/">Practical acquaintance with the package manager for Kubernetes - Helm</a> ‚Äù; </li><li>  " <a href="https://habr.com/company/flant/blog/336170/">Practice with dapp.</a>  <a href="https://habr.com/company/flant/blog/336170/">Part 2. Deploying Docker images in Kubernetes with the help of Helm</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/345580/">Build and heat applications in Kubernetes using dapp and GitLab CI</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/345116/">Best CI / CD practices with Kubernetes and GitLab</a> ‚Äù <i>(review and video of the report)</i> ; </li><li>  " <a href="https://habr.com/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> " <i>(video of the report, which includes an introduction to the technical device Kubernetes).</i> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/417079/">https://habr.com/ru/post/417079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417065/index.html">Splunk How-to, or How and Where to Learn Splunk</a></li>
<li><a href="../417069/index.html">Once again about OpenSSL</a></li>
<li><a href="../417071/index.html">Friday's PHP: Free Skillbox Webinars</a></li>
<li><a href="../417073/index.html">A day in the life of a mobile developer Uber</a></li>
<li><a href="../417075/index.html">CSS Paint API</a></li>
<li><a href="../417081/index.html">North, will, hope, a country without borders (c), or How projects are made in the harsh Siberian conditions</a></li>
<li><a href="../417083/index.html">High loads of the World Cup 2018</a></li>
<li><a href="../417085/index.html">Browsers turn off the sound in your WebRTC application. Stop what?</a></li>
<li><a href="../417087/index.html">HPE Digitize 2018: event and live streaming</a></li>
<li><a href="../417089/index.html">Quantum computer: one photon to rule by all</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>