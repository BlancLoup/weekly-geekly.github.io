<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple inline visitor for boost :: variant</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 

 One fine Friday evening I wrote error handling in one of my hobby projects ... So, this is an introduction for another article. 
 In gene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple inline visitor for boost :: variant</h1><div class="post__text post__text-html js-mediator-article"> Hi, Habr. <br><br>  One fine Friday evening I wrote error handling in one of my hobby projects ... So, this is an introduction for another article. <br>  In general, one fine Friday evening I needed to go through the <code>boost::variant</code> and do something with the data lying there.  The standard task for <code>boost::variant</code> , and the canonical (but very verbose) way to solve it, is to describe the structure inherited from <code>boost::static_visitor</code> with overloaded <code>operator()</code> and pass it to <code>boost::apply_visitor</code> .  And this wonderful evening for some reason I became very lazy to write all this bunch of code, and I wanted to have some simpler and more concise way of describing the visitors.  What came of it, you can read under the cut. <br><a name="habracut"></a><br>  So, the canonical way looks something like this: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Variant_t = boost::variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, QString, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualsToValTypeVisitor</span></span></span><span class="hljs-class"> :</span></span> boost::static_visitor&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValType Value_; EqualsToValTypeVisitor (ValType val) : Value_ { val } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value_ == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi (s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString&amp; s)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value_ == s.toInt (); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T val)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value_ == val; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoFoo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Variant_t&amp; var)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boost::apply_visitor (EqualsToValTypeVisitor&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { val }, var)) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  And we also took advantage of the fact that the four cases for <code>int</code> , <code>char</code> , <code>float</code> and <code>double</code> can be described by one template operator, otherwise the operators would be three more, the code would be even more bloated, and it would look still more terrible. <br><br>  In addition, when the function-handlers of specific types are short, it is somehow a shame to get a separate structure for them, pull them away from the function in which they are used, and so on.  You also have to write a constructor, if you need to transfer some data from the point of application of the visitor to the visitor itself, you have to create fields for this data, you have to keep track of copying, links and other things.  It all starts not very pleasant to smell. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A natural question arises: is it possible to somehow define the visitors directly at the place of use, and with a minimum of the syntactic overhead?  Well, to straight <br><pre> <code class="hljs kotlin">void DoFoo (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Variant_t&amp; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bool isEqual = Visit (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, [&amp;<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> == std::stoi (s); }, [&amp;<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> == s.toInt (); }, [&amp;<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>] (auto other) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other == <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; }); }</code> </pre><br><br>  It turns out you can. <br><br>  Since the solution turns out to be surprisingly simple and elegant in its own way, and writing it at once is not interesting (the article is painfully short), I will also describe a little how I came to this decision, so you can skip the next two or three paragraphs. <br><br>  My first attempt, in the implementation details of which I will not go into (but which can be poked <a href="http://goo.gl/8Ydzru">here</a> ), was stuffing all lambdas into <code>std::tuple</code> and sequentially iterating them into the template <code>operator()</code> its own class, storing them until some time some function with an argument passed to <code>operator()</code> . <br><br>  The obvious disadvantage of this solution is the fatally incorrect processing of types that are brought together, and the dependence on the order of lambda transfer to the visitor creation function.  So, consider the above-mentioned <code>Variant_t</code> , which has among others <code>int</code> and <code>char</code> .  If it was created with the <code>char</code> type, and the lambda receiving the <code>int</code> was first transferred to the visitor creation function, then it will be called first (and successfully!), And the case for <code>char</code> will not come.  Moreover, this problem is really fatal: for the same <code>int</code> and <code>char</code> it is impossible (at least, without significant distortions) to determine the order of lambdas so that for both <code>int</code> and <code>char</code> passed to the right place, without any type conversions. <br><br>  However, now it is worth remembering what lambda is and how it is developed by the compiler.  And it unfolds into an anonymous structure with the overridden <code>operator()</code> .  And if we have a structure, then it can be inherited from it, and its <code>operator()</code> will automatically be in the corresponding scope.  And if you inherit from all structures at once, then all their <code>operator()</code> 's will go where necessary, and the compiler will automatically select the operator to call with each specific type, even if the types are given into each other (as in the above-mentioned case <code>int</code> and <code>char</code> ) . <br><br>  And then - the case of technology and variadic templates: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> :</span></span> Args... <span class="hljs-comment"><span class="hljs-comment">// ,     variadic pack { Visitor (Args&amp;&amp;... args) : Args { std::forward&lt;Args&gt; (args) }... //    { } }; }</span></span></code> </pre><br><br>  Let us try to write a function that takes <code>boost::variant</code> and a set of lambdas and visits this very <code>variant</code> : <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Variant, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Variant&amp; v, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boost::apply_visitor (detail::Visitor&lt;Args...&gt; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt; (args)... }, v); }</code> </pre><br><br>  Oops, got a compilation error.  <code>apply_visitor</code> expects to get a successor to <code>boost::static_visitor</code> , at least in my version of Boost 1.57 (they say that support for automatic output of the returned type was added later in C ++ 14-mode). <br><br>  How to get the return type?  You can try, for example, to take the first lambda from the list and call it with an object constructed by default, something like <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Variant, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TailArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Variant&amp; v, Head&amp;&amp; head, TailArgs&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> R_t = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (head ({})); <span class="hljs-comment"><span class="hljs-comment">//return boost::apply_visitor (detail::Visitor&lt;Head, TailArgs...&gt; { std::forward&lt;Head&gt; (head), std::forward&lt;TailArgs&gt; (args)... }, v); }</span></span></code> </pre><br>  In this case, we naturally assume that all lambdas return the same type (or, more precisely, all returned types are convertible into each other). <br><br>  The problem with this solution is that this very object may not have a default constructor.  <code>std::declval</code> will not help us here either, because the type taken by the first lambda is not known in advance, and trying to call it with all types in a row from the type list of the <code>variant</code> is too crutchy and verbose. <br><br>  Instead, we will do the opposite.  We will take the first type from the <code>variant</code> type list and call our already constructed <code>Visitor</code> with it.  This is guaranteed to work, because the visitor must be able to handle any of the types in the <code>variant</code> .  So: <br><pre> <code class="hljs ruby">template&lt;typename HeadVar, typename... TailVars, typename... Args&gt; auto Visit (const boost::variant&lt;HeadVar, TailVars...&gt;&amp; v, Args&amp;&amp;... args) -&gt; { using R_t = decltype (detail::Visitor&lt;Args...&gt; { std::forward&lt;Args&gt; (args)... } (std::declval&lt;HeadVar&gt; ())); <span class="hljs-regexp"><span class="hljs-regexp">//return</span></span> boost::apply_visitor (detail::Visitor&lt;Args...&gt; { std::forward&lt;Args&gt; (args)... }, v); }</code> </pre><br><br>  However, <code>Visitor</code> itself must inherit from <code>boost::static_visitor&lt;R_t&gt;</code> , and <code>R_t</code> at this point.  Well, it's quite easy to solve by breaking the <code>Visitor</code> into two classes, one of which deals with inheriting from lambdas and aggregating their <code>operator()</code> 's, and the other implements <code>boost::static_visitor</code> . <br><br>  Total we get <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisitorBase</span></span></span><span class="hljs-class"> :</span></span> Args... { VisitorBase (Args&amp;&amp;... args) : Args { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt; (args) }... { } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> :</span></span> boost::static_visitor&lt;R&gt;, VisitorBase&lt;Args...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> VisitorBase&lt;Args...&gt;::VisitorBase; }; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> HeadVar, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TailVars, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::variant&lt;HeadVar, TailVars...&gt;&amp; v, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> R_t = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (detail::VisitorBase&lt;Args...&gt; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt; (args)... } (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;HeadVar&gt; ())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boost::apply_visitor (detail::Visitor&lt;R_t, Args...&gt; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt; (args)... }, v); }</code> </pre><br>  For compatibility with C ++ 11, you can add trailing return type <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">template</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">typename</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HeadVar</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">typename</span></span>... <span class="hljs-selector-tag"><span class="hljs-selector-tag">TailVars</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">typename</span></span>... <span class="hljs-selector-tag"><span class="hljs-selector-tag">Args</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Visit</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">boost</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::variant</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">HeadVar</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TailVars</span></span>...&gt;&amp; <span class="hljs-selector-tag"><span class="hljs-selector-tag">v</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Args</span></span>&amp;&amp;... <span class="hljs-selector-tag"><span class="hljs-selector-tag">args</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">decltype</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">detail</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::VisitorBase</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Args</span></span>...&gt; { <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::forward&lt;Args&gt; (args)... } (<span class="hljs-selector-tag"><span class="hljs-selector-tag">std</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::declval</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">HeadVar</span></span>&gt; ()))</code> </pre><br><br>  A nice bonus is the ability to work with noncopyable lambdas (exciting unique Cptr in C ++ 14 style, for example): <br><pre> <code class="hljs kotlin">#define NC nc = std::unique_ptr&lt;int&gt; {} Variant_t v { <span class="hljs-string"><span class="hljs-string">'a'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> auto&amp; asQString = Visit (v, [NC] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString::fromStdString (s); }, [NC] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }, [NC] (auto <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString::fromNumber (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); });</code> </pre><br><br>  The disadvantage is the impossibility of a more subtle pattern-matching in the style <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; vec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre><br>  Unfortunately, <code>[] (const std::vector&amp; vec) {}  .     C++17.</code> <code>[] (const std::vector&amp; vec) {}  .     C++17.</code> </div><p>Source: <a href="https://habr.com/ru/post/270689/">https://habr.com/ru/post/270689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270679/index.html">Critical vulnerability in a number of Java Application Server</a></li>
<li><a href="../270681/index.html">WoSign Free SSL - The End Of A Big Chinese Freebie</a></li>
<li><a href="../270683/index.html">Christmas gifts from 3CX</a></li>
<li><a href="../270685/index.html">Using large pages in memory in PHP 7</a></li>
<li><a href="../270687/index.html">Who was on the server?</a></li>
<li><a href="../270691/index.html">Cloud for development companies: Babystep.tv uses Azure to launch ‚Äúrockets‚Äù from its new SPACEPORT</a></li>
<li><a href="../270693/index.html">Report from the #PostgreSQLRussia mitap on November 3</a></li>
<li><a href="../270695/index.html">The three best technology companies of the Forum and the Open Innovations Technology Show received IBM cloud grants in the amount of $ 120,000</a></li>
<li><a href="../270697/index.html">Overview of ES6 at 350 points. Part two</a></li>
<li><a href="../270699/index.html">Instant File Initialization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>