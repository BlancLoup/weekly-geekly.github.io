<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory model in the examples and not only</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the continuation of a series of topics called "the fundamental things about Java that are worth knowing, but which many do not know." Previous topi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory model in the examples and not only</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/cd78f779/ad7a4de3/af925150/ca8a006c.png" align="left">  <font color="grey"><i>In the continuation of a series of topics called "the fundamental things about Java that are worth knowing, but which many do not know."</i></font>  <font color="grey"><i>Previous topic: <a href="http://habrahabr.ru/blogs/java/133907">Binary compatibility in the examples and not only</a></i></font> <br><br>  The Java memory model is something that influences the way any java developer code works.  Nevertheless, quite a few people neglect the knowledge of this important topic, and sometimes come up against completely unexpected behavior of their applications, which is explained precisely by the features of the JMM device.  Take, for example, a very common and <b>incorrect</b> implementation of the Double-checked locking pattern: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Keeper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Data data = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Data </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data(); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } }</code> </pre> <br>  People who write such code try to improve performance by avoiding blocking if the value has already been assigned.  Unfortunately, these people do not take into account many factors, as a result of the manifestation of which a zombie apocalypse can happen.  Under the cut, I will tell the theory and give examples of how something can go wrong.  In addition, as they said in one Indian film, ‚ÄúIt‚Äôs not enough to know what is wrong.  You need to know how to make it so. ‚Äù  Therefore, recipes for success can also be found further. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  A little bit of history </h1>  The first version of JMM appeared along with Java 1.0 in 1995.  It was the first attempt to create a consistent and cross-platform memory model.  Unfortunately, or fortunately, it had several serious flaws and misunderstandings.  One of the saddest problems was the absence of any guarantees for final fields.  That is, one thread could create an object with a final-field, and another thread could not see the values ‚Äã‚Äãin this final-field.  Even the <b><code>java.lang.String</code></b> class was subject to this.  In addition, this model did not allow the compiler to produce many effective optimizations, and when writing multi-threaded code it was difficult to be sure that it would actually work as expected. <br><br>  Therefore, in 2004, JSR 133 appeared in Java 5, in which the shortcomings of the original model were eliminated.  We will talk about what happened. <br><br><h1>  Atomicity </h1>  Although many people know this, I consider it necessary to recall that on some platforms, some write operations may turn out to be non-atomic.  That is, while the value is being recorded by one stream, another stream may see some intermediate state.  There is no need to go far for an example - the records of the same long and double, if they are not declared as volatile, do not have to be atomic and on many platforms are written in two operations: the high and low 32 bits separately.  (see <a href="http://java.sun.com/docs/books/jls/second_edition/html/memory.doc.html">standard</a> ) <br><br><h1>  Visibility </h1><br>  In the old JMM, each of the running threads had its own cache (working memory), in which were stored some of the states of the objects that this thread manipulated.  Under some conditions, the cache was synchronized with the main memory (main memory), but nevertheless a significant portion of the time values ‚Äã‚Äãin the main memory and in the cache could diverge. <br><br>  In the new model of memory, such a concept was abandoned, because where exactly the value is stored is not interesting to anyone at all.  <b>It is only important under which conditions one thread sees the changes made by another thread</b> .  In addition, iron is already smart enough to cache something, put it into registers, and get up other operations. <br><br>  It is important to note that, unlike C ++, out-of-thin-air values ‚Äã‚Äãare never taken: for any variable, the value observed by the flow is either assigned to it or is default. <br><br><h1>  Reordering </h1>  But this, as they say, is not all.  <font color="grey"><s>If you place an order right now, your instructions will be rearranged in places completely free of charge!</s></font>  Processors show incredible agility in optimizing the execution of instructions.  The compiler and JIT also help them in this.  One of the remarkable effects may be that the actions performed by one thread, another thread see in a different order.  This phrase is quite difficult to understand, just reading, because I will give an example.  Let there is such a code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReorderingSample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ first = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; second = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!second); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> first; } }</code> </pre><br>  And in this code, the <b><code>checkValues</code></b> method is called from one thread, and the <b><code>checkValues</code></b> method is <b><code>checkValues</code></b> from another thread.  It would seem that the code should run without problems, because the <b><code>second</code></b> field is set to <b><code>true</code></b> later than the <b><code>first</code></b> field, and therefore when (more precisely, if) we see that the second field is true, then the first one should also be like this.  But it was not there. <br><br>  Although you may not worry about this within one thread, in a multithreaded environment the results of operations performed by other threads may be observed in the wrong order.  In order not to be unfounded, I wanted to ensure that assertion worked on my machine, but I did not succeed for so long ( <font color="grey">no, I did not forget to specify the <b><code>-ea</code></b> switch when I started <b><code>-ea</code></b></font> ) that, desperate, I asked the question still provoke reordering "to the well-known performance-engineers.  So Sergey Kuksenko answered my question: <br><blockquote>  On machines with TSO (which includes x86) is quite difficult to show. <br>  breaking reordering.  This can be shown on any ARM or <br>  PowerPC.  You can also refer to the Alpha - the processor with the weakest rules of ordering.  Alpha - it was a nightmare for developers of compilers and operating system kernels.  Happiness that he did die.  On the net you can find masses of stories about it. <br><br>  Classic example: <br>  <font color="grey"><i>(example is similar to the one above - author‚Äôs comment)</i></font> <br>  ... on x86 will always work correctly, because if you saw <br>  If you set the ‚Äúb‚Äù, then you will see the ‚Äúa‚Äù. <br></blockquote><br><br>  And when I said that I would like for each aspect considered in the article to find a working demo of what is happening, Sergey pleased me, saying that <b><i>it is necessary to read manuals on the corresponding hardware for a long time and diligently.</i></b>  For a while I was thinking about trying to get an effect on the phone, but in the end I decided that it was not so important.  In addition, I still specialize not at all on the features of any specific platforms. <br><br>  So, back to our original example and see how it can spoil reordering.  Let our <b><code>Data</code></b> class in the constructor perform some not-so-trivial calculations and, most importantly, write some values ‚Äã‚Äãinto <b>non-final</b> fields: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String question; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> answer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxAllowedValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.answer = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.question = reverseEngineer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.answer); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxAllowedValue = <span class="hljs-number"><span class="hljs-number">9000</span></span>; } }</code> </pre><br><br>  It turns out that the stream that first finds that <b><code>data == null</code></b> will perform the following actions: <ol><li>  Allocate memory for a new object </li><li>  Call the <b><code>Data</code></b> class constructor </li><li>  Write the value <b>42</b> in the <b><code>answer</code></b> field of the class <b><code>Data</code></b> </li><li>  Write some string in the <b><code>question</code></b> field of the <b><code>Data</code></b> class. </li><li>  Write the value <b>9000</b> in the <b><code>maxAllowedValue</code></b> field of the <b><code>Data</code></b> class </li><li>  Write the newly created object in the <b><code>data</code></b> field of the <b><code>Keeper</code></b> class. </li></ol>  Feel the catch?  Nothing prevents another thread from seeing what happened in point 6 <b>before</b> it sees what happened in points 3-5.  As a result, this thread will see the object in the incorrect state, when its fields have not yet been established.  This, of course, does not suit anyone, and therefore there is a rigid set of rules according to which the optimizer / compiler / your evil counterpart is forbidden to perform reordering. <br><br><h1>  Happens-before </h1><h2>  Definition </h2>  All these rules are set using the so-called <i>happens-before</i> relationship.  It is defined as: <br><blockquote>  Let there be a stream <b>X</b> and a stream <b>Y</b> (not necessarily different from the stream <b>X</b> ).  And let there be operations <b>A</b> (running on thread <b>X</b> ) and <b>B</b> (running on thread <b>Y</b> ). <br><br>  In this case, <b>A happens-before B</b> means that <i>all changes made by flow <b>X</b> before operation <b>A</b> and changes that this operation has caused are visible to flow <b>Y</b> at the time of operation <b>B</b> and after the operation.</i> </blockquote>  In words, such a definition may not be perceived very well, therefore I will explain a little.  Let's start with the simplest case, when there is only one flow, that is, <b>X</b> and <b>Y</b> are the same.  Inside one thread, as we have said, there are no problems, because the operations with respect to each other, happens to be in accordance with the order in which they are specified in the source code (program order).  For a multithreaded case, everything is somewhat more complicated, and here without ... the pictures cannot be understood.  And here she is: <br><br><img src="https://habrastorage.org/storage1/46d939ea/1b308bfd/7919f9ec/d1d3b73c.png" align="left"><br>  Here, on the left, the green marks are those operations that are guaranteed to be seen by the Y stream, and the red ones are those that may not be seen.  On the right, red marks those operations that, while performing, may still not see the results of performing green operations, to the left, and green - those that, when performed, will see everything.  It is important to note that the happens-before relation is <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B8%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">transitive</a> , that is, if A <i>happens-before</i> B and B <i>happens-before</i> C, then A <i>happens-before</i> C. <br><br><h2>  Operations related to the happens-before relationship </h2><br>  Now let's see what exactly the restrictions on reordering are in the JMM.  A deep and detailed description can be found, for example, in <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook</a> , but I will give everything on a somewhat more superficial level and, perhaps, skip some of the limitations.  Let's start with the simplest and most famous: locks. <br><br>  <b>1.</b> releasing the monitor <i>happens-before</i> the monitor of <b>the same</b> monitor.  Please note: it is the release, not the exit, that is, you can not worry about safety when using <b><code>wait</code></b> . <br><br>  Let's see how this knowledge will help us correct our example.  In this case, everything is very simple: just remove the external check and leave the synchronization as it is.  Now the second stream is guaranteed to see all the changes, because it will receive the monitor only after another thread releases it.  And since he will not let it go until everything initializes, we will see all the changes at once, not separately: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Keeper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Data data = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Data </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } }</code> </pre><br>  <b>2.</b> Writing to the volatile variable <i>happens-before</i> reading from the same variable. <br><br>  The change that we made, of course, corrects the incorrectness, but returns the one who wrote the original code to where it came from - to block each time.  Rescue can keyword volatile.  In fact, the considered statement (2) means that when reading everything that is declared volatile, we will always receive the current value.  In addition, as I said before, for volatile fields, an entry is always (including long and double) an atomic operation.  Another important point: if you have a volatile entity that has links to other entities (for example, an array, List, or some other class), then always the link to the entity itself, but not everything, will always be "fresh" incoming <br><br>  So back to our Double-locking sheep.  Using volatile, you can fix the situation like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Keeper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Data data = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Data </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data(); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } }</code> </pre><br>  Here we still have a lock, but only if <b><code>data == null</code></b> .  We filter out the remaining cases using volatile read.  Correctness is ensured by the fact that volatile store <i>happens-before</i> volatile read, and all operations that occur in the constructor are visible to the person who reads the field value. <br><br>  In addition, it uses an interesting assumption that is worth checking out: volatile store + read is faster than blocking.  However, as all the same productivity engineers tirelessly repeat to us, microbench marks have little to do with reality, especially if you don‚Äôt know how the thing you are trying to measure is arranged.  Moreover, if you think you know how it is arranged, then you are most likely mistaken and do not take into account any important factors.  I do not have enough confidence in the depth of my knowledge to make my benchmarks, so there will be no such measurements here.  However, there is some information on volatile performance in this <a href="http://people.apache.org/~shade/talks/javaday-Oct2011-jmm.pdf">presentation</a> starting on slide # 54 (although I strongly recommend reading everything).  <b>UPD:</b> there is an interesting <a href="http://habrahabr.ru/blogs/java/129494/">comment</a> in which they say that volatile is significantly faster than synchronization, by design. <br><br>  <b>3.</b> Writing a value in the <b><code>final</code></b> field (and, if this field is a link, then all the variables reachable from this field (dereference-chain)) when constructing an object, it <i>happens-before</i> writing this object to any variable that occurs outside this constructor. <br><br>  This also looks rather confusing, but in fact the essence is simple: if there is an object that has a <b><code>final</code></b> field, then this object can be used only after setting this <b><code>final</code></b> field (and everything that this field can refer to).  You should not forget, however, that if you pass a link to the constructed object (ie, <b><code>this</code></b> ) out of the constructor, someone can see your object in an unfinished state. <br><br>  In our example, it turns out that it is enough to make the field write to which happens last, <b><code>final</code></b> , how everything will magically work without <b><code>volatile</code></b> and without synchronization every time: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String question; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> answer; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxAllowedValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.answer = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.question = reverseEngineer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.answer); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxAllowedValue = <span class="hljs-number"><span class="hljs-number">9000</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseEngineer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> answer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre><br>  Only this is the salt that it will work magically, and a person who does not know about your clever trick may not understand you.  Yes, and you too can forget about it pretty quickly.  There is, of course, an option to add a proud comment like ‚Äúneat trick here!‚Äù, Describing what is happening here, but for some reason this seems to me not a very good practice. <br><br>  <b>UPD:</b> This is not true.  The comments describe <a href="http://habrahabr.ru/blogs/java/133981/">why</a> .  <b>UPD2</b> : According to the results of the discussion, Ruslan wrote <a href="http://cheremin.blogspot.com/2011/12/final.html">an article</a> . <br><br>  In addition, it is important to remember that the fields are also static, and that the JVM classes are guaranteed to initialize only once upon the first access.  In this case, the same singleton ( <font color="grey">we will not call it a pattern or an anti-pattern within this article. The article is not about that at all;)</font> ) like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Singleton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceContainer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Singleton instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Singleton(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InstanceContainer.instance; } }</code> </pre>  This, of course, is not a tip on how to implement a singleton, since everyone who read Effective Java knows that if you are <font color="grey"><s>completely unexpected for some reason, for some reason you</s></font> decide to write it, it is best to use enum and get from the boxes solve all problems with multithreading, and with serialization, and with cloning.  <b>UPD:</b> For how best to implement singleton, you can read <a href="http://habrahabr.ru/blogs/java/129494/">this</a> topic. <br><br>  By the way, to those who know that final-fields can be changed through Reflection and interested in how such changes will be visible, I can say this: ‚Äúeverything seems to be fine, it‚Äôs just not clear why, and it‚Äôs not clear whether everything is really whether well. "  There are several topics on this topic, most of <a href="http://cheremin.blogspot.com/2011/06/reflection.html">this</a> online.  If someone tells in the comments how it really is, I will be extremely happy.  However, if no one tells, then I myself will find out and will definitely tell.  <b>UPD</b> : In the comments <a href="http://habrahabr.ru/blogs/java/133981/">told</a> . <br><br>  Surely there are some other operations related to the happens-before relationship that I did not cover in this article, but they are much more specific, and if you have interest, you can find them yourself in the <a href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html">standard</a> or somewhere else, and then share them with all in the comments. <br><br><h1>  Credits, links and stuff </h1>  First of all, I would like to thank for some of the consultations and the preliminary verification of the article on the content of the clinical nonsense of the previously mentioned productivity engineers: <b>Alexey <a href="https://habrahabr.ru/users/theshade/" class="user_link">TheShade</a> Shipilev</b> and <b>Sergey <a href="https://habrahabr.ru/users/walrus/" class="user_link">Walrus</a> Kuksenko</b> . <br><br>  I also provide a list of sources that I used when writing the article and just good links on the topic: <ul><li>  <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a> by Doug Lea </li><li>  <a href="http://people.apache.org/~shade/talks/javaday-Oct2011-jmm.pdf">Slides from the report about the Java Memory Model</a> by Sergey Kuksenko </li><li>  <a href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html">Chapter 17. Threads and Locks</a> of Java Language Specification </li><li>  <a href="http://www.javaspecialist.ru/2011/06/java-memory-model.html">Java Memory Model in brief</a> by Artem Danilov </li><li>  <a href="http://jcip.net/">Java Concurrency in Practice</a> </li></ul>  Leave interesting questions, additions and corrections in the comments, I will be glad to read and answer. </div><p>Source: <a href="https://habr.com/ru/post/133981/">https://habr.com/ru/post/133981/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133976/index.html">What engine do you use to create HTML5 games?</a></li>
<li><a href="../133977/index.html">Mandate Tag Management in MAFM 3.0</a></li>
<li><a href="../133978/index.html">FTBB programmer for minimalist Arduino</a></li>
<li><a href="../133979/index.html">How do you pronounce python (in Russian)?</a></li>
<li><a href="../133980/index.html">JSF GUI Development Experience</a></li>
<li><a href="../133982/index.html">Habrahabr - winner ROTOR 2011</a></li>
<li><a href="../133983/index.html">Impressive Solids: making a game in C # under OpenGL, part I</a></li>
<li><a href="../133984/index.html">Setting up a proxy on the firmware Tomato</a></li>
<li><a href="../133987/index.html">Choosing a distributed file system for Linux. A few words about Ceph and the rest</a></li>
<li><a href="../133988/index.html">Gingerbread holds 50.51% of the market for Android smartphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>