<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to OCaml: OCaml Program Structure [2]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[approx. Lane: continued translation, the first article here ] 

 OCaml program structure 
 Now we will spend a little time on the high-level analysis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to OCaml: OCaml Program Structure [2]</h1><div class="post__text post__text-html js-mediator-article">  [approx.  Lane: continued translation, the first article <a href="http://habrahabr.ru/blogs/programming/108529">here</a> ] <br><img src="https://habrastorage.org/getpro/habr/post_images/923/f9c/3a3/923f9c3a37d9a2263615e60b69ed03c8.png" alt="teaser for an article with graphics on OCaml" align="right"><br><h1>  OCaml program structure </h1><br>  Now we will spend a little time on the high-level analysis of some real OCaml programs.  I would like to show you local and global definitions, the difference in use <nobr><code>;;</code></nobr>  <nobr>and <code>;</code></nobr>  , modules, nested functions, links.  Because of this, we will encounter many OCaml concepts that so far have no sense for a beginner to learn OCaml, since we have not met them before.  Do not focus on them, focus instead on a general idea of ‚Äã‚Äãthe format of the programs and language features that I will point to. <br><br><h2>  Local "variables" (actually local expressions) </h2><br>  Take our <code>average</code> function on C and add local variables to it (compare it with an example in the last chapter). <br><br><pre> double average (double a, double b)
 {
   double sum = a + b;
   return sum / 2;
 }
</pre><br>  Now look at this for OCaml: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> let average ab =
   let sum = a +.  b in
   sum /.  2.0 ;;
</pre><br>  The standard expression <code>let name = expression in</code> used to define a local named expression and <code>name</code> can be used in the future instead of expression up to <code>;;</code>  , which means the end of the local code block.  Notice we didn‚Äôt even use the indent after the in declaration.  Just take the <code>let ... in</code> as if it were a single statement. <br><a name="habracut"></a><br>  Now, comparing local variables on C and the above local named expressions is a matter of manual dexterity.  Although they differ in something.  The variable <code>sum</code> in C code uses memory on the stack.  You can later assign the sum any value you want, or even get a memory address where the value is stored.  For the OCaml version this is not the case.  In it, <code>sum</code> is just the short name of the expression <code>a +. b</code>  <code>a +. b</code> .  There is no way to assign anything to a <code>sum</code> .  (A little later we will show how to create variables for which you can change the value). <br><br>  Here is another example for final clarification.  These two code snippets should return the same value ((a + b) + (a + b) <sup>2</sup> ): <br><br><pre> let fab =
   (a +. b) +.  (a +. b) ** 2.
   ;;
</pre><br><pre> let fab =
   let x = a +.  b in
   x +.  x ** 2.
   ;;
</pre><br>  The second version should be faster in theory (but most compilers will be able to implement the stage called ‚Äúdestroying common subexpressions‚Äù for you), and it is definitely easier to read.  <code>x</code> in the second example is just a short name for <code>a +. b</code>  <code>a +. b</code> . <br><h2>  Global "variables" (actually global expressions) </h2><br>  You can also define global names for different things at the top level, and, like local ‚Äúvariables‚Äù above, they are not really variables, they are short names for different things.  Here is a real (albeit slightly trimmed) example: <br><br><pre> let html =
   let content = read_whole_file file in
   GHtml.html_from_string content
   ;;<font></font>
<font></font>
 let menu_bold () =
   match bold_button # active with
     true -&gt; html # set_font_style ~ enable: [`BOLD] ()
   |  false -&gt; html # set_font_style ~ disable: [`BOLD] ()
   ;;<font></font>
<font></font>
 let main () =
   (* code omitted *)
   factory # add_item "Cut" ~ key: _X ~ callback: html # cut
   ;;
</pre><br><br>  This is a piece of real code.  <code>html</code> - a widget for editing HTML (a library object lablgtk), created at the beginning of the program with the expression <code>let html =</code> .  Then, further, it is used in several functions. <br><br>  Please note that the name <code>html</code> in the code snippet above should not be taken as a real global variable, as in C or other imperative languages.  There is no memory allocation for "storing" a " <code>html</code> pointer."  It is impossible to assign <code>html</code> something, for example, to redefine it as a pointer to another widget.  In the next section, we will discuss links that are real variables. <br><br><h2>  let-binding </h2><br>  Any use of <code>let ...</code> , no matter where, at the top level (globally) or inside functions (locally), is often called let-binding (binding using let). <br><br><h2>  References: Real Variables </h2><br>  And what if you want a real variable, the value of which you can assign and change during the program?  In this case, you need to use the <b>link</b> .  Links are very similar to pointers in C / C ++.  In Java, all variables that store objects are actually references (pointers) to objects.  In Perl, links are links, just like in OCaml. <br><br>  Here is how we create an <code>int</code> link in OCaml: <br><br><pre> ref 0 ;;
</pre><br>  In fact, such an expression is not very useful.  We created a link and due to the fact that we did not give her a name, the garbage collector immediately came and collected it!  (In fact, most likely, it will be thrown out at the compilation stage).  Let's give the link a name: <br><br><pre> let my_ref = ref 0 ;;
</pre><br>  This link currently stores a whole zero.  Let's now write another value into it (assignment operation): <br><br><pre> my_ref: = 100 ;;
</pre><br>  And let's see what the link stores now: <br><br><pre> #! my_ref ;;
 -: int = 100
</pre><br>  So, the operator <code>:=</code> used to assign links, and the operator <code>!</code>  dereference links returning content.  Here is a rough but effective comparison with C / C ++: <br><table><tbody><tr><th>  Ocaml </th><th>  C / C ++ </th></tr><tr><td><pre> let my_ref = ref 0 ;;
 my_ref: = 100 ;;  
 ! my_ref
</pre><br></td><td><pre> int a = 0;  int * my_ptr = &amp; a;
 * my_ptr = 100;
 * my_ptr
</pre><br></td></tr></tbody></table><br>  The links have their own scope, but you will not use them too often.  The use of <code>let name=expression in</code> to name local expressions in your functions will be much more frequent. <br><h2>  Nested functions </h2><br>  There is no concept of nested functions in C.  GCC supports nested functions for C programs, but I don‚Äôt know of any programs that would use this extension.  In any case, this is what gcc's info page writes about nested functions: <br><blockquote>  A nested function is a function defined inside another function (Nested functions are not supported for GNU C ++).  The names of nested functions are local to the block in which they were defined.  For example, here is the definition of the nested function 'square', which is called twice: <br><br><pre> foo (double a, double b)
 {
   double square (double z) {return z * z;  }<font></font>
<font></font>
   return square (a) + square (b);
 }
</pre><br>  The nested function has access to all the functions of the external function that are visible at the time of the function definition.  This is the so-called "area of ‚Äã‚Äãlexical visibility."  Here is an example of a nested function that inherits a variable called offset: <br><br><pre> bar (int * array, int offset, int size)
 {
   int access (int * array, int index)
     {return array [index + offset];  }
   int i;
   / * ... * /
   for (i = 0; i &lt;size; i ++)
     / * ... * / access (array, i) / * ... * /
 }
</pre><br></blockquote><br>  I hope the idea is clear.  Nested functions, however, are very useful and are actively used in OCaml.  Here is an example of using a nested function from a real code: <br><br><pre> let read_whole_channel chan =
   let buf = Buffer.create 4096 in
   let rec loop () =
     let newline = input_line chan in
     Buffer.add_string buf newline;
     Buffer.add_char buf '\ n';
     loop ()
   in
   try
     loop ()
   with
     End_of_file -&gt; Buffer.contents buf ;;
</pre><br>  Don't worry yet, if you don't understand this code entirely - it contains many concepts that we haven‚Äôt talked about yet.  Instead, concentrate on the central nested <code>loop</code> function, which takes an argument of type <code>unit</code> .  You can call <code>loop ()</code> from the read_whole_channel function, and it is not defined outside the function.  The nested function has access to the variables defined in the main function (so the <code>loop</code> gets access to the local variables <code>buf</code> and <code>chan</code> ). <br><br>  The form for defining a nested function is similar to the task of a local named expression: <code>let name <em>arguments</em> = <em>function-defenition</em> in.</code> <br><br>  Usually the function definition is indented on a new line (as in the example above).  And remember to use <code>let rec</code> instead of <code>let</code> if the function is recursive (as in the example above). <br><br><h2>  Modules and <code>open</code> command </h2><br>  OCaml comes with many interesting modules (libraries with useful code).  For example, there are standard libraries for drawing graphs, creating GUI interfaces using a set of widgets, handling large numbers, data structures, and making POSIX system calls.  These libraries are located in / usr / lib / ocaml / VERSION (on Unix).  For our examples, we will focus on a fairly simple module called <code>Graphics</code> . <br><br>  The <code>Graphics</code> module consists of 5 files (on my system): <br><br><pre> /usr/lib/ocaml/3.08/graphics.a
 /usr/lib/ocaml/3.08/graphics.cma
 /usr/lib/ocaml/3.08/graphics.cmi
 /usr/lib/ocaml/3.08/graphics.cmxa
 /usr/lib/ocaml/3.08/graphics.mli
</pre><br>  [approx.  Trans .: and on my system (Debian Sid) the modules are dumped directly into / usr / lib / ocaml, without specifying the version]. <br><br>  First, we concentrate on the file <code>graphics.mli</code> .  This is a text file, so you can easily see its contents.  First of all, note that the name is <code>graphics.mli</code> , not <code>Graphics.mli</code> .  OCaml always makes the first letter of the file name capitalized when it comes to modules.  This can be quite confusing, unless you know about it beforehand. <br><br>  If we want to use functions in <code>Graphics</code> , then there are two ways.  Or at the beginning of our program we write the <code>open Graphics;;</code> declaration <code>open Graphics;;</code>  or we supplement all calls to the corresponding functions with the prefix: <code>Graphics.open_graph.open</code> .  <code>open</code> slightly resembles the <code>import</code> function in Java, and slightly more (recalls) the <code>use</code> expression in Perl. <br><br>  [For Windows users: In order for this example to work interactively in Windows, you will need to create a separate top level (toplevel).  Run a command from the command line like this: ocamlmktop -o ocaml-graphics graphics.] <br><br>  A couple of the following examples should clarify everything (These two examples paint different things - try them both).  Notice that the first example calls <code>open_graph</code> , the second one calls <code>Graphics.open_graph</code> .  [approx.  Trans .: At the beginning of the article screenshots of what programs do]. <br><br><pre> (* To compile this example: ocamlc graphics.cma grtest1.ml -o grtest1 *)<font></font>
<font></font>
 open Graphics ;;<font></font>
<font></font>
 open_graph "640x480" ;;
 for i = 12 downto 1 do
   let radius = i * 20 in
   set_color (if (i mod 2) = 0 then red else yellow);
   fill_circle 320 240 radius
 done ;;
 read_line () ;;
</pre><br><hr><br><br><pre> (* To compile this example: ocamlc graphics.cma grtest2.ml -o grtest2 *)<font></font>
<font></font>
 Random.self_init () ;;
 Graphics.open_graph "640x480" ;;<font></font>
<font></font>
 let rec iterate r x_init i =
         if i = 1 then x_init
         else
                 let x = iterate r x_init (i-1) in
                 r *.  x *.  (1.0 -. X) ;;<font></font>
<font></font>
 for x = 0 to 639 do
         let r = 4.0 *.  (float_of_int x) /.  640.0 in
         for i = 0 to 39 do
                 let x_init = Random.float 1.0 in
                 let x_final = iterate r x_init 500 in
                 let y = int_of_float (x_final *. 480.) in
                 Graphics.plot xy
         done
 done ;;<font></font>
<font></font>
 read_line () ;;
</pre><br>  Both examples use some language features that we haven‚Äôt talked about yet: imperative <code>for</code> loops, <code>if-then-else</code> blocks, recursion.  We will discuss this later.  Regardless, you can still: (1) try to understand how they work (2) how type inference allows you to catch errors. <br><h2>  <code>Pervasives</code> module </h2><br>  There is one module that does not need "open".  This is the <code>Pervasives</code> module (located in /usr/lib/ocaml/3.08/pervasives.mli [note: I have /usr/lib/ocaml/pervasives.mli]).  All characters from the <code>Pervasives</code> module are automatically imported into all OCaml programs. <br><h2>  Rename modules </h2><br>  What if you want to use symbols from <code>Graphics</code> , but don't want to import them all, and you are lazy to type Graphics every time?  Just rename the module using this trick: <br><br><pre> module Gr = Graphics ;;<font></font>
<font></font>
 Gr.open_graph "640x480" ;;
 Gr.fill_circle 320 240 240 ;;
 read_line () ;;
</pre><br>  In fact, this technique is very useful if you want to import a nested module (modules can be nested one into another), but you do not want to print the path to the nested module each time. <br><h2>  When to use and when to skip <code>;;</code>  and <code>;</code> </h2><br>  Now we consider a very important question.  When to use <code>;;</code>  when to use <code>;</code>  and when should you skip both options?  This tricky question remains as long as you understand it well.  He was worried about the author for a long time while he was studying OCaml. <br><br>  Rule number 1 - you must use <code>;;</code>  to separate statements in the top level of your code (top-level) and <b><em>never</em></b> inside the definition of functions or any other kind of statements. <br><br>  Let's look at a fragment when from the second example with graphics: <br><br><pre> Random.self_init () ;;
 Graphics.open_graph "640x480" ;;<font></font>
<font></font>
 let rec iterate r x_init i =
         if i = 1 then x_init
         else
                 let x = iterate r x_init (i-1) in
                 r *.  x *.  (1.0 -. X) ;;
</pre><br><br>  We have two statements at the top level and the definition of the <code>iterate</code> function.  Each of them ends <code>;;</code>  . <br><br>  Rule number 2 - <em>sometimes</em> you can skip <code>;;</code>  .  As a neophyte, you should not worry too much about this rule and always write <code>;;</code>  , as prescribed by rule number 1.  But if you read someone else's code, you will occasionally encounter the absence <code>;;</code>  .  Places to drop <code>;;</code>  : <br><ul><li>  Before the <code>let</code> keyword; </li><li>  Before the <code>open</code> keyword; </li><li>  Before the keyword <code>type</code> ; </li><li>  At the very end of the file </li><li>  In several other (very rare) cases where OCaml can ‚Äúassume‚Äù that the next element is the beginning of a new statement, not a continuation of the current one. </li></ul><br>  Here is an example code where <code>;;</code>  omitted where possible: <br><br><pre> open Random (* ;; *)
 open Graphics ;;<font></font>
<font></font>
 self_init () ;;
 open_graph "640x480" (* ;; *)<font></font>
<font></font>
 let rec iterate r x_init i =
         if i = 1 then x_init
         else
                 let x = iterate r x_init (i-1) in
                 r *.  x *.  (1.0 -. X) ;;<font></font>
<font></font>
 for x = 0 to 639 do
         let r = 4.0 *.  (float_of_int x) /.  640.0 in
         for i = 0 to 39 do
                 let x_init = Random.float 1.0 in
                 let x_final = iterate r x_init 500 in
                 let y = int_of_float (x_final *. 480.) in
                 Graphics.plot xy
         done
 done ;;<font></font>
<font></font>
 read_line () (* ;; *)
</pre><br>  Rules No. 3 and No. 4 apply to <code>;</code>  .  They are completely different from the rules for <code>;;</code>  .  A single semicolon (;) is called <b>a sequence point</b> .  Trans .: I can be wrong with the translation of the sequence point], which plays exactly the same role as a single semicolon in C, C ++, Java or Pearl.  It means "do everything after this place when you do everything before it."  I bet you didn't know that. <br><br>  Rule number 3: Consider <code>let ... in</code> statement and never put <code>;</code>  after him. <br><br>  Rule # 4: Complete all other statements in the code block <code>;</code>  <em>except</em> the last one. <br><br>  The internal for loop above is a good example.  Please note that we have never used a single <code>;</code>  in the code. <br><br><pre>         for i = 0 to 39 do
                 let x_init = Random.float 1.0 in
                 let x_final = iterate r x_init 500 in
                 let y = int_of_float (x_final *. 480.) in
                 Graphics.plot xy
         done
</pre><br>  The only place where use is possible <code>;</code>  - this is a line of <code>Graphics.plot xy</code> , but since this is the last line of the block, according to rule No. 4, it is not necessary to install it. <br><br><h2>  Note regarding ";" </h2><br>  Brian Hart corrected me: <br><blockquote> <code>;</code>  - the same operator as, for example, the addition operator ( <code>+</code> ).  Well, not quite as +, but in fact - exactly.  + has the type <code>int -&gt; int -&gt; int</code> - it takes two integers and returns an integer (their sum). <code>;</code>  has type <code>unit -&gt; 'b -&gt; 'b</code> - it takes two values ‚Äã‚Äãand simply returns the second.  Unlike the comma in C.  You can write <code>a;b;c;d</code> as easy as you can write <code>a + b + c + d</code> . <br><br>  This is one of those fundamental concepts, an understanding of which gives an understanding of the language, but which never really speaks out loud ‚Äî literally everything in OCaml is an expression.  <code>if/then/else</code> is an expression.  <code>a;b</code> is an expression.  <code>match foo with ...</code> is an expression.  The code below is absolutely correct (and they all do the same thing): <br><br><pre>  let fxby = if b then x + y else x + 0<font></font>
 <font></font>
  let fxby = x + (if b then y else 0)<font></font>
 <font></font>
  let fxby = x + (match b with true -&gt; y | false -&gt; 0)<font></font>
 <font></font>
  let fxby = x + (let gz = function true -&gt; z | false -&gt; 0 in gyb)<font></font>
 <font></font>
  let fxby = x + (let _ = y + 3 in (); if b then y else 0)
</pre><br>  Especially look at the last one - I use <code>;</code>  as an operator for ‚Äúcombining two statements.  All functions in OCaml can be expressed as: <br><pre>  let name [parameters] = expression
</pre><br>  The definition of "expression" in OCaml is somewhat broader than in C.  In fact, C has the concept of "statements", but all the statements in C are just expressions in OCaml (combined <code>;</code> ). <br><br>  The only difference between <code>;</code>  and <code>+</code> is the ability to reference <code>+</code> as a function.  For example, I can define the function <code>sum_list</code> to sum up lists of integers as: <br><pre> let sum_list = List.fold_left (+) 0
</pre><br></blockquote><br><br><h2>  All together: some real code </h2><br>  In this section, we will show some real code snippets from the labgtk 1.2 library (Labgtk is the interface in OCaml for native Unix widgets).  Warning: this code is full of things that we haven‚Äôt talked about yet.  Do not go into details, look instead at the general structure of the code, the place where the authors used <code>;;</code>  where they used <code>;</code>  where they used <code>open</code> , how they beat off text, how they used local and global expressions. <br><br>  ... However, I will give you a few tips to not get lost at all. <br><br><ul><li>  <code>?foo</code> and <code>~foo</code> are ways to specify optional and named arguments to functions in OCaml.  It will not be possible to draw a direct parallel with C-like languages, but Perl, Python and Smalltalk have this concept.  You can call the arguments in the function call, omit some of them and pass the remaining ones in the order that suits you. </li><li>  <code>foo#bar</code> - a method call (a method call called <code>bar</code> with respect to an object called <code>foo</code> ).  This is similar to <code>foo-&gt;bar</code> , <code>foo.bar</code> , <code>$foo-&gt;bar</code> (C ++, Java, Perl). </li></ul><br><br>  The first fragment: The programmer opens a pack of standard libraries (omitting <code>;;</code> because the following keywords are open or let).  It also creates a function called file_dialog.  Inside this function, it defines a named expression called <code>sel</code> using the two-line statement <code>let sel = .. in</code> .  It then calls several methods for sel. <br><br><pre> (* First snippet *)
 open StdLabels
 open GMain<font></font>
<font></font>
 let file_dialog ~ title ~ callback? filename () =
   let sel =
     GWindow.file_selection ~ title ~ modal: true? Filename () in
   sel # cancel_button # connect # clicked ~ callback: sel # destroy;
   sel # ok_button # connect # clicked ~ callback: do_ok;
   sel # show ()
</pre><br>  The second fragment: Just a large list of global names at the top level.  Note that the author has omitted everything <code>;;</code>  according to rule number 2. <br><br><pre> (* Second snippet *)<font></font>
<font></font>
 let window = GWindow.window ~ width: 500 ~ height: 300 ~ title: "editor" ()
 let vbox = GPack.vbox ~ packing: window # add ()<font></font>
<font></font>
 let menubar = GMenu.menu_bar ~ packing: vbox # pack ()
 let factory = new GMenu.factory menubar
 let accel_group = factory # accel_group
 let file_menu = factory # add_submenu "File"
 let edit_menu = factory # add_submenu "Edit"<font></font>
<font></font>
 let hbox = GPack.hbox ~ packing: vbox # add ()
 let editor = new editor ~ packing: hbox # add ()
 let scrollbar = GRange.scrollbar `VERTICAL ~ packing: hbox # pack ()
</pre><br>  The third fragment: The author imports all the characters from the <code>GdkKesyms</code> module.  Then comes the unusual <code>let-binding</code> .  <code>let _ = expression</code> means ‚Äúcalculate the value of the expression (including the execution of all side effects), but throw out the result‚Äù.  In this case, ‚Äúcalculate the value of an expression‚Äù means executing <code>Main.main ()</code> , which is the main GTK loop, a side effect of which is the appearance of a window on the screen and the execution of the entire application.  The ‚Äúresult‚Äù of the call to <code>Main.main ()</code> significant.  Most likely this <code>unit</code> , but I did not check - and it just does not return until the application is completed. <br><br>  Note that this fragment contains long chains, in fact, procedural commands.  This is a real classic imperative program. <br><br><pre> (* Third snippet *)<font></font>
<font></font>
 open GdkKeysyms<font></font>
<font></font>
 let _ =
   window # connect # destroy ~ callback: Main.quit;
   let factory = new GMenu.factory file_menu ~ accel_group in
   factory # add_item "Open ..." ~ key: _O ~ callback: editor # open_file;
   factory # add_item "Save" ~ key: _S ~ callback: editor # save_file;
   factory # add_item "Save as ..." ~ callback: editor # save_dialog;
   factory # add_separator ();
   factory # add_item "Quit" ~ key: _Q ~ callback: window # destroy;
   let factory = new GMenu.factory edit_menu ~ accel_group in
   factory # add_item "Copy" ~ key: _C ~ callback: editor # text # copy_clipboard;
   factory # add_item "Cut" ~ key: _X ~ callback: editor # text # cut_clipboard;
   factory # add_item "Paste" ~ key: _V ~ callback: editor # text # paste_clipboard;
   factory # add_separator ();
   factory # add_check_item "Word wrap" ~ active: false
     ~ callback: editor # text # set_word_wrap;
   factory # add_check_item "Read only" ~ active: false
     ~ callback: (fun b -&gt; editor # text # set_editable (not b));
   window # add_accel_group accel_group;
   editor # text # event # connect # button_press
     ~ callback: (fun ev -&gt;
       let button = GdkEvent.Button.button ev in
       if button = 3 then begin
         file_menu # popup ~ button ~ time: (GdkEvent.Button.time ev);  true
       end else false);
   editor # text # set_vadjustment scrollbar # adjustment;
   window # show ();
   Main.main ()
</pre><br><br>  <em>[approx.</em>  <em>Per.: if someone sees errors or rekkryaki, write, correct]</em> </div><p>Source: <a href="https://habr.com/ru/post/108532/">https://habr.com/ru/post/108532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108525/index.html">What means of publishing and viewing photo-panoramas exist for those who do not use the services of external hosting?</a></li>
<li><a href="../108527/index.html">Dice Wars on App Engine + Twisted</a></li>
<li><a href="../108528/index.html">Cartography in miniature</a></li>
<li><a href="../108529/index.html">Introduction to OCaml: The Basics [1]</a></li>
<li><a href="../108530/index.html">How do you usually pronounce the phrase "MySQL"? In addition to slang "Muskul". Why?</a></li>
<li><a href="../108534/index.html">Thin Provisioning - ‚Äúcredit card‚Äù for storage</a></li>
<li><a href="../108535/index.html">RSS has suddenly changed content</a></li>
<li><a href="../108536/index.html">Process Explorer. Overview of some features</a></li>
<li><a href="../108537/index.html">Numbers Every Programmer Should Know</a></li>
<li><a href="../108539/index.html">Debugging Javascript on Mobile Devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>