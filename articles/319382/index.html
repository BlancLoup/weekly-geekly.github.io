<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How PVS-Studio looks for errors: methods and technologies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PVS-Studio is a static source code analyzer for searching errors and vulnerabilities in C, C ++ and C # programs. In this article I want to give an ov...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How PVS-Studio looks for errors: methods and technologies</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/515/50b/121/51550b121c1cd1d73f2d4f4bb691555a.png" alt="What's inside of PVS-Studio" align="left">  PVS-Studio is a static source code analyzer for searching errors and vulnerabilities in C, C ++ and C # programs.  In this article I want to give an overview of the technologies that we use in the PVS-Studio analyzer to detect errors in the program code.  In addition to general theoretical information, I will use practical examples to show how this or that technology allows detecting errors. <br><br><h2>  Introduction </h2><br>  The reason for writing this article was my presentation at the open conference ISPAS 2016 (ISPRAS OPEN 2016), held in early December in the Main building of the Russian Academy of Sciences.  The topic of the report: ‚ÄúPrinciples of operation of the PVS-Studio static code analyzer‚Äù ( <a href="https://yadi.sk/i/29hbY9qH337G5F">presentation in pptx format</a> ). <br><br>  Unfortunately, the presentation time was very limited, so I had to prepare a very short presentation and not tell a lot of what I wanted in the report.  Therefore, I decided to write this article, where I will talk in more detail about what approaches and algorithms we use when developing the PVS-Studio project. <br><a name="habracut"></a><br>  At the moment, PVS-Studio is, in fact, two separate analyzers: one for C ++, the other for C #.  Moreover, they are written in different languages.  We develop the C ++ analyzer core in C ++, and the C # analyzer core in C #. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, developing these two cores, we use the same approach.  Moreover, a number of employees simultaneously participate in the development of both C ++ and C # diagnostics.  Therefore, later in the article I will not share these analyzers.  The description of the mechanisms will be common to both analyzers.  Yes, of course there are some differences, but for sight-seeing, they are insignificant.  If the need arises in the process of narration, I will clearly indicate whether it is a C ++ analyzer, or C #. <br><br><h2>  Team </h2><br>  Before proceeding to the description of the analyzer, I will say a few words about our company and our team. <br><br>  The PVS-Studio analyzer is developed in the Russian company OOO Program Verification.  The company develops on its own funds received from the sales of PVS-Studio.  The company's office is located in the city of Tula, located 200 km.  from Moscow. <br><br>  Website: <a href="http://www.viva64.com/">http://www.viva64.com</a> <br><br>  At the time of this writing, the company employs 24 people. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/05b/b41/9d7/05bb419d774df59ddfb05cae768177dd.png" alt="PVS-Studio command"></p><br><br>  Some people think that such a product as a code analyzer can be made by one person.  However, this is a big job that requires a lot of person-years.  And even more person-years are required in order to maintain and develop it. <br><br>  We see our mission in popularizing the static code analysis methodology.  And of course, to earn money by developing a powerful tool to identify as many errors as possible at the very early stages of application development. <br><br><h2>  Our achievements </h2><br>  To popularize PVS-Studio, we regularly check various open projects and describe the errors found in them in the <a href="http://www.viva64.com/ru/inspections/">articles</a> .  At the moment we have checked about 270 projects. <br><br>  In the process of writing these articles, we have identified <a href="http://www.viva64.com/ru/examples/">more than 10,000 errors</a> that were reported to the authors of the projects.  We are very proud of this and now I will explain why. <br><br>  If you divide the number of errors found by the number of projects, you get a not very impressive number: about 40 errors per project.  Therefore, I want to highlight an important point.  These 10,000 errors are a side effect.  We never set out to reveal as many errors as possible.  Often we stop when we have found enough defects in a project to write an article. <br><br>  This very well demonstrates the convenience and capabilities of the analyzer.  We are proud that you can just take unfamiliar projects and almost immediately find any errors in them.  If this were not the case, we would not have revealed 10,000 errors simply as a side effect of writing articles to the blog. <br><br><h2>  PVS-Studio </h2><br>  In short, <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> is: <br><br><ul><li>  More than 340 diagnostics for C, C ++; </li><li>  Over 120 diagnostics for C #; </li><li>  Windows; </li><li>  Linux; </li><li>  Plugin for Visual Studio; </li><li>  Quick start (compilation monitoring); </li><li>  Various support features, such as integration with SonarQube and IncrediBuild. </li></ul><br><h3>  Why C and C ++ </h3><br>  C and C ++ languages ‚Äã‚Äãare extremely efficient and elegant.  But in return, they require incredible attention from the programmer and deep knowledge of the subject area.  Therefore, static code analyzers have long been well established among C and C ++ developers.  Moreover, although languages, compilers and development tools are developing, but, as they say, nothing changes.  Now I will explain with an example what I mean. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c4c/479/a03/c4c479a0334d38e4344328e7ad8fd022.png" alt="C ++ &amp; C #"></p><br><br>  By the 30th anniversary of C ++, we tested the first compiler of the Cfront language, written in 1985.  Who is interested in the details, I suggest to read the article " <a href="http://www.viva64.com/ru/b/0355/">On the thirtieth anniversary of the first C ++ compiler: looking for errors in Cfront</a> ". <br><br>  We found the following error in it: <br><br><pre><code class="cpp hljs">Pexpr expr::typ(Ptable tbl) { .... Pclass cl; .... cl = (Pclass) nn-&gt;tp; cl-&gt;permanent=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= use if (cl == 0) error('i',"%k %s'sT missing",CLASS,s); // &lt;= test ....</span></span></code> </pre> <br>  First, the pointer <i>cl is</i> dereferenced, and only then it is checked for NULL equality. <br><br>  It's been 30 years. <br><br>  Now the code before us is not a Cfront compiler, but a modern Clang.  And this is what PVS-Studio detects in it: <br><br><pre> <code class="cpp hljs">.... Value *StrippedPtr = PtrOp-&gt;stripPointerCasts(); PointerType *StrippedPtrTy = dyn_cast&lt;PointerType&gt;(StrippedPtr-&gt;getType()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= use if (!StrippedPtr) // &lt;= test return 0; ....</span></span></code> </pre> <br>  As the saying goes: ‚ÄúBugs.  C ++ bugs never change. ‚Äù  The <i>StrippedPtr</i> pointer is first dereferenced, and only then it is checked for NULL equality. <br><br>  Code analyzers are extremely useful for C and C ++ languages.  Therefore, we have developed and will continue to develop the PVS-Studio analyzer for these languages.  It is not expected that these tools will have less work, as languages ‚Äã‚Äãare extremely popular and at the same time extremely dangerous. <br><br><h3>  Why C # </h3><br>  Of course, in some moments the C # language is more perfect and secure than C ++.  However, he did not manage to go far, and he also delivers a lot of headaches to programmers.  I will confine myself to only one of the examples, but in general this is a topic for a separate article. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32c/618/3b6/32c6183b602495f586649e7c1b7952b3.png" alt="C #, Facepalm"></p><br><br>  We again meet an old friend - the error described above.  Fragment from the PowerShell project: <br><br><pre> <code class="cpp hljs">.... _parameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ParameterMetadata&gt;( other.Parameters.Count, <span class="hljs-comment"><span class="hljs-comment">// &lt;= use StringComparer.OrdinalIgnoreCase); if (other.Parameters != null) // &lt;= test ....</span></span></code> </pre> <br>  First, the <i>other.Parameters</i> link <i>is</i> used to get the <i>Count</i> property, and only then it is checked for <i>null</i> equality. <br><br>  As you can see, the fact that in C # pointers were called links was not better.  As for the various typos, they do not depend on the language at all.  In general, there is work for PVS-Studio and we are actively developing C # -direction. <br><br><h3>  What's next? </h3><br>  So far we have no clear plans, what language we want to support next.  We have two candidates: Objective-C and Java.  We are more inclined to the Java language, but so far we have not finally decided. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d28/524/e5b/d28524e5bca277374c856ddf7bfb0df5.png" alt="What's next?"></p><br><br><h2>  What technologies we do not use in PVS-Studio </h2><br>  Before talking about the internal structure of PVS-Studio, I‚Äôll briefly note what is not in PVS-Studio. <br><br>  PVS-Studio has nothing to do with the Prototype Verification System ( <a href="http://pvs.csl.sri.com/">PVS</a> ).  This is just a coincidence.  The abbreviation PVS is derived from the name of our company Program Verification Systems. <br><br>  PVS-Studio does not directly use the mathematical tools of grammar to find errors.  The analyzer operates at a higher level.  The analysis is performed on the basis <a href="http://www.viva64.com/ru/t/0039/">of the parse tree</a> . <br><br>  PVS-Studio does not use the Clang compiler to analyze C / C ++ code.  Clang is used to perform the preprocessing step.  You can learn more about this in the article " <a href="http://www.viva64.com/ru/b/0186/">A little about the interaction of PVS-Studio and Clang</a> ".  To build the parse tree, we use our own parser, which was based on the now forgotten OpenC ++ library.  However, almost nothing is left of the code of that library, and we will implement support for new language constructs on our own. <br><br>  When working with C # code, we rely on <a href="http://www.viva64.com/ru/b/0399/">Roslyn</a> .  C # PVS-Studio analyzer checks the source code of the program directly, which improves the analysis accuracy compared to checking the binary byte-code (Common Intermediate Lanuage). <br><br>  PVS-Studio does not use string matching and regular expressions for finding errors.  This is a dead end road.  This approach has so many flaws that it is impossible to make at least a qualitative analyzer on its basis, and many diagnostics are in principle impossible to implement.  This topic is discussed in more detail in my article " <a href="http://www.viva64.com/ru/b/0087/">Static Analysis and Regular Expressions</a> ". <br><br><h2>  What technologies do we use in PVS-Studio </h2><br>  To ensure the high quality of the static analysis results, we use advanced methods for analyzing the source code of a program and its control flow graph.  Let's take a look at them. <br><br>  <b>Note.</b>  Further, as examples, some diagnostics will be considered and the principles of their operation are briefly described.  It is important to note that I deliberately omit the description of cases when diagnostics should not work in order not to overload the article with details.  I write this note for those who have not encountered the development of analyzers: do not think that everything is as simple as it will be written below.  Making diagnostics is only 5% of work.  Swearing on a suspicious code is not difficult, it is much more difficult not to swear at the correct code.  95% of the time it takes to develop a diagnostic program to train the analyzer to highlight various programming techniques that, although they look suspicious for diagnostics, are in fact correct. <br><br><h3>  Pattern-based analysis </h3><br>  It is used to search for places in the source code that are similar to known code templates with an error.  There are a lot of patterns, and the complexity of their identification is extremely different.  Moreover, some diagnostics for detecting typos resort to empirical algorithms. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c45/7ee/9e4/c457ee9e4c51b00636d0dd9549364489.png" alt="Pattern-based analysis"></p><br><br>  To begin with, let's look at the two most <b>simple cases</b> that can be identified using pattern analysis.  The first simple case: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*path)[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;e-&gt;dest-&gt;loop_father != path-&gt;last()-&gt;e-&gt;....) { delete_jump_thread_path (path); e-&gt;aux = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ei_next (&amp;ei;); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { delete_jump_thread_path (path); e-&gt;aux = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ei_next (&amp;ei;); }</code> </pre> <br>  PVS-Studio warning: V523 The 'then' statement is equivalent to the 'else' statement.  tree-ssa-threadupdate.c 2596 <br><br>  Regardless of the condition, the same set of actions is always performed.  I think everything is so simple here that no special explanation is required.  By the way, I met this code fragment not in the student‚Äôs term paper, but in the GCC compiler code.  The results of the GCC compiler check can be found in the article " <a href="http://www.viva64.com/ru/b/0425/">Finding errors in the GCC compiler code using the PVS-Studio analyzer</a> ". <br><br>  The second simple case (code taken from the FCEUX project): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((t=(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(next-&gt;name,<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(name+<span class="hljs-number"><span class="hljs-number">1</span></span>))))</code> </pre> <br>  PVS-Studio warning: V518 The 'realloc' function allocates a strange amount of memory calculated by 'strlen (expr)'.  Perhaps the correct variant is 'strlen (expr) + 1'.  fceux cheat.cpp 609 <br><br>  The following error pattern is analyzed.  Programmers know that when they allocate memory for storing a string, they must additionally allocate memory for one character where the end-of-line ( <a href="http://www.viva64.com/ru/t/0088/">terminal zero</a> ) sign will be stored.  In other words, programmers know that they must add +1 or + sizeof (TCHAR).  But they do it sometimes casually.  As a result, they add 1 not to the value that the <i>strlen</i> function returns, but to the pointer. <br><br>  That is exactly what happened in our case.  Instead of <i>strlen (name + 1)</i> should be written <i>strlen (name) +1</i> . <br><br>  Because of this error, the memory is allocated slightly less than required.  Next, a buffer overflow will occur and the consequences will be unpredictable.  Moreover, the program can pretend that it works correctly if, thanks to luck, two bytes after the allocated buffer are not used.  In an even worse scenario, such a defect may produce induced errors that will manifest themselves in a completely different place. <br><br>  Now consider the analysis of the <b>average level of complexity</b> . <br><br>  Diagnostics is formulated as follows: warned if after using the <i>as</i> operator for <i>null</i> the original object is checked instead of the result of the <i>as</i> operator. <br><br>  Consider a code snippet from the CodeContracts project: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override Predicate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JoinWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Predicate other)</span></span></span><span class="hljs-function"> </span></span>{ var right = other as PredicateNullness; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value == right.value) {</code> </pre> <br>  PVS-Studio warning: V3019 Possibly an incorrect variable is compared to null after type conversion using 'as' keyword.  Check variables 'other', 'right'.  CallerInvariant.cs 189 <br><br>  Note that the variable <i>other is</i> checked for equality <i>null</i> , and not at all <i>right</i> .  This is an obvious mistake, because then it works with the <i>right</i> variable. <br><br>  And in the end - a <b>complex pattern</b> associated with the use of macros. <br><br>  The macro expands so that the priority of the operation inside the macro is higher than the priority of the operation outside the macro.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RShift(a) a &gt;&gt; 3 .... RShift(a &amp; 0xFFF) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// a &amp; 0xFFF &gt;&gt; 3</span></span></span></span></code> </pre> <br>  To solve the problem, you need to put the argument <i>a</i> in brackets in brackets (and better, the whole macro is also in brackets), that is, write like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RShift(a) ((a) &gt;&gt; 3),</span></span></code> </pre> <br>  Then the macro will unfold correctly in: <br><br><pre> <code class="cpp hljs">RShift(a &amp; <span class="hljs-number"><span class="hljs-number">0xFFF</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ((a &amp; 0xFFF) &gt;&gt; 3)</span></span></code> </pre> <br>  Description of the pattern looks simple, but in practice the implementation of the diagnosis is very complicated.  It is not enough to analyze only "#define RShift (a) a &gt;&gt; 3".  If you issue warnings on all such lines, there will be too many positives.  It is necessary to look at how the macro is revealed in a particular case, and try to separate situations when it is a special idea, and when there really is not enough brackets. <br><br>  Consider this error on the example code of a real FreeBSD project: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ICB2400_VPINFO_PORT_OFF(chan) \ (ICB2400_VPINFO_OFF + \ sizeof (isp_icb_2400_vpinfo_t) + \ (chan * ICB2400_VPOPT_WRITE_SIZE)) .... off += ICB2400_VPINFO_PORT_OFF(chan - 1);</span></span></code> </pre> <br>  PVS-Studio warning: V733  Check expression: chan - 1 * 20. isp.c 2301 <br><br><h3>  Type inference </h3><br>  Type inference based on the semantic model of the program allows the analyzer to have complete information about all variables and expressions found in the code. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3de/d36/a48/3ded36a48a9b6ee99faa716e0ca02c0f.png" alt="Inheritance"></p><br><br>  In other words, the analyzer must know whether the token <i>Foo is a</i> variable name, a class name or a function.  The analyzer largely repeats the work of the compiler, which also needs to know exactly the type of an object and all the accompanying information about the type: size, signed / unsigned type, if a class, then from whom it is inherited, and so on. <br><br>  It is for this reason that the PVS-Studio analyzer requires you to preprocess * .c / *. Cpp files.  Only by analyzing the preprocessed file can we collect all the information about the types.  Without such information, many diagnostics can not be carried out, or they will give a lot of false positives. <br><br>  <b>Note.</b>  If someone declares that their analyzer is able to check * .c / *. Cpp files as a text document, without full preprocessing, then you should know, this is just self-indulgence.  Yes, such an analyzer can find something, but in general it is a frivolous toy. <br><br>  So, information about types is needed both for detecting errors and, in order, on the contrary, not to issue false warnings.  Especially important information about the classes. <br><br>  Let's take a look at examples of how type information is used. <br><br>  The first example demonstrates that type information is needed to detect an error when working with the <i>fprintf</i> function (the code is taken from the Cocos2d-x project): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WCHAR *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gai_strerrorW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ecode)</span></span></span></span>; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> gai_strerror gai_strerrorW .... fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"net_listen error for %s: %s"</span></span></span><span class="hljs-meta">, serv, gai_strerror(n));</span></span></code> </pre> <br>  PVS-Studio warning: V576 Incorrect format.  Consider checking the fourth argument of the fprintf function.  The type of symbols is expected.  ccconsole.cpp 341 <br><br>  The <i>frintf</i> function expects a pointer of type <i>char *</i> as the fourth argument.  By chance it turned out that the actual argument is a string of type <i>wchar_t *</i> . <br><br>  To identify this error, you need to know the type that <i>gai_strerrorW returns</i> .  If this information is not available, then it is not possible to identify the error. <br><br>  Now consider an example where knowledge of type information prevents a false warning from being issued. <br><br>  Code of the form "* A = * A;"  definitely considered a suspicious analyzer.  However, the analyzer will keep silent if it encounters the following situation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr; .... *ptr = *ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;=   V570</span></span></code> </pre> <br>  The <i>volatile qualifier</i> suggests that this is not a mistake, but a special idea of ‚Äã‚Äãthe programmer.  For some reason, the developer needs to ‚Äútouch‚Äù a memory cell.  Why does he need it - we do not know, but if he does that, then it makes sense and you should not issue a warning. <br><br>  Now let's look at an example of how to detect an error based on knowledge of the class. <br><br>  The sample code is taken from the CoreCLR project: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GCStatistics</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StatisticsBase { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplayAndUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; .... GCStatistics g_LastGCStatistics; .... <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;g_LastGCStatistics, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(g_LastGCStatistics));</code> </pre> <br>  PVS-Studio Warning: V598 The 'memcpy' function is used to copy the fields of the 'GCStatistics' class.  Virtual table pointer will be maintained by this.  cee_wks gc.cpp 287. <br><br>  Copying one object to another using the <i>memcpy</i> function is quite acceptable if the objects are POD structures.  However, there are virtual methods in the class here, which means there is also a pointer to a table of virtual methods.  Copying this pointer from one object to another is extremely dangerous. <br><br>  So, diagnostics became possible due to the fact that we know that the <i>g_LastGCStatistics</i> variable is an instance of a class, and that this class is not a POD type. <br><br><h3>  Symbolic execution </h3><br>  Symbolic execution allows you to calculate the values ‚Äã‚Äãof variables that can lead to errors, to check the ranges (range checking) of values.  In our articles, we sometimes call this the mechanism for calculating virtual values: see, for example, the article " <a href="http://www.viva64.com/ru/b/0394/">Finding errors by calculating virtual values</a> ." <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d86/686/de2/d86686de2ea543b2d40e973a73576ee1.png" alt="Symbolic execution"></p><br><br>  Knowing the estimated values ‚Äã‚Äãof the variables, you can identify errors such as: <br><br><ul><li>  memory leaks; </li><li>  overflow; </li><li>  out of bounds array; </li><li>  dereferencing null pointers in C ++ / accessing null links in C #; </li><li>  meaningless conditions; </li><li>  division by 0; </li><li>  and so on. </li></ul><br>  Consider how using knowledge of the possible values ‚Äã‚Äãof variables you can find various errors.  Let's start with the code snippet taken from the QuantLib project: <br><br><pre> <code class="cpp hljs">Handle&lt;YieldTermStructure&gt; md0Yts() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> q6mh[] = { <span class="hljs-number"><span class="hljs-number">0.0001</span></span>,<span class="hljs-number"><span class="hljs-number">0.0001</span></span>,<span class="hljs-number"><span class="hljs-number">0.0001</span></span>,<span class="hljs-number"><span class="hljs-number">0.0003</span></span>,<span class="hljs-number"><span class="hljs-number">0.00055</span></span>,<span class="hljs-number"><span class="hljs-number">0.0009</span></span>,<span class="hljs-number"><span class="hljs-number">0.0014</span></span>,<span class="hljs-number"><span class="hljs-number">0.0019</span></span>, <span class="hljs-number"><span class="hljs-number">0.0025</span></span>,<span class="hljs-number"><span class="hljs-number">0.0031</span></span>,<span class="hljs-number"><span class="hljs-number">0.00325</span></span>,<span class="hljs-number"><span class="hljs-number">0.00313</span></span>,<span class="hljs-number"><span class="hljs-number">0.0031</span></span>,<span class="hljs-number"><span class="hljs-number">0.00307</span></span>,<span class="hljs-number"><span class="hljs-number">0.00309</span></span>, ........................................................ <span class="hljs-number"><span class="hljs-number">0.02336</span></span>,<span class="hljs-number"><span class="hljs-number">0.02407</span></span>,<span class="hljs-number"><span class="hljs-number">0.0245</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// 60  .... for(int i=0;i&lt;10+18+37;i++) { // i &lt; 65 q6m.push_back( boost::shared_ptr&lt;Quote&gt;(new SimpleQuote(q6mh[i])));</span></span></code> </pre> <br>  PVS-Studio warning: V557 Array overrun is possible.  The value of 'i' index could reach 64. markovfunctional.cpp 176 <br><br>  Here the analyzer knows the following data: <br><br><ul><li>  <i>q6mh</i> array contains 60 elements; </li><li>  the array counter <i>i</i> will take the values ‚Äã‚Äã[0..64]. </li></ul><br>  Knowing this data, the V557 diagnostics detects an out of bounds of the array when performing the operation <i>q6mh [i]</i> . <br><br>  Now consider a situation where division by 0 may occur. The code is taken from the Thunderbird project: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnboxedTypeSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSValueType type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ....... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-function"><span class="hljs-function">Minstruction *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUnboxedProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = offset / UnboxedTypeSize(unboxedType);</code> </pre> <br>  PVS-Studio warning: V609 Divide by zero.  Denominator range [0..8].  ionbuilder.cpp 10922 <br><br>  The <i>UnboxedTypeSize</i> function returns various values, including 0. Without checking that the result of the function can be 0, it is used as a denominator.  This could potentially lead to the division of the variable <i>offset</i> by 0. <br><br>  The previous examples dealt with a range of integer values.  However, the analyzer operates with values ‚Äã‚Äãof other data types, for example, with strings and pointers. <br><br>  Consider an example of incorrect handling of strings.  In this case, the analyzer stores information that the entire string has been converted to upper or lower case.  This allows you to identify the following situations: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> lowerValue = value.ToLower(); .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> insensitiveOverride = lowerValue == lowerValue.ToUpper();</code> </pre> <br>  PVS-Studio warning: V3122 The 'lowerValue' lowercase string is compared with the 'lowerValue.ToUpper ()' uppercase string.  ServerModeCore.cs 2208 <br><br>  The programmer wanted to check that all characters in the string are capitalized.  The code clearly contains some kind of logical error, since previously all the characters of this string were converted to lowercase. <br><br>  It is possible to continue describing diagnostics based on knowledge of the meaning of variables for a long time.  I will give just one more example related to pointers and memory leaks. <br><br>  The code is taken from the WinMerge project: <br><br><pre> <code class="cpp hljs">CMainFrame* pMainFrame = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CMainFrame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hMutex) { ReleaseMutex(hMutex); CloseHandle(hMutex); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } m_pMainWnd = pMainFrame;</code> </pre> <br>  Analyzer Warning: V773 The function was exited without releasing the 'pMainFrame' pointer.  A memory leak is possible.  Merge merge.cpp 353 <br><br>  If the frame could not be loaded, the function ends its work.  This does not destroy the object, the pointer to which is stored in the variable <i>pMainFrame</i> . <br><br>  Diagnostics works as follows.  The analyzer remembers that the <i>pMainFrame</i> pointer stores the address of an object created with the <i>new</i> operator.  Analyzing the control flow graph, the analyzer encounters a <i>return statement</i> .  At the same time, the object was not destroyed and the pointer continues to refer to the created object.  This means that a memory leak occurs at this point. <br><br><h3>  Method annotations </h3><br>  Annotation of methods provides more information about the methods used than can be obtained by analyzing only their signatures. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac0/b36/69d/ac0b3669d89aa669729aeb2b21321ee7.png" alt="memcmp ()"></p><br><br>  We did a lot of work annotating the functions: <ul><li>  C / C ++.  At the moment, <b>6570</b> functions have been annotated (standard C and C ++ libraries, POSIX, MFC, Qt, ZLib, and so on). </li><li>  C #.  <b>920</b> functions have been annotated at the moment. </li></ul><br>  Consider how the memcmp function is <i>annotated</i> in the C ++ kernel of the analyzer: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"int memcmp(const void *buf1, const void *buf2, size_t count);"</span></span> ADD(REENTERABLE | RET_USE | F_MEMCMP | STRCMP | HARD_TEST | INT_STATUS, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"memcmp"</span></span>, POINTER_1, POINTER_2, BYTE_COUNT);</code> </pre> <br>  Brief explanations on the markup: <ul><li>  C_ - ancillary control mechanism for annotations (unit tests); </li><li>  REENTERABLE - a repeated call with the same arguments will give the same result; </li><li>  RET_USE - the result should be used; </li><li>  F_MEMCMP ‚Äî run certain checks of the buffer overflow; </li><li>  STR_CMP - if equal, the function returns 0; </li><li>  HARD_TEST is a special function: some libraries define their own identical functions in their namespace and therefore the namespace should be ignored; </li><li>  INT_STATUS - the result cannot be explicitly compared with 1 or -1; </li><li>  POINTER_1, POINTER_2 - pointers must be non-zero and different; </li><li>  BYTE_COUNT - the parameter sets the number of bytes and must be greater than 0. </li></ul><br>  These annotations are used by many diagnostics.  Consider some of the errors that we found in the application code due to the above markup for the <i>memcmp</i> function. <br><br>  An example of using the <b>INT_STATUS</b> markup.  CoreCLR project: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GUID&amp; _Key1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GUID&amp; _Key2)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(&amp;_Key1, &amp;_Key2, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GUID)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  V698 Expression 'memcmp (....) == -1' is incorrect.  This function can return not only the value '-1', but any negative value.  Consider using 'memcmp (....) &lt;0' instead.  sos util.cpp 142 <br><br>  Such code may work, but in general it is incorrect.  The <i>memcmp</i> function returns values ‚Äã‚Äãof 0, greater than zero, and less than zero.  Important: <ul><li>  "More than zero" is not necessary 1 </li><li>  "Less than zero", this is not necessarily -1 </li></ul><br>  Thus, there is no guarantee in the performance of the written code.  At any time, the comparison may start to work incorrectly.  This can happen when changing the compiler, changing the optimization settings and so on. <br><br>  The INT_STATUS flag helps to reveal another type of error.  Firebird project code: <br><br><pre> <code class="cpp hljs">SSHORT TextType::compare(ULONG len1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UCHAR* str1, ULONG len2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UCHAR* str2) { .... SSHORT cmp = <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(str1, str2, MIN(len1, len2)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) cmp = (len1 &lt; len2 ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : (len1 &gt; len2 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cmp; }</code> </pre> <br>  PVS-Studio.  V642 Saving the 'memcmp' function result inside the 'short' type variable is inappropriate.  Breaking the program's logic.  texttype.cpp 3 <br><br>  Again carelessly working with the result, which returns the function <i>memcmp</i> .  The error is that the size of the type is truncated: the result is placed in a variable of type <i>short</i> . <br><br>  Some may think that we quibble.  Not at all.  Such inaccurate code can easily become the cause of the real vulnerability. <br><br>  One such error caused a serious vulnerability in MySQL / MariaDB to versions 5.1.61, 5.2.11, 5.3.5, 5.5.22.  The reason was the following code in the 'sql / password.c' file: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> my_bool; .... <span class="hljs-function"><span class="hljs-function">my_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(...); }</code> </pre> <br>  The bottom line is that when the MySQL / MariaDB user connects, the token is computed (SHA for password and hash), which is compared with the expected value of the <i>memcmp</i> function.  On some platforms, the return value may fall out of range [-128..127].  As a result, in 1 case out of 256, the procedure of comparing the hash with the expected value always returns <i>true</i> , regardless of the hash.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, a simple bash command gives the attacker root access to the vulnerable MySQL server, even if he does not know the password. A more detailed description of this problem can be found here: </font></font><a href="http://seclists.org/oss-sec/2012/q2/493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Security vulnerability in MySQL / MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the mark </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTE_COUNT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Project GLG3D:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Matrix4::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix4&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;other, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Matrix4) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V575 The 'memcmp' function processes '0' elements. Inspect the 'third' argument. graphics3D matrix4.cpp 269 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third argument to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">is</font></i><font style="vertical-align: inherit;"> marked as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTE_COUNT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is considered that such an argument should not be equal to 0. In the given code fragment, the third actual parameter is just 0. The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error is that a bracket is not put there. As a result, the third argument is the expression </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sizeof (Matrix4) == 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The result of this expression is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the markup </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POINTER_1 and POINTER_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . GDB Project:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">psymbol_compare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sym1</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr1</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sym2</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partial_symbol</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr2</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span> (&amp;sym1-&gt;ginfo.value, &amp;sym1-&gt;ginfo.value, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (sym1-&gt;ginfo.value)) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; .......</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V549 The first argument of the memcmp function is equal to the second argument. psymtab.c 1580 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first and second arguments are marked as PONTER_1 and POINTER_2. First, it means that they should not be NULL. But in this case, we are interested in the second markup property: these pointers should not be the same, as indicated by the suffixes _1 and _2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of a typo in the code, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; sym1-&gt; ginfo.value buffer is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compared to itself. PVS-Studio, based on the markup, easily detects this error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F_MEMCMP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> markup </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This markup includes a number of special diagnostics for functions such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__builtin_memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As a result, such an error in the Haiku project can be identified:</font></font><br><br><pre> <code class="cpp hljs">dst_s_read_private_key_file(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(in_buff, <span class="hljs-string"><span class="hljs-string">"Private-key-format: v"</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V512 A call-out for the 'memcmp' function. "Private-key-format: v". dst_api.c 858 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The string ‚ÄúPrivate-key-format: v‚Äù consists of 21 characters, not 20 characters. Thus, less bytes are compared than required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the markup </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REENTERABLE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To be honest, the word ‚Äúreenterable‚Äù does not quite reflect the essence of this flag. However, all the developers in our team are used to it and do not want to make changes in the code for the sake of beauty. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the markup is as follows. The function has no state and no side effects: does not change memory, does not print something on the screen, does not delete files on the disk. Due to this, the analyzer can distinguish the correct constructions from the wrong ones. For example, this code is quite legal:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(f, <span class="hljs-string"><span class="hljs-string">"1"</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(f, <span class="hljs-string"><span class="hljs-string">"1"</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The analyzer will not issue warnings. </font><font style="vertical-align: inherit;">We write two units to a file and the code cannot be reduced to:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(f, <span class="hljs-string"><span class="hljs-string">"1"</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But such a code is redundant and the analyzer will be alerted, since the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cosf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">has no state and does not record anything anywhere:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cosf(a) &gt; <span class="hljs-number"><span class="hljs-number">0.1f</span></span> &amp;&amp; cosf(a) &gt; <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us now return to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">and see what error we managed to detect using the considered markup in the PHP project:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((len == <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* sizeof (none|auto|pass) */</span></span> &amp;&amp; (!<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"pass"</span></span>, charset_hint, <span class="hljs-number"><span class="hljs-number">4</span></span>) || !<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"auto"</span></span>, charset_hint, <span class="hljs-number"><span class="hljs-number">4</span></span>) || !<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"auto"</span></span>, charset_hint, <span class="hljs-number"><span class="hljs-number">4</span></span>)))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio warning: V501 There are identical sub-expressions! Memcmp ("auto", charset_hint, 4) </font></font> operator.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">html.c 396 It is </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checked twice that the buffer contains the word ‚Äúauto‚Äù. This code is redundant and the analyzer assumes that it contains an error. Indeed, the comment tells us that the comparison with the string ‚Äúnone‚Äù is missing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, using markup, you can find a lot of interesting errors. Often, analyzers provide opportunities for users to annotate functions on their own. In PVS-Studio, these capabilities are underdeveloped. There are only a few diagnostics in it, for which something can be annotated. For example, this is the </font></font><a href="http://www.viva64.com/ru/w/V576/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V576</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagnostics </font><font style="vertical-align: inherit;">for finding errors using formatted output functions (printf, sprintf, wprintf, and so on). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We deliberately do not develop the mechanism of user annotations. There are two reasons for this:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a large project, no one will waste time marking up functions. </font><font style="vertical-align: inherit;">It is simply unrealistic when you have 10 million lines of code, and the PVS-Studio analyzer is focused on medium and large projects.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If functions from some well-known library are not marked up, then it is better to write to us and we ourselves will annotate them. </font><font style="vertical-align: inherit;">Firstly, we will do it faster and better, and secondly, the markup results will be available to all our users.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One more time about technology. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly summarize my story about the technologies used. </font><font style="vertical-align: inherit;">PVS-Studio uses:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pattern-based analysis based on an abstract syntax tree: Used to find places in the source code that are similar to known code patterns with an error. </font></font></li><li>   (type inference)     :          ,   . </li><li>   (symbolic execution):    ,     ,    (range checking) . </li><li>    (data-flow analysis):    ,         . ,        if/else. </li><li>   (method annotations):      ,         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Based on these technologies, the analyzer can detect the following classes of errors in C, C ++ and C # programs: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 64-bit errors; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the address of a local variable is returned from the function by reference; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arithmetic overflow, underflow; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> out of bounds array; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dual release of resources; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dead code; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> micro-optimization; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unreachable code; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uninitialized variables; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unused variables; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incorrect shift operations; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unspecified / unspecified behavior; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incorrect work with types (HRESULT, BSTR, BOOL, VARIANT_BOOL); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> misconception about the function / class; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> typos; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lack of a virtual destructor; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the design of the code does not coincide with the logic of its work; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> errors due to copy-paste; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> errors with exceptions; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer overflow; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> safety issues; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> confusion with priority operations; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> null pointer / null reference dereference; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dereference of parameters without prior verification; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> synchronization errors; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> errors when using WPF; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory leaks; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> integer division by 0; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagnostics created by special requests of users. </font></font></li></ul><br>  Conclusion.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio analyzer is a powerful error-finding tool that uses a modern arsenal of methods to detect them. </font></font><br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a7e/ad3/d41/a7ead3d41f24bc0c5edf2432152d63c0.png" alt="PVS-Studio is a positive superhero"></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, PVS-Studio is the positive superhero of the software world. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testing PVS-Studio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Development of code analyzers is impossible without their constant thorough testing. </font><font style="vertical-align: inherit;">When developing PVS-Studio, we use 7 different testing methods:</font></font><br><br><ol><li>      .     PVS-Studio.           .  C++  # . </li><li>      .     ,         . PVS-Studio  C#  C++ .  ,     Clang   C++ . </li><li> -  , , .    ,       -        .      . </li><li>          .     -. </li><li>  , ,        . </li><li>         (projects and solutions).        .      ,  ,  -       .        . C++    120   Windows (Visual C++),    24   Linux (GCC).  C#    .     54 . </li><li>      ‚Äî ,    Visual Studio. </li></ol><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article is written to popularize static analysis methodology. I think readers are interested to know not only about the results of using code analyzers, but also how they are arranged inside. I will try from time to time to write articles on this topic.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, we plan to participate more in various events, such as conferences and seminars. </font><font style="vertical-align: inherit;">We will be happy to receive invitations to various events, especially those taking place in Moscow and St. Petersburg. </font><font style="vertical-align: inherit;">For example, in your institute or company there are meetings of programmers where people share their experience. </font><font style="vertical-align: inherit;">We can come and make a report on an interesting topic. </font><font style="vertical-align: inherit;">For example, about modern C ++, about how we develop analyzers, about typical errors of programmers and how to prevent them, refining the coding standard and so on. </font><font style="vertical-align: inherit;">I ask you to send invitations to me by mailing karpov [@] viva64.com. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, some links:</font></font><br><br><ul><li> <a href="http://www.viva64.com/ru/pvs-studio/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download PVS-Studio for Windows</font></font></a> </li><li> <a href="http://www.viva64.com/ru/pvs-studio-download-linux/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download PVS-Studio for Linux</font></font></a> </li><li> <a href="http://www.viva64.com/ru/b/0457/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Free license option for PVS-Studio</font></font></a> </li></ul><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0466/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov. <a href="http://www.viva64.com/en/b/0466/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How PVS-Studio does the bug search: methods and technologies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/319382/">https://habr.com/ru/post/319382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319368/index.html">Using Node.js technology as a platform for optimizing server capacity</a></li>
<li><a href="../319370/index.html">Electronics development: from idea to device</a></li>
<li><a href="../319374/index.html">VPS-digest: 30 useful materials on Habr√© and not only</a></li>
<li><a href="../319378/index.html">Powershell Practice: Monitoring Windows Backup Backup</a></li>
<li><a href="../319380/index.html">Exploit Exercises or another site for VulnHub lovers</a></li>
<li><a href="../319384/index.html">Direct disk access from python (simhdd)</a></li>
<li><a href="../319386/index.html">Modal windows and notifications in Angular</a></li>
<li><a href="../319388/index.html">BLE under the microscope 2</a></li>
<li><a href="../319392/index.html">Realistic UI: a realistic look at the Optimistic UI</a></li>
<li><a href="../319394/index.html">Own image slider on jQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>