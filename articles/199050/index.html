<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Groovy vs Java for JavaFX</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaFX is good! 
 First a few words about JavaFX. What we liked working with her. 

 Modern API . Even without builders, everything looks very modern....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Groovy vs Java for JavaFX</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/codeorchestra/blog/199050/"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/e94/262/7f7e94262d878b16ea42c1a2ba9c6a4d.png" alt="image"></a> <a name="habracut"></a><br><br><h4>  JavaFX is good! </h4><br>  First a few words about JavaFX.  What we liked working with her. <br><br>  <b>Modern API</b> .  Even without builders, everything looks very modern. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Total <b>Data Driven Development</b> .  We adore it.  The logic based on the data bundle clears the code from trash, hetera / setters - ‚ÄúDown with!‚Äù.  Work with data change events, bi-directional "binding". <br><br>  <b>FXML</b> .  Great thing for prototyping.  Understandable to the designer, there is a good visual tool from Oracle - "JavaFX Scene Builder".  I note that then we still wanted to rewrite FXML in the form of ordinary code.  Simply supporting FXML is harder than code - you always have to edit two files, code and FXML.  Plus when using code it is easier to use inheritance. <br><br>  <b>Nodes</b> .  Component structure.  You can run on a tree.  You can search by lookup ().  Like in the DOM.  Straight jQuery write. <br><br>  <b>CSS</b> .  This is really a thing.  "We throw off" components through one common css-file.  ID tags, CSS classes, selectors and pseudo selectors. <br><br>  <b>Text Engine</b> .  Very good engine for complex texts. <br><br>  <b>WebView</b> .  We realize the heaped components on the Webkit engine.  <a href="http://habrahabr.ru/company/codeorchestra/blog/198776/">Read about this previous article</a> . <br><br><h4>  Which is not very good </h4><br>  This is good.  What is wrong?  JavaFX script at one time did not just come up with.  Creating fields for accessing Bindable data through heters and setters is a step back and yesterday.  Java is not very good here.  In Java 8 there are lambda expressions, but their appearance is also the answer to the question that something needs to be done with Java and a reason to think about a more radical solution. <br><br><h4>  Groovy! </h4><br>  We solved all these problems for ourselves by choosing Groovy.  Laconic, in a good sense, old (matured) and well supported in IDEA.  Groovy allowed us to reduce the amount of code ten times exactly.  It works, looks and reads almost like Java, but how good it is in terms of compactness! <br><br>  There are still a lot of good and beautiful languages ‚Äã‚Äãfor the JVM, but it so happened that Groovy suits us.  Yes, and we love brackets, annotations and we don‚Äôt want to break something in ourselves.  Plus, I personally had a seven-year experience of using Groovy, and when there is an expert in the team, it is better to use, rather than take something completely unknown. <br><br>  By the way, Groovy ranks 18th in terms of language popularity (according to <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">TIOBE</a> ). <br><br><h4>  Our practices </h4><br>  Now let's see the examples.  We copy from our project, the code is real. <br><br><h4>  Configuring Components </h4><br>  Simply create an instance of the component through the code and configure it. <br>  In Java, we had to step by step, line by line, assign values. <br><br><pre><code class="java hljs">Button button = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Button(); button.setFocusTraversable(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); button.setLayoutX(<span class="hljs-number"><span class="hljs-number">23</span></span>); button.setPrefHeight(<span class="hljs-number"><span class="hljs-number">30</span></span>); button.setPrefWidth(<span class="hljs-number"><span class="hljs-number">30</span></span>); button.setText(<span class="hljs-string"><span class="hljs-string">"ADD"</span></span>);</code> </pre> <br>  What does the same thing look like if you rewrite it to Groovy? <br><br><pre> <code class="java hljs">Button button = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Button(focusTraversable: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, layoutY: <span class="hljs-number"><span class="hljs-number">23</span></span>, prefHeight: <span class="hljs-number"><span class="hljs-number">30</span></span>, prefWidth: <span class="hljs-number"><span class="hljs-number">30</span></span>, text: <span class="hljs-string"><span class="hljs-string">"Add"</span></span>)</code> </pre><br>  Gruvy, let me remind you, who does not know, allows access to access methods (getters, setters) without the set / get prefix.  That is, if there is a setText method in the class - then its call is made through a simple assignment of the value - text = ‚ÄúAdd‚Äù.  Plus, when compiling Groovy classes, getters and setters are added automatically to public fields.  Therefore, it is not hard to call the set / get method out of the groove if there is no real need for this. <br><br>  And in the constructor parameters you can pass pairs - name: value (in fact, this is the usual HashMap and the syntax is used here Groovy Maps - [key1: value1, key2: value]). <br><br>  Moreover, it is important that IDEA tells us all this, validates the data type and access restriction. <br><br>  This way of configuring the components immediately suggests whether it is possible to configure the structure of the components immediately? <br><br>  Can! <br><br><pre> <code class="java hljs">menus.addAll( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Menu(text: <span class="hljs-string"><span class="hljs-string">"File"</span></span>, newItems: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"New Window"</span></span>, onAction: { t -&gt; ApplicationUtil.startAnotherColtInstance() } as EventHandler&lt;ActionEvent&gt;, accelerator: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyCodeCombination(KeyCode.N, KeyCombination.SHORTCUT_DOWN) ), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Menu(text: <span class="hljs-string"><span class="hljs-string">"New Project"</span></span>, newItems: [ newAs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"New AS Project"</span></span>, id: <span class="hljs-string"><span class="hljs-string">"new-as"</span></span>, onAction: { t -&gt; ProjectDialogs.newAsProjectDialog(scene, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } as EventHandler&lt;ActionEvent&gt; ), newJs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"New JS Project"</span></span>, id: <span class="hljs-string"><span class="hljs-string">"new-js"</span></span>, onAction: { t -&gt; ProjectDialogs.newJsProjectDialog(scene, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } as EventHandler&lt;ActionEvent&gt; ) ]), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SeparatorMenuItem(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Open Project"</span></span>, onAction: { t -&gt; ProjectDialogs.openProjectDialog(scene, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } as EventHandler&lt;ActionEvent&gt;, accelerator: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyCodeCombination(KeyCode.O, KeyCombination.SHORTCUT_DOWN) ), recentProjectsSubMenu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Menu(text: <span class="hljs-string"><span class="hljs-string">"Open Recent"</span></span>, newItems: [ clearRecentProjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Clear List"</span></span>, onAction: { t -&gt; RecentProjects.clear() } as EventHandler&lt;ActionEvent&gt; ), ]), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SeparatorMenuItem(), save = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Save Project"</span></span>, id: <span class="hljs-string"><span class="hljs-string">"save"</span></span>, onAction: { t -&gt; ProjectDialogs.saveProjectDialog() } as EventHandler&lt;ActionEvent&gt;, accelerator: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyCodeCombination(KeyCode.S, KeyCombination.SHORTCUT_DOWN), disable: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), saveAs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Save As..."</span></span>, onAction: { t -&gt; ProjectDialogs.saveAsProjectDialog(scene) } as EventHandler&lt;ActionEvent&gt;, accelerator: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyCodeCombination(KeyCode.S, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN), ), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Close Project"</span></span>, onAction: { t -&gt; ProjectDialogs.closeProjectDialog() } as EventHandler&lt;ActionEvent&gt;, accelerator: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyCodeCombination(KeyCode.W, KeyCombination.SHORTCUT_DOWN), ), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SeparatorMenuItem(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Exit"</span></span>, onAction: { t -&gt; ApplicationUtil.exitColt() } as EventHandler&lt;ActionEvent&gt; ), ]), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Menu(text: <span class="hljs-string"><span class="hljs-string">"Help"</span></span>, newItems: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Open Demo Projects Directory"</span></span>, onAction: { t -&gt; ProjectDialogs.openDemoProjectDialog(scene) } as EventHandler&lt;ActionEvent&gt; ), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MenuItem( text: <span class="hljs-string"><span class="hljs-string">"Open Welcome Screen"</span></span>, onAction: { t -&gt; ProjectDialogs.openWelcomeScreen(scene) } as EventHandler&lt;ActionEvent&gt; ), ]) )</code> </pre><br>  Such code looks no less readable than FXML.  Plus, here, on the spot, you can describe all the event handlers that could not be done in FXML.  And to support such code is easier. <br><br><h4>  Dynamic properties and methods </h4><br>  An attentive reader will ask, what is the Menu field ‚ÄúnewItems‚Äù?  Yes, the Menu class has no such method.  And we added such a method, because we can only read the items field, but we cannot assign it. It does not have the ‚ÄúsetItems ()‚Äù method, but there is only ‚ÄúgetItems ()‚Äù and it is impossible to assign a new value. Read-only. To To configure the Menu as a structure, we added a dynamic field. <br><br>  Adding such a field is very simple, but our Java entity has long resisted such sedition as dynamic methods.  We thought a lot of bicycles until we came to terms with the fact that it was necessary to take advantage of the dynamics.  And everything turned out to be simple and scary. <br><br>  Adding dynamic fields we carried out in a separate class GroovyDynamicMethods.  Here is his code: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyDynamicMethods</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> inited = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">false</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(inited)<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inited = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">true</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(javafx.scene.Node, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"newStyleClass"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { String it -&gt; styleClass.add(it)</span></span></span><span class="hljs-function"> }) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parent, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"newChildren"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, {List&lt;MenuItem&gt; it -&gt; children.addAll(it)</span></span></span><span class="hljs-function"> }) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Menu, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"newItems"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, {List&lt;MenuItem&gt; it -&gt; items.addAll(it)</span></span></span><span class="hljs-function"> }) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class clazz, String methodName, Closure methodBody)</span></span></span><span class="hljs-function"> </span></span>{ addMethod(clazz, <span class="hljs-string"><span class="hljs-string">"set"</span></span> + methodName.capitalize(), methodBody) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class clazz, String methodName, Closure methodBody)</span></span></span><span class="hljs-function"> </span></span>{ ExpandoMetaClass exp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandoMetaClass(clazz, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) exp.<span class="hljs-string"><span class="hljs-string">"$methodName"</span></span> = methodBody exp.initialize() clazz.metaClass = exp } }</code> </pre><br>  As you can see, we only needed to add three methods to support the configuration of components through the structure. <br><br>  Plus, we taught IDEA to understand that classes have these dynamic fields. <br><br><img src="http://codeorchestra.s3.amazonaws.com/habr/habr-java-vs-groovy-javafx/idea-dynamic-properties.png" alt="image"><br><br>  Now IDEA is aware of the existence of such fields as if they were in the JavaFX API. <br><br><h4>  Work with Bindable Properties </h4><br>  Data binding is a great thing.  Our team uses such a mantra - ‚ÄúIf something can be done through bandinding, do it through banding‚Äù.  "... so as not to redo it." <br><br>  Banding allows you to link the data model and components.  UI components themselves have a binding property that can be associated with model data or based on changing these properties logic - subscribe to data change events. <br><br>  Simple checkbox example: <br><br><pre> <code class="java hljs">CheckBox checkBox = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CheckBox(); checkBox.selectedProperty().bindBidirectional(selectedProperty);</code> </pre><br>  And here we react to the event of clicking on the checkbox: <br><br><pre> <code class="java hljs">CheckBox checkBox = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CheckBox(); checkBox.selectedProperty().addListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChangeListener&lt;Boolean&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObservableValue&lt;? extends Boolean&gt; value, Boolean before, Boolean after)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"value = "</span></span> + value); } });</code> </pre><br>  Use conveniently.  It is not very convenient to describe such properties. <br><br>  Java offers such a script (the code is generated by IDEA automatically). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StringProperty name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleStringProperty(); <span class="hljs-comment"><span class="hljs-comment">//   //     (     ) public StringProperty nameProperty() { return name; } //    public String getName() { return name.get(); } //       public void setName(String name) { this.name.set(name); }</span></span></code> </pre><br>  Everything is good, and the IDE for us generates such code.  Well, not stupid?  Why do we need all this to see?  Behind all this stuff we do not see our logic. <br><br>  Decision!  We take the AST transformation that this code generates for us.  When compiling. <br><br>  Our property (which we described in Java in 10 lines) turns into Groovy in one line and looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FXBindable</span></span> String name;</code> </pre><br>  @FXBindable you can take in <a href="http://groovyfx.org/">GroovyFX</a> , or you can take <a href="https://github.com/code-orchestra/groovy-fx-goodies">ours</a> . <br>  We fork this annotation and you can take it from us on the <a href="https://github.com/code-orchestra/groovy-fx-goodies">githaba</a> . <br><br>  Plus, in the same project, you will find a file with the <a href="">.gdsl</a> extension, which will teach IDEA to use this annotation - automit, etc. <br><br>  This transformation also creates methods setName, getName, getNameProperty.  Plus, the name () method is added, which allows you to access the field by writing even fewer letters.  It tastes good, but we most often use this method. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameInput.textProperty().bindBidirectional(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name()) <span class="hljs-comment"><span class="hljs-comment">// this.name() -     name</span></span></code> </pre><br><h4>  Down with anonymous classes </h4><br>  In the Menu example, we subscribe to events through anonymous classes.  On the example of the menu structure, it can be seen that the event handler is a ‚Äúcover‚Äù. <br><br><pre> <code class="java hljs">onAction: { t -&gt; ProjectDialogs.newAsProjectDialog(scene, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } as EventHandler&lt;ActionEvent&gt;</code> </pre><br>  All the magic in ‚Äúas EventHandler‚Äù - the body of the cokure is moved to the body of the handle method, the class EventHandler.  Using such a brief entry to handle events makes the code cleaner.  By the way, smart IDEA offers Quiche ‚ÄúChange to dynamic instantiation‚Äù.  You can also use another one to write - via Map ([handler1: {}, handler2: {}]), if the class handler requests to overload several methods. <br><br><h4>  Work with XML </h4><br>  In our project, we needed to serialize the data model to XML and take it from disk.  At first, we wanted to use XStream out of habit, but we needed a more manageable structure - the Bindable properties of JavaFX are big and the converters are too lazy to write.  We looked at JAXB, too bad.  The same with Groovy XML serialization. <br><br>  Fit built into Groovy SDK XmlSlurper. <br><br>  Each Bean model implements two methods ‚Äî buildXml and buildModel ‚Äî serialization and deserialization. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Closure </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildXml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'launcher'</span></span>(launcherType) <span class="hljs-string"><span class="hljs-string">'browser-path'</span></span>(browserPath) <span class="hljs-string"><span class="hljs-string">'nodejs-path'</span></span>(nodejsPath) <span class="hljs-string"><span class="hljs-string">'console-value'</span></span>(console) } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object node)</span></span></span><span class="hljs-function"> </span></span>{ launcherType = node.<span class="hljs-string"><span class="hljs-string">'launcher'</span></span> browserPath = node.<span class="hljs-string"><span class="hljs-string">'browser-path'</span></span> nodejsPath = node.<span class="hljs-string"><span class="hljs-string">'nodejs-path'</span></span> console = node.<span class="hljs-string"><span class="hljs-string">'console-value'</span></span> }</code> </pre><br>  The buildXml method returns the structure as a clause.  The magic here is in calling and assigning non-existent methods and properties.  If a non-existent method is called, then a property is created as a child node, if a value is assigned to a non-existent field, an XML attribute is created, if a non-existent method is called and a clime is passed to it as a parameter, then a nested XML node structure is created. <br><br>  The buildModel method takes a node argument and parses the node through dynamic queries. <br><br><h4>  Work with files </h4><br>  Our program works a lot with the file system.  Using Groovy, we were able to greatly reduce the IO code.  We didn‚Äôt have to save every nanosecond, we don‚Äôt have a loaded web server, and Groovy did a lot of work for us. <br><br>  Groovy SDK offers many useful extensions for Java classes, including File.  For example, the ability to write / read the contents of a file simply through the "text" field, or work with file lines using the "splitEachLine". <br><br>  In addition, we liked AntBuilder, which can also be used to search and filter files. <br><br>  The following example copies files: <br><br><pre> <code class="java hljs">def ant = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AntBuilder() ant.sequential { myDir = <span class="hljs-string"><span class="hljs-string">"test/to/"</span></span> mkdir(dir:myDir) copy(todir:myDir) { fileset(dir:<span class="hljs-string"><span class="hljs-string">"text/from/"</span></span>) { include(name:<span class="hljs-string"><span class="hljs-string">"**/*.*"</span></span>) } } }</code> </pre><br>  You can search for files by pattern using fileScaner: <br><br><pre> <code class="java hljs">def ant = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AntBuilder() def scanner = ant.fileScanner { fileset(dir: file) { include(name: <span class="hljs-string"><span class="hljs-string">"**/*.jpg"</span></span>) } } scanner.each{ printlt(it) }</code> </pre><br>  And of course AntBuilder is a full-fledged ANT, with all its extensions and capabilities.  Here still study and study.  Gradle also uses AntBuilder, and the fact that there you can "bloat" impresses us. <br><br><h4>  Using GPath to work with Nodes </h4><br>  So the structure of components in JavaFX, we used requests to the nodes as collections.  With this approach, getting rid of a large number of cycles, we have greatly reduced our code. <br><br>  For example, to remove scrolls in Java: <br><br><pre> <code class="java hljs">webView.getChildrenUnmodifiable().addListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListChangeListener&lt;Node&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListChangeListener.Change&lt;? extends Node&gt; change)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;jNode&gt; scrolls = webView.lookupAll(<span class="hljs-string"><span class="hljs-string">".scroll-bar"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node scroll : scrolls) { scroll.setVisible(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } });</code> </pre><br>  Same on Groovy: <br><br><pre> <code class="java hljs">webView.childrenUnmodifiable.addListener({ change -&gt; webView.lookupAll(<span class="hljs-string"><span class="hljs-string">".scroll-bar"</span></span>)*.visible = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } as ListChangeListener)</code> </pre><br><h4>  Fighting NPE </h4><br>  The operator "?." - in our opinion, only he alone can make you think about switching from Java to Groovy. <br><br><pre> <code class="java hljs">model?.projectSettings?.projectPaths?.livePaths?.each{ println(it) }</code> </pre><br>  We translate this into Java and get at least twenty lines of code. <br><br><h4>  Conclusion </h4><br>  That's probably all that we could remember.  Of course, in our project we used other Groovy ‚Äúgoodies‚Äù, but if we list everything, we will go beyond the scope of the article, and you can find a lot of Groovy textbooks. <br><br>  But I want to talk about what does not suit us from Groovy.  First, we avoided unnecessary dynamics.  In our team, we agreed that it is necessary to specify the type when creating any variable or field (except for the parameters of the collar - half the pleasure from them is lost here).  Also, we did not use mixins and overloaded operators.  We consider code juggling as a harmful practice - not only compact, but also controlled, supported code is important to us.  That's probably all.  Groovy is very similar to Java and we used it in this context - we know that AST transformations are performed during compilation and we, when writing the code, assume that something else is added to us for some construction by an automatic machine.  Such is Java with autogeneration.  And we don't need anything else. <br><br>  Project site <a href="http://codeorchestra.com/">codeorchestra.com</a> </div><p>Source: <a href="https://habr.com/ru/post/199050/">https://habr.com/ru/post/199050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../199034/index.html">PCB or version control software</a></li>
<li><a href="../199036/index.html">MS-DOS viruses in action</a></li>
<li><a href="../199040/index.html">Yourself IPv6 Tunnel Broker with openvpn and 6to4</a></li>
<li><a href="../199042/index.html">Unzipping poetry in slow motion (gzip)</a></li>
<li><a href="../199044/index.html">Computer PC "Search". Electronmash</a></li>
<li><a href="../199052/index.html">45% of web resources of the largest Russian companies contain critical vulnerabilities</a></li>
<li><a href="../199056/index.html">Why Open Data is a culture of working with information on the example of Roszdravnadzor</a></li>
<li><a href="../199060/index.html">Visualization of a two-dimensional gaussian on a plane</a></li>
<li><a href="../199062/index.html">pdoTools - a set of quick snippets and a library</a></li>
<li><a href="../199064/index.html">Create a platformer in 30 minutes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>