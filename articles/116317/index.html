<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Difficulties in comparing code analyzers or do not forget about usability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The desire of users to compare different code analyzers between themselves is understandable and natural. However, to realize this desire is not as ea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Difficulties in comparing code analyzers or do not forget about usability</h1><div class="post__text post__text-html js-mediator-article"><img src="http://www.viva64.com/external-pictures/habr68/image1.png"><br><br>  The desire of users to compare different code analyzers between themselves is understandable and natural.  However, to realize this desire is not as easy as it may seem at first glance.  The fact is that it is unclear what specific factors to compare among themselves. <br><br>  If we reject absolutely absurd ideas like ‚Äúcompare the number of diagnosed errors‚Äù or ‚Äúcompare the number of messages that the tool issued‚Äù, then even a reasonable parameter ‚Äúsignal-to-noise ratio‚Äù does not seem to be an ideal criterion for evaluating the code analyzer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Do you doubt that comparing these parameters is pointless?  Let's give some examples. <br><br><a name="habracut"></a><br><br><h2>  What parameters to compare is simply meaningless </h2><br>  Consider such a simple at first glance characteristic, as the number of diagnostic tests.  It seems that the more of them, the better.  But for an end user using a specific set of operating systems and compilers, the total number of rules does not mean anything.  The diagnostic rules that are relevant to systems, libraries and compilers, which he does not use, do not give him anything.  They even interfere with it, cluttering the system settings and documentation, complicate the use and implementation of the tool. <br><br>  The following analogy is relevant here.  A man enters the store to buy a heater.  He is interested in the department of home appliances and if there is a big choice in this department, then this is good.  But other departments are not interested in him.  There is nothing wrong if you can buy an inflatable boat, cell phone and chair in this store.  But the presence of the department of inflatable boats does not improve the range of heaters. <br><br>  Take, for example, the Klocwork tool, which supports a large variety of systems, including exotic ones.  In one of these systems, there is a compiler that ‚Äúswallows‚Äù the following code: <br><pre>  inline int x; </pre><br>  The Klocwork analyzer has a diagnostic message that allows you to detect this anomaly in the code: ‚ÄúThe 'inline' keyword.  It turns out that it seems good that there is such a diagnosis.  But, say, a developer using the Microsoft Visual C ++ compiler or another adequate compiler does not have any benefit from this diagnostics.  Visual C ++ simply does not compile such code: "error C2433: 'x': 'inline' not permitted on data declarations". <br><br>  Another example.  Some compilers poorly support the bool type.  Therefore, Klocwork can warn of a situation where a member of the class has a bool type: "PORTING.STRUCT.BOOL: This is a struct / class has a bool member." <br><br>  They wrote bool in the classroom, here‚Äôs the horror ... It is clear that an extremely small percentage of developers can benefit from such a diagnostic message. <br><br>  There are a lot of similar examples.  And it turns out that the total number of diagnostic rules has nothing to do with how many errors the analyzer will detect in a particular project.  An analyzer that implements 100 diagnostics and is oriented for Windows applications can find much more errors in a project compiled by Microsoft Visual Studio than a cross-platform analyzer that implements 1000 diagnostics. <br><br>  So, we have obtained that it is impossible to compare the utility of the analyzer in such a parameter as the number of diagnostic tests. <br><br>  You can say: ‚ÄúLet us then compare the number of checks relevant to a particular system.  For example, we will select all the rules that allow you to search for errors in Windows programs. ‚Äù  But this approach does not work for two reasons: <br><br>  Firstly, it often happens that in some analyzer the test is implemented by one diagnostic rule, and in the other - by several rules.  And if you compare the number of diagnostic rules, it seems that one of the analyzers is better, although they are the same for detectable errors. <br><br>  Secondly, the implementation of various diagnostics can be of different quality.  For example, almost all analyzers have a search for ‚Äúmagic numbers‚Äù.  But, for example, in one analyzer only magic numbers can be detected that are dangerous from the point of view of transferring code to 64-bit systems (4, 8, 32, etc.), then in the other - just all magic numbers (1, 2). , 3, etc.).  And just in the comparison table in the column ‚Äúsearch for magic numbers‚Äù to put both there and there a ‚Äúplus sign‚Äù will not be enough. <br><br>  They also like to give such a characteristic as the speed of the tool, or the number of lines of code processed per minute.  But after all, it does not make practical sense.  There is no connection between the speed of the code analyzer and the speed of project analysis by a person!  First, often the launch of code analysis is performed automatically during nightly builds.  And it is important to just ‚Äúhave time‚Äù to check up in the morning.  And, secondly, they often forget when comparing about such a parameter as usability.  However, let's deal with this issue in more detail. <br><br><h2>  Ease of use of the tool is very important for proper comparison. </h2><br>  The fact is that a very important role in the actual use of code analyzers is how convenient the tool is to use ... <br><br>  Recently, we tested the <a href="http://www.emule.com/">eMule</a> project with two code analyzers, evaluating the convenience of this operation.  One of them was a static analyzer built into some editions of Visual Studio.  The other is our <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> .  And we immediately saw several problems in working with the code analyzer built into Visual Studio.  Moreover, these problems do not relate to the very quality of analysis and speed of work. <br><br>  The first problem is the impossibility to save the list of messages from the analyzer for further work with it.  For example, when I checked with the built-in eMule analyzer, I received two thousand messages.  Thoughtfully process them all at once is impossible, so you have to return to them within a few days.  However, the inability to save the results of the analysis leads to the fact that you have to re-check the project every time, which is very tiring.  In PVS-Studio there is an opportunity to save the analysis results in order to return to work with them later. <br><br>  The second problem is related to how the processing of duplicate analyzer messages is implemented.  It's about diagnosing problems in the header files (.h-files).  Let the analyzer detect a problem in an .h file that is included in ten .cpp files.  Analyzing each of these ten .cpp files, the analyzer built into Visual Studio gives the same message about the problem in the .h file ten times!  Specific example.  When checking eMule message <br><pre>  c: \ users \ evg \ documents \ emuleplus \ dialogmintraybtn.hpp (450): 
 warning C6054: String 'szwThemeColor' might not be zero-terminated:
 Lines: 434, 437, 438, 443, 445, 448, 450 </pre><br>  issued more than ten times.  Because of this, the analysis results are cluttered up, and the same messages have to be viewed almost constantly.  It should be noted that from the very beginning in PVS-Studio, duplicate messages were not displayed, but filtered. <br><br>  The third problem is the issue of messages on problems in the system include files (from folders of the type C: \ Program Files (x86) \ Microsoft Visual Studio 10.0 \ VC \ include).  The analyzer built into Visual Studio does not hesitate to stigmatize the system header files, although there is not much practical sense in this.  Again an example.  When eMule was checked, the same message about system files was repeatedly encountered: <br><pre>  1&gt; c: \ program files (x86) \ microsoft
 sdks \ windows \ v7.0a \ include \ ws2tcpip.h (729): 
 warning C6386: Buffer overrun: accessing 'argument 1', 
 the writable size is '1 * 4' bytes, 
 but '4294967272' bytes might be written: 
 Lines: 703, 704, 705, 707, 713, 714, 715, 720, 
 721, 722, 724, 727, 728, 729 </pre><br>  Anyway, no one will edit the system files.  So why on such files "swear"?  PVS-Studio never swore system files. <br><br>  This also includes the inability to specify the tool so that it does not check some files by mask.  For example, all files are "* _generated.cpp" or "c: \ libs \".  In PVS-Studio, you can specify files to exclude. <br><br>  The fourth problem affects the actual work with the list of messages from the code analyzer.  In any code analyzer, of course, you can disable any diagnostic messages by code.  Only here it can be done with a different level of convenience.  More precisely, the question is whether it is necessary to restart the analysis to hide extra messages by code or not.  In the code analyzer from Visual Studio, you need to rewrite the codes of the disconnected messages in the project settings, then restart the analysis.  At the same time, of course, it is unlikely that all the ‚Äúextra‚Äù diagnostics will immediately be indicated, so the restart will have to be repeated several times.  In PVS-Studio, you can easily hide and show messages by code without restarting and are much more convenient. <br><br>  The fifth problem is filtering messages not only by code, but also by text.  For example, it is useful to hide all messages containing "printf".  There is no such possibility in the built-in analyzer in Visual Studio, there is in PVS-Studio. <br><br>  Finally, the sixth problem is how convenient it is for the instrument to indicate that this message is a false positive.  The mechanism with #pragma warning disable, used in Visual Studio, allows you to hide the message only when you restart the analysis.  Unlike the mechanism in PVS-Studio, where messages can be marked as ‚ÄúFalse Alarm‚Äù and hidden without restarting the analysis. <br><br>  All six of these problems, though not affecting the quality of the actual code analysis, but are very important.  After all, the ease of use of the tool is the integral indicator on which it depends: will it really come to the assessment of the quality of the analysis or not. <br><br>  Total, we get the following picture.  The eMule project is checked by a static analyzer built into Visual Studio several times faster than PVS-Studio does.  But it took 3 days to work with the Visual Studio analyzer (actually less, but had to switch to other tasks in order to rest).  And it took only 4 hours to work with PVS-Studio. <br><br>  <i>Note.</i>  <i>Regarding the number of errors found, both analyzers showed approximately equal results, and found the same errors in this project.</i> <br><br><h2>  Conclusion </h2><br>  Comparing static analyzers with each other is a very complex and complex task.  And to answer the question which tool is better AT ALL - it is impossible.  You can only talk about which tool is best for a particular project and user. </div><p>Source: <a href="https://habr.com/ru/post/116317/">https://habr.com/ru/post/116317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116309/index.html">Feature of work of class AsyncTask</a></li>
<li><a href="../116311/index.html">Watching video without leaving the site</a></li>
<li><a href="../116313/index.html">Yandex with taste of Intel</a></li>
<li><a href="../116314/index.html">Unladen Swallow is everything ...</a></li>
<li><a href="../116316/index.html">Greetings GCC 4.6</a></li>
<li><a href="../116318/index.html">Warner Bros. launches some more movies on Facebook</a></li>
<li><a href="../116320/index.html">Arab support problems. Where is more dramatic, in a Nokia ad or on a female body?</a></li>
<li><a href="../116322/index.html">Surgeons at Sunnybrook Hospital use Kinect during surgery.</a></li>
<li><a href="../116323/index.html">New issue of UserAndLINUX 11.04</a></li>
<li><a href="../116325/index.html">Google with MasterCard and Citigroup is working on a system of NFC payments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>