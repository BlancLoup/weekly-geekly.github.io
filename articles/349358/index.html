<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apache Ignite - database cache</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Apache Ignite, you can define a named data cache for persistent storage, load data into it, and then perform various manipulations with them. 

 Yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apache Ignite - database cache</h1><div class="post__text post__text-html js-mediator-article">  In Apache Ignite, you can define a named data cache for persistent storage, load data into it, and then perform various manipulations with them. <br><br>  You can perform get / put operations as c Map, for example, in java, these operations are called read-through, read-through and read-through.  Those.  after the cache is loaded, when the get operation is executed, the object will be taken from it, and not from the database, but when written, it will change in the cache and be written to the data storage.  If, when trying to take an object, it will not be in the cache, it will first be written to it.  It is clear that read operations will already be from the memory of the cache and very quickly.  All this is relevant for get / put operations.  For other search operations, for example, to search for an object that does not have a key - Query, how to quickly find data in the cache ?, work with transactions, all this is below in the article ... <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/c2/ea/4h/c2ea4hxkvzg7r1nti_pftmxz408.jpeg" alt="image"><br><br>  In the cache, the data is recorded by a key which may for example be the primary key from the database table.  For my example, I took the Oracle XE database, by default Ignite provides the H2 database, but in real life I think I will still have to deal with other databases.  So, we take an entity (table) of a database and prepare a class for it in Java (as a data source for an entity, there can be any set: view, function, etc., we can fully control here). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">KLADR table as a cache entry</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kladr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span>(index = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String code; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Timestamp upd_date; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kladr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, String code, String name, Timestamp upd_date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.code = code; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.upd_date = upd_date; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kladr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// No-op. } @Override public String toString() { return id + "/"+ code + "/" + name + "/" + upd_date; } }</span></span></code> </pre> <br></div></div><br>  Annotations show the fields that will participate in Query operations, as well as the index field. <br><br>  Now we need to inherit from the class - CacheStoreAdapter and override its main methods: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKladrStore</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheStoreAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kladr</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,    get (...)  Ignite Cache. @Override public Kladr load(Long key) { //     ,    ¬´put (...)¬ª  Ignite Cache. @Override public void write(Cache.Entry&lt;? extends Long, ? extends Kladr&gt; entry) { //     ,    ¬´remove (...)¬ª  Ignite Cache. @Override public void delete(Object key) { //  mehtod   ,   ¬´loadCache ()¬ª  ¬´localLoadCache ()¬ª //      . @Override public void loadCache(IgniteBiInClosure&lt;Long, Kladr&gt; clo, Object... args) {</span></span></code> </pre><br>  It can be seen that the key will be the ID, and the element of the collection is the class Kladr (&lt;Long, Kladr&gt;) <br><br>  It looks like this <br><br><div class="spoiler">  <b class="spoiler_title">CacheKladrStore</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKladrStore</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheStoreAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kladr</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,    get (...)  Ignite Cache. @Override public Kladr load(Long key) { try (Connection conn = connection()) { try (PreparedStatement st = conn.prepareStatement( "select id, code, name, upd_date from KLADR where id=?")) { st.setLong(1, key); ResultSet rs = st.executeQuery(); return rs.next() ? new Kladr(rs.getLong(1), rs.getString(2), rs.getString(3), rs.getTimestamp(4) ) : null; } } catch (SQLException e) { throw new CacheLoaderException("Failed to load: " + key, e); } } //     ,    ¬´put (...)¬ª  Ignite Cache. @Override public void write(Cache.Entry&lt;? extends Long, ? extends Kladr&gt; entry) { Long key = entry.getKey(); Kladr val = entry.getValue(); try (Connection conn = connection()) { try (PreparedStatement stUpd = conn.prepareStatement( "update KLADR set upd_date = ? where id = ?")) { stUpd.setTimestamp(1, val.upd_date); stUpd.setLong(2, val.id); int updated = stUpd.executeUpdate(); if (updated == 0) { try (PreparedStatement stIns = conn.prepareStatement( "insert into KLADR (id, code, name, upd_date) values (?, ?, ?, ?)")) { stUpd.setLong(1, val.id); stUpd.setString(2, val.code); stUpd.setString(2, val.name); //... //stIns.executeUpdate(); } } } } catch (SQLException e) { throw new CacheWriterException("Failed to write [key=" + key + ", val=" + val + ']', e); } } //     ,    ¬´remove (...)¬ª  Ignite Cache. @Override public void delete(Object key) { try (Connection conn = connection()) { try (PreparedStatement st = conn.prepareStatement("delete from KLADR where id=?")) { st.setLong(1, (Long)key); st.executeUpdate(); } } catch (SQLException e) { throw new CacheWriterException("Failed to delete: " + key, e); } } //  mehtod   ,   ¬´loadCache ()¬ª  ¬´localLoadCache ()¬ª //      . @Override public void loadCache(IgniteBiInClosure&lt;Long, Kladr&gt; clo, Object... args) { if (args == null || args.length == 0 || args[0] == null) throw new CacheLoaderException("Expected entry count parameter is not provided."); final int entryCnt = (Integer)args[0]; try (Connection conn = connection()) { try (PreparedStatement st = conn.prepareStatement( "select id, code, name, upd_date from KLADR where id between 100000 and 150000 and rownum &lt;= " + entryCnt)) { try (ResultSet rs = st.executeQuery()) { int cnt = 0; while (cnt &lt; entryCnt &amp;&amp; rs.next()) { Kladr kladr = new Kladr(rs.getLong(1), rs.getString(2), rs.getString(3), rs.getTimestamp(4) ); clo.apply(kladr.id, kladr); cnt++; } } } } catch (SQLException e) { throw new CacheLoaderException("Failed to load values from cache store.", e); } } //   JDBC      // ,   . private Connection connection() throws SQLException { return openConnection(true); } //   JDBC private Connection openConnection(boolean autocommit) throws SQLException { //    RDBMS (Oracle, MySQL, Postgres, DB2, Microsoft SQL  . .) //       Oracle. Locale.setDefault(Locale.ENGLISH); Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "HR", "1"); conn.setAutoCommit(autocommit); return conn; } }</span></span></code> </pre><br></div></div><br>  First tests <br><br><div class="spoiler">  <b class="spoiler_title">Preparing to start</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKladrStoreExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CACHE_NAME = CacheKladrStoreExample.class.getSimpleName(); <span class="hljs-comment"><span class="hljs-comment">/** *  , - . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ENTRY_COUNT = <span class="hljs-number"><span class="hljs-number">50_000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IgniteException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// To start ignite try (Ignite ignite = Ignition.start("examples/config/example-ignite.xml")) { System.out.println(); System.out.println("&gt;&gt;&gt; Cache store example started."); CacheConfiguration&lt;Long, Kladr&gt; cacheCfg = new CacheConfiguration&lt;&gt;(CACHE_NAME); // Set atomicity as transaction, since we are showing transactions in example. cacheCfg.setAtomicityMode(TRANSACTIONAL); // Configure Spring store. cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheKladrStore.class)); cacheCfg.setReadThrough(true); cacheCfg.setWriteThrough(true); //   Query     ,   . QueryEntity qe = new QueryEntity(Long.class, Kladr.class); LinkedHashMap linkedHashMap = new LinkedHashMap(); linkedHashMap.put("code", "java.lang.String"); linkedHashMap.put("name", "java.lang.String"); linkedHashMap.put("id", "java.lang.Long"); linkedHashMap.put("upd_date", "java.sql.Timestamp"); qe.setFields(linkedHashMap); Collection&lt;QueryEntity&gt; collection = new ArrayList&lt;&gt;(); collection.add(qe); cacheCfg.setQueryEntities(collection); //      . try (IgniteCache&lt;Long, Kladr&gt; cache = ignite.getOrCreateCache(cacheCfg)) { //  </span></span></code> </pre><br></div></div><br>  load a massively cache, 50,000 objects (see loadCache in CacheKladrStore above) <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Long, Kladr&gt; cache = ignite.getOrCreateCache(cacheCfg)) { <span class="hljs-comment"><span class="hljs-comment">//      . //  CacheStore.loadCache (...) loadCache(cache);</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">loadCache</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Long, Kladr&gt; cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">//    . cache.loadCache(null, ENTRY_COUNT); long end = System.currentTimeMillis(); System.out.println("&gt;&gt;&gt; Loaded size" + cache.size() + " " + (end - start) + "ms."); }</span></span></code> </pre><br></div></div><br>  Loading 50 000 thousand objects takes a few seconds.  What we ship, how much, everything under our control is convenient. <br><br>  We read data from the cache, for the ID that downloaded <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//    getFromCache(cache, 100_000L, 120_000L);</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">getFromCache</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Long, Kladr&gt; cache, Long i1, Long i2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> millis = System.currentTimeMillis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i = i1; i &lt; i2; i++) { Kladr kladr = cache.get(i); kladr.upd_date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timestamp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.util.Date().getTime()); } System.out.println(<span class="hljs-string"><span class="hljs-string">"getFromCache otal get values msec.:"</span></span> + (System.currentTimeMillis() - millis)); }</code> </pre><br></div></div><br>  we read 20 000 thousand objects, everything is fine here, everything is taken now from the cache, there are no calls in the database. <br><br>  But if you now call reading objects that are not in the cache <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//     getFromCache(cache, 10_000L, 11_000L);</span></span></code> </pre><br>  now for each get will be called (see CacheKladrStore) <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//     ,    get (...)  Ignite Cache. @Override public Kladr load(Long key) {</span></span></code> </pre><br>  the object will be read from the database and placed in the cache, the operation took me for 1,000 objects ‚Äî for several seconds already.  And already when re-reading will be taken from the cache as before in the test (read-through in action). <br><br>  Transaction Transactions <br><br><div class="spoiler">  <b class="spoiler_title">executeTransaction</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Long, Kladr&gt; cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long id1 = <span class="hljs-number"><span class="hljs-number">100_001L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long id2 = <span class="hljs-number"><span class="hljs-number">100_009L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = Ignition.ignite().transactions().txStart()) { <span class="hljs-comment"><span class="hljs-comment">//      1 Kladr val = cache.get(id1); System.out.println("Read value first id1: " + val); Kladr newKladr = new Kladr(id1, val.code, val.name, new Timestamp(new java.util.Date().getTime())); //    ,      cache.put(id1, newKladr); //       1 val = cache.get(id1); System.out.println("Read value after id1: " + val); // //     2 val = cache.get(id2); System.out.println("Read value first id2: " + val); newKladr = new Kladr(id2, val.code, val.name, new Timestamp(new java.util.Date().getTime())); cache.put(id2, newKladr); //       2 val = cache.get(id2); System.out.println("Read value after id2: " + val); //       . //      CacheKladrStore write(Cache.Entry&lt;? extends Long, ? extends Kladr&gt; entry) tx.commit(); } System.out.println("Read value id1 after commit: " + cache.get(id1)); }</span></span></code> </pre><br></div></div><br>  Yes, just as it should be (or almost), we open a transaction, modify various objects, and only if successful will they be recorded in the commit () database.  <b>For each modified object placed in the cache (put)</b> will be called (see CacheKladrStore) <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//     ,    ¬´put (...)¬ª  Ignite Cache. @Override public void write(Cache.Entry&lt;? extends Long, ? extends Kladr&gt; entry) {</span></span></code> </pre><br>  those.  after commit is called, - write will be called. <br><br>  Here is the console output: <br><br><img src="https://habrastorage.org/webt/fk/f-/8s/fkf-8sh6lxav0bkwjucaubf8vz8.png" alt="image"><br><br>  It can be seen that they were considered from the cache (previously from byzy), then modified, placed in the cache, and after the commit transaction the data were in the database and cache. <br><br>  And what if after the modification in the cache, but before writing to the database - Exception?, For example here <br><br><pre> <code class="java hljs"> System.out.println(<span class="hljs-string"><span class="hljs-string">"Read value after id2: "</span></span> + val); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"RuntimeException"</span></span>); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); } } System.out.println(<span class="hljs-string"><span class="hljs-string">"Read value id1 after commit: "</span></span> + cache.get(id1));</code> </pre><br>  .  Commit does not happen, but in the cache the data will be rolled back - everything is OK! <br><br><img src="https://habrastorage.org/webt/1e/qa/qe/1eqaqee_zqgzcm_qgem9zswh80g.png" alt="image"><br><br>  After Exception we see the previous value, which was before the modification. <br><br>  These were operations of the get / put type, but the application logic is not limited to this, and we need different searches according to different criteria, to get collections and single objects. <br><br>  Query can work with this in the cache.  There is a feature requests will work <b>only with the data that is already in the cache</b> . <br><br>  An example of working with a cache through a query: <br><br><pre> <code class="java hljs">SqlQuery sql = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(Kladr.class, <span class="hljs-string"><span class="hljs-string">"id = ?"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">100_000</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">101_000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (QueryCursor&lt;Cache.Entry&lt;Long, Kladr&gt;&gt; cursor = cache.query(sql.setArgs(i))) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Cache.Entry&lt;Long, Kladr&gt; e : cursor) { e.getValue().upd_date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timestamp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.util.Date().getTime()); t++; } } } System.out.println(<span class="hljs-string"><span class="hljs-string">"SqlQuery by id "</span></span> + (System.currentTimeMillis() - start) + <span class="hljs-string"><span class="hljs-string">"msec, t="</span></span> + t);</code> </pre><br>  reading 1000 objects took 300 ms.  But there was a reading across the field which was annotated as an index. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span>(index = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id;</code> </pre><br>  And again, in life, we need searches and other fields, check the ‚Äúcode‚Äù field where there is no index, the result is sad, as in the database (but in fact much worse) full scan, the search has been done 1000 times for 30 seconds. <br><br><div class="spoiler">  <b class="spoiler_title">Search in the 'code' field</b> <div class="spoiler_text"><pre> <code class="java hljs"> String[] codes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"4401300010999"</span></span>, <span class="hljs-string"><span class="hljs-string">"4401300011700"</span></span>}; sql = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(Kladr.class, <span class="hljs-string"><span class="hljs-string">"code = ?"</span></span>); start = System.currentTimeMillis(); t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">100_000</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">101_000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (QueryCursor&lt;Cache.Entry&lt;Long, Kladr&gt;&gt; cursor = cache.query(sql.setArgs(codes[i % <span class="hljs-number"><span class="hljs-number">2</span></span>]))) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Cache.Entry&lt;Long, Kladr&gt; e : cursor) { e.getValue().upd_date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timestamp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.util.Date().getTime()); t++; } } } System.out.println(<span class="hljs-string"><span class="hljs-string">"SqlQuery by code "</span></span> + (System.currentTimeMillis() - start) + <span class="hljs-string"><span class="hljs-string">"msec., t="</span></span> +t);</code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/1n/fe/tj/1nfetjd2jf7erbzuqwvnj83zmzq.png" alt="image"><br><br>  I didn‚Äôt want to compare, but this case became interesting to me, going through all the values, the data in the cache (in memory) seems to be pretty attractive conditions and how the database (Oracle XE) will handle this search.  Here is the result, the same search in the database gave 6 seconds. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> code_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> VARCHAR2(<span class="hljs-number"><span class="hljs-number">30</span></span>); v_codes code_type; v_code varchar2(30); v_t number :=0; v_ts timestamp; v_id number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> v_codes := code_type(<span class="hljs-string"><span class="hljs-string">'4401300010999'</span></span>, <span class="hljs-string"><span class="hljs-string">'4401300011700'</span></span>); v_ts := systimestamp; for i in 1..1000 loop v_code := v_codes((i mod 2)+1); <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kladr k <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> k.code = v_code; v_t := v_t + 1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; dbms_output.put_line('query by code ' || to_char(systimestamp - v_ts) || ', t=' || v_t); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><img src="https://habrastorage.org/webt/a1/rz/6z/a1rz6zjzcid2sg2hruxovlmjliq.png" alt="image"><br><br>  Apparently in the database more intellectually deals with the cache, storage, search, and so on.  If the field to add an index, search in the database 28ms.  In Ignite, you can also add an index on one more field and search - took off! <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span>(index = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String code;</code> </pre><br><img src="https://habrastorage.org/webt/1s/gm/9o/1sgm9orkxscej_6b8ny2sjym-tq.png" alt="image"><br><br>  and made - 160ms. <br><br>  True in the database, it went an order of magnitude faster with the index.  But this is not always the main thing, the <a href="https://habrahabr.ru/post/348202/">issue of scaling the</a> computing system (previously considered) is also very important. <br><br>  There are other types of requests to the cache, for example ScanQuery, here is the same example with it: <br><br><div class="spoiler">  <b class="spoiler_title">Scanquery</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">100_000</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">101_000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = i; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (QueryCursor&lt;Cache.Entry&lt;Long, Kladr&gt;&gt; cursor = cache.query(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScanQuery&lt;Long, Kladr&gt;((k, v) -&gt; v.id == id))) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Cache.Entry&lt;Long, Kladr&gt; e : cursor) e.getValue().upd_date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timestamp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.util.Date().getTime()); t++; } } System.out.println(<span class="hljs-string"><span class="hljs-string">"ScanQuery by id "</span></span> + (System.currentTimeMillis() - start) + <span class="hljs-string"><span class="hljs-string">"msec., t="</span></span> +t);</code> </pre><br></div></div><br>  Its result is: <br><br><img src="https://habrastorage.org/webt/rd/zv/yh/rdzvyhqfakijj4feqgh4lteuog8.png" alt="image"><br><br>  <a href="https://apacheignite.readme.io/v1.1/docs/persistent-store">Material</a> </div><p>Source: <a href="https://habr.com/ru/post/349358/">https://habr.com/ru/post/349358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349344/index.html">FastTrack Training. "Network Basics". Understanding Cisco Architecture. Eddie Martin December 2012</a></li>
<li><a href="../349348/index.html">The way to manage color schemes "Swift" "iOS" applications</a></li>
<li><a href="../349350/index.html">Setting up the development environment: coffee grounds (Part 2)</a></li>
<li><a href="../349354/index.html">Develop isomorphic RealWorld applications with SSR and Progressive Enhancement. Part 2 - Hello World</a></li>
<li><a href="../349356/index.html">Sum of iconCaption points in the cluster LoadingObjectManager</a></li>
<li><a href="../349360/index.html">Bitcoin will not be a new digital money: about the drug business, transaction costs and gold</a></li>
<li><a href="../349362/index.html">SVG masks and wow effects: magic with simple words</a></li>
<li><a href="../349364/index.html">OOP without "O"</a></li>
<li><a href="../349366/index.html">Web components. Part 1: Custom Elements</a></li>
<li><a href="../349370/index.html">How I adjusted Telegram notifications for Mi Band 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>