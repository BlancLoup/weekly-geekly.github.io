<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recognition of the RF passport on the Elbrus platform. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will continue to talk about the adventures of our passport recognition program: now the passport will go to Elbrus! 



 So, what d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recognition of the RF passport on the Elbrus platform. Part 1</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article we will continue to talk about the adventures of our passport recognition program: now the passport will go to Elbrus! </p><br><div style="text-align:center;"><img width="70%" src="https://habrastorage.org/files/afe/6fe/891/afe6fe8914ed41618335ee077625a104.png"></div><br><p>  So, what do we know about the architecture of Elbrus? </p><br><p>  Elbrus is a high-performance and energy-efficient processor architecture, characterized by high security and reliability.  Modern Elbrus architecture processors can be used as servers, desktops, and even embedded computers.  They are able to meet the increased requirements for information security, the working temperature range and the duration of the product life cycle.  The Elbrus architecture processors, as we are told by the MCST publications [1, 2], are intended for solving problems of signal processing, mathematical modeling, scientific calculations, as well as other tasks with increased requirements for computing power. </p><br><p>  We in Smart Engines tried to make sure that the performance of Elbrus is true enough to realize the recognition of a passport without significant loss in speed. </p><a name="habracut"></a><br><h3>  Overview and narrative: architecture features Elbrus </h3><br><p>  The architecture of Elbrus belongs to the category of architectures that use the principle of a wide command word (Very Long Instruction Word, VLIW).  On processors with a VLIW architecture, the compiler generates sequences of groups of commands (broad command words), in which there are no dependencies between the commands within the group and the dependencies between the commands in different groups are minimized.  These groups of commands are executed in parallel, which ensures a high level of parallelism at the level of operations. </p><br><img width="35%" align="left" src="https://habrastorage.org/files/53d/334/93e/53d33493e60247bc9513234b5c5125b0.png"><br><p>  Parallelization at the command level is entirely provided by the optimizing compiler, which significantly simplifies the hardware for executing commands, since now it does not solve paralleling tasks, as is the case, for example, with the x86 architecture.  The power consumption of the system is reduced: the processor is no longer required to analyze dependencies between operands or rearrange operations, since all these tasks are assigned to the compiler.  The compiler has much more computational and time resources than hardware analyzers of binary code, and therefore can perform the analysis more carefully, find more independent operations, and as a result form broad command words that are executed more efficiently. </p><br><p>  Along with the use of parallelism of operations in the Elbrus architecture, the implementation of other types of parallelism characteristic of the computational process is also laid: vector parallelism, parallelism of control flows on shared memory, task parallelism in a multi-machine complex. </p><br><p>  In addition, the Elbrus architecture is binary compatible with the Intel x86 architecture, implemented on the basis of dynamic binary translation. </p><br><p>  Another important feature of the Elbrus architecture is the hardware support for the protection of programs and data during execution.  Programs are executed in a single virtual space implemented at the hardware level, which minimizes the possibility of executing malicious code and allows detecting errors that are difficult to be detected on other architectures. </p><br><p>  Thus, the main features of the architecture of Elbrus processors [3, 4]: </p><br><ul><li>  parallel energy efficient core architecture; </li><li>  automatic parallelization of a stream of commands using a compiler; </li><li>  increasing the reliability and security of the created software due to the presence of a protected mode; </li><li>  compatibility with common microprocessor architectures. </li></ul><br><h3>  Our acquaintance with Elbrus </h3><br><p> The specific machine we were working with was Elbrus 4.4, combining four 4-core Elbrus 4C processors with 3 memory controllers, 3 interprocessor exchange channels, 1 I / O channel and 8 MB of cache level 2 (2 MB per core) .  The operating clock frequency of the Elbrus 4C is 800 MHz, the technological norm is 65 nm, the average power dissipation is 45 W.  Operating system - OS "Elbrus", created on the basis of Linux.  This is what the <code>uname -a</code> command displayed to us: </p><br><div style="text-align:center;"><img width="100%" src="https://habrastorage.org/files/dc0/3be/765/dc03be765c074e1db9f8c23003ae6103.png"></div><br><p>  The optimizing compiler for Elbrus is called lcc.  On our server was installed lcc version 1.20.09 dated August 27, 2015, compatible with gcc 4.4.0.  lcc works with standard gcc flags, and also defines some additional ones.  From the standard flags, we noticed -ffast and -ffast-math.  These options are disabled by default, because they include transformations with real arithmetic, which can lead to incorrect results of programs that imply strict adherence to the IEEE or ISO standards for real operations and functions.  In addition, they include some potentially dangerous optimizations, which in rare cases can lead to incorrect behavior of programs that freely juggle with pointers.  Both flags additionally include -fstdlib, -faligned, -fno-math-errno, -fno-signed-zeros, -ffinite-math-only, -fprefetch, -floop-apb-conditional-loads, -fstrict-aliasing.  Their use significantly affects the performance of the program. </p><br><p>  In addition, lcc allows you to fine-tune the optimization quite fine, for example, there are a whole set of flags to configure the function substitution parameters: </p><br><p>  Table 1. Flags lcc, allowing control of function substitution parameters. </p><br><table><thead><tr><th>  Lcc flag </th><th>  Purpose </th></tr></thead><tbody><tr><td>  -finline-level = &lt;f&gt; </td><td>  Sets the rate of substitution increase [0.1-20.0] </td></tr><tr><td>  -finline-scale = &lt;f&gt; </td><td>  Sets the rate of increase of the main resource constraints [0.1-5.0] </td></tr><tr><td>  -finline-growfactor = &lt;f&gt; </td><td>  Sets the maximum increase in the size of the procedure after substitution [1.0-30.0] </td></tr><tr><td>  -finline-prog-growfactor = &lt;f&gt; </td><td>  Specifies the maximum increase in the size of the program after substitution [1.0-30.0] </td></tr><tr><td>  -finline-size = &lt;n&gt; </td><td>  Sets the maximum size of the inline procedure. </td></tr><tr><td>  -finline-to-size = &lt;n&gt; </td><td>  Specifies the maximum size of the procedure into which substitution can be made. </td></tr><tr><td>  -finline-part-size = &lt;n&gt; </td><td>  Sets the maximum size of the probable procedure region for partial substitution </td></tr><tr><td>  -finline-second-size = &lt;n&gt; </td><td>  Specifies the maximum size of an unconditional invoked procedure </td></tr><tr><td>  -flib-inline-uncond-size = &lt;n&gt; </td><td>  Sets the maximum size of an unconditional library routine. </td></tr><tr><td>  -finline-probable-calls = &lt;f&gt; </td><td>  Prohibits the substitution of procedures, the call counter of which is less than (argument * max_call_count), <br>  where max_call_count is the maximum call operation counter for the entire task. </td></tr><tr><td>  -force-inline </td><td>  Enables unconditional function substitution with the inline specifier. </td></tr><tr><td>  -finline-vararg </td><td>  Includes the substitution of functions with a variable number of arguments. </td></tr><tr><td>  -finline-only-native </td><td>  Performs substitution only for functions with an explicit inline modifier </td></tr></tbody></table><br><p>  You can also customize interprocedural optimizations, pointer analysis, data paging, etc. </p><br><p>  For profiling on Elbrus, familiar to many perf are available, as well as the much less well-known dprof.  In addition, an extension is available for dprof that allows you to convert a profile to a valgrind-compatible format. </p><br><p>  So, our goal was to launch the console version of the passport recognition program.  It is written entirely in C / C ++, sometimes using C ++ 11.  Despite the fact that C ++ 11 support is not stated, in fact, lcc understands it, although very selectively.  Full C ++ 11 support is planned for newer versions of lcc. <br>  Not exactly supported: </p><br><ul><li>  std :: default_random_engine.  Unfortunately, here you can only advise to use third-party pseudo-random number generators. </li><li>  nullptr_t.  In those cases when nullptr is really needed, you have to use some specially selected value of the object instead. </li><li>  std :: begin and std :: end.  For STL objects, you can use the begin () and end () methods, but for C / C ++ objects you will have to search for addresses manually. </li><li>  std :: chrono :: steady_clock.  We used std :: chrono :: high_resolution_clock instead of it, although, of course, the absence of std :: chrono :: steady_clock can introduce inaccuracies in the measurement of working time. </li><li>  The std :: string :: pop_back () method is missing.  But instead you can easily use std :: string :: erase (size () - 1, 1). </li><li>  std :: to_string is not defined for a double argument.  This problem is solved by converting, for example, to long double, which is supported. </li><li>  The standard STL containers do not provide specifications for std :: unique_ptr as a stored object with a move operation instead of copying, that is, for example, std :: map &lt;int, std :: uniqie_ptr&gt; cannot be created. </li></ul><br><p>  At the same time, std :: unique_ptr, std :: shared_ptr are supported by themselves. </p><br><p>  In addition, lcc disturbs the __uint128_t gcc extension, as well as the source code files in UTF-8 with BOM. </p><br><p>  After rewriting unsupported pieces of code, we were able to successfully compile our project.  However, we simply did not succeed in simply taking and running the passport recognition program: we received an error Bus error when trying to start it.  After consultation with the experts of the MCST, it was found that the problem lies in the unallocated access to the memory that occurs inside the Eigen library, which we use. </p><br><p>  Eigen is an optimized header-only linear algebra library written in C ++ [5].  It can be used for various operations on matrices and vectors, and also includes optimizations for x86 SSE, ARM NEON, PowerPC AltiVec and even IBM S390x. </p><br><p>  Since the Eigen developers hardly expected that their library would ever be used on Elbrus, they did not include it in the list of supported architectures, and the mode of aligned memory access was simply disabled.  Our colleagues from the MCST promptly helped us fix this problem by showing how to modify: </p><br><div style="text-align:center;"><img width="100%" src="https://habrastorage.org/files/9da/26c/973/9da26c9736414f7cb560e748c36dfd5e.png"></div><br><p>  As a result of this addition, the Eigen functionality we need has earned.  It should be noted that this was the only incompatibility of Eigen with Elbrus, and it manifests itself only with the included optimizations. </p><br><p>  However, our misadventures did not stop at this.  The error Bus error has not gone away, but now it appeared when the code was already executed by our libraries.  After a little research, we found that unallocated memory access periodically arose during the initialization of additional image containers in the recognition process. </p><br><p>  When filling a 8-bit line with a fixed value, in order to accelerate, there was a part of the line that is a multiple of 4 bytes, and was filled with 32-bit values ‚Äã‚Äã(created by copying the original 8-bit), and the rest of the line was filled with one byte.  However, when allocating an 8-bit picture, alignment in the memory is guaranteed only up to one byte, and an error occurred when trying to write a 32-bit value to this address. <br>  To solve the problem, we added in the beginning of processing the line calculation of the nearest address, which is a multiple of the required number of bytes (in the described case - four) and filling in to this address one byte, and filling in 4 bytes already done from this address. <br>  After correcting this error, our program not only started, but also demonstrated proper operation! </p><br><p><img width="29%" src="https://habrastorage.org/files/0aa/f00/ed6/0aaf00ed63e542d1bc754711d5079ddc.png"><img width="69%" src="https://habrastorage.org/files/e18/52b/145/e1852b145bd641bfa4b63e08cac43acf.png"></p><br><p>  It was already a small victory, but we moved on.  The next step we went directly to optimizing our system.  Our program can work in two modes: recognition of a randomly located passport in a photo or a scanned image (anywhere mode), and also recognition of a passport in a video clip (mobile mode).  In the second case, it is assumed that the passport takes up most of the frame, from frame to frame its position changes slightly, and the processing of one frame includes significantly simplified document search algorithms. </p><br><p>  Recognition of one test image in anywhere-mode, going to 1 stream, ‚Äúout of the box‚Äù worked on Elbrus for about 100 (!) Seconds. </p><br><p>  At first we tried to use all 16 Elbrus cores 4.4.  It was possible to use all 16 flows efficiently only in about a third of our program.  The remaining calculations managed to be parallelized into 2 threads.  As a result, the recognition time was reduced to 7.5 seconds.  Inspired, we looked at the profiler.  To our surprise, we saw something like this there: </p><br><div style="text-align:center;"><img width="100%" src="https://habrastorage.org/files/2c2/95c/8e6/2c295c8e69604c87baf63f9c6a4fa3af.png"></div><br><p>  It turned out that inside the main program loop there was a wonderful place: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object&gt; candidates; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> x = x_min; x &lt; x_max; x += x_step) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> y = y_min; y &lt; y_max; y += y_step) candidates.emplace_back(x, y, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>);</code> </pre> <br><p>  As a result of the repeated execution of this code, the overhead of changing the size of the vector is monstrously growing and reaches 16% of the recognition time.  On other architectures, this place was not noticeable, but on Elbrus memory reallocation was unexpectedly slow.  After correcting this annoying misstep, the operating time was reduced by almost 1 second. </p><br><p>  Then we proceeded to increase the parallelism within each thread - the main ‚Äúchip‚Äù of the VLIW.  To do this, we used the shortest path - the EML library already optimized by the MCST specialists. </p><br><h3>  High Performance EML Library </h3><br><p>  For microprocessors of the Elbrus architecture, the EML library has been developed - a library that provides the user with a set of various functions for high-performance processing of signals, images, video, as well as mathematical functions and operations [4, 6]. </p><br><p>  EML includes the following function groups: </p><br><ul><li>  Vector - functions for working with data vectors (arrays); </li><li>  Algebra - functions of linear algebra; </li><li>  Signal - signal processing functions; </li><li>  Image - image processing functions; </li><li>  Video - video processing functions; </li><li>  Volume - transformation functions of three-dimensional structures; </li><li>  Graphics - functions for drawing shapes. </li></ul><br><p>  The EML library is intended for use in programs written in C / C ++ languages. </p><br><p>  Low-level image processing functions are either supported by EML directly, or representable through the basic arithmetic functions of EML on vectors (in our case, image lines). </p><br><p>  For example, elementwise addition of two arrays of 32-bit real numbers: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) dst[i] = src1[i] + src2[i];</code> </pre> <br><p>  can be performed using the EML function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_Add_32F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32f *pSrc1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32f *pSrc2, eml_32f *pDst, eml_32s len)</span></span></span></span></code> </pre> <br><p>  Where </p><br><ul><li>  <code>pSrc1</code> - pointer to the vector of the first operand </li><li>  <code>pSrc2</code> - Pointer to the second operand vector </li><li>  <code>pDst</code> - <code>pDst</code> vector pointer </li><li>  <code>len</code> - The number of elements in vectors </li></ul><br><p>  She returns </p><br><ul><li>  <code>EML_OK</code> if the function completed successfully </li><li>  <code>EML_INVALIDPARAMETER</code> if one of the pointers is NULL or the length of the vectors is less than or equal to 0. </li></ul><br><p>  The total eml_Status enumeration can take 4 values: </p><br><ul><li>  <code>EML_OK</code> - No Error </li><li>  <code>EML_INVALIDPARAMETER</code> - <code>EML_INVALIDPARAMETER</code> argument or out of range </li><li>  <code>EML_NOMEMORY</code> - No free memory for the operation. </li><li>  <code>EML_RUNTIMEERROR</code> - Incorrect data, error during execution </li></ul><br><p>  The main data types are defined: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> eml_8s; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> eml_8u; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> eml_16s; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> eml_16u; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eml_32s; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eml_32u; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eml_32f; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> eml_64f;</code> </pre> <br><p>  The function for the elementwise multiplication of 32-bit real numbers is similarly arranged: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_Mul_32F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32f *pSrc1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32f *pSrc2, eml_32f *pDst, eml_32s len)</span></span></span></span></code> </pre> <br><p>  But for integers, only the functions of elementwise addition and multiplication with a shift are defined, which perform the following operations: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Addition for (int i = 0; i &lt; len; ++i) dst[i] = SATURATE((src1[i] + src2[i]) &lt;&lt; shift); // Multiplication for (int i = 0; i &lt; len; ++i) dst[i] = SATURATE((src1[i] * src2[i]) &lt;&lt; shift);</span></span></code> </pre> <br><p>  And the actual EML function: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// int16_t addition eml_Status eml_Vector_AddShift_16S(const eml_16s *pSrc1, const eml_16s *pSrc2, eml_16s *pDst, eml_32s len, eml_32s shift) // int32_t addition eml_Status eml_Vector_AddShift_32S(const eml_32s *pSrc1, const eml_32s *pSrc2, eml_32s *pDst, eml_32s len, eml_32s shift) // uint8_t addition eml_Status eml_Vector_AddShift_8U(const eml_8u *pSrc1, const eml_8u *pSrc2, eml_8u *pDst, eml_32s len, eml_32s shift) // int16_t multiplication eml_Status eml_Vector_MulShift_16S(const eml_16s *pSrc1, const eml_16s *pSrc2, eml_16s *pDst, eml_32s len, eml_32s shift) // int32_t multiplication eml_Status eml_Vector_MulShift_32S(const eml_32s *pSrc1, const eml_32s *pSrc2, eml_32s *pDst, eml_32s len, eml_32s shift) // uint8_t multiplication eml_Status eml_Vector_MulShift_8U(const eml_8u *pSrc1, const eml_8u *pSrc2, eml_8u *pDst, eml_32s len, eml_32s shift)</span></span></code> </pre> <br><p>  Such functions can be useful, for example, for integer arithmetic. </p><br><p>  EML defines a structure for an image: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * data; <span class="hljs-comment"><span class="hljs-comment">/**&lt;     */</span></span> eml_image_type type; <span class="hljs-comment"><span class="hljs-comment">/**&lt;    */</span></span> eml_32s width; <span class="hljs-comment"><span class="hljs-comment">/**&lt;    ,  x */</span></span> eml_32s height; <span class="hljs-comment"><span class="hljs-comment">/**&lt;    ,  y */</span></span> eml_32s stride; <span class="hljs-comment"><span class="hljs-comment">/**&lt;       */</span></span> eml_32s channels; <span class="hljs-comment"><span class="hljs-comment">/**&lt;   ()   */</span></span> eml_32s flags; <span class="hljs-comment"><span class="hljs-comment">/**&lt;   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * state; <span class="hljs-comment"><span class="hljs-comment">/**&lt;     */</span></span> eml_32s bitoffset;<span class="hljs-comment"><span class="hljs-comment">/**&lt;           */</span></span> eml_format format; <span class="hljs-comment"><span class="hljs-comment">/**&lt;   */</span></span> eml_8u addition[<span class="hljs-number"><span class="hljs-number">32</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)]; <span class="hljs-comment"><span class="hljs-comment">/**&lt;     64  */</span></span> } eml_image;</code> </pre> <br><p>  Supported eml_image_type data types for images: </p><br><ul><li>  EML_BIT - 1-bit unsigned integer data </li><li>  EML_UCHAR - 8-bit unsigned integer data </li><li>  EML_SHORT - 16-bit signed integer data </li><li>  EML_INT - 32-bit signed integer data </li><li>  EML_FLOAT - 32-bit floating point data </li><li>  EML_DOUBLE - 64-bit floating point data </li><li>  EML_USHORT - 16-bit non-valid integer data </li></ul><br><p>  EML supports other functions needed for image processing.  For example, the transposition function, which is often necessary for the effective implementation of separable filters: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Image_FlipMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_image *pSrc, eml_image *pDst)</span></span></span></span></code> </pre> <br><p>  This function superimposes the center of the original image on the center of the resulting image and transposes it.  Her work can be described by the formula: </p><br><pre> <code class="cpp hljs">dst[width_dst/<span class="hljs-number"><span class="hljs-number">2</span></span> + (y - height_src/<span class="hljs-number"><span class="hljs-number">2</span></span>), height_dst/<span class="hljs-number"><span class="hljs-number">2</span></span> + (x - width_src/<span class="hljs-number"><span class="hljs-number">2</span></span>)] = src[x, y],  x = [<span class="hljs-number"><span class="hljs-number">0</span></span>, width<span class="hljs-number"><span class="hljs-number">-1</span></span>], y = [<span class="hljs-number"><span class="hljs-number">0</span></span>, height<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre> <br><p>  Images must have the same data type ( <code>EML_UCHAR, EML_SHORT, EML_FLOAT  EML_DOUBLE</code> ) and have the same number of channels (1, 3 or 4). </p><br><h3>  Experiments and Results </h3><br><p>  Table 2 shows addition and multiplication times for different types of data.  In this experiment, we measured 50 times the execution time of 1000 iterations of addition / multiplication of two arrays of length 10 <sup>5</sup> and took the median from the obtained values.  The table shows the average execution time per iteration.  It can be seen that the use of EML makes it possible to significantly speed up computations in real 32-bit numbers and 8-bit unsigned integers.  This is important because these types of data are very often used in an optimized image processing path. </p><br><p>  Table 2. The execution time of addition and multiplication of arrays of numbers of length 10 <sup>5</sup> per Elbrus 4.4. </p><br><table><thead><tr><th>  Addition </th></tr></thead><tbody><tr><td>  <strong>Data type</strong> </td><td>  <strong>uint8_t</strong> </td><td>  <strong>float</strong> </td></tr><tr><td>  Without EML, Œºs </td><td>  16.7 </td><td>  148.8 </td></tr><tr><td>  EML, Œºs </td><td>  8.0 </td><td>  83.6 </td></tr></tbody></table><br><table><thead><tr><th>  <strong>Multiplication</strong> </th></tr></thead><tbody><tr><td>  <strong>Data type</strong> </td><td>  <strong>uint8_t</strong> </td><td>  <strong>float</strong> </td></tr><tr><td>  Without EML, Œºs </td><td>  31.4 </td><td>  108.9 </td></tr><tr><td>  EML, Œºs </td><td>  27.6 </td><td>  73.5 </td></tr></tbody></table><br><p>  Then, we decided to test how EML handles images and investigated transposition, since this is a fairly demanded operation in image processing.  The dependence of the transposition time on the size for square images of different types: </p><br><div style="text-align:center;"><img width="100%" src="https://habrastorage.org/files/15f/d79/4ae/15fd794ae86f4e758a8659d8cf3cb0be.png"></div><br><p>  You can see that the EML demonstrates good acceleration for the uint8_t and float types. </p><br><p>  The results of speeding up the passport recognition program (test image, anywhere mode) are shown in Table 3. They were obtained in the first 3 months of working with Elbrus and, of course, we plan to work on optimizing the system further. </p><br><p>  Table 3. The process of optimizing the passport recognition program for Elbrus 4.4. </p><br><table><thead><tr><th>  Version </th><th>  Work time with </th></tr></thead><tbody><tr><td>  1 thread </td><td>  ~ 100 </td></tr><tr><td>  16 streams, O3 </td><td>  6.2 </td></tr><tr><td>  16 streams, O4 </td><td>  5.4 </td></tr><tr><td>  16 streams, O4, transpose (EML) </td><td>  5.0 </td></tr><tr><td>  16 streams, O4, transpose, matrix operations (EML) </td><td>  4.5 </td></tr><tr><td>  16 streams, O4, transpose, matrix operations, arithmetic operations (EML) </td><td>  3.4 </td></tr></tbody></table><br><p>  To estimate the operating time of the optimized version, we analyzed the operating time for 1000 input images for each of the modes.  Table 4 shows the minimum, maximum and average recognition times for a single frame for anywhere and mobile modes. </p><br><p>  Table 4. The time of recognition of the passport to Elbrus 4.4. </p><br><table><thead><tr><th>  Mode </th><th>  Minimum time, c </th><th>  Maximum time with </th><th>  Average time, with </th></tr></thead><tbody><tr><td>  anywhere </td><td>  0.9 </td><td>  8.5 </td><td>  2.2 </td></tr><tr><td>  mobile </td><td>  0.2 </td><td>  1.5 </td><td>  0.6 </td></tr></tbody></table><br><p>  We did not compare performance with Intel or ARM: it took us several years to optimize our libraries for these processors and it would be incorrect to make a comparison now, after only 3 months of work. </p><br><h3>  Conclusion </h3><br><p>  In this article we tried to share our experience of porting the program to such an unusual architecture as Elbrus.  ‚ÄúThis definitely cannot happen to us!‚Äù - we thought, talking about some types of software errors, but no one is immune from silly blunders.  We have to admit that working with the Elbrus platform really helped us find at least two problem areas in our code, so the manufacturer‚Äôs promises can be considered fulfilled. </p><br><p>  In just a few months, we managed not only to achieve the correct operation of recognition, but also to significantly accelerate our system on Elbrus.  Now the performance of our passport recognition program for Elbrus 4.4 and x86 is no longer an order of magnitude difference, which is a very good result.  And we do not intend to stop there.  We believe that it can still be significantly improved. </p><br><p>  Well, all this means that our first steps in the journey to Elbrus can be considered quite successful! </p><br><p>  Many thanks to the company MCST and its staff for providing the hardware platform and advice on architecture and optimization. </p><br><h4>  Used sources </h4><br><p>  [1] A.K.  Kim, I.N.  Bychkov et al. Elbrus architectural line today: microprocessors, computing systems, software // Modern information technologies and IT education.  Collection of reports, p.  21‚Äì29. <br>  [2] A.K.  Kim  Russian universal microprocessors and high performance computing systems: results and a look into the future.  Issues of radio electronics series EVT, Vol. 3, c.  5‚Äì13, 2012. <br>  [3] A.K.  Kim and I.N.  Bychkov.  Russian technology "Elbrus" for personal computers, servers and supercomputers. <br>  [4] V.S.  Volin et al. Microprocessors and computing complexes of the Elbrus family.  Tutorial.  Peter, 2013. <br>  [5] Eigen, C ++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms, <a href="http://eigen.tuxfamily.org/">http://eigen.tuxfamily.org</a> . <br>  [6] P.A.  Ishin, V.E.  Loginov, and P.P.  Vasiliev.  Acceleration of calculations using high-performance mathematical and multimedia libraries for the Elbrus architecture. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/304750/">https://habr.com/ru/post/304750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304738/index.html">Vulnerabilities of corporate information systems - 2015: inside is worse than outside</a></li>
<li><a href="../304740/index.html">Signal and Transport Protocols WebRTC: Tearing Covers</a></li>
<li><a href="../304742/index.html">Usability rules for bots</a></li>
<li><a href="../304744/index.html">ETERNUS Snapshot Manager - an effective tool for high data availability</a></li>
<li><a href="../304748/index.html">Introduction to compilers, interpreters and JITs</a></li>
<li><a href="../304752/index.html">Wecon LX3V: Chinese PLC with aliexpress</a></li>
<li><a href="../304754/index.html">The report on the results of "My Circle" for June 2016, and the most popular vacancies of the month</a></li>
<li><a href="../304758/index.html">Who should be afraid of among malware</a></li>
<li><a href="../304760/index.html">Popular logistics trends for e-commerce</a></li>
<li><a href="../304764/index.html">The evolution of threats and defense strategies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>