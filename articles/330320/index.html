<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Looking Ahead</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One hundred and thirteen times a second, it stretches, and gets farther and farther. If a confirmation came, the signal - it could stop, and it does n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Looking Ahead</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>One hundred and thirteen times a second, it stretches, and gets farther and farther.</i></b>  <b><i>If a confirmation came, the signal - it could stop, and it does not stop.</i></b>  <b><i>It stretches and finds new ways.</i></b>  <b><i>It improvises, it studies.</i></b>  <b><i>It does not realize that it does ...</i></b> <b><i><br><br></i></b>  <b><i>James Cory "The Fire of Sibola"</i></b> <br><br>  Generally speaking, "strong" AI game is not my priority.  It is foolish to compete with specialized game engines, doing universal and having only single-threaded JavaScript built into the browser as a computing resource.  In addition, there are a number of games in which the need for complex AI simply does not arise.  Here, for example, the entire AI comes down to <a href="">finding the shortest path</a> , and in <a href="https://glukkazan.github.io/stalemate/hunt.htm">this game</a> , the task copes with the <a href="">random</a> task.  Alas, such games are the exception rather than the rule.  More often, one has to work hard enough for the program to make moves that would not seem idiotic. <br><a name="habracut"></a><br>  The goal of my <a href="https://glukkazan.github.io/">project</a> is to promote board games.  I'm looking for little-known or simply forgotten board games and try to bring them back to life.  A variety of games: ancient, modern, complex and very childish, for two players or more of them.  Even for one player (puzzles are also games).  One criterion - the <a href="https://github.com/GlukKazan/Dagaz/blob/master/doc/games.txt">game</a> should be interesting!  At least to me. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the current stage of development of the project, the server part does not imply any more than a set of html-pages with the accompanying JavaScript code.  I want the game to load and work in any modern Web browser, including locally, without access to the Internet.  All sorts of competitions, ratings and everything related to the interaction of players-people among themselves - all this is not about my project.  Perhaps it will be, but hardly in the near future. <br><br>  And here comes the development of bots and algorithms controlling them.  That is, an interactive board with the most complete control of the rules of the game is nice, but in order to interest a person who may not be familiar with the game at all, you need to play with him.  And since the game of people among themselves is not yet provided, we have to deal with bots. <br><br><h2>  <b>The basic Instinct</b> </h2><br>  As I said, there are games in which the machine requires not so much intelligence as instinct.  And this does not mean that the games are bad!  As a rule, such games are asymmetric.  A creative approach is required from one of the parties (a person will do it), the game of the other side is more routine.  Here is a good <a href="https://glukkazan.github.io/elimination/maharadja.htm">example of</a> such a game. <br><br>  Having on your side a complete chess "army", you need to catch (eat) just one piece - Maharaj, combining the moves of a chess knight and queen.  This is a very strong piece, but if White plays correctly, the outcome is predetermined.  On the other hand, playing for black is rather trivial.  The implementation of the <a href="">bot is</a> not much different from the random one.  He does the following: <br><br><ol><li>  Among all the available moves, he is looking for a move directly leading to victory (in our case, this is taking the opponent's king) </li><li>  If there is no such move, looking for any move taking the opponent's piece and not substituting for ‚ÄúMaharaj‚Äù under the counter attack </li><li>  If there are no suitable moves, it makes any safe move. </li><li>  If there are no safe moves, pass the baton to another bot (usually random) </li></ol><br>  Oddly enough, this simple strategy is suitable for many games.  In any case, in the first approximation.  Here are video <a href="http://www.di.fc.ul.pt/~jpn/gv/archimedes.htm">games</a> with rather exotic rules of capture.  The figures are immediately removed from the board if they are threatened (by the rules of the chess queen) three or more opponent pieces: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SJtaql0lNww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Here is another example.  In the " <a href="http://www.di.fc.ul.pt/~jpn/gv/3musketeers.htm">Three Musketeers</a> ", captures are performed only by one of the opponents, but on each turn.  The task of another player is to direct the "musketeers" so that they are on the same vertical or horizontal.  If the goal is not achieved and any of the parties cannot make another move, the ‚Äúmusketeers‚Äù will win: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OzaMmuKBbO8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Playing for the "musketeers", it would be quite possible to get along with the random, but it would be a shame if the computer built the line by chance, having another safe move in reserve.  Bot should play more <a href="">carefully</a> .  The code is as simple as possible. <br><br><div class="spoiler">  <b class="spoiler_title">Choice of safe stroke</b> <div class="spoiler_text"><pre><code class="javascript hljs">CarefulAi.prototype.getMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-comment"><span class="hljs-comment">//       _.chain(Dagaz.AI.generate(ctx, ctx.board)) //      ,    .filter(function(move) { return move.actions.length &gt; 0; }) //    .each(function(move) { //     ,    var b = ctx.board.apply(move); //      if (b.checkGoals(ctx.design, ctx.board.player) &gt;= 0) { //       result.push(move); } }, this); if (result.length &gt; 0) { //        var ix = this.params.rand(0, result.length - 1); return { done: true, move: result[ix], ai: "careful" }; } //     if (this.parent) { //    return this.parent.getMove(ctx); } }</span></span></code> </pre> </div></div><br>  Of course, I don‚Äôt want to say at all that bots would not play these games better using more complex algorithms, but the simplest solutions have their own use (for example, <a href="">randomly</a> can throw bones in those games where this is required).  In addition, simple algorithms have one important advantage.  They work very fast. <br><br><h2>  <b>Games for one</b> </h2><br>  In the case of puzzles, the game AI is not so much a necessity, as a way to ‚Äúfill‚Äù the hand.  In the end, it is assumed that the person will solve them himself!  On the other hand, you can endlessly watch the computer trying to solve the puzzle for you: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QNsRGQBKitg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A simple <a href="">brute-force</a> algorithm (nothing more effective for this class of puzzles has yet been invented).  To ensure that the positions do not repeat, use <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist Hash</a> .  In this video, you can see that single squares walt each other for a long time.  All because the bot considers them as <b>different</b> figures.  It is <a href="https://github.com/GlukKazan/Dagaz/commit/7a9e23bfc6fb39a18620ccfad9688094cbad7efd">easy to</a> fix.  Now the solution is much faster: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l4oi8r747a0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Another moment, which personally made me very nervous, was that before reaching the cherished goal just a couple of steps ‚Äúin a straight line‚Äù, the bot could take a step ‚Äúaside‚Äù and move the dies for half an hour, moving away from the solution further and further .  To solve this problem, I used the time allotted to animate the move.  Over 100 milliseconds, almost imperceptible to humans, you can catch hundreds of positions. <br><br><div class="spoiler">  <b class="spoiler_title">Running forward</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queue = [ ctx.board ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - timestamp &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.AI_FRAME) &amp;&amp; queue.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> board = queue.shift(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moves = cache(x, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board.checkGoals(Dagaz.Model.getDesign(), board.player) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">move</span></span>: traceMove(ctx, board), <span class="hljs-attr"><span class="hljs-attr">ai</span></span>: <span class="hljs-string"><span class="hljs-string">"win"</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; moves.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = board.apply(moves[i]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = getKey(b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(x.cache[k]) &amp;&amp; !isLoop(ctx, b)) { queue.push(b); } } } ...</code> </pre></div></div><br>  Just go through all sorts of moves, while there is time.  If we find a goal - go to it in a straight line!  Although the work of this bot is pretty visual, it does not use the best way to solve the problem.  It would be wiser to spend more time in the beginning to do the animation after the solution has been found.  This is exactly what I did when developing a bot to solve Solitaire Solitaire: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Zoo92gVSHOQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Following the example of <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D0%25B9%25D0%25B1%25D0%25BD%25D0%25B8%25D1%2586,_%25D0%2593%25D0%25BE%25D1%2582%25D1%2584%25D1%2580%25D0%25B8%25D0%25B4_%25D0%2592%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B3%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BC">Leibniz</a> , I solve this problem in the opposite direction, that is, starting with one piece standing in the center of the board and performing the reverse moves, I try to build the original figure.  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D1%2581_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC">From</a> this point of view, the task is reduced to the usual <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D1%2581_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC">search with a return</a> .  Here is a piece of the log: <br><br><div class="spoiler">  <b class="spoiler_title">Some text</b> <div class="spoiler_text">  Goal: 10,16,17,18,24,31 <br>  Current: 22.23 <br>  Current: 22,25,24 <br>  Current: 22,27,24,26 <br>  Current: 22,27,38,26,31 <br>  Current: 24,27,38,26,31,23 <br>  Current: 22,27,38,24,31,25 <br>  Current: 22,27,38,26,29,30 <br>  Current: 22,27,38,26,33,32 <br>  Current: 22,27,38,26,17,24 <br>  Current: 22,27,10,26,17 <br>  Current: 24,27,10,26,17,23 <br>  Current: 22,27,10,24,17,25 <br>  Current: 22,27,10,26,15,16 <br>  Current: 22,27,10,26,19,18 <br>  Current: 22,27,10,26,31,24 <br>  Current: 22,39,24,32 <br>  Current: 22,37,24,32,38 <br>  Current: 22,23,24,32,38,30 <br>  Current: 22,37,26,32,38,25 <br>  Current: 22,37,10,32,38,17 <br>  Current: 22,37,24,30,38,31 <br>  Current: 22,37,24,34,38,33 <br>  Current: 22,37,24,46,38,39 <br>  Current: 22,37,24,18,38,25 <br>  ... <br></div></div><br>  You can see that I interrupt the search after a set of 6 positions is reached (the solitaire game you were looking for consisted of so many pieces).  Of course, this is not the only optimization.  With the naive approach described above, the positions can be repeated.  As always, when it comes to repetition of positions, Zobrist Hash comes to the rescue (in fact, it helps even earlier: before comparing positions elementwise much more efficiently at the beginning, comparing their hashes). <br><br><div class="spoiler">  <b class="spoiler_title">By the way speaking</b> <div class="spoiler_text">  With the debugging of this bot there was a funny incident.  It so happened that I run the developed games, mostly under Firefox, only occasionally checking them on Chrome and IE.  Once, when laying out a release, it turned out that solitaire-ai, working perfectly under IE and FireFox, under Chrome, is ten times slower!  It was not very critical, but very strange. <br><br>  For clarification of a situation it was necessary to use a profiler.  As a result, it turned out that the reason for the brakes in Chrome is this console.log  Even if the console itself is closed.  After I removed the console output, it all worked at about the same speed.  The moral in this story is very simple.  If you need to display a large amount of text (for example, for debugging purposes) and you are going to use console.log for this - think again. <br></div></div><br>  Having pretty much trained on puzzles, you can move on to more complex matters. <br><br><h2>  <b>It stretches</b> </h2><br>  It‚Äôs pretty obvious that more or less serious games, like chess or checkers, would require a more complex AI than anything I wrote above.  The choice, by and large, is small: Minimax, with its " <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D1%258C%25D1%2584%25D0%25B0-%25D0%25B1%25D0%25B5%25D1%2582%25D0%25B0-%25D0%25BE%25D1%2582%25D1%2581%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Alpha-Beta Clipping</a> " and the " <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Monte-Carlo</a> " method (and for <a href="https://habrahabr.ru/post/208580/">that</a> and the <a href="https://habrahabr.ru/post/282522/">other</a> there are wonderful articles on Habr√©).  Each of these approaches is universal.  Each of them has its pros and cons.  Without pretending to complete the review, I will list the first thing that comes to mind. <br><br><ol><li>  To use the minimax method, it is necessary to determine the function that performs the assessment of the position (as a developer of board games with experience, I can see that for some games this can be very difficult). </li><li>  Alpha-beta clipping is especially effective when performing a depth search, or a combined search (width, to some guaranteed depth, for example, 2-3 moves, then, depth, no more than N levels).  This makes it unsuitable in conditions of limited computing resources and, most importantly, if it is necessary to output an answer no later than a specified time (let knowledgeable people correct me if I am mistaken). </li><li>  The effectiveness of alpha-beta clipping can be significantly improved by pre-ranking the moves by their quality (as I will say below, when using the Monte-Carlo method, such heuristics are also useful). </li><li>  When using the minimax method, the depth search cannot be stopped at an arbitrary location.  When detecting forced moves (in Chess, shahs and taking figures are such), the search should be continued until a more ‚Äúcalm‚Äù position appears. </li><li>  When using the Monte Carlo method, the simulation is performed to the terminal position (the victory of one of the players or the recognition of a draw).  In games with a long party duration, this can be a problem. </li></ol><br>  Taking into account all these considerations, I decided, without discarding the minimax method, finally, in the current iteration, to focus on the <a href="">Monte Carlo</a> method (of course, having selected the tasks suitable for it).  As one of the games, to test the operation of the algorithm, I chose " <a href="https://glukkazan.github.io/elimination/kono.htm">Four-Field Kono</a> " - a children's game originally from Korea. <br><br>  This is a simple taking game, the goal of which is to deprive the opponent of all his pieces or the possibility of a move.  Taking in Kono is quite peculiar.  In order to pick up an opponent's piece, you must land on it by jumping one of your pieces over the other (thanks to this, you can start the game, despite the fact that in the initial position the board is full of pieces).  Here is the debug output when calculating one of the moves (time limit ~ 3 seconds): <br><br><div class="spoiler">  <b class="spoiler_title">Debug log</b> <div class="spoiler_text">  Player: Black <br>  d2 - c2 <br>  Goal: 1;  Deep: 26;  Player: 1;  P1: a2;  P2: a4, a3, b3, c3, c2 <br>  Goal: 1;  Deep: 20;  Player: 1;  P1: a1;  P2: a4, b4, c4, d4, b3 <br>  Goal: 1;  Deep: 16;  Player: 1;  P1: b1;  P2: a4, b4, d4, a3, c3, d3 <br>  Goal: 1;  Deep: 34;  Player: 1;  P1: c2;  P2: a4, b4, d4, b3 <br>  Goal: 1;  Deep: 22;  Player: 1;  P1: c3;  P2: a3, b3, d3, b2, d2 <br>  Goal: 1;  Deep: 24;  Player: 1;  P1: b1;  P2: a4, b4, c3, b2, c2 <br>  Goal: 1;  Deep: 30;  Player: 1;  P1: d2;  P2: a4, c4, b3, b2 <br>  Goal: 1;  Deep: 12;  Player: 1;  P1: a1;  P2: a4, b4, c4, b3, d3, d2 <br>  Goal: 1;  Deep: 34;  Player: 1;  P1: b1;  P2: a4, b4, a3, c1 <br>  Goal: 1;  Deep: 60;  Player: 1;  P1: d2;  P2: a4, b4, b3, b1, c1 <br>  Goal: 1;  Deep: 34;  Player: 1;  P1: d2;  P2: a3, c2, a1, b1 <br>  Goal: 1;  Deep: 36;  Player: 1;  P1: b1;  P2: a4, d4, a3, d3, c2 <br>  Goal: 1;  Deep: 32;  Player: 1;  P1: c1;  P2: b4, a3, c3, a2, c2 <br>  Goal: 1;  Deep: 24;  Player: 1;  P1: c2;  P2: b3, b2 <br>  Goal: 1;  Deep: 70;  Player: 1;  P1: a1;  P2: b3, b2 <br>  Goal: 1;  Deep: 38;  Player: 1;  P1: b1;  P2: a4, b4, c3, a2, b2 <br>  Goal: 1;  Deep: 28;  Player: 1;  P1: a1;  P2: a4, d4, b3, c3, c2 <br>  Goal: 1;  Deep: 34;  Player: 1;  P1: b2;  P2: a4, b4, d4, a3, d3 <br>  Goal: 1;  Deep: 20;  Player: 1;  P1: c1;  P2: a4, b4, c4, d4, a3, c3 <br>  Goal: 1;  Deep: 18;  Player: 1;  P1: c2;  P2: a4, c4, a3, c3, b2, d1 <br>  Goal: 1;  Deep: 28;  Player: 1;  P1: a2;  P2: d4, c3, d3, c2 <br>  Goal: 1;  Deep: 34;  Player: 1;  P1: d1;  P2: b4, a3, b3, d3, a2 <br>  Goal: 1;  Deep: 30;  Player: 1;  P1: b1;  P2: a4, a3, b3, c3, b2, c2 <br>  Goal: 1;  Deep: 36;  Player: 1;  P1: a2;  P2: b4, a3, b3 <br>  Goal: 1;  Deep: 24;  Player: 1;  P1: c1;  P2: b4, a3, b3, d3 <br>  Goal: 1;  Deep: 36;  Player: 1;  P1: a1;  P2: a4, c3, a2, c2 <br>  Goal: 1;  Deep: 22;  Player: 1;  P1: c1;  P2: a4, b4, c4, d4, b2, c2 <br>  Goal: 1;  Deep: 38;  Player: 1;  P1: c3;  P2: a4, d4, b3, b2, c2 <br>  Goal: 1;  Deep: 46;  Player: 1;  P1: a1;  P2: a4, b4, c4, b2, c2 <br>  Goal: 1;  Deep: 38;  Player: 1;  P1: a1;  P2: a4, b4, d3, c2, d2 <br>  Goal: 1;  Deep: 28;  Player: 1;  P1: b1;  P2: b4, c4, d4, c3, a2 <br>  Goal: 1;  Deep: 20;  Player: 1;  P1: d2;  P2: a4, b4, c4, b3, c2 <br>  Goal: 1;  Deep: 20;  Player: 1;  P1: c1;  P2: a4, b3, c3, b2 <br>  Goal: 1;  Deep: 48;  Player: 1;  P1: d1;  P2: a3, a2, b2 <br>  Win = 5;  All = 11;  Move = d3 - c3 <br>  Win = 6;  All = 12;  Move = d3 - d2 <br>  Win = 13;  All = 18;  Move = a3 - b3 <br>  Win = 7;  All = 13;  Move = c4 - c3 <br>  Win = 3;  All = 8;  Move = b4 - b3 <br>  Player: White <br>  a3 - b3 <br></div></div><br>  Having such a conclusion before your eyes, you can evaluate the correctness of the algorithm.  The first thing you should pay attention to is whether the ‚Äúgoals‚Äù set by the algorithm correspond to the player‚Äôs goals according to the rules of the game.  In the process of debugging, I had a couple of situations when the algorithm was trying to look for ‚Äúnot that‚Äù.  If everything is normal with goals, we look at the assessment of moves (Win is the number of victories fixed, All is the total number of games played).  UCT out of the box works, in principle, not bad, but I made a couple of changes: <br><br><ol><li>  Restricted search depth (100 by default) </li><li>  Added heuristics of moves </li></ol><br><div class="spoiler">  <b class="spoiler_title">For Kono, the heuristic is as follows</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.actions.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board.getPiece(pos) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { r += <span class="hljs-number"><span class="hljs-number">9</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  That is, captures are 10 times more preferable than ‚Äúquiet‚Äù moves.  It should be noted here that, in contrast to the minimax method, it is useless to sort the moves in Monte Carlo (according to their heuristics).  It is necessary to build an algorithm so that the probability of choosing a move is proportional to its heuristic estimate.  Both innovations had a favorable effect on the statistics of wins / games played for Kono and I took on other games. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DxmMkTZKroI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  There are no takes in this <a href="http://www.di.fc.ul.pt/~jpn/gv/dodgem.htm">game</a> .  To win, you need to hold your pieces through the entire field, then remove them from the board (this is considered to be a move).  You can only move forward, left and right (orthogonal).  The opponent's figures move perpendicular to the movement and interfere with the passage.  It is impossible to lock the opponent's pieces!  With all the seeming simplicity, the game is quite deep.  Just try to play it with a <a href="https://glukkazan.github.io/races/dodgem-5x5.htm">computer</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Heuristics pretty obvious</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; move.actions.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((move.actions[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (move.actions[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = move.actions[i][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - move.actions[i][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((board.player == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (d &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span>)) { r += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((board.player == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (d == <span class="hljs-number"><span class="hljs-number">1</span></span>)) { r += <span class="hljs-number"><span class="hljs-number">10</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((move.actions[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (move.actions[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { r += <span class="hljs-number"><span class="hljs-number">5</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre><br>  If the figure moves forward, not sideways, we consider the move preferred. <br></div></div><br>  In terms of debugging, the game gave information about the behavior of the algorithm on large boards.  All estimates of the number of victories for moves instantly zeroed out.  The algorithm simply did not have time to find a single victory, as a result of which he began to make the first available moves (not at all the best).  Increasing the search depth did not help much - three seconds were clearly not enough for a set of "critical" mass of games played in the simulation phase.  I had to consider heuristics when choosing a move: <br><br><div class="spoiler">  <b class="spoiler_title">Changes in UCT</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UctAi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params = params; ... if (_.isUndefined(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.UCT_COEFF)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.UCT_COEFF = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>); } } UctAi.prototype.getMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generate(ctx, ctx.board); ... var mx = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ctx.childs.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.childs[i].win &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { u = ctx.childs[i].win / ctx.childs[i].all; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> h = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.heuristic(ctx.design, ctx.board, ctx.childs[i].move); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.UCT_WEIGHT * u + (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.UCT_WEIGHT) * h; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mx === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (w &gt; mx)) { mx = w; ctx.result = ctx.childs[i].move; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Weight: "</span></span> + w + <span class="hljs-string"><span class="hljs-string">"; Win = "</span></span> + ctx.childs[i].win + <span class="hljs-string"><span class="hljs-string">"; All = "</span></span> + ctx.childs[i].all + <span class="hljs-string"><span class="hljs-string">"; Move = "</span></span> + ctx.childs[i].move.toString()); } ... }</code> </pre></div></div><br>  Heuristics moves are certainly worse than what UCT gives, but, in not very difficult games, they let the computer live to the point where UCT can work.  The weights are chosen in such a way that heuristics have a significant impact only in cases where the Monte Carlo algorithm does not work. <br><br>  The next game was <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a> .  I already wrote about it <a href="https://geektimes.ru/post/263072/">before</a> .  This is not to say that the Monte Carlo method works quite well here.  The program makes quite adequate moves, but if you set a goal, to win it is not at all difficult: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oK3rROwrm9M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The main reason is that I could not come up with a simple and adequate heuristics for this game.  As a result, the program makes its moves ‚Äúby touch‚Äù.  If there are enough computing resources, this would not be a problem (the Monte-Carlo algorithm is suitable for this game as it should be), but 3 seconds of calculating the course in one stream is the maximum that I can afford (by the way, UCT can be very good scaled when there are multiple streams). <br><br>  Of course, the Monte Carlo method, as it is now implemented in me, is not suitable for all games.  I'm not going to dwell on it.  For games like Chess, perhaps minimax will work better.  I will still have the opportunity to investigate this question.  Also, I have some thoughts about improving the current implementation of UCT.  Let's see what happens better. <br></div><p>Source: <a href="https://habr.com/ru/post/330320/">https://habr.com/ru/post/330320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330310/index.html">Overview of VR / AR Google I / O 2017</a></li>
<li><a href="../330312/index.html">The best presentations at the conference United Dev Conf 2017</a></li>
<li><a href="../330314/index.html">12 hours in the skin of the Android developer through the eyes of the JS developer</a></li>
<li><a href="../330316/index.html">Another use of blockchains: Smart contracts</a></li>
<li><a href="../330318/index.html">Google I / O ride: how, why and how much</a></li>
<li><a href="../330322/index.html">Creating a third-party VR game</a></li>
<li><a href="../330324/index.html">Yii 2.0.12</a></li>
<li><a href="../330326/index.html">Five Docker Utilities You Should Know</a></li>
<li><a href="../330328/index.html">Android mitap at Badoo office on June 17</a></li>
<li><a href="../330332/index.html">15 best recipes for Smart Home with ioBroker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>