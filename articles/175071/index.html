<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>BYOD in a container: we virtualize Android. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the story about the technology of Android virtualization, made in Parallels Labs by a group of students of the Department of MIT of the Aca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>BYOD in a container: we virtualize Android. Part two</h1><div class="post__text post__text-html js-mediator-article">  I continue the story about the technology of Android virtualization, made in <a href="http://www.parallels.com/ru/education">Parallels Labs</a> by a group of students of the <a href="http://mit.spbau.ru/">Department of MIT of the Academic University of St. Petersburg</a> as part of the master's work.  <a href="http://habrahabr.ru/post/174211/">In yesterday's article,</a> we looked at the general concept of Android virtualization, which allows it.  The task of today's post is to deal with the virtualization of telephony, sound and user input systems. <br><br><a name="habracut"></a><br><br>  Audio and telephony were virtualized in user space.  The general idea of ‚Äã‚Äãsuch virtualization is to implement a proxy (server and client) at the level of a hardware independent interface in the Android stack.  The proxy server is placed in a separate container with the original software stack of the operating system for performing client requests on physical devices.  A proxy client is placed in each container with an Android user. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Audio device </h3><br><br>  A typical scenario for using an audio device when running multiple Android would be listening to music in one of the operating systems and playing the sound of a game running in another.  The user probably would like to hear the sound of all running Android, but in fact the physical sound device is not designed for this.  When you try to use it, the OS reports an error and sometimes cannot play a sound until the next reboot.  Audio unit virtualization should provide the ability to simultaneously listen to the sound of all Android. <br><br>  You also need to implement interaction with the telephony service so that, during a telephone conversation, the audio device records and transmits the voice of the user to the cellular network and reproduces the voice of the interlocutor received from the cellular network. <br><br><h6>  Proxy client </h6><br><br>  AudioHardwareInterface interface is a replaceable hardware independent interface to the sound device, as we are <a href="http://www.kandroid.org/online-pdk/guide/audio.html">told about by the</a> Android Platform Developer's Guide.  In addition, it is the lowest-level and simplest hardware independent audio interface.  In fact, it is a stream for recording sound to play.  In addition to the audio stream played by Android, in its implementation you can get other useful information. <br><br>  It would be possible to perform a substitution at a higher level.  For example, substitute part of the Android audio framework.  But the analysis showed that the audio framework is much more complicated than the AudioHardwareInterface.  Therefore, in the case of audio device virtualization, the proxy client is an implementation of AudioHardwareInterface. <br><br>  The main responsibility of the proxy client is to send the Android audio stream and other useful information to the proxy server, which will play all Android audio streams.  Audio streams are played in uncompressed form, so transferring them using copying to a proxy server can result in noticeable overhead.  We avoid them by using inter-container shared memory to transfer audio streams.  Information and control messages are transmitted using the mechanism of intercontainer messaging. <br><br><h6>  Proxy server </h6><br><br>  The main task of the proxy server is to mix the audio streams received from the proxy clients and play the resulting audio stream on the physical audio device.  To ensure maximum portability of the proxy server, sound mixing and playback should be carried out independently of the device.  The Android audio framework interfaces are hardware independent.  In addition, in the audio framework already laid the possibility of mixing audio streams.  Android‚Äôs audio framework does not provide access to its mixer from the outside, so using it requires either embedding it into the audio framework or using the mixer implicitly.  The architecture of our sound virtualization solution is shown in the figure. <br><br><img src="https://habrastorage.org/storage2/bf5/63f/e2a/bf563fe2a2c35900f9305be4b791d470.jpg"><br><br>  The simplest solution that allows you to mix and play audio in Android is to use audio classes from the Android SDK.  In our solution, the audio stream of each user is reproduced by a separate object of the AudioTrack class from the Android SDK.  Using classes allows the Android audio framework to mix all the audio streams that are played back and sends the resulting audio stream to a device‚Äôs speaker or headphone output. <br><br>  It should be noted that the classes from the Android SDK are written in Java, and their use requires the launch of the Dalvik JVM.  Running Dalvik in the case of Android means launching the entire OS due to the use of a mechanism like bootstrapping.  Here we have a problem: running Android takes 200-250 MB of RAM and consumes computing resources.  This is an inadmissible overhead for the task of reproducing and mixing audio streams, but in this paper we managed to avoid them.  In fact, we are not using Java classes from the Android SDK, but their native backend written in C ++.  That is why the launch of Dalvik, which means that the launch of a full Android container is not required. <br><br>  Fully native applications, such as a proxy server, cannot be registered in the Android rights monitoring system.  At the same time, the services accessed by the proxy server silently ignored requests due to lack of rights.  Everything was decided by removing the rights checks in these services.  We did this peace of mind trick, since this deletion does not affect security.  In the container with the proxy server, foreign applications are never launched, it is completely under the control of virtualization technology. <br><br><h6>  Sound level control </h6><br><br>  The user probably wants the sound volume of different Android to be adjusted.  It turned out that in Android 2.x there is no abstraction of a hardware mixer, i.e.  mixing is done through the CPU.  Since the mixing of audio streams inside each Android is completely independent (there is no shared shared hardware mixer), the overall volume level of each Android can be configured in Android itself.  The proxy server simply does not make changes to the sound levels of each OS, and the user adjusts the sound level of each Android in their user interface, as if there was no virtualization on the phone. <br><br><h6>  Sound output devices </h6><br><br>  Mobile devices typically have multiple audio output devices.  For example, a large speaker, handset, headphones, bluetooth headset.  Launched OSs may simultaneously require playback of their audio streams on different output devices.  In some cases, their requirements will be incompatible.  For example, it does not make sense to play one sound on a large speaker, and the other in headphones or a tube.  It will also be strange if during a call in the handset not only the interlocutor's voice is heard, but also the music playing before the call. <br><br>  Therefore, a policy of routing audio streams to various output devices was developed, which implements the user's ‚Äúleast surprise‚Äù strategy.  As part of this strategy, in particular, it is sometimes required to simulate the playback of Android sound.  To do this, the proxy client is switched to a dummy playback mode, in which synchronous functions are blocked for the duration of the audio stream being played, so Android thinks that it played the sound, although in fact it was not sent to the proxy server for playback. <br><br><h6>  Interaction with telephony service </h6><br><br>  In the proxy client, which is an implementation of AudioHardwareInterface, we can get information about whether the phone is currently on the phone or not.  If the conversation is on, then you need to set up the audio subsystem for recording and reproducing voice and interacting with the telephony service.  In fact, all you have to do is to translate the AudioHardwareInterface implementation supplied with the device into the call mode by calling the setMode method (MODE_IN_CALL) and set the sound routing to the handset, otherwise the interlocutor‚Äôs voice will be played by the current audio output device.  Thus, the device provider is responsible for implementing the interaction with the telephony service. <br><br><h3>  Telephony </h3><br><br>  The most interesting and difficult was the technology of dispatching telephone calls between containers.  The software control stack for accessing mobile networks on Android contains the following components: <br><br>  1. API com.android.internal.telephony package. <br>  2. The rild daemon, multiplexing user application requests in mobile network access equipment. <br>  3. Proprietary library of access to equipment. <br>  4. GSM modem driver. <br><br>  The interface between components (2) and (3) is documented and is called the Radio Interface Layer, or RIL.  It is described in the development / pdk / docs / porting / telephony.jd file. <br><br>  For RIL virtualization, I had to solve the following problems: <br>  Proprietary RIL implementations in various ‚ÄúAndroids‚Äù are trying to re-initialize the equipment; <br>  It is not clear which of the ‚ÄúAndroids‚Äù should receive incoming calls and SMS; <br>  It is not clear how to manage calls and SMS from from different "Androids". <br><br>  It should also be noted here that the implementation of the GSM modem drivers differs significantly on different devices, so the existence of a universal solution for virtualizing this device in the kernel is impossible.  In addition, the proprietary RIL library uses an undocumented protocol to interact with a GSM modem, which is an obstacle to its virtualization, even for a specific smartphone model. <br><br><h6>  Client part </h6><br><br>  The specific implementation of the RIL library on the phone is unknown, but its interface is known.  We have created a level of abstraction in the form of a virtual RIL proxy and RIL client.  On the client side, the rild daemon instead of the original RIL library loads the RIL client implemented by us.  RIL-client, intercepting calls to the interface, transmits calls through the mechanism of inter-container interaction RIL-proxy, which in turn makes the main interface virtualization, and uses the original RIL library to access telephony. <br><br><h6>  Server part </h6><br><br>  The server part is implemented as a single-threaded application that loads the proprietary implementation of RIL and receives messages from proxy clients running in user containers using the inter-container interaction mechanism.  In the OnRequestComplete handler, we do not know the type of request, but the method of packaging the response of a proprietary RIL implementation depends on it, so when a request arrives, the server remembers the token match the request number in order to call the response marshaller in this handler. The RIL proxy server should handle the situation when clients receive requests with identical tokens, so when a new request arrives, the proxy server looks at the list of request tokens processed by the proprietary RIL library, and if it turns out,  that the request with such a token is now being processed, the server generates a new token for the incoming request.  Thus, the proxy server for all incoming requests stores their real and dummy tokens. <br><br><h6>  Request Routing Policy </h6><br><br>  For each type of requests coming to OnRequest, a processing policy is defined.  Currently three policies are defined: <br><ul><li>  Unconditional blocking of the request.  The policy is set for all requests that have never been encountered during the development of a proxy server. </li><li>  Unconditional request transfer to a proprietary library.  The policy applies to all requests that do not change the state of the proprietary library and GSM modem. </li><li>  Request transfer from active container to proprietary library.  Used for requests related to sending SMS and making calls. </li></ul><br><br>  For each type of asynchronous notification, routing policies are also defined: <br><ul><li>  Unconditional blocking notification. </li><li>  Routing to the active container.  The policy is set for notifications related to the acceptance of SMS and calls. </li><li>  Routing to all containers.  For service notifications "iron" - for example, about a change in the signal level of the cellular network </li></ul><br><br><h3>  Input subsystem </h3><br><br>  Android uses the evdev subsystem to collect kernel input events.  For each process that opens the / dev / input / eventX file, this driver creates a queue of events from the input subsystem kernel. <br><br><img src="https://habrastorage.org/storage2/322/838/7c3/3228387c3c400b6701943db87cb78cc8.jpg"><br><br>  Thus, incoming input events can be delivered to all containers.  The evdev_event () function is an input event manager, so in order to prevent the delivery of input messages to inactive containers, this function has been modified so that all incoming input events are added only to the process queues of the active container. <br><br><h3>  Something about testing </h3><br><br>  After we managed to launch our solution on smartphones, we did a series of experiments in order to quantify the characteristics of our solution.  I must say that we did not work on optimization - this work is still to be done. <br><br>  The main goals of testing were: <br><ul><li>  demonstration of the readiness of the developed technology; </li><li>  measuring memory consumption on virtualized phones; </li><li>  definition of energy consumption of the developed technology. </li></ul><br><br>  Testing was conducted on a Samsung Galaxy S II smartphone using the following smartphone usage scenarios: <br><br>  1. Simple (turn on the phone and do nothing with it); <br>  2. Playing music with backlight on; <br>  3. Angry Birds (where can I go without them?) And simultaneous playing of music. <br><br>  Test scripts were executed on three configurations: <br>  1. Original CyanogenMod 7 for Samsung Galaxy S II (1); <br>  2. One container with CyanogenMod 7 (2); <br>  3. Two containers with CyanogenMod 7: music was played in one container, the other was playing (3). <br><br>  In each test run, the following parameters were measured: <br>  1. The amount of free memory and the size of the cache file system (for information / proc / meminfo); <br>  2. Battery charge (according to / sys / class / power_supply / battery / capacity. <br><br>  Each test run lasted 30 minutes, measurements were made with a frequency of 2 c.  Here's what we got: <br><br><img src="https://habrastorage.org/storage2/280/f13/ad3/280f13ad3aa917eb2b94feab1905096c.jpg"><br><br>  It may seem strange that memory costs in the case of containers are less than in real environments.  The exact cause has not been established (we have not tried to figure out this issue so far), but the same effect is also observed in the Cells project, which they described <a href="http://www.cs.columbia.edu/~cdall/pubs/Cells-SOSP-final.pdf">in their article</a> . <br><br>  Testing showed the acceptability of the developed solutions and demonstrated insignificant consumption of the memory and the smartphone's battery by the developed technology except for the case (the last row of the table), in which the increase in energy consumption by the two containers almost doubled compared to the unmodified Android.  Currently, work is underway to clarify the reasons for this behavior. <br><br>  As can be seen from the values ‚Äã‚Äãof memory consumption, when launching the second container, it increases by more than 2 times, which is an obstacle to launching several containers on one smartphone: experiments show that Google Nexus S, which has 380 MB, cannot start more than one container without activation of the paging file. <br><br><h3>  Conclusion </h3><br><br>  Around the mobile devices now generates a large part of the technological news.  The master's (or graduate, as usual) project of a group of students showed the viability of virtualization technology on mobile devices and gave an idea of ‚Äã‚Äãhow this technology can be used to create products. <br><br>  Some interesting facts about the creation of our solution: <br><ul><li>  There are three main developers of the project, two of whom were students of the Academic University in St. Petersburg at the time of their work, and one was in charge of a graduation project; </li><li>  The project lasted 11 months; </li><li>  The project was assisted by engineers from the Moscow office of Parallels; </li><li>  The project involved three Android devices. </li></ul><br><br>  If something important is left behind the scenes, ask questions in the comments.  I will try to answer them. </div><p>Source: <a href="https://habr.com/ru/post/175071/">https://habr.com/ru/post/175071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175057/index.html">Humble Bundle with Android Games</a></li>
<li><a href="../175061/index.html">Mathematical proof in 140 characters</a></li>
<li><a href="../175063/index.html">Diff Displays: highlight changes on the second / third display in the background</a></li>
<li><a href="../175065/index.html">And what is happening in Dyatkovo or the all-seeing eye of the governor</a></li>
<li><a href="../175069/index.html">The romance of the north: satellite posts at base stations, a shovel and an incredible amount of snow</a></li>
<li><a href="../175073/index.html">Evernote has been speaking Russian for 4 years!</a></li>
<li><a href="../175075/index.html">Squeezing maximum performance out of the keyboard</a></li>
<li><a href="../175077/index.html">The Ministry of Communications prepared SORM equipment requirements for Internet providers</a></li>
<li><a href="../175081/index.html">How much is the active user?</a></li>
<li><a href="../175083/index.html">WEB DESIGN: Personalization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>