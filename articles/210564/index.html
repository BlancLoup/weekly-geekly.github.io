<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>User Timing API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation by Alex Danilo‚Äôs article about the User Timing API published on January 21, 2014. 

 High performance of web applications is cru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>User Timing API</h1><div class="post__text post__text-html js-mediator-article">  <i>This is a translation by Alex Danilo‚Äôs <a href="http://www.html5rocks.com/en/tutorials/webperformance/usertiming/">article</a> about the User Timing API published on January 21, 2014.</i> <br><br>  High performance of web applications is crucial to achieve a good user experience.  While web applications are becoming more complex, an understanding of the impact of productivity is vital to creating a competitive user experience.  Over the past few years, various APIs have appeared in browsers to analyze network performance, load time, etc., but they do not provide the necessary information with sufficient flexibility to find problems that slow down an application.  Using the <a href="http://www.w3.org/TR/user-timing/">User Timing API</a> provides a mechanism to determine which part of your application is the slowest.  This article will show you how to work with the User Timing API and examples of its use. <a name="habracut"></a><br><br><h5>  You cannot optimize what you cannot measure. </h5><br>  The first step in speeding up a web application is to understand where time losses occur.  Measuring the time spent on the execution of individual parts of the Javascript code is an ideal way to determine hot spots, and this is the first step in understanding how to improve performance.  Fortunately, the <a href="http://www.w3.org/TR/user-timing/">User Timing API</a> provides a way to embed API calls in different parts of the code and then obtain detailed information about the execution time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  High Resolution time and 'now ()' </h5><br>  Accuracy is the basis of accurate time measurement  There was no time to be content with millisecond accuracy of measurement, but the development of a site capable of being rendered at a speed of 60 FPS means that each frame must be rendered within 16 ms.  That is, millisecond accuracy is not enough for a qualitative analysis.  Thus, <a href="http://www.w3.org/TR/hr-time/">High Resolution Time</a> was introduced, a new type of time measurement built into modern browsers.  High Resolution Time provides timestamps in floating-point format, which allows measurements to be made to the microsecond level ‚Äî a thousand times better than before. <br>  To get the current time in the web application, call the ' <a href="http://www.w3.org/TR/hr-time/">now ()</a> ' method, <a href="http://www.w3.org/TR/hr-time/">extending</a> the <a href="http://www.w3.org/TR/navigation-timing/">Performance</a> interface: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myTime = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.now();</code> </pre> <br>  There is another interface, <a href="http://www.w3.org/TR/navigation-timing/">PerformanceTiming</a> , which provides additional information on how the application is loaded.  The 'now ()' method returns the time elapsed since the <a href="http://www.w3.org/TR/navigation-timing/">navigationStart</a> event occurred in PerformanceTiming. <br><br><h5>  Type DOMHighResTimeStamp </h5><br>  When trying to profile web applications in the past, you would most likely have to deal with something like Date.now (), which <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html">DOMTimeStamp</a> returns.  DOMTimeStamp is an integer number of milliseconds.  To ensure higher accuracy, a new type of <a href="http://www.w3.org/TR/hr-time/">DOMHighResTimeStamp</a> was introduced.  It is a floating point type, also representing time in milliseconds.  But, due to its type, the value can be fractional parts of milliseconds and makes it possible to get an accuracy of up to one thousandth of a millisecond. <br><br><h5>  User Timing Interface </h5><br>  Now that you have High Resolution time at your disposal, you can use the User Timing interface to get information.  The User Timing interface provides functions that allow you to call methods in various places of our application, leaving breadcrumbs like Hansel and Gretel to track where time costs occur. <br><br><h5>  Using 'mark ()' </h5><br>  The ' <a href="http://www.w3.org/TR/user-timing/">mark ()</a> ' method is the primary tool in the time analysis toolkit.  Mark () allows you to save a timestamp.  Especially useful is the ability to name timestamps. <br><br>  Calling mark () in different parts of the code will determine how long it took to reach this mark. <br>  The specification provides a number of predefined labels that may be useful - 'mark_fully_loaded', 'mark_fully_visible', 'mark_above_the_fold' ‚Äù, etc. <br>  For example, you can set a label to determine when the application is fully loaded using the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.mark(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  Setting named labels in a web application will help collect more runtime information to analyze current time costs. <br><br><h5>  Calculate measurements with 'measure ()' </h5><br>  Once the timestamps are set, you need to measure the time spent executing the application between them.  To do this, use the ' <a href="http://www.w3.org/TR/user-timing/">measure ()</a> ' method.  It is also able to calculate the elapsed time between timestamps and any known event in the PerformanceTiming interface. <br>  For example, you can measure the time between a full DOM load and the moment when your application is fully loaded: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.measure(<span class="hljs-string"><span class="hljs-string">'measure_load_from_dom'</span></span>, <span class="hljs-string"><span class="hljs-string">'domComplete'</span></span>, <span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  <i>Note: in this example, the event name " <a href="http://www.w3.org/TR/navigation-timing/">domComplete</a> " is <a href="http://www.w3.org/TR/navigation-timing/">passed</a> from the <a href="http://www.w3.org/TR/navigation-timing/">PerformanceTiming</a> interface.</i> <br><br>  Calling measure () keeps the measurement result available for future reference.  Keeping the data during the work, the application remains operable and the data can be obtained later, after the end of the work. <br><br><h5>  Removing tags using 'clearMarks ()' </h5><br>  Sometimes it is useful to be able to get rid of tags that are already created.  For example, it may be necessary when conducting batch launches of an application as part of the profiling, when it is necessary to nullify the results before each launch.  With the call ' <a href="http://www.w3.org/TR/user-timing/">clearMarks ()'</a> it is easy to get rid of any tags that have been set. <br>  This code will remove all existing marks: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.clearMarks();</code> </pre><br>  Of course, there are some situations in which you should not delete all timestamps.  If you need to get rid of specific tags, you just need to pass the name of the mark you want to delete.  For example, the code below will remove the mark set in the first example, leaving all the rest: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.peformance.clearMarks(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  It may also be necessary to remove previously made measurements, so that there is a corresponding 'clearMeasures ()' method.  The principle of operation is similar to clearMarks (), but instead of marks, measurements are deleted.  For example, the following code will remove the measurements set in measure () in the previous example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.clearMeasures(<span class="hljs-string"><span class="hljs-string">'measure_load_from_dom'</span></span>);</code> </pre><br>  If you need to delete all the dimensions, simply call clearMeasures () with no arguments. <br><br><h5>  Data acquisition </h5><br>  The ability to set marks and measurements is useful, but at some point it will be necessary to obtain data for subsequent analysis.  This is also easy to do - all you need is to use the <a href="http://www.w3.org/TR/performance-timeline/">PerformanceTimeline</a> interface. <br><br>  For example, the method ' <a href="http://www.w3.org/TR/performance-timeline/">getEntriesByType ()</a> ' allows you to get all the timestamps or measurements in the form of a list, for later sorting and retrieving information.  The list is compiled in chronological order, so that the labels are presented in the order in which they appear in the web application. <br>  The following code returns a list of all the marks that exist in the application: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'mark'</span></span>);</code> </pre><br>  While the following code, returns a list of all dimensions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'measure'</span></span>);</code> </pre><br>  You can also get a list of named marks.  For example, the following code will return a list with one entry containing the mark_fully_loaded mark in the startTime property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByName(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br><h5>  Testing an XHR request (example) </h5><br>  Now, after a brief introduction to the User Timing API, you can use it to analyze the duration of an <a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a> in the application. <br><br>  First, you need to change all <a href="http://www.w3.org/TR/XMLHttpRequest/">send ()</a> requests to trigger a timestamp and replace success callbacks with a function call that sets up another stamp and then generates a measurement of the duration of the request. <br><br>  Normal XMLHttpRequest will look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myReq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); myReq.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); myReq.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ do_something(e.responseText); } myReq.send();</code> </pre><br>  For the code of the example, you should add a global counter to track the number of requests, and also use it to store measurements for each perfect request: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reqCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myReq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); myReq.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); myReq.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.mark(<span class="hljs-string"><span class="hljs-string">'mark_end_xhr'</span></span>); reqCount++; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.measure(<span class="hljs-string"><span class="hljs-string">'measure_xhr_'</span></span> + reqCnt, <span class="hljs-string"><span class="hljs-string">'mark_start_xhr'</span></span>, <span class="hljs-string"><span class="hljs-string">'mark_end_xhr'</span></span>); do_something(e.responseText); }</code> </pre><br>  This code generates dimensions with unique names for each XMLHttpRequest sent.  It is assumed that requests are executed sequentially - the code for parallel requests will be a little more complicated.  This will serve as an exercise for the reader. <br><br>  After the web application has made all the requests, you can output them to the console with the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'measure'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = items[i]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'XHR '</span></span> + req.name + <span class="hljs-string"><span class="hljs-string">' took '</span></span> + req.duration + <span class="hljs-string"><span class="hljs-string">'ms'</span></span>); }</code> </pre><br><h5>  Conclusion </h5><br>  The User Timing API provides many excellent tools applicable to any aspect of your web application.  Reducing the number of ‚Äúhot spots‚Äù in an application can be easily achieved by using API calls throughout the application and post-processing the data to get a picture of the delays.  But what if the browser does not support this API?  This is not a problem, there is a <a href="https://gist.github.com/pmeenan/5902672">good emulation</a> that is able to pass the test <a href="http://www.webpagetest.org/">webpagetest.org</a> .  So is it worth the wait?  You should try the User Timing API right now, and a new opportunity will appear to achieve greater performance, and your users will say thank you. </div><p>Source: <a href="https://habr.com/ru/post/210564/">https://habr.com/ru/post/210564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210546/index.html">Processing incoming requests, the experience of a small web studio</a></li>
<li><a href="../210548/index.html">TorrentMonitor and hello again</a></li>
<li><a href="../210554/index.html">Video about how the collider works and how it works</a></li>
<li><a href="../210558/index.html">List of DOM rendering optimizations implemented at the Javascript framework level</a></li>
<li><a href="../210562/index.html">Designer review Android 4.4 KitKat. Part 2</a></li>
<li><a href="../210570/index.html">Stock market: How are exchanges organized and why are they needed?</a></li>
<li><a href="../210572/index.html">Why did I change jobs?</a></li>
<li><a href="../210574/index.html">Gaming community in terms of independent game developer</a></li>
<li><a href="../210576/index.html">UX-strategy in practice. Part 1 - Framework</a></li>
<li><a href="../210578/index.html">Photo report of the construction process of the data center "DataPro Tver". Part I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>