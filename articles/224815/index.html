<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scroll Views inside Scroll Views</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I want to present an OLEContainerScrollView , which is a descendant of UIScrollView and allows you to add several scroll views, table...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scroll Views inside Scroll Views</h1><div class="post__text post__text-html js-mediator-article">  In this article, I want to present an <a href="https://github.com/ole/OLEContainerScrollView"><i>OLEContainerScrollView</i></a> , which is a descendant of <i>UIScrollView</i> and allows you to add several scroll views, tables ( <i>UITableView</i> ) or collections ( <i>UICollectionView</i> ) into one container. <br><br><h4>  Possible use </h4><br>  You can use the <i>OLEContainerScrollView</i> to achieve the following goals: <br><ul><li>  Placing several scroll views (or tables, or collections) one below the other so that their usual behavior during scrolling does not suffer.  In the case of tables or collections, we are talking about preserving the functionality of the cell reuse mechanism. </li><li>  Transform one complex <i>UITableViewDataSource</i> or <i>UICollectionViewDataSource</i> into several simple data sources by splitting a table or collections, consisting of several sections, into several single-section tables or collections, arranged one after another. </li><li>  Adding a header or footer ( <i>header</i> or <i>footer</i> ) above or below the collection without having to manage their markup.  In this case, it will be a simple <i>UIScrollViews</i> or <i>UIViews</i> . </li></ul><a name="habracut"></a><br><h4>  Reuse cells in tables and collections </h4><br>  Before considering the implementation of my class, let's take a look at how tables or collections work at all.  Both classes, <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UITableView_Class/Reference/Reference.html"><i>UITableView</i></a> and <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionView_class/Reference/Reference.html"><i>UICollectionView</i></a> , are descendants of <a href="https://developer.apple.com/Library/ios/documentation/UIKit/Reference/UIScrollView_Class/Reference/UIScrollView.html"><i>UIScrollView</i></a> and behave similarly.  However, the key difference is that the tables and collections <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/Reference/Reference.html">reuse their cells</a> .  When the <i>view</i> scrolls and the cell goes off the screen, this cell is removed from the <i>view</i> hierarchy (in other words, the message <i>removeFromSuperview is</i> sent to <i>it</i> ) and transferred to the queue for reuse (reuse queue).  At the same time, before the new cell should appear, the table calls the free cell from the waiting queue of the reuse and re-places it on its hierarchy of views.  This approach avoids significant memory consumption, minimizes the number of costly creation and allocation (allocation) operations in the memory of new types and ensures the fastest possible scrolling. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/2b4/07d/9ff2b407decbf6ea4513cf938ebc114a.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Illustration of reuse cells in a <i>UITableView</i> .  Invisible cells are removed from the view hierarchy (indicated by a blue dotted line) and added to the table view before being displayed as a result of scrolling.  Note that the table <i>frame</i> (light blue rectangle) is smaller than the content size (content size, circled in red dotted line), as is usually the case with scroll view.  <a href="">Download video (in H.264 format)</a> . </blockquote><br><h4>  A simple approach to the implementation of the container </h4><br>  Placing multiple scroll views in one common container, also being a scroll view, is a fairly simple task: <br><br><ul><li>  Create a <i>UIScrollView</i> that will be the container for the nested scroll view. </li><li>  Add nested scroll views to the container.  It can be as simple scroll view, and tables or collections. </li><li>  Set the nested scroll view <i>frame</i> so that they contain all their content ( <i>contentSize</i> ).  Set scroll views one above the other. </li><li>  Set the content size ( <i>contentSize</i> ) of the container as the sum of the <i>frames of the</i> nested views. </li></ul><br>  Thus, when we set each <i>frame</i> scroll view size <i>frame</i> larger or equal to the size of their content, we get a situation in which these scroll view will never scroll - the only scrolling object will be the container.  This avoids interference with touch processing between nested scroll views and their container. <br><br>  This scheme certainly works, but there is one major drawback: excessive memory waste.  If nested scroll views are tables or collections, then they create a cell for each row, because all the cells in their understanding are visible.  If the collection contains hundreds or thousands of cells, then the effect will be truly dramatic: scrolling will slow down, and your application will consume all the available memory on the device. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/582/0e7/ae95820e7862691a2909d36f752b4d7d.gif"><br><br><blockquote>  An example of a simple approach to implementing a container for several scroll views.  Two tables are added as <i>subviews</i> into one common container, which itself is a scroll view (rectangle with black stroke).  <i>The frames of the</i> tables (light blue and light yellow rectangles) are modified to fully accommodate the content of each table (red dotted outline).  Notice how it affected the reuse of cells - it stopped, all cells of each row are present at the same time, regardless of whether the cell is visible (inside the <i>frame of the</i> container, black rectangle) or not.  <a href="">Download video (in H.264 format)</a> . </blockquote><br><h4>  OLEContainerScrollView </h4><br>  Now I will talk about my scroll view container.  <i>OLEContainerScrollView</i> is a descendant of <i>UIScrollView</i> , which automatically organizes nested views in a deck or stack style (similar to <a href="https://developer.apple.com/library/mac/documentation/AppKit/Reference/NSStackView_Class/Chapters/Reference.html"><i>NSStackView</i></a> on OS X).  This container works with all types of views, not only with scroll views, although it handles the scroll view in a special way. <br><br><h4>  Adding Views </h4><br>  To add a view to a container, you need to use the <i>addSubviewToContainer:</i> method.  I was forced to create new methods to add and remove views to the container, rather than relying on the existing <i>addSubview: / removeFromSuperview pair</i> , because I wanted to add views to the private <i>contentView</i> , not directly to the container.  This technique allowed us to avoid interference from private subspecies of the <i>UIScrollView</i> itself, which are created to display scroll indicators, when we later search through nested types to adjust their sizes. <br><br>  As soon as the view is added to the container, the following happens: <br><br><ul><li>  If a new view is an instance of <i>UIScrollView</i> (or a descendant), then its own scrolling is disabled by using the property <i>subview.scrollEnabled = NO;</i>  .  So only our container will handle the scrolling gestures. </li><li>  Subscribe to KVO notifications (notifications) about resizing nested views.  For normal <i>UIViews</i> , <i>we</i> observe changes in the <i>frames</i> and <i>bounds</i> properties.  For scroll view, we observe the changes in the size of the content through the <i>contentSize</i> property.  This must be done in order to subsequently customize (relayout) the nested views when they change their sizes from the outside. </li></ul><br><h4>  Align while scrolling </h4><br>  During scrolling, the container continuously aligns the <i>frames of the</i> views nested in it in the following way: <br><br><ul><li>  Enumerates all the nested views in the order from the appendix and positions them in a pile: each next view after the previous one.  The width of all species is adjusted to the width of the container so that the species fits in container <sup>1</sup> .  For ordinary <i>UIViews</i> , space is allocated according to the height of their <i>frame</i> .  For scroll view, enough space is allocated to accommodate their content; height is taken from <i>contentSize.height</i> .  This means that the view following the scroll view will be placed in the container so that the entire contents of the scroll view fits in it. </li><li>  The size of the content of the container consists of the size of the content of all nested views. </li></ul><br>  This still corresponds to the simple approach described earlier.  Now we need to align the <i>frames of</i> all scroll views in the container so that they get the minimum size that will allow to fill the viewport of the container ( <a href="http://oleb.net/blog/2014/04/understanding-uiscrollview/">according to <i>bounds</i></a> ): <br><br><ul><li>  To do this, we define for each nested scroll view in container <sup>2</sup> how their content areas intersect with the current scope of the container, and set the <i>frame</i> for them accordingly.  This means that the <i>frame of</i> any scroll view will never be larger than the size of the container, and that views that are not currently in scope will have a frame with a height of 0. </li></ul><br>  Take a look at the video below to see how this algorithm works.  At the beginning, the first table fills the entire scope of the container (marked with a black stroke) - the table <i>frame</i> (light blue rectangle) is exactly equal to the <i>bounds of the</i> container.  The second table is completely out of scope - its <i>frame</i> has a height of 0, the table is invisible.  As a result, there is no need to create cells in it (yellow dotted line). <br><br>  As soon as the user scrolls the contents of the container, and the second table goes into view, the height of the <i>frame of the</i> table (light yellow rectangle) starts to increase from the lower limit of the scope until it reaches the height of the container.  At the same time, the <i>frame of the</i> first table is compressed to zero until the table is removed off the screen.  Both tables can use without restriction all possibilities of cell reuse without any restrictions and conditions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/404/2eb/522/4042eb522327e886751ba450378accb3.gif"><br><blockquote>  Demonstration of the <i>OLEContainerScrollView</i> .  <a href="">Download video (in H.264 format)</a> . </blockquote><br><h4>  Code </h4><br>  The interface of the <i>OLEContainerScrollView</i> class looks like this: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@interface</span></span> OLEContainerScrollView : UIScrollView - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)addSubviewToContainer:(UIView *)subview; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)removeSubviewFromContainer:(UIView *)subview; <span class="hljs-meta"><span class="hljs-meta">@end</span></span></code> </pre> <br><br>  But the implementation of the <i>layoutSubviews</i> method, which does all the work: <br><pre> <code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OLEContainerScrollView</span></span></span><span class="hljs-class"> ... - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layoutSubviews</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> layoutSubviews]; <span class="hljs-comment"><span class="hljs-comment">// Translate the container view's content offset to contentView bounds. // This keeps the contentview always centered on the visible portion of the container view's // full content size, and avoids the need to make the contentView large enough to fit the // container view's full content size. self.contentView.frame = self.bounds; self.contentView.bounds = (CGRect){ self.contentOffset, self.contentView.bounds.size }; // The logical vertical offset where the current subview (while iterating over all subviews) // must be positioned. Subviews are positioned below each other, in the order they were added // to the container. For scroll views, we reserve their entire contentSize.height as vertical // space. For non-scroll views, we reserve their current frame.size.height as vertical space. CGFloat yOffsetOfCurrentSubview = 0.0; for (UIView *subview in self.contentView.subviews) { if ([subview isKindOfClass:[UIScrollView class]]) { UIScrollView *scrollView = (UIScrollView *)subview; CGRect frame = scrollView.frame; CGPoint contentOffset = scrollView.contentOffset; // Translate the logical offset into the sub-scrollview's real content offset and frame size. // Methodology: // (1) As long as the sub-scrollview has not yet reached the top of the screen, set its scroll position // to 0.0 and position it just like a normal view. Its content scrolls naturally as the container // scroll view scrolls. if (self.contentOffset.y &lt; yOffsetOfCurrentSubview) { contentOffset.y = 0.0; frame.origin.y = yOffsetOfCurrentSubview; } // (2) If the user has scrolled far enough down so that the sub-scrollview reaches the top of the // screen, position its frame at 0.0 and start adjusting the sub-scrollview's content offset to // scroll its content. else { contentOffset.y = self.contentOffset.y - yOffsetOfCurrentSubview; frame.origin.y = self.contentOffset.y; } // (3) The sub-scrollview's frame should never extend beyond the bottom of the screen, even if its // content height is potentially much greater. When the user has scrolled so far that the remaining // content height is smaller than the height of the screen, adjust the frame height accordingly. CGFloat remainingBoundsHeight = fmax(CGRectGetMaxY(self.bounds) - CGRectGetMinY(frame), 0.0); CGFloat remainingContentHeight = fmax(scrollView.contentSize.height - contentOffset.y, 0.0); frame.size.height = fmin(remainingBoundsHeight, remainingContentHeight); frame.size.width = self.contentView.bounds.size.width; scrollView.frame = frame; scrollView.contentOffset = contentOffset; yOffsetOfCurrentSubview += scrollView.contentSize.height; } else { // Normal views are simply positioned at the current offset CGRect frame = subview.frame; frame.origin.y = yOffsetOfCurrentSubview; frame.size.width = self.contentView.bounds.size.width; subview.frame = frame; yOffsetOfCurrentSubview += frame.size.height; } } self.contentSize = CGSizeMake(self.bounds.size.width, fmax(yOffsetOfCurrentSubview, self.bounds.size.height)); } @end</span></span></code> </pre><br></div></div><br>  The rest of the code is quite template, you can read it <a href="https://github.com/ole/OLEContainerScrollView">on GitHub</a> . <br><br><h4>  Auto Layout </h4><br>  A <i>few</i> words about <i>Auto Layout</i> : <i>OLEContainerScrollView</i> does not use this function inside, and it is probably impossible to implement this behavior using <i>Auto Layout</i> struts ( <a href="https://developer.apple.com/LIBRARY/ios/technotes/tn2154/_index.html"><i>UIScrollView</i> and <i>Auto Layout are</i> not exactly best friends, anyway</a> ).  However, there should be no problems with using this class with other objects that use <i>Auto Layout</i> for marking inside.  As I said earlier, you can mix the manual layout and auto layout quite freely. <br><br><h4>  Hey, where's the podspec? </h4><br>  I deliberately did not (yet) <i>make CocoaPod</i> from <i>OLEContainerScrollView</i> .  I wrote this class to solve my very specific problem, and I believe that it has enough potential to grow into a common component.  Of course, so far it is not.  The limitations are as follows: <br><br><ul><li>  The class supports only the vertical markup of nested views and only vertical scrolling. </li><li>  Vertical markings are very inflexible.  With it, all nested views are stretched to the width of the container.  It does not support gaps between nested views or their free placement. </li><li>  The size of the content changes following the dimensions of the nested views, but does not animate well enough. </li></ul><br>  If you are interested in using this class, I will be glad if you look at its code and use it for your own purposes.  I will also be happy to add your improvements ( <i>pull pull requests</i> ).  And email me if you want to see this class as a <i>CocoaPod</i> . <br><br><h4>  Conclusion </h4><br>  Placing several (including scroll) views on one common container ‚Äî the scroll view is not a daily trick, but this approach can make it easier for you to work with data sources for tables and collections, as well as simplify markup and layout, turning their sections into individual species. <br><br>  <i>The OLEContainerScrollView</i> is not currently a full-featured component, but I hope that it will become so with your help.  Anyway, writing this component helped me to deepen my understanding of the <i>UIScrollView</i> device and the <i>UIKit</i> coordinate system. <br><br><h4>  Footnotes: </h4><br><ol><li>  This is something I would like to make more flexible in a future version.  Currently, the class only supports vertical markup. </li><li>  I have done this so far only for species inheriting from <i>UIScrollView</i> .  The <i>frame</i> height of a regular <i>UIView</i> remains unchanged, even if the view is not in scope.  I did so in order to avoid changes in the markup (or even errors in <i>auto layout</i> ) that could be caused by zeroing the size of a view that does not expect such manipulations with its size.  Changing this behavior will be easy in the future. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  It is also desirable for a deeper understanding to read the article <a href="http://oleb.net/blog/2014/04/understanding-uiscrollview/">"Understanding UIScrollView"</a> . <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/224815/">https://habr.com/ru/post/224815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224799/index.html">RegEx Crossword</a></li>
<li><a href="../224803/index.html">Security analysis of network Unity3D games on VKontakte</a></li>
<li><a href="../224805/index.html">Git: Beyond the Possible</a></li>
<li><a href="../224807/index.html">Co-founder of The Pirate Bay Peter Sunde was arrested in Sweden</a></li>
<li><a href="../224813/index.html">The right to be forgotten by Google</a></li>
<li><a href="../224817/index.html">Useful materials for mobile developer # 55 (May 26 - June 1)</a></li>
<li><a href="../224821/index.html">We deduce MySQL from an environment</a></li>
<li><a href="../224823/index.html">Open source anti-corruption code (and not only)</a></li>
<li><a href="../224825/index.html">Getting started with browserify</a></li>
<li><a href="../224827/index.html">A few words about integrating defect management systems with TFS into TFS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>