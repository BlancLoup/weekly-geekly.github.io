<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Merge sort</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Merge sorting work according to this principle: 



1. Looking for (as an option - formed) ordered subarrays. 
2. Ordered subarrays are connected into...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Merge sort</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img width="690" height="244" src="https://habrastorage.org/webt/wx/ju/qt/wxjuqtiexdckl__y0ty6qow5djy.jpeg"></div><br>  Merge sorting work according to this principle: <br><br><ol><li>  Looking for (as an option - formed) ordered subarrays. </li><li>  Ordered subarrays are connected into a general ordered subarray. </li></ol><a name="habracut"></a><br>  By itself, any ordered sub-array within an array has no special value.  But if in the array we find <i>two</i> ordered subarrays, then this is a completely different matter.  The fact is that very quickly and with minimal cost it is possible to merge over them - to form a common ordered subarray from a pair of ordered subarrays. <br><br><img width="608" height="121" src="https://habrastorage.org/webt/__/ic/yc/__icycp4olpdm4lerf6icxkwixi.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you can see, it is very simple to combine two ordered arrays into one.  It is necessary to move simultaneously in both arrays from left to right and compare the next pairs of elements from both arrays.  The smaller element is sent to the common boiler.  When the elements end in one of the arrays, the remaining elements from the other array are simply transferred in order to the main list. <br><br>  This is the salt of the algorithms of this class.  Initially, a random array can be broken up into many small ordered subarrays.  During pairwise merging, the number of ordered subarrays decreases, the length of each of them increases.  In the last step, the array is just two ordered subarrays, which merge into a single ordered structure. <br><br><img align="right" width="400" height="210" src="https://habrastorage.org/webt/xx/2m/3x/xx2m3xrmgyaydhts-oyotbgzmg4.jpeg"><br clear="left">  The author of this concept is John von Neumann.  Sometimes there is a controversial statement that he came up with sorting while working on the Manhattan project, as he was faced with the task of ensuring effective calculations of a huge amount of statistical data when developing a nuclear bomb.  It is difficult to assess the plausibility of this version, since its first work on sorting by merger dates back to 1948, and the creation of the bomb was completed 3 years earlier.  However, what is there for atomic sorting, let's take a look at it. <br><br><h1>  Natural Neumann merger </h1><br><img align="left" width="380" height="251" src="https://habrastorage.org/webt/jn/hu/eb/jnhuebcvppgm5ogyhycskyquioe.gif"><br clear="right">  The Neumann algorithm was influenced by the design features of computers from the 40s.  It looked like this: <br><br><ol><li>  A total of three magnetic tapes are used ‚Äî the main one on which unsorted data is recorded and two auxiliary ones. </li><li>  Data is sequentially read from the main tape. </li><li>  While the sequentially readable data is an ordered subarray, they are written to one of the auxiliary tapes. </li><li>  As soon as the next sorted subarray is completed (i.e., an element smaller than the previous one is found on the main tape), a pointer is put on the auxiliary tape (the end of the subarray) and a switch to another auxiliary tape occurs. </li><li>  Items 2-4 are repeated again, only the data is transferred to another auxiliary tape.  At the completion of the next ordered sub-array on the main tape, alternately switching to one auxiliary tape, then to another takes place. </li><li>  When all data from the main tape is read, the processing of auxiliary tapes takes place. </li><li>  Data is read from both auxiliary tapes. </li><li>  In this case, the next data from the two tapes are compared with each other.  According to the results of the comparison, a smaller element from the pair is recorded on the main tape. </li><li>  Since the borders of the arrays on the auxiliary tapes are marked with pointers, reading and comparison occurs only within the sorted subarrays. </li><li>  If on one of the auxiliary tapes the elements of the next sub-array have run out, then from the remaining tape the remainder of the sub-array is simply transferred to the main tape. </li><li>  Repeat the whole process again until the data on the main tape is a completely ordered array. </li></ol><br>  The Neumann sorting is an adaptive algorithm: it not only fixes the sorted pieces of the array, but first of all tries to increase them in order to form even longer ordered subarrays on the basis of the elongated ordered subarrays.  Therefore, it is also called <b>adaptive merge sorting</b> . <br><br>  The complexity of this algorithm is modest - O ( <b>n <sup>2</sup></b> ), and, nevertheless, for the pioneers of tube calculations, this was a breakthrough. <br><br>  On the example of this first merge sorting, the lack of this class of algorithms is already visible - the cost of additional memory.  In this regard, almost all merge sorting additionally requires O ( <b>n</b> ), but occasionally there are elegant exceptions. <br><br><h1>  Bose-Nelson Direct Merger </h1><br>  Strictly speaking, the Bose-Nelson algorithm is a sorting network, not a sorting network.  In the process, the array and all its subarrays are divided in half and nothing prevents all these halves from being processed in parallel at all stages.  However, it can be presented in the form of sorting.  And we will sometime get to the topic of sorting nets too. <br><br><img width="608" height="173" src="https://habrastorage.org/webt/nj/6m/ja/nj6mjancjmsxwpy9nsph_qzrvgq.gif"><br><br><ol><li>  The array is divided in half - on the left and right halves. </li><li>  Elements are divided into groups. </li><li>  In the first iteration, these are two elements (the 1st element of the left half + the 1st element of the right half, the 2nd element of the left half + the 2nd element of the right half, etc.), on the second iteration - the fours of elements (1 the 2nd and 2nd elements of the left half + the 1st and 2nd elements of the right half, the 3rd and 4th elements of the left half + the 3rd and 4th elements of the right half, etc.), on the third - eights, etc. </li><li>  Elements of each group from the left half are a sorted subarray, elements of each group from the right half are also a sorted subarray. </li><li>  We merge the sorted subarrays from the previous item. </li><li>  We return to point 1. The cycle continues until the size of the groups is less than the size of the array. </li></ol><br>  It may seem that additional memory is required here.  But no!  For a clearer perception in animation, the left and right halves of the array are located on top of each other, so that the relative position of the compared subarrays is more obvious.  However, due to strict division in half, an algorithm is possible, in which all comparisons and exchanges are made on site, without attracting additional memory resources.  Which is very unusual for merge sorting. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bose_nelson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> m = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &lt; len(data): j = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> j + m &lt; len(data): bose_nelson_merge(j, m, m) j = j + m + m m = m + m <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bose_nelson_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j, r, m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j + r &lt; len(data): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &gt; data[j + r]: data[j], data[j + r] = data[j + r], data[j] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: m = m // <span class="hljs-number"><span class="hljs-number">2</span></span> bose_nelson_merge(j, r, m) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j + r + m &lt; len(data): bose_nelson_merge(j + m, r, m) bose_nelson_merge(j + m, r - m, m) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br>  There is still in all the sorts of merge something that makes them related to the hydrogen bomb.  First there is a division, then synthesis. <br><br><h2>  Links </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge</a> / <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">Merger</a> <br><br><h3>  Articles series: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Excel application AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Exchange sorting</a> </li><li>  <a href="https://habr.com/post/415935/">Sorting inserts</a> </li><li>  <a href="https://habr.com/post/422085/">Sort by selection</a> </li><li>  <b>Merge sort</b> <ul><li>  <a href="https://habr.com/post/432646/">Balanced merger top-down and bottom-up</a> </li><li>  Multiphase merge sorting </li><li>  Cascade Merge Sort </li><li>  Oscillating merge sort </li><li>  Filamentous and immiscible sorting </li><li>  Merge sort comparison </li></ul></li></ul><br>  Both of the sortings mentioned in today's article are now available in the AlgoLab application (who studies the algorithms using this Excel application, update the file).  And in just a couple of days, with the release of a quick continuation on merge sorting, several more algorithms of this class will be available. <br><br>  For the Bose-Nelson sort, a limit is set - the size of the array must be a power of two.  If this condition is not met, the macro will cut the array to the appropriate size. <br><blockquote> <a href="https://www.edsd.com/" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a> <br clear="right">  The article was written with the support of the company EDISON Software, which <a href="https://www.edsd.com/software-for-new-tomography-device">writes software for 3d-reconstruction</a> and is engaged in the <a href="https://www.edsd.com/portfolio/measurement-automation">development of sophisticated measuring equipment</a> . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/431964/">https://habr.com/ru/post/431964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431954/index.html">Former vice president of Sun and DEC became president of MIPS / Wave, talks about Russia and RISC / V</a></li>
<li><a href="../431956/index.html">Logic, Explainability and Future of Understanding</a></li>
<li><a href="../431958/index.html">Tesla's Virtual Power Station with rechargeable batteries (Powerwall) expands to 1,000 homes in Australia</a></li>
<li><a href="../431960/index.html">Nvidia went crazy and opens up PhysX under BSD-3</a></li>
<li><a href="../431962/index.html">Orbit Fab plans to refuel satellites right in orbit</a></li>
<li><a href="../431968/index.html">Large FAQ about long-distance trains and non-obvious rules</a></li>
<li><a href="../431970/index.html">Support department: waiting vs reality</a></li>
<li><a href="../431972/index.html">Leaked personal data of Quora users</a></li>
<li><a href="../431974/index.html">Tumblr rejects strawberry content completely</a></li>
<li><a href="../431976/index.html">Informatics Day in Russia: the history of the first project of an automatic computer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>