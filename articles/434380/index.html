<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of dependency injection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about the basics of dependency injection (Eng. Dependency Injection, DI ) in simple language, and also talk about the reas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of dependency injection</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Basics of dependency injection"></p><br><p>  In this article I will talk about the basics of dependency injection (Eng. <em>Dependency Injection, DI</em> ) in simple language, and also talk about the reasons for using this approach.  This article is intended for those who do not know what is dependency injection, or doubts the need to use this technique.  So, let's begin. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  What is addiction? </h2><br><p> Let's first look at an example.  We have <code>ClassA</code> , <code>ClassB</code> and <code>ClassC</code> , as shown below: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  You can see that the class <code>ClassA</code> contains an instance of the class <code>ClassB</code> , so we can say that the class <code>ClassA</code> depends on the class <code>ClassB</code> .  Why?  Because the <code>ClassA</code> class needs the <code>ClassB</code> class to work correctly.  We can also say that the <code>ClassB</code> class is a dependency of the <code>ClassA</code> class. </p><br><p>  Before continuing, I want to clarify that such a relationship is good, because we do not need one class to do all the work in the application.  We need to divide the logic into different classes, each of which will be responsible for a particular function.  And in this case, the classes will be able to interact effectively. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  How to work with addictions? </h2><br><p>  Let's look at three ways that are used to perform dependency injection tasks: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  First way: create dependencies in a dependent class </h3><br><p>  Simply put, we can create objects whenever we need them.  Look at the following example: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  It is very easy!  We create a class when we need it. </p><br><p>  <strong>Benefits</strong> </p><br><ul><li>  It is easy and simple. </li><li>  The dependent class ( <code>ClassA</code> in our case) completely controls how and when to create dependencies. </li></ul><br><p>  <strong>disadvantages</strong> </p><br><ul><li>  <code>ClassA</code> and <code>ClassB</code> closely related to each other.  Therefore, whenever we need to use <code>ClassA</code> , we will have to use <code>ClassB</code> , and <strong>it will be impossible to replace <code>ClassB</code> with something else</strong> . </li><li>  With any change in the initialization of the <code>ClassB</code> class, it is necessary to correct the code inside the <code>ClassA</code> class (and all other <code>ClassB</code> dependent classes).  This complicates the process of changing dependencies. </li><li>  <strong><code>ClassA</code> cannot be tested.</strong>  If you need to test a class, and this is one of the most important aspects of software development, then you will have to carry out unit testing of each class separately.  This means that if you want to check the correctness of how <code>ClassA</code> works exclusively and create several unit tests to test it, then, as was shown in the example, you will create an instance of the <code>ClassB</code> class, even when it does not interest you.  If an error occurs during testing, you will not be able to understand where it is located - in <code>ClassA</code> or <code>ClassB</code> .  After all, there is a possibility that part of the code in <code>ClassB</code> led to an error, while <code>ClassA</code> works correctly.  In other words, unit testing is impossible, because modules (classes) cannot be separated from each other. </li><li>  <code>ClassA</code> must be configured so that it can inject dependencies.  In our example, he should know how to create <code>ClassC</code> and use it to create <code>ClassB</code> .  I wish he knew nothing about it.  Why?  Because of the <strong>principle of uniform responsibility</strong> . </li></ul><br><blockquote>  <em>Each class must do only their work.</em> </blockquote><p>  Therefore, we do not want classes to be responsible for anything but their own tasks.  The introduction of dependencies is an additional task that we set for them. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  The second way: implement dependencies through a custom class. </h3><br><p>  So, realizing that dependency injection inside the dependent class is not the best idea, let's explore the alternative method.  Here, the dependent class defines all the dependencies it needs inside the constructor and allows the user class to provide them.  Is this a way to solve our problem?  We learn a little later. </p><br><p>  Look at the sample code below: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Now <code>ClassA</code> gets all the dependencies inside the constructor and can simply call the methods of the <code>ClassB</code> class without initializing anything. </p><br><p>  <strong>Benefits</strong> </p><br><ul><li>  <code>ClassA</code> and <code>ClassB</code> now loosely coupled, and we can replace <code>ClassB</code> without breaking the code inside <code>ClassA</code> .  For example, instead of passing <code>ClassB</code> we will be able to pass <code>AssumeClassB</code> , which is a subclass of <code>ClassB</code> , and our program will work <code>AssumeClassB</code> . </li><li>  <code>ClassA</code> can now be tested.  When writing a unit test, we can create our own version of <code>ClassB</code> (a test object) and pass it to <code>ClassA</code> .  If an error occurs during the test, then now we know for sure that this is definitely an error in <code>ClassA</code> . </li><li>  <code>ClassB</code> free from dependency and can focus on performing its tasks. </li></ul><br><p>  <strong>disadvantages</strong> </p><br><ul><li>  This method resembles a chain mechanism, and at some point the chain should break.  In other words, a <code>ClassA</code> must know everything about initializing <code>ClassB</code> , which in turn requires knowledge and about initializing <code>ClassC</code> , etc.  So, you see that any change in the constructor of any of these classes can lead to a change in the calling class, not to mention that <code>ClassA</code> can have more than one user, so the logic of creating objects will be repeated. </li><li>  Despite the fact that our dependencies are clear and easy to understand, the user code is nontrivial and difficult to manage.  Therefore, everything is not so simple.  In addition, the code violates the principle of common responsibility, since it is responsible not only for its work, but also for the implementation of dependencies in dependent classes. </li></ul><br><p>  The second method obviously works better than the first, but it still has its drawbacks.  Is it possible to find a more suitable solution?  Before considering the third method, let's first talk about the very concept of dependency injection. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  What is dependency injection? </h3><br><blockquote>  Dependency injection is a way to handle dependencies outside the dependent class when the dependent class does not need to do anything. </blockquote><p>  Based on this definition, our first solution does not explicitly use the idea of ‚Äã‚Äãdependency injection, and the second way is that the dependent class does nothing to provide dependencies.  But we still think the second solution is bad.  WHY?! </p><br><p>  Since the <a href="https://en.wikipedia.org/wiki/Dependency_injection">definition of dependency injection</a> says nothing about where the work with dependencies should occur (except outside the dependent class), the developer must choose a suitable place for dependency injection.  As you can see from the second example, the custom class is not the right place. </p><br><p>  How to do better?  Let's look at the third way to handle dependencies. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  The third way: let someone else handle dependencies instead of us. </h3><br><p>  According to the first approach, the dependent classes are responsible for getting their own dependencies, and in the second approach, we moved the dependency processing from the dependent class to a custom class.  Let's imagine that there is someone else who could handle the dependencies, as a result of which neither the dependent nor the user classes would do this work.  This method allows you to work with dependencies in the application directly. </p><br><blockquote>  <strong><em>‚ÄúNet‚Äù implementation of dependency injection (in my personal opinion)</em></strong> <br><br>  <em>Responsibility for handling dependencies rests with the third party, so no part of the application will interact with them.</em> </blockquote><p>  Dependency injection is not a technology, framework, library, or something similar.  This is just an idea.  The idea of ‚Äã‚Äãworking with dependencies outside the dependent class (preferably in a dedicated part).  You can apply this idea without using any libraries or frameworks.  However, we usually refer to frameworks for dependency injection, because it simplifies the work and avoids writing template code. </p><br><p>  Any dependency injection framework has two inherent characteristics.  Other additional functions might be available to you, but these two functions will always be present: </p><br><p>  First, these frameworks offer a way to define the fields (objects) to be implemented.  Some frameworks do this by annotating a field or constructor using the <code>@Inject</code> annotation, but there are other methods.  For example, <a href="https://insert-koin.io/">Koin</a> uses Kotlin's built-in language features to define embedding.  By <code>Inject</code> meant that the dependency must be handled by the DI framework.  The code will look something like this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Secondly, the frameworks allow you to determine how to provide each dependency, and this happens in a separate file (s).  Approximately it looks like this (keep in mind that this is only an example, and it may differ from framework to framework): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  So, as you can see, each function is responsible for handling one dependency.  Therefore, if we need to use <code>ClassA</code> somewhere in the application, the following will happen: our DI framework creates one instance of <code>ClassC</code> , invoking <code>provideClassC</code> , passing it to <code>provideClassB</code> and receiving an instance of <code>ClassB</code> , which is passed to <code>provideClassA</code> , and as a result <code>ClassA</code> is created.  It is almost magic.  Now let's explore the advantages and advantages of the third method. </p><br><p>  <strong>Benefits</strong> </p><br><ul><li>  Everything is as simple as possible.  Both the dependent class and the dependency class are clear and simple. </li><li>  Classes are loosely coupled and easily replaceable by other classes.  Suppose we want to replace <code>ClassC</code> with <code>AssumeClassC</code> , which is a subclass of <code>ClassC</code> .  To do this, you only need to change the provider code as follows, and wherever <code>ClassC</code> is used, the new version will now be automatically used: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Please note that no code inside the application changes, only the provider method.  It seems that nothing can be even simpler and more flexible. </p><br><ul><li>  Incredible testability.  You can easily replace dependencies with test versions during testing.  In fact, dependency injection is your main assistant when it comes to testing. </li><li>  Improved code structure, because  The application has a separate place for handling dependencies.  As a result, the remaining parts of the application may focus on performing their functions exclusively and not overlap with dependencies. </li></ul><br><p>  <strong>disadvantages</strong> </p><br><ul><li>  DI frameworks have a certain entry threshold, so the project team must spend time and study it before it can be used effectively. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><ul><li>  Dependency handling without DI is possible, but this can lead to application crashes. </li><li>  DI is just an effective idea, according to which it is possible to handle dependencies outside the dependent class. </li><li>  The most effective use of DI is in certain parts of the application.  Many frameworks contribute to this. </li><li>  Framework and libraries are not needed for DI, but they can help a lot. </li></ul><br><p>  In this article I tried to explain the basics of working with the concept of dependency injection, and also listed the reasons for using this idea.  There are many more resources that you can explore to learn more about using DI in your own applications.  For example, a separate section is devoted to this topic in the advanced part of our <a href="https://devcolibri.com/course/android-profession/">Android profession course</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/434380/">https://habr.com/ru/post/434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434368/index.html">Machine learning for finding errors in code: how I trained at JetBrains Research</a></li>
<li><a href="../434370/index.html">Regular shadow shadows in the Phaser, or the use of bicycles</a></li>
<li><a href="../434372/index.html">The development of the digital economy of Russia will cost the state 1.8 trillion rubles</a></li>
<li><a href="../434374/index.html">Check RBAC at Kubernetes</a></li>
<li><a href="../434376/index.html">"Yandex" will test its robomobil in Israel</a></li>
<li><a href="../434382/index.html">Migrate Alpine Linux to RISC-V</a></li>
<li><a href="../434384/index.html">About the responsibility of performers</a></li>
<li><a href="../434386/index.html">Douglas Engelbart: "Augmenting Human Intellect: A Conceptual Framework"</a></li>
<li><a href="../434394/index.html">Bugatti Automobiles successfully tested a brake caliper printed on a 3D printer</a></li>
<li><a href="../434402/index.html">Veeam solution for backup and recovery of virtual machines on the Nutanix AHV platform. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>