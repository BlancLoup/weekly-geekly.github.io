<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing FizzBuzz on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I became interested in FPGA programming and decided that it would be interesting to implement the algorithm of the FizzBuzz game on FPGA. FP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing FizzBuzz on FPGA</h1><div class="post__text post__text-html js-mediator-article">  Recently, I <a href="https://en.wikipedia.org/wiki/Fizz_buzz">became</a> interested in FPGA programming and decided that it would be interesting to implement the algorithm of the <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> game on FPGA.  FPGA ( <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">user-programmable gate array</a> ) is an interesting chip.  It is programmed to execute arbitrary digital logic.  It is possible to construct a complex circuit without laying the physical channels between the individual valves and the flip-flops.  The microcircuit can turn into anything from a logic analyzer to a microprocessor and a video generator. <br><br>  <a href="http://wiki.c2.com/%3FFizzBuzzTest">Test FizzBuzz</a> - write a program that gives numbers from 1 to 100, where multiples of three are replaced by the word ‚ÄúFizz‚Äù, multiples of five by the word ‚ÄúBuzz‚Äù, and multiples of fifteen by ‚ÄúFizzBuzz‚Äù.  Since such a program is implemented in several lines of code, it is often asked at interviews in order to weed out those who do not know how to program at all. <br><br> <a href=""><img src="https://habrastorage.org/webt/no/qa/1n/noqa1nzdi_aunyusy3uq-zbrgnc.jpeg"></a> <br>  <i><font color="gray">A Mojo FPGA card connected to the serial-to-USB port.</font></i>  <i><font color="gray">The big chip on the board is the Spartan 6 FPGA</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The implementation of FizzBuzz in digital logic, not in code, is rather meaningless, but it seemed to me a good example for learning.  <a href="https://habr.com/ru/post/357718/"><sup>one</sup></a> <a name="1_1"></a>  For this project, I used a simple <a href="https://embeddedmicro.com/products/mojo-v3">Mojo V3</a> FPGA development board for beginners.  It has the FPGA of the Xilinx Spartan 6 family. It is one of the smallest FPGAs, but it has 9000 logic cells and 11,000 triggers - so the kid is capable of a lot. <br><a name="habracut"></a><br><h1>  Implementing FPGA serial output </h1><br>  What does it mean to implement FizzBuzz on FPGA?  This means that the contacts of the general-purpose input / output interface (GPIO) from the board can be connected to anything, so the FizzBuzz output will appear in a different form: by LEDs, on seven-segment indicators, LCD display, VGA monitor.  I decided that text output to the terminal via a serial channel most closely matches the spirit of the ‚Äústandard‚Äù FizzBuzz program.  So the first thing to do is to implement serial output on the FPGA. <br><br>  The main idea of ‚Äã‚Äãserial communication is the transmission of bits one by one.  <a href="https://learn.sparkfun.com/tutorials/serial-communication/all">The RS-232 serial port</a> is a simple protocol for serial data transmission, invented in 1960 to connect teletypes and modems.  The diagram below shows how the ‚ÄúF‚Äù symbol (binary 01000110) is sequentially transmitted over the channel.  First, the start bit (zero) is sent to indicate the beginning of a character.  <a href="https://habr.com/ru/post/357718/"><sup>2</sup></a> <a name="2_2"></a>  Then eight bits of the character are transmitted in reverse order.  At the end, a stop bit is sent.  Between the characters, the bar remains in standby mode (one) until the next character is transmitted.  At a baud rate of 9600 baud, the transmission of each bit takes 1/9600 seconds.  With eight data bits with no parity and one stop bit, this protocol is known as 8N1.  There are many protocols for serial data transmission, but 9600 8N1 is very common. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e63/cb6/7e6/e63cb67e66c2417e8dd6f94119f5fa41.png"><br>  <i><font color="gray">Sequential transmission of the character ‚ÄúF‚Äù at 9600 baud / 8N1</font></i> <br><br>  The first step in implementing such a serial transmission is to create 1/9600 second intervals for each bit.  This interval is measured by calculating 5208 clocks on a Mojo.  <a href="https://habr.com/ru/post/357718/"><sup>3</sup></a> <a name="3_3"></a>  I made a 13-bit counter for periodic counting from 0 to 5207. A simple finite state machine keeps track of which bit is output in each interval.  It starts with the initial bit, changes its state as it processes the eight bits of data and the stop bit.  The state is stored in a four-bit register (in general, in FPGA you will have to deal with a large number of clock pulses, counters and finite automata). <br><br>  To create an interval and state registers in the FPGA, I wrote code in the Verilog hardware description language.  I will not explain in detail Verilog - I hope you will understand how it works.  In the following code, the first lines specify the 13-bit <code>counter</code> register and the four-bit <code>state</code> register.  The counter is increased to a value of 5207, then reset to 0, while the <code>state</code> incremented by one to process the next output bit.  (Note that <code>&lt;=</code> is an assignment operator, not a comparison <a href="https://habr.com/ru/post/357718/"><sup>4</sup></a> <a name="4_4"></a>  ).  The string <code>always @(posedge clk)</code> indicates that the procedural block is triggered on the positive edge of the clock frequency. <br><br><pre> <code class="hljs pgsql">reg [<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] counter; reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] state; <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter &lt; <span class="hljs-number"><span class="hljs-number">5207</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> counter &lt;= counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> counter &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; state &lt;= state + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Although it looks like ordinary program code, it works completely differently.  In a conventional programming language, operations are usually performed sequentially, since the program is executed line by line.  For example, the processor checks the value of <code>counter</code> .  Then adds one to the <code>counter</code> .  But in Verilog there is neither a processor nor an executable program.  Instead, the code creates the hardware to perform the operations.  For example, to increase the <code>counter</code> , one addition scheme is created, and for increasing the <code>state</code> , another scheme is created.  Additional logic is created for comparison with 5207. Unlike a serial processor, an FPGA performs everything in parallel.  For example, an FPGA simultaneously performs a comparison of 5207, an increase and a reset <code>counter</code> , and an increase in <code>state</code> on each clock.  Because of this, in strongly parallel tasks, FPGA can work to be much faster than a processor. <br><br>  The next part of the code outputs the corresponding bit for each state.  As before, it looks like a normal program code, but generates hardware circuits, and not operations that are performed sequentially.  In this case, the code creates a logic gate (essentially a multiplexer) to select the right <code>out</code> value. <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (state) IDLE: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = MARK; // high START: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = SPACE; // low BIT0: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = char1[<span class="hljs-number"><span class="hljs-number">0</span></span>]; BIT1: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = char1[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ... BIT6: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = char1[<span class="hljs-number"><span class="hljs-number">6</span></span>]; STOP: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = MARK; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = MARK; endcase</code> </pre> <br>  There is some more code to set constants, initialize counters, start and stop the transmission of each character, but the code above gives a general idea of ‚Äã‚Äãhow Verilog works.  All code for serial data output is <a href="">here</a> . <br><br><h1>  FizzBuzz Algorithm </h1><br>  The next step is to determine what specifically to send through the serial channel.  How to translate numbers from 1 to 100 in ASCII characters?  This is trivial on a microprocessor, but difficult in digital logic.  The problem is that converting a binary number to a decimal requires dividing by 10 and 100, and the division is very inconvenient to implement in the gates.  I decided to use <br>  binary decimal counter (BCD), which stores each of the three digits separately.  This made the meter a bit more complicated, since nodes are introduced into the counter circuit, which ensure the correction of the counting process in case of overflow to one side or the other from the nine.  But the issuance of numbers is simplified. <br><br>  I wrote a BCD module ( <a href="">source code</a> ) for a three-digit counter.  It has three four-bit counters <code>digit2</code> , <code>digit1</code> , and <code>digit0</code> .  The <code>increment</code> flag signals an increase in the counter.  Usually, only <code>digit0</code> increases.  But if it reaches nine, it turns to 0, and <code>digit1</code> increases.  If <code>digit1</code> also becomes 9, then it turns to 0, and <code>digit2</code> increases.  Thus, there is a countdown from 000 to 999. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>) begin if (digit0 != <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Regular <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> digit <span class="hljs-number"><span class="hljs-number">0</span></span> digit0 &lt;= digit0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Carry <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> digit <span class="hljs-number"><span class="hljs-number">0</span></span> digit0 &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (digit1 != <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Regular <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> digit <span class="hljs-number"><span class="hljs-number">1</span></span> digit1 &lt;= digit1 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Carry <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> digit <span class="hljs-number"><span class="hljs-number">1</span></span> digit1 &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; digit2 &lt;= digit2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  As before, keep in mind that this only looks like a normal program, but in reality the code turns into a bunch of logic gates that generate new values ‚Äã‚Äãof <code>digit2</code> , <code>digit1</code> and <code>digit0</code> on each <code>digit0</code> .  The system does not follow the instructions in order, so performance is not limited by the number of instructions, but only by delaying the signals propagating through the valves. <br><br>  The next task is to check the divisibility by 3 and 5. As a simple division, division with the remainder is also easy to implement on a microprocessor, but difficult in digital logic.  There is no built-in division operation, so you have to create a whole bunch of gates.  Although the IDE can synthesize them for division with the remainder, but it is tasteless.  Instead, I just made counters for the remainder of the division by 3 and 5. For example, mod3 will simply give out 0, 1, 2, 0, 1, 2 ... <a href="https://habr.com/ru/post/357718/"><sup>5</sup></a> <a name="5_5"></a><br><br>  The last part of FizzBuzz is the code for outputting each line character by character.  In the program, we can simply call the sequential output procedure for each character.  But in the FPGA, you need to keep track of which symbol is sent to the output, with the help of another state machine.  Note that when converting each digit to ASCII, binary 11 is concatenated using a slightly odd syntax of <code>2'b11</code> .  The code given here is a bit simplified.  <a href="">The full code</a> contains zero checks at the beginning, so ‚Äú001‚Äù is output as ‚Äú1‚Äù. <br><br><pre> <code class="hljs erlang">state &lt;= state + <span class="hljs-number"><span class="hljs-number">1</span></span>; // Different state from serial <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod3 == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; mod5 != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Fizz <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (state) <span class="hljs-number"><span class="hljs-number">1</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"F"</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"i"</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"z"</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"z"</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"\r"</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> char &lt;= <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; state &lt;= NEXT; // Done with output line <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> else <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod3 != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; mod5 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ... Buzz <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> omitted ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> else <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mod3 == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; mod5 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ... Fizzbuzz <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> omitted ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> else <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // No divisors; output the digits <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the number. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (state) <span class="hljs-number"><span class="hljs-number">1</span></span>: char &lt;= {<span class="hljs-number"><span class="hljs-number">2</span></span>'b11, digit2[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]}; <span class="hljs-number"><span class="hljs-number">2</span></span>: char &lt;= {<span class="hljs-number"><span class="hljs-number">2</span></span>'b11, digit1[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]}; <span class="hljs-number"><span class="hljs-number">3</span></span>: char &lt;= {<span class="hljs-number"><span class="hljs-number">2</span></span>'b11, digit0[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]}; <span class="hljs-number"><span class="hljs-number">4</span></span>: char &lt;= <span class="hljs-string"><span class="hljs-string">"\r"</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> char &lt;= <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; state &lt;= NEXT; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  If you put it all together, the final FizzBuzz scheme consists of numerous state machines and counters.  The main state machine controls the code at the top, moving through the characters in the string.  For each character, the state machine activates the serial output module and waits for the character to be output.  Inside the module, the state machine passes through each bit of the symbol.  It waits until the data rate counter counts the bit width.  When the symbol transfer is complete, the serial output module sends a signal to the master state machine.  Then it goes to the next character in the string.  When the line is completed, the main state machine increases the BCD counter (which counts from 1 to 100) - and starts outputting the next line. <br><br>  In programming languages, it is easy to perform sequential operations, cycles, subroutine calls, and so on.  But in FPGA, you need to explicitly track what is happening with the help of finite automata and counters.  In exchange, FPGA provides powerful concurrency and control. <br><br><h1>  Running FizzBuzz on the FPGA board </h1><br>  To compile Verilog code, I used the Xilinx ISE tool (see below).  In this development environment, you can write code, model it, and synthesize logic circuits for downloading to FPGA.  The ISE tool is pretty straightforward and is explained in <a href="https://embeddedmicro.com/pages/verilog">the Mojo manuals</a> .  The synthesis process is much slower than compiling: for my FizzBuzz program, it took about 45 seconds. <br><br> <a href=""><img src="https://habrastorage.org/webt/w1/x8/mg/w1x8mgls--6mdqv9yls2osf-wj0.png"></a> <br>  <i><font color="gray">By writing the Verilog code in the Xilinx ISE tool, you can program the FPGA functionality</font></i> <br><br>  As soon as my code earned in simulator <a href="https://habr.com/ru/post/357718/"><sup>7</sup></a> <a name="7_7"></a>  I downloaded it to the FPGA board via USB cable.  I connected the FPGA output pin to the USB-to-serial <a href="https://habr.com/ru/post/357718/"><sup>6</sup></a> adapter <a name="6_6"></a>  and used a terminal emulator ( <code>screen</code> ) to display the serial output on the computer.  I pressed the reboot button on the Mojo board - and (after a little extra debugging) the output of FizzBuzz appeared (below). <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e67/899/a9f/e67899a9f6a38edda4c1993d8b14a463.png"><br>  <i><font color="gray">The first page of the FizzBuzz FPGA output in the terminal emulator</font></i> <br><br>  The image below shows raw raw serial data from an FPGA (yellow).  This is the end result of the operation of the FizzBuzz scheme on the FPGA board - a sequence of pulses.  The oscilloscope also demonstrates decoded ASCII characters (green).  The image shows FizzBuzz for 2, 3, and 4 (CR and LF are carriage return and line feed characters). <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f79/b7a/e68/f79b7ae68ed7154d5c2923f607eeadfc.png"><br>  <i><font color="gray">The serial output signal (yellow) at the beginning of the FizzBuzz output.</font></i>  <i><font color="gray">ASCII decoding - green</font></i> <br><br><h1>  What happens inside the FPGA? </h1><br>  You may ask how the Verilog schema description is converted to digital logic and how the FPGA implements this logic.  The ISE synthesis tool takes a description of Verilog ‚Äî and generates schemas suitable for implementation inside an FPGA.  First, from the Verilog code, it synthesizes a ‚Äúnetlist‚Äù (netlist), defining logic and interconnections.  Then translates the lists into FPGA primitives in accordance with the capabilities of a particular chip (in our case Spartan 6).  At the end, an optimization procedure is started to minimize the signal path. <br><br> <a href=""><img src="https://habrastorage.org/webt/ff/-l/y-/ff-ly-e8baxjasmvkc0nj_ky31i.png"></a> <br>  <i><font color="gray">FizzBuzz circuit diagram</font></i> <br><br>  The figure above shows the FizzBuzz chain as generated by the synthesis tool.  As you can see, the Verilog code turns into a big tangle of schemes.  Each block is a trigger, logic element, multiplexer, or other element.  The blocks consist of counters, status registers and logic of the FizzBuzz circuit.  Although it seems that there are a lot of logical elements, in fact, less than 2% of the power of the chip is used.  A close-up (below) shows the trigger scheme (labeled ‚Äúfdre‚Äù) <a href="https://habr.com/ru/post/357718/"><sup>8</sup></a> <a name="8_8"></a>  and a lookup table (labeled ‚Äúlut5‚Äù) from the BCD counter.  What is convenient in Verilog is that you design the circuit at a high level ‚Äî and it turns into a low-level circuit.  This is called RTL ( <a href="https://en.wikipedia.org/wiki/Register-transfer_level">register transfer level</a> ) and allows the use of registers and high-level operations on them without worrying about low-level hardware implementation.  For example, you can simply write <code>count + 1</code> - and get a binary adder circuit. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/33f/3ff/d6a/33f3ffd6a0053656395cba4212168354.png"><br>  <i><font color="gray">Detailed diagram of the trigger and search table</font></i> <br><br>  The FPGA uses an interesting technique for logical equations.  Instead of linking individual gates, a lookup table (LUT) is used, with which it is convenient to implement arbitrary logic.  Each table has six input lines, so it can implement any combinatorial logic with six input signals.  It turns out 64 different combinations of input signal and 64-bit truth table.  By saving this table as a 64-bit image, LUT can implement any logical function. <br><br>  For example, part of the logic for an output pin is equivalent to the logic below.  It is implemented by storing the 64-bit value <code>FFFFA8FFFFA8A8A8</code> in the lookup table.  On a Spartan 6 chip, this LUT is placed in 64 bits of static random access memory, which is loaded during FPGA initialization.  Since there are 5720 separate tables in a microcircuit, it can be programmed to implement a set of arbitrary schemes. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/10f/91a/f5f/10f91af5fdc155ce88ea62e604d39348.png"><br>  <i><font color="gray">Logic elements implemented by a single lookup table in FPGA</font></i> <br><br>  The last part of the task is a matrix switch that arbitrarily connects the circuits.  In Spartan 6, several LUTs, triggers, and multiplexers are assembled into <i>configurable logic blocks</i> (CLB) <a href="https://habr.com/ru/post/357718/"><sup>9</sup></a> <a name="9_9"></a>  .  These CLBs are connected by <i>matrix switches</i> , as shown below.  Each block of the matrix switch is programmed to connect different buses, which allows you to lay the FPGA contacts as you like.  An important part of the FPGA synthesis process is block positioning to minimize wiring distance.  This is necessary both to minimize the propagation delay of the signal, and to maintain a reserve of interconnect paths. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c3c/152/d18/c3c152d18a576aadef46cdd5271b09d2.png"><br>  <i><font color="gray">The matrix switch in the Spartan 6 FPGA allows arbitrary connections between CLBs.</font></i>  <i><font color="gray">From <a href="https://www.xilinx.com/support/documentation/user_guides/ug384.pdf">the user manual</a></font></i> <br><br><h1>  Is it worth it to try FPGA? </h1><br>  Personally, I first looked at the FPGAs with fear, because they seemed scary and strange.  Although there is a learning curve, but FPGAs were not as complex as I thought.  If you are interested in new programming paradigms, then the FPGA will certainly show things from a different angle.  What you take for granted, such as the sequential execution of operations, will come to the fore.  You can experiment with high parallelism.  And the FPGA will allow you to better understand how digital circuits work. <br><br>  However, I would not recommend experimenting with FPGA if you are at least somewhat familiar with connecting LEDs / switches and do not understand basic digital logic: gates, triggers, and state machines.  But if you are comfortable with Arduino, then FPGA is the smart next step. <br><br>  Probably, for most applications the microcontroller is better suited to FPGA, and it is easier to program.  If you don‚Äôt need a high data transfer rate or concurrency, then FPGA will probably be redundant.  In my case, the microcontroller barely coped with the <a href="http://www.righto.com/2018/01/xerox-altos-3-mbs-ethernet-building.html">three megabit Ethernet gateway</a> , so for the next project I take a closer look at the FPGA. <br><br><h1>  Mojo - good pay for a start? </h1><br>  Mojo FPGA development <a href="https://www.adafruit.com/product/1553">boards</a> sell <a href="https://www.adafruit.com/product/1553">Adafruit</a> and <a href="https://www.sparkfun.com/products/11953">Sparkfun</a> , so I thought it was a good hacker choice.  The board is designed for beginners in FPGA programming, and it copes well with this role.  The creators of Mojo have written a large <a href="https://embeddedmicro.com/pages/verilog">collection of guides for using Verilog</a> .  <a href="https://habr.com/ru/post/357718/"><sup>ten</sup></a> <a name="10_10"></a>  .  If the manual is written for a specific board, then problems with the board and tools are solved much faster.  Mojo is programmed with a standard USB cable - this is more convenient than special JTAG adapters. <br><br> <a href=""><img src="https://habrastorage.org/webt/mn/8a/jd/mn8ajdh40gum3fhcrdujj8m-sho.jpeg"></a> <br>  <i><font color="gray">Mojo FPGA board with Spartan-6 FPGA chip</font></i> <br><br>  Although there are many I / O pins on the Mojo, no peripherals are sold with it, except for eight LEDs.  It would be more pleasant to experiment with the board, if there are buttons, seven-segment displays, VGA output, sensors, and so on.  (They are easy to connect to Mojo, but it would be convenient to have it included).  In addition, some development boards have external RAM, and Mojo does not.  This is a problem for applications like a logic analyzer that requires a lot of memory.  <a href="https://habr.com/ru/post/357718/"><sup>eleven</sup></a> <a name="11_11"></a>  (Although you can extend Mojo with <a href="https://embeddedmicro.com/products/io-shield">IO</a> <a href="https://embeddedmicro.com/products/sdram-shield">lining</a> or <a href="https://embeddedmicro.com/products/sdram-shield">RAM lining</a> ). <br><br>  A good book to get started with Mojo is <a href="https://www.amazon.com/Programming-FPGAs-Getting-Started-Verilog/dp/125964376X/">‚ÄúFPGA Programming</a> . <a href="https://www.amazon.com/Programming-FPGAs-Getting-Started-Verilog/dp/125964376X/">‚Äù</a>  It also describes the much cheaper <a href="http://papilio.cc/index.php%3Fn%3DPapilio.PapilioOne">Papilo One</a> and <a href="https://numato.com/product/elbert-v2-spartan-3a-fpga-development-board">Elbert 2</a> motherboards.  If you want to see other options, here is a <a href="https://joelw.id.au/FPGA/CheapFPGADevelopmentBoards">list of FPGA development boards</a> . <br><br><h1>  Conclusion </h1><br>  The task of FizzBuzz is impractical to implement on FPGA, but it was interesting, I learned a lot about FPGA programming.  But of course, I won‚Äôt get a job if the FizzBuzz question is asked for an interview!  My <a href="https://github.com/shirriff/fpga-fizzbuzz">code is on GitHub</a> , but keep in mind that I'm still new to this business. <br><br><h1>  Notes and links </h1><br><a name="1"></a>  1. Implementing a microprocessor on an FPGA is a trivial task.  For example, with the Spartan 6 chip, you can click a couple of buttons in the IDE wizard - and it will generate a circuit for <a href="https://www.xilinx.com/products/design-tools/microblaze.html">the MicroBlaze processor</a> .  Therefore, an intelligent person would write FizzBuzz code in a few lines of C, and then run it on the processor inside the FPGA.  But for me it is too easy.  <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="2"></a>  2. The start bit is required, otherwise the receiver will not be able to determine the beginning of the character if the first bit of the character is 1. <br><br><a name="3"></a>  3. Since in Mojo the clock frequency is 50 MHz, then at 9600 baud each bit will take 50000000/9600 or approximately 5208 cycles.  This is not a very high speed, so for the experiment I ran the code at a speed of 10 million baud (counting up to five cycles for each bit) - and the circuit survived (the USB-to-serial interface only supports speed up to 230400 baud, so I checked the result on the oscilloscope).  <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="4"></a>  4. In Verilog, <code>&lt;=</code> is a non-blocking assignment operator, and <code>=</code> is a blocking assignment operator.  Non-blocking assignments occur in parallel and are usually used for sequential logic (clock trigger).  Blocking assignments are used for combinatorial logic (without ticks).  This is a bit confusing, see <a href="https://www.nandland.com/articles/blocking-nonblocking-verilog.html">here</a> for more details.  <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="5"></a>  5. I used not a binary, but a binary-decimal counter, so the remainder of the division by 5 is determined almost trivially, looking at the last digit.  But the remainder of the division by 3 is non-trivial, so I had to leave the counter option.  <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="6"></a>  6. It was impossible to send serial input directly to the computer, because it does not have a serial port.  Instead, I used the USB-to-serial <a href="https://www.adafruit.com/product/284">adapter</a> , <a href="https://www.adafruit.com/product/284">FTDI Friend</a> from Adafruit.  This adapter can also accept a 3.3-volt signal, in contrast to the inconvenient +/‚àí 15 volts in the original RS-232.  <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="7"></a>  7. Debugging FPGA is completely different from debugging a program.  Since the FPGA is essentially a black box, you first need to check everything in the simulator, otherwise you will go to the <a href="http://zipcpu.com/blog/2017/05/19/fpga-hell.html">"FPGA-hell"</a> with blinking LEDs, trying to understand what is happening.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of debugging, to simulate a circuit, you need to write a ‚Äútestbench‚Äù (testbench) - the Verilog code, which at different times provides different input data ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Then run the simulator (below) and check that the output is correct. </font><i><font color="gray"><font style="vertical-align: inherit;">Xilinx's </font></font></i><i><font color="gray"><a href="https://www.xilinx.com/products/design-tools/isim.html"><font style="vertical-align: inherit;">ISim simulator</font></a></font></i><i><font color="gray"><font style="vertical-align: inherit;"> allows you to check the FPGA circuit.</font></font></i><font style="vertical-align: inherit;"> If something goes wrong, the simulator lets you go over the internal signals and identify the problem. </font><font style="vertical-align: inherit;">After complete testing in the simulator when running on a real FPGA, my code has only the most trivial problems. </font><font style="vertical-align: inherit;">The main one was that I assigned a serial output to the wrong contact, so there was no output.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/d1/za/cm/d1zacmfmosd0qmgttm8fkem9ldq.png"></a> <br> <i><font color="gray"><a href="https://www.xilinx.com/products/design-tools/isim.html"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></font></i> <br><br><font style="vertical-align: inherit;"></font> <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="8"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Spartan 6 FPGA supports several types of triggers. </font><font style="vertical-align: inherit;">FDRE is a D-flip-flop with a synchronous reset / set-up input and clock operation.</font></font> <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="9"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Configurable Spartan 6 FPGA (CLB) logic blocks are quite complex. They contain LUT modules, 8 flip-flops, wide multiplexers, logic, distributed RAM, and shift registers. The hard-soldered components of these blocks slightly reduce flexibility, but greatly simplify the design of the matrix switches. CLB is described in detail in the CLB </font></font><a href="https://www.xilinx.com/support/documentation/user_guides/ug384.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There are other types of blocks in the Spartan 6 FPGA, including clock generation units and DSP units capable of fast multiplication of 18 √ó 18 bits.</font></font> <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="10"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. An alternative to the Verilog language is </font></font><a href="https://en.wikipedia.org/wiki/VHDL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is also supported by the development environment. </font><font style="vertical-align: inherit;">Mojo also supports </font></font><a href="https://embeddedmicro.com/blogs/news/lucid-and-the-mojo-ide"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lucid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a simpler FPGA language, developed by the Mojo team. </font><font style="vertical-align: inherit;">Mojo </font></font><a href="https://embeddedmicro.com/pages/lucid"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lucid Guides</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> explain the language, and there is also a </font></font><a href="https://www.amazon.com/Learning-FPGAs-Digital-Design-Beginners/dp/1491965495/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on this topic. </font><font style="vertical-align: inherit;">However, I decided that it is better to learn the standard language than Lucid.</font></font> <a href="https://habr.com/ru/post/357718/">‚Üë</a> <br><br><a name="11"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Mojo does not have external RAM, but there are 576 kilobits of internal memory. </font><font style="vertical-align: inherit;">Although this is a tiny amount compared to boards that have megabytes of external DRAM.</font></font> <a href="https://habr.com/ru/post/357718/">‚Üë</a> </div><p>Source: <a href="https://habr.com/ru/post/357718/">https://habr.com/ru/post/357718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357706/index.html">Haskell - knight's move 3. Conclusion</a></li>
<li><a href="../357710/index.html">The fate of the open source project after the death of the programmer</a></li>
<li><a href="../357712/index.html">Detective story with CMake 3.10 and Android Studio</a></li>
<li><a href="../357714/index.html">Semaphores, races, critical sections and Scratch. Plants vs. Zombies</a></li>
<li><a href="../357716/index.html">Delphi: the fastest DataSet (TJvMemoryData, TMemTableEh, TdxMemData, TkbmMemTable)</a></li>
<li><a href="../357720/index.html">Web development - where to start?</a></li>
<li><a href="../357724/index.html">Gmail is not working</a></li>
<li><a href="../357726/index.html">Dropbox Practical magic lessons</a></li>
<li><a href="../357750/index.html">Survey: Google Reader after a while</a></li>
<li><a href="../357752/index.html">"Angry cat" has already earned millions of dollars (up to $ 100 million)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>