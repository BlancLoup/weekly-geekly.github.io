<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to just write a distributed web service in Python + AMQP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. I have been writing in Python for quite some time. Recently had to deal with RabbitMQ. I like it. Because he without any problems (it is cle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to just write a distributed web service in Python + AMQP</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr.  I have been writing in Python for quite some time.  Recently had to deal with RabbitMQ.  I like it.  Because he without any problems (it is clear that with some subtleties) is going to cluster.  Then I thought: it would be nice to use it as a message queue in a piece of the API of the project I'm working on.  The API itself is written in tornado, the main point was to exclude the blocking code from the API.  All synchronous operations were performed in the thread pool. <br><br>  The first thing I decided was to make a separate process (s) ‚Äúworker‚Äù, which would take over all the synchronous work.  I conceived that the ‚Äúworker‚Äù was as simple as possible, and made tasks from the queue one after another.  Say I chose something from the database, answered, took over the next task, and so on.  The workers themselves can be run a lot and then AMQP is already playing the role of some kind of IPC. <br><br>  After some time, a module has grown out of it, which assumes all the routine associated with AMQP and the transfer of messages back and forth, and also compresses them with gzip if there is too much data.  So was born the <a href="https://github.com/mosquito/crew">crew</a> .  Actually, using it, we will write a simple API that will consist of a server on tornado and simple and uncomplicated ‚Äúworker‚Äù processes.  Looking ahead, I‚Äôll say that all code <a href="https://github.com/mosquito/crew">is available on github</a> , and what I‚Äôm going to talk about next is collected <a href="https://github.com/mosquito/crew/tree/master/example">in the example folder</a> . <br><a name="habracut"></a><br><h4>  Training </h4><br>  So, let's understand in order.  The first thing we need to do is install RabbitMQ.  How to do this, I will not describe.  Let me just say that on the same ubunt he is put and works out of the box.  On my Mac, the only thing I had to do was put LaunchRocket, which collected all the services that were installed through homebrew and brought to the GUI: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/759/c16/819/759c16819dc240848d8fbb70a4829731.jpg" alt="LaunchRocket"><br><br>  Next we create our project virtualenv and install the module itself through pip: <br><br><pre><code class="bash hljs">mkdir -p api <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> api virtualenv env <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> env/bin/activate pip install crew tornado</code> </pre> <br><br>  In the module dependencies, the tornado is not intentionally indicated, since it may not be on the host with a worker.  And web parts usually create requirements.txt, where all other dependencies are listed. <br><br>  I will write the code in parts so as not to disturb the order of the narration.  What we will have in the end, you can see <a href="https://github.com/mosquito/crew/blob/master/example/master.py">here</a> . <br><br><h4>  Write the code </h4><br>  The tornado server itself consists of two parts.  In the first part, we define handlers request handlers, and in the second, an event-loop is run.  Let's write the server and create our first api method. <br><br>  Master.py file: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># encoding: utf-8 import tornado.ioloop import tornado.gen import tornado.web import tornado.options class MainHandler(tornado.web.RequestHandler): @tornado.gen.coroutine def get(self): #   test c  100 resp = yield self.application.crew.call('test', priority=100) self.write("{0}: {1}".format(type(resp).__name__, str(resp))) application = tornado.web.Application( [ ('/', MainHandler), ], autoreload=True, debug=True, ) if __name__ == "__main__": tornado.options.parse_command_line() application.listen(8888) tornado.ioloop.IOLoop.instance().start()</span></span></code> </pre><br><br>  Thanks to coroutine in a tornado, the code looks easy.  You can write the same without coroutine. <br><br>  Master.py file: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   test c  100 self.application.crew.call('test', priority=100, callback=self._on_response) def _on_response(resp, headers): self.write("{0}: {1}".format(type(resp).__name__, str(resp)))</span></span></code> </pre><br><br>  Our server is ready.  But if we run it, and we go to /, then we will not wait for an answer, there is no one to handle it. <br><br>  Now we write a simple worker: <br><br>  File worker.py: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># encoding: utf-8 from crew.worker import run, context, Task @Task('test') def long_task(req): context.settings.counter += 1 return 'Wake up Neo.\n' run( counter=0, # This is a part of this worker context )</span></span></code> </pre><br><br>  So, as you can see in the code, there is a simple function wrapped by the <a href="http://habrahabr.ru/users/task/" class="user_link">Task</a> Decorator (‚Äútest‚Äù), where test is the unique identifier of the task.  In your worker there can not be two tasks with the same identifiers.  Of course, it would be correct to call the task ‚Äúcrew.example.test‚Äù (which is usually what I call in the production environment), but for our example, simply ‚Äútest‚Äù is enough. <br><br>  Immediately striking context.settings.counter.  This is a kind of context that is initialized in the worker process when the run function is called.  Also, the context already has context.headers - these are the response headers for separating the metadata from the response.  In the example with the callback function, this particular dictionary is passed to _on_response. <br><br>  Headers are reset after each response, but context.settings do not.  I use context.settings to pass to the worker (s) function the connection to the database and, in general, any other object. <br><br>  Also worker processes startup keys, there are not many of them: <br><br><pre> <code class="bash hljs">$ python worker.py --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Usage: worker.py [options] Options: -h, --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> message and <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> -v, --verbose make lots of noise --logging=LOGGING Logging level -H HOST, --host=HOST RabbitMQ host -P PORT, --port=PORT RabbitMQ port</code> </pre><br><br>  URL connection to the database and other variables can be taken from the environment variable.  Therefore, a worker in the parameters waits only for him to connect with AMQP (host and port) and the logging level. <br><br>  So, we start everything and check: <br><br><pre> <code class="bash hljs">$ python master.py &amp; python worker.py</code> </pre><br><br><img src="https://habrastorage.org/files/01a/5d2/2dc/01a5d22dc1af4cf6aac26b656f9fbd50.jpg" alt="image"><br><br><h4>  It works, but what happened behind the screen? </h4><br>  When starting the tornado server, tornado connected to RabbitMQ, created Exchange DLX and started listening to the DLX queue.  This is a Dead-Letter-Exchange - a special queue in which tasks fall, which no worker has taken over a specific timeout.  He also created a queue with a unique identifier, where answers from workers will be received. <br><br>  After running, worker created in turn for each queue wrapped by the Decorator Task and subscribed to them.  When a task arrives, the main-loop worker creates a single thread, controlling the execution time of the task in the main thread and performing the wrapped function.  After return from the wrapped function, it serializes it and enqueues the server in the response queue. <br><br>  After the request is received, the tornado server assigns the task to the appropriate queue, indicating the identifier of its unique queue to which the response should be received.  If no worker has taken the task, then RabbitMQ redirects the task to the exchange DLX and the tornado server receives a message that the queue timeout has expired, generating an exception. <br><br><h4>  Hanging task </h4><br>  To demonstrate how the mechanism for completing tasks, which are hung during execution, works, we will write another web method and task in the worker. <br><br>  In the master.py file add: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> @tornado.gen.coroutine <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: resp = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.application.crew.call( <span class="hljs-string"><span class="hljs-string">'dead'</span></span>, persistent=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, priority=<span class="hljs-number"><span class="hljs-number">255</span></span>, expiration=<span class="hljs-number"><span class="hljs-number">3</span></span>, ) self.write(<span class="hljs-string"><span class="hljs-string">"{0}: {1}"</span></span>.format(type(resp).__name__, str(resp))) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> TimeoutError: self.write(<span class="hljs-string"><span class="hljs-string">'Timeout'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ExpirationError: self.write(<span class="hljs-string"><span class="hljs-string">'All workers are gone'</span></span>)</code> </pre><br><br>  And add it to the list of handlers: <br><br><pre> <code class="python hljs">application = tornado.web.Application( [ (<span class="hljs-string"><span class="hljs-string">r"/"</span></span>, MainHandler), (<span class="hljs-string"><span class="hljs-string">r"/stat"</span></span>, StatHandler), ], autoreload=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, debug=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, )</code> </pre><br><br>  And in worker.py: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@Task('dead') def infinite_loop_task(req): while True: pass</span></span></code> </pre><br><br>  As you can see from the example above, the task will go into an infinite loop.  However, if the task fails in 3 seconds (counting the time it takes it to get out of the queue), the main loop in the worker will send the SystemExit exception to the stream.  And yes, you have to process it. <br><br><h4>  Context </h4><br>  As mentioned above, the context is such a special object that is imported and has several built-in variables. <br><br>  Let's make simple statistics on the answers of our worker. <br><br>  Add the following handler to the master.py file: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> @tornado.gen.coroutine <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> resp = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.application.crew.call(<span class="hljs-string"><span class="hljs-string">'stat'</span></span>, persistent=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, priority=<span class="hljs-number"><span class="hljs-number">0</span></span>) self.write(<span class="hljs-string"><span class="hljs-string">"{0}: {1}"</span></span>.format(type(resp).__name__, str(resp)))</code> </pre><br><br>  Also register in the list of request handlers: <br><br><pre> <code class="python hljs">application = tornado.web.Application( [ (<span class="hljs-string"><span class="hljs-string">r"/"</span></span>, MainHandler), (<span class="hljs-string"><span class="hljs-string">r"/fast"</span></span>, FastHandler), (<span class="hljs-string"><span class="hljs-string">r"/stat"</span></span>, StatHandler), ], autoreload=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, debug=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, )</code> </pre><br><br>  This handler is not very different from the previous ones, it simply returns the value that the worker passed to him. <br><br>  Now the task itself. <br><br>  In the file worker.py add: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@Task('stat') def get_counter(req): context.settings.counter += 1 return 'I\'m worker "%s". And I serve %s tasks' % (context.settings.uuid, context.settings.counter)</span></span></code> </pre><br><br>  The function returns a string with information about the number of tasks processed by the worker. <br><br><h4>  PubSub and Long polling </h4><br>  Now we implement a couple of handlers.  One at the request will just hang and wait, and the second will take POST data.  After the transfer of the latter, the first will give them. <br><br>  master.py: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LongPoolingHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> LISTENERS = [] @tornado.web.asynchronous <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.LISTENERS.append(self.response) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data)</span></span></span><span class="hljs-function">:</span></span> self.finish(str(data)) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">responder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cls.LISTENERS: cb(data) cls.LISTENERS = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PublishHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> @tornado.gen.coroutine <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> resp = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.application.crew.call(<span class="hljs-string"><span class="hljs-string">'publish'</span></span>, self.request.body) self.finish(str(resp)) ... application = tornado.web.Application( [ (<span class="hljs-string"><span class="hljs-string">r"/"</span></span>, MainHandler), (<span class="hljs-string"><span class="hljs-string">r"/stat"</span></span>, StatHandler), (<span class="hljs-string"><span class="hljs-string">r"/fast"</span></span>, FastHandler), (<span class="hljs-string"><span class="hljs-string">r'/subscribe'</span></span>, LongPoolingHandler), (<span class="hljs-string"><span class="hljs-string">r'/publish'</span></span>, PublishHandler), ], autoreload=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, debug=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, ) application.crew = Client() application.crew.subscribe(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, LongPoolingHandler.responder) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: application.crew.connect() tornado.options.parse_command_line() application.listen(<span class="hljs-number"><span class="hljs-number">8888</span></span>) tornado.ioloop.IOLoop.instance().start()</code> </pre><br><br>  Let's write the publish task. <br><br>  worker.py: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@Task('publish') def publish(req): context.pubsub.publish('test', req)</span></span></code> </pre><br><br>  If you do not need to transfer control to the worker, you can simply publish directly from the tornado server <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PublishHandler2</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> self.application.crew.publish(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, self.request.body)</code> </pre><br><br><h4>  Parallel execution of tasks </h4><br>  Often there is a situation where we can perform several tasks in parallel.  The crew has a little syntactic sugar for this: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Multitaskhandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> @tornado.gen.coroutine <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.application.crew.parallel() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mc: <span class="hljs-comment"><span class="hljs-comment"># mc - multiple calls mc.call('test') mc.call('stat') test_result, stat_result = yield mc.result() self.set_header('Content-Type', 'text/plain') self.write("Test result: {0}\nStat result: {1}".format(test_result, stat_result))</span></span></code> </pre><br><br>  In this case, the task will be assigned two tasks in parallel and the exit from with will be made at the end of the last. <br><br>  But you need to be careful, as some task may cause an exception.  It will be equated directly to the variable.  Thus, you need to check if test_result and stat_result are not instances of the Exception class. <br><br><h4>  Future plans </h4><br>  When <a href="http://habrahabr.ru/users/eigrad/" class="user_link">eigrad</a> offered to write an interlayer, with which you can start any wsgi application using the crew, I immediately liked this idea.  Just imagine, requests will not rush to your wsgi application, but will flow evenly through the queue at wsgi-worker. <br><br>  I have never written a wsgi server and do not even know where to start.  But you can help me, pull-requests I accept. <br><br>  I also think to add a client for another popular asynchronous framework, for twisted.  But while I deal with it, I don‚Äôt have enough free time. <br><br><h4>  Thanks </h4><br>  Thanks to the developers of RabbitMQ and AMQP.  Great ideas. <br><br>  Also thank you, readers.  I hope you do not waste time. </div><p>Source: <a href="https://habr.com/ru/post/241740/">https://habr.com/ru/post/241740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241726/index.html">‚ÄúSled leads to Russia‚Äù: Russian hackers accused of breaking NATO systems</a></li>
<li><a href="../241728/index.html">Electronic "ball of fate" on ATtiny13</a></li>
<li><a href="../241730/index.html">How to make profitable design development sites (part 2)</a></li>
<li><a href="../241732/index.html">Autopsy revealed: blame space</a></li>
<li><a href="../241738/index.html">Paired goods. Placement of goods on the trading floor</a></li>
<li><a href="../241742/index.html">Xbox One gamepad for PC games</a></li>
<li><a href="../241744/index.html">TypeScript and the path to version 2.0</a></li>
<li><a href="../241746/index.html">Gentlemen Access Development Kit</a></li>
<li><a href="../241748/index.html">We design information architecture for e-commerce. Part 2</a></li>
<li><a href="../241752/index.html">"Immersed" servers under water!?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>