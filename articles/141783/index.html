<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Workflow organization: engine state management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the article - Organization of workflows: synchronization channel . Continuation was born as an attempt to write an e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Workflow organization: engine state management</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the article - <a href="http://habrahabr.ru/post/141509/">Organization of workflows: synchronization channel</a> .  Continuation was born as an attempt to write an example of using the approach with synchronous messages. <br><br>  In this part, I want to show by example how to manage and display the state of the engine with the workflow using synchronous messages between the threads.  And show how to bypass the problem of interlocking threads when closing an application. <br><br>  Let's go back to the example from the previous article.  We have a graphical interface that displays the state of the engine with the workflow.  Suppose the engine can be started, stopped, paused and, accordingly, removed from the pause.  To implement this behavior, the easiest way to apply something similar to the design patterns of the state machine and the observer. <br><a name="habracut"></a><br>  To begin with, we will define the set of engine states.  The engine will be asynchronous, so the transition states will also be in the state set.  I got the following set of states: NotStarted, StartPending, Started, PausePending, Paused, ResumePending, StopPending. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      These states will primarily be used to change the state of a GUI.  Ie, the GUI will receive a notification about the state change of the engine, and display this state accordingly.  For example, when switching to the NotStarted state, the GUI should show the ‚ÄúStart‚Äù button, and the ‚ÄúPause‚Äù buttons ‚ÄúContinue‚Äù and ‚ÄúStop‚Äù should be disabled.  Accordingly, when switching to the Paused state, the ‚ÄúStart‚Äù and ‚ÄúPause‚Äù buttons will be locked, and the ‚ÄúContinue‚Äù and ‚ÄúStop‚Äù buttons must be unlocked. <br><br>  Let's take a look at how the engine status notification handler can look like, using the example of the WTL dialog with the corresponding control buttons: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMainDlg::OnStateChanged(EngineState::State state) { <span class="hljs-comment"><span class="hljs-comment">//    ,     GUI     CSyncChannel, //              //   Pending ,   ,       //          GetDlgItem(IDC_BUTTON_START).EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_STOP).EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_PAUSE).EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CONTINUE).EnableWindow(FALSE); switch (state) { case EngineState::NotStarted: GetDlgItem(IDC_BUTTON_START).EnableWindow(TRUE); break; case EngineState::Started: GetDlgItem(IDC_BUTTON_STOP).EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_PAUSE).EnableWindow(TRUE); break; case EngineState::Paused: GetDlgItem(IDC_BUTTON_STOP).EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_CONTINUE).EnableWindow(TRUE); break; } }</span></span></code> </pre> <br>  To manage its state, the engine will have a corresponding set of functions: Start, Pause, Resume, Stop, which in the dialog class will be called from the appropriate button handlers. <br><br>  Due to the use of synchronous messages, the transition from one state to another will be carried out synchronously with the flow of the GUI.  That is, while the GUI thread is in the handler for pressing the ‚ÄúStart‚Äù button, the engine cannot transition to the Started or Paused state asynchronously, it waits until the handler for pressing the ‚ÄúStart‚Äù button is completed.  This greatly simplifies the management of engine states. <br><br>  Transition to pending states, such as StartPending, is performed inside a call to control functions, such as Start, and therefore, after exiting the Start function, the engine will have StartPending status.  That is, notification of the transition to the StartPending state will be triggered synchronously, even before the completion of the Start function call. <br><br>  Let's look at the implementation of the engine. <br>  I quote the engine class completely, because  When working with multithreading, any missing part can play a big role. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Engine.h namespace EngineState { enum State { NotStarted, StartPending, Started, PausePending, Paused, ResumePending, StopPending }; }; class IEngineEvents { public: virtual void OnStateChanged(EngineState::State state) = 0; }; class CEngine { public: CEngine(IEngineEvents* listener); ~CEngine(void); public: //      void Start(); void Stop(); void Pause(); void Resume(); public: // GUI          bool ProcessMessage(MSG&amp; msg); private: void WaitForThread(); static DWORD WINAPI ThreadProc(LPVOID param); void Run(); bool CheckStopAndPause(); void ChangeState(EngineState::State state); void OnStateChanged(EngineState::State state); private: CSyncChannel m_syncChannel; //        IEngineEvents* m_listener; HANDLE m_hThread; volatile EngineState::State m_state; };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Engine.cpp CEngine::CEngine(IEngineEvents* listener) : m_listener(listener), m_hThread(NULL), m_state(EngineState::NotStarted) { m_syncChannel.Create(GetCurrentThreadId()); } CEngine::~CEngine(void) { //      ,      m_state = EngineState::StopPending; //  ,    . //          GUI,   . //  ,       , //  m_syncChannel,      . m_syncChannel.Close(); //     . WaitForThread(); } void CEngine::WaitForThread() { if (m_hThread) { //    . //         : // StopPending  NotStarted _ASSERT(m_state == EngineState::StopPending || m_state == EngineState::NotStarted); //      DWORD waitResult = WaitForSingleObject(m_hThread, INFINITE); _ASSERT(waitResult == WAIT_OBJECT_0); //    ,    HANDLE   CloseHandle(m_hThread); m_hThread = NULL; } } void CEngine::Start() { //   ,   GUI  //        ,      //      if (m_state == EngineState::NotStarted) { //   Start   ,    , //         //       ,     WaitForThread(); //    , //   this,      Run    m_hThread = CreateThread(NULL, 0, CEngine::ThreadProc, this, 0, NULL); if (m_hThread) { //     StartPending //       ChangeState(EngineState::Started) //  ,      SyncChannel, //       , //    ,        "Start" //     StartPending    , //    Started    ChangeState(EngineState::StartPending); } } } void CEngine::Stop() { //   ,   GUI  if (m_state != EngineState::NotStarted &amp;&amp; m_state != EngineState::StopPending) { //   ,          ChangeState(EngineState::StopPending); } //    ,     //      //       ChangeState(EngineState::Stopped) //         WaitForThread } void CEngine::Pause() { //   ,   GUI  if (m_state == EngineState::Started) { //    PausePending     Started ChangeState(EngineState::PausePending); } } void CEngine::Resume() { //   ,   GUI  if (m_state == EngineState::Paused) { //    ResumePending     Paused ChangeState(EngineState::ResumePending); } } bool CEngine::ProcessMessage(MSG&amp; msg) { // GUI         return m_syncChannel.ProcessMessage(msg); } DWORD WINAPI CEngine::ThreadProc(LPVOID param) { //    ,   //        Run reinterpret_cast&lt;CEngine*&gt;(param)-&gt;Run(); return 0; } void CEngine::Run() { //  GUI  ,     ChangeState(EngineState::Started); for (;;) { //    ,   -  //          if (!CheckStopAndPause()) { break; } //    -  ,    :) Sleep(1000); } //   ,     ChangeState(EngineState::NotStarted); //     NotStarted   //  -        //        WaitForSingleObject } bool CEngine::CheckStopAndPause() { //       . //        GUI. if (m_state == EngineState::StopPending) { //    Stop,     return false; } if (m_state == EngineState::PausePending) { //     , //    GUI     //        ChangeState(EngineState::Paused); while (m_state == EngineState::Paused) { Sleep(100); } if (m_state == EngineState::StopPending) { //    Stop,     return false; } //      //    GUI         ChangeState(EngineState::Started); } //       return true; } void CEngine::ChangeState(EngineState::State state) { //       , //    GUI ,  m_syncChannel m_syncChannel.Execute(boost::bind(&amp;CEngine::OnStateChanged, this, state)); } void CEngine::OnStateChanged(EngineState::State state) { //      GUI ,   m_state //     m_state       //      ,       //             GUI  m_state = state; m_listener-&gt;OnStateChanged(m_state); }</span></span></code> </pre><br>  Using the CEngine class. <br>  In my example, the CEngine class object is declared a member of the WTL dialog class. <br>  The set of dialogue functions comes down to handlers for pressing the ‚ÄúStart‚Äù, ‚ÄúStop‚Äù, ‚ÄúContinue‚Äù, and ‚ÄúPause‚Äù keys, which resemble the corresponding functions of the CEngine object. <br><br>  Also, the dialog class subscribes to the engine state change notifications using the IEngineEvents interface, the implementation of the OnStateChanged function of this interface was given at the beginning of the article. <br><br>  To provide streaming messages to the CEngine class, the dialog class sets itself as a window message filter using standard WTL :: CMessageLoop :: AddMessageFilter methods, and implements the WTL :: CMessageFilter interface: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMessageFilter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreTranslateMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MSG* pMsg)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  The implementation of the PreTranslateMessage function is reduced to re-calling the CEngine :: ProcessMessage function. <br><br>  To solve the problem of interlocking threads when closing an application, no additional action is required in the dialog class.  This problem is completely solved by using CSyncChannel :: Close in the CEngine class destructor.  Thus, the workflow is fully encapsulated inside the CEngine class, which provides tangible benefits when working with this class. </div><p>Source: <a href="https://habr.com/ru/post/141783/">https://habr.com/ru/post/141783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141777/index.html">Lakes and Oceans on XKCD</a></li>
<li><a href="../141778/index.html">Makes Sense Charity Auction Meeting</a></li>
<li><a href="../141780/index.html">Useful links for learning CSS animations</a></li>
<li><a href="../141781/index.html">The domain Xakep.Ru is divided</a></li>
<li><a href="../141782/index.html">Non-traditional project development path</a></li>
<li><a href="../141784/index.html">How to behave in open space</a></li>
<li><a href="../141785/index.html">Mikrotik OS and automatic switching to the backup channel</a></li>
<li><a href="../141786/index.html">I don't understand how they did it.</a></li>
<li><a href="../141787/index.html">DrupalConf conference materials</a></li>
<li><a href="../141788/index.html">Client analytics: Big Brother knows what you will buy tomorrow and when you change provider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>