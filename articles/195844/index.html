<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What can we expect from Ruby 2.1?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few days ago, Konstantin Haase, one of the key people in the Ruby community, posted an entry in his blog about the preview version of Ruby 2.1. Chan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What can we expect from Ruby 2.1?</h1><div class="post__text post__text-html js-mediator-article">  A few days ago, Konstantin Haase, one of the key people in the Ruby community, posted an <a href="">entry in his blog</a> about the preview version of Ruby 2.1.  Changes between versions 2.0 and 2.1 have accumulated enough to read into his presentation, and better in Russian. <br><a name="habracut"></a><br>  <i>NB: Of course, Ruby 2.1 contains all the great features of the previous version - 2.0.</i>  <i>Changes from previous versions will not be mentioned.</i> <br><br><h4>  Refinement mechanism </h4><br>  It is known that the <abbr title="refinements">refinement</abbr> engine is introduced in Ruby 2.0.  The implementation of this mechanism turned out to be rather inconsistent, therefore, in version 2.0, its functionality was somewhat limited and marked as experimental. <br><br><blockquote>  It is worth recalling that the refinements allow you to apply <abbr title="monkey patches">decoys patches</abbr> in a single Ruby file: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">refine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> + "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">puts</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">".</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span></span></code> </pre> <br>  Outside this file, instances of the <code>String</code> class will not respond to the <code>foo</code> method. <br></blockquote><br>  In the new version of Ruby, updates will not be an experimental feature.  Moreover, they can be applied not only to the top-level scope, but also to individual modules. <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">refine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> + "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">puts</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">".</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  It is important to keep in mind that overreliance on clarifications may lead to the writing of rather confusing code.  The developers of some implementations of Ruby have already stated that they may refuse to support the refinement. <br><br><h4>  Decimal Literals </h4><br>  When working with Ruby, you can see that the floating-point values ‚Äã‚Äãdo not behave in the best way when they are performed on calculations that are familiar with working with decimal fractions: <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">irb(main):001:0&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">30000000000000004</span></span></code> </pre><br>  This behavior leads to the fact that a large number of Ruby-developers begin to use whole numbers, imitating a given number of decimal places when presenting the result.  Of course, this method works well with a strictly specified number of decimal places.  Otherwise, you have to use rational fractions - this is not very bad, but the language does not have a sufficiently convenient syntax to work with them. <br><br>  The new version of Ruby introduces the <code>r</code> suffix to describe decimal and rational fractions: <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">irb(main):001:0&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>r =&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">10</span></span>) irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">002</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>r * <span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br><h4>  Immune strings </h4><br>  If the code contains a string declaration, then each time the line containing the code is executed, Ruby creates a new object of the <code>String</code> class.  This is due to string <abbr title="mutability">mutability</abbr> .  In such cases, <abbr title="symbols">characters</abbr> behave much more efficiently, since they are initialized only once.  However, to compare a character with a string, you need to convert a string to a symbol or a character to a string.  Performing such transformations is a risky operation, opening up the potential for a DoS attack, since the characters are not released during garbage collection, and any character-to-string conversion creates a new string. <br><br>  The only way to protect yourself from negative consequences in this case is to store and use the string as a constant: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAR</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar?</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAR</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Often, to get rid of mutability, perform line freezing.  Freezing the object prevents it from being modified by the Ruby code, but does not give any performance gains: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAR</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">".</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">freeze</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar?</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAR</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  It looks quite ridiculous and cumbersome.  Fortunately, Ruby 2.1 offers a new syntax for solving this problem: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar?</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> == "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  In the above code, an <abbr title="immutable">immutable</abbr> <code>String</code> object will be created, and wherever it is used, it will be initialized only once. <br><br>  It is possible that this syntax may seem strange.  The same code snippet can be rewritten equivalently: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar?</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> == %</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">q</span></span></span><span class="hljs-class">{</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">}</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  In general, the question of applying the suffix <code>f</code> to arrays and hashes remains open. <br><br><h4>  Mandatory Key Arguments </h4><br>  For some reason, the <abbr title="required keyword arguments">obligatory key arguments</abbr> were not mentioned in the announcement of Ruby 2.0.  So Ruby 2.0 introduces the required key arguments: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">a:</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> puts a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-comment"><span class="hljs-comment"># 20 foo # 10</span></span></code> </pre><br>  With this approach to declaring methods, you have to specify the default values ‚Äã‚Äãof the arguments.  This is not always possible, so Ruby 2.1 allows you to specify the required key arguments: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">a:</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> puts a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-comment"><span class="hljs-comment"># 20 foo # ArgumentError: missing keyword: a</span></span></code> </pre><br><h4>  Method declaration returns method name </h4><br>  In previous versions of Ruby, a method declaration with <code>def</code> returned <code>nil</code> . <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; nil</span></span></code> </pre><br>  Now this behavior has changed and the method name is returned as a symbol: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; :foo</span></span></code> </pre><br>  This is useful for metaprogramming and performing such tricks.  For example, does everyone know that the <code>private</code> method can take arguments? <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     foo class Foo def foo end private :foo #  bar   def bar end end</span></span></code> </pre><br>  Now, when <code>def</code> returns the name of the declared method, you can easily make the methods private: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     foo  bar class Foo private def foo end private \ def bar end def baz end end</span></span></code> </pre><br><h4>  Remove extra bytes from strings </h4><br>  Ruby now has a convenient method for removing extra bytes from strings: <br><br><pre> <code class="ruby hljs">some_string.scrub(<span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre><br>  It used to be difficult to achieve the same behavior of this method for all existing Ruby implementations, so a <a href="https://github.com/rkh/coder">library</a> is also available for this. <br><br><h4>  StringScanner supports named captures </h4><br>  Many people like the <code>StringScanner</code> class from the standard language library.  In particular, it is used in Rails to parse route patterns.  Sinatra 2.0 will do the same. <br><br>  In version 1.9, support for named captures was added, but <code>StringScanner</code> did not support them: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'strscan'</span></span> s = StringScanner.new(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) s.scan(<span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;bar&gt;.*)/</span></span>) puts s[<span class="hljs-symbol"><span class="hljs-symbol">:bar</span></span>]</code> </pre><br>  In Ruby 2.0, this code will throw an exception: <br><br><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">TypeError:</span></span> no implicit conversion of Symbol into Integer</code> </pre><br>  But when launched on Ruby 2.1, everything will be fine: <br><br><pre> <code class="ruby hljs">foo</code> </pre><br><h4>  Work with network interfaces </h4><br>  You can now access network interfaces using the <code>Socket.getifaddrs</code> method: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'socket'</span></span> Socket.getifaddrs.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|i|</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{i.name}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{i.addr.ip_address}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.addr.ip? <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  An example of the output of such a program: <br><br><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">lo0:</span></span> fe80::<span class="hljs-number"><span class="hljs-number">1</span></span>%lo<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">lo0:</span></span> <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">lo0:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">en0:</span></span> fe80::<span class="hljs-number"><span class="hljs-number">1240</span></span><span class="hljs-symbol"><span class="hljs-symbol">:f3ff</span></span><span class="hljs-symbol"><span class="hljs-symbol">:fe7e</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">594</span></span>e%en<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">en0:</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">178.30</span></span> <span class="hljs-symbol"><span class="hljs-symbol">en2:</span></span> fe80::<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">e07:</span></span><span class="hljs-number"><span class="hljs-number">54</span></span><span class="hljs-symbol"><span class="hljs-symbol">ff:</span></span><span class="hljs-symbol"><span class="hljs-symbol">fe6f:</span></span><span class="hljs-number"><span class="hljs-number">147</span></span>a%en2</code> </pre><br><h4>  Quick work with numbers for computational tasks </h4><br>  Ruby 2.1 behaves faster when working with large numbers by using 128-bit integers as the internal representation of <code>Bignum</code> objects.  Moreover, the use of the GNU Multiple Precision Arithmetic Library provides an additional boost to performance. <br><br><h4>  Changes in the virtual machine </h4><br>  Now the Ruby virtual machine, along with the use of the global method cache, performs <abbr title="call site caching">caching at the place of the function call</abbr> .  There are <a href="https://speakerdeck.com/rkh/aloha-ruby-conf-2012-message-in-a-bottle">separate slides</a> about it. <br><br><h4>  Rgenc </h4><br>  The new version of Ruby uses a new <abbr title="generational GC">generational generation of garbage</abbr> .  Due to this, garbage collection will be faster.  Prior to this, a conservative garbage collector was used, which operates according to the ‚Äústop the world - mark - sweep‚Äù scheme. <br><br>  In fact, the old collector has not disappeared anywhere.  Such things are difficult to change due to the characteristics of the internal and external Ruby C program interface. <br><br>  However, the Ruby 2.1 virtual machine classifies objects into <i>light</i> and <i>dark</i> .  Depending on the assigned class, the behavior of the garbage collector is determined.  There are operations that make a <i>bright</i> object <i>dark</i> .  For example, working with it from an extension in the C language.  Objects such as open files are <i>dark</i> initially. <br><br>  The new garbage collector works only with <i>light</i> objects. <br><br><h4>  RubyGems Update </h4><br>  RubyGems received an upgrade to version 2.2.0, which brings several minor improvements. <br><br><h4>  Nothing is eternal </h4><br>  Do not forget that the recent release is only a preliminary version, and all of the above may change. </div><p>Source: <a href="https://habr.com/ru/post/195844/">https://habr.com/ru/post/195844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195834/index.html">Linear representation of an octree using the Morton code</a></li>
<li><a href="../195836/index.html">Methods for solving color perception problems</a></li>
<li><a href="../195838/index.html">Methods of forming a measurement with attributes type 1 and 2</a></li>
<li><a href="../195840/index.html">Conceptual model of an individual approach to teachers and students in the organization and planning of the educational process at the university</a></li>
<li><a href="../195842/index.html">Preparation of schedules in MatLab</a></li>
<li><a href="../195846/index.html">Experience of construction of a kopter: WLtoys V949 + MultiWii 2.0</a></li>
<li><a href="../195848/index.html">RailsClub'Moscow 2013. Photos</a></li>
<li><a href="../195850/index.html">Cancel Anti-Piracy Law - Crowd Funding Project from the Association of Internet Users</a></li>
<li><a href="../195852/index.html">New Olympiad in a new language: open registration</a></li>
<li><a href="../195854/index.html">Acceptance of bank card payments in applications - PayOnline Payment SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>