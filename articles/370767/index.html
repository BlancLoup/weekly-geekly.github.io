<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write AI for Vindinium on single-board computers. Part 3: from theory to practice. Effectively hunt for mines in PP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A series of articles on writing AI for multiplayer online game of the bagel genre, limited by the performance of a single-board computer. 

 In this p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write AI for Vindinium on single-board computers. Part 3: from theory to practice. Effectively hunt for mines in PP</h1><div class="post__text post__text-html js-mediator-article">  A series of articles on writing AI for multiplayer online game of the bagel genre, limited by the performance of a single-board computer. <br><br>  In this part of the article we will look at one of the most understandable and obedient AI in bagels, write simple rules that can be easily managed and talk about collecting statistics. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/311/ba4/f85/311ba4f85b8a4d3ebc7f65eed79d86ba.png" alt="image"></div><br>  But before that, a little bit about the sublime: <a href="https://geektimes.ru/users/janvarev/" class="user_link">janvarev</a> launched a very convenient <a href="http://janvarev.com/VindiniumLeaderboard">leaderboard</a> , by which you can track your ranking among players who played for ten days.  Join you too!  The first five users of Hiktaims, who will occupy a place higher than <code>Zonko 0.11</code> in the leaderboard on September 30th, will receive a <s>gold</s> postcard from Moscow!  <s>I am a poor student, I live on a scholarship.</s> The only condition is that the bot's nickname must be the same as Hicktimes (or at least look like). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚Üí <a href="https://geektimes.ru/post/291823/">Part 1</a> <br>  ‚Üí <a href="https://geektimes.ru/post/291879/">Part 2</a> <br><a name="habracut"></a><br><h3>  Potential fields ... </h3><br>  First you need to understand what are potential fields (PP), for this we need <a href="https://habrahabr.ru/post/262181/">this</a> and <a href="https://habrahabr.ru/post/307368/">this</a> article. <br><br>  In general, PP can be represented as a map of the signal propagation from an object to all cells of the field, skirting obstacles.  Here, for example, the spread of the field near the player R (id = 4), the darker, the weaker the field. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/4b9/234/b20/4b9234b20b33468d87d3f096d7c65a91.png"></div><br>  There are <a href="http://ewanduncan.weebly.com/pathfinding-lee-algorithm.html">implementations using pseudo-code</a> , which allows working on software with most programming languages. <br><br>  The calculation of potential fields for all mines, players and taverns is not a very difficult task, which even a single-board computer can cope with due programmer's straightforwardness. <br><br>  Now look at this task fully: <br><br><ol><li>  We receive from the server information about the state of the game; </li><li>  We get the coordinates of taverns, players, mines - significant game objects; </li><li>  We consider the potential field of all game objects, add to the general dictionary of the form: <code>  - id  -  </code> ; </li><li>  Using magic, we get the decision which way we will go this time. </li></ol><br>  Now we will work on points: <br><br><h3>  1. Information about the state of the game </h3><br>  Frankly speaking, there is nothing to talk about.  The official website is available for quick start kits in 28 programming languages.  By the way, it is very easy to do without them, because there are only POST requests and work with json.  For python, there are requests and json modules that do all the dirty work themselves.  In the second part was given the code that works with server responses. <br><br><h3>  2. Get the coordinates of game objects </h3><br>  Here you need to say a few words: <br><br><ol><li>  The coordinates of all four players are available in <code>game - heroes - <i>hero_id</i> - pos</code> ; </li><li>  Taverns and spawnpoints are the only immutable objects on the map.  They do not move, do not pass from one hand to another.  Their location can be remembered once and for all; </li><li>  The coordinates of the mines will have to get out of the map every time, because they tend to change their owner; </li><li>  Then we pack all this into one ‚Äúname - coordinate‚Äù dictionary, and the mines and taverns should be numbered. </li></ol><br><div class="spoiler">  <b class="spoiler_title">How does the final stage look like for me:</b> <div class="spoiler_text"> <code>{'0_0': [4, 2], <br> '0_1': [4, 13], <br> '0_2': [11, 2], <br> '0_3': [11, 13], <br> 'A_0': [3, 3], <br> 'D_0': [12, 12], <br> 'E_0': [12, 12], <br> 'F_0': [3, 12], <br> 'Q_0': [3, 3], <br> 'R_0': [3, 12], <br> 'S_0': [12, 3], <br> 'W_0': [12, 3], <br> 't_0': [3, 4], <br> 't_1': [3, 11], <br> 't_2': [12, 4], <br> 't_3': [12, 11]}</code> <br>  In this case, the first character of the key indicates the type of object, the last - the number of identical objects.  0, 1, 2, 3, 4 denote mines and their belonging to any player (0 is a neutral mine, 3 is a mine owned by a third player).  Q, W, E, R are four players respectively, A, S, D, F are their spawn points.  The values ‚Äã‚Äãare coordinates. <br></div></div><br><h3>  3. Calculate potential fields </h3><br>  Above, I said that there are no barriers for the implementation of a potential field in my PL.  Personally, I liked a very concise and quick solution <a href="https://github.com/CorvoOrc/Lee-algorithm/blob/master/lee_algo.py">from here</a> , it‚Äôs only worth transferring a part of the emit function to your code, with a bit of fine-tuning with a file.  It is necessary to divide all objects into three categories: <br><br>  - Emptiness - saves and distributes further the charge of the field.  Spunpoints and empty cells belong to such objects.  By the way, a spunpoint must spread a charge, even if a character is standing on it. <br><br>  - Barrier - does not save or distribute further the charge of the field.  Such objects are all obstacles with which the player cannot interact (marked on the map "##"). <br><br>  - Battery - retains the value of the charge, but does not distribute further.  This is necessary so that the field goes around these objects.  Such objects are mines, players, taverns. If, for example, a player blocks a passage a width of one square, the signal will not be able to spread further. <br><br>  Now, if it makes sense to bother with the speed of work, you need to divide the task into N parts (in the case of a single-board quad-core computer N = 3, in order to save one core for the main process and for the internal needs of the operating system) and feed the map and coordinates to the processes to get potential maps of all objects (my implementation on Python3 in one thread does not cope with a map size of 28x28 with 40+ objects, it is necessary to parallelize). <br><br><div class="spoiler">  <b class="spoiler_title">Multiprocessing for python</b> <div class="spoiler_text">  I use the module concurrent.futures, I beckon the simplicity of working with processes and threads. <br>  How do I break a task: <br><br><pre> <code class="python hljs">g = list(board.objects.keys()) <span class="hljs-comment"><span class="hljs-comment"># ,    ,     #      if len(g)%3 == 0: missions = (g[:len(g)//3], g[len(g)//3:2*len(g)//3], g[2*len(g)//3:]) else: missions = (g[:len(g)//3+1], g[len(g)//3+1:2*len(g)//3+1] , g[2*len(g)//3+1:]) pot_field = zero_field(data['game']['board']['size']) #   ,       with concurrent.futures.ProcessPoolExecutor(max_workers=3) as pool: pp = [] for i in range(3): #worker_layer       pp.append(pool.submit(worker_layer, board, targets=missions[i], coors=targets)) for i in pp: m = i.result() #        if pot_field =='': pot_field = m else: for key in pot_field.keys(): if key in m: pot_field[key].update(m[key])</span></span></code> </pre><br></div></div><br><h3>  4. Magic </h3><br>  Now we can turn to any point of the map to find out the distance of objects to it. <br><br><div class="spoiler">  <b class="spoiler_title">Starter kit to build is not the most intelligent AI</b> <div class="spoiler_text">  In order to verify that we are still doing everything correctly, I propose such a simple, but not without flaws, scheme: <br><br><ol><li>  Take five points from our object: (x, y) - Stay, (x-1, y) - North, (x + 1, y) - South, (x, y-1) - West, (x, y + 1) - East.  Eliminate those points that run into barriers ("##"). </li><li>  For each of the remaining points: <br><br><ul><li>  Find the signal value from the nearest tavern, the nearest not to our mine (= the smallest signal value for the selected categories); </li><li>  Take answer = 0; </li><li>  We use the rule for the nearest mine: <br><br><ul><li>  If our_health &lt;21 and distance_to_working == 0, then answer- = 100; </li><li>  Otherwise, if the distance to the mine == 0, then answer + = 990; </li><li>  Otherwise, answer + = 49 + mod (50, distance_to + 1); </li></ul><br></li><li>  We use the rule for the nearest tavern: <br><br><ul><li>  If our_health&gt; 80 and distance_to_taverny == 0, then answer- = 100; </li><li>  Otherwise, if our health is&gt; 50 or gold_number &lt;2, then ignore; </li><li>  Otherwise, if distance_to_ tavern == 0, then answer + = 100; </li><li>  Otherwise, answer + = mod (mod (200, our_health), distance_to_ tavern + 1); </li></ul><br></li><li>  We use the rule for each enemy: <br><br><ul><li>  If our_health-health_ of the enemy&gt; -19 and the number of employees&gt; 0 and distance == 1, then answer + = 80; </li><li>  Our_Health-Health_Enemy&gt; -19 and number of employees&gt; 0 and distance == 1, then answer + = 100; </li><li>  Otherwise, if the distance is &lt;4 and our_health &lt;45, then answer + = -100 + 8 * distance; </li></ul><br></li></ul></li><li>  Select the point with the highest answer value, send the direction. </li></ol><br></div></div><br>  Pretty clumsy, non-optimized, but for starters, it will.  It was one of the very first AI sketches for <code>Zaraza 0.1</code> .  Try running the AI ‚Äã‚Äãby following these instructions and see a glimpse of the mind.  For how the AI ‚Äã‚Äãplays according to these rules, you can see <a href="http://vindinium.org/uznw35wg">here</a> , <a href="http://vindinium.org/92cpjkh4">here</a> and <a href="http://vindinium.org/s6qq3w7h">here</a> .  It becomes clear that on large maps, where they rarely encounter enemies, the AI ‚Äã‚Äãcan fight with the fighters, simply avoiding meetings, and on medium and small maps, where clashes are inevitable, this primordium of intelligence cannot combat other AI.  We need to work on optimizing the engine. <br><br><h3>  Object exploration: mines </h3><br>  Consider the ways in which you can search for mines on the map: <br><br><h4>  Method 1 - Go to the nearest mine </h4><br><img src="https://habrastorage.org/web/c59/08f/871/c5908f8716ca4aeeb962c5cdcc396791.png"><br><br>  <u>Pros:</u> <br>  + The easiest way. <br><br>  <u>Minuses:</u> <br>  - All other components of this venture <br><br>  <u>Comment:</u> <br>  If you stand at a crossroads with the same distance to the two nearest mines, you can choose any. <br><br>  Three fights, laid out a little higher, reveal all the unviability of this method.  Superfluous moves, illogical movements, turning circles - everything is replete with redundancy. <br><br><h4>  Method 2 - add weight for a good choice. </h4><br><img src="https://habrastorage.org/web/883/843/fde/883843fde3bc44628093459ae702a516.png"><br><br>  <u>Pros:</u> <br>  + Now AI will choose quantitatively more pleasant way. <br>  + Easy to implement. <br><br>  <u>Minuses:</u> <br>  - There is a better way. <br><br>  <u>Comment:</u> <br>  This method is really incredibly good.  We will not look for the closest option, but the best one in the short term.  For implementation, you can use the addition of all weights with the formula, for example, 600 / (n + 1), where n is the distance to the object.  This will help to accurately reach the best place at an equal distance, and also makes more attractive points with more mines.  In this case, it is worth making the mine itself, for example, with a weight of 1000 units, for otherwise the cell next to the two mines will have a similar attractiveness as the mine itself (600/1 = 600/2 + 600/2).  The average Elo points for 100 battles increased from 1550 to 1833 only with a change in the method of searching for mines, this says a lot. <br><br><h4>  Method 3 - some plan that he follows </h4><br><img src="https://habrastorage.org/web/44b/37f/2a8/44b37f2a82c043e9a2a7cd52c59e415d.png"><br>  <i>Part of the map, where this method will be effective</i> <br><br>  The algorithm is as follows: <br><br><ol><li>  We make a list of all the mines that we can conquer with the current amount of health (to successfully mine a mine, you need to have at least 21 health units. Obviously, there will be enough of us for a maximum of 4 mines). </li><li>  Mentally we go to each mine, we win. </li><li>  Now we repeat paragraph 1 and 2, starting from the place of conquering a certain mine exactly until we have a list of all possible scenarios for capturing nearby mines (and for health counters, no more than four mines can be captured), you can even build a tree such combinations.  Fortunately, the distance from each point to the mine we have. </li><li>  You can also look further - to assess the distance to the tavern, because it is a vital thing in this cycle. </li><li>  Choose the most delicious option </li></ol><br>  <u>Pros:</u> <br><br>  + A much better way to find mines. <br>  + Looks for the best "chains" to search for mines. <br>  + The most effective way, if not the existence of rivals. <br><br>  <u>Minuses:</u> <br>  - May be somewhat resource intensive. <br>  - Does not take into account the activities of enemies. <br><br>  <u>Comment:</u> <br>  This method has advantages that cannot be ignored.  If you work in this direction, you can achieve significant success, even sticking to the resources of the single-board.  The estimated number of moves and the number of mines captured can be used as an estimating function or, for example, <code>(  )/(  )</code> .  There may be many interesting ideas. <br><br><h4>  Way geektimes </h4><br>  If you have an idea to find mines, put it in the comments, because I have nothing else to come to mind. <br><br>  But how to make sure that the change in the bot engine made it better? <br><br><h2>  Collect statistics for 50/100/250 games! </h2><br>  Decide on the collected material.  For me, the choice was simple: <br><br>  - viewUrl - a link by which you can view the battle <br>  - the place that we occupied in the battle <br>  - the ratio of our gold and gold of the winner as an indicator of the success of the battle <br>  - current Elo points <br>  - whether we dropped out of the game prematurely (this can happen if there were problems with the Internet or if we crossed the limit of 1 second to send a solution) <br>  - the size of the card (which often correlates with the winning place) <br><br>  Now you need to choose a way to save this information.  If you choose from simple, there are two options: <a href="https://en.wikipedia.org/wiki/Comma-separated_values">.scv</a> and Google Forms.  It should be said that GF may be a more convenient option, as it adds a timestamp from under the box and statistics are available online.  How to enter the answers in the form, you can search for the query "submit google form programming_lang". <br><br><h3>  Task at home </h3><br>  In the meantime, Hiktaim users have question number 2: <br><br><img src="https://habrastorage.org/web/76d/3f1/21c/76d3f121ce044d2e96a2efd36c819bc2.png"><br><br>  The screenshot shows a piece of the map: <br>  Q - our player <br>  S - enemy spawnpoint <br><br>  The programmer Oknoz decided to add such a property: if the owner of an enemy spawnpoint has a dangerously small number of health points, then the spawnpoint begins to emit a repulsive potential field, which does not encourage close finding near this spawnpoint.  But the player was trapped, becoming an excellent prey for an enemy player as soon as he was reborn.  Oknoz is thinking about what needs to be done to prevent such situations from happening. <br>  Any guesses?  One of the possible solutions I will write in the comments under the spoiler. <br><br><h3>  Conclusion </h3><br>  So, step by step, you can create a brave and mighty warrior who will cross his swords with alpha-beta clipping and minimax adherents on an equal footing! <br><br>  In the next part, we will consider possible behaviors for taverns, spunpoints, opponents, see how fields are formed, what a blocking is a priority field, and consider whether it is worth painting over the dead ends.  And, of course, a couple of words about competing algorithms. <br><br>  ‚Üí <a href="http://vindinium.org/">Link to Vindinium</a> <br>  ‚Üí The <a href="https://www.reddit.com/r/vindinium/">link to the Vindinium subreddium</a> is a very useful thing, there you can hear the answers to very interesting and intricate questions. <br>  ‚Üí <a href="https://github.com/rakovskij-stanislav/Vindinium_Zaraza">Link to my githab with some old insights from Vindinium</a> </div><p>Source: <a href="https://habr.com/ru/post/370767/">https://habr.com/ru/post/370767/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../370757/index.html">28 major mistakes when photographing products for an online store that can be avoided</a></li>
<li><a href="../370759/index.html">How the work of the largest 3D company Top 3D Shop is arranged from the inside</a></li>
<li><a href="../370761/index.html">Psychologists explained how to persuade people to buy bad goods. It's all about reviews</a></li>
<li><a href="../370763/index.html">Outside the boring blockchain bubble</a></li>
<li><a href="../370765/index.html">Using plastic bags in Kenya equated to felony</a></li>
<li><a href="../370769/index.html">Terry Pratchett's unfinished novels laid under the rink</a></li>
<li><a href="../370771/index.html">Hashflare updates the price list for services and unilaterally changes the terms of contracts</a></li>
<li><a href="../370773/index.html">Quadcopter DJI Mavic Pro Platinum</a></li>
<li><a href="../370775/index.html">Data from Hubble shows that there may be water on the TRAPPIST-1 planets</a></li>
<li><a href="../370777/index.html">The neural network was taught to write excellent reviews about cafes and restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>