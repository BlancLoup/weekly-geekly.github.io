<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New in SObjectizer 5.5.23: wish fulfillment or Pandora's box?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of a reflection article published a month ago, " Is it easy to add new features to the old framework? Flour of choice o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New in SObjectizer 5.5.23: wish fulfillment or Pandora's box?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  This article is a continuation of a reflection article published a month ago, " <a href="https://habr.com/post/423879/">Is it easy to add new features to the old framework? Flour of choice on the example of the development of SObjectizer</a> ".  In that article, the task we wanted to solve in the next version of SObjectizer was described, two approaches to its solution were considered, and the advantages and disadvantages of each approach were listed. <br><br>  Time passed, one of the approaches was brought to life and the new versions of <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> , as well as the accompanying <a href="https://sourceforge.net/p/sobjectizer/wiki/About%2520so5extra/">project so_5_extra</a> , already what is called ‚Äú <a href="https://sourceforge.net/p/sobjectizer/wiki/About%2520so5extra/">breathing deeply</a> ‚Äù.  You can literally take and try. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today we will talk about what was done, why it was done, what it led to.  If it is interesting to someone to follow the development of one of the few living, cross-platform and open actor frameworks for C ++, you are welcome under cat. <br><a name="habracut"></a><br><h1>  How did it all start? </h1><br>  It all started with an attempt to solve the problem of guaranteed cancellation of timers.  The essence of the problem is that when a deferred or periodic message is sent, the programmer can cancel the delivery of the message.  For example: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  After calling <i>timer_id.release (), the</i> timer will no longer send new instances of the my_message message.  But those copies that have already been sent and hit the queue of recipients will not go anywhere.  Over time, they will be extracted from these queues and will be transferred to recipient agents for processing. <br><br>  This problem is a consequence of the basic principles of operation of SObjectizer-5 and does not have a simple solution due to the fact that SObjectizer cannot remove messages from the queues.  It cannot, because in SObjectizer the queues belong to the dispatchers, the dispatchers are different, their queues are also organized in different ways.  Including <a href="https://habr.com/post/353712/">there are dispatchers who are not part of the SObjectizer</a> and SObjectizer, in principle, can not know how these dispatchers work. <br><br>  In general, there is such a feature among native timers SObjectizer.  Not that she too spoiled the life of developers.  But some extra attention needs to be shown.  Especially for beginners who are just familiar with the framework. <br><br>  And then, finally, the hands went so far as to propose a solution for this problem. <br><br><h1>  What solution was chosen? </h1><br>  In the <a href="https://habr.com/post/423879/">previous article</a> , two possible options were considered.  The first option did not require modification of the message delivery mechanism in SObjectizer, but instead required the programmer to explicitly change the type of message sent / received. <br><br>  The second option required a modification of the SObjectizer message delivery mechanism.  It was this path that was chosen because it allowed the fact that the message was sent in a specific way to be hidden from the recipient of the message. <br><br><h2>  What has changed in SObjectizer? </h2><br><h3>  New concept: envelope with message inside </h3><br>  The first component of the implemented solution is the addition of a concept such as an envelope to SObjectizer.  An envelope is a special message, within which lies the actual message (payload).  SObjectizer delivers an envelope with a message to the recipient in almost the usual way.  The principal difference in the processing of the envelope is found only at the very last stage of delivery: <br><br><ul><li>  upon delivery of a regular message, the receiving agent simply searches for a handler for this type of message and, if such a handler is found, the found handler is called and the delivered message is given as a parameter; </li><li>  and upon delivery of the envelope with the message, after the handler is found, an attempt is first made to get the message from the envelope.  And only if the envelope has given the message stored in it, only then is the handler called. </li></ul><br>  There are two key points that have a major impact on what and how envelopes with messages can be used. <br><br>  The first key point is that a message is requested from an envelope only when a handler is found for the message from the receiver.  Those.  only when the message is indeed delivered to the recipient and the recipient will process this message right here and now. <br><br>  The second key point here is that the envelope may not give the message in it.  Ie, for example, the envelope can check the current time and decide that all delivery times have been missed and, therefore, the message has ceased to be relevant and cannot be processed.  Therefore, the envelope will not give the message out.  Accordingly, SObjectizer will simply ignore this envelope and will not take any additional actions. <br><br><h4>  What is an envelope? </h4><br>  An envelope is an implementation of the envelope_t interface, which is defined as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Those.  An envelope is essentially the same message as everyone else.  But with a special sign, which is returned by the so5_message_kind () method. <br><br>  The programmer can develop his envelopes by inheriting from envelope_t (or, which is more convenient, from <a href="">so_5 :: extra :: enveloped_msg :: just_envelope_t</a> ) and overriding the hook methods handler_found_hook () and transformation_hook (). <br><br>  Inside the hook methods, the envelope developer decides whether he wants to send the message inside the envelope for processing / transformation or not.  If so, the developer should call the invoke () method and the invoker object.  If he does not want, then he does not call, in this case the envelope and its contents will be ignored. <br><br><h4>  How do envelopes solve the problem of canceling timers? </h4><br>  The solution that is now implemented in so_5_extra as the so_5 :: extra :: revocable_timer namespace is very simple: with a special sending of a deferred or periodic message, a special envelope is created, inside which is not only the message itself, but the atomic revoked flag.  If this flag is cleared, the message is considered relevant.  If set, the message is considered withdrawn. <br><br>  When a hook method is called on an envelope, the envelope checks the value of the revoked flag.  If the flag is set, the envelope does not give the message out.  Thus, the message processing is not performed even if the timer has already managed to place the message in the recipient's queue. <br><br><h3>  Interface extension abstract_message_box_t </h3><br>  Adding the envelope_t interface is only one part of the envelope implementation in SObjectizer.  The second part is taking into account the fact of the existence of envelopes in the message delivery mechanism inside the SObjectizer. <br><br>  Here, unfortunately, it was not without making changes visible to the user.  In particular, in the class abstract_message_box_t, which defines the interface of all mailboxes in SObjectizer, it was necessary to add another virtual method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  This method is responsible for delivering the message envelope to the recipient with a message like msg_type inside.  Such delivery may vary in implementation details depending on what the mbox is. <br><br>  When adding do_deliver_enveloped_msg () to abstract_message_box_t, we had a choice: to make it a pure virtual method or to suggest some default implementation. <br><br>  If we made do_deliver_enveloped_msg () a pure virtual method, then we would break the compatibility between the SObjectizer versions in branch 5.5.  After all, then those users who wrote their own mbox implementations would have to modify their own mboxes when switching to SObjectizer-5.5.23, otherwise they would not be able to compile with the new version of SObjectizer. <br><br>  We did not want this, so we did not do do_deliver_enveloped_msg () as a pure virtual method in v.5.5.23.  It has a default implementation that simply throws an exception.  Thus, custom user mboxes can continue to work normally with regular messages, but will automatically refuse to accept envelopes.  We found this behavior more acceptable.  Moreover, at the initial stage it is unlikely that envelopes with messages will be used widely, and it is unlikely that custom implementations of SObjectizer mboxes are often found in the ‚Äúwild‚Äù nature;) <br><br>  In addition, there is a far from zero chance that in subsequent major versions of SObjectizer, where we will not look at compatibility with branch 5.5, the interface abstract_message_box_t will undergo major changes.  But we are already running far ahead ... <br><br><h2>  How to send envelopes with messages </h2><br>  SObjectizer 5.5.23 itself does not provide simple means of sending envelopes.  It is assumed that a specific type of envelope and appropriate tools are developed for a specific task for conveniently sending envelopes of a particular type.  An example of this can be seen in <a href="">so_5 :: extra :: revocable_timer</a> , where you need not only to send an envelope, but also to give the user a special timer_id. <br><br>  For simpler situations, you can use the tools from <a href="">so_5 :: extra :: enveloped_msg</a> .  For example, this is how sending a message with a specified limit on its delivery time looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  To make it really fun: envelopes in envelopes </h2><br>  Envelopes are designed to carry inside some messages.  But which ones? <br><br>  Any. <br><br>  And this brings us to an interesting question: is it possible to put an envelope inside another envelope? <br><br>  Yes you can.  How much you want.  The nesting depth is limited only by the common sense of the developer and the stack depth for the recursive call handler_found_hook / transformation_hook. <br><br>  At the same time, SObjectizer goes to meet the developers of their own envelopes: the envelope should not think about what is inside it - a specific message or another envelope.  When a hook method is called on an envelope and the envelope decides that it can return its contents, the envelope simply invokes handler_invoker_t and transmits a reference to its contents to invoke ().  And already invoke () inside itself will understand what it deals with.  And if this is another envelope, then invoke () itself will call the necessary hook method for this envelope. <br><br>  Using the above toolkit from so_5 :: extra :: enveloped_msg, the user can make several nested envelopes like this: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Some examples of using envelopes </h1><br>  Now, after we have walked through the insides of SObjectizer-5.5.23, it‚Äôs time to move on to the more useful for users, application part.  Below are a few examples that are either based on what is already implemented in so_5_extra, or use tools from so_5_extra. <br><br><h2>  Recall timers </h2><br>  Since the whole kitchen with envelopes was started in order to solve the problem of guaranteed recall of timer messages, let's see what happened in the end.  We will use the example from so_5_extra-1.2.0, which uses the tools from the new so_5 :: extra :: revocable_timer namespace: <br><br><div class="spoiler">  <b class="spoiler_title">Recall Timer Example Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  What do we have here? <br><br>  We have an agent who first initiates several timer messages, and then blocks his working thread for a while.  During this time, the timer manages to queue an agent for several requests as a result of timers that have been triggered: several instances of periodic, one instance of first_delayed and second_delayed. <br><br>  Accordingly, when the agent unlocks its thread, it should receive the first periodic and first_delayed.  When processing the first_delayed agent, it cancels the delivery of periodic-second and second_delayed.  Therefore, these signals to the agent should not reach regardless of whether they are already in the agent's queue or not (and they are). <br><br>  We look at the result of the example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Yes, that is right.  Received the first periodic and first_delayed.  Then there is neither periodic, nor second_delayed. <br><br>  But if in the example we replace the ‚Äútimers‚Äù from so_5 :: extra :: revocable_timer with regular timers from SObjectizer, then the result will be different: the agent will be reached by those instances of the periodic and second_delayed signals that have already reached the agent in the queue. <br><br><h2>  Messages with restrictions on delivery time </h2><br>  Another useful thing at times that will become available in so_5_extra-1.2.0 is the delivery of a message with a time limit.  For example, the request_handler agent sends a verify_signature message to the crypto_master agent.  At the same time, request_handler wants verify_signature to be delivered within 5 seconds.  If this does not happen, then there will be no sense in handling verity_signature, the request_handler agent will already stop its work. <br><br>  And the crypto_master agent is a friend who loves to be a bottleneck: sometimes it starts to slow down.  At such moments, messages such as the above verify_signature accumulate in the queue, which can wait until the crypto_master becomes relieved. <br><br>  Suppose that request_handler sent the message verify_signature to the crypto_master agent, but then crypto_master poplohe oh he "stuck" for 10 seconds.  The request_handler agent has already fallen off, i.e.  already sent everyone a denial of service and completed their work.  But the message verify_signature in the crypto_master queue remains!  So, when the crypto_master "otlipnet", then he will take this message and will process this message.  Although it is no longer needed. <br><br>  With the help of the new envelope so_5 :: extra :: enveloped_msg :: time_limited_delivery_t, we can solve this problem: the request_handler agent sends verify_signature nested in the envelope time_limited_delivery_t with a delivery time limit: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Now, if the crypto_master "sticks" and does not have time to get to verify_signature in 5 seconds, then the envelope simply will not give this message for processing.  And crypto_master will not do work that no one needs. <br><br><h2>  Message delivery reports to the recipient </h2><br>  And finally, an example of a curious thing, which is not implemented regularly either in SObjectizer, or in so_5_extra, but which can be done independently. <br><br>  Sometimes you want to get something like a ‚Äúdelivery report‚Äù from a SObjectizer message to a recipient.  Indeed, it is one thing when the message reached the recipient, but the recipient, for whatever his reasons, did not react to it.  Another thing is when the message did not reach the recipient at all.  For example, it was blocked <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Limits/">by an overload protection agent mechanism</a> .  In the first case, the message to which we did not wait for an answer, you can not resend.  But in the second case, it may make sense to re-send the message after some time. <br><br>  Now we will look at how, using envelopes, you can implement the simplest ‚Äúdelivery reports‚Äù mechanism. <br><br>  So, first we will do the necessary preparatory actions: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Now we can define the messages that will be used in the example.  The first message is a request to perform any actions we need.  And the second message is a confirmation that the first message reached the recipient: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  Next, we can define a processor_t agent that will process request_t messages.  But will process with imitation of "sticking".  Those.  it handles request_t, after which it changes its state from st_normal to st_busy.  In the st_busy state, it does nothing and ignores all messages that arrive to it. <br><br>  This means that if the processor_t agent sends three request_t messages in a row, it will process the first one, and the other two will be thrown, because  when processing the first message, the agent will go to st_busy and ignore what will come to him while he is in st_busy. <br><br>  In st_busy, the processor_t agent will spend 2 seconds, after which it will return to st_normal again and will be ready to process new messages. <br><br>  Here‚Äôs how the agent processor_t looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Now we can define the agent requests_generator_t, which has a packet of requests that need to be delivered to the processor_t.  The agent request_generator_t sends the entire pack every 3 seconds, and then waits for delivery confirmation in the form of delivery_receipt_t. <br><br>  When the delivery_recept_t arrives, the requests_generator_t agent throws the delivered request out of the packet.  If the bundle is completely empty, then the work of the example is completed.  If there is still something left, the remaining bundle will be sent again when the next reshipment time comes. <br><br>  So here is the request_generator_t agent code.  It is quite voluminous, but primitive.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can only pay attention to the inside of the send_requests () method, which sends request_t messages nested in a special envelope. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agent code requests_generator_t</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have messages and there are agents who must communicate with these messages. </font><font style="vertical-align: inherit;">Only a small amount remains - to somehow force the delivery_receipt_t messages to arrive when the request_t is delivered to the processor_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done with the help of such an envelope:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, there is nothing complicated. </font><font style="vertical-align: inherit;">We inherit from so_5 :: extra :: enveloped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">This is an auxiliary envelope type that stores the message attached to it and provides a basic implementation of the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () and transformation_hook () </font><font style="vertical-align: inherit;">hooks </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore, we can only save the necessary attributes inside custom_envelope_t and send delivery_receipt_t inside the handler_found_hook () hook.</font></font><br><br>  That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we run this example, we get the following: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it must be said that in practice such a simple custom_envelope_t is hardly suitable for generating delivery reports. </font><font style="vertical-align: inherit;">But if someone is interested in this topic, then it can be discussed in the comments, and not to increase the volume of the article.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What else could be done with envelopes? </font></font></h1><br>  Great question!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To which we ourselves do not yet have an exhaustive answer. </font><font style="vertical-align: inherit;">Probably, the possibilities are limited except by the fantasy of users. </font><font style="vertical-align: inherit;">Well, if something is missing for the realization of fantasies in SObjectizer, then you can tell us about it. </font><font style="vertical-align: inherit;">We always listen. </font><font style="vertical-align: inherit;">And, importantly, sometimes we even do :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integration of agents with mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we speak a little more seriously, then there is another feature that I would like to have at times and which was even planned for so_5_extra-1.2.0. But which, most likely, will not get into release 1.2.0 any more. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea is to simplify the integration of </font></font><a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520chains/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mchains</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and agents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that initially mchains were added to SObjectizer in order to simplify the communication of agents with other parts of the application that are written without agents. For example, there is a main application thread on which user interaction takes place using the GUI. And there are several agent-workers who perform background ‚Äúhard‚Äù work. It is not a problem to send a message to the agent from the main thread: just call normal send. But how to transfer information back?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this mchains were added. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But over time, it turned out that mchains can play a much larger role. You can, in principle, make multi-threaded applications on SObjectizer without agents at all, only on mchain (see more </font></font><a href="https://habr.com/post/358120/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). You can also use mchains as a means of load balancing agents. As a mechanism for solving the problem of producer-consumer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The producer-consumer problem is that if the producer generates messages faster than the consumer can process them, then we are in trouble. The message queues will grow, the performance may degrade over time, or the application will crash altogether due to memory exhaustion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The usual solution we proposed to use in this case is to use</font></font><a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520By%2520Example%2520Collector%2520and%2520Performer%2520Pair/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a couple of collector-performer agents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . You can also use </font></font><a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Limits/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">message limits</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (either as the main protection mechanism or as an addition to the collector-performer). But writing collector-performer requires additional work from the programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But mchains could be used for these purposes with minimal effort from the developer. So, the producer would put the next message in mchain, and the consumer would take messages from this mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the problem is that when a consumer is an agent, it is not very convenient for an agent to work with mchain with the available functions receive () and select (). And this inconvenience could be tried to eliminate with the help of some tool for the integration of agents and mchains.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When developing such a tool, you will need to solve several problems. For example, when a message arrives at mchain, at what point should it be removed from mchain? If the consumer is free and does not process anything, then you can take the message from mchain immediately and give it to the agent-consumer. If the consumer has already been sent a message from mchain, he has not yet managed to process this message, but a new message has already arrived at mchain ... How to be in this case? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an assumption that envelopes can help in this case. So, when we take the first message from mchain and send it to the consumer, we wrap this message in a special envelope. When the envelope sees that the message has been delivered and processed, it requests the next message from mchain (if any).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, everything is not so simple. </font><font style="vertical-align: inherit;">But so far it looks quite solvable. </font><font style="vertical-align: inherit;">And, I hope, a similar mechanism will appear in one of the following versions of so_5_extra.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Were we going to open Pandora‚Äôs box? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that in our case the added possibilities themselves cause ambivalent feelings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, the envelopes have already allowed / allowed to do things that were previously mentioned (and something was just dreamed of). </font><font style="vertical-align: inherit;">For example, these are guaranteed cancellation of timers and a limit on delivery time, delivery reports, the ability to revoke a previously sent message. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, it is not clear what this will lead to later. </font><font style="vertical-align: inherit;">After all, from any opportunity you can make a problem, if you start to exploit this opportunity where necessary and where not. </font><font style="vertical-align: inherit;">So can we open the Pandora's box and we ourselves still can not imagine what awaits us? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains only to be patient and see where all this will lead us.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On the nearest development plans of SObjectizer instead of conclusion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of a conclusion, I would like to talk about how we see the nearest (and not only) future of SObjectizer. If someone doesn‚Äôt like something in our plans, you can express your opinion and influence how SObjectizer-5 will develop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first beta versions of SObjectizer-5.5.23 and so_5_extra-1.2.0 are already fixed and available for download and experiments. There will still be a lot of work to be done in the field of documentation and use cases. Therefore, the official release is planned in the first decade of November. If it works out earlier, we will do it earlier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The release of SObjectizer-5.5.23, to all appearances, will mean that the evolution of branch 5.5 is coming to its final. The very </font></font><a href="https://sourceforge.net/p/sobjectizer/news/2014/10/sobjectizer-v550-released/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first release in this thread took place four years ago, in October 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Since then, SObjectizer-5 has evolved within branch 5.5 without any major breaking changes between versions. It was not easy. Especially given the fact that all this time we had to look at the compilers, which was far from ideal support for C ++ 11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we don‚Äôt see any sense in looking at compatibility inside the 5.5 branch and, especially, on old C ++ compilers. What could have been justified in 2014, when C ++ 14 was just getting ready to be officially adopted, and C ++ 17 was not yet on the horizon, now it looks completely different. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus, in SObjectizer-5.5 itself a fair amount of rakes and props have already accumulated, which appeared because of this very compatibility and which hamper the further development of SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, in the coming months we are going to act on the following scenario: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Development of the next version of so_5_extra, in which I would like to add tools to simplify the writing of tests for agents. Whether it will be so_5_extra-1.3.0 (that is, with breaking changes relative to 1.2.0) or will it be so_5_extra-1.2.1 (that is, without breaking changes) is not yet clear. Let's see how it goes. It is only clear that the next version of so_5_extra will be based on SObjectizer-5.5.</font></font><br><br>  1a.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the next version of so_5_extra needs to do something extra in SObjectizer-5.5, the next version 5.5.24 will be released. If for so_5_extra it is not necessary to make improvements to the SObjectizer core, then version 5.5.23 will be the last significant version in the framework of the 5.5 branch. Minor bug-fix releases will come out. But the development of branch 5.5 itself stops at version 5.5.23 or 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Then a version of SObjectizer-5.6.0 will be released, which will open a new branch. In the 5.6 branch, we will clean the SObjectizer code from all the accumulated crutches and props, as well as from the old rubbish, which has long been marked depressed. Some things are likely to refactor (for example, abstract_message_box_t can be changed), but hardly cardinal. The basic principles of work and the characteristics of SObjectizer-5.5 in SObjectizer-5.6 will remain the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 will require C ++ 14 (at least at the level of GCC-5.5). Visual C ++ compilers below VC ++ 15 (which is from Visual Studio 2017) will not be supported. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Branch 5.6 is considered by us as a stable branch of SObjectizer, which will be relevant until the first version of SObjectizer-5.7 appears.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like to make release of version 5.6.0 in the beginning of 2019, approximately in February. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. After the stabilization of the 5.6 branch, we would like to start working on the 5.7 branch, in which we could review some basic principles of SObjectizer operation. For example, completely abandon the public dispatchers, leaving only private. To alter the mechanism of cooperations and their parent-child relationships, thereby getting rid of the bottleneck during registration / deregistration of cooperations. Remove the division by message / signal. Leave only send / send_delayed / send_periodic to send messages, and hide the methods deliver_message and schedule_timer ‚Äúunder the hood‚Äù. Modify the message dispatch mechanism to either completely remove the dynamic_casts from this process or reduce them to the minimum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, there is where to turn. In this case, SObjectizer-5.7 will already require C ++ 17, without regard to C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at things without rose-colored glasses, then it is good if release 5.7.0 takes place at the end of autumn 2019. That is, The main working version of SObjectizer at 2019 will be the 5.6 branch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. In parallel, all this will develop so_5_extra. Probably, along with SObjectizer-5.6, the so_5_extra-2 version will be released, which during 2019 will incorporate a new functionality, but based on SObjectizer-5.6.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we ourselves see a progressive evolution for SObjectizer-5 with a gradual revision of some of the basic principles of SObjectizer-5. At the same time, we will try to do this as smoothly as possible so that we can switch from one version to another with minimal pain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if someone would like more dramatic and significant changes from SObjectizer, then </font></font><a href="http://eao197.blogspot.com/2018/10/progthoughts-sobjectizer-6.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we have some thoughts on this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In short, you can remake SObjectizer as you like, to the extent that you can implement SObjectizer-6 for another programming language. But we will not do this entirely at our own expense, as it happens with the evolution of SObjectizer-5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this, perhaps, everything. In comments </font></font><a href="https://habr.com/post/423879/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There was a good and constructive discussion. </font><font style="vertical-align: inherit;">It would be useful for us if a similar discussion happened this time. </font><font style="vertical-align: inherit;">As always, we are ready to answer any questions, but on sensible ones, and with pleasure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And to the most patient readers who have reached this line, thank you very much for taking the time to read the article.</font></font></div><p>Source: <a href="https://habr.com/ru/post/426983/">https://habr.com/ru/post/426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426973/index.html">Corporate Sandwiches</a></li>
<li><a href="../426975/index.html">Joker 2018: the impossible is possible</a></li>
<li><a href="../426977/index.html">LibreOffice: a bad dream accountant</a></li>
<li><a href="../426979/index.html">How to learn English for free: 3 banal tools and detailed instructions for each</a></li>
<li><a href="../426981/index.html">10 tricks for advanced dashboarding in Splunk. Part 1</a></li>
<li><a href="../426985/index.html">kubebox and other console shells for Kubernetes</a></li>
<li><a href="../426987/index.html">Learn OpenGL. Lesson 6.3 - Image Based Lighting. Diffuse irradiation</a></li>
<li><a href="../426991/index.html">Startup Digest: 10 nearest IT events in Moscow</a></li>
<li><a href="../426993/index.html">Do I need to learn C to understand how a computer works?</a></li>
<li><a href="../426995/index.html">Recycling harms both products and employees</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>