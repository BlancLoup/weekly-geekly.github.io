<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Go: bytes and strings packages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of one of Ben Johnson's articles from the "Go Walkthrough" series on a more in-depth study of the standard Go library in the context of re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Go: bytes and strings packages</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of one of Ben Johnson's articles from the "Go Walkthrough" series on a more in-depth study of the standard Go library in the context of real-world tasks.</em> </p><br><p>  In the <a href="https://medium.com/%40benbjohnson/go-walkthrough-io-package-8ac5e95a9fbd">previous post,</a> we figured out how to work with byte streams, but sometimes we need to work with a specific set of bytes in memory.  Although byte slices are quite suitable for many tasks, there are quite a few cases when it is better to use the <a href="https://golang.org/pkg/bytes/">bytes</a> package.  We will also look at the <a href="https://golang.org/pkg/strings/">strings</a> package today, since its API is almost identical to bytes, only it works with strings. </p><br><p>  This post is one of a series of articles on a more in-depth analysis of the standard library.  Despite the fact that standard documentation provides a lot of useful information, in the context of real-world tasks it can be difficult to figure out what to use and when.  This series of articles aims to show the use of standard library packages in the context of real-world applications.  If you have questions or comments, you can always email me on Twitter - <a href="https://twitter.com/benbjohnson">@benbjohnson</a> . </p><a name="habracut"></a><br><h2>  Short digression about strings and bytes </h2><br><p>  Rob Pike wrote an excellent and deep post about <a href="https://blog.golang.org/strings">strings, bytes, runes and symbols</a> , but for this post I would like to give a simpler definition from the point of view of the developer. </p><br><p>  Slice byte is a variable sequential set of bytes.  Lightly verbose, so let's try to understand what it means. </p><br><p>  We have slice bytes: </p><br><pre><code class="go hljs">buf := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}</code> </pre> <br><p>  It is changeable, so you can change the elements in it: </p><br><pre> <code class="go hljs">buf[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">// []byte{1,2,3,5}</span></span></code> </pre> <br><p>  You can also change its size: </p><br><pre> <code class="go hljs">buf = buf[:<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-comment"><span class="hljs-comment">// []byte{1,2} buf = append(buf, 100) // []byte{1,2,100}</span></span></code> </pre> <br><p>  And it is sequential, since the bytes in memory go one by one: </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-params"><span class="hljs-params">|2|</span></span><span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-params"><span class="hljs-params">|4</span></span></code> </pre> <br><p>  Strings, on the other <em>hand</em> , are an <em>unchangeable</em> sequential set of <em>fixed-size</em> bytes.  This means that you can not change the lines - just create new ones.  This is important to understand in the context of program performance.  In programs that need very high performance, the constant creation of a large number of lines will create a significant burden on the garbage collector. </p><br><p>  From the developer's point of view, strings are best used when you work with data in UTF-8 ‚Äî they can be used as keys to the map, unlike byte slices, for example, and most APIs use strings to represent string data.  On the other hand, byte slices are much better suited when you need to work with raw bytes, when processing data streams, for example.  They are also more convenient if you want to avoid new allocations of memory and want to reuse memory. </p><br><h2>  Adapting strings and slices for streams </h2><br><p>  One of the most important features of the bytes and strings packages is that they implement <a href="https://golang.org/pkg/io/">io.Reader</a> and <a href="https://golang.org/pkg/io/">io.Writer interfaces</a> for working with bytes and strings in memory. </p><br><h3>  In-memory readers </h3><br><p>  The two self underused functions in the standard Go library are <a href="https://golang.org/pkg/bytes/">bytes.NewReader</a> and <a href="https://golang.org/pkg/strings/">strings.NewReader</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span></span></code> </pre> <br><p>  These functions return the implementation of the <a href="https://golang.org/pkg/io/">io.Reader</a> interface, which serves as a wrapper around a slice of bytes or a string in memory.  But these are not only readers - they also implement other related interfaces, such as <a href="https://golang.org/pkg/io/">io.ReaderAt</a> , <a href="https://golang.org/pkg/io/">io.WriterTo</a> , <a href="https://golang.org/pkg/io/">io.ByteReader</a> , <a href="https://golang.org/pkg/io/">io.ByteScanner</a> , <a href="https://golang.org/pkg/io/">io.RuneReader</a> , <a href="https://golang.org/pkg/io/">io.RuneScanner</a> and <a href="https://golang.org/pkg/io/">io.Seeker</a> . </p><br><p>  I regularly see code where byte and line <a href="https://golang.org/pkg/bytes/">slices</a> are first written in <a href="https://golang.org/pkg/bytes/">bytes.Buffer</a> , and then the buffer is used as a reader: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer buf.WriteString(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) http.Post(<span class="hljs-string"><span class="hljs-string">"http://example.com/"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, &amp;buf)</code> </pre> <br><p>  This approach requires extra memory allocations and can be slow.  It will be much more efficient to use <a href="https://golang.org/pkg/strings/">strings.Reader</a> : </p><br><pre> <code class="go hljs">r := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>) http.Post(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, r)</code> </pre> <br><p>  This method also works when you have many rows or slices of bytes that can be combined with [io.MultiReader] (): </p><br><pre> <code class="go hljs">r := io.MultiReader( strings.NewReader(<span class="hljs-string"><span class="hljs-string">"HEADER"</span></span>), bytes.NewReader([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}), myFile, strings.NewReader(<span class="hljs-string"><span class="hljs-string">"FOOTER"</span></span>), )</code> </pre> <br><h3>  In-memory writer </h3><br><p>  The bytes package also implements the <a href="https://golang.org/pkg/io/">io.Writer</a> interface for slicing bytes in memory using the <a href="https://golang.org/pkg/bytes/">Buffer</a> type.  It implements almost all interfaces of the <a href="https://golang.org/pkg/io">io</a> package, except <a href="https://golang.org/pkg/io/">io.Closer</a> and <a href="https://golang.org/pkg/io/">io.Seeker</a> .  It also has a <a href="https://golang.org/pkg/bytes/">WriteString ()</a> helper method for writing a string to the end of the buffer. </p><br><p>  I actively use Buffer in unit tests to capture the output of service logs.  You can pass a buffer as an argument to <a href="https://golang.org/pkg/log/">log.New ()</a> and check the output later: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer myService.Logger = log.New(&amp;buf, <span class="hljs-string"><span class="hljs-string">""</span></span>, log.LstdFlags) myService.Run() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.Contains(buf.String(), <span class="hljs-string"><span class="hljs-string">"service failed"</span></span>) { t.Fatal(<span class="hljs-string"><span class="hljs-string">"expected log message"</span></span>) }</code> </pre> <br><p>  But in production code, I rarely use <a href="https://golang.org/pkg/bytes/">Buffer</a> .  Despite the name, I do not use it for buffered reading and writing, as there is a <a href="https://golang.org/pkg/bufio">bufio</a> package in the standard library especially for this. </p><br><h2>  Package organization </h2><br><p>  At first glance, the bytes and strings packages seem very large, but in reality they are just a collection of simple utility functions.  We can group them in several categories: </p><br><ul><li>  Comparison functions </li><li>  Verification functions </li><li>  Prefix / Suffix Functions </li><li>  Replacement functions </li><li>  Merge and split functions </li></ul><br><p>  When we understand how these functions are grouped, the seemingly large API will look much more comfortable. </p><br><h2>  Comparison functions </h2><br><p>  When you have two slices of bytes or two lines, you may need to get an answer to two questions.  First, are these two objects equal?  And the second - which of the objects goes before when sorting? </p><br><h3>  Equality </h3><br><p>  The <a href="https://golang.org/pkg/bytes/">Equal ()</a> function answers the first question: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span></code> </pre> <br><p>  This function is only in the bytes package, since strings can be compared using the == operator. </p><br><p>  Although checking for equality may seem like a simple task, there is a popular mistake in using <a href="https://golang.org/pkg/strings/">strings.ToUpper ()</a> to check for equality without registering: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.ToUpper(a) == strings.ToUpper(b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  This approach is wrong, it uses 2 allocations for new lines.  A much more correct approach is to use <a href="https://golang.org/pkg/bytes/">EqualFold ()</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualFold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, t []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualFold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, t </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span></code> </pre> <br><p>  The word Fold here means <a href="https://www.w3.org/International/wiki/Case_folding">Unicode case-folding</a> .  It covers the rules for upper and lower case not only for AZ, but also for other languages, and can convert œÜ to œï. </p><br><h3>  Comparison </h3><br><p>  To find out the order for sorting two slices of bytes or strings, we have the <a href="https://golang.org/pkg/bytes/">Compare ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  This function returns -1 if a is less than b, 1 if a is greater than b, and 0 if a and b are equal.  This function is present in the strings package exclusively for symmetry with bytes.  Russ Cox even calls for the fact that " <a href="">no one should use strings</a> . <a href="">Compare</a> ."  It is easier to use the built-in operators &lt;and&gt;. </p><br><blockquote>  "no one should use strings. Compare", Russ Cox </blockquote><br><p>  Usually you need to compare byte slices or strings when sorting data.  The <a href="https://golang.org/pkg/sort/">sort.Interface</a> interface needs a comparison function for the Less () method.  To translate the ternary form of the Compare () return value into a Boolean value for Less (), it is enough just to check for equality with -1: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ByteSlices [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p ByteSlices)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes.Compare(p[i], p[j]) == <span class="hljs-number"><span class="hljs-number">-1</span></span> }</code> </pre> <br><h2>  Verification functions </h2><br><p>  The bytes and strings packages provide several ways to check or find the value in a string or in a slice byte. </p><br><h3>  Count </h3><br><p>  If you are validating the input data, it may be necessary to check for the presence (or absence) of certain bytes in them.  For this you can use the function <a href="https://golang.org/pkg/bytes/">Contains ()</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b, subslice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, substr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span></code> </pre> <br><p>  For example, you can check for certain bad words: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.Contains(input, <span class="hljs-string"><span class="hljs-string">"darn"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"inappropriate input"</span></span>) }</code> </pre> <br><p>  If you need to find the exact number of occurrences of the required substring, you can use Count (): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Another use of <a href="https://golang.org/pkg/bytes/">Count ()</a> is to count the number of runes in a line.  If you pass an empty slice or an empty string as a sep argument, Count () returns the number of runes + 1. This is different from the output of len (), which returns the number of bytes.  This difference is important if you are working with Unicode multibyte characters: </p><br><pre> <code class="go hljs">strings.Count(<span class="hljs-string"><span class="hljs-string">"I "</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 6 len("I ") // 9</span></span></code> </pre> <br><p>  The first line may seem strange, because in fact there are 5 runes, but do not forget that Count () returns the number of runes plus one. </p><br><h3>  Indexing </h3><br><p>  Checking for an entry is an important task, but sometimes you need to find the exact position of the substring or the desired slice.  You can do this using indexing functions: </p><br><pre> <code class="go hljs">Index(s, sep []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexAny(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, chars <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexByte(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, c <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IndexFunc(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  There are several functions for different cases.  <a href="https://golang.org/pkg/bytes/">Index () is</a> looking for multibyte slices.  <a href="https://golang.org/pkg/bytes/">IndexByte ()</a> finds a single byte in a slice.  <a href="https://golang.org/pkg/bytes/">IndexRune ()</a> searches for a Unicode code point in a UTF-8 string.  <a href="https://golang.org/pkg/bytes/">IndexAny ()</a> works similarly to <a href="https://golang.org/pkg/bytes/">IndexRune ()</a> , but searches for several code points simultaneously.  <a href="https://golang.org/pkg/bytes/">Finally</a> , <a href="https://golang.org/pkg/bytes/">IndexRune ()</a> allows you to use your own function to search for an index. </p><br><p>  There is also a similar set of functions for finding the first position from the end: </p><br><pre> <code class="go hljs">LastIndex(s, sep []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastIndexAny(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, chars <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastIndexByte(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, c <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastIndexFunc(s []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  I usually use little indexing functions, because more often I have to write something more complicated, like parsers. </p><br><h2>  Prefixes, suffixes and deletes </h2><br><p>  Prefixes in programming you will meet quite often.  For example, paths in HTTP addresses are often grouped by functionality using prefixes.  Or, another example - a special character at the beginning of a line, like "@", is used to mention a user. </p><br><p>  The <a href="https://golang.org/pkg/bytes/">HasPrefix ()</a> and <a href="https://golang.org/pkg/bytes/">HasSuffix ()</a> functions allow you to check such cases: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, prefix []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasSuffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, suffix []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasSuffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, suffix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span></code> </pre> <br><p>  These functions may seem too simple to bother with them, but I regularly see the following error when developers forget to check for a zero line size: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'@'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  This code looks simple, but if str is an empty string, you get a panic.  The <a href="https://golang.org/pkg/bytes/">HasPrefix ()</a> function contains this check: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.HasPrefix(str, <span class="hljs-string"><span class="hljs-string">"@"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><h3>  Deletion </h3><br><p>  The term "trimming" in the bytes and strings packages means removing bytes or runes at the beginning and / or end of a slice or string.  The very generalized function for this is <a href="https://golang.org/pkg/bytes/">Trim ()</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cutset </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cutset </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  It removes all runes from the cutset on both sides - from the beginning and end of the line.  You can also delete only from the beginning, or only from the end, using <a href="https://golang.org/pkg/bytes/">TrimLeft ()</a> and <a href="https://golang.org/pkg/bytes/">TrimRight ()</a> respectively. </p><br><p>  But more specific removal options are most often used - removing spaces, for this there is a <a href="https://golang.org/pkg/bytes/">TrimSpace ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  You might think that deleting with a cutset equal to "\ n \ r" may be enough, but TrimSpace () can also remove space characters defined in Unicode.  This includes not only spaces, line breaks, or tabs, but also non-standard characters such as <a href="https://en.wikipedia.org/wiki/Thin_space">"thin space"</a> or <a href="http://www.fileformat.info/info/unicode/char/200a/index.htm">"hair space"</a> . </p><br><p>  <a href="https://golang.org/pkg/bytes/">TrimSpace () is</a> , in fact, just a <a href="">wrapper</a> over <a href="https://golang.org/pkg/bytes/">TrimFunc ()</a> , which defines the characters to be used for deletion: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TrimFunc(s, unicode.IsSpace) }</code> </pre> <br><p>  Thus, you can very simply create your own function, which will remove, say, only spaces at the end of the line: </p><br><pre> <code class="go hljs">TrimRightFunc(s, unicode.IsSpace)</code> </pre> <br><p>  Finally, if you want to remove not characters, but a specific substring on the left or on the right, then there are <a href="https://golang.org/pkg/bytes/">TrimPrefix ()</a> and <a href="https://golang.org/pkg/bytes/">TrimSuffix ()</a> functions for this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, prefix []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimSuffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, suffix []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimSuffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, suffix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  They go hand in hand with the <a href="https://golang.org/pkg/bytes/">HasPrefix ()</a> and <a href="https://golang.org/pkg/bytes/">HasSuffix ()</a> functions to check for the presence of a prefix or suffix, respectively.  For example, I use them to add bash-like configuration file paths in the home directory: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Look up user's home directory. u, err := user.Current() if err != nil { return err } else if u.HomeDir == "" { return errors.New("home directory does not exist") } // Replace tilde prefix with home directory. if strings.HasPrefix(path, "~/") { path = filepath.Join(u.HomeDir, strings.TrimPrefix(path, "~/")) }</span></span></code> </pre> <br><h2>  Replacement functions </h2><br><h3>  Easy replacement </h3><br><p>  Sometimes you need to replace a substring or part of a slice.  For most simple cases, all you need is the <a href="https://golang.org/pkg/bytes/">Replace ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Replace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, old, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Replace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, old, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  It replaces any occurrence of old in your line with new.  If n is -1, all occurrences will be replaced.  This feature is very well suited if you want to replace a simple word with a pattern.  For example, you can allow the user to use the $ NOW pattern and replace it with the current time: </p><br><pre> <code class="go hljs">now := time.Now().Format(time.Kitchen) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(strings.Replace(data, <span class="hljs-string"><span class="hljs-string">"$NOW"</span></span>, now, <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><p>  If you need to replace several different occurrences at once, use <a href="https://golang.org/pkg/strings/">strings.Replacer</a> .  It takes an old / new value as an input: </p><br><pre> <code class="go hljs">r := strings.NewReplacer(<span class="hljs-string"><span class="hljs-string">"$NOW"</span></span>, now, <span class="hljs-string"><span class="hljs-string">"$USER"</span></span>, <span class="hljs-string"><span class="hljs-string">"mary"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(r.Replace(<span class="hljs-string"><span class="hljs-string">"Hello $USER, it is $NOW"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// Output: Hello mary, it is 3:04PM</span></span></code> </pre> <br><h3>  Register replacement </h3><br><p>  You may think that working with registers is simple - lower and upper, just something to do - but Go works with Unicode, and Unicode is never simple.  There are three types of registers: upper, lower and upper case. </p><br><p>  The top and bottom are fairly simple for most languages, and using the <a href="https://golang.org/pkg/bytes/">ToUpper ()</a> and <a href="https://golang.org/pkg/bytes/">ToLower ()</a> functions is <a href="https://golang.org/pkg/bytes/">enough</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToUpper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToUpper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToLower</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToLower</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  But, in some languages, the rules of registers differ from the generally accepted ones.  For example, in Turkish, <strong>i</strong> in upper case looks like <strong>ƒ∞</strong> .  For such special cases, there are special versions of these functions: </p><br><pre> <code class="go hljs">strings.ToUpperSpecial(unicode.TurkishCase, <span class="hljs-string"><span class="hljs-string">"i"</span></span>)</code> </pre> <br><p>  Further, we also have a capital register and the <a href="https://golang.org/pkg/bytes/">ToTitle ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  Perhaps you will be very surprised when you see that <a href="https://golang.org/pkg/bytes/">ToTitle ()</a> will <a href="https://golang.org/pkg/bytes/">convert</a> all your characters to uppercase: </p><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(strings.ToTitle(<span class="hljs-string"><span class="hljs-string">"the count of monte cristo"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// Output: THE COUNT OF MONTE CRISTO</span></span></code> </pre> <br><p>  This is because in Unicode, capitalization is a special type of register, and not the writing of the first letter in a word in upper case.  In most cases, the capital and upper case are one and the same, but there are several code points in which this is not the case.  For example, code point <a href="https://www.compart.com/en/unicode/U%2B01C9">«â</a> (yes, this is one code point) in upper case looks like «á, and in upper case -. </p><br><p>  The function that you need in this case is most likely <a href="https://golang.org/pkg/bytes/">Title ()</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Title</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Title</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  Her conclusion will be more like the truth: </p><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(strings.Title(<span class="hljs-string"><span class="hljs-string">"the count of monte cristo"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// Output: The Count Of Monte Cristo</span></span></code> </pre> <br><h3>  Mapping Rune </h3><br><p>  There is another way to replace data in byte slices and strings - the <a href="https://golang.org/pkg/bytes/">Map ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mapping </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rune</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function">) []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mapping </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rune</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  This feature allows you to specify your own function to test and replace each rune.  To be honest, I had no idea about this function until I started writing this post, so I can‚Äôt tell any personal usage history here. </p><br><h2>  Merge and split functions </h2><br><p>  Quite often, you have to work with strings containing delimiters, by which the string should be broken.  For example, paths in UNIX are combined with colons, and CSV format is, in fact, just data, separated by commas. </p><br><h3>  String splitting </h3><br><p>  For a simple split of slices or substrings, we have Split () functions: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitAfter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitAfterN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitAfter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitAfterN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  These functions break a string or slice byte according to a delimiter and return them in the form of several slices or substrings.  After () - functions include the separator itself in the substrings, and N () - functions limit the number of divisions returned: </p><br><pre> <code class="go hljs">strings.Split(<span class="hljs-string"><span class="hljs-string">"a:b:c"</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ["a", "b", "c"] strings.SplitAfter("a:b:c", ":") // ["a:", "b:", "c"] strings.SplitN("a:b:c", ":", 2) // ["a", "b:c"]</span></span></code> </pre> <br><p>  Splitting is a very frequent operation, but it usually occurs in the context of working with a file in CSV or UNIX paths.  For such cases, I use the <a href="https://golang.org/pkg/encoding/csv/">encoding / csv</a> and <a href="https://golang.org/pkg/path/">path</a> packages, respectively. </p><br><h3>  Categorization </h3><br><p>  Sometimes you will need to specify delimiters as a set of runes, not a series of runes.  The best example here would be splitting words into spaces of different lengths.  Simply calling <a href="https://golang.org/pkg/bytes/">Split ()</a> with a space as a separator, you get empty substrings at the output, if there are several spaces in a row at the input.  Instead, use the <a href="https://golang.org/pkg/bytes/">Fields ()</a> function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span></code> </pre> <br><p>  It treats consecutive spaces as one delimiter: </p><br><pre> <code class="go hljs">strings.Fields(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ["hello", "world"] strings.Split("hello world", " ") // ["hello", "", "", "world"]</span></span></code> </pre> <br><p>  The Fields () function is a simple wrapper around another function, FieldsFunc (), which allows you to specify an arbitrary function for checking runes on a separator: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FieldsFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">) [][]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span></code> </pre> <br><h3>  String concatenation </h3><br><p>  Another operation that is often used when working with data is the union of slices and strings.  For this there is a function <a href="https://golang.org/pkg/bytes/">Join ()</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s [][]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, sep []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, sep </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br><p>  One of the errors I encountered is that developers try to implement string concatenation manually and write something like: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, s := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> a { output += s <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(a) - <span class="hljs-number"><span class="hljs-number">1</span></span> { output += <span class="hljs-string"><span class="hljs-string">","</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br><p>  The problem with this code is that there are a lot of memory allocations in it.  Since strings are immutable, each iteration creates a new string.  The <a href="https://golang.org/pkg/strings/">strings.Join ()</a> function uses a slice byte as a buffer and converts it to a string at the very end.  This minimizes the number of memory allocations. </p><br><h2>  Different functions </h2><br><p>  There are two functions that I could not clearly assign to any category, so they are here below.  First, the <a href="https://golang.org/pkg/bytes/">Repeat ()</a> function allows you to create a string of duplicate elements.  Honestly, the only time I used it was to create a line dividing the output in the terminal: </p><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(strings.Repeat(<span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>))</code> </pre> <br><p>  Another function, <a href="https://golang.org/pkg/bytes/">Runes (),</a> returns a slice of runes in a string or slice of bytes, interpreted as UTF-8.  I have never used this function, since the for loop on a line does exactly the same thing, without unnecessary allocations. </p><br><h1>  Conclusion </h1><br><p>  Slices of bytes and strings are fundamental primitives in Go.  They are the representation of bytes or runes in memory.  Packages bytes and strings provide a large number of auxiliary functions, as well as adapters for io.Reader and io.Writer interfaces. </p><br><p>  It‚Äôs pretty easy to lose sight of many of these useful features because of the large size of the APIs of these packages, but I hope that this post has helped you to get acquainted with these packages and learn about the features they provide. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/307554/">https://habr.com/ru/post/307554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307542/index.html">When should you think about optimizing your IT infrastructure?</a></li>
<li><a href="../307544/index.html">From Slides Defined to Software Defined Networking. Part 1</a></li>
<li><a href="../307548/index.html">Welcome to Tarantool meetup August 25</a></li>
<li><a href="../307550/index.html">The collapse of the cloud technology exchange. What's next?</a></li>
<li><a href="../307552/index.html">Path indie developers on the market Steam Greenlight: Project ‚Ññ1</a></li>
<li><a href="../307556/index.html">Planning usability testing. Part 1</a></li>
<li><a href="../307558/index.html">Blend @PreAuthorize in Spring Security with arbitrary types and simple inspected DSL</a></li>
<li><a href="../307560/index.html">Use powershell scripts in icinga2</a></li>
<li><a href="../307562/index.html">Soprocess: -What, -how, -why?</a></li>
<li><a href="../307564/index.html">The Golden Key is an unavoidable possibility of a full bypass of Secure Boot on most Windows devices.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>