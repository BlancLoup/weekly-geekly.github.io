<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Management and cleaning in D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 We all know that D uses the garbage collector. He manages the allocation of memory. It is used by implementations of such built-in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Management and cleaning in D</h1><div class="post__text post__text-html js-mediator-article">  Good day, Habr! <br><br>  We all know that D uses the garbage collector.  He manages the allocation of memory.  It is used by implementations of such built-in types as associative and dynamic arrays, strings (which are also arrays), exceptions, delegates.  Its use is also integrated into the syntax of the language (concatenation, new operator).  GC removes responsibility and load from the programmer, allows you to write more compact, understandable and secure code.  And these are perhaps the most important advantages of a garbage collector.  Should I give it up?  Payback for the use of the collector will be excessive use of memory, which is unacceptable with very limited resources and pauses of all threads (stop-the-world) to the assembly itself.  If these points are critical for you, welcome under cat. <br><a name="habracut"></a><br><br><h3>  How bad is it? </h3><br>  First you need to find out, is it bad at all? <br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  It is worth sinning for embedded tools only after checking the architecture and algorithms used. <br></div></div><br>  You can use <a href="https://ru.wikipedia.org/wiki/Valgrind">valgrind</a> , its memcheck tool (by default) will show how many times the program allocated and released the memory, as well as its amount (row total heap usage). <br>  But valgrind will not be able to show GC usage statistics.  Fortunately, this is built into runtime D (dmd only).  The garbage collector of an already compiled program can be configured and profiled as follows: <br><pre><code class="bash hljs">app <span class="hljs-string"><span class="hljs-string">"--DRT-gcopt=profile:1 minPoolSize:16"</span></span> program args</code> </pre> <br>  The first argument (string) is processed in runtime and does not reach the main function. <br>  Supported parameters: <br><ul><li>  disable: 0 | 1 - disabling the collector </li><li>  profile: 0 | 1 - profiling with output at completion </li><li>  initReserve: N - memory reserved at startup (MB) </li><li>  minPoolSize: N - initial and minimum pool size (MB) </li><li>  maxPoolSize: N - maximum pool size (MB) </li><li>  incPoolSize: N - increment pool (MB) </li><li>  heapSizeFactor: N - the ratio of the target heap size to the used memory </li></ul><br>  When profiling is enabled, the output of the program after its completion will be something like this: <br><pre> <code class="hljs pgsql"> Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> collections: <span class="hljs-number"><span class="hljs-number">101</span></span> Total GC prep <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> milliseconds Total mark <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> milliseconds Total sweep <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> milliseconds Total page recovery <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> milliseconds Max Pause <span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> milliseconds Grand total GC <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span> milliseconds GC <span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>: <span class="hljs-number"><span class="hljs-number">67</span></span> MB, <span class="hljs-number"><span class="hljs-number">101</span></span> GC <span class="hljs-number"><span class="hljs-number">17</span></span> ms, Pauses <span class="hljs-number"><span class="hljs-number">13</span></span> ms &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ms</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Life without assembly (almost) </h3><br>  If, after all the tests and GC settings, the result remains unsatisfactory, you can resort to some tricks. <br><br><h4>  Do not need a collector - do not use </h4><br>  Seriously?  Is that allowed? <br>  In the critical sections of the program, the collector can simply be disabled: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.memory; ... GC.disable(); ...</code> </pre><br>  And when "there will be time for cleaning" turn it back on or immediately start: <br><pre> <code class="cpp hljs">... GC.enable(); GC.collect(); <span class="hljs-comment"><span class="hljs-comment">// enable  collect   ,    ...</span></span></code> </pre><br>  During completion, the program once again starts the garbage collector, regardless of the state of its inclusion. <br>  When using this technique, it is important to remember that the memory continues to be allocated and in the case when it is not enough, the program will be terminated by the OS. <br><br><h4>  Use the right types. </h4><br>  As mentioned in the beginning of the article, arrays, classes, delegates are not the most suitable candidates for use when trying to get away from the GC. <br>  Some classes can be replaced by structures.  In D, structures are allocated on the stack and destroyed when leaving the visibility zone.  If there are nowhere classes, then you can use it only in the scope: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.typecons; ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cls = scoped!MyClass( param, of, my, _class ); ...</code> </pre><br>  The cls object will behave as an instance of the class MyClass, but will be destroyed when leaving the zone of visibility without GC participation.  It is worth replacing that the scope keyword for creating class objects wants to be abstracted in favor of the library implementation, <a href="">here is a</a> discussion. <br><br><h4>  Ranges! </h4><br>  A separate coil and, as I understand it, the current trend in the development of a standard library is the transition to the concept of ranges.  So now almost all functions from std.algorithm work.  The ranges can be different: input, output, infinite, with a length, etc. <br>  Their meaning is that these are objects (structures) containing certain methods, such as front, popFront, and so on.  For more information on which structures can act as ranges in the <a href="http://dlang.org/phobos/std_range_primitives.html">standard library</a> .  Their advantages are pending computation and no memory allocation.  A simple example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.typetuple; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIRWL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> isIRWL = isInputRange!R &amp;&amp; hasLength!R; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FloatHandler = is( ElementType!R == <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R1,R2)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( R1 a, R2 b )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( allSatisfy!(isIRWL,R1,R2) &amp;&amp; allSatisfy!(FloatHandler,R1,R2) )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = chain( a, b ); <span class="hljs-comment"><span class="hljs-comment">//     float res = 0.0f; foreach( val; c ) res += val; // foreach ) return res / c.length; //   InputRange   } void main() { float[] a = [1,2,3]; float[] b = [4,5,6,7]; writeln( avg( a, b ) ); // 4 float[] d = chain( a, b ).array; //    writeln( d ); // [1,2,3,4,5,6,7] }</span></span></code> </pre><br>  The chain function returns an object of type Result (local for the function), which itself contains 2 references to the ranges that were specified at the input.  When iterating through this object, the front and popFront methods are called using foreach, and this object calls the corresponding methods first on the first range, then on the second, when the first one becomes empty. <br>  A good <a href="http://dconf.org/2015/talks/davis.pdf">presentation</a> on the topic of ranges was at DConf2015, by Jonathan M Davis. <br><br><h4>  If you really want classes </h4><br>  Yes, such that are constantly being created and deleted.  In this case, you can slightly re-register the class and use the concept of FreeList <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Foo freelist; <span class="hljs-comment"><span class="hljs-comment">//   Foo next; //     static Foo allocate() { Foo f; if( freelist ) //       { f = freelist; //   freelist = f.next; } else f = new Foo(); //    return f; } static void deallocate(Foo f) //       { f.next = freelist; freelist = f; } ...     ... } ... Foo f = Foo.allocate(); ... Foo.deallocate(f);</span></span></code> </pre><br>  In this case, we minimize the allocation of memory for new objects, if these have already been created and are no longer needed.  Completely from the collector, this does not enclose us, but if memory is not allocated, then the collector will not run the assembly. <br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  It is better to allocate all the necessary memory in advance, of course, if this is possible. <br></div></div><br><br><h3>  Life without assembly (well, if only slightly) </h3><br>  I did not find a way to fully write on D without using a collector, but this is, in part, in my opinion, good.  Manual memory management is fraught with errors, insecure, cumbersome, etc. (old and evil C ++).  But if you strongly need, then you can. <br><br>  For manual memory management, functions from libc malloc and free are used.  To work with arrays, this is elementary: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.stdc.stdlib; ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arr = (cast(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>*count))[<span class="hljs-number"><span class="hljs-number">0.</span></span>.count]; ... <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>( arr.ptr ); ...</code> </pre><br><br>  To protect yourself from unwanted use of GC, you can use the @nogc attribute.  The compiler will give an error when it detects the use of a collector inside blocks with such an attribute. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arr)</span></span></span><span class="hljs-function"> @nogc </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass; <span class="hljs-comment"><span class="hljs-comment">//  arr ~= 42; //  foo(); // :  ,    @nogc }</span></span></code> </pre><br>  To maintain flexibility of use, it is <b>not necessary</b> to specify attributes to template functions.  If the template function will be called from @nogc code, the compiler will try to make it also @nogc.  For this, the condition must be preserved that only @nogc functions are used within this template function.  This behavior of the compiler turns out to be useful in case of reuse of template code, when the template function will be needed when using the collector (it will be called from normal code and will use ordinary code inside itself).  This also applies to other attributes (nothrow, pure, etc). <br><br>  When compiling, you can display all the places in the program where the collector is used: <pre> <code class="bash hljs">dmd -vgc source.d ...</code> </pre><br>  The compiler will only indicate the locations of use, but will not generate an error. <br><br>  It must be remembered that when creating threads through the standard library, the collector is also used.  To create threads without a collector, you must use C-shnye functions, as is the case with malloc and free. <br><br><h4>  And lastly: creating classes without a collector </h4><br>  A small example with comments <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.exception; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.stdc.stdlib : <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.stdc.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.memory : GC; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.traits; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X ) { x = X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * x; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x ) { super(x); } <span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> * x * z; } } <span class="hljs-comment"><span class="hljs-comment">// std.conv.emplace    @nogc,   T classEmplace(T,Args...)( void[] chunk, auto ref Args args ) if( is(T == class) ) { enum size = __traits(classInstanceSize, T); //     //  ,    if( chunk.length &lt; size ) return null; if( chunk.length % classInstanceAlignment!T != 0 ) return null; //  TypeInfo       init,     //          ,   memcpy( chunk.ptr, typeid(T).init.ptr, size ); auto res = cast(T)chunk.ptr; //   static if( is(typeof(res.__ctor(args))) ) res.__ctor(args); else static assert(args.length == 0 &amp;&amp; !is(typeof(&amp;T.__ctor)), "Don't know how to initialize an object of type " ~ T.stringof ~ " with arguments " ~ Args.stringof); return res; } auto heapAlloc(T,Args...)( Args args ) { enum size = __traits(classInstanceSize, T); auto mem = malloc(size)[0..size]; if( !mem ) onOutOfMemoryError(); //GC.addRange( mem.ptr, size ); //    return classEmplace!(T)( mem, args ); } auto heapFree(T)( T obj ) { destroy(obj); //GC.removeRange( cast(void*)obj ); //     free( cast(void*)obj ); } void main() { auto test = heapAlloc!B( 12 ); writeln( "test.foo(): ", test.foo() ); // 72 heapFree(test); }</span></span></code> </pre><br>  About the commented lines GC.addRange () and GC.removeRange ().  If you are firmly determined that you will not use the collector, you can leave them zakomementirovannymi.  If arrays, delegates, other classes, etc. that are to be cleaned with the help of GC are stored inside the class, then you need to add to the GC a range of memory that it will scan for garbage collection. <br><br>  If the constructor is @nogc, then you can use heapAlloc in the @nogc functions, with heapFree everything is more complicated: destroy, in addition to calls to destructors (which you can simply implement with mixin), also performs some actions related to the class monitor (of course, if you want, you can and replace them with the @nogc option). <br><br><h3>  Conclusion </h3><br><br>  In the development of the language and the standard library, one can observe the tendency to abandon the "forcible" use of the garbage collector.  At the moment, work on this is far from complete, but there are some advances. <br><br>  In this regard, I found interesting reports from <a href="http://dconf.org/2015/talks/bright.pdf">Walter Bright</a> and <a href="http://dconf.org/2015/talks/alexandrescu.pdf">Andrei Alexandrescu</a> from the same DConf2015. <br><br>  Ps.  Why on Habr√© there is no syntax highlighting D? <br>  Pps.  Does anyone know if D conferences are scheduled in Russia? </div><p>Source: <a href="https://habr.com/ru/post/260151/">https://habr.com/ru/post/260151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260135/index.html">Manage Azure DNS almost without PowerShell</a></li>
<li><a href="../260139/index.html">3CX Phone System v14: version for technical specialists</a></li>
<li><a href="../260141/index.html">Phalcon 2.0.3 release</a></li>
<li><a href="../260145/index.html">HL7 FHIR: Fast Healthcare Interoperability Resources</a></li>
<li><a href="../260149/index.html">How I found the best programming language in the world. Piece Yo (2.72)</a></li>
<li><a href="../260159/index.html">Comparison of Security Enhanced NGINX and Hiawatha Web Server in repelling attacks of level 7 (BOTS / SQL / XSS etc.)</a></li>
<li><a href="../260161/index.html">5 data visualization experiments</a></li>
<li><a href="../260163/index.html">Understanding the grid in Adobe Illustrator</a></li>
<li><a href="../260169/index.html">Understanding the Web Interface Architecture</a></li>
<li><a href="../260173/index.html">LiveReload - javascript update without full page reload (for example, mithril)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>