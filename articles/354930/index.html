<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>BigInt - long arithmetic in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BigInt is a new numeric primitive data type in JavaScript that allows you to work with arbitrary precision numbers. With BigInt you can safely store a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>BigInt - long arithmetic in javascript</h1><div class="post__text post__text-html js-mediator-article"><p> <code>BigInt</code> is a new numeric primitive data type in JavaScript that allows you to work with arbitrary precision numbers.  With <code>BigInt</code> you can safely store and process large integers even beyond the maximum safe integer value <code>Number</code> .  In this article, we will look at some examples of using <code>BigInt</code> and the new features of Chrome 67, comparing <code>BigInt</code> and <code>Number</code> in JavaScript. </p><a name="habracut"></a><br><h2 id="primery-ispolzovaniya">  Examples of using </h2><br><p>  Arbitrary precision integers open up many new uses for JavaScript. </p><br><p>  BigInt allows you to prevent overflow errors during mathematical operations.  This fact in itself makes countless possibilities available, for example, mathematical operations on large numbers are commonly used in financial technologies. </p><br><p>  <a href="https://developer.twitter.com/en/docs/basics/twitter-ids">Large numeric identifiers</a> and <a href="https://github.com/nodejs/node/pull/20220">high-precision time stamps</a> cannot be safely represented by the <code>Number</code> data type in JavaScript.  <a href="https://github.com/stedolan/jq/issues/1399">This often</a> leads to <a href="https://github.com/nodejs/node/issues/12115">errors</a> and forces developers to store them as strings.  With <code>BigInt</code> this data can be represented as numeric values. </p><br><p>  <code>BigInt</code> can be used in a possible implementation of the <code>BigDecimal</code> data type.  This will allow storing monetary values ‚Äã‚Äãas decimal fractions without loss of accuracy when performing operations (for example, without a <code>0.10 + 0.20 !== 0.30</code> problem <code>0.10 + 0.20 !== 0.30</code> ). </p><br><p>  Previously, in JavaScript, in any of these cases, you had to use libraries that emulate the <code>BigInt</code> functionality.  When <code>BigInt</code> becomes widely available, it will be possible to abandon these dependencies in favor of natively supported <code>BigInt</code> .  This will help reduce download time, parsing and compilation, as well as increase runtime performance. </p><br><p><img src="https://habrastorage.org/webt/ep/l8/hc/epl8hchee6j7hskpzq0g_ivp1he.png" alt="https://habrastorage.org/webt/ep/l8/hc/epl8hchee6j7hskpzq0g_ivp1he.png"><br>  <em>Native <code>BigInt</code> runs faster than popular custom libraries</em> </p><br><p>  For the BigInt <code>BigInt</code> , a library is required that implements the necessary functions, as well as a transfiguration step, to translate the new syntax into a library API call.  Babel currently supports <code>BigInt</code> parsing literals, but cannot convert them.  Therefore, we do not hope that <code>BigInt</code> will be used in production on sites that require compatibility with a wide range of browsers.  However, now that this functionality is starting to appear in browsers, you can start experimenting with BigInt, expecting with time more and more support for BigInt. </p><br><h2 id="status-kvo-number">  Status Quo: Number </h2><br><p>  The primitive <code>Number</code> data type in JavaScript is represented by double-precision floating-point numbers.  The constant <code>Number.MAX_SAFE_INTEGER</code> contains the largest possible integer that can be safely incremented by one.  Its value is <code>2 ** 53-1</code> . </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>.MAX_SAFE_INTEGER; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 9_007_199_254_740_991</span></span></code> </pre> <br><p>  <em>Note: for readability, I group numbers using underscores as delimiters.</em>  <em>The corresponding <a href="https://github.com/tc39/proposal-numeric-separator">sentence</a> will allow the use of such an entry for regular numeric JavaScript literals.</em> </p><br><p>  Increasing it by one gives the expected result: </p><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">max</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 9_007_199_254_740_992</span></span></code> </pre> <br><p>  But if we increase it by one more, <code>Number</code> will not be able to accurately save the result: </p><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">max</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 9_007_199_254_740_992</span></span></code> </pre> <br><p>  Note that the result of the expression <code>max + 1</code> will be equal to the result of the expression <code>max + 2</code> .  Therefore, whenever we get this particular value in javascript, one cannot say whether it is accurate or not.  Any calculations with integers outside the safe integer range (that is, from <code>Number.MIN_SAFE_INTEGER</code> to <code>Number.MAX_SAFE_INTEGER</code> ) are potentially not accurate.  For this reason, we can only rely on integer values ‚Äã‚Äãin the safe range. </p><br><h2 id="novinka-bigint">  New: BigInt </h2><br><p>  <code>BigInt</code> is a new numeric primitive data type in JavaScript that allows you to work with arbitrary precision numbers.  With <code>BigInt</code> you can safely store and process large integers even beyond the maximum safe integer value <code>Number</code> . </p><br><p>  To create <code>BigInt</code> suffices to add the suffix <code>n</code> to the literal notation of an integer.  For example, <code>123</code> will become <code>123n</code> .  The global function <code>BigInt(number)</code> can be used to cast a number to <code>BigInt</code> .  In other words, <code>BigInt(123) === 123n</code> .  Let's use this to solve the problems we talked about above: </p><br><pre> <code class="hljs lisp">BigInt(<span class="hljs-name"><span class="hljs-name">Number</span></span>.MAX_SAFE_INTEGER) + <span class="hljs-number"><span class="hljs-number">2</span></span>n<span class="hljs-comment"><span class="hljs-comment">; // ‚Üí 9_007_199_254_740_993n</span></span></code> </pre> <br><p>  Here is another example, with the multiplication of two numbers of type <code>Number</code> : </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">1234567890123456789</span></span> * <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 151851850485185200000</span></span></code> </pre> <br><p>  If we look at the low-order digits, <code>9</code> and <code>3</code> , it can be argued that the result of the multiplication must end with <code>7</code> (because <code>9 * 3 === 27</code> ).  But the result ends with a set of zeros.  Something went wrong.  Let's try again with <code>BigInt</code> : </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">1234567890123456789</span></span>n * <span class="hljs-number"><span class="hljs-number">123</span></span>n; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 151851850485185185047n</span></span></code> </pre> <br><p>  This time the result is correct. </p><br><p>  The limits for safe operation with integers do not apply to <code>BigInt</code> , so with <code>BigInt</code> we can use long arithmetic without worrying about loss of precision. </p><br><h3 id="novyy-primitivnyy-tip-dannyh">  New primitive data type </h3><br><p>  <code>BigInt</code> is a new primitive data type in the JavaScript language, so it gets its own type, which can return a <code>typeof</code> operator: </p><br><pre> <code class="hljs ruby">typeof <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí <span class="hljs-string"><span class="hljs-string">'number'</span></span> typeof <span class="hljs-number"><span class="hljs-number">123</span></span>n; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí <span class="hljs-string"><span class="hljs-string">'bigint'</span></span></code> </pre> <br><p>  Since <code>BigInt</code> is an independent data type, a number of type <code>BigInt</code> never be strictly equal to a number of type (for example, <code>42n !== 42</code> ).  To compare a number of type <code>BigInt</code> and a number of type <code>Number</code> , convert one of them to the type of the other before making a comparison, or use a comparison with type conversion ( <code>==</code> ): </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">42</span></span>n === BigInt(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>n == <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  When casting to a boolean value (for example, in <code>if</code> , using <code>&amp;&amp;</code> or <code>||</code> , or as the result of a <code>Boolean(int)</code> expression, and so on), numbers of type <code>BigInt</code> behave exactly like numbers of type. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>n) { console.log(<span class="hljs-string"><span class="hljs-string">'if'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log(<span class="hljs-string"><span class="hljs-string">'else'</span></span>); } // ‚Üí logs <span class="hljs-string"><span class="hljs-string">'else'</span></span>, because `<span class="hljs-number"><span class="hljs-number">0</span></span>n` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> falsy.</code> </pre> <br><h3 id="operatory">  Operators </h3><br><p>  <code>BigInt</code> supports most operators.  Binary <code>+</code> , <code>-</code> , <code>*</code> and <code>**</code> work as usual.  <code>/</code> and <code>%</code> also work, rounding the result to a whole if necessary.  Bitwise Operators <code>|</code>  , <code>&amp;</code> , <code>&lt;&lt;</code> , <code>&gt;&gt;</code> and <code>^</code> work with <code>BigInt</code> numbers in the same way as <code>Number</code> numbers, when negative numbers are represented in binary form as an additional code. </p><br><pre> <code class="hljs markdown">(7 + 6 - 5) <span class="hljs-bullet"><span class="hljs-bullet">* 4 *</span></span><span class="hljs-bullet"><span class="hljs-bullet">* 3 / 2 % 3; // ‚Üí 1 (7n + 6n - 5n) *</span></span> 4n ** 3n / 2n % 3n; // ‚Üí 1n</code> </pre> <br><p>  Unary <code>-</code> can be used to indicate a negative <code>BigInt</code> value, for example, <code>-42n</code> .  Unary <code>+</code> not supported because it violates the asm.js code, which expects that <code>+x</code> will always return either a <code>Number</code> or an exception. </p><br><p>  The important point is that you should not mix <code>BigInt</code> and <code>Number</code> in operations.  This is good because any implicit conversion can lead to loss of information.  Consider an example: </p><br><pre> <code class="hljs lisp">BigInt(<span class="hljs-name"><span class="hljs-name">Number</span></span>.MAX_SAFE_INTEGER) + <span class="hljs-number"><span class="hljs-number">2.5</span></span><span class="hljs-comment"><span class="hljs-comment">; // ‚Üí ??</span></span></code> </pre> <br><p>  What should be equal to the result?  There is no right answer.  <code>BigInt</code> cannot contain fractional numbers, and <code>Number</code> cannot accurately contain large numbers greater than the safe integer limit.  Therefore, operations with <code>BigInt</code> and <code>Number</code> result in a <code>TypeError</code> exception. </p><br><p>  The only exception to this rule is comparison operators, such as <code>===</code> (discussed earlier), <code>&lt;</code> and <code>&gt;=</code> , since they return logical values ‚Äã‚Äãthat do not carry the risk of losing accuracy. </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí TypeError <span class="hljs-number"><span class="hljs-number">123</span></span> &lt; <span class="hljs-number"><span class="hljs-number">124</span></span>n; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‚Üí <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  <em>Note: since <code>BigInt</code> and <code>Number</code> usually do not mix, it is not necessary to overwrite the already existing code from <code>Number</code> to <code>BigInt</code> .</em>  <em>Decide which of these two types you need and use it.</em>  <em>For new APIs that work with potentially large integers, <code>BigInt</code> is the best choice.</em>  <em>However, <code>Number</code> can still be used for values ‚Äã‚Äãthat are guaranteed to be in the safe range of integers.</em> </p><br><p>  It is also worth noting that the <code>&gt;&gt;&gt;</code> operator, which performs an unsigned right shift, does not make sense for <code>BigInt</code> numbers, since they always contain a sign.  Therefore, <code>&gt;&gt;&gt;</code> does not work for <code>BigInt</code> numbers. </p><br><h3 id="api">  API </h3><br><p>  Several new API methods for <code>BigInt</code> become available. </p><br><p>  The <code>BigInt</code> global constructor <code>BigInt</code> similar to the <code>Number</code> constructor: it converts its argument to <code>BigInt</code> (as mentioned earlier).  If the conversion fails, a <code>SyntaxError</code> or <code>RangeError</code> exception will be thrown. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">BigInt</span></span>(<span class="hljs-number"><span class="hljs-number">123</span></span>); // ‚Üí <span class="hljs-number"><span class="hljs-number">123</span></span>n <span class="hljs-type"><span class="hljs-type">BigInt</span></span>(<span class="hljs-number"><span class="hljs-number">1.5</span></span>); // ‚Üí RangeError <span class="hljs-type"><span class="hljs-type">BigInt</span></span>(<span class="hljs-string"><span class="hljs-string">'1.5'</span></span>); // ‚Üí SyntaxError</code> </pre> <br><p>  There are two functions that allow you to limit <code>BigInt</code> values <code>BigInt</code> specified number of significant bits, treating the number as either signed or unsigned.  <code>BigInt.asIntN(width, value)</code> limit the number <code>value</code> type <code>BigInt</code> to the number of bits specified in <code>width</code> taking into account the sign, and <code>BigInt.asUintN(width, value)</code> will do the same, considering the value as unsigned.  For example, if you need operations on 64-bit numbers, you can use these APIs to stay in the appropriate range: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     `BigInt`, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       64-  . const max = 2n ** (64n - 1n) - 1n; BigInt.asIntN(64, max); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ‚Üí 9223372036854775807n BigInt.asIntN(64, max + 1n); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ‚Üí -9223372036854775808n /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ^  ,    </span></span></code> </pre> <br><p>  Notice that the overflow occurs as soon as we pass a <code>BigInt</code> that exceeds the 64-bit integer range (i.e. 63 bits for the value itself and 1 bit for the character). </p><br><p>  <code>BigInt</code> allows <code>BigInt</code> to accurately represent 64-bit signed and unsigned integers that are commonly used in other programming languages.  Two new typed arrays, <code>BigInt64Array</code> and <code>BigUint64Array</code> , simplify working with these values: </p><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BigInt64Array(<span class="hljs-number"><span class="hljs-number">4</span></span>); // ‚Üí [<span class="hljs-number"><span class="hljs-number">0</span></span>n, <span class="hljs-number"><span class="hljs-number">0</span></span>n, <span class="hljs-number"><span class="hljs-number">0</span></span>n, <span class="hljs-number"><span class="hljs-number">0</span></span>n] <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.length; // ‚Üí <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // ‚Üí <span class="hljs-number"><span class="hljs-number">0</span></span>n <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>n; <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // ‚Üí <span class="hljs-number"><span class="hljs-number">42</span></span>n</code> </pre> <br><p>  <code>BigInt64Array</code> guarantees that its values ‚Äã‚Äãwill be within the limits of possible 64-bit signed values. </p><br><pre> <code class="hljs pgsql">//     `<span class="hljs-type"><span class="hljs-type">BigInt</span></span>`, //       <span class="hljs-number"><span class="hljs-number">64</span></span>-  . const max = <span class="hljs-number"><span class="hljs-number">2</span></span>n ** (<span class="hljs-number"><span class="hljs-number">64</span></span>n - <span class="hljs-number"><span class="hljs-number">1</span></span>n) - <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = max; <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // ‚Üí <span class="hljs-number"><span class="hljs-number">9</span></span>_223_372_036_854_775_807n <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = max + <span class="hljs-number"><span class="hljs-number">1</span></span>n; <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // ‚Üí <span class="hljs-number"><span class="hljs-number">-9</span></span>_223_372_036_854_775_808n // ^  ,    </code> </pre> <br><p>  <code>BigUint64Array</code> works similarly for unsigned 64-bit values. </p><br><p>  <code>BigInt</code> fun with <code>BigInt</code> ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/354930/">https://habr.com/ru/post/354930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354906/index.html">Distribution of programs on Go. Part 1</a></li>
<li><a href="../354910/index.html">By the Day of Radio. Oh connection, you are the world</a></li>
<li><a href="../354912/index.html">PyTorch Tour</a></li>
<li><a href="../354914/index.html">Setting security for applications on the SAP Cloud Platform cloud platform</a></li>
<li><a href="../354916/index.html">Experience using Mikrotik CHR for organizing virtual routing</a></li>
<li><a href="../354934/index.html">Plausible reconstruction of Instagram-like filters</a></li>
<li><a href="../354936/index.html">(Akin's laws) laws of space engineering</a></li>
<li><a href="../354938/index.html">Loud sound of the fire extinguishing system knocked out the drives in the Nasdaq data center</a></li>
<li><a href="../354940/index.html">Extreme Performance Virtual Server (VPS / VDS)</a></li>
<li><a href="../354942/index.html">Cross-language software development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>