<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting FreeModbus 1.5 under STM32 HAL rs485 without RTOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I started working on embedded systems and has come to programming microcontrollers, namely, STM32F373. One of the tasks was to deploy a Modb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting FreeModbus 1.5 under STM32 HAL rs485 without RTOS</h1><div class="post__text post__text-html js-mediator-article">  Recently, I started working on embedded systems and has come to programming microcontrollers, namely, STM32F373.  One of the tasks was to deploy a Modbus Slave RTU over an rs485 interface. <br><br>  As the deadline was pressed, it was decided to take something ready, which I did.  A short googling led me to the <a href="http://www.freemodbus.org/">FreeModbus</a> library, and here the pain started, which I hope you will not encounter. <br><a name="habracut"></a><br><h4>  0. Preparing a project </h4><br>  For a quick start, I use <a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/PF259242%3Ficmp%3Dstm32cubemx_pron_pr-stm32cubef2_apr2014%26sc%3Dstm32cube-pr2">STM32CubeMX</a> , it allows you to quickly generate the controller initialization code without pain.  In my case, this is STM32F373VCTx LQFP100. <br><br>  Periphery: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  TIM6 </li><li>  USART1 </li></ul><br>  I only do this to generate the <code>HAL_TIM_Base_MspInit()</code> and <code>HAL_UART_MspInit()</code> functions, this will make your life easier if you connect other timers and usart'y. <br><br><img src="https://habrastorage.org/files/004/ab7/9a5/004ab79a50dd40d495c8cf16a5953ab4.PNG" alt="peripheral"><br><br>  Clocking: <br><br>  We need the TIM6 timer or the one you have chosen to operate at a frequency of at least 20kHz.  After rustling through the initialization code, I realized that TIM6 works on PCLK1 (Peripheral CLocK).  By default, it (the timer) is clocked from HSI (High Speed ‚Äã‚ÄãInternal resonator), just like everything else, but it seemed to me that this is not enough, so I drove the whole thing through the PLL (Phase-Locked Loop) and set the multiplier value to x8 to raise to 32 MHz, so the MK works smoother and more pleasant. <br><br><img src="https://habrastorage.org/files/b6c/30a/b89/b6c30ab89e2b4423bae4e40d3872a44a.PNG" alt="clock config"><br><br>  Additional configuration: <br><br>  We will need to work with the interrupt timer, so we will enable it on the Configuration tab of the System NVIC section "TIM6 global interrupt and DAC1 underrun error interrupts".  We also need USART1 "USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25" interrupts. <br><br><img src="https://habrastorage.org/files/9fd/80e/725/9fd80e7253d441efa808d3445c7d42cb.PNG" alt="image"><br><br>  I use a lot of additional interrupts to indicate errors, so don‚Äôt pay attention to a bunch of checkboxes. <br><br>  On it we finish, we save the project, the code. <br><br>  I generate code for <a href="http://www.openstm32.org/Downloading%2Bthe%2BSystem%2BWorkbench%2Bfor%2BSTM32%2Binstaller%3Fstructure%3DDocumentation">SW4STM32</a> (System Workbench for STM32, registration required).  I prefer to generate separate .h / .c files for the periphery, turn on full_assert and turn off the generation of the call to the functions of the peripheral initialization. <br><br><img src="https://habrastorage.org/files/ae9/0c6/e53/ae90c6e538844ec2850413fd69557031.PNG" alt="image"><img src="https://habrastorage.org/files/6d6/eb6/f8d/6d6eb6f8db3e4d52b7e5a4678bf29b5c.PNG" alt="image"><img src="https://habrastorage.org/files/87d/873/0b4/87d8730b491343268c98aa2e54127142.PNG" alt="image"><br><br><h4>  1. Download &amp; install </h4><br>  Everything is simple here: download the <a href="https://sourceforge.net/projects/freemodbus.berlios/files/freemodbus-v1.5.0.zip/download">archive</a> , unpack, copy the files from the <i>archive / modbus /</i> into the project, do not forget about the <i>archive / modbus / include</i> , add to the includes. <br>  We will also need a port layer, with which we will work, take it from the <i>archive / demo / BARE</i> , copy, ready. <br><br><h4>  2. Porting </h4><br>  We do everything based on the official <a href="http://www.freemodbus.org/api/sec_porting_serial.html">documentation</a> . <br><br><h5>  port.h </h5><br>  Let's start with include'ov: I <i>remove assert.h</i> , because I throw <code>assert()</code> on <code>assert_param()</code> , and add <i>stm32f3xx_hal.h</i> , if you use a processor of another series, then instead of this, use the appropriate library. <br><br>  Next we are interested in the <code>ENTER_CRITICAL_SECTION( )</code> and <code>EXIT_CRITICAL_SECTION( )</code> macros.  We replace them with <code>__disable_irq()</code> and <code>__enable_irq()</code> respectively. <br>  Immediately, it should be noted that this is not the best implementation of critical sections: if a situation occurs in which a function with such a critical section causes another function with such a critical section from its critical section, we will get a premature interrupt activation (example in the spoiler), but if you port it described in the article way, then this situation does not happen.  A solution to the problem can be found <a href="http://mcuoneclipse.com/2014/01/26/entercritical-and-exitcritical-why-things-are-failing-badly/">here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Problem demonstration</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ENTER_CRITICAL_SECTION(); <span class="hljs-comment"><span class="hljs-comment">//      //       EXIT_CRITICAL_SECTION(); //  ,    ,        bar() } void bar() { ENTER_CRITICAL_SECTION(); //      foo(); //      ,    EXIT_CRITICAL_SECTION(); //  =( }</span></span></code> </pre><br></div></div><br><br>  I also add the prototype <code>UART_IRQ_Handler()</code> , which will be used for a bit of a crutch implementation of the interrupt response. <br><br><div class="spoiler">  <b class="spoiler_title">port.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * FreeModbus Libary: BARE Port * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt; * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA * * File: $Id: port.h,v 1.1 2006/08/22 21:35:13 wolti Exp $ */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _PORT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f3xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;inttypes.h&gt; #define INLINE inline #define PR_BEGIN_EXTERN_C extern "C" { #define PR_END_EXTERN_C } //   #define ENTER_CRITICAL_SECTION( ) __disable_irq() #define EXIT_CRITICAL_SECTION( ) __enable_irq() //      #define assert(val) assert_param(val) typedef uint8_t BOOL; typedef unsigned char UCHAR; typedef char CHAR; typedef uint16_t USHORT; typedef int16_t SHORT; typedef uint32_t ULONG; typedef int32_t LONG; #ifndef TRUE #define TRUE 1 #endif #ifndef FALSE #define FALSE 0 #endif // callback  uart BOOL UART_IRQ_Handler(USART_TypeDef * usart); #endif</span></span></span></span></code> </pre><br></div></div><br><h5>  porttimer.c </h5><br>  Again, let's start with the includes: in the platform includes section, add <code>stm32f3xx_hal_tim.h</code> , from which you need the <code>TIM_COUNTERMODE_UP</code> constant. <br><br>  In the static functions section, I add a handler for the timer and 2 variables for storing the timeout, and the current value of the counter. <br>  The <code>xMBPortTimersInit()</code> function is <code>xMBPortTimersInit()</code> timer initialization.  We expect that it will tick every 50 Œºs. <br><br>  htim - our handler, type - <code>static TIM_HandleTypeDef</code> , global <br>  timeout - <code>static uint16_t</code> , global <br>  downcounter - <code>static uint16_t</code> , global <br><br><pre> <code class="cpp hljs"> htim.Instance = TIM6; <span class="hljs-comment"><span class="hljs-comment">// ,     6  htim.Init.CounterMode = TIM_COUNTERMODE_UP; //    ( 0  ) /*    ,       32 HAL_RCC_GetPCLK1Freq() -   PCLK1,     32000000   1000000,         1  -1 -   :   ,  0 -    1, 1 -   2  ..*/ htim.Init.Prescaler = (HAL_RCC_GetPCLK1Freq() / 1000000) - 1; //  50 ,  -1, ,   htim.Init.Period = 50 - 1; //   ,      timeout = usTim1Timerout50us; // ,   ,    HAL return HAL_OK == HAL_TIM_Base_Init(&amp;htim) ? TRUE : FALSE;</span></span></code> </pre><br>  The <code>vMBPortTimersEnable()</code> function.  There are 2 simple steps: <br><br><ol><li>  Reset timer. </li><li>  Start the timer asynchronously with interrupt feedback. </li></ol><br><pre> <code class="cpp hljs"> downcounter = timeout; HAL_TIM_Base_Start_IT(&amp;htim);</code> </pre><br>  The <code>vMBPortTimersDisable()</code> function.  Then just turn off the timer. <br><br><pre> <code class="cpp hljs"> HAL_TIM_Base_Stop_IT(&amp;htim);</code> </pre><br>  Also add a function to respond to the <code>HAL_TIM_Base_Stop_IT()</code> timer: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,    ,       if(__HAL_TIM_GET_FLAG(&amp;htim, TIM_FLAG_UPDATE) != RESET &amp;&amp; __HAL_TIM_GET_IT_SOURCE(&amp;htim, TIM_IT_UPDATE) !=RESET) { __HAL_TIM_CLEAR_IT(&amp;htim, TIM_IT_UPDATE); //    if (!--downcounter) //  ,      prvvTIMERExpiredISR(); //  callback  }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">porttimer.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * FreeModbus Libary: BARE Port * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt; * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA * * File: $Id: porttimer.c,v 1.1 2006/08/22 21:35:13 wolti Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ----------------------- Platform includes --------------------------------*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"port.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f3xx_hal_tim.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Modbus includes ----------------------------------*/</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mb.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbport.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- static functions ---------------------------------*/</span></span></span><span class="hljs-meta"> static void prvvTIMERExpiredISR( void ); static TIM_HandleTypeDef htim; static uint16_t timeout = 0; static uint16_t downcounter = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Start implementation -----------------------------*/</span></span></span><span class="hljs-meta"> BOOL xMBPortTimersInit( USHORT usTim1Timerout50us ) { htim.Instance = TIM6; htim.Init.CounterMode = TIM_COUNTERMODE_UP; htim.Init.Prescaler = (HAL_RCC_GetPCLK1Freq() / 1000000) - 1; htim.Init.Period = 50 - 1; timeout = usTim1Timerout50us; return HAL_OK == HAL_TIM_Base_Init(&amp;htim) ? TRUE : FALSE; } inline void vMBPortTimersEnable( ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enable the timer with the timeout passed to xMBPortTimersInit( ) */</span></span></span><span class="hljs-meta"> downcounter = timeout; HAL_TIM_Base_Start_IT(&amp;htim); } inline void vMBPortTimersDisable( ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Disable any pending timers. */</span></span></span><span class="hljs-meta"> HAL_TIM_Base_Stop_IT(&amp;htim); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Create an ISR which is called whenever the timer has expired. This function * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that * the timer has expired. */</span></span></span><span class="hljs-meta"> static void prvvTIMERExpiredISR( void ) { ( void )pxMBPortCBTimerExpired( ); } void TIM6_DAC1_IRQHandler(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* TIM Update event */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(__HAL_TIM_GET_FLAG(&amp;htim, TIM_FLAG_UPDATE) != RESET &amp;&amp; __HAL_TIM_GET_IT_SOURCE(&amp;htim, TIM_IT_UPDATE) !=RESET) { __HAL_TIM_CLEAR_IT(&amp;htim, TIM_IT_UPDATE); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!--downcounter) prvvTIMERExpiredISR(); } }</span></span></code> </pre><br></div></div><br><h5>  portserial.c </h5><br>  In general, the whole article was written precisely because of this file, because I could not port the UART-layer to STM32 under the ‚Äúpure‚Äù HAL and had to go deeper.  In the description of the library it is written that interrupts are needed, signaling that the transmission buffer is empty and that the reception buffer is not empty.  And HAL does not support such callbacks, so we will show off. <br><br>  Thesaurus: <br><br>  huart - handler for UART, <code>static UART_HandleTypeDef</code> <br>  DE_Port - port of the channel direction control legs, <code>static GPIO_TypeDef *</code> <br>  DE_Pin - pin to control the channel direction, <code>static uint16_t</code> <br><br>  Let's start with the <code>vMBPortSerialEnable()</code> function.  Here we turn to the "hidden opportunities" HAL. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xRxEnable) { <span class="hljs-comment"><span class="hljs-comment">//      //      (.   rs485) HAL_GPIO_WritePin(DE_Port, DE_Pin, GPIO_PIN_RESET); __HAL_UART_ENABLE_IT(&amp;huart, UART_IT_RXNE); //  ,       } else { __HAL_UART_DISABLE_IT(&amp;huart, UART_IT_RXNE); //   } if (xTxEnable) { //      //      (.   rs485) HAL_GPIO_WritePin(DE_Port, DE_Pin, GPIO_PIN_SET); __HAL_UART_ENABLE_IT(&amp;huart, UART_IT_TXE); //  ,      } else { __HAL_UART_DISABLE_IT(&amp;huart, UART_IT_TXE); //   }</span></span></code> </pre><br>  Further, the initialization function of the port <code>xMBPortSerialInit()</code> .  Made it more or less universal, it initializes the specified UART itself, but do not forget that the part with MSP initialization should be generated: initialization of pins, interrupts, etc. <br><br><div class="spoiler">  <b class="spoiler_title">xMBPortSerialInit ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> huart.Init.Mode = UART_MODE_TX_RX; <span class="hljs-comment"><span class="hljs-comment">//      huart.Init.HwFlowCtl = UART_HWCONTROL_NONE; //    (   rs485) // ,    ,        huart.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED; huart.Init.OverSampling = UART_OVERSAMPLING_16; //  - huart.Init.StopBits = UART_STOPBITS_1; //  - huart.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; //  : UART,     switch (ucPORT) { case 0: huart.Instance = USART1; DE_Port = GPIOA; DE_Pin = GPIO_PIN_12; break; case 1: huart.Instance = USART2; DE_Port = GPIOA; DE_Pin = GPIO_PIN_1; break; case 2: huart.Instance = USART3; DE_Port = GPIOB; DE_Pin = GPIO_PIN_14; break; default: //  ,      ,     ,   - return FALSE; } //  huart.Init.BaudRate = ulBaudRate; //   switch (ucDataBits) { case 8: huart.Init.WordLength = UART_WORDLENGTH_8B; break; case 9: huart.Init.WordLength = UART_WORDLENGTH_9B; break; default: //  ,      ,     ,   - return FALSE; } //    switch (eParity) { case MB_PAR_NONE: huart.Init.Parity = UART_PARITY_NONE; break; case MB_PAR_EVEN: huart.Init.Parity = UART_PARITY_EVEN; break; case MB_PAR_ODD: huart.Init.Parity = UART_PARITY_ODD; break; default: //  ,      ,     ,   - return FALSE; } //  ,  rs485 return HAL_OK == HAL_RS485Ex_Init(&amp;huart, UART_DE_POLARITY_HIGH, 0, 0) ? TRUE : FALSE;</span></span></code> </pre><br></div></div><br>  Now I / O functions <code>xMBPortSerialPutByte()</code> and <code>xMBPortSerialGetByte()</code> .  Here we will do hardcore low-level (for HAL) IO, using UART's registers. <br><br>  To read the byte from the port: <code>*pucByte = huart.Instance-&gt;RDR</code> <br>  To write a byte to the port: <code>huart.Instance-&gt;TDR = ucByte</code> <br><br>  And finally, we add the <code>UART_IRQ_Handler()</code> function, which we described in <i>port.h.</i>  It will be responsible for intercepting I / O interrupts.  The basic idea: if the interruption is ‚Äúour‚Äù, i.e.  from our port, and what we are waiting for, we return <code>TRUE</code> - this means that we intercepted it. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usart == huart.Instance) { <span class="hljs-comment"><span class="hljs-comment">// ,     if((__HAL_UART_GET_IT(&amp;huart, UART_IT_RXNE) != RESET) &amp;&amp; (__HAL_UART_GET_IT_SOURCE(&amp;huart, UART_IT_RXNE) != RESET)) { // ,      pxMBFrameCBByteReceived(); //     __HAL_UART_SEND_REQ(&amp;huart, UART_RXDATA_FLUSH_REQUEST); //    return TRUE; // ,   } if((__HAL_UART_GET_IT(&amp;huart, UART_IT_TXE) != RESET) &amp;&amp;(__HAL_UART_GET_IT_SOURCE(&amp;huart, UART_IT_TXE) != RESET)) { // ,      pxMBFrameCBTransmitterEmpty(); //     return TRUE; // ,   } } return FALSE; // ,    ,   </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">portserial.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * FreeModbus Libary: BARE Port * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt; * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA * * File: $Id: portserial.c,v 1.1 2006/08/22 21:35:13 wolti Exp $ */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"port.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Modbus includes ----------------------------------*/</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mb.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbport.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- static functions ---------------------------------*/</span></span></span><span class="hljs-meta"> static UART_HandleTypeDef huart; static GPIO_TypeDef * DE_Port; static uint16_t DE_Pin; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Start implementation -----------------------------*/</span></span></span><span class="hljs-meta"> void vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* If xRXEnable enable serial receive interrupts. If xTxENable enable * transmitter empty interrupts. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (xRxEnable) { HAL_GPIO_WritePin(DE_Port, DE_Pin, GPIO_PIN_RESET); __HAL_UART_ENABLE_IT(&amp;huart, UART_IT_RXNE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { __HAL_UART_DISABLE_IT(&amp;huart, UART_IT_RXNE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (xTxEnable) { HAL_GPIO_WritePin(DE_Port, DE_Pin, GPIO_PIN_SET); __HAL_UART_ENABLE_IT(&amp;huart, UART_IT_TXE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { __HAL_UART_DISABLE_IT(&amp;huart, UART_IT_TXE); } } BOOL xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity ) { huart.Init.Mode = UART_MODE_TX_RX; huart.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED; huart.Init.OverSampling = UART_OVERSAMPLING_16; huart.Init.StopBits = UART_STOPBITS_1; huart.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; switch (ucPORT) { case 0: huart.Instance = USART1; DE_Port = GPIOA; DE_Pin = GPIO_PIN_4; break; case 1: huart.Instance = USART2; DE_Port = GPIOA; DE_Pin = GPIO_PIN_1; break; case 2: huart.Instance = USART3; DE_Port = GPIOB; DE_Pin = GPIO_PIN_14; break; default: return FALSE; } huart.Init.BaudRate = ulBaudRate; switch (ucDataBits) { case 8: huart.Init.WordLength = UART_WORDLENGTH_8B; break; case 9: huart.Init.WordLength = UART_WORDLENGTH_9B; break; default: return FALSE; } switch (eParity) { case MB_PAR_NONE: huart.Init.Parity = UART_PARITY_NONE; break; case MB_PAR_EVEN: huart.Init.Parity = UART_PARITY_EVEN; break; case MB_PAR_ODD: huart.Init.Parity = UART_PARITY_ODD; break; default: return FALSE; } return HAL_OK == HAL_RS485Ex_Init(&amp;huart, UART_DE_POLARITY_HIGH, 0, 0); } BOOL xMBPortSerialPutByte( CHAR ucByte ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Put a byte in the UARTs transmit buffer. This function is called * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been * called. */</span></span></span><span class="hljs-meta"> huart.Instance-&gt;TDR = ucByte; return TRUE; } BOOL xMBPortSerialGetByte( CHAR * pucByte ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Return the byte in the UARTs receive buffer. This function is called * by the protocol stack after pxMBFrameCBByteReceived( ) has been called. */</span></span></span><span class="hljs-meta"> *pucByte = huart.Instance-&gt;RDR; return TRUE; } BOOL UART_IRQ_Handler(USART_TypeDef * usart) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart == huart.Instance) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((__HAL_UART_GET_IT(&amp;huart, UART_IT_RXNE) != RESET) &amp;&amp; (__HAL_UART_GET_IT_SOURCE(&amp;huart, UART_IT_RXNE) != RESET)) { pxMBFrameCBByteReceived(); __HAL_UART_SEND_REQ(&amp;huart, UART_RXDATA_FLUSH_REQUEST); return TRUE; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((__HAL_UART_GET_IT(&amp;huart, UART_IT_TXE) != RESET) &amp;&amp;(__HAL_UART_GET_IT_SOURCE(&amp;huart, UART_IT_TXE) != RESET)) { pxMBFrameCBTransmitterEmpty(); return TRUE; } } return FALSE; }</span></span></code> </pre><br></div></div><br>  It would seem that this is all, but there are a couple more points: <br><br>  As you can see, nobody calls the <code>UART_IRQ_Handler()</code> function.  To fix this, you need to visit the <i>stm32f3xx_it.c</i> file.  There we add include for <i>port.h.</i>  The following lines must be added to all USARTx_IRQ_Handler's (in our case, <code>USART1_IRQ_Handle()</code> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   ,       if (FALSE != UART_IRQ_Handler(USART1)) return;</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">stm32f3xx_it.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** ****************************************************************************** * @file stm32f3xx_it.c * @brief Interrupt Service Routines. ****************************************************************************** * * COPYRIGHT(c) 2016 STMicroelectronics * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * 1. Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation * and/or other materials provided with the distribution. * 3. Neither the name of STMicroelectronics nor the names of its contributors * may be used to endorse or promote products derived from this software * without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * ****************************************************************************** */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f3xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f3xx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f3xx_it.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"port.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* External variables --------------------------------------------------------*/</span></span></span><span class="hljs-meta"> extern UART_HandleTypeDef huart1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cortex-M4 Processor Interruption and Exception Handlers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @brief This function handles System tick timer. */</span></span></span><span class="hljs-meta"> void SysTick_Handler(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 0 */</span></span></span><span class="hljs-meta"> HAL_IncTick(); HAL_SYSTICK_IRQHandler(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 1 */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* STM32F3xx Peripheral Interrupt Handlers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add here the Interrupt Handlers for the used peripherals. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For the available peripheral interrupt handler names, */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* please refer to the startup file (startup_stm32f3xx.s). */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25. */</span></span></span><span class="hljs-meta"> void USART1_IRQHandler(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART1_IRQn 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (FALSE != UART_IRQ_Handler(USART1)) return; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART1_IRQn 0 */</span></span></span><span class="hljs-meta"> HAL_UART_IRQHandler(&amp;huart1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART1_IRQn 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART1_IRQn 1 */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span></span></span></span></code> </pre><br></div></div><br>  And the strangest thing is that I still could not decide: the library, in response, gave all the bytes except the last.  It killed me, and when calculating everything was OK, this is probably a question of UART or hand curves, but the following decision saved: just add another one to the byte counter (the <i>modbus / rtu / mbrtu.c file</i> is <code>eMBRTUSend()</code> ). <br><br><div class="spoiler">  <b class="spoiler_title">modbus / rtu / mbrtu.c eMBRTUSend () function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">eMBErrorCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eMBRTUSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( UCHAR ucSlaveAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UCHAR * pucFrame, USHORT usLength )</span></span></span><span class="hljs-function"> </span></span>{ eMBErrorCode eStatus = MB_ENOERR; USHORT usCRC16; ENTER_CRITICAL_SECTION( ); <span class="hljs-comment"><span class="hljs-comment">/* Check if the receiver is still in idle state. If not we where to * slow with processing the received frame and the master sent another * frame on the network. We have to abort sending the frame. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eRcvState == STATE_RX_IDLE ) { <span class="hljs-comment"><span class="hljs-comment">/* First byte before the Modbus-PDU is the slave address. */</span></span> pucSndBufferCur = ( UCHAR * ) pucFrame - <span class="hljs-number"><span class="hljs-number">1</span></span>; usSndBufferCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */</span></span> pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress; usSndBufferCount += usLength; <span class="hljs-comment"><span class="hljs-comment">/* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */</span></span> usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount ); ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> ); ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> ); usSndBufferCount++; <span class="hljs-comment"><span class="hljs-comment">//      /* Activate the transmitter. */ eSndState = STATE_TX_XMIT; vMBPortSerialEnable( FALSE, TRUE ); } else { eStatus = MB_EIO; } EXIT_CRITICAL_SECTION( ); return eStatus; }</span></span></code> </pre><br></div></div><br><h4>  3. Usage </h4><br>  Already almost done. <br><br><h5>  Customization </h5><br>  Visit <i>mbconfig.h</i> .  Look for it in include'ah.  I have SW4STM32, so Ctrl + Click saves me.  First, we configure the library to work only with ModbusRTU: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*! \brief If Modbus ASCII support is enabled. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MB_ASCII_ENABLED ( 0 ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! \brief If Modbus RTU support is enabled. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MB_RTU_ENABLED ( 1 ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! \brief If Modbus TCP support is enabled. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MB_TCP_ENABLED ( 0 )</span></span></code> </pre><br>  You can also turn off features that you don‚Äôt use, this will ease the library and allow you not to implement callbacks. <br><br><h5>  Using </h5><br><ol><li>  #include "mb.h </li><li>  eMBInit () </li><li>  eMBEnable () </li><li>  eMBPoll () </li></ol><br>  And don't forget to implement callbacks. <br><br>  On this I think that I fulfilled my mission, go to the <a href="http://www.freemodbus.org/api/index.html">off-site</a> for examples and documentation. <br><br>  Usage: <a href="http://www.freemodbus.org/api/group__modbus.html">Modules / Modbus</a> <br>  Callbacks: <a href="http://www.freemodbus.org/api/group__modbus__registers.html">Modules / Modbus Registers</a> </div><p>Source: <a href="https://habr.com/ru/post/279747/">https://habr.com/ru/post/279747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279735/index.html">Productivity in the development of Office Add-ins</a></li>
<li><a href="../279737/index.html">Replacing jitter exceptions</a></li>
<li><a href="../279739/index.html">Processing ‚Äúvideo 360‚Äù, image cleaning: algorithm and its implementation in C #</a></li>
<li><a href="../279743/index.html">NetApp StorageGrid object storage</a></li>
<li><a href="../279745/index.html">Template Turing Machine</a></li>
<li><a href="../279749/index.html">Study: DDR4, considered ‚Äúinvulnerable‚Äù, is vulnerable to Rowhammer vulnerability</a></li>
<li><a href="../279751/index.html">Programmers misconceptions about phone numbers</a></li>
<li><a href="../279753/index.html">QA: Conference. The second wave of speakers</a></li>
<li><a href="../279757/index.html">TrueConf video conferencing. Review and comparison with Skype for Business</a></li>
<li><a href="../279759/index.html">Read & Comment. Now on Habr√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>