<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Young's Binary Tables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, as promised , the continuation of the topic of Jung tables. Let me remind you that the Young table refers to a numerical matrix that has some spec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Young's Binary Tables</h1><div class="post__text post__text-html js-mediator-article">  So, as <a href="http://habrahabr.ru/blogs/algorithm/121800/">promised</a> , the continuation of the topic of Jung tables.  Let me remind you that the Young table refers to a numerical matrix that has some special properties.  A matrix is ‚Äã‚Äãa two-dimensional array.  And here a natural question should arise - why should the array be two-dimensional?  And what if we try to implement a three or four dimension table on the same principles <strike>, and best of all, of course, five stars</strike> !  About where such a generalization will lead us, you can read under the cut ... <a name="habracut"></a><br><h4>  One-dimensional young table </h4><br>  Before we take the dimension of Jung's table to infinity, let's see what remains behind us "behind our backs".  Only one is less than two (not counting zero, but the Young dimension of the zero dimension is something like a null space - no one knows what it is, but it sounds nice). <br>  So, Jung's one-dimensional table - what is it?  Following the definition given in the previous topic, this is just a descending, one-dimensional array, all of whose non-empty cells are located at its beginning. <br><img src="http://ir43.com/images/byt1.jpg"><br>  The rise and descent of elements (basic operations on Young table) in this case are reduced to a linear view of the table from right to left (ascent) or from left to right (descent): <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> X[i]&gt;X[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]: X[i], X[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = X[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], X[i] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, n)</span></span></span><span class="hljs-function">:</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> X[i]a&gt;X[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: X[i], X[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = X[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], X[i] i += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br>  The sorting algorithm itself is almost the same as the one described <a href="http://habrahabr.ru/blogs/algorithm/121800/">here</a> . <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YoungSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,n): MoveUp(X,i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,n): X[<span class="hljs-number"><span class="hljs-number">0</span></span>], X[ni] = X[ni], X[<span class="hljs-number"><span class="hljs-number">0</span></span>] MoveDown(X,ni)</code> </pre><br>  The attentive reader will notice that the first loop in this sorting is nothing more than a standard insert sorting.  True, the result is a sequence in descending order.  Therefore, the second cycle performs a tricky reverse reversal of the sequence.  It is clear that this treatment could be made more efficiently, but now our goal is to try to generalize the concept of Young table to the case of arbitrary dimension, so the optimization of one particular case (and even such a simple one) does not make sense. <br><h4>  Generalized Young Tables </h4><br>  For the definition of a generalized Young table, we take the following: a Young table is a partially ordered almost filled numerical array of dimension d. <br>  To determine the properties of partial ordering and almost fullness, we introduce the concept of the upper neighbor of the cell (element) of the array.  Let some cell of the array be characterized by the indices i <sub>1</sub> , i <sub>2</sub> , ..., i <sub>d</sub> .  Then, the top neighbor of a given cell is any cell whose all indices, with the exception of one, are equal to the indices of that cell, and the remaining index is exactly one less than the corresponding index of the given cell.  For example, a cell with indices [1,0,5,3] has three upper neighbors: [0,0,5,3], [1,0,4,3] and [1,0,5,2].  Thus, if all indices of a cell are non-zero, then it has exactly d upper neighbors, and if all indices are zero, then there are no neighbors above ‚Äî such an element is called the vertex of the Young table. <br>  Then, partial ordering means that the value of any element of the Young table is not greater than the values ‚Äã‚Äãof all its upper neighbors in this table. <br>  Almost full means that if some cell of the Young table is filled (that is, it contains some value), then all its upper neighbors are also filled. <br>  It is easy to show that along each dimension (when all indices, except one, are fixed), the values ‚Äã‚Äãof the cells of the Young table form a non-increasing sequence.  As a result, the largest element of the table is always located at its top. <br>  Unfortunately, the visualization of the already three-dimensional Jung tables is fraught with considerable difficulties, so the reader is invited to turn on his multidimensional imagination, helping him (the imagination), if necessary, with pictures of the usual two-dimensional Jung tables. <br>  The lifting and lowering operations are summarized in an obvious way.  When lifting some element, all its neighbors are moved from above, if neighbors with smaller values ‚Äã‚Äãare found, then the smallest one is selected, it changes places with the current one and the process continues for the new current element.  If the values ‚Äã‚Äãof all the upper neighbors are greater than the current, then the rise is complete.  An example of lifting an element in a three-dimensional table of Young is shown in the figure (only a fragment of the table is shown). <br><img src="http://ir43.com/images/byt2.jpg"><br>  The descent is performed in the same way, but all the neighbors from the bottom (the cells for which the current is the upper neighbor) are selected and the largest one is selected from them. <br>  Using these two operations, you can implement the insertion of a new element into the table and the removal of the largest element from the table.  And already by means of an insertion and removal sorting is simply implemented.  The implementation of the ascent and descent, in principle, should not cause any particular difficulties even for d-dimensional tables, but, nevertheless, we first try to assess the complexity of these two operations. <br>  We assume that each index of the d-dimensional Young table varies from 0 to m-1.  Take the worst case - the table is filled to the end (the number of elements n = m <sup>d</sup> ), you want to raise the last of its elements, which (as it happens) is the greatest.  Those.  at the end of the climb, this element should be on top of the table.  Because  in the process of lifting, at each iteration exactly one index of the element decreases by one, then we have to perform about dm iterations.  At each iteration, one exchange is performed, and no more than d comparisons (when viewing neighbors).  So, one lifting operation (in the worst case) will cost us O (d <sup>2</sup> m) actions.  This means that n such operations will cost O (d <sup>2</sup> mn) actions.  Taking into account the fact that n = m <sup>d</sup> , we obtain the following estimate of the complexity of sorting using the d-dimensional Young table: O (d <sup>2</sup> n <sup>1 + 1 / d</sup> ). <br>  The good news is that as d increases, the exponent 1 + 1 / d: 2 (one-dimensional Young table), 1.5 (standard Young table), 1.33, 1.25, 1.2, etc., decreases in the limit of this all - 1 - will we really beat quick sorting ?!  Now the bad news is that as d increases, so does the coefficient over a given degree.  It is easy to show (using the derivative) that the optimal choice of the parameter d is approximately equal to log <sub>2</sub> n.  We substitute this value into the formula O (d <sup>2</sup> n <sup>1 + 1 / d</sup> ) and after simple transformations we get the final estimate O (nlog <sup>2</sup> n) - everything, the revolution is canceled, because  the obtained estimate is asymptotically slightly, but worse than the optimal linear-logarithmic ... <br><h4>  Young's Binary Tables </h4><br>  Although we have shown that even at best, sorting with the help of Young tables does not reach asymptotic optimality, we still try to implement the best of these tables, i.e.  a table of dimension d = log <sub>2</sub> n, which we will call the binary Young table.  Even if such a table cannot be used to organize efficient sorting, nevertheless, it is possible that someone will be able to find useful use for it.  And among other things, the implementation of Jung's binary table is simply a good programming exercise. <br>  First let's formalize the concept of a binary Young table.  We will call the binary Young table of dimension d, in which each index can take only two values ‚Äã‚Äã0 and 1. If we denote by n the capacity of such a table, we get n = 2 <sup>d</sup> or d = log <sub>2</sub> n.  Examples of such tables for small values ‚Äã‚Äãof d are shown in the following figure.  Yeah, an astute reader will say, but this is a hypercube of dimension d!  And it will be absolutely right. <br><img src="http://ir43.com/images/byt3.jpg"><br>  Now let's deploy such a hypercube into a linear array using the standard layout of multidimensional arrays in memory ‚Äî the lowest index is the fastest changing.  For example, consider the dimension table d = 3 from the previous figure. <br><img src="http://ir43.com/images/byt4.jpg"><br>  What we see is that the indices, treated as numbers in the binary number system, form the sequence 0, 1, 2, 3, etc.  That is, we obtained a simple algorithm for transforming the coordinates of a cell in a binary Young table to the coordinates of the same cell in a linearized table.  Well, we can work with bats!  It seems we can ... <br>  The key concepts of the Young table are the upper and lower neighbors of the cells.  In terms of the binary Young table, these concepts are defined as follows: a cell with index i (in a linearized table) is called the upper neighbor of a cell with index j if the bit representation of the number i matches the bit representation of j, except for exactly one bit, which in j is equal unit, and in i - zero.  Accordingly, cell j in this definition will be the lower neighbor of cell i.  For example, the cell with the number 6 = 110 <sub>2</sub> is the upper neighbor of the cell with the number 7 = 111 <sub>2</sub> , and the lower neighbor of the cell with the number 2 = 010 <sub>2</sub> . <br><h4>  Lifting and lowering elements </h4><br>  Lifting and lowering operations are defined in the same way as they were defined above for generalized tables.  To implement these operations for binary tables, by virtue of the definition of upper and lower neighbors just made, we need an efficient algorithm for iterating over all single (ascent) or zero (descent) bits of a given integer number.  Especially for those who are too lazy to think in this direction, there is a wonderful book by Henry Warren ‚ÄúAlgorithmic Tricks for Programmers‚Äù, where there are formulas of interest to us.  So, to reset the rightmost bit of the number x, the operation x &amp; (x-1) is used.  To replace the extreme zero from the right by one, the analogous operation x | (x + 1) is used.  These operations (plus a few dances with a tambourine) are enough to organize the enumeration of all units (zeros) in a given integer. <br><h4>  Implementation </h4><br>  Below is the implementation of lifting and lowering the elements for a binary Young table represented by the vector X. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: t = i j = i <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> j: <span class="hljs-comment"><span class="hljs-comment">#       i k = j-1 l = k&amp;i if X[t]&gt;X[l]: t = l #     j = k&amp;j if i==t: return #   X[i], X[t] = X[t], X[i] #   i = t</span></span></code> </pre><br>  When descending, the neighbors are sorted in ascending order of their numbers, so when a first empty neighbor is detected (with a number larger than the table size), the search ends. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, n)</span></span></span><span class="hljs-function">:</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: t = i j = i <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#      k = j+1 l = k|i if l&gt;=n: break #     -  if X[t]&lt;X[l]: t = l #     j = k|j if i==t: return #  X[i], X[t] = X[t], X[i] i = t</span></span></code> </pre><br>  The sorting itself is done according to the standard scheme <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YoungTableauSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,n): <span class="hljs-comment"><span class="hljs-comment">#    MoveUp(X,i) for i in range(1,n): #   X[0], X[ni] = X[ni], X[0] MoveDown(X,ni)</span></span></code> </pre><br><h4>  Instead of conclusion </h4><br>  So, what have we achieved?  Someone will say that nothing special, and will be right in their own way.  Sorting clearly does not reach the optimum, losing, for example, pyramidal sorting, based on similar principles.  For the same reasons, the implementation of the ADT Queue with priority based on binary Jung tables is inferior to the same implementation using pyramids.  On top of that, the transition from standard tables to binary ones was probably the only advantage of Young tables over the pyramids - the search for an arbitrary element.  I recall that in two-dimensional tables, such a search is performed in O (n <sup>1/2</sup> ) time, but in binary tables, the search for an arbitrary value will require an almost complete enumeration of the entire table, i.e.  linear in n time.  On the other hand, as they say, who does not risk, he does not drink champagne.  We tried to come up with a new sorting algorithm and we succeeded.  Yes, and with such a rare performance O (nlog <sup>2</sup> n)!  And yet, the author still has hope that such a beautiful data structure is simply obliged to have some interesting and useful properties that may be discovered by some of the readers.  Thanks for attention! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Literature: <br><ol><li>  Kormen T. et al. - Algorithms.  Construction and Analysis, 2009 </li><li>  Fulton W. - Young Tables, 2006 </li><li>  Warren G. - Algorithmic Tricks for Programmers, 2004 </li></ol><br>  PS: By the way, I fully admit the idea that everything described above has already been discovered by someone once.  I would be very grateful if anyone has this kind of information and he is ready to share it! </div><p>Source: <a href="https://habr.com/ru/post/121836/">https://habr.com/ru/post/121836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121825/index.html">Podcast, where are the audio tags?</a></li>
<li><a href="../121826/index.html">Market prospects for Russian IT startups</a></li>
<li><a href="../121828/index.html">Project Manager within the matrix</a></li>
<li><a href="../121829/index.html">ActiveState acquired Phenona</a></li>
<li><a href="../121830/index.html">With age, developers are getting better, but they are getting smaller.</a></li>
<li><a href="../121837/index.html">Paste all: sports information widgets for external sites</a></li>
<li><a href="../121839/index.html">USB pan to charge the phone</a></li>
<li><a href="../121841/index.html">This software makes hacker life easier, and ours with you is more difficult.</a></li>
<li><a href="../121843/index.html">Debugger Canvas - a new way to debug code in Visual Studio</a></li>
<li><a href="../121845/index.html">The servers of EVE Online, Minecraft and The Escapist magazine were attacked</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>