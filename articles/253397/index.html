<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Kicks to common sense (part 4)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let the saber whistle the whirlwind! 
 Kostaki is not a judge for me! 
 Kostaki is right, so am I! 
 ... 

 Kozma Prutkov " New Greek Song " 

 Mat an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Kicks to common sense (part 4)</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>Let the saber whistle the whirlwind!</i></b> <b><i><br></i></b>  <b><i>Kostaki is not a judge for me!</i></b> <b><i><br></i></b>  <b><i>Kostaki is right, so am I!</i></b> <b><i><br></i></b>  <b><i>...</i></b> <b><i><br><br></i></b>  <b><i><a href="https://ru.wikiquote.org/wiki/%25D0%259A%25D0%25BE%25D0%25B7%25D1%258C%25D0%25BC%25D0%25B0_%25D0%259F%25D1%2580%25D1%2583%25D1%2582%25D0%25BA%25D0%25BE%25D0%25B2">Kozma Prutkov</a> " <a href="http://www.klassika.ru/stihi/prutkov/spit-zaliv-ehllada.html">New Greek Song</a> "</i></b> <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)">Mat</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2582">Pat</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">castling</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D1%258F%25D1%2582%25D0%25B8%25D0%25B5_%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2585%25D0%25BE%25D0%25B4%25D0%25B5">taking on the aisle</a> .  Can any other game (besides Chess) deliver a big headache to developers?  Of course!  And I'm sure most of you know <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">this game</a> ... <br><a name="habracut"></a><br><h4>  <b>7. Turkish strike</b> </h4><br>  The basis of the problem again lies forced moves.  It would be completely not interesting to play most of the <a href="http://www.di.fc.ul.pt/~jpn/gv/checkers.htm">variants of checkers</a> , without following the rule of obligatory capture.  If you can eat a player's figure, you need to eat it (even if it is very unprofitable for you)!  This principle underlies the whole matching game of checkers.  I know only one game from this family in which the mandatory take rule is not used (and this is a good example of excluding only the confirming rule). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img align="left" src="https://habrastorage.org/files/7c0/09e/da6/7c009eda6cf5482fa00cf9abe2070aad.gif">  <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1800">Ossetian checkers</a> , apparently, are one of the oldest checkers games.  Although it uses the "checkered" principle of combat (jumping over the opponent's figure), differences from the usual checkers are perhaps more than similarities.  The game does not use a chessboard.  There is no transformation of figures.  The figures go "only forward" (vertically or diagonally) on one cell and, having reached the last line, lose the ability to perform "quiet moves".  From this position, the figures can still continue to move, since it is allowed to beat the opponent‚Äôs pieces in any direction.  The most important difference from other checkers games is the fact that taking in ‚ÄúOssetian checkers‚Äù is not obligatory.  And the main unifying factor is that in one move you can take several enemy pieces at once!  The capture is carried out ‚Äúalong the chain‚Äù - after completing the ‚Äúpercussion‚Äù move, the figure can continue moving, provided that in the next step it takes another figure. <br><br><div class="spoiler">  <b class="spoiler_title">On the issue of "Kenakh"</b> <div class="spoiler_text">  Currently, on the territory of Ossetia, another interesting checker game is spread.  The <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B5%25D0%25BD%25D1%258B">Kenes</a> are played on a familiar 8x8 board.  The initial arrangement is similar to the " <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Turkish drafts</a> ".  On the last horizontal line, the transformation of figures into long-range queens (Pepper).  The moves of the figures are also carried out according to the rules similar to those used in Turkish Checkers, except that the non-transformed figure (Ken) is allowed to back and also jump over friendly kens (without a fight, of course), standing side by side (no similar rule in one of the other traditional drafts games). <br><br>  The rule of jumping over friendly figures can be understood in different ways.  Can I jump backwards (if taking backwards is allowed)?  Is it allowed to jump a few of their pieces "along the chain" and, if so, can it be interleaved by jumping over their pieces to capture the enemy?  Unfortunately, all the descriptions of ‚ÄúKenov‚Äù that I managed to find bypass these questions.  The only thing in which they are in solidarity is that such jumping over is not allowed to transformed queens (it is also impossible to jump over your queens).  In order to somehow sort out this issue, I developed my own implementation of Kenov and posted a video on YouTube: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/1GKtBh-uA3U%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjr3tBAKQpfOblxkQsMv46qRXjlGw" frameborder="0" allowfullscreen=""></iframe><br><br>  A few days ago my expectation was crowned with success.  <a href="http://www.youtube.com/user/MrSultanRatrout">Sultan Ratrout</a> provided me with detailed comments on this game.  Here is what he writes: <br><br><blockquote>  <i>There are some similarities between the two "Kena" and "Kens" checkers games.</i>  <i>It's called Ossetian Kena or simply Kena.</i> <i><br></i>  <i>...</i> <i><br></i>  <i>Kens is a game influenced by the Osseitan Kena.</i>  <i>As for the Kens rules, they are found on the websites ‚Äúdi.fc and boardgamsgeek‚Äù.</i>  <i>Kens cant jumps the same rules for Turkish checkers, but he can jump more consistently.</i> <i><br></i>  <i>...</i> </blockquote><br>  It turned out that there is not one but two similar games ‚ÄúKens‚Äù and ‚ÄúKena‚Äù (it is possible that this separation occurred precisely because of the insufficiently detailed description of the rules).  In one of them, it is impossible to jump back and ‚Äúalong the chain‚Äù, in the other - it is allowed.  In all likelihood, in both variants, taking is obligatory. <br><br>  The presence of detailed descriptions of games in publicly available sources is a really sensitive issue.  We practically lost <a href="http://skyruk.livejournal.com/244920.html">Pettya</a> and <a href="http://skyruk.livejournal.com/244920.html">Latrunkuli</a> simply because the ancient Greeks and Romans, for all their love for these games, simply did not bother to describe their rules!  Somehow (and most likely wrong) we can play <a href="http://skyruk.livejournal.com/246910.html">Hnefatafl</a> only thanks to the notes of <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25B5%25D0%25B9,_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BB">Carl Linnaeus</a> .  Attempts to reconstruct ancient games resemble a tangled <a href="http://skyruk.livejournal.com/231444.html">detective story</a> . <br><br>  We have already lost a lot of board games and continue to lose them.  The full rules of " <a href="http://skyruk.livejournal.com/459139.html">air combat</a> " are now known only to one nameless collector.  We know that <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD,_%25D0%2598%25D0%25BE%25D1%2581%25D0%25B8%25D1%2584_%25D0%2592%25D0%25B8%25D1%2581%25D1%2581%25D0%25B0%25D1%2580%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B8%25D1%2587">Stalin</a> , apparently, loved board games, but it seems that now no one will remember how <a href="http://skyruk.livejournal.com/459330.html">these figures</a> go.  I appeal to all readers.  If you know the rules of exotic and even the most common board games - share with them.  Check out the descriptions on <a href="https://www.wikipedia.org/">Wikipedia</a> and other publicly available sources.  Write to people who collect the rules of the games, do not hesitate to correct them if they are mistaken.  Do not let this knowledge disappear forever! <br></div></div><br>  So, taking in checkers games is an integral move, in the process of which the position on the board can change.  If you do not see this problem, look again carefully.  In the most ancient versions of the game (Ossetian and Turkish), the taken pieces are simply removed from the board as you progress.  At the same time, the same board field can be visited several times.  The only limitation in force in the ‚ÄúTurkish drafts‚Äù is that in the process of fighting figures, the woman cannot change the direction of movement to the opposite.  This way of fighting (in honor of the game that gave birth to it) was called the ‚ÄúTurkish strike‚Äù and its power (especially in the performance of the long-range lady) is terrifying: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/fAzYFoXMqfQ%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhhinh643JRbZc3eHuFrpGVQG3RDIA" frameborder="0" allowfullscreen=""></iframe><br><br>  In most modern versions of the game, there are special rules that make the implementation of the "Turkish strike" impossible.  Taken pieces remain on the board until the end of the turn and cannot be taken again (in order to distinguish them from other pieces, in the process of making a ‚Äústroke‚Äù turn, they are usually turned over, and upon completion they are removed from the board all at once).  Another important question concerns exactly how the rule of obligatory capture should be interpreted when performing a composite move.  And here are possible options ... <br><br>  It is easiest to assume that at any stage in the execution of a move, taking is mandatory.  Having started the ‚Äúshock‚Äù course of one of the figures, we are obliged to continue it as long as there is the possibility of the battle of enemy figures.  In other words, the ‚Äúchain of taking‚Äù cannot be interrupted; it must be passed to the end.  I know only one game in the family of drafts games (with obligatory take) where this rule does not work.  For us, this is exotic, but in Madagascar <a href="http://en.wikipedia.org/wiki/Fanorona">Fanor√≥n is</a> very popular. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/64ar37WY2Uc%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhj-ItsMXPMBgIT7WTQwrV-RJmNfUw" frameborder="0" allowfullscreen=""></iframe><br><br>  First of all, a completely unusual way of taking figures is striking.  Fanorona belongs to a rare variety of ‚Äúcontact‚Äù checkers (another interesting representative of this trend is the modern game <a href="http://www.mindsports.nl/index.php/arena/bushka/81-rules%3Fshowall%3D%26start%3D3">Bushka</a> ).  In order to remove the enemy figure from the board, you need to come close to it, or move away from it.  Not only the attacked figure is removed, but also all the enemy figures standing behind it in the direction of the attack.  Perhaps, this moment is better to <a href="http://www.boardgamesoftheworld.com/fanorona.html">illustrate</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8d9/415/61a/8d941561af494e89bafc5c735d32f453.jpg"></div><br><br>  The capture in Fanorone, as well as in checkers, is an integral move.  The attacking figure can continue to take more and more new enemy pieces, if it has such an opportunity.  The only thing that is forbidden to her is, in the course of the battle, to change the direction of movement to the opposite (almost as in ‚ÄúTurkish drafts‚Äù).  The unique difference of Fanorona from other checkers games is that the player can interrupt the chain of captures at any time, at his discretion (annoyingly, in some <a href="https://play.google.com/store/apps/details%3Fid%3Dorg.thibault.android.fanoronafree">implementations of the</a> Android game, an important element of the game mechanics is missing).  In this case, the first take is required.  You can not perform a "quiet" move, if there is the possibility of fighting enemy figures. <br><br>  Some elementary rules, connecting with others, form more and more new types of games.  In most of the drafts, the take series must be completed.  In many of them, on the last horizontal line, ordinary figures are transformed into queens.  But what if the transformation occurred in the process of "cutting"?  Different variants of the game approach this issue differently. <br><br>  In Armenian and Russian drafts, the transformation takes place in the process of combat - the figure that has become a lady, continues to take the new rules.  In Turkish, Old French and English checkers, transformation occurs only at the end of a turn.  In Turkish drafts, the figure can continue to fight (if there is such an opportunity), but since the "cutting" back is prohibited, the figure remains in the zone of transformation.  In the old French and English versions, a simple checker on the last horizontal line just cannot continue moving and stops. <br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text"><img align="left" src="https://habrastorage.org/files/413/67a/413/41367a4133f443769889be7d02ee8091.jpg">  The original way to solve this problem in another ancient game system - " <a href="http://posle-raboti.msk.ru/index/drugie_igry_s_shashkami/0-62">Senegalese checkers</a> ".  The transformation of the figures in this game does not occur.  Cutting and moves back are prohibited - the figures can move and "cut" only forward and sideways.  Checkers that have reached the last rank - just removed from the board!  This rule completely deprives the players of an incentive to advance the pieces.  It is beneficial to keep the game in the center of the board for as long as possible!  As soon as the pieces lose the opportunity to cut each other - the game ends.  The winner is the player who has more pieces left. <br></div></div><br>  Amusing metamorphosis undergoes this rule in international, 100-cell checkers.  The transformation, as before, occurs only at the end of the turn, but ‚Äúcutting back‚Äù is not only allowed, but also obligatory!  The figure must continue to fight, and if in its process it leaves the last horizontal - there will be no transformation, it will remain a simple figure! <br><br>  We have not considered another, last question, but it will give odds to all the previous ones.  The player is obliged to complete the "chain" of taking, but what to do if there are several such "chains"?  Which of the possible moves to choose?  Here opinions also diverge.  The most liberal rules adhere to the "Russian checkers".  In them, the player can choose any of the possible options for taking.  In Turkish and international drafts, there is a ‚Äúmajority rule‚Äù in its classical interpretation: of all the possible options for taking, the player must choose the one in which the largest number of enemy pieces are taken (simple ones are figures or ladies ‚Äî it doesn't matter). <br><br>  In all its glory, "social inequality" appears in the "Italian drafts".  In this game, a simple checker not only can not beat the lady, but is also valued below!  It is required to beat the maximum possible number of opponent pieces, and with an equal number of them, take the maximum number of queens.  This discrimination reaches its apogee in another Italian game.  In <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1260">Damone</a> , in addition to the <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1260">ladies</a> , there are also "emperors", inviolable for all subordinate figures.  By this, the game resembles <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1267">Dablot</a> , but, unlike the latter, transformations in it are still possible.  Simple checkers can turn into ladies, and ladies into emperors (repeated transformations are prohibited - a simple checker will never become emperor). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/38b/f2c/3d9/38bf2c3d9a9f4b099a8ada4c8f6bd995.JPG"></div><br><br>  Priority of a different kind operates in the "Portuguese checkers" - if there is a choice between taking a woman or a simple game, the player must cut it with a woman.  The most difficult formulation of the ‚Äúrule of majority‚Äù is in the ‚ÄúOld French Checkers‚Äù.  Let me <a href="http://skyruk.livejournal.com/256132.html">quote</a> : <br><br><blockquote><ul><li>  <i>Initially, the choice of two options for taking was voluntary, regardless of the quality and number of checkers, and only in 1653 the majority rule was introduced (for serial taking, the player must chop the maximum possible number).</i> </li><li>  <i>If during a series of takes, you can cut the same number of pieces with a simple piece or a queen, the player must take a queen.</i>  <i>However, if the number of drafts removed is the same in both cases, but in one ‚Äúbranch‚Äù there are enemy queens (or there are more of them), the player must choose this option, even if it is then necessary to chop with a simple checker and not a lady.</i> </li><li>  <i>In addition, the rank of the removed checkers does not matter, the serial take is subject to the number: you need to take the checkers to the maximum.</i>  <i>When choosing to take either 3 simple checkers or 2 queens, the player must take 3 simple ones.</i> </li></ul></blockquote><br>  I think you already understood that, in terms of implementation, drafts games are not any easier than chess.  What does <a href="http://www.zillions-of-games.com/">Zillions of Games</a> provide to make life easier for developers?  Consider these features: <br><br><ul><li>  Partial moves implemented by the <b>add-partial</b> command </li><li>  <b>Move</b> priorities defined by <b>move-priorities</b> </li><li>  A number of clever settings supported by the <b>option</b> command </li></ul><br>  Without the support of partial moves, there would be no talk of any implementation of checkers.  The <b>add-partial</b> command allows you to combine a sequence of takes in a long composite move.  In addition, this command allows you to transform a piece (for example, checkers into a queen) when completing any partial move (this feature is useful in Russian Checkers).  Once the capture is completed, the checkered figure cannot continue moving in a ‚Äúquiet‚Äù movement.  She must continue to take the opponent's pieces.  Obviously, some kind of possibility is required to separate partial moves by type.  And there is such an opportunity: <br><br><div class="spoiler">  <b class="spoiler_title">Types of moves</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> man-jump-add ( <span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) )) ... (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Man) ... (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> jumptype) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> ne)(<span class="hljs-name"><span class="hljs-name">man-capture</span></span> sw)(<span class="hljs-name"><span class="hljs-name">man-capture</span></span> se) (<span class="hljs-name"><span class="hljs-name">move-type</span></span> nonjumptype) (<span class="hljs-name"><span class="hljs-name">man-shift</span></span> nw) (<span class="hljs-name"><span class="hljs-name">man-shift</span></span> ne) ) )</code> </pre> <br></div></div><br>  If the move type is specified in the <b>add-partial</b> command ( <b>jumptype</b> in the example), the composite move can be continued only by moves of this type.  Types are also used to set the priority of moves: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">move-priorities</span></span> jumptype nonjumptype)</code> </pre><br>  This record means that if there is a possibility of a take, the ‚Äúquiet‚Äù move cannot be performed.  More than two types can be listed in the list of priorities, but the possibility of performing a type of a move completely prohibits all moves, the types of which follow the list.  How is the ‚Äúmajority rule‚Äù defined?  Very simple and "hardcore": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre><br>  You can specify that with an equal number of figures should take a greater number of ladies: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  This is where the possibilities end.  For example, it is impossible to specify that one should take the minimum number of figures (why this may be needed is another question).  The <b>option</b> command is useful in the implementation of Fanorona: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"pass partial"</span></span> true)</code> </pre><br>  The fact is that a player cannot simply take and stop performing a composite move.  This feature must be explicitly resolved.  I really do not like both the ‚Äúmagic‚Äù of the <b>option</b> command and the implementation, with its help, of skipping moves (in this case, partial ones), but this is perhaps a topic for another conversation. <br><br><div class="spoiler">  <b class="spoiler_title">And what about the "Turkish strike"?</b> <div class="spoiler_text">  This is all complicated.  Taken, in the process of performing a composite move, the figures must be marked (to exclude the possibility of their re-taking), using the attributes or the transformation of figures.  At the completion of the composite move, all marked shapes are removed from the board.  The problem is that the ZoG move generator does not provide any post-processing capability.  As a result, it is necessary to determine which of the partial moves are performed last. <br><br>  The code turns out to be very confusing (and in the case of Fanorona, for example, it is not at all realizable, since the player makes the decision to end the turn).  It is not surprising that such implementations are full of errors.  I often saw a piece of the pieces taken not being removed from the board, at the end of the composite move.  There are more complex cases.  Can you find the error in the following code? <br><br><div class="spoiler">  <b class="spoiler_title">Russian checkers</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> international-checker-add (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? more-captures-found?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">change-type</span></span> King) ) add else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> international-checker-jump-find mark (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> enemy? (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-name"><span class="hljs-name">not</span></span> captured?) ) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures-found? true) ) ) back ) (<span class="hljs-name"><span class="hljs-name">define</span></span> shashki-jump ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> captured?)) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> captured? true) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures-found? false) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> short-jump? true) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">international-checker-jump-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">international-checker-jump-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">international-checker-jump-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures-found?) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> captured? true) else mark capture a0 (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? nxt) nxt (<span class="hljs-name"><span class="hljs-name">if</span></span> captured? capture (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> short-jump? false)) ) back ) $<span class="hljs-number"><span class="hljs-number">1</span></span> to (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? short-jump?) (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures-found?))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">change-type</span></span> King)) (<span class="hljs-name"><span class="hljs-name">international-checker-add</span></span>) ) ) ... (<span class="hljs-name"><span class="hljs-name">variant</span></span> (<span class="hljs-name"><span class="hljs-name">title</span></span> <span class="hljs-string"><span class="hljs-string">"Shashki (Russian Draughts)"</span></span>) ... (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Checker) ... (<span class="hljs-name"><span class="hljs-name">attribute</span></span> captured? false) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> jumptype) (<span class="hljs-name"><span class="hljs-name">shashki-jump</span></span> nw ne sw) (<span class="hljs-name"><span class="hljs-name">shashki-jump</span></span> ne nw se) (<span class="hljs-name"><span class="hljs-name">shashki-jump</span></span> sw nw se) (<span class="hljs-name"><span class="hljs-name">shashki-jump</span></span> se sw ne) (<span class="hljs-name"><span class="hljs-name">move-type</span></span> nonjumptype) (<span class="hljs-name"><span class="hljs-name">checker-shift</span></span> nw) (<span class="hljs-name"><span class="hljs-name">checker-shift</span></span> ne) ) ) ... )</code> </pre><br></div></div><br>  This is part of a very successful <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D218">package of</a> "checkers" games, which includes <a href="http://www.gambiter.ru/checkers/item/276-chess-checkers.html">Belarusian chess</a> "(with a correctly working" checkmate king ") and" Liberian checkers "(with a very ingenious ban on completing the game with a triple repetition of the position), but it contains an annoying mistake. <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/9a5/672/9f2/9a56729f201741fb99bc580bf6112e8b.PNG"></div><br>  In the first case, everything is fine.  The white piece takes two blacks and turns into a queen.  The second diagram illustrates the error.  The white checker takes the black one, turns into a lady and stays on the last line, although it <b>should</b> , according to the rules of the Russian Drafts, take the next figure with the lady's move. <br><br>  Localizing the error, fix it simply.  It's all about the <b>international-checker-jump-find</b> checks that determine if the move has a continuation.  This macro checks whether it is possible to take the next figure from the target position, but does this according to the rules of the non-transformed figure.  This works for International Drafts, but does not take into account all possibilities in Russian Drafts.  My correction is not very elegant, but solves the problem: <br><br><div class="spoiler">  <b class="spoiler_title">Correction</b> <div class="spoiler_text"><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+(define shashki-checker-jump-find + mark + (while (and (on-board? $1) (empty? $1)) + $1 + ) + (if (on-board? $1) + $1 + (if (and enemy? (empty? $1)(not captured?) ) + (set-flag more-captures-found? true) + ) + ) + back +) (define shashki-jump ( $1 (verify enemy?) (verify (not captured?)) (set-attribute captured? true) (set-flag more-captures-found? false) (set-flag short-jump? true) $1 + (if (in-zone? promotion-zone) + (shashki-checker-jump-find $1) + (shashki-checker-jump-find $2) + (shashki-checker-jump-find $3) + else (international-checker-jump-find $1) (international-checker-jump-find $2) (international-checker-jump-find $3) + ) (opposite $1) (if (flag? more-captures-found?) (set-attribute captured? true) else mark capture a0 (while (on-board? nxt) nxt (if captured? capture (set-flag short-jump? false)) ) back ) $1 to (verify empty?) (verify (or (not-flag? short-jump?) (flag? more-captures-found?))) (if (in-zone? promotion-zone) (change-type King)) (international-checker-add) ) )</span></span></code> </pre><br></div></div><br>  If the figure is in the zone of transformation, use a special check, with the omission of empty fields in the direction to the enemy figure.  The next partial move will be calculated according to the rules of the course of the dam, so no changes will be required there. <br></div></div><br>  By the way, I have already mentioned, in previous articles, that descriptions of the moves of the Kings look simply monstrous.  For some reason, the <b>add-partial</b> command does not work inside the cycle (the program crashes), and the lady, in all variants of the checkers with long-range queens (except <a href="http://thaichess.narod.ru/index/0-36">Thai</a> ), should have a choice on which free field, after the taken figure , her land.  Of course, a solution was found: <br><br><div class="spoiler">  <b class="spoiler_title">The turn of the ladies</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> international-king-jump1 ( (<span class="hljs-name"><span class="hljs-name">international-king-work</span></span>) to (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? allowed?)) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? short-jump?) (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures-found?))) (<span class="hljs-name"><span class="hljs-name">international-checker-add</span></span>) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> international-king-jump2 ( (<span class="hljs-name"><span class="hljs-name">international-king-work</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) to (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? allowed?)) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? short-jump?) (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures-found?))) (<span class="hljs-name"><span class="hljs-name">international-checker-add</span></span>) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> international-king-jump3 ( (<span class="hljs-name"><span class="hljs-name">international-king-work</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) to (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? allowed?)) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? short-jump?) (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures-found?))) (<span class="hljs-name"><span class="hljs-name">international-checker-add</span></span>) ) ) ... (<span class="hljs-name"><span class="hljs-name">variant</span></span> (<span class="hljs-name"><span class="hljs-name">title</span></span> <span class="hljs-string"><span class="hljs-string">"Shashki (Russian Draughts)"</span></span>) ... (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> King) ... (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> jumptype) (<span class="hljs-name"><span class="hljs-name">international-king-jump1</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump1</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump1</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump1</span></span> se nw sw ne) (<span class="hljs-name"><span class="hljs-name">international-king-jump2</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump2</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump2</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump2</span></span> se nw sw ne) (<span class="hljs-name"><span class="hljs-name">international-king-jump3</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump3</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump3</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump3</span></span> se nw sw ne) (<span class="hljs-name"><span class="hljs-name">international-king-jump4</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump4</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump4</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump4</span></span> se nw sw ne) (<span class="hljs-name"><span class="hljs-name">international-king-jump5</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump5</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump5</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump5</span></span> se nw sw ne) (<span class="hljs-name"><span class="hljs-name">international-king-jump6</span></span> nw se ne sw) (<span class="hljs-name"><span class="hljs-name">international-king-jump6</span></span> ne sw se nw) (<span class="hljs-name"><span class="hljs-name">international-king-jump6</span></span> sw ne nw se) (<span class="hljs-name"><span class="hljs-name">international-king-jump6</span></span> se nw sw ne) ... ) ) )</code> </pre><br></div></div><br>  The choice of the field on which the woman stops is transferred to the upper level, directly into the cycle of stroke generation.  It works, but the abundance of "copy-paste" gets out beyond all reasonable limits.  Of course, there is also a cure for this, but it is even <a href="http://habrahabr.ru/post/214713/">worse than the disease</a> . <br></div></div><br>  In general, the mechanisms provided by Zillions of Games are quite efficient, if not for one thing.  With their help, it is impossible to implement ‚ÄúOssetian Kena‚Äù mentioned under the first spoiler in this article.  The problem is that starting a composite move, we do not know whether the enemy‚Äôs figures will be ‚Äúeaten‚Äù in the process of its execution.  Ken can jump over the friendly kens and beat the hostile ones, alternating these partial moves in a random order, as part of a composite move. <br><br>  Obviously, ‚Äúskipping‚Äù and ‚Äúbattle‚Äù by the ken must have the same type of move (otherwise it will not be possible to build a composite move, because an <b>add-partial</b> can take only one type), but this type of move cannot be given a higher priority, since Otherwise, simple movements will never be performed.  This means that the ‚Äúmandatory take‚Äù rule cannot be determined. <br><br>  It is less obvious that the option " <b>pass partial</b> " will have to be set to <b>true</b> (the possibility of interrupting the player‚Äôs composite move).  When jumping, the friendly ken is not deleted.  Finding the first closed loop, the program will jump on it forever.  In a reduced form, the rules are completely non-playable.  Both sides prefer to conduct meaningless maneuvers, rather than risk their pieces, substituting them for the enemy‚Äôs battle (this can be seen in the video below the first spoiler). <br><br>  Of course, I would not have started this whole conversation if I did not know how to fix it.  For a start, it is worthwhile to figure out what is stopping us in ZRF.  I see several problems: <br><br><ul><li>  Lack of pre- and post-processing when generating moves (complicates logic, prevents to realize opposition to ‚ÄúTurkish strike‚Äù in games like Fanorone) </li><li>  Combining the functions of completing the generation of a move and movement of pieces in the <b>add</b> and <b>add-partial</b> commands (one of the reasons why an <b>add-partial</b> cannot accept several types of moves) </li><li>  Using stroke types both to control the construction of a composite stroke, and to set priorities (the priority mechanism acts only on the first partial move, but not on the composite move as a whole) </li><li>  The lack of a universal mechanism for implementing the "rule of majority" (using ZRF, it is unlikely that you can correctly implement the "Old French Checkers") </li></ul><br>  In ZRF, the definition of a path generation algorithm is monolithic.  There is no possibility for executing a single code (before or after the execution of the main algorithm), within the framework of generating an arbitrary move (possibly from some group), but there is an actual need for it!  Counteraction to the ‚ÄúTurkish strike‚Äù is an excellent illustration of this. <br><br>  Because of the need to determine the last partial move (as part of a compound move), the code becomes completely unreadable and prone to various errors.  Moreover, this approach is not compatible with the early interruption of a composite course (option " <b>pass partial</b> ").  Of course, in Fanorone, it is not necessary to fight the ‚ÄúTurkish strike‚Äù (due to the specificity of the mechanism for taking figures, it is impossible), but games in which such an opportunity may be needed have a right to life. <br><br>  About the fact that combining the functions of moving figures and completing the generation of a move is not a good idea, I have already written many times before.  Fortunately, this has been fixed in <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> .  As for priorities, I generally think this decision is extremely unfortunate.  There is a more universal approach, which allows to realize both priorities and the ‚Äúrule of majority‚Äù and much more.  Let's see how the definition of ‚ÄúOssetian Kena‚Äù could look like in an ideal world: <br><br><div class="spoiler">  <b class="spoiler_title">Broken invariant</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> invariant (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count)) (<span class="hljs-name"><span class="hljs-name">set!</span></span> max-capturing-count capturing-count) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> goals (<span class="hljs-name"><span class="hljs-name">check-loss</span></span> no-moves?) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-promotion (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion) (<span class="hljs-name"><span class="hljs-name">promote</span></span> King) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-friend (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) take-piece ) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">man-move</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-empty?) drop-piece add-move ) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">man-jump</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-empty?) drop-piece (<span class="hljs-name"><span class="hljs-name">add-move-part</span></span> jump-type) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-enemy?) (<span class="hljs-name"><span class="hljs-name">increment!</span></span> capturing-count) capture (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-empty?) drop-piece (<span class="hljs-name"><span class="hljs-name">add-move-part</span></span> jump-type) ) ... (<span class="hljs-name"><span class="hljs-name">game</span></span> (<span class="hljs-name"><span class="hljs-name">title</span></span> <span class="hljs-string"><span class="hljs-string">"Ossetian Kena"</span></span>) ... (<span class="hljs-name"><span class="hljs-name">pieces</span></span> (<span class="hljs-name"><span class="hljs-name">attribute</span></span> capturing-count <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">pre</span></span> goals) (<span class="hljs-name"><span class="hljs-name">post</span></span> invariant) (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Man) (<span class="hljs-name"><span class="hljs-name">pre</span></span> check-friend) (<span class="hljs-name"><span class="hljs-name">post</span></span> check-promotion) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">mode</span></span> normal-type) (<span class="hljs-name"><span class="hljs-name">man-move</span></span> n) (<span class="hljs-name"><span class="hljs-name">man-move</span></span> w) (<span class="hljs-name"><span class="hljs-name">man-move</span></span> e) ) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">mode</span></span> jump-type) (<span class="hljs-name"><span class="hljs-name">man-jump</span></span> n) (<span class="hljs-name"><span class="hljs-name">man-jump</span></span> w) (<span class="hljs-name"><span class="hljs-name">man-jump</span></span> e) (<span class="hljs-name"><span class="hljs-name">man-jump</span></span> s) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> n) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> w) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> e) (<span class="hljs-name"><span class="hljs-name">man-capture</span></span> s) ) ) (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> King) ... ) ) )</code> </pre><br></div></div><br>  Pre- and post actions allow the logic to be divided into relatively independent fragments.  For example, a check on the transformation into a woman, in this version of the checkers, should be carried out at the end of any partial move, which has not yet been turned into a figure ( <b>Man</b> ).  Although this is a small piece of code, there‚Äôs absolutely no need to clutter up the implementation of three different types of moves.  By repeating the same fragment three times, it is three times easier to make a mistake (of course, you can use macros, but in this case, using the phrase <b>post</b> , in describing the type of figure, looks more logical). <br><br>  Other checks are located in the global description section of <b>pieces</b> .  This code is executed before and after the completion of the entire composite move (it is here that the transformation of the figures into ‚ÄúInternational Checkers‚Äù should be carried out).  Here, with the phrase <b>attribute,</b> you can define variables that are available at any stage of the execution of a compound stroke.  In <b>capturing-count,</b> we count the total number of pieces taken.  The invariant is that this value should not be less than the maximum number of pieces taken in all generated moves. <br><br>  But how can this work?  It is good if the moves are generated in the direction of reducing the number of pieces taken (then new variants will be discarded during the check), but we cannot guarantee such an order of generation of moves!  Here you can go for a little trick.  In addition to testing, you can create a pending condition associated with each generated move.  If, when generating a subsequent move, the value of <b>max-capturing-count</b> changes, it will be necessary to recheck all previously generated moves (they will not have to be regenerated again) and weed out those for which the condition is no longer fulfilled. <br><br>  This mechanism is similar to the one I proposed for the ‚Äúoptimized‚Äù calculation of the <b>no-moves?</b>  .  It is too expensive each time to generate moves only to determine the player‚Äôs loss.  It is much more reasonable to register a deferred check, generate moves in the usual way and record a defeat after the fact, if the resulting list of moves is empty.  In the case of invariants, this mechanism is used not for optimization purposes, but to ensure their correct calculation.  This is what I call the " <b>broken invariant</b> " and I believe that this concept will be very useful to me when designing a move generator.  In any case, it is much more universal than the mechanisms proposed by the Zillions of Games and the Axiom Development Kit. <br></div><p>Source: <a href="https://habr.com/ru/post/253397/">https://habr.com/ru/post/253397/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253387/index.html">We write processing Asterisk AMI do it yourself. Part one: create a class in PHP to refer to an asterisk or how to make a php socket client yourself</a></li>
<li><a href="../253389/index.html">The hero of IT-stories: quest</a></li>
<li><a href="../253391/index.html">DUMP-2015 Conference: Serverside.Experience and Serverside.Knowledge section</a></li>
<li><a href="../253393/index.html">As we with third-graders programmed the address garland</a></li>
<li><a href="../253395/index.html">Mongoose rake</a></li>
<li><a href="../253401/index.html">Analysis of the tasks of the warm-up training round of the Russian Code Cup 2015</a></li>
<li><a href="../253403/index.html">Semaphore App. Ruby on Rails. Continuous integration / delivery</a></li>
<li><a href="../253405/index.html">The Golden App mobile application competition has started</a></li>
<li><a href="../253407/index.html">CNC machine with advanced functionality</a></li>
<li><a href="../253413/index.html">Installing gitolite on a Centos server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>