<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural generator of Khrushchev</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I sat at home, read an article about Khrushchev and admired the genius of the architect. Then he let me go, and I thought that the despondency an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural generator of Khrushchev</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/c2c/ac7/421/c2cac7421e1c530930791e9c4039f629.gif">  Once I sat at home, read <a href="http://lurkmore.to/%25D0%25A5%25D1%2580%25D1%2583%25D1%2589%25D1%2591%25D0%25B2%25D0%25BA%25D0%25B0">an article about Khrushchev</a> and admired the genius of the architect.  Then he let me go, and I thought that the despondency and monotony of the Khrushchev can be described mathematically very easily.  Right angles, equal intervals, minimum decorations - what could be simpler? <br><br>  In fact, the Khrushchev there are several dozen modifications, but some kind of basis, the essence of the Khrushchev still can be traced. <br><br>  In general, without thinking twice, I sat down and wrote a C # generator for C # under <a href="http://unity3d.com/">Unity3d</a> .  Under the cat description of the algorithm and thinking on the topic of uv-cards, submesh and shaders. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  ‚ñ£ First try.  Total programming of all geometry. </h4><br>  For starters, I tried to do everything programmatically.  There are several advantages to this approach: there is no need to open the editor, the size of the distribution kit is smaller and it is easier to manipulate the mathematical side of the models.  There are no downsides, if you type quickly, you have a lot of paper and good imagination.  Manually connecting vertices into triangles is not very easy. <br><br><blockquote><img align="right" src="https://habrastorage.org/getpro/habr/post_images/202/1ae/03a/2021ae03abde0b737e75a3ebd007f6d0.png">  <i>For those who do not know:</i> <i><br></i>  <i>You have probably heard that three-dimensional models consist of polygons.</i>  <i>Polygons are usually understood as triangles.</i>  <i>Triangles are described using vertices and links between them.</i>  <i>In addition to this information, a list of normals is applied ‚Äî vectors that tell the graphics engine how to light the model.</i> <i><br></i> </blockquote><br>  Take for example a window.  If it is completely flat and is just a small square in a small square, then it is already eight peaks and ten triangles.  If you drown the window a little into the wall, then these are four more vertices and eight more triangles.  And if you add a window sill or a box with flowers?  Personally, from such calculations, my ears begin to blow steam. <br><br><div class="spoiler">  <b class="spoiler_title">Code to create a primitive window</b> <div class="spoiler_text">  At the entrance there are four panel tops with a window.  From the product of vectors we find the normal.  Calculate four more vertices for the corners of the window.  Putting everything into suitable arrays, making triangles from vertices.  We distribute triangles on submesh.  About submeshs read on. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EntrancePanel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vertex0, Vector3 vertex1, Vector3 vertex2, Vector3 vertex3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross((vertex1 - vertex0), (vertex2 - vertex0)).normalized; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window0 = vertex0 + (vertex3 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span> + (vertex1 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window1 = vertex0 + (vertex3 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span> + (vertex1 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window2 = vertex0 + (vertex3 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.75f</span></span> + (vertex1 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window3 = vertex0 + (vertex3 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.75f</span></span> + (vertex1 - vertex0) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh { vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {vertex0, vertex1, vertex2, vertex3, window0, window1, window2, window3, window0, window1, window2, window3}, normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { normal, normal, normal, normal, normal, normal, normal, normal, normal, normal, normal, normal }, uv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.75f</span></span>, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.75f</span></span>, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)}, triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, subMeshCount = <span class="hljs-number"><span class="hljs-number">2</span></span> }; mesh.SetTriangles(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-number"><span class="hljs-number">0</span></span>); mesh.SetTriangles(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre> </div></div><br>  The option is interesting, but after I spent a lot of time creating a wall, window, front door and a glazed balcony, I suddenly felt sad, and I decided to go in from the other side. <br><br><h4>  ‚ñ£ The second attempt.  All through the editor, with submeshs and lots of materials </h4><br>  Generally speaking, the engine is completely indifferent to the origin of vertices, triangles and normals.  Two models, one of which was ‚Äúborn‚Äù in the code, and the other in Blender, will make excellent friends and will work the same way.  Moreover, they can be merged into one model with submeshes (submodels? <i>Subgrids? Subguns?</i> ), All of whose transformations will affect submeshes.  Submeshes are just additional lists with vertex indices, nothing more. <br><br>  On each of the submes, you can hang your own material, which will make the glass shiny and the walls rough.  The idea is quite tolerable, only each material is an additional challenge to the shader, and spying on submesh indices turned out to be an incredibly dreary task.  I played a little with submeshes and abandoned this venture. <br><br><h4>  ‚ñ£ Third attempt.  Camo shader and texture maps </h4><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/d60/4c0/a2d/d604c0a2d89540aa9e681c7d6143d8f4.png">  Video cards love when they are fed polygons and textures in large chunks.  For example, it is much easier for them to swallow one model with a million triangles than a million models with one triangle.  The same principle applies to textures.  When a bunch of pictures are glued together into one large, a texture atlas is obtained.  Often, several texture atlases are made: one for color, the other for lighting, and the third for reflections. <br><br>  I decided to write my own shader, the benefit of Unity is simple, and I used a single atlas for texturing the models.  The shader accepts this atlas and an additional map of shiny surfaces, into which I have brought all the windows. <br><br><div class="spoiler">  <b class="spoiler_title">Shader code for Khrushchev</b> <div class="spoiler_text">  The code below is the usual Specular shader that comes with Unity, in which windows are rendered into a separate map and a parameter is added to change their color. <br><br><pre> <code class="objectivec hljs">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Khrushchyovka"</span></span> { Properties { _Color (<span class="hljs-string"><span class="hljs-string">"Main Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Base (RGBA)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _GlassColor (<span class="hljs-string"><span class="hljs-string">"Glass Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _Shininess (<span class="hljs-string"><span class="hljs-string">"Shininess"</span></span>, Range (<span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.078125</span></span> _SpecColor (<span class="hljs-string"><span class="hljs-string">"Specular Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _SpecTex (<span class="hljs-string"><span class="hljs-string">"Specular (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGPROGRAM</span></span> <span class="hljs-meta"><span class="hljs-meta">#pragma surface surf BlinnPhong sampler2D _MainTex, _SpecTex; fixed4 _Color, _GlassColor; half _Shininess; struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutput o) { half4 main = tex2D (_MainTex, IN.uv_MainTex); half4 spec = tex2D(_SpecTex, IN.uv_MainTex); o.Albedo = main.rgb * _Color.rgb + spec.rgb * _GlassColor.rgb; o.Gloss = spec.rgb; o.Specular = _Shininess; } ENDCG } FallBack </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Diffuse"</span></span></span><span class="hljs-meta"> }</span></span></code> </pre></div></div><br><br><h4>  ‚ñ£ We build a wall </h4><br>  Now the fun part is building the building.  The easiest way to start is from one wall.  To make a wall of several panels, they must be placed side by side.  In the <a href="http://habrahabr.ru/post/194620/">previous article</a> I mentioned <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh.CombineMeshes.html">CombineMeshes</a> , used to combine models.  Together with the models, he can be fed transformation matrices with which you can move, rotate and resize models.  The logic is simple: in the cycle we type the required number of models, each shift a certain distance, we get a continuous wall.  If you need a wall of a certain size, then simply divide it by the length of one panel and find out the required number of panels. <br><br>  After a brief googling, it turned out that the panels in the Khrushchev houses come in different sizes.  In order not to bother much, I made all the plates in two sizes: 2.5 m long and 3 m. In fact, the dimensions should be slightly different, but I just could not find sensible documentation. <br><br>  With two different plates to fill the interval of a given length is much more difficult.  This task has its own name - <a href="http://en.wikipedia.org/wiki/Subset_sum_problem">Subset sum problem</a> .  There are a lot of options for solving this problem; I chose a simple recursive algorithm. <br><br>  Initially, there is an array with the available panel lengths and a segment that needs to be filled.  As a result of the algorithm, another array is obtained, the numbers in which mean the number of required panels with the length of the matching index from the first array.  That is, the first array looks like this: {3, 2.5f}.  And the second for a segment of 11 meters looks like this: {2, 2}.  I also note that the array with panels is sorted in descending order. <br><br>  The segment for filling is divided integrally by the length of the largest panel, the result is added to the second array, the remainder is written to the variable.  If the remainder is zero, then the task is completed, and the result is in the second array.  If the remainder is greater than zero, this means that the largest panel overlaps it, throw out one large panel, add its length to the remainder and repeat the first operation with the remainder and the next panel in the list.  We throw out large panels until the largest panel in the second array is the smallest in the first one, or the remainder becomes zero. <br><br><div class="spoiler">  <b class="spoiler_title">Algorithm Code</b> <div class="spoiler_text">  In addition to the above, a check for the size of the remainder is added; if it is smaller than the smallest panel, then one small panel is added. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExteriorWallSizesDraft</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remainder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] draft = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (draft == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { draft = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[panels.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; draft.Length; i++) { draft[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainder &lt; panels[panels.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]) { draft[draft.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> draft; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = startIndex; i &lt; panels.Length; i++) { draft[i] += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(remainder / panels[i]); remainder %= panels[i]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainder &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; draft.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (draft[i] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == draft.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> draft; } draft[i]--; remainder += panels[i]; startIndex = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } draft = ExteriorWallSizesDraft(remainder, draft, startIndex); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> draft; }</code> </pre></div></div><br>  No matter how hard I tried, I couldn‚Äôt understand the principle of distribution of panels of different lengths, so after converting an array with a quantity into an array with lengths, it is mixed using the <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B0%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D0%25B8%25D1%2588%25D0%25B5%25D1%2580%25D0%25B0%25E2%2580%2593%25D0%2599%25D0%25B5%25D1%2582%25D1%2581%25D0%25B0">Fisher ‚Äì Yets</a> algorithm.  It turns out quite tolerable result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/815/521/6db/8155216dba342877dbfc1bc438e16ddb.png"><br><br><h4>  ‚ñ£ We design the facade </h4><br>  On different floors Khrushchev uses different panels.  On the first floor there are windows and empty walls, on the second there can be balconies.  Additionally, the building has a basement and sometimes an attic.  To create a facade map, you can take an array with the lengths of the walls and the number of floors and make a two-dimensional array in which the panel type is stored in the array of each floor.  Then on this template, you can make the appropriate panels. <br><br>  For the front facade, the algorithm is as follows.  The ground floor is filled with basement panels.  The first floor is completely filled with windows.  The second floor completely copies the first, except that part of the windows is replaced by balconies.  The third floor and above simply copy the second floor pattern all the way to the roof.  If there is an attic, then attic panels are added on top. <br><br>  If the balconies are crammed completely randomly, then an ugly jumble turns out, so it is better to place the balconies on both sides of the facade in a separate cycle symmetrically about the center.  Similarly, with windows on the front facades, there may be empty walls and windows on the first floor.  To make it look good, the windows must be symmetrical.  On the second floor of the butt, part of the windows, like the front facade, is replaced with balconies, but only on the central panels; on the extreme panels, balconies are extremely rare. <br><br>  The final touch is the door.  If you divide the number of panels by the number of doors plus one, then you can get the segments through which you need to place the doors so that they are located more or less evenly.  In fact, in real Khrushchev houses the entrance to the building is located differently, judging from the photographs and plans, but so far I have not been able to think of anything better.  On the ground floor there is the main entrance, on the next one there are windows that need to be slightly shifted during the model creation stage.  On the last floor, instead of the window, there is an empty low panel.  In some buildings, the main entrance is with a porch, then the scheme changes, but I was already too lazy to make models, so this option is not taken into account. <br><br><div class="spoiler">  <b class="spoiler_title">Facade Generator Code</b> <div class="spoiler_text">  To indicate the type of panel I use an enum, it looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> PanelType { Wall, Window, Balcony, Entrance, EntranceWall, EntranceWallLast, Socle, Attic, };</code> </pre><br><br>  The branching code below is quite simple, the variable names speak for themselves, there is nothing special to explain. <br><br><pre> <code class="cs hljs">List&lt;List&lt;PanelType&gt;&gt; FacadePattern(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> panelCount, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> floorCount, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> haveAttic=<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> longFacade=<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> entrancesCount=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> panelPattern = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;List&lt;PanelType&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entranceIndex = panelCount / (entrances + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entranceCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; floorCount+<span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { panelPattern.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;PanelType&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; panelCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entrancesCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j == entranceIndex &amp;&amp; entranceCount &lt;= entrances) { panelPattern[<span class="hljs-number"><span class="hljs-number">0</span></span>].Add(PanelType.Entrance); entranceCount++; entranceIndex = panelCount*entranceCount/(entrances + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { panelPattern[<span class="hljs-number"><span class="hljs-number">0</span></span>].Add(PanelType.Socle); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (panelPattern[<span class="hljs-number"><span class="hljs-number">0</span></span>][j] == PanelType.Entrance) { panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>].Add(PanelType.EntranceWall); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (longFacade) { panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>].Add(PanelType.Window); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>].Add(PanelType.Wall); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { panelPattern[i].Add(panelPattern[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == floorCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (panelPattern[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] == PanelType.Entrance || panelPattern[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] == PanelType.EntranceWall) { panelPattern[i][j] = PanelType.EntranceWallLast; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !longFacade) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>].Count / <span class="hljs-number"><span class="hljs-number">2</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j != panelCount - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>][j] = PanelType.Window; panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>][panelPattern[<span class="hljs-number"><span class="hljs-number">1</span></span>].Count - <span class="hljs-number"><span class="hljs-number">1</span></span> - j] = PanelType.Window; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>].Count/<span class="hljs-number"><span class="hljs-number">2</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>][j] == PanelType.Window &amp;&amp; panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>][panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>].Count - <span class="hljs-number"><span class="hljs-number">1</span></span> - j] == PanelType.Window &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>][j] = PanelType.Balcony; panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>][panelPattern[<span class="hljs-number"><span class="hljs-number">2</span></span>].Count - <span class="hljs-number"><span class="hljs-number">1</span></span> - j] = PanelType.Balcony; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haveAttic) { panelPattern.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;PanelType&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; panelCount; j++) { panelPattern[panelPattern.Count<span class="hljs-number"><span class="hljs-number">-1</span></span>].Add(PanelType.Attic); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> panelPattern; }</code> </pre></div></div><br><br><img src="https://habrastorage.org/getpro/habr/post_images/426/1db/3c4/4261db3c40fcb8f004290d5fb3e84794.png"><br><br><h4>  ‚ñ£ Roof Khrushchev </h4><br>  Four of the facade is not the house, you need a roof.  As it turned out, the roofs of Khrushchev are different.  There are flat, there are gable, there are four-pitched.  Unfortunately, the photos of Khrushchev roofs on the Internet are even smaller than the plans of their floors, so the roofs turned out naked to me.  Generally speaking, there should be ventilation chambers and roof outlets that would be easy to place if the size of the building were constant, but for my case it was necessary to come up with an algorithm for placement it is not very clear what is not clear where.  So let them be naked for now. <br><br>  For the roof, I made models with a width and a length of one meter, and then just stretched them as needed. <br><br><div class="spoiler">  <b class="spoiler_title">Roof selection</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (roofType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RoofType.Flat: combine.Add(RandomItem(roofFlat)); matrices.Add(Matrix4x4.TRS(roofHeight, Quaternion.identity, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(length, <span class="hljs-number"><span class="hljs-number">1</span></span>, width))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RoofType.FlatOverhang: combine.Add(RandomItem(roofFlat)); matrices.Add(Matrix4x4.TRS(roofHeight, Quaternion.identity, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(length + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, width + <span class="hljs-number"><span class="hljs-number">1</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RoofType.Gabled: combine.Add(RandomItem(roofGabled)); matrices.Add(Matrix4x4.TRS(roofHeight, Quaternion.identity, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(length, <span class="hljs-number"><span class="hljs-number">1</span></span>, width + <span class="hljs-number"><span class="hljs-number">1</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RoofType.Hipped: combine.Add(RandomItem(roofHipped)); matrices.Add(Matrix4x4.TRS(roofHeight, Quaternion.identity, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(length + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, width + <span class="hljs-number"><span class="hljs-number">1</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre></div></div><br>  That's all.  Khrushchev is ready. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f20/587/e5b/f20587e5b70ac6e92a83369ebef529b9.png"><br><br><h4>  ‚ñ£ Conclusion </h4><br>  The described approach has one bottleneck.  <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh.CombineMeshes.html">CombineMeshes is</a> not only slow, but it also has a limit on the number of vertices and triangles to merge.  If you suddenly as I decided to make a skyscraper Khrushchev, the number of peaks will quickly exceed 65 thousand, and you will get the ruins as in the picture below.  To avoid this, you need to write your own function gluing models. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/176/d6b/958176d6b06322e768f81186578bfab0.png"><br><br>  Project sources and binaries for different platforms can be downloaded from the links below. <br><br>  <b>Note: The link code below is outdated, see the <a href="https://github.com/Syomus/ProceduralToolkit">Procedural Toolkit for the</a> latest version</b> <br><br>  <a href="http://basmanovdaniil.github.io/ProceduralExperiments/Khrushchyovka.html">Unity Web Player</a> |  <a href="">Windows</a> |  <a href="">Linux</a> |  <a href="">Mac</a> |  <a href="https://github.com/BasmanovDaniil/ProceduralExperiments">Sources on GitHub</a> <br><br>  Left mouse button - new building, Esc - Exit. <br><br>  PS I would be glad if someone will help with the refinement of the models, from me the modeler is bad. </div><p>Source: <a href="https://habr.com/ru/post/196862/">https://habr.com/ru/post/196862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196850/index.html">Questions for interviews with the former scener</a></li>
<li><a href="../196852/index.html">Author Blackhole exploit kit arrested</a></li>
<li><a href="../196854/index.html">Misha ... no, Sergei ... no, Polina! Node-Polina!</a></li>
<li><a href="../196856/index.html">What is VPS and what it eats with - virtual server infographics</a></li>
<li><a href="../196860/index.html">Upsource: JetBrains New Platform</a></li>
<li><a href="../196864/index.html">Work with the touch screen on Arduino DUE</a></li>
<li><a href="../196866/index.html">Google introduced the 11-inch chromebook from HP</a></li>
<li><a href="../196868/index.html">Click and Grow. Half a year - normal flight</a></li>
<li><a href="../196870/index.html">Algorithms in bioinformatics, online course</a></li>
<li><a href="../196872/index.html">HTML5 frequency noise generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>