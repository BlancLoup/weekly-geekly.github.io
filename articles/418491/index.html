<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test automation resistances</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that modular testing technologies have existed for 30 years (in 1989, Kent Beck wrote the article ‚ÄúSimple Smalltalk Testing: With Pat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test automation resistances</h1><div class="post__text post__text-html js-mediator-article"><p>  Despite the fact that modular testing technologies have existed for 30 years (in 1989, Kent Beck wrote the article ‚ÄúSimple Smalltalk Testing: With Patterns‚Äù), however, not all programmers own this technology and not all companies have made automatic testing part of their corporate culture. .  Even despite the obvious advantages of automatic testing, behavioral resistance is still quite strong.  Anyone who has tried to implement automated tests knows that there will always be some reason why this could not be done. </p><br><p>  From my personal experience of introducing reliable programming techniques in my company, in companies that I advised, communicating at conferences, as well as from publicly available sources, I formulated typical objections and resistances that impede the introduction of an automatic testing culture. </p><br><p>  I grouped all the objections into a pyramid of reliable programming, which includes four levels: <a name="habracut"></a></p><br><ul><li>  <strong>Professional culture</strong> (the highest level, the basis of reliable programming) is a set of norms, unwritten rules, and employee convictions that guide him in his work.  For example: ‚ÄúSend the code uncovered by tests to the repository is bad‚Äù, ‚ÄúIt is embarrassing to be silent about errors found in the code‚Äù. </li><li>  <strong>Management</strong> is the procedures, policies, rules adopted by the organization, as well as the will (decisions) of managers.  For example: ‚ÄúEach developed feature of an application must pass a revision code.  With no exceptions!". </li><li>  <strong>Methods</strong> are scientific approaches, ways of solving a particular task.  For example: ‚ÄúIf the function of the application is difficult to test, you need to increase the application testability by using the Dependency Injection pattern‚Äù. </li><li>  <strong>Technologies</strong> (lowest level) are programming languages, libraries, frameworks, tools.  For example, JUnit, Selenium, XCTest, and so on. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Why do you need such a division?  Because the problem of one level is solved by methods of the same level or by methods of a higher level.  For example, if it is not customary in an organization to write automated tests (the problem of professional culture), then this problem cannot be solved by describing the testing business process in detail (‚Äúmanagement‚Äù level) or setting a modern framework (‚Äútechnology‚Äù level).  I give a guarantee that in a week no one will write tests, regardless of the approved business process. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Cultural objection </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  ‚ÄúMy programs don't break.  I see no need for testing. ‚Äù </h3><br><p>  This statement I heard from a beginner or overly confident programmers. <br>  Of course, once written function can not break by itself.  But here it is important to understand that over time, the program may require support, the introduction of new functions or additions to existing functions.  The complexity of the programs - the number of classes and dependencies between them - is quite large, and with time, after introducing another new function or improving an existing one, an error will occur sooner or later.  An automatic test would reveal such a regression. </p><br><p>  In addition, often such an objection can be heard from novice programmers who have no concept of testing.  For example, only crashes are considered breakage, not functional errors. </p><br><p>  At one of the interviews that I conducted, the following dialogue took place: </p><br><p>  - Do you have the skills of automatic testing? <br>  - No, I wrote simple programs, there was nothing to break. <br>  - What is your motivation to change jobs? <br>  - I want to write complex applications. </p><br><p>  I know very well how this ends.  The programmer is trusted to develop a more complex program, but he doesn‚Äôt know the methods of automatic testing, cannot test the application qualitatively, and cannot cope with the scale of the project, which will result in disruption of the project, cost overrun in the development budget, loss of reputation.  Because I personally supervised projects where I could not cope with the scale of the project and overwhelmed him precisely because of the lack of automatic tests. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Reluctance to take responsibility for the quality of the code for testing. </h3><br><p>  Automated tests are the only source of operational and objective information about the true quality of a software product.  In other words, behind the programmer's back there is always an overseer, who at any time can report to the management how well the programmer does his job.  Automatic tests allow us to link the productivity of labor not with closed tickets in Djir, but with the true quality of the software product.  And here you need to think about how to write reliably, so that each successive code change does not break existing functions.  That each new function worked not only in the scenario when everything is good, but also correctly handles errors. </p><br><p>  Responsibility is a voluntary commitment to ensure a positive result of labor.  The employee accepts this commitment because of its nature and education.  Unfortunately, due to the cultural and professional crisis, not every programmer is willing to take on such obligations. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Write immediately correctly without errors" </h3><br><p>  People who are not very familiar with how software development takes place may have a negative attitude towards developers who mention some kind of bugs. </p><br><p>  - Let's cover the app with automatic tests. <br>  - What for? <br>  - To make sure everything works correctly and there are no errors. <br>  - Do you write with errors?  Do you have low qualifications?  Write immediately correctly without errors. <br>  - Yes, but everyone makes mistakes ... <br>  - But the friend company XYZ said that they have top programmers who write without errors! </p><br><p>  Thus, the development of tests is difficult to ‚Äúsell‚Äù to customers who are not technically savvy.  As a result, the management is forced to develop a project without automatic tests, which leads to known problems. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Management Objections </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  ‚ÄúIt‚Äôs twice as long to write a program with tests.  We will not meet the deadlines. ‚Äù </h3><br><p>  At first glance, this thesis seems fair.  Writing tests really takes a lot of programmer time.  But programmers and management do not take into account that the total product development time includes not only programming, but debugging and support, as well as the huge cost of manual regression testing after making corrections. </p><br><p>  Automatic tests have several functions: </p><br><ol><li>  <strong>Checking</strong> . <br>  1.1.  Tests check whether the test object works correctly. <br>  1.2.  Tests check the quality of the programmer's work: whether the problem is solved, whether there are any side effects in the form of regressions. </li><li>  <strong>Diagnostic</strong> .  Diagnostic tests can significantly reduce the time to search for a defect.  Tests allow you to determine the location of the error to within the class and method, and sometimes to within a line of code. </li><li>  <strong>Automating</strong>  Tests allow you to quickly and easily enter the test object in the desired state for debugging. </li><li>  <strong>Documenting</strong> . <br>  4.1.  Acceptance tests fix customer requirements for the product being developed. <br>  4.2.  Tests show examples of the use of the developed component, thereby reducing the time to study the work of the system by another programmer. </li></ol><br><p>  In one of the organizations that I advised, the manager resisted the introduction of an automatic testing culture: </p><br><p> - But after all tests to write for a long time!  We will not meet the deadlines! <br>  - Do you have mistakes that you have been looking for and correcting for a very long time? <br>  - Yes, there are. <br>  - What is the most difficult case? <br>  - We were looking for one mistake for 80 hours. <br>  - 80 hours is two weeks of work of the programmer.  If you spent even a whole week on test automation, it would save you months of diagnosing and debugging your application! </p><br><p>  In our organization there is a postulate: ‚ÄúTo write a program with tests twice as fast!‚Äù And this postulate is not discussed.  Only factor 2 is discussed - sometimes both 3 and 4. And some projects are simply impossible to complete without proper automated testing (see a collapsed project). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  ‚ÄúWe already have a manual testing department, let them test it.‚Äù </h3><br><p>  At first glance, the separation of specializations for testing and programming seems logical. </p><br><p>  But let's look at the shortcomings of manual testing: </p><br><ul><li>  It is very expensive. </li><li>  Run for a very long time.  For example: test scripts for a mobile application ‚ÄúOnline Cinema‚Äù tester makes 40 hours.  And this is only for one platform!  If you need to test the application on iPhone, iPad, Apple TV, Android, Fire TV, then you need to spend 40 √ó 6 = 240 hours of working time, this is one and a half months, which is unacceptable for short development cycles. </li><li>  Manual testing is subject to the usual human errors - does not give an objective and true result. </li></ul><br><p>  Moreover, some types of tests can not be performed in a reasonable time, because the number of combinations of formats and different test scenarios is very large.  For example: </p><br><ol><li>  The function to import CSV files. </li><li>  Parsers of text documents. </li><li>  Financial instruments. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Method level objections </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ignorance of automatic testing methods. </h3><br><p>  Due to the crisis of education in universities, there are no disciplines for automatic testing anywhere.  There are very few such courses in commercial IT-schools.  And the existing courses are superficial and of poor quality.  Therefore, I often met a stupor with programmers: they do not know how to test non-trivial applications (more difficult than 2 + 2 = 4). </p><br><p>  In fact, the science of testing is quite extensive.  For example, not every programmer will immediately answer the questions: a) what is testability?  b) what is controllability and observability?  c) what design patterns improve application testability?  And so on. </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Programmers do not know what they are writing, what it looks like, what the functions and interfaces will be. </h3><br><p>  It is very difficult to test what is unclear how it looks.  In other words, without pre-formulated requirements for the application, the programmer cannot understand what is expected of him. </p><br><p>  The peculiarity of some projects is that they are developed using the Minimum Viable Product technology, which in other words can be described as: ‚ÄúLet's do at least something in minimum time and minimum budget,‚Äù and the programmer is considered by the customer or management as an analyst, designer, architect, programmer and tester in one bottle.  With this approach, the formal stage of designing a software system is excluded: the definition of business logic, the subject area, the interfaces of the components, as well as their internal organization of their relations between them.  There is no formalized architecture, there are no interfaces, there are no prescribed business processes - it is not clear what to test, through which interfaces and what is the expected result. </p><br><h3 id="netestoprigodnyy-kod">  Not valid code. </h3><br><p>  Testability is a project property that says: how easy it can be tested.  Testability is determined by two other properties: controllability and observability.  Manageability is a property that determines how easily an application can be entered in the desired state for testing (to fulfill preconditions).  Observability - how easy it is to consider the state after the test, compare it with the expected one. </p><br><p>  For example, two-factor authentication using SMS is very difficult to test automatically, because the function of receiving SMS is beyond the scope of the automated testing environment.  Such a system is not testable. </p><br><p>  Facing an untestable system, the programmer gives up and avoids testing such a system. </p><br><h3 id="podgotovka-testovyh-dannyh">  Preparation of test data. </h3><br><p>  One of the unobvious resistances is the preparation of test data and standards.  For example: the initial state of the database on which testing is performed.  The preparation of test data can take a lot of time and routine work, therefore this work is considered ungrateful and uninteresting among programmers. </p><br><p>  Decision: </p><br><ul><li>  development of reference values ‚Äã‚Äãand examples at the design stage of acceptance tests - they will also help resolve conflicts with the customer at the work acceptance stage; </li><li>  development of reference values ‚Äã‚Äãat the system design stage.  For example, reference HTTP requests and responses will help to integrate client and server more easily; </li><li>  development of special database building procedures in which the required database state is created automatically, rather than manually </li><li>  using the Object Mother template [Fowler, Schuh, Peter, and Stephanie Punke.  "Easing Test Object Creation in XP."  XP Universe.  2003], which helps to easily allocate and initialize objects in the required state. </li></ul><br><h3 id="obsluzhivanie-testov">  Test service. </h3><br><p>  During the development of the project to it may change the requirements (clarification, change).  Or internal refactoring may occur, which will change the class interfaces.  As requirements change, the acceptance criteria for a particular function will change, and with them the tests.  At some point, the programmer may refuse to service the tests - that is, to keep them up-to-date. </p><br><p>  Decision: </p><br><ul><li>  the use of the ‚Äúadapter‚Äù pattern in order to decouple the logic of the test from the interface that it is testing; </li><li>  use high-level tests (Gherkin, Cucumber, Given-When-Then); </li><li>  see the resistance solution ‚Äútest data preparation‚Äù. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  There is no doubt that software must be reliable: exceed consumer expectations.  Automated tests, though not the only, but an important component in the development of reliable software. </p><br><p>  I formulated typical objections and obstacles to the implementation of automatic testing, which I encountered personally in my organization, as well as in those organizations that I advised. </p><br><p>  The article outlines only the problems and barely affects their solutions.  In general, the strategy for solving the mentioned problems seems to me like this: </p><br><ol><li>  Formation and promotion of a new IT design culture, which is reliability, pride and personal responsibility for the result. </li><li>  Developing new high standards for code testing. </li><li>  Development and implementation of training courses. </li><li>  The introduction of motivation in the career of programmers and managers, linked to the quality of the developed software products, as well as with the skills of automatic testing. </li></ol><br><p>  The most important thing that I managed to understand is that the problems are at different levels: technological, methodical, managerial and cultural.  And they need to be addressed at appropriate levels.  It is very difficult to implement automatic tests if the programmer is not trained in methods of testable design or if the management does not support a culture of reliable programming in the organization. </p><br><p>  I will be grateful to examples from your practice, how easy or how hard it was to implement automated tests in your organization.  What problems did you face?  How did you solve them? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418491/">https://habr.com/ru/post/418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418479/index.html">Conference DEFCON 23. How I lost my second eye, or further research in the field of data destruction. Part 2</a></li>
<li><a href="../418481/index.html">Living in Israel - some IT related moments</a></li>
<li><a href="../418483/index.html">How to compress bootloader for STM8 to size 8 bytes in flash memory</a></li>
<li><a href="../418485/index.html">Breaking Bad 3 - Place a cross over Dark Forester</a></li>
<li><a href="../418487/index.html">About work in Germany</a></li>
<li><a href="../418493/index.html">Bluetooth First person story</a></li>
<li><a href="../418497/index.html">"I do not recognize you in make-up" (c)</a></li>
<li><a href="../418503/index.html">After 2020, the UK will get the first spaceport - in Scotland</a></li>
<li><a href="../418505/index.html">Review and Comparison of Gateway Quantum Software Platforms</a></li>
<li><a href="../418507/index.html">What did astronautics give us?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>