<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sudoku: so how many of them? Part 1/2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! This publication arose after looking through this post , in which the author tries to count the number of different sudoku. Wanting to more a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sudoku: so how many of them? Part 1/2</h1><div class="post__text post__text-html js-mediator-article">  Hi Habr!  This publication arose after looking through <a href="https://habrahabr.ru/post/312822/">this post</a> , in which the author tries to count the number of different sudoku.  Wanting to more accurately understand the question, in a couple of minutes I googled the exact answer given in this <a href="http://www.math.cornell.edu/~mec/Summer2009/Mahmood/Intro.html">article</a> .  The text of this article seemed to me interesting in itself, so I decided to make a translation (rather freestyle). <br><br><img src="https://habrastorage.org/files/d90/893/9b0/d908939b06b7475a870dbb6759ef7a53.jpg"><br><br>  Unfortunately, the original of this article was written for <s>morons of a</s> very wide range of readers, in the sense that the topic is not considered very deeply, but in some detail.  In this case, only the general approach to solving the problem, without technical details, is explained, and, in fact, it ends at the most interesting place with the phrase ‚Äúwell, then they counted it on the computer‚Äù.  As a result, I supplemented the presentation with my own comments: they are either marked in italics, or hidden under spoilers.  They reveal some technical points in more detail.  Perhaps the post along with these comments summarily pulls into a full-fledged article, rather than just a translation, but I decided to leave everything as it is (in fact, I did not find the translation button for the translation back into a regular article, and creating a new publication just for the sake of it laziness). <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  Sudoku is a puzzle that has gained worldwide popularity since 2005.  In order to solve Sudoku, we need only logic and trial and error.  Complicated maths appear only on closer examination: to calculate the number of different grids, sudoku needs combinatorics to determine the number of these grids without taking into account all possible symmetries you need group theory, and to solve sudoku on an industrial scale - the theory of complexity of algorithms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the first time, the Sudoku puzzle in a form known to us was published in 1979 in the American magazine Dell Magazines under the name ‚ÄúNumbers in Place‚Äù by Howard Garns.  In 1984, Sudoku was first published in Japan in the journal Nikoli.  It was Maki Kaji, president of Nikoli (which, by the way, specializes in all kinds of puzzles and logic games), gave the puzzle the name ‚Äúsudoku‚Äù, which in Japanese means ‚Äúsingle numbers‚Äù.  When the game became popular in Japan, it was New Zealander Wayne Gould who drew attention to it.  Wayne wrote a program that could generate hundreds of sudoku.  In 2004, he published some of these puzzles in London newspapers.  Shortly thereafter, a fever of sudoku swept across England.  In 2005, the puzzle became popular in the United States.  Sudoku began to be published regularly in many newspapers and magazines, delighting people around the world. <br><br>  The classic version of Sudoku has the form of a square table 9 √ó 9, total - 81 <b>cells</b> .  This table is divided into 9 3 √ó 3 <b>blocks</b> .  Some cells contain numbers from the set {1,2,3,4,5,6,7,8,9} (these numbers cannot be changed), the remaining cells are empty.  The goal of the game is to fill all empty cells using only the above nine numbers, so that on each horizontal line, on each vertical, and also on each block, each of the numbers would be present exactly once.  We will call these restrictions the <b>Main Rule of the</b> game. <br><br>  The rules described above refer to sudoku of <b>order</b> 3. In the general case, sudoku of order n is a table n <sup>2</sup> √ó n <sup>2</sup> divided into n <sup>2</sup> blocks of size n √ó n each.  And all this needs to be filled with numbers from 1 to n <sup>2</sup> so that the Main Rule is fulfilled. <br><br>  For example, in the following picture you can see an example of sudoku, as well as its decision: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/34c/76f/394/34c76f394bdf4283a6ef04e3ed5dcdba.JPG"></div><br><h1>  Approaches to the solution </h1><br>  They say that math is not needed to solve Sudoku - this is not true.  It actually means that only arithmetic is not needed.  The puzzle does not depend on the fact that we use numbers from 1 to 9. We can easily replace these 9 numbers with letters, colors or <a href="">sushi</a> .  In fact, to solve Sudoku you need to apply this kind of mathematical thinking, like logical deduction. <br><br>  The simplest heuristics for solving sudoku is to first write out for every empty cell all possible numbers that can be written there, without contradicting the General Rule, using the numbers given initially.  If only one option is possible for a cell, it is this one that needs to be written in this cell. <br><br>  Another approach to solve is to choose a number, and after that a row, column or block.  After that, you should consider all the positions in the row / column / block and check whether the selected number can be placed there without breaking the Main Rule.  If the number is suitable for only one position - you can safely enter it there.  Once this is done, the selected number can be excluded from the possible options for all other empty cells in the corresponding row, column, and block. <br><br>  Usually these two rules are not enough to fill the net with sudoku.  Often, more sophisticated methods are required to achieve progress, and sometimes it is necessary to go through the options and roll back if the selection fails.  A more sophisticated strategy is to look at pairs or triples of cells in a row, column, or block.  It may turn out that for the pair of cells in question only two numbers from the group are suitable, but it is unclear which of them should be placed in which of these two cells.  However, from this we can conclude that the numbers from this pair cannot appear on any other places in the group in question.  This reduces the number of options in other empty cells and helps get closer to the solution.  Similarly, if a triple of numbers can be placed only in a certain triple of positions (not clearly in what order), then these three numbers can be excluded from consideration for all other cells in the neighborhood. <br><br>  Note that in addition to the data heuristics there are many others.  You can even come up with your own solution strategies. <br><br>  When none of the simple heuristics helps, you need to try to select an empty cell with the fewest options and try one of the options.  In the case of a contradiction (repeated numbers in a row, column or block), you should cancel all your actions until the moment of your choice and try another option. <br><br>  <b>Exercise:</b> Try the above methods on this sudoku: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8e2/19e/97a/8e219e97a4de417f9ca7c23a3c923add.JPG"></div><br>  On the Internet you can find many other sudoku of any complexity and for every taste. <br><br><h1>  So how many of them? </h1><br>  This is a very interesting question.  So how many different sudoku are 9 √ó 9?  How many ways can you fill a 9 √ó 9 table with numbers from 1 to 9 so that the Main Rule is fulfilled?  We describe the method by which Bertram Felgenhauer and Frazer Jarvis calculated this number at the beginning of 2006. <br><br>  First agree on the notation.  We will call a <b>strip a</b> triple of blocks whose centers are located on the same horizontal line.  Total we have three bands - top, bottom and middle.  <b>A stack</b> will be called a triple of blocks whose centers are located on the same vertical.  We also have three stacks, like the bands, left, right and middle.  The cell at the intersection of the <b>i-th</b> row and <b>j-th</b> column will be denoted as <b>(i, j)</b> . <br><br>  Preparations are over and we are ready to count the number N - the number of different sudoku.  First, we denote all sudoku blocks as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/981/714/f0f/981714f0f4f148f9b20ce10f3bf9b4c0.JPG"></div><br>  How many ways can I fill in block B1?  Since for block B1 we have 9 numbers, one for each cell, in the first one we can write one of the numbers in one of 9 ways.  For each of these 9 ways, we have 8 ways to place one of the remaining numbers in exactly 8 ways.  For the third cell for each of these 9 √ó 8 ways, the number of options to go further is exactly 7. We are, in fact, trying to build all possible permutations of length 9 and the number of ways we need to fill the B1 block is equal to the number of these permutations - 9!  = 9 √ó 8 √ó 7 √ó 6 √ó 7 √ó 4 √ó 3 √ó 2 √ó 1 = 362880. Starting from sudoku, in which block B1 is filled in a certain way, we can get sudoku with any other filling of block B1 by simply reassigning numbers ( <i>recall that it doesn‚Äôt matter to us what numbers are where - the main thing is to know where the numbers are the same and where are different</i> )  Therefore, for simplicity, fill the block B1 with numbers from 1 to 9 in the order shown in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0ae/924/10e/0ae92410e06547d3baced199cd83d764.JPG"></div><br>  Let the number of sudoku in which block B1 is filled exactly as in the picture is N1.  The total number of sudoku will be N1 √ó 9!, Hence N1 = N / 9 !. <br><br>  Consider all the ways to fill the first row in blocks B2 and B3.  Since 1, 2 and 3 are already present in block B1, these numbers can no longer be used in this string.  Only the numbers 4, 5, 6, 7, 8 and 9 from the second and third lines of block B1 can be used in the first line of blocks B2 and B3. <br><br>  <b>Exercise:</b> List all possible ways to fill the first line in blocks B2 and B3 with permutation accuracy.  Hint: there are a total of ten ways to split six numbers into two parts of three, and changing B2 to B3, we get ten more ways.  Total - twenty. <br><br>  Let us call two of these options <b>pure upper lines</b> : when the numbers {4,5,6}, as in the second row of block B1, are placed together in B2, and the numbers {7,8,9}, as in the third row of block B1, are arranged together in B3 (well, the case when B2 and B3 are swapped).  All other methods are <b>mixed upper lines</b> , since in the first line B2 and B3, the sets {4,5,6} and {7,8,9} are mixed together. <br><br>  Well, we have these twenty ways, and we want to know how to fill in the remaining cells in the front page. <br><br>  <b>Exercise:</b> Think a little about how you can fill in the first lane starting with a clean top line 1,2,3; {4,5,6}; {7,8,9} (we write a, b, c, if there are three numbers go in fixed order and {a, b, c} if these numbers can go in any order).  How many ways are there, considering the different ordering methods in B2 and B3?  It is true that there are as many of these methods as for the other clean row 1,2,3; {7,8,9}; {4,5,6}? <br><br>  Remember, we do not change the order in block B1, since we already take into account the number of grids, which are obtained by mixing devies of numbers in B1. <br><br>  It turns out that for a clean top line 1,2,3; {4,5,6}; {7,8,9} - exactly (3!) <sup>6</sup> ways, because we definitely need to put {7,8,9}; { 1,2,3} on the second line in blocks B2 and B3, and {1,2,3}; {4,5,6} - on the third line.  After that, we can randomly swap the numbers in these six triples in B2 and B3 in order to get all the configurations.  For the second clean top line, the answer is the same, since all that we change places is blocks B2 and B3. <br><br>  For the case of mixed top lines, everything is more complicated.  Let's look at the top row 1,2,3; {4,6,8}; {5,7,9}.  Further, the first lane can be filled as shown in the picture below, where a, b and c are the numbers 1, 2, 3 in any order. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0e4/4a7/344/0e44a73443ee4bd3a3f734cfde72da1b.JPG"></div><br>  As soon as the number a is chosen, b and c are the remaining two numbers in any order, since they are in the same lines.  For a, there are three ways to choose, and then we can simply mix the numbers in six triples in B2 and B3 in any order ‚Äî and you will always get a suitable front page.  Total number of configurations - 3x (3!) <sup>6</sup> .  It is easy to show that in the remaining seventeen ways we get the same number. <br><br>  Now we can calculate the total number of different upper bands for a fixed block B1: 2x (3!) <sup>6</sup> + 18x3x (3!) <sup>6</sup> = 2612736.  The first part of the sum is the number of lanes for the net upper lanes, and the second - for the mixed ones. <br><br>  Instead of counting the number of different fully filled grids for each of these 2,612,736 options, Felgenhauer and Jarvis first determined which of these upper bands had the same number of full fill options.  This analysis reduces the number of bands that we will need to consider for further calculations. <br><br>  There are several operations that leave the number of completely filled grids unchanged: reassign numbers, swap any blocks in the first lane, shuffle the columns in any block, change the order of three lines in the lane.  As soon as any of the operations change the order of the numbers in B1, we simply reassign the numbers so as to bring the B1 block to a standard form. <br><br>  When we swap the blocks B1, B2 and B3 - the number of fillings of the grids is preserved, since we start with the correct grid of sudoku, and the only way to maintain correctness in the future is to swap B4, B5, B6 and B7, B8, B9 as we changed B1, B2, B3.  In the end, all the stacks will remain the same.  In other words, each correct filling of the entire grid for one upper strip gives exactly one correct filling of the grid for the other upper strip obtained by mixing blocks B1, B2, B3. <br><br>  <b>Exercise:</b> See for yourself that if you swap blocks B2 and B3 in the next grid, the only way to keep the grid correct is to swap B5 and B6, and also B8 and B9.  The stacks remain the same, but their locations change. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2cc/7e9/4d7/2cc7e94d780a4c65bfe81d35c98cf385.JPG"></div><br>  <b>Exercise:</b> Suppose you have a correctly filled sudoku grid and you swap some columns in any of the blocks B1, B2 or B3.  What needs to be done additionally with the remaining columns so that the Sudoku grid remains correct?  For example, if you swapped the first and second columns in block B2, how would you correct the rest of the grid so that it still satisfies the Main Rule? <br><br>  The last exercise tells us that each filling of the first bar gives us a unique filling for such a first bar, in which the columns are arranged in a certain way inside the blocks. <br><br>  This observation allows us to reduce the number of front pages that we need to consider.  According to Felgenhauer and Jarvis, we shuffle the columns in blocks B2 and B3 so that the values ‚Äã‚Äãin the topmost row go in ascending order.  After that, we may swap blocks B2 and B3 so that the very first number in block B2 ( <i>upper left</i> ) is less than the very first number in block B3.  This operation is called lexicographic reduction.  Since for each of the two blocks we have exactly 6 different permutations and only 2 ways to arrange the blocks relative to each other, the lexicographic reduction tells us that for any first lane you can build a class of 6 <sup>2</sup> √ó 2 = 72 first lanes with the same number full fillings of grids ( <i>and for all elements from each class this construction will lead to the same class</i> ).  Thus, we now need to consider only 2612736/72 = 36288 front pages. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  I think it's time to start writing code to make the article a little more hardcore.  We are going to check that the lexicographically reduced upper lanes, in which the block B1 is standard - exactly 36,288 pieces. <br><br>  To begin with, we will describe the structure for our band (I, as usual, write in C ++): <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAND</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 3 blocks of 3x3 grids BAND() { for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) m[i][j][k] = 0; } void print() { for (int i=0; i&lt;3; i++) { for (int j=0; j&lt;3; j++) { for (int k=0; k&lt;3; k++) printf( "%d", m[j][i][k] ); printf( " " ); } printf( "\n" ); } printf( "\n" ); } bool is_valid( bool with_zeros ) { for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) { if (!(0&lt;=m[i][j][k] &amp;&amp; m[i][j][k]&lt;=9)) return false; if (!with_zeros &amp;&amp; m[i][j][k]==0) return false; } bool F[10]; for (int i=0; i&lt;3; i++) // check blocks { memset( F, 0, sizeof( F ) ); for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) { if (F[m[i][j][k]]) return false; if (m[i][j][k]&gt;0) F[m[i][j][k]] = true; } } for (int i=0; i&lt;3; i++) // check rows { memset( F, 0, sizeof( F ) ); for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) { if (F[m[j][i][k]]) return false; if (m[j][i][k]&gt;0) F[m[j][i][k]] = true; } } return true; } };</span></span></code> </pre> <br>  The code of explanations deserves only the is_valid () method: it checks that the Main Rule for the strip is executed.  If the with_zeros argument is true, then the method does not take into account zeros (and with zeros we will denote cells of partially filled bands, in which no digit has yet been assigned). <br><br>  The code for generating all the bands we are interested in is as follows: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_bands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BAND band, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> col, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; BAND &gt; &amp; res )</span></span></span><span class="hljs-function"> </span></span>{ col++; <span class="hljs-comment"><span class="hljs-comment">// move to the next empty cell if (col==3) { col=0; row++; } if (row==3) { row=1; block++; } if (block==3) // no next empty cell { res.push_back( band ); return; } for (int a=1; a&lt;=9; a++) { band.m[block][row][col] = a; if (band.is_valid( true )) gen_bands( band, block, row, col, res ); } } vector&lt; BAND &gt; gen_all_bands() { BAND b0; int t=1; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) b0.m[0][i][j] = t++; // b0 has standard block B1; B2 and B3 are empty vector&lt; BAND &gt; starting_bands; for (int a=4; a&lt;=4; a++) for (int b=a+1; b&lt;=9; b++) for (int c=b+1; c&lt;=9; c++) { BAND b1 = b0; b1.m[1][0][0] = a; b1.m[1][0][1] = b; b1.m[1][0][2] = c; int ind = 0; for (int d=4; d&lt;=9; d++) if (d!=a &amp;&amp; d!=b &amp;&amp; d!=c) b1.m[2][0][ind++] = d; //b1.print(); starting_bands.push_back( b1 ); } // we filled the first row by all possible ways printf( "bands with filled the first row %d\n", (int)starting_bands.size() ); // 10 bands total vector&lt; BAND &gt; reduced_bands; for (int i=0; i&lt;(int)starting_bands.size(); i++) gen_bands( starting_bands[i], 0, 2, 2, reduced_bands ); printf( "lexicographically reduced bands %d\n", (int)reduced_bands.size() ); // 36288 bands total return reduced_bands; }</span></span></code> </pre><br>  First we prepare the starting_bands - the bands in which block B1 is filled and the first lines of blocks B2 and B3.  There are only 10 of them, because in order to maintain the lexicographical order, we do not take into account options when block B2 is ‚Äúlarger‚Äù than block B3.  After this, we simply search through all the required bands.  The calculations given above in the code are not used - they are more for the "head" than for the machine.  The main thing is that the numbers eventually came together.  And we will use the generated bands later in the next spoiler. <br></div></div><br>  For each of these options, we consider all sorts of permutations of the three upper blocks: there are exactly 6. And for each of these options, there are 6 <sup>3</sup> permutations of columns inside all the blocks.  After we mix everything up, you reassign the numbers so that in block B1 they all go in the standard order.  We can also randomly shuffle the top three lines, then reassign the numbers again so that the B1 block becomes standard.  After each of these operations, the amount of filling in the entire grid for this first band will remain unchanged.  Felgenhauer and Jarvis, using a computer program, determined that these operations reduce the number of front pages that it makes sense to consider, from 36,288 to only 416. <br><br>  <b>Exercise:</b> Consider a defined front page.  Do some operations on it that save the number of fillings for the entire sudoku grid.  You can start with the following: swap the first and second lines.  After that, reassign the numbers in block B1 to bring it to standard form.  Perform lexicographic reduction. <br><br>  The main thing you should pay attention to is: the band with which we started and the band with which we finished have the same amount of filling the entire grid with sudoku.  Therefore, instead of calculating the number of fillings of the grids for each band, we can count their number only for one of them. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  From this point on, some non-obviousness begins - the authors of the original offer to believe them in word.  But we are not like that - we will write code to make sure in person.  Namely: now we will check the fact that by performing the operations described above, we will end up with exactly 416 options. <br><br>  For greater clarity, let us describe what we will do now: we will build a graph.  Imagine that each of the lexicographically reduced bands is a vertex of a graph (that is, we have only 36,288 vertices).  When we apply an operation to a strip (which mixes numbers, but does not change the number of final grids for a given strip) - we in our graph connect the starting strip and the ending strip with an edge.  The edges are undirected, since each of the above operations is reversible - we can return everything backwards by doing the actions in the reverse order.  Now let's apply all sorts of operations for each strip and draw all sorts of edges.  Then, for any two vertices connected by a chain of edges, the answer will be the same.  Anyway, it will be the same for all vertices in the same connected component.  That is, we need to count the number of connected components in the resulting graph - and there should be exactly 416 of them. <br><br>  First we make modifications to the BAND structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAND</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* old code */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// turn into standard form { // relabeling int relabel[10]; int t = 1; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) relabel[m[0][i][j]] = t++; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) m[i][j][k] = relabel[m[i][j][k]]; // lexicographic reduction for (int i=1; i&lt;3; i++) { if (m[i][0][0] &gt; m[i][0][1]) for (int j=0; j&lt;3; j++) swap( m[i][j][0], m[i][j][1] ); if (m[i][0][1] &gt; m[i][0][2]) for (int j=0; j&lt;3; j++) swap( m[i][j][1], m[i][j][2] ); if (m[i][0][0] &gt; m[i][0][1]) for (int j=0; j&lt;3; j++) swap( m[i][j][0], m[i][j][1] ); } // swap B2 and B3 if (m[1][0][0] &gt; m[2][0][0]) for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) swap( m[1][i][j], m[2][i][j] ); } BAND get_copy() { BAND re; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) for (int k=0; k&lt;3; k++) re.m[i][j][k] = m[i][j][k]; return re; } BAND swap_blocks( int x, int y ) // swap blocks x and y { BAND re = get_copy(); for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) swap( re.m[x][i][j], re.m[y][i][j] ); re.normalize(); return re; } BAND swap_rows( int x, int y ) // swap rows x and y { BAND re = get_copy(); for (int i=0; i&lt;3; i++) for (int j=0; j&lt;3; j++) swap( re.m[i][x][j], re.m[i][y][j] ); re.normalize(); return re; } BAND swap_columns( int b, int x, int y ) // swap columns x and y in block b { BAND re = get_copy(); for (int i=0; i&lt;3; i++) swap( re.m[b][i][x], re.m[b][i][y] ); re.normalize(); return re; } };</span></span></span></span></code> </pre><br>  Now we can lexicographically reduce our band (the normalize () method), and also do all 3 operations described above.  When applying an operation, a copy of the object is created, then an operation is applied to the copy, then the result is normalized (so as not to go beyond the reduced 36,288 bands). <br><br>  Now we can calculate the number of connected components using standard depth traversal.  In this case, the graph is clearly not built. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BAND &amp; A, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BAND &amp; B ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Am[i][j][k] != Bm[i][j][k]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Am[i][j][k] &lt; Bm[i][j][k]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BAND &amp; A, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BAND &amp; B ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Am[i][j][k] != Bm[i][j][k]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt; BAND &gt; used_bands; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> comp_size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BAND b )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (used_bands.find( b ) != used_bands.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; comp_size++; used_bands.insert( b ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { dfs( b.swap_blocks( i, j ) ); dfs( b.swap_rows( i, j ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) dfs( b.swap_columns( k, i, j ) ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; BAND &gt; bands = gen_all_bands(); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; comp_sizes; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; BAND &gt; ident_bands; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)bands.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (used_bands.find( bands[i] ) == used_bands.end()) { comp_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; dfs( bands[i] ); comp_sizes.push_back( comp_size ); ident_bands.push_back( bands[i] ); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"number of connected components %d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)comp_sizes.size() ); <span class="hljs-comment"><span class="hljs-comment">// 416 components for (int i=0; i&lt;(int)comp_sizes.size(); i++) printf( "%d ", comp_sizes[i] ); }</span></span></code> </pre><br>  Comparison operators are needed so that they can be used by set.  As a result, the program actually finds exactly 416 connectivity components.  In comp_sizes, the sizes of these components are added, and in ident_bands, one of the vertices from each component (the bar is a representative of the class).  It should be noted that the resulting components do not always have the same size.  For example, the program displays the following dimensions: <br><br> <code>1 27 18 54 6 9 54 108 9 54 108 54 54 108 54 54 54 18 6 108 54 54 6 18 6 54 18 54 18 54 2 54 108 108 108 54 108 108 108 108 54 108 108 108 54 108 108 54 108 54 108 54 108 108 108 54 108 108 108 54 108 108 108 54 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 108 108 108 108 108 108 108 54 108 108 108 108 54 108 108 108 18 108 108 54 108 108 108 54 54 108 108 108 54 54 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 54 54 18 54 54 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 108 108 108 108 54 108 108 54 108 108 108 108 108 108 108 108 108 36 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 108 54 108 108 108 108 108 108 108 54 108 108 108 54 108 108 108 108 54 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 108 54 108 108 54 108 108 108 108 108 54 108 108 108 108 108 108 54 54 54 54 54 54 6 18 54 18 108 54 54 108 54 54 108 54 54 108 108 108 108 54 108 108 108 108 108 54 108 108 108 108 108 108 108 54 54 108 108 108 108 108 54 108 54 108 108 54 54 108 108 108 108 108 108 54 18 18 54 54 108 54 54 108 108 54 108 108 54 108 108 108 108 108 54 108 54 18 54 108 108 54 54 108 108 54 54 108 108 108 54 54 108 108 108 108 108 108 108 54 36 108 108 108 108 108 54 108 108 108 108 108 54 108 108 54 54 108 54 108 108 108 54 54 108 108 108 54 18 108 54 54 54 108 54 18 18 54 54 54 108 18 54 54 54 54 3 27 9 9 <br></code> <br><br>  Well, now, in fact, you can count the number of final fillings for each representative, multiply by the number of vertices in the corresponding component and at the end add up.  But with this we will not hurry. <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b0e/28b/707/b0e28b7076004aa1b96c2aa162a6aa43.JPG"></div><br>  There are several more operations that reduce the number of grids to consider.  If we have a pair of numbers <b>{a, b}</b> such that <b>a</b> and <b>b</b> are in the same column, moreover, <b>a</b> is on the i-th line, and <b>b</b> is on the j-th, and, among other things, there is the same pair in another column, and for this column <b>a is</b> already on the j-th row, and <b>b</b> is on the i-th row ( <i>i.e., these four numbers are in the corners of a rectangle, and the opposite numbers are equal</i> ), then we can swap numbers in both pairs and get a new correct band with the same number of finite grids.  For example, in Sudoku, just above, the numbers 8 and 9 in the sixth and ninth columns form this configuration.  Having considered all possible cases, Felgenhauer and Jarvis reduced the number of front pages needed for consideration from 416 to 174. <br><br>  But that's not all.  They considered other configurations of the same sets ( <i>of three or more numbers</i> ) lying opposite each other in two different columns or rows that can be swapped and the response will not change.  This reduces the number of options to 71, and if we further consider these options and apply more complex symmetries there, the number of bands for consideration can be reduced to 44. And for each of these 44 bands, all the other bands in the corresponding class have the same number of complete fillings of the entire grid. . <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  Let's supplement our program with new operations in order to get improvements up to 174 and up to 71 lanes.  We will not improve up to 44 lanes - everything is quite difficult there, and there is very little intelligible information about this.  Felgenhauer and Jarvis in their article improve only to 71, and they bring the number 44 already at the end after all calculations (however, they also write that there are suitable transformations to get the required 44 bands - about this at the end of this spoiler). <br><br>  So, let's add the operation of swapping two pairs of numbers, which are located in the corners of one rectangle.  This is very easy to add to the code already written: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAND</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* old code */</span></span> <span class="hljs-function"><span class="hljs-function">BAND </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_cross</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c2 )</span></span></span><span class="hljs-function"> </span></span>{ BAND re = get_copy(); <span class="hljs-comment"><span class="hljs-comment">// note: b1 must be together with c1 and b2 must be together with c2 if (re.m[b1][r1][c1] == re.m[b2][r2][c2] &amp;&amp; re.m[b1][r2][c1] == re.m[b2][r1][c2]) { swap( re.m[b1][r1][c1], re.m[b2][r1][c2] ); swap( re.m[b1][r2][c1], re.m[b2][r2][c2] ); } re.normalize(); return re; } }; void dfs( BAND b ) { /* old code */ for (int b1=0; b1&lt;3; b1++) for (int b2=b1+1; b2&lt;3; b2++) for (int r1=0; r1&lt;3; r1++) for (int r2=r1+1; r2&lt;3; r2++) for (int c1=0; c1&lt;3; c1++) for (int c2=0; c2&lt;3; c2++) dfs( b.swap_cross( b1, b2, r1, r2, c1, c2 ) ); }</span></span></code> </pre><br>  We simply iterate through all the rectangles (the only optimization is that the left and right columns of this rectangle should lie in different blocks for obvious reasons) and check that the numbers in the opposite corners are the same.  If this is so, we make a change to the band, otherwise we leave the band unchanged (then, in fact, in our graph it generates a loop that does not affect anything). <br><br>  If we run the updated code, we get, as expected, exactly 174 bands. <br><br>  Add more operations: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BAND</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* old code */</span></span> <span class="hljs-function"><span class="hljs-function">BAND </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_3x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c2 )</span></span></span><span class="hljs-function"> </span></span>{ BAND re = get_copy(); <span class="hljs-comment"><span class="hljs-comment">// note: b1 must be together with c1 and b2 must be together with c2 if (( re.m[b1][0][c1] == re.m[b2][1][c2] &amp;&amp; re.m[b1][1][c1] == re.m[b2][2][c2] &amp;&amp; re.m[b1][2][c1] == re.m[b2][0][c2]) || ( re.m[b1][0][c1] == re.m[b2][2][c2] &amp;&amp; re.m[b1][1][c1] == re.m[b2][0][c2] &amp;&amp; re.m[b1][2][c1] == re.m[b2][1][c2])) { swap( re.m[b1][0][c1], re.m[b2][0][c2] ); swap( re.m[b1][1][c1], re.m[b2][1][c2] ); swap( re.m[b1][2][c1], re.m[b2][2][c2] ); } re.normalize(); return re; } BAND swap_mask( int r1, int r2, int mask ) { BAND re = get_copy(); int num1=0, num2=0; for (int i=0; i&lt;3; i++) // block for (int j=0; j&lt;3; j++) // col if ((mask&gt;&gt;(i*3+j))&amp;1) { num1 += (1&lt;&lt;re.m[i][r1][j]); num2 += (1&lt;&lt;re.m[i][r2][j]); } if (num1 == num2) for (int i=0; i&lt;3; i++) // block for (int j=0; j&lt;3; j++) // col if ((mask&gt;&gt;(i*3+j))&amp;1) swap( re.m[i][r1][j], re.m[i][r2][j] ); re.normalize(); return re; } }; void dfs( BAND b ) { /* old code */ for (int b1=0; b1&lt;3; b1++) for (int b2=b1+1; b2&lt;3; b2++) for (int c1=0; c1&lt;3; c1++) for (int c2=0; c2&lt;3; c2++) dfs( b.swap_3x2( b1, b2, c1, c2 ) ); for (int r1=0; r1&lt;3; r1++) for (int r2=r1+1; r2&lt;3; r2++) for (int mask=1; mask&lt;(1&lt;&lt;9); mask++) dfs( b.swap_mask( r1, r2, mask ) ); }</span></span></code> </pre><br>  The first of the swap_3x2 () operations is the case when we look for identical subsets in two columns.  The fact is that a subset of size 1 does not exist (the Main Rule is otherwise violated), a subset of size 2 is already processed by the swap_cross () procedure, and we have 3 rows in total. Hence, we need to check only one option - all three numbers in two columns.  For them, there are exactly two match options: <br><br><img src="https://habrastorage.org/files/288/5d5/170/2885d517054f46508ed1e5289745bdc5.jpg"><br><br>  If everything is the same, we simply swap the columns.  Otherwise - leave the strip unchanged. <br><br>  For the second swap_mask () operation, we iterate over various subsets of the columns and look for two rows ‚Äî whether the sets of numbers for these subsets of columns are the same.  Examples of suitable options: <br><br><img src="https://habrastorage.org/files/75f/3b3/5cd/75f3b35cd85248a3af3d230814b45963.JPG"><br><img src="https://habrastorage.org/files/7e8/1f3/2d7/7e81f32d73b94c2f85024f32bc1d6b3e.JPG"><br><br>  In case of coincidence, we swap the found subsets (we match a pair in each column).  If there is a mismatch, we do nothing. <br><br>  It should be noted that the swap_cross () operation considered earlier is a special case of swap_mask ().  Therefore, swap_cross () can be thrown out as unnecessary. <br><br>  This time the launch of the program will be long - the program runs on my machine for about 30 seconds.  But the result is what was expected - 71. It is clear that the code was written far from optimal, but for our purposes this performance is more than enough. <br><br>  The dimensions of the connectivity components are the following: <br> <code>4 108 72 216 24 216 216 2592 216 216 1296 1404 540 108 72 510 702 270 2214 6 504 6 1350 666 702 18 756 20 2268 1134 2592 972 270 864 864 972 2052 486 270 1620 540 432 144 432 864 324 540 270 270 234 6 18 540 288 216 54 108 108 288 54 378 108 108 54 108 54 108 36 108 54 54 <br></code> <br>  As for the operations that reduce the number of options to 44, then they look something like this: <br><br><img src="https://habrastorage.org/files/a13/d05/fb6/a13d05fb6ace4f38bd02a6fc60928d93.jpg"><br><br>  You can try to describe them more formally and implement in code. <br></div></div><br>  Let C be one of 44 bands.  Then the number of ways in which C can be added to the full grid of sudoku is denoted by n <sub>C.</sub>  We will also need the number m <sub>C</sub> - the total number of lanes for which the number of final fillings is the same as that of C. When the total number of different sudoku is N = Œ£ <sub>C</sub> m <sub>C</sub> n <sub>C</sub> , that is, the sum of m <sub>C</sub> n <sub>C</sub> over all 44 lanes. <br><br>  Felgenhauer and Jarvis wrote a computer program to perform the final calculations.  They calculated the number N1 (the number of correct fillings, in which B1 is in standard form) for each of the 44 bands.  Then they multiplied that number by 9! To get an answer.  They found that the number of all possible correct sudoku grids 9 by 9 is equal to N = 6670903752021072936960, which is approximately equal to 6.671 √ó 10 <sup>21</sup> . <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  Let's and we will add our program for calculations.  Let's start with the GRID structure - sudoku grids into which numbers can be entered and for each empty cell it is possible to find out whether it is possible to write a number into it or not. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GRID</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> R[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>], C[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>], B[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( T, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( T ) ); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( R, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( R ) ); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( C, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( C ) ); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( B, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( B ) ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; j++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, T[i][j] ); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !R[x][num] &amp;&amp; !C[y][num] &amp;&amp; !B[(x/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(y/<span class="hljs-number"><span class="hljs-number">3</span></span>)][num]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_num</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ T[x][y] = num; R[x][num] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; C[y][num] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; B[(x/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(y/<span class="hljs-number"><span class="hljs-number">3</span></span>)][num] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unset_num</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ T[x][y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; R[x][num] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; C[y][num] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; B[(x/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(y/<span class="hljs-number"><span class="hljs-number">3</span></span>)][num] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } G;</code> </pre><br>  Arrays of flags R, C, and B store information about which numbers are already marked in the corresponding rows, columns, and blocks.  This then allows you to quickly determine whether you can put a number in a cell or not. <br><br>  The following procedure for each band BAND builds the initial grid for iterating over the GRID and starts the iteration: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_band</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BAND band )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nums[] = { <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>; j++) { G.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; b++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; c++) G.set_num( band.m[a][b][c], b, a*<span class="hljs-number"><span class="hljs-number">3</span></span>+c ); G.set_num( nums[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); G.set_num( nums[i], <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); G.set_num( nums[j], <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">1</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k!=i &amp;&amp; k!=j) G.set_num( nums[k], t++, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// starting grid is complete //G.print(); grids_count = 0; dfs2( 8, 0 ); res += grids_count; fprintf( stderr, "." ); } return res; }</span></span></code> </pre><br>  In fact, this procedure at the very beginning fills the first column of the grid, and not by all means, but only lexicographically reduced - this reduces further enumeration exactly 72 times (the main thing then is not to forget to multiply the answer by 72).  Total each process_band () procedure call runs dfs2 () exactly 10 times. <br><br>  The search itself looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> grids_count; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ x++; <span class="hljs-comment"><span class="hljs-comment">// find next empty cell if (x==9) { x=3; y++; } if (y==9) // no empty cells { grids_count++; return; } for (int a=1; a&lt;=9; a++) if (G.can_set( a, x, y )) { G.set_num( a, x, y ); dfs2( x, y ); G.unset_num( a, x, y ); } }</span></span></code> </pre><br>  Brute force is completely unsophisticated.  We iterate over all the remaining empty cells in the following order: first, go down the second column from the top down (in blocks B4 and B7), then go down the third column from the top down, and so on. <br><br>  One run of dfs2 () on my machine takes about 30 seconds, i.e.  processing of one strip takes about 5 minutes.  Implementation, of course, can be a little faster, you can try to do it yourself.  The Felgenhauer and Jarvis program for one lane works for about 2 minutes (as they write in their article), i.e.  only 2.5 times faster than our implementation.  Full processing of all 71 bands (for our program) takes 6 hours. <br><br>  As a result, the program displays the following: <br><pre> <code class="cpp hljs">bands with filled the first row <span class="hljs-number"><span class="hljs-number">10</span></span> lexicographically reduced bands <span class="hljs-number"><span class="hljs-number">36288</span></span> number of connected components <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> x <span class="hljs-number"><span class="hljs-number">108374976</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">102543168</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span> x <span class="hljs-number"><span class="hljs-number">100231616</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">99083712</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> x <span class="hljs-number"><span class="hljs-number">97282720</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">102047904</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">98875264</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">2592</span></span> x <span class="hljs-number"><span class="hljs-number">98733568</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">98875264</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">99525184</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">1296</span></span> x <span class="hljs-number"><span class="hljs-number">98369440</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">1404</span></span> x <span class="hljs-number"><span class="hljs-number">97287008</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">540</span></span> x <span class="hljs-number"><span class="hljs-number">98128064</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">98128064</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span> x <span class="hljs-number"><span class="hljs-number">97685328</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">510</span></span> x <span class="hljs-number"><span class="hljs-number">98950072</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">702</span></span> x <span class="hljs-number"><span class="hljs-number">98153104</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> x <span class="hljs-number"><span class="hljs-number">97961464</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">2214</span></span> x <span class="hljs-number"><span class="hljs-number">97961464</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> x <span class="hljs-number"><span class="hljs-number">98950072</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> x <span class="hljs-number"><span class="hljs-number">97685328</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> x <span class="hljs-number"><span class="hljs-number">99258880</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">1350</span></span> x <span class="hljs-number"><span class="hljs-number">97477096</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">666</span></span> x <span class="hljs-number"><span class="hljs-number">97549160</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">702</span></span> x <span class="hljs-number"><span class="hljs-number">97477096</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> x <span class="hljs-number"><span class="hljs-number">97549160</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">756</span></span> x <span class="hljs-number"><span class="hljs-number">96702240</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> x <span class="hljs-number"><span class="hljs-number">94888576</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">2268</span></span> x <span class="hljs-number"><span class="hljs-number">97116296</span></span> <span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">1134</span></span> x <span class="hljs-number"><span class="hljs-number">98371664</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">2592</span></span> x <span class="hljs-number"><span class="hljs-number">97539392</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">972</span></span> x <span class="hljs-number"><span class="hljs-number">97910032</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> x <span class="hljs-number"><span class="hljs-number">98493856</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">864</span></span> x <span class="hljs-number"><span class="hljs-number">98119872</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">864</span></span> x <span class="hljs-number"><span class="hljs-number">98733184</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">972</span></span> x <span class="hljs-number"><span class="hljs-number">97116296</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">2052</span></span> x <span class="hljs-number"><span class="hljs-number">96482296</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">486</span></span> x <span class="hljs-number"><span class="hljs-number">97346960</span></span> <span class="hljs-number"><span class="hljs-number">38</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> x <span class="hljs-number"><span class="hljs-number">97346960</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">1620</span></span> x <span class="hljs-number"><span class="hljs-number">97416016</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">540</span></span> x <span class="hljs-number"><span class="hljs-number">97455648</span></span> <span class="hljs-number"><span class="hljs-number">41</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">432</span></span> x <span class="hljs-number"><span class="hljs-number">98784768</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">144</span></span> x <span class="hljs-number"><span class="hljs-number">101131392</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">432</span></span> x <span class="hljs-number"><span class="hljs-number">97992064</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">864</span></span> x <span class="hljs-number"><span class="hljs-number">97756224</span></span> <span class="hljs-number"><span class="hljs-number">45</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">324</span></span> x <span class="hljs-number"><span class="hljs-number">96380896</span></span> <span class="hljs-number"><span class="hljs-number">46</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">540</span></span> x <span class="hljs-number"><span class="hljs-number">97910032</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> x <span class="hljs-number"><span class="hljs-number">97416016</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> x <span class="hljs-number"><span class="hljs-number">97714592</span></span> <span class="hljs-number"><span class="hljs-number">49</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">234</span></span> x <span class="hljs-number"><span class="hljs-number">96100688</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> x <span class="hljs-number"><span class="hljs-number">99258880</span></span> <span class="hljs-number"><span class="hljs-number">51</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> x <span class="hljs-number"><span class="hljs-number">96100688</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">540</span></span> x <span class="hljs-number"><span class="hljs-number">96482296</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">288</span></span> x <span class="hljs-number"><span class="hljs-number">96807424</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span> x <span class="hljs-number"><span class="hljs-number">97372400</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">97714592</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">97372400</span></span> <span class="hljs-number"><span class="hljs-number">57</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">95596592</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">288</span></span> x <span class="hljs-number"><span class="hljs-number">96631520</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">95596592</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">378</span></span> x <span class="hljs-number"><span class="hljs-number">95596592</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">96482296</span></span> <span class="hljs-number"><span class="hljs-number">62</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">96482296</span></span> <span class="hljs-number"><span class="hljs-number">63</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">98371664</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">97455648</span></span> <span class="hljs-number"><span class="hljs-number">65</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">97416016</span></span> <span class="hljs-number"><span class="hljs-number">66</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">97287008</span></span> <span class="hljs-number"><span class="hljs-number">67</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> x <span class="hljs-number"><span class="hljs-number">97372400</span></span> <span class="hljs-number"><span class="hljs-number">68</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> x <span class="hljs-number"><span class="hljs-number">98048704</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">98493856</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>/<span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> x <span class="hljs-number"><span class="hljs-number">98153104</span></span> total number of sudoku <span class="hljs-number"><span class="hljs-number">3546146300288</span></span>*<span class="hljs-number"><span class="hljs-number">9</span></span>!*<span class="hljs-number"><span class="hljs-number">72</span></span>*<span class="hljs-number"><span class="hljs-number">72</span></span> total time <span class="hljs-number"><span class="hljs-number">21213</span></span> sec</code> </pre><br>  To get the final result, you need to use a calculator (I didn't want to write long arithmetic), and ... everything is the same!  You can check the numbers with those that have turned out to Felgenhauer and Jarvis <a href="http://www.afjarvis.staff.shef.ac.uk/sudoku/results2.txt">here</a> . <br><br>  The full code of our program (not to collect pieces of spoilers) is <a href="http://www.everfall.com/paste/id.php%3F9puvv11924px">here</a> . <br></div></div><br><h1>  To be continued </h1><br>  In the next part, we count the number of really different sudoku, assuming that two sudoku are the same if they turn into each other by turns, reflections, shuffling of columns, and so on.  To do this, we dive into the theory of groups, get acquainted with the Burnside Lemma and, of course, write an hellish program to calculate the answer.  In general, do not miss. </div><p>Source: <a href="https://habr.com/ru/post/313224/">https://habr.com/ru/post/313224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313210/index.html">We test not absolutely real (or absolutely unreal) monitoring from New Relic and Appdynamics</a></li>
<li><a href="../313212/index.html">Blockchain ‚â† Cryptocurrency. Blockchain> Cryptocurrency</a></li>
<li><a href="../313214/index.html">The complete guide to native advertising in the mobile application</a></li>
<li><a href="../313216/index.html">Neural networks for beginners. Part 2</a></li>
<li><a href="../313218/index.html">Architecture and programming computer Vectrex</a></li>
<li><a href="../313226/index.html">Donald Knut: about his wife, kisses, "Concrete math" and a look at teaching at the university</a></li>
<li><a href="../313232/index.html">Will Microsoft HoloLens ignite or not?</a></li>
<li><a href="../313234/index.html">JavaScript 2016, and can be easier?</a></li>
<li><a href="../313236/index.html">ZeroNights 2016 program + HackQuest announcement</a></li>
<li><a href="../313238/index.html">Golden Pistols or Why couldn‚Äôt Aeroflot be tricked?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>