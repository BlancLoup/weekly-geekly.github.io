<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TDD study through intensive practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note from the translator : my experience of exploring development through testing is in many ways similar to what the author describes (although it st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TDD study through intensive practice</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note from the translator</b> : my experience of exploring development through testing is in many ways similar to what the author describes (although it started a few years later).</i>  <i>I started learning TDD on my own, at work, correcting bugs and creating new modules from scratch.</i>  <i>The effect of the use of TDD made me so powerful an impression that it gave rise to a desire to share the ability to use this technique with others.</i>  <i>I also conducted Code Retreats inside and outside my company.</i>  <i>And I see the same problems in my trainings - it is very difficult to take and ‚Äúshove‚Äù the understanding of the essence of TDD into other people's heads.</i> <i><br><br></i>  <i>Therefore, in this article I see a fresh look at the problem, which, perhaps, will give a new impetus to the study of TDD for me and my colleagues.</i>  <i>I think it will be useful for other interested in developing through testing.</i>  <i>I will be glad to see your comments.</i> <br><br>  I use TDD as a tool for learning and teaching the basics of modular design, but I have to note that the effectiveness of the training is highly dependent on the discipline of the students.  I want to do my job better and better, and therefore I‚Äôm constantly looking for new ways to plan critical steps in teaching TDD.  I think I found a microtechnique that helps in this matter, and I want to immediately share it with you. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Tl; dr? </h4><br>  Many TDD advocates recommend an approach called ‚Äúintensive practice,‚Äù but I guess that you will not have the opportunity to spend a lot of working time on the practice.  I advise people to ‚Äúuse TDD consciously,‚Äù but I still didn‚Äôt know a good way to explain the meaning of these words reasonably well, which reduced the value of my advice.  You can start using both approaches (intensive and conscious) at the same time if you start correcting bugs through tests.  Even if you still do not know how to design software at the expert level, then at least you can already study as an expert.  And fixing bugs through tests will give you a natural and not too risky opportunity to do this.  You will have the opportunity to practice in TDD diligently and deliberately.  If you have the opportunity to fix bugs at work alone, then you can use these practices without attracting too much attention, which usually occurs when talking about "intensive practice".  Just tell everyone that you are fixing bugs.  Everyone will like it. <br><br>  You just need to start by writing a test that will fall until you fix the bug.  If you need more details, read on before starting. <br><br><a name="habracut"></a><br><h5>  Details </h5><br>  While reading Gary Klein's <a href="http://link.jbrains.ca/1mIEU4I">Sources of Power</a> book, which describes how people learn to make decisions, my chapter on intensive practice attracted my attention.  (I will comment on a few quotes from the 104th page of this book.) <br><blockquote>  Since the key to effective decision-making is building expertise, one of the temptations will be to create a training that teaches people to think like experts. </blockquote><br>  It seems to me that many people are exposed to this temptation and build their trainings in such a way as to maximize the amount of expert-level information with which they can load the participants.  I did it too, but I stopped when I visited one of them as an ordinary participant.  If you open the faucet and start pouring dozens of rules and conclusions into me, I will ‚Äúoverflow‚Äù in just a couple of hours, and then I will stop listening. <br><blockquote>  In most cases it will be too long and expensive pleasure. </blockquote><br>  Yeah. <br><blockquote>  However, if we cannot teach people how to think as experts, we may be able to teach them how to learn as experts. </blockquote><br>  Go on ... <br><blockquote>  Having studied the literature, I have identified several ways in which experts in various fields can be trained: <br><ul><li>  They take part in intensive practice in such a way that every practical lesson has a purpose and evaluation criteria. </li><li>  They accumulate a vast layer of experience. </li><li>  They receive feedback: accurate, diagnostic, and timely. </li><li>  They enrich their experience by conducting ‚Äúdebriefing‚Äù to learn from their mistakes. </li></ul><br></blockquote><br>  Some of this sounds familiar, but something is a new opportunity to learn more from TDD practices. <br><br><h4>  Three of the four - not so bad </h4><br>  Earlier, I mentioned intensive practice.  In <a href="http://link.jbrains.ca/QWtA8S">‚ÄúDon't Waste Your Golden Learning Opportunity!‚Äù</a> I wrote about new practices that can be viewed as sketches.  This metaphor is taken from music, where etudes are widely used to practice technology.  Athletes, in turn, may think of practice as a game of training.  But, since most programmers are unlikely to practice outside of their day job, it makes sense to consider such practice modes that can be used during ‚Äúregular work‚Äù. <br><br>  I myself studied first the ‚Äúfirst tests‚Äù approach (test-first), and then the ‚Äútest-driven development‚Äù in the heat of daily work, when time is limited, and they expect real results from me.  Looking back now, I understand that I have done three of the four things that Klein lists as sources of training for experts. <br><br><ul><li>  I developed an extensive layer of experience using TDD to write almost all of my working code from the beginning of 2000 until I left IBM in November 2001. </li><li>  I received accurate, diagnostic, and timely feedback by asking thousands of questions and participating in serious discussions in various mailings.  (There was no StackOverflow yet.) I also answered a lot of other people's questions, which required me to read, write and improve a lot of code. </li><li>  Answering questions on mailing lists, at conferences, at user meetings, I often touched old topics over and over again, which allowed me to hone my old answers and also experience new insights.  All this experience eventually turned into my first book: <a href="http://link.jbrains.ca/TEDGGm">JUnit Recipes: Practical Methods for Programmer Testing</a> . </li></ul><br>  But even when I was practicing intensively and diligently (and even consciously), I did not go so far as to formulate an explicit goal and evaluation criterion for my practical exercises.  More precisely, sometimes I went, but more often not.  As a rule, I did not set such goals explicitly, and if I did, then it happened by chance.  Now it is time to remember my past experience and learn from it a new lesson. <br><br><h4>  Intensive TDD Practice </h4><br>  If you want to practice in TDD as a tool for the qualitative design of software systems, try to do this at work. <br><br>  Grasp fix some bug.  Most likely, you already know how to fix bugs, using the principle of ‚Äúfirst tests‚Äù (test-first), but just in case I will briefly describe this process: <br><br><ol><li>  Write an integration test that falls due to this bug.  The test does not have to pass to the end, but you can continue it as far as you need.  The main thing that he fell because of the existing bug. </li><li>  Start writing less and less (more focused) tests that bring you closer to the location of the bug.  You can use for this technique " <a href="http://link.jbrains.ca/QWvN42">Saff Squeeze</a> " (or any similar).  You can even use the debugger if you want. </li><li>  Stop when you have a minimal test (or several tests if the bug has several reasons), which describes the essence of the error causing this bug. </li><li>  Correct the error, make sure all tests pass, and then record all your changes. </li><li>  Pour yourself a cup of coffee. </li></ol><br>  And now let's go back to the four points of Klein and see how this method will help you learn how to design software at the expert level. <br><br>  <b>Does this sound like an intense practice?</b>  Yes.  When I sit down to fix the bug with this method, I treat it as an opportunity to practice writing tests, an opportunity to learn to rely less on the debugger and tracking code in my head, an opportunity to learn to better express and document (through tests) my knowledge of the code I am debugging . <br><br>  <b>Do I have a clear goal and evaluation criteria?</b>  I see a clear goal: fix a bug, learn how to write tests, learn how to write more focused tests, and also document the knowledge gained about the code so that this knowledge does not evaporate by the time I send my changes to the general repository.  And as evaluation criteria, I can choose one of the following: <br><br><ul><li>  How easy is it for me to return to these tests some time after fixing the bug and understand what I was doing? </li><li>  How easy is it for someone else to read my tests and understand what I did? </li><li>  How easy is it for me to move from large to smaller tests? </li><li>  Is any information lost when I switch from large tests to smaller ones? </li><li>  How sure am I that this particular bug will not happen again? </li><li>  How calm and comfortable do I feel when fighting a bug? </li></ul><br>  I don‚Äôt know if you would call these criteria clear enough, but at least you can start from them.  Perhaps together we can work out more successful evaluation criteria. <br><br>  <b>Will it help me to gain a vast layer of experience?</b>  It will help if I fix 50 bugs this way in the next few months.  At a minimum, if I decide to fix all the bugs in this way, I will consistently accumulate a significant amount of experience.  Especially if I fix bugs in all parts of the system.  And even more so if in several systems. <br><br>  <b>Will I receive accurate, diagnostic, timely feedback?</b>  I think yes.  Every time I write a new test, it will either pass or fall.  Therefore, at least I can understand that I have begun to approach the broken part of the code.  I can‚Äôt be 100% sure that I‚Äôve found the piece of code that causes the crash until my tests are small enough to prove it in one way or another, and I am gradually moving in that direction. <br><br>  <b>Will this help me review my old experience to get new insights?</b>  Yes and no.  No, because (as I hope) I don‚Äôt have to fix the same bug twice;  but yes, because I work this way with every new bug, so I will have to face the same parts of the system many times.  The more bugs I fix in any part of the system, the more opportunity I will have to go back to my past tests and compare my new experience with the old one.  If I spend a little time comparing what I do differently compared to previous times, this will give me the opportunity to get new insights. <br><br>  So, it seems to me that this method of correcting bugs will help the practitioner to study as an expert (at least in this interpretation of both the method and the model of training experts described by Klein).  Just try it yourself and appreciate this approach. <br><br><h4>  Outside of working with bugs </h4><br>  How can TDD be used to learn modular design principles at the expert level?  I must mention one common negligence along the way.  It is not that serious negligence, but rather the result of good intentions and at the same time misunderstanding.  I have always considered using the ‚Äúinformed approach‚Äù as particularly important.  Therefore, when someone starts to declare that the development through tests ‚Äúdoes not work‚Äù or ‚Äúcauses suffering‚Äù or ‚Äúhurts‚Äù, I join the discussion and repeat the same idea over and over again: <br><blockquote>  The rules do nothing themselves;  people do everything.  TDD, like any other practice, requires the practitioner to include brains.  He must exercise consciously. </blockquote><br>  It was true, but rather useless ... until today.  I am sure that Klein revealed to me a more accurate and applicable way to explain what ‚Äúconscious practice‚Äù is.  I am going to use it in my trainings starting today.  It seems that I used it implicitly in the study of TDD (and modular design), but so far I have not had an easy-to-remember way to formulate it.  Thank you, Gary Klein. <br><br><h4>  How to practice TDD "consciously" </h4><br>  Take a pause of a few seconds and think about when and how you are going to learn TDD.  What code?  What time?  In what conditions?  It is not necessary to limit ourselves strictly to these rules, but they will help streamline the process.  It is very important to determine for yourself when you are ready to use TDD, and in which not.  Determine it, for now, just for yourself.  You can negotiate with colleagues later. <a href="https://habr.com/ru/post/225929/"><sup>2</sup></a> . <br><br>  Once you have defined the framework in which you will practice TDD, you can ask yourself the goals and evaluation criteria for these workouts.  I'll throw some ideas. <br><br><h6>  TDD Training Goals </h6><br><ul><li>  Create through the tests an integration point with the library that you have not worked with before. </li><li>  Separate some of your code from integration with the framework. </li><li>  Write smaller tests that require a framework-oriented testing library (for example, Robolectric, NUnitASP, rspec-rails, or JSFUnit), and more tests that use regular testing libraries (regular JUnit, RSpec or pytest). </li><li>  Reduce the time it takes to create the next test. </li></ul><br><h6>  Evaluation criteria for TDD training. </h6><br><ul><li>  Have I made this part of the system easier than usual? </li><li>  Are the names in this part of the system more understandable to others, do they help to understand how to change this code? </li><li>  Can I expand this part of the system by simply adding a new code, rather than modifying the existing one? </li><li>  Does the code needed to set up the environment of my tests depend only on those parts of the system that I just created? </li><li>  If my test contains several checks, do I assume that they are strongly related to each other? </li><li>  Do my tests run fast enough?  Or have they even become faster than before? </li></ul><br>  If we sit together for at least ten minutes, then we‚Äôll probably come up with a dozen more of these useful criteria.  Select a few and keep them in mind during the next programming session, during which you will work out TDD. <br><br>  And let me turn to the issue of <b>obtaining new insights from the old experience</b> , because I often come across this, teaching others and practicing with them.  To recycle your experience, it is not necessary to conduct any classes yourself.  You can, for example, just answer other people's questions.  For example, I repeatedly answer the same questions that come from different people.  (Usually, I can not stand to repeat myself, but now I realized that these repetitions are in fact much more valuable.) The more I answer these questions, the more I reflect on my understanding.  Over time, my ideas are faced with a variety of new challenges and either strengthened or give life to new, more successful ones.  I also participate in Code Retreats specifically to work on the same small tasks over and over with new people.  Every year I experience new insights while working on the ‚Äúlife‚Äù game. <br><br>  And now I would like to go to one important point in Gary Klein‚Äôs model, the point that led me to write this article today. <br><br><h4>  Extensive layer of experience </h4><br>  For years, I have described TDD as a ‚Äútechnique for teaching design,‚Äù in which we can use a mechanism similar to the mechanism for developing language skills.  How did you learn to speak your native language?  Most likely, it looked something like this: <br><ul><li>  First, for a long time.  You just listened to the speech of the people around you. </li><li>  At some point you started saying very simple phrases. </li><li>  When you started to say these phrases, you noticed how others react to your speech. </li><li>  Sometimes you corrected, explaining that it is necessary to say this, and not that way. </li><li>  From these explanations, you extracted the rules and principles for constructing "correct" phrases. </li><li>  You relied on these rules and principles in building new proposals. </li></ul><br>  And this process went on without stopping.  The language you speak has become a tool for continuous communication with other people, including experiments, evaluation, mutual influence, attempts at correction, the extraction of new rules and principles ... - and so on until death. <br><br>  In my opinion, TDD allows you to study code design in a similar way.  It allows you to go beyond conventional programming, giving the programmer the ability to evaluate code in high-level criteria, a la "I can easily test this," or "I can separate this code from its context to run in an isolated environment" or "I can add a new behavior by adding code, not by changing an existing one. ‚Äù  You may argue that such assessments can be obtained even simply by reading and discussing the code, but it is TDD that motivates the programmer to engage in dialogue with the code, think about ‚Äúhow should this piece behave?‚Äù Or ‚Äúhow should I design this part?‚Äù From different sides .  I think that such an interactive style of creating code allows you to accumulate experience much more efficiently and faster than the traditional ‚Äúwrite a lot, read rarely‚Äù approach.  At a minimum, TDD motivates the programmer to see the code from different points of view. <br><br>  The main role in this approach is played by refactoring.  During refactoring, it is required to evaluate the existing code, understand and identify its problems, suggest a way to improve it, and then modify it in accordance with this method.  (I don‚Äôt want to conduct a major refactoring without tests, and if I didn‚Äôt write tests in the first place, I‚Äôd hardly have enough of them to make me feel confident enough when refactoring.) The refactoring process allows the programmer to see different design options for one the same code, each of which may either have certain problems or not;  This allows you to compare different design options and choose the most worthy of them.  The programmer has the opportunity to compare the ‚Äúbefore‚Äù and ‚Äúafter‚Äù states of refactoring and evaluate what effect his improvements in the code give. <br><br>  You can compare the ‚Äúbefore refactoring‚Äù design with incorrect or correct-but-poorly formulated language expressions.  And various micro-refactoring techniques (for example, ‚Äúreplacing inheritance with delegation‚Äù or ‚Äúintroducing a variable‚Äù) - with the rules and principles by which these expressions can be corrected and improved.  In this case, the refactoring itself will be similar to the act of applying these rules and principles for correcting expressions (code).  And you can evaluate your changes through the presentation of how the programmer will perceive them, who needs to read and understand what you have done.  If you cannot evaluate your work yourself or feel insecure, try to offer your options to others, ask for their evaluation.  They can correct you or at least indicate a bad style.  Just like you used this method to learn your native language, use it to learn the language of modular code design. <br><hr><br>  one <a name="1"></a>  .  Read Chapter 3 of the <a href="http://link.jbrains.ca/TeSr30">Switch</a> book to learn more about helping people change their behavior. <br>  2 <a name="2"></a>  .  I teach teams how to apply new practices through safe experiments, which helps them improve their work.  I have not written about this in detail yet, but I promise to do it.  If you can‚Äôt wait for a new article and want to know about it as soon as possible, <a href="http://link.jbrains.ca/you-have-some-questions">contact me</a> and we will work this way together. </div><p>Source: <a href="https://habr.com/ru/post/225929/">https://habr.com/ru/post/225929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225919/index.html">Sign up for a hairdresser at Amazon: an online store is preparing a raid on the service market</a></li>
<li><a href="../225921/index.html">Police arrested two Russian hackers who used the Find my iPhone function to extort</a></li>
<li><a href="../225923/index.html">General Electric developed 3D technology for printing sensors inside jet turbines.</a></li>
<li><a href="../225925/index.html">Civilization V with all additions released for Linux</a></li>
<li><a href="../225927/index.html">Devconf 2014 - Laravel practical workshop - for the first time in Russia</a></li>
<li><a href="../225931/index.html">ANGULARJS + REQUIREJS</a></li>
<li><a href="../225933/index.html">IBM received a patent for a new technology to combat Internet fraud</a></li>
<li><a href="../225935/index.html">In-Memory OLTP in SQL Server 2014. Part II</a></li>
<li><a href="../225945/index.html">We kill the "bell" from Google Chrome in the tray</a></li>
<li><a href="../225947/index.html">SwiftKey for Android. Now free</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>