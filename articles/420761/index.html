<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TypeScript 3.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript 3.0! Yes, it came out, and there are really a lot of innovations in it. Under the cat you will find a detailed description of all the lates...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TypeScript 3.0</h1><div class="post__text post__text-html js-mediator-article">  TypeScript 3.0!  Yes, it came out, and there are really a lot of innovations in it.  Under the cat you will find a detailed description of all the latest versions of the latest version, including the build mode, a new unknown type, significant changes in the API, performance improvements and much more.  Join now! <br><br><img src="https://habrastorage.org/webt/xl/ep/xt/xlepxtzys_k0mqm0crbje5aekvu.jpeg"><a name="habracut"></a><br><br>  TypeScript 3.0 released!  A new milestone in the development of TypeScript, an assistant to all users of JavaScript, has begun. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are not familiar with TypeScript yet, it‚Äôs not too late to find out about it now!  TypeScript is a JavaScript extension developed for use in the modern version of this static type language.  The TypeScript compiler reads TypeScript code containing, in particular, type declarations and annotations, and provides clean, easy to read JavaScript code in which these constructs are converted and deleted.  The resulting code runs in any runtime environment that conforms to the ECMAScript standard, for example in your favorite browser or on the Node.js server platform. <br><br>  Using such an environment means that the code will be analyzed for errors or typos before it is launched by users, but its benefits are not limited to this.  With all this information and analysis results, TimeScript improves usability by providing automatic code completion and navigation tools such as Find all References, Go to Definition, and Rename in your favorite editor. . <br><br>  To get started with the language and get more information, follow the <a href="http://typescriptlang.org/">link</a> .  If you want to try TypeScript 3.0 right now, you can download it from <a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">NuGet</a> or via npm by entering the command <br><br><pre><code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> -g typescript</code> </pre> <br>  In addition, support is available in the following editors: <br><br><ul><li>  <a href="">Visual Studio 2017</a> (version 15.2 and later); </li><li>  <a href="">Visual Studio 2015</a> (update 3 required); </li><li>  Visual Studio Code ( <a href="https://code.visualstudio.com/insiders/">you need to install a preliminary release</a> , while this feature is not supported in the main); </li><li>  <a href="https://packagecontrol.io/packages/TypeScript">Sublime Text 3 on the PackageControl site</a> . </li></ul><br>  <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support">Other editors</a> are updated according to their own graphics, but soon they will all have excellent TypeScript support. <br><br><h2>  Review Version 3.0 </h2><br>  After TypeScript 2.0, we made a brief overview of the contributions of previous versions to its current state.  Between the releases of TypeScript 1.0 and 2.0, the language includes union types, type conditions (type guards), support for the current ECMAScript standard, type aliases, JSX support, and literal and polymorphic types <code>this</code> .  If we also include the introduced non-null TypeScript 2.0 types, control flow analysis, support for tagged unions, this types and a simplified model for obtaining <code>.d.ts</code> files, then we can say that this period fully defined the basics TypeScript works. <br><br>  So what has been done since then?  What brought us to TypeScript 3.0, in addition to the new features of the ECMAScript standard like <code>async</code> / <code>async</code> / <code>await</code> asynchronous functions, generators and the extension / rest (rest / spread) operator? <br><br>  TypeScript 2.1 was a fundamental release in which a static model of metaprogramming in JavaScript was introduced.  Key request ( <code>keyof</code> ), index access ( <code>T[K]</code> ) and types of associated objects ( <code>{ [K in keyof T]: } T[K]}</code> ) - here is a list of tools that were used to more effectively model the React, Ember libraries, Lodash and others. <br><br>  In TypeScript 2.2 and 2.3 releases, there is support for the mixin class templates, <code>object</code> type (representing an object that is not a primitive), and default values ‚Äã‚Äãfor generic types.  These features have been used in a number of projects, such as Angular Material and Polymer.  In addition, TypeScript 2.3 introduced the possibility of detailed control of <code>this</code> types, which allows the language to work well with libraries such as Vue, and the <code>checkJs</code> flag was <code>checkJs</code> , allowing you to check types in JavaScript files. <br><br>  In the TypeScript 2.4 and 2.6 releases, the story continues to increase the severity of function type checking associated with some of the oldest reviews about our type system.  The <code>--strictFunctionTypes</code> flag was introduced, forcing the contravariance of parameters.  In release 2.7, the trend towards rigor has been preserved and has been expressed in testing in classes using the <code>--strictPropertyInitialization</code> flag. <br><br>  In TypeScript 2.8, conditional types are introduced, a powerful tool for static expression of types-based solutions, and release 2.9 summarizes the keyof operator and simplifies import for types. <br><br>  And that brings us to TypeScript 3.0!  Despite the new integer number in the issue, little has changed in release 3.0 (which implies a very easy update).  It introduces a new, flexible and scalable way of structuring projects, powerful new support for working with parameter lists, new types for providing explicit checks, improved JSX support, significantly more user-friendly error diagnostics, and much more. <br><br><h2>  What's new? </h2><br><ul><li>  Links to projects <br><ul><li>  <code>--build</code> mode </li><li>  Output structure management </li><li>  Future plans </li></ul></li><li>  Extract and distribute parameter lists using tuples </li><li>  New features of tuple types </li><li>  Type <code>unknown</code> </li><li>  Improved error diagnosis and user environment <br><ul><li>  Related error ranges </li><li>  Improved diagnostics and error handling </li></ul></li><li>  Support for the <code>defaultProps</code> property in JSX </li><li>  Directives <code>/// &lt;reference lib="..." /&gt;</code> </li><li>  Increase the speed of work in the editor <br><ul><li>  Refactoring named import statements </li><li>  Completion of end tags and frame with contour </li><li>  Quick fixes for unreachable code and unused tags </li></ul></li><li>  Critical changes <br><ul><li>  <code>unknown</code> is a reserved type name </li><li>  API Critical Changes </li></ul></li></ul><br><h2>  Links to projects </h2><br>  Quite often, building a library or application requires several steps.  Suppose your code base contains the <code>src</code> and <code>test</code> directories.  Suppose you have a <code>client</code> folder where the client-side code of the application is stored, and a server folder containing the server-side code on the Node.js platform, and each of them borrows a part of the code from the <code>shared</code> folder.  Perhaps you use the so-called ‚Äúsingle repository‚Äù and have many projects that are complexly dependent on each other. <br><br>  One of the most important functions that we worked on with the release of TypeScript 3.0, called "links to the project", and it is designed to simplify the work with such scripts. <br><br>  Thanks to links to a project, some TypeScript projects may depend on others.  In particular, <code>tsconfig.json</code> files <code>tsconfig.json</code> allowed to reference other <code>tsconfig.json</code> files.  Defining these dependencies makes it easy to divide the code into smaller projects, because the TypeScript compiler (and its tools) can understand the build order and the structure of the output.  This means that the assembly is faster and is performed incrementally (step by step), transparent navigation, editing and refactoring on various projects are supported.  Since TypeScript 3.0 lays the foundation for the project and provides an API, any build tool must be able to provide this. <br><br><h4>  What does this look like? </h4><br>  As a simple example, here is the <code>tsconfig.json</code> file containing references to projects. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ./src</span></span><span class="hljs-regexp"><span class="hljs-regexp">/bar/tsconfig</span></span>.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> project references. <span class="hljs-string"><span class="hljs-string">"composite"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"declaration"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Other options... <span class="hljs-string"><span class="hljs-string">"outDir"</span></span>: <span class="hljs-string"><span class="hljs-string">"../../lib/bar"</span></span>, <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"esnext"</span></span>, <span class="hljs-string"><span class="hljs-string">"moduleResolution"</span></span>: <span class="hljs-string"><span class="hljs-string">"node"</span></span>, }, <span class="hljs-string"><span class="hljs-string">"references"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"../foo"</span></span> } ] }</code> </pre> <br>  It has two new fields: <code>composite</code> and <code>references</code> . <br><br>  The <code>references</code> field simply points to other <code>tsconfig.json</code> files (or the folders in which they are contained).  Each link here is just an object with a <code>path</code> field ("path") and indicates to the TypeScript compiler that to build this project you first need to build another project to which it refers. <br><br>  Apparently, the field <code>composite</code> has the same importance.  The <code>composite</code> field ensures that certain parameters will be included that allow any project that depends on a given one to refer to it and to include it in an incremental build.  Intellectual and incremental build is important because one of the main reasons why you can abandon the project is assembly speed. <br><br>  For example, if a <code>front-end</code> project is dependent on a <code>shared</code> project, and a <code>shared</code> - on a core, then our APIs related to project references will help identify changes in the core, but reassemble only the shared ones if the types produced by the project <code>core</code> (i.e., <code>.d.ts</code> files).  This means that a change in core does not entail a global reassembly of all projects.  For this reason, setting the <code>composite</code> flag also gives rise to the setting and the <code>declaration</code> flag. <br><br><h4>  --Build mode </h4><br>  In TypeScript 3.0, a set of APIs will appear for referencing projects so that other tools can provide this fast incremental build method.  In particular, in the gulp-typescript plug-in, these APIs are already used!  Thus, later references to projects will be integrated with your chosen orchestra compilers. <br><br>  However, for many simple applications and libraries, it is advisable not to use external tools.  That is why the tbu command now sets the new flag - <code>--build</code> . <br><br>  The <code>tsc --build</code> (or its pseudonym, <code>tsc -b</code> ) takes a set of projects and builds them, as well as build dependent projects.  When using the new build mode, first, the - build flag must be set, and it can be combined with some other flags: <br><ul><li>  <code>--verbose</code> : show each step required by the build process. </li><li>  <code>--dry</code> : builds without generating output files (useful in combination with the <code>--verbose</code> option). </li><li>  <code>‚Äìclean</code> : tries to delete the output files corresponding to the specified input. </li><li>  <code>--force</code> : force a complete, non-incremental build of the project. </li></ul><br><h4>  Output structure management </h4><br>  One subtle, but incredibly useful advantage of references to projects is the logical ability to match input files with the corresponding output. <br><br>  If you have ever tried to separate the client and server parts of the application, then you might encounter problems managing the output structure. <br><br>  For example, if both the client / index.ts and server / index.ts files refer to shared / index.ts for the following projects: <br><br><img src="https://habrastorage.org/webt/sb/wy/z4/sbwyz4hbixbmi8mnvek370pitvw.png"><br><br>  ... then when we try to build client and server projects we get ... <br><br><img src="https://habrastorage.org/webt/yk/rb/ft/ykrbftrbeb_l6ca3j75g95vtdnu.png"><br><br>  ‚Ä¶but not‚Ä¶ <br><br><img src="https://habrastorage.org/webt/t3/oa/g0/t3oag0vxnflnjvvb8dqlcdgbfds.png"><br><br>  Note that after the build, we received copies of the shared folder in both the client and server.  We spent too much time on the shared shared build and added an undesirable level of nesting in lib / client / client and lib / server / server. <br><br>  The problem is that TypeScript is eagerly looking for .ts files and trying to include them in this compilation.  Ideally, TypeScript should understand that these files should not be part of the assembly in the same compilation, and instead refer to the .d.ts files for information about the types. <br><br>  Creating a tsconfig.json file for shared results in exactly this result.  It signals the TypeScript compiler: <br><br><ol><li>  that a shared project should be built independently </li><li>  and that when importing from ../shared we should look for .d.ts files in its output directory. </li></ol><br>  This allows you to avoid running a double build, as well as accidental inclusion of the entire contents of the shared. <br><br><h4>  Future plans </h4><br>  To gain a deeper understanding of the project links and the possibilities of using them, read about them in more detail in the <a href="https://github.com/Microsoft/TypeScript/issues/3469">tracker of this release</a> .  In the near future we will prepare documentation for links to projects and build mode. <br><br>  We want authors of other programming tools to maintain links to projects and continue to improve the editing environment with regard to this function.  We intend to ensure that working with links to projects goes as smoothly as developing code with a single tsconfig.json file.  If you end up using links to projects, we will be grateful for any feedback. <br><br><h2>  Extract and distribute parameter lists using tuples </h2><br>  We often take this for granted, but JavaScript allows us to treat parameter lists as first-class values ‚Äã‚Äã‚Äî using either arguments or rest parameters (for example, ... rest). <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Note that call works for functions with any number of parameters.  Unlike other languages, JavaScript does not force us to define call0, call1, call2, etc., as follows: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(param1); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(param1, param2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, param1, param2, param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(param1, param2, param3); }</code> </pre> <br>  Unfortunately, for some time there was no good way to express it in TypeScript without declaring a finite number of overloads: <br><br><pre> <code class="hljs lua">// TODO (billg): <span class="hljs-number"><span class="hljs-number">5</span></span> overloads should *probably* be enough <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> anybody? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T4</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3, param4: T4)</span></span></span></span> =&gt; R, param1: T1, param2: T2, param3: T3, param4: T4): R <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T3</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2, param3: T3)</span></span></span></span> =&gt; R, param1: T1, param2: T2, param3: T3): R <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T2</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1, param2: T2)</span></span></span></span> =&gt; R, param1: T1, param2: T2): R <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T1</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (param1: T1)</span></span></span></span> =&gt; R, param1: T1): R; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: ()</span></span></span></span> =&gt; R, param1: T1): R; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: any[])</span></span></span></span> =&gt; any, ...args: any[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); }</code> </pre> <br>  Phew!  Another fatal case with a thousand overloads!  Or at least as much of the overload as required by users. <br><br>  TypeScript 3.0 allows you to better model such scripts, since now parameters of the rest type can be universal, and their type is defined as a tuple.  Instead of declaring each of these overloads, we say that the rest parameter ... args from the fn function should be a type parameter that expands the array, and then reuse it for the ... args parameter that the call function passes: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: (...args: TS)</span></span></span><span class="hljs-function"> =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function">, ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...args)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br>  When we call the call function, TypeScript tries to extract the parameter list from what we pass to fn, and turn it into a tuple: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: number, y: string)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + y).toLowerCase(); } // The `TS` <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> parameter is inferred as `[number, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]` call(foo, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br>  When TypeScript defines TS as [number, string], and we end up using TS for the rest parameter of the call function, an instance of the function looks like this: <br><br><pre> <code class="hljs sql">function <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(fn: (...args: [<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, ...args: [<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span></code> </pre> <br>  And in TypeScript 3.0, when using a tuple in the rest, the parameter is minimized to the rest of the parameter list!  The above copy is reduced to simple parameters without tuples: <br><br><pre> <code class="hljs sql">function <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(fn: (arg1: <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, arg2: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, arg1: <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, arg2: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span></code> </pre> <br>  So, in addition to catching type conversion errors on passing invalid arguments: <br><br><pre> <code class="hljs coffeescript">function call&lt;TS extends any[], R&gt;(fn: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...args: TS)</span></span></span><span class="hljs-function"> =&gt;</span></span> R, ...args: TS): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args); } call(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: number, y: string)</span></span></span><span class="hljs-function"> =&gt;</span></span> y, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ~~~~~~~ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Error! `<span class="javascript"><span class="javascript">string</span></span>` isn<span class="hljs-string"><span class="hljs-string">'t assignable to `number`!</span></span></code> </pre> <br>  ... and type definitions from other arguments: <br><br><pre> <code class="hljs ruby">call((x, y) =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">/* .... */</span></span> }, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ^ ^ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">`x`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`y`</span></span> have their types inferred as <span class="hljs-string"><span class="hljs-string">`string`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`number`</span></span> respectively.</code> </pre> <br>  ... we can also see the tuple types that these functions define externally: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuple</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TS</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">[]&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...xs: TS)</span></span></span></span>: TS { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xs; } let x = tuple(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); // has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> `[number, number, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]`</code> </pre> <br>  But pay attention to one nuance.  To do all this work, we had to expand the possibilities of tuples ... <br><br><h4>  New features of tuple types </h4><br>  In order to model the list of parameters in the form of a tuple (as we have just discussed), we had to rethink the tuple types for a bit.  Prior to the release of TypeScript 3.0, the best of what was allowed to be modeled using tuples was the order and length of the parameter set. <br><br>  However, parameter lists are not just ordered type lists.  For example, parameters at the end may be optional: <br><br><pre> <code class="hljs lua">// Both `y` <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> `z` are optional here. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: boolean, y = 100, z?: string)</span></span></span></span> { // ... } foo(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, undefined, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br>  The last parameter may be a rest parameter. <br><br><pre> <code class="hljs lua">// `rest` accepts any number of strings - even none! <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...rest: string[])</span></span></span></span> { // ... } foo(); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>);</code> </pre> <br>  And finally, there is one rather interesting property of parameter lists - they can be empty: <br><br><pre> <code class="hljs lua">// Accepts no parameters. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // ... } foo();</code> </pre> <br>  Therefore, in order for tuples to match the parameter lists, we needed to model each of these scenarios. <br><br>  First, there are now optional elements at the end of the tuples: <br><br><pre> <code class="hljs scala"><span class="hljs-comment"><span class="hljs-comment">/** * 2D, or potentially 3D, coordinate. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinate</span></span></span><span class="hljs-class"> </span></span>= [number, number, number?];</code> </pre> <br>  The Coordinate type creates a tuple with an optional property named 2 ‚Äî an element with index 2 may not be defined!  Interestingly, since tuples use numeric literal types for their length property (length), the length property of the Coodinate tuple is type 2 |  3 <br><br>  Secondly, the rest element may now be present at the end of the tuple. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneNumberAndSomeStrings</span></span></span><span class="hljs-class"> </span></span>= [number, ...string[]];</code> </pre> <br>  Thanks to the rest elements, the tuples exhibit a very interesting behavior of "unbounded from the end."  In the example above, the type OneNumberAndSomeStrings is required for the type of its first property to be number, and one or more properties of type string are allowed.  Indexing this type of tuple with an arbitrary number number returns the type string |  number because the index value is unknown.  Similarly, since the length of the tuple is unknown, the value of the length property is just a number. <br><br>  It should be noted that in the absence of other elements, the rest element in a tuple is identical to itself: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>= [...number[]]; <span class="hljs-comment"><span class="hljs-comment">// Equivalent to `number[]`.</span></span></code> </pre> <br>  Finally, tuples can now be empty!  Although it is not very useful when used outside parameter lists, an empty tuple type can be defined as []: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyTuple</span></span></span><span class="hljs-class"> </span></span>= [];</code> </pre> <br>  As you would expect, the empty tuple has a length property of 0, and indexing with number returns the type never. <br><br><h2>  Improved error diagnosis and user environment </h2><br>  Over time, we receive more and more requests from members of our community to improve error messages.  Although this work is far from complete, we heard you and made a number of improvements in TypeScript 3.0. <br><br><h4>  Related error ranges </h4><br>  In part, the goal of a good error message is to indicate to the user also the way to correct it, or, first of all, to make it clear why this message appeared.  In most cases, it contains a lot of information or indicates several reasons for its occurrence.  From an analysis of these reasons, we can conclude that errors flow from different parts of the code. <br><br>  Related error ranges are a new way to provide this information to users.  In TypeScript 3.0, error messages can generate messages elsewhere in the code so that users can find out the cause and effect of the error. <br><br><img src="https://habrastorage.org/webt/ha/-n/h4/ha-nh4ttnfnexzsg-rj47jiu7cu.png"><br><br>  In a sense, the associated error messages can not only give an explanation to the user, but also indicate the path to the place where everything went wrong. <br><br><img src="https://habrastorage.org/webt/bf/sg/ws/bfsgws4xoje8i7_mxqpoari_wfw.png"><br><br>  These intervals will also appear in terminal mode when you run the tsc command with the --pretty mode enabled, although we are still working on improving the user interface and will take into account your feedback! <br><br><h4>  Improved diagnostics and error handling </h4><br>  In preparing the TypeScript 2.9 release, we <a href="https://github.com/Microsoft/TypeScript/issues/25310">began to pay more attention</a> to error messages, and in Release 3.0, we really tried to solve the main tasks that would allow us to perform an intelligent, clear and accurate error diagnosis.  This includes, in particular, the selection of appropriate types in case of inconsistencies in the types of union and output directly to the source of error for certain types of messages. <br><br>  We believe that our efforts have been justified, and as a result you will receive shorter and clearer error messages. <br><br><img src="https://habrastorage.org/webt/rn/fj/1a/rnfj1aowq5j-myv-1qjvdeowpui.png"><br><br><img src="https://habrastorage.org/webt/5l/tk/zu/5ltkzun56pppzlksb88k_zapume.png"><br><br><h2>  Type unknown </h2><br>  The type any (any) is a type in TypeScript, suitable for anything.  Since it covers the types of all possible values, it does not force us to do any checks before we try to call these values, construct them, or access their properties.  It also allows you to assign any type values ‚Äã‚Äãto variables that expect values ‚Äã‚Äãof any other type. <br><br>  This feature is generally useful, but cannot provide sufficient rigor. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> foo: any = <span class="hljs-number"><span class="hljs-number">10</span></span>; // <span class="hljs-type"><span class="hljs-type">All</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> these will throw errors, but <span class="hljs-type"><span class="hljs-type">TypeScript</span></span> // won't complain since `foo` has the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `any`. foo.x.prop; foo.y.prop; foo.z.prop; foo(); new foo(); upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">); foo `hello world!`; function upperCase(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toUpperCase</span></span></span><span class="hljs-class">(); }</span></span></code> </pre> <br>  Sometimes in TypeScript I want to describe a type that does not fit to anything.  This is useful for the API that wants to signal: "there can be any value here, so you need to do some checking before using it."  And users are forced to analyze the returned values ‚Äã‚Äãfor security reasons. <br><br>  TypeScript 3.0 introduces a new type called unknown, which does just that.   any,  unknown   , ,    any,  unknown          .         unknown,      . <br><br>       unknown  any,     foo   : <br><br><pre> <code class="hljs pgsql">let foo: <span class="hljs-type"><span class="hljs-type">unknown</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>; // Since `foo` has <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> `<span class="hljs-type"><span class="hljs-type">unknown</span></span>`, TypeScript // errors <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> these locations. foo.x.prop; foo.y.prop; foo.z.prop; foo(); <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> foo(); upperCase(foo); foo `hello world!`; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> upperCase(x: string) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br>       ,           ,    ,   . <br><br><pre> <code class="hljs lua">let foo: unknown = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasXYZ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: any)</span></span></span></span>: obj is { x: any, y: any, z: any } { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!obj &amp;&amp; typeof obj === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj &amp;&amp; <span class="hljs-string"><span class="hljs-string">"z"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj } // Using a user-defined <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> guard... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasXYZ(foo)) { // ...we<span class="hljs-string"><span class="hljs-string">'re allowed to access certain properties again. foo.x.prop; foo.y.prop; foo.z.prop; } // We can also just convince TypeScript we know what we'</span></span>re doing // by using a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> assertion. upperCase(foo as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upperCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.toUpperCase(); }</code> </pre> <br> :  ,    ,   ,  {} | null | undefined,   unknown           ,       : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Arrayify&lt;T&gt; = T extends <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; : never; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A = Arrayify&lt;{} | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> | undefined&gt;; // <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>[] | undefined[] | {}[] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> B = Arrayify&lt;<span class="hljs-type"><span class="hljs-type">unknown</span></span>&gt;; // <span class="hljs-type"><span class="hljs-type">unknown</span></span>[]</code> </pre> <br><h2>  defaultProps  JSX </h2><br> <i> :  .d.ts  React    , ,     .</i> <br><br>   -     TypeScript/JavaScript   ,   ,         .           ,     .       ,      . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> loudlyGreet(<span class="hljs-type"><span class="hljs-type">name</span></span> = "world") { // Thanks <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> initializer, `<span class="hljs-type"><span class="hljs-type">name</span></span>` will <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> have <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> `string` internally. // We don<span class="hljs-string"><span class="hljs-string">'t have to check for `undefined` here. console.log("HELLO", name.toUpperCase()); } // Externally, `name` is optional, and we can potentially pass `undefined` or omit it entirely. loudlyGreet(); loudlyGreet(undefined);</span></span></code> </pre> <br>   React         (props).        React  ,  defaultProps,      props. <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> non-TypeScript JSX file <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react-dom"; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Greet extends React.Component { render() { const { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;Hello ${<span class="hljs-type"><span class="hljs-type">name</span></span>.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "world", }; } // <span class="hljs-keyword"><span class="hljs-keyword">Notice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> `<span class="hljs-type"><span class="hljs-type">name</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> was specified! // vvvvvvvvv const result = ReactDOM.renderToString(&lt;Greet /&gt;); console.log(result);</code> </pre> <br>  ,   &lt;Greet /&gt;    name.    Greet,  name    ¬´world¬ª,    : Hello world!. <br><br>  , TypeScript  ,  defaultProps  -    JSX.                render: <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name?: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-comment"><span class="hljs-comment">// Notice the `!` ------v return &lt;div&gt;Hello ${name!.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: "world"} }</span></span></code> </pre> <br>      ,       . <br><br>    TypeScript 3.0        JSX,  LibraryManagedAttributes.    ,     ,   TypeScript,     JSX.  ,    ,      React  defaultProps ,   ,  propTypes. <br><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">Props</span></span> { name: string } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;Props&gt;</span></span></span><span class="hljs-class"> </span></span>{ render() { const { name } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span> ${name.toUpperCase()}!&lt;/div&gt;; } static defaultProps = { name: <span class="hljs-string"><span class="hljs-string">"world"</span></span>} } <span class="hljs-comment"><span class="hljs-comment">// Type-checks! No type assertions needed! let el = &lt;Greet /&gt;</span></span></code> </pre> <br>   ,   .  defaultProps,         Partial ,  -   (stateless function components, SFC),   defaultProps   Partial ,    .           defaultProps    (.  )       SFC   ES2015: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"world"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }: Props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello ${name.toUpperCase()}!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre> <br>  ,   .      TypeScript,   .d.ts   DefinitelyTyped      ,  ,  @types/react     .          DefinitelyTyped,        . <br><br><h2>  /// &lt;reference lib="..." /&gt; </h2><br>   ,     ,   ,   (polyfills) ‚Äî ,     API    ,      ( .d.ts),        API.   ,               TypeScript  lib.d.ts      ,   --lib  --target. ,    core-js       lib.es2015.d.ts. <br><br>     TypeScript 3.0 ,      API,   ,     : /// &lt;reference lib="..." /&gt;. <br><br> ,    Promise  ES2015      <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;reference lib="es2015.promise" /&gt;</span></span></span><span class="hljs-comment"> export {};</span></span></code> </pre> <br>    ,    TypeScript 3.0    ,      lib.es2015.promise.d.ts,    ,  Promise . <br><br><h4>      </h4><br> ,      ,  TypeScript  ,          .        TypeScript  JavaScript   ,   Visual Studio, Visual Studio Code        TypeScript.   ,    ,    ,  Go to Definition (¬´  ¬ª)       . TypeScript 3.0    . <br><br><h4>     </h4><br>       ,    ,  . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dependency <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./dependency"; // look at <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> this repetition! dependency.foo(); dependency.bar(); dependency.baz();</code> </pre> <br>   ,       ,   ,          ,   . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { foo, bar, baz } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./dependency"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// way lower in the file... foo(); bar(); baz();</span></span></code> </pre> <br>   ,      ,      . TypeScript 3.0   ,       . <br><br><img src="https://habrastorage.org/webt/-z/t2/fg/-zt2fg-ailzlgreoxw8jonn_b8m.png"><br><br><h4>        </h4><br>    TypeScript    ,      JSX: <br><br><ul><li>    JSX; </li><li>       JSX. </li></ul><br><img src="https://habrastorage.org/webt/6d/gv/nr/6dgvnrwu7ivqadbw5yillk1kroo.png"><br><br><h4>         </h4><br> TypeScript      ‚Äî   ,    . <br><br><h2>   </h2><br>         <a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes"> </a> ,    <a href="https://github.com/Microsoft/TypeScript/wiki/API-Breaking-Changes/"> API</a> . <br><br>  ,   TypeScript 3    ,    .       ,       API     . <br><br><h4> unknown ‚Äî    </h4><br>  unknown ‚Äî   ,        ,   ,    . <br><br><h4>    API </h4><br><ul><li>    LanguageService#getSourceFile  ,        . . <a href="https://github.com/Microsoft/TypeScript/pull/24540">#24540</a> . </li><li>   TypeChecker#getSymbolDisplayBuilder       . . <a href="https://github.com/Microsoft/TypeScript/pull/25331">#25331</a> .     emitter ( )  node builder. </li><li>   escapeIdentifier  unescapeIdentifier  .     API   ,        .   ,       ,      .           escapeLeadingUnderscores  unescapeLeadingUnderscores,     ,    (      ¬´¬ª  __String  string   ). </li><li>  TypeChecker#getSuggestionForNonexistentProperty, TypeChecker#getSuggestionForNonexistentSymbol  TypeChecker#getSuggestionForNonexistentModule  ,         API. . <a href="https://github.com/Microsoft/TypeScript/pull/25520">#25520</a> . </li></ul><br><h2>  Perspectives </h2><br>    TypeScript  .     ,        ,  ,  DefinitelyTyped   ,       .     ,            . <br><br>           ,         TypeScript ( ,   ).       ,   ,           JavaScript.      ,      TypeScript,       . <br><br>    <a href="https://github.com/Microsoft/TypeScript/wiki/Roadmap"></a>   ,      ,     ,     ,   , <a href="https://twitter.com/typescriptlang/"> Twitter</a>    <a href="https://github.com/Microsoft/TypeScript/issues/new/choose">  </a> .     . <br><br> ,          TypeScript, !         .    ,  ,       TypeScript   ,  . <br><br>   ! <br>  TypeScript </div><p>Source: <a href="https://habr.com/ru/post/420761/">https://habr.com/ru/post/420761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420739/index.html">The box is still in the pen: why in 2018 you still need to learn languages ‚Äã‚Äãyourself</a></li>
<li><a href="../420741/index.html">Cheat sheet for programmers or "we google for you"</a></li>
<li><a href="../420749/index.html">GitLab for Continuous Delivery project on InterSystems technologies: Containers</a></li>
<li><a href="../420753/index.html">Microservice Frontend - Modern Approach to Front Sharing</a></li>
<li><a href="../420757/index.html">Programming Contest: Trading (Results)</a></li>
<li><a href="../420763/index.html">KDD 2018, second day, seminars</a></li>
<li><a href="../420765/index.html">Impressions of the Gemini PDA. Pocket dual-boot combine or useless toy?</a></li>
<li><a href="../420767/index.html">Rostelecom Demands to Recognize Sputnik Bankrupt</a></li>
<li><a href="../420769/index.html">Looking.House - more than 150 points of Looking Glass on one site</a></li>
<li><a href="../420775/index.html">Own game in 72 hours: rakes, crutches and alpacas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>