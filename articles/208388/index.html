<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vaadin: Useful Improvements and Observations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vaadin is a component UI framework for building Java web applications. We have been using Vaadin as part of our CUBA platform for 4 years and during t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vaadin: Useful Improvements and Observations</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://vaadin.com/home">Vaadin</a> is a component UI framework for building Java web applications.  We have been using Vaadin as part of our <a href="https://www.cuba-platform.com/">CUBA platform</a> for 4 years and during this time we have gained a lot of experience working with it. <br><br>  Vaadin was chosen by us for several reasons: <br><ul><li>  Server programming model that does not require the use of javascript / html in application code </li><li>  Ability to create rich AJAX UI </li><li>  Many components and third-party addons </li></ul><br>  Among the shortcomings worth noting: <br><ul><li>  High server memory requirements, since all user interface elements and their data are stored in the HTTP session </li><li>  The complexity of expanding Vaadin components and writing add-ons </li></ul><br>  In this article, I will share solutions to some of the problems and challenges that we encountered when using Vaadin.  I will analyze several solutions in detail, for the rest - only important points. <a name="habracut"></a><br><br><h5>  Empty place in GridLayout </h5><br>  One of the features of the corporate application is the requirement to change the interface screens depending on user rights and data state.  Often, components on a form are placed in a grid using <code>GridLayout</code> , and then when you hide rows or columns in a standard Vaadin, there are empty spaces of indents for invisible components.  This behavior can be changed, which will require the creation of its successor <code>GridLayout</code> .  <code>SuperGridLayout</code> call it <code>SuperGridLayout</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ed1/5d6/40c/ed15d640c24840e671e89bc81e4ecce8.png"><br><br>  We will need: <br><ol><li>  <code>SuperGridLayout</code> - the heir of the server-side <code>GridLayout</code> </li><li>  <code>SuperGridLayoutConnector</code> - connector for connection of the server with the widget, the successor to the <code>GridLayoutConnector</code> </li><li>  <code>SuperGridLayoutWidget</code> - the widget itself, a successor to <code>VGridLayout</code> </li></ol><br>  Not all Vaadin components are extensible yet, so don‚Äôt be surprised at some hacks to override the package local methods.  We are forced to create our components in the <code>com.vaadin.ui</code> package.  Developers add-ons are generally quite common practice, although there is progress towards extensibility. <br><br>  <code>SuperGridLayout</code> itself <code>SuperGridLayout</code> not contain any logic: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperGridLayout</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridLayout</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  The <code>SuperGridLayoutConnector</code> indicates that we will use the <code>SuperGridLayoutWidget</code> widget.  Vaadin defines this by the return type of the <code>getWidget()</code> method. <br><habracut><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Connect</span></span>(SuperGridLayout.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperGridLayoutConnector</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridLayoutConnector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SuperGridLayoutWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SuperGridLayoutWidget) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getWidget(); } }</code> </pre><br>  Well, the widget code itself with a fix to hide passes: <br><div class="spoiler">  <b class="spoiler_title">SuperGridLayoutWidget</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperGridLayoutWidget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VGridLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .. @Override void layoutCellsHorizontally() { // ... for (int i = 0; i &lt; cells.length; i++) { for (int j = 0; j &lt; cells[i].length; j++) { // ... // Fix for GridLayout leaves an empty space for invisible components #VAADIN-12655 // hide zero width columns if (columnWidths[i] &gt; 0) { x += columnWidths[i] + horizontalSpacing; } } // ... } @Override void layoutCellsVertically() { // ... for (int column = 0; column &lt; cells.length; column++) { // ... for (int row = 0; row &lt; cells[column].length; row++) { // ... // Fix for GridLayout leaves an empty space for invisible components #VAADIN-12655 // hide zero height rows if (rowHeights[row] &gt; 0) { y += rowHeights[row] + verticalSpacing; } } } // ... } }</span></span></code> </pre><br></div></div><br>  Now you need to add to your project an assembly of a set widget with a new component.  This is described in detail in the Vaadin documentation. <br>  The full code can be found here: <a href="https://github.com/Haulmont/vaadin-super-grid">https://github.com/Haulmont/vaadin-super-grid</a> <br><br><h5>  Right-click selection in the tree and table </h5><br>  By default, Vaadin does not highlight the record for which we have opened the context menu.  And this behavior can not be changed without any special tricks.  Add a right-click selection for the tree, a similar process for the table. <br><br>  Let's name our tree SuperTree and we will get <code>SuperTree</code> , <code>SuperTreeWidget</code> and <code>SuperTreeConnector</code> .  <code>SuperTree</code> is a simple heir to Tree.  And in <code>SuperTreeWidget</code> will completely copy the code from <code>VTree</code> , into <code>SuperTreeConnector</code> - the code from <code>TreeConnector</code> .  Next, change the code in the <code>SuperTreeConnector</code> so that it uses the <code>SuperTreeWiget</code> widget and the <code>@Connect(SuperTree.class)</code> annotation <code>@Connect(SuperTree.class)</code> . <br><br>  We have got our own client-side implementation for the server component Tree.  In <code>SuperTreeConnector</code> we <code>SuperTreeConnector</code> turn on the <code>contextMenuSelection</code> flag and accessors for it.  In the <code>updateFromUIDL</code> method with the flag set, we will reset the flag for the widget with the flag <code>rendering = false</code> and interrupt the execution.  This is necessary so that our context menu is not minimized.  Next, in the <code>SuperTreeWidget.TreeNode</code> add a <code>showContextMenu</code> selection to the <code>showContextMenu</code> method if it is not selected: <br><div class="spoiler">  <b class="spoiler_title">#showContextMenu</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showContextMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Event event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!readonly &amp;&amp; !disabled) { <span class="hljs-comment"><span class="hljs-comment">// Select node by right click if (!isSelected()) { toggleSelection(); getConnector().setContextMenuSelection(true); } if (actionKeys != null) { int left = event.getClientX(); int top = event.getClientY(); top += Window.getScrollTop(); left += Window.getScrollLeft(); client.getContextMenu().showAt(this, left, top); } event.stopPropagation(); event.preventDefault(); } }</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/e8b/a46/259/e8ba46259c5fe198fd1a4c522fc88c7c.png"><br><br>  Now if the user clicks on the node with the right mouse button, our node will be selected. <br>  The full code here: <a href="https://github.com/Haulmont/vaadin-super-tree">https://github.com/Haulmont/vaadin-super-tree</a> <br><br><h5>  Hotkeys for input fields </h5><br>  It so happened in the Vaadin API that hotkeys are attached to <code>Panel</code> , <code>Window</code> or <code>UI</code> objects.  This means that adding leafers for hotkeys, for example, for a field, you add them to the guardian container nearest the hierarchy.  This behavior leads to the fact that for the same keys in the two fields you already need to write clever code, and the writing of your components with hot keys is complicated by an order of magnitude.  If we simply wrap all duplicate components in the panel, then we will complicate our browser screen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bac/16c/7f5/bac16c7f5fb7b5efc8d55dc5935daae8.png"><br><br>  To solve this problem for tables and trees is quite difficult, consider a simple solution on the example of text fields.  Let's try to make your <code>SuperTextField</code> with a search for Enter and the ability to use several such fields on the screen. <br><br>  In <code>SuperTextField</code> we define our <code>ActionManager</code> responsible for the hotkeys of this field. <br><div class="spoiler">  <b class="spoiler_title">SuperTextField</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperTextField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//.. /** * Keeps track of the Actions added to this component, and manages the * painting and handling as well. */ protected ActionManager shortcutsManager; @Override public void paintContent(PaintTarget target) throws PaintException { super.paintContent(target); if (shortcutsManager != null) { shortcutsManager.paintActions(null, target); } } @Override protected ActionManager getActionManager() { if (shortcutsManager == null) { shortcutsManager = new ConnectorActionManager(this); } return shortcutsManager; } @Override public void changeVariables(Object source, Map&lt;String, Object&gt; variables) { super.changeVariables(source, variables); if (shortcutsManager != null) { shortcutsManager.handleActions(variables, this); } } @Override public void addShortcutListener(ShortcutListener listener) { getActionManager().addAction(listener); } @Override public void removeShortcutListener(ShortcutListener listener) { getActionManager().removeAction(listener); } @Override public void addActionHandler(Action.Handler actionHandler) { getActionManager().addActionHandler(actionHandler); } @Override public void removeActionHandler(Action.Handler actionHandler) { getActionManager().removeActionHandler(actionHandler); } }</span></span></code> </pre><br></div></div><br>  In the <code>SuperTextFieldConnector</code> add the loading of hot keys from JSON and transfer them to the widget. <br><div class="spoiler">  <b class="spoiler_title">SuperTextFieldConnector</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Connect</span></span>(SuperTextField.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperTextFieldConnector</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFieldConnector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SuperTextFieldWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SuperTextFieldWidget) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getWidget(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFromUIDL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UIDL uidl, ApplicationConnection client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.updateFromUIDL(uidl, client); <span class="hljs-comment"><span class="hljs-comment">// We may have actions attached to this text field if (uidl.getChildCount() &gt; 0) { final int cnt = uidl.getChildCount(); for (int i = 0; i &lt; cnt; i++) { UIDL childUidl = uidl.getChildUIDL(i); if (childUidl.getTag().equals("actions")) { if (getWidget().getShortcutActionHandler() == null) { getWidget().setShortcutActionHandler(new ShortcutActionHandler(uidl.getId(), client)); } getWidget().getShortcutActionHandler().updateActionMap(childUidl); } } } } }</span></span></code> </pre><br></div></div><br>  Well, in the widget we will listen to keystrokes and pass them to a special handler who knows about the shortcut keys. <br><div class="spoiler">  <b class="spoiler_title">SuperTextFieldWidget</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperTextFieldWidget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VTextField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShortcutActionHandler</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShortcutActionHandlerOwner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ShortcutActionHandler shortcutHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SuperTextFieldWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handle shortcuts DOM.sinkEvents(getElement(), Event.ONKEYDOWN); } @Override public void onBrowserEvent(Event event) { super.onBrowserEvent(event); final int type = DOM.eventGetType(event); if (type == Event.ONKEYDOWN &amp;&amp; shortcutHandler != null) { shortcutHandler.handleKeyboardEvent(event); } } public void setShortcutActionHandler(ShortcutActionHandler handler) { this.shortcutHandler = handler; } @Override public ShortcutActionHandler getShortcutActionHandler() { return shortcutHandler; } //.. }</span></span></code> </pre><br></div></div><br>  Now we can <code>SuperTextField</code> as many <code>SuperTextField</code> fields with the same key combinations. <br>  Full code here: <a href="https://github.com/Haulmont/vaadin-super-textfield">https://github.com/Haulmont/vaadin-super-textfield</a> <br><br><h5>  Styles "-focus" for TabSheet, Table, CheckBox, Tree, MenuBar </h5><br>  In Vaadin for some components there are not enough styles of various states.  Let's try adding a "-focus" selector for trees with focus. <br><br>  The scheme of actions is simple: we start the <code>FocusTree</code> , <code>FocusTreeConnector</code> and <code>FocusTreeWidget</code> . <br><br>  Add the style "-focus" in the widget: <br><div class="spoiler">  <b class="spoiler_title">Focustreewidget</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FocusTreeWidget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFocus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FocusEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onFocus(event); addStyleDependentName(<span class="hljs-string"><span class="hljs-string">"focus"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBlur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlurEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onBlur(event); removeStyleDependentName(<span class="hljs-string"><span class="hljs-string">"focus"</span></span>); } }</code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/a12/8fd/4e1/a128fd4e1f20bb6fbb41eb7f7cc28673.png"><br><br>  Now it remains only to get the necessary CSS styles for the component with the ‚Äúv-tree-focus‚Äù selector. <br>  Example here: <a href="https://github.com/Haulmont/vaadin-focus-selector">https://github.com/Haulmont/vaadin-focus-selector</a> <br><br><h5>  Ability to display a value in ComboBox that is not in the list of options </h5><br>  In <a href="https://www.cuba-platform.com/">the CUBA platform,</a> soft deletion of objects from the database is standard.  Deleted objects are not available for use, but must be displayed as part of other objects using them.  That is, if you delete some Buyer object, then by opening the Order made by this customer, we should see the name of the remote Buyer in the Buyer selection field, but it should be absent in the selection list.  However, Vaadin does not allow setting a value in the drop-down field that is missing from the options. <br><br>  This feature can simply be implemented in an options container.  It is enough that for any key it reports (containsId) that such an element exists.  The limitation of such a hack is that the key and its container element must be the same object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a4/f12/42c/4a4f1242c997116d1a04cfe74339baeb.png"><br><br>  If you select data for drop-down lists along with setting a value, then you just need to use an <code>IndexedContainer</code> or <code>BeanContainer</code> , which contains both options and a value.  When you do not control the loading of data for the container, such a hack may be useful.  (eg SQLContainer or self-written data sources). <br><div class="spoiler">  <b class="spoiler_title">SuperBeanContainer</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperBeanContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDTYPE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BEANTYPE</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDTYPE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BEANTYPE</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Object missingBoxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SuperBeanContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BEANTYPE&gt; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(type); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object itemId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsFlag = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.containsId(itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!containsFlag) { missingBoxValue = itemId; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;IDTYPE&gt; itemIds = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getItemIds(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (missingBoxValue != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !itemIds.contains(missingBoxValue)) { List&lt;IDTYPE&gt; newItemIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(itemIds); newItemIds.add((IDTYPE) missingBoxValue); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (IDTYPE itemId : itemIds) { newItemIds.add(itemId); } itemIds = newItemIds; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> itemIds; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BeanItem&lt;BEANTYPE&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object itemId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (missingBoxValue == itemId) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanItem(itemId); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getItem(itemId); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (missingBoxValue != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { size++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } }</code> </pre><br></div></div><br>  Example here: <a href="https://github.com/Haulmont/vaadin-super-combobox">https://github.com/Haulmont/vaadin-super-combobox</a> <br><br><h5>  About switching to Vaadin 7 </h5><br>  Vaadin 7 has changed a lot, including browser support.  IE7 is no longer supported, IE8 + support is announced.  But at the same time, there were big performance problems in IE 8. The process of rendering components has changed dramatically, it is now phased and uses intensive JavaScript calculations.  This behavior can not be changed.  Some ‚Äúcomplex‚Äù screens (a table with 10 columns in 5 embedded vertical boxes) in IE8 are drawn 10-20 times slower than in Chrome.  When moving or choosing Vaadin 7, keep this in mind. <br>  We solved this problem straightforwardly - we support both 6 and 7 versions in the Vaadin platform, and in the project of the application you can choose which version to use. <br><br>  <a href="http://dev.vaadin.com/ticket/12797">dev.vaadin.com/ticket/12797</a> - Bug checked, but there is no activity yet. <br><br>  Also, before moving on, make sure that your add-ons will work in the new version.  Not all add-on developers have released versions that are compatible with Vaadin 7. <br><br>  Addons for Vaadin, which we translated into version 7 (maybe it will be useful to someone): <br><ul><li>  Overlays: <a href="https://github.com/Haulmont/vaadin-overlays">github.com/Haulmont/vaadin-overlays</a> </li><li>  Notifique: <a href="https://github.com/Haulmont/Notifique">github.com/Haulmont/Notifique</a> </li><li>  AppletIntegration: <a href="https://github.com/Haulmont/AppletIntegration">github.com/Haulmont/AppletIntegration</a> </li></ul><br>  For prototyping on Vaadin, we use a convenient procurement with Maven, Groovy and Jetty: <a href="https://github.com/Haulmont/vaadin-sandbox">https://github.com/Haulmont/vaadin-sandbox</a> - <code>mvn clean package jetty:run</code> <br><br><h5>  Reservations </h5><br>  I tried to show the simplest solutions, there are many other improvements, but their consideration can result in a separate article. <br><br>  We do not use the hacks described in this article in this form, because we support our own version of Vaadin and can add the necessary hooks and protected API to it.  <a href="https://github.com/Haulmont/vaadin">https://github.com/Haulmont/vaadin</a> .  Perhaps for you this will also be a better option than copying entire classes of the framework.  The benefit of git allows you to conveniently merge changes from Upstream. </habracut></div><p>Source: <a href="https://habr.com/ru/post/208388/">https://habr.com/ru/post/208388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208370/index.html">Koreans made a nanobot to fight cancer</a></li>
<li><a href="../208374/index.html">Intel announced support for Steam Machines and announced Dual OS officially + response from AMD</a></li>
<li><a href="../208376/index.html">How I made the API work in Yiinitializr Advanced</a></li>
<li><a href="../208378/index.html">Creating zip modules in python</a></li>
<li><a href="../208384/index.html">The official openSUSE forum is hacked</a></li>
<li><a href="../208390/index.html">High-precision machines must not be moved without the permission of the manufacturer.</a></li>
<li><a href="../208392/index.html">Name in success or success in name? (trademarks part2)</a></li>
<li><a href="../208394/index.html">PlayStation Now: games for PlayStation on a tablet, TV, smartphone</a></li>
<li><a href="../208396/index.html">CoolRF: Project News Digest # 1</a></li>
<li><a href="../208400/index.html">The principles of the DBMS. MVCC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>