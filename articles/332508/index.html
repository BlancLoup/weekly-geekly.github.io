<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automata programming. Part 2. State and transition diagrams</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first article I gave an example of automaton programming from the general to the particular, or rather, constructive decomposition . The next d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automata programming. Part 2. State and transition diagrams</h1><div class="post__text post__text-html js-mediator-article">  <i><a href="https://habrahabr.ru/post/331556/">In the first article</a> I gave an example of automaton programming from the general to the particular, or rather, <b>constructive decomposition</b> .</i>  <i>The next design stage, the study of the resulting modules.</i>  <i>But first, I will show you what automata are from a mathematical and practical point of view.</i>  <i>The basis of automata is a model describing the process occurring in time, called a state diagram, and it is impossible to imagine automaton programming without this essence.</i>  <i>Why this is so considered in today's article.</i> <br><a name="habracut"></a><br><br>  <a href="https://habrahabr.ru/post/331556/">Table of contents.</a> <br><br><p></p><h2>  Automatic vs machine </h2><br>  Specialists lead a fairly extensive classification of automata: deterministic and non-deterministic, finite and infinite, Miles and Mura, synchronous and asynchronous, etc.  However, from the user's point of view, this is just the same as if a person wanted to decide for himself whether he needed a personal car in the megalopolis, and they would tell him about the number of cylinders and the injector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a promoter, I note that from the point of view of use, automata fall into two related categories: <br><br><ul><li>  automata as a mathematical abstraction, we assign here and methods of realization of automata. <br></li><li>  automata as a set of techniques and approaches for designing digital logic devices (circuits and programs), also based on mathematics. </li></ul><br>  The relationship between these approaches is easy to illustrate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/e64/a6c/412/e64a6c412beb42d4b43aaee272d4cb40.png"></div><br>  Figure 1. Machine design and machine implementation <br><br>  As far as it becomes clear from communication with colleagues, there is a category of formalists, people considering automata as: <br><br><ul><li>  entities whose description must strictly fit into the framework of UML State Diagrams or similar description methods, that is, have a set of nodes specified as separate functions, a set of signals, and a formalized table defining the relationships between them. <br></li><li>  the notion of an automata-implemented program is strictly limited to belonging to one of the implementation techniques ‚Äî boost.statechart, visualState, etc. </li></ul><br>  Obviously, such an approach narrows the space of opportunities that are opened up due to the automata-oriented paradigm, and such an attitude towards automata can be explained only by the lack of popular science material that is fixable. <br><br>  What I want to use machines for is the simplicity and at the same time the depth of <i>design</i> .  In the previous part, it was shown that the <i>automata-oriented design of</i> modules is based on splitting a task into an operational automaton ( <b>OA</b> ) and a control automaton ( <b>UA</b> ), and the operating automaton in turn can be re-divided into a lower-level operational automaton and its controlling automaton . <br><br>  An operating machine is a semi-finished product that can optimally perform some action, but at the same time it ‚Äúdoesn‚Äôt care‚Äù when to perform this action and with what parameters.  The operating machine can do this with any valid parameters.  An excellent example of an ALU operating machine. <br><br>  In turn, the parametrization and launching of the operating automaton falls on the shoulders of the controlling automaton. The multistage fragmentation makes it possible to avoid obtaining a complex controlling automaton with not obvious, though iron logic, replacing it with several simple controlling automata with the most clear operation. <br><br>  In this case, the <i>implementation of the</i> control automaton may not be automaton at all, or it may be automaton, but without attributes such as: states rolled up into separate functions, tables of signals and corresponding transitions.  And finally, I note that any program is an automatic machine, and yet not all programs are automatically implemented. <br><br>  <i>But in this case, what is meant by an automatically implemented program?</i> <br><br><h2>  Implementation: automatic vs non-automatic. </h2><br>  The main attribute of an automatically implemented program is: <br><br><ul><li>  the presence of clearly defined and clearly limited states.  During operation, the program is <i>always</i> <i>in one</i> of the states. <br></li><li>  The current state of the program is described by a single variable, which is called the <i>internal state of the automaton</i> . </li></ul><br>  This definition, so to speak, is an invariant, the embodiment of which may be different.  In the section <i>Ways to implement automaton programs,</i> we consider a number of examples that illustrate what has been said, but in general the essence is clear. <br><br>  Now there is a clear criterion by which we assign programs to automatically implemented programs, but someone will ask: what is the trick of the automatic implementation, why in some cases is it more valuable? <br><br>  The main thing that distinguishes the auto-implemented algorithms from the implemented ones is non-automated lies in the sphere of our psyche, or rather, how we think.  As a colleague pointedly noted: <br><blockquote>  ‚ÄúThe human mind is designed in such a way that it is easier for him to understand the algorithms that feed the input data and receive the output data, and the result depends only on the input, not on the internal state.  Such ‚Äúpure functions‚Äù ( <i>let's call them analytical editors</i> ) are easier to understand, test and reuse. ‚Äù </blockquote><br>  The behavior of an analytical function can be represented as a table or a graph: there is something at the input and there is a one-to-one correspondence at the output.  However, most digital devices are such that using analytical functions as bricks, as a result, we still get a program whose behavior depends on the internal state.  That is, the use of analytical functions does not solve the problem of "understanding", moving it to another level! <br><br>  In order to illustrate the term ‚Äúcomprehensibility‚Äù and features of human thinking, I propose to consider how the same abstract algorithm, implemented automatically and non-automaticly, is written. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/331/6d9/6c4/3316d96c4985463ab4c9946ceba2526b.png"></div><br><br>  but) <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/d74/7a2/f5e/d747a2f5e8b2412586cf1cb75aee6550.PNG"></div><br><br>  b) <br><br>  Figure 2. A generalized example of a control device (a) and a graph diagram describing the operation of this device (b). <br><br>  A certain program is designed to control a certain device.  As shown in Fig. 2a, the non-specified OA, which is controlled by the UA, which is shown in Fig. 2, controls the ‚Äúhardware‚Äù directly.  2 (b).  The UA processes external commands, conventionally denoted by the {0,1,2} character set, and translates them into a set of microinstructions controlling the operation machine.  By microinstructions, I mean a set of commands that is necessary for obtaining an effect.  Each set of microinstructions is conditionally denoted by the symbol {1,2,3,4,5,6}.  Flags {a, b, c} of the controlling machine monitor the state of the <i>managed object</i> , and, accordingly, determine the processing modes of the input command. <br><br>  Since this is a digital device with memory, the algorithm described in Fig. 2 is actually an automaton, despite the fact that the implementation of the algorithm is not automatic.  This leads to the fact that there <i>are</i> no <i>explicitly selected states in it</i> , with the result that the current state is <i>implicitly</i> determined by flags.  In this case, the description of the program by the graph scheme itself does not contradict the automaton principle, an automaton-implemented program can be described by a graph scheme, there will be such an example.  The main hitch connected with the graph-scheme is low understanding of the program of the described HS from the point of view of the dynamic, i.e.  proceeding in time process. <br><br>  This is what I mean: this is a very simple example, but it is not possible to unequivocally say which output signal will correspond to the input signal 0, because it will depend on the state of the flags, or rather the flag b, which in turn depends on what was at the entrance earlier.  It is also not easy to tell straight away which output sequence will correspond to the input sequence: 2,1,0,2,1,0.  To do this, you must actually run the algorithm. <br><br>  In order to give a complete correspondence of the input and output signals, that is, to describe the function in the form of a table, it will be necessary to perform a total test, and, moreover, the result will be obtained in the form of two-signal sequences, in which various input combinations are iterated. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/862/473/ac7/862473ac7bca47ad8eff4351a6fcb6fe.png"></div><br>  Figure 3. Timing diagram - a way to describe the behavior of systems with memory. <br><br>  Since the three binary flags allow us to track no more (but possibly no less) of the 8 preceding characters, then for the alphabet of 3 input symbols, to describe all possible options we need to bring 6561 diagrams, the so-called power of the product of the set of input signals and the set of states with increasing number of states and the size of the alphabet of input signals grows geometrically. <br><br>  Automaton implementation of the program allows you to describe it using <i>the state diagram</i> , and the state diagram and transitions provide a radically different approach to the analysis of dynamic systems with memory.  We construct an automaton that implements the algorithm depicted in Fig. 2b (I will not specify how, this is a topic for another conversation), and which is described by a state diagram and transitions depicted in Fig. 4. The state name on the diagram coincides with the output symbol when the automaton in this condition. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/354/fb2/15b/354fb215bb49448eb14925168ff8c29b.png"></div><br>  Figure 4. State and transition diagrams corresponding to the algorithm shown in Figure 2. <br><br>  Using this diagram is very convenient, since only input symbols affect transitions, there are no additional conditions.  In other words, to analyze the reaction to the input symbol for the implementation of Fig. 2, you need to have the current state of the flags before your eyes, in each iteration a new one, and in order to analyze the behavior of the device implemented as shown in Fig. 4, nothing is needed except this diagram. <br><br>  This is <i>an important</i> advantage of the automaton approach, called: <br><br><a name="View"></a><br><h2>  A look at the dynamic processes outside the time axis. </h2><br>  The human brain is designed so that it is easier to work with a table of numbers than if the same table is shown one digit at a time.  In the first case, a person is able to identify complex patterns, in the second one can hardly determine any pattern, except for the simplest ones, even if you scroll through the table cyclically. <br><br>  Consider an example, let us have a sequence of commands <br><br><pre><code class="cpp hljs">Set_position(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">-11</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>); Line_to (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br>  You must admit that each of the actions is distinguished by its simplicity of purpose.  However, not completing all the actions can not say that we will succeed.  The result of this algorithm is shown in Fig.  5 a <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/103/edb/213/103edb213a384889bff1a24a3b59735e.png"></div><br>  a) b) <br>  Figure 5. The result of executing a sequence of commands (a), and the result of executing the same sequence, if an error is made (b). <br><br>  At the same time, make a mistake in the calculations, and specify, for example, in the first operator of the second line instead of (1, -3) the value of (2, -3) the result of the work would be different (5 b), but looking at the text of the program of this can not understand.  And this is a simple case when the result can be seen immediately after execution.  If we saw the result as a single line at each moment of time, or dealt not with graphics, but with numbers, our error would not be so obvious. <br><br>  This is a complex information for the human brain, called a <i>dynamic process, as a sequence of actions</i> (in the example, separate lines), <i>resulting in the imposition of some intended result</i> (in the example of the figure). <br><br>  A good example of looking at dynamic processes outside the time axis is the analysis of signals in the frequency domain.  Consider the signal in Fig. 6. In some ways it can be compared with the time diagram of the automaton.  This is also a sequence of actions: the signal crossed 0, went up, reached a maximum, went down, crossed 0 again. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/b8e/9eb/3be/b8e9eb3be7424816a2864ab894096423.png"></div><br>  Figure 6. Signal graph, analogue of the timing diagram for automata. <br><br>  Obviously, this is a periodic signal, one can even guess that it consists of several sinusoids, but it is difficult for us to say from which ones. <br>  At the same time, the spectrum directly gives us an idea of ‚Äã‚Äãthe structure of the signal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/533/3f2/4bb/5333f24bba8d4be8adf7d884f5c202e2.png"></div><br>  Figure 7. The spectrum of the signal shown in Figure 6. <br><br>  The spectrum can be compared with the automaton diagram in the following respect: it contains a <i>static description</i> of what underlies the <i>process that takes place in time</i> .  Both the spectrum and the state and transition diagram make it possible to analyze the process outside the time axis, encompassing it as a whole, and not as a sequence of steps. <br><br><h2>  A bit of math </h2><br>  The state and transition diagram as a rigorous mathematical category allows for in-depth analysis. <br><br>  Let us analyze the process described by the diagram of states and transitions in Fig. 5.  For this we need the concept of an isomorphic automaton.  Isomorphic automata is a mathematical term for automata, which are actually the same automaton with renamed states and / or signals. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/04c/730/ef3/04c730ef31794ac8b7f66df6825031d7.png"></div><br>  Figure 8. Isomorphic automata. <br><br>  From the conditions of the problem, it follows that we know nothing about the processes that are simulated by the algorithm in Fig.  2 b.  Nevertheless, the analysis given in fig.  4 diagrams allows you to select two very similar clusters, switching between which is performed mainly by signal 0. <br><br>  We construct an automaton isomorphic to the original, but in which the state numbers have been renamed as shown in Fig. 9 and outlined on it the indicated clusters.  In the cluster with the states 4,5,6 in brackets the identical states of the first cluster are indicated. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/354/fb2/15b/354fb215bb49448eb14925168ff8c29b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9ae/95b/3f7/9ae95b3f7d554933aab79da2a071aafd.png"></div><br>  Figure 9. An automaton isomorphic to that depicted in Figure 4 <br><br>  We decompose (we divide) the initial automaton into two parallel automata, as shown in Fig.  ten. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/895/a5d/d10/895a5dd109764f5ea1d911bb41877bff.png"></div><br>  Figure 10. Parallel decomposition of the automaton shown in Figure 9. <br><br>  The output symbol of each of the machines is given after the slash after the name of the state.  The output symbols of the received automata are arithmetically added, giving the output symbols from 1 to 6, which completely correspond to the symbols at the output of the original automaton with the same input data.  Such a combination of automata is called a parallel composition. <br><br>  Pay attention to <i>Automatic 2</i> .  Whatever state it is in, input symbol 0 causes appearance of symbol 1, input symbol 1 leads to the appearance of symbol 3, and symbol 2 to the appearance of symbol 2. That is, in fact, this is a combinational circuit, an array of output symbols, and the array index is the character at the input.  Figure machine as shown in Fig.  eleven <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/740/c6f/6da/740c6f6da3ec4b608ca7d5f0eed51103.PNG"></div><br>  Figure 11. An automaton equivalent to the automaton shown in fig.  ten <br><br>  Since the output symbols we encoded a certain set of microinstructions, it may seem that arithmetic transformations are inappropriate here, however, if you look at the problem through the eyes of a mathematician and imagine that we have an array of implemented microinstructions, in which each microinstruction has an index, in this case the correctness is Our transformations are beyond doubt. <br><br>  I would like to emphasize that since the characters 0,1,2 at the input and the characters 1,2,3 at the output belong to different alphabets, then you cannot just take and give the character 1 from the output back to the input.  However, there may be such automata in which the input and output symbols belong to the same alphabet and in this case, the output symbols of the automaton can be fed to its input.  This is called <b>composition with feedback</b> .  Section 4.7 is devoted to such compositions. <br><br>  From the condition of the problem, the nature of the object, which is modeled by the algorithm, was not known. <br>  rice  2 b, and nevertheless, analyzing and decomposing automata, we established that the basis of the simulated phenomenon is actually two independent processes that contribute to the final result.  And although in the case of an abstract example, this does not give anything but an interesting observation, in the case of a specific task, the above analysis may reveal non-obvious aspects of the modeled phenomenon, therefore it is interesting not only from the point of view of programming, but also from an engineering point of view.  For an engineer, an understanding of the processes underlying the phenomenon can correct the view on the device being developed and get an original technical solution that beats the essence. <br><br>  The considered example involves another important and useful property of automata, the concept of <b>equivalent automata</b> .  The fact is that there can be arbitrarily many automata with different numbers of states (i.e., we are <b>not</b> talking <b>about</b> isomorphic automata) that will give the same response to the same input sequence.  Accordingly, if you put them in the ‚Äúblack box‚Äù, you will not be able to distinguish them by supplying different sequences to the input and analyzing the response. <br><br>  Some automata will be more ‚Äúwasteful‚Äù in terms of the number of internal states, while others are more ‚Äúeconomical.‚Äù  Among the entire set of equivalent automata there will be an automaton with the minimum possible number of states, and it is called the <b>minimal automaton</b> .  Moreover, there are algorithmic methods for obtaining from any automaton an equivalent minimal one.  This property in particular means that when drawing up a diagram of states and transitions one should not strive to minimize the number of states, but one should achieve the most clear and complete picture.  And although understanding and simplicity of implementation are often related, it may turn out that it is clearer to present the result as a pair of automata as in our example.  After that, using mathematical algorithms, you can find the equivalent minimum automaton. <br><br>  Since I have no intention to consider in this article the theory of automata, I will briefly list the basic mathematical operations that can be performed on automata: composition, decomposition, minimization, obtaining an automaton from a microprogram, obtaining an automaton-based microprogram, algebraic operations on automata (addition, comparison of automata ), construction of a simulating automaton, etc. Theoretical substantiations and methods for performing these transformations can be found, for example, <a href="http://3ys.ru/vvedenie-v-teoriyu-tsifrovykh-avtomatov.html">here</a> . <br><br><br>  Summarize today's part.  A characteristic feature of <i>non-automatic</i> programming is that the state of the program at any given time is described not only by the program counter, but also by a certain number of internal flags.  The term <i>state</i> in the non-automatic style of programs is a kind of non-formalizable concept, meaning roughly that the program performs all the actions that TK requires.  And nevertheless, as it was shown above, even with the non-automatic style of the program, mathematically it is an automaton.  It has <i>states in a mathematical sense</i> , but these states are not described anywhere.  It is not known how many of them and what the relationship between them.  Adding each new binary flag increases the number of possible states geometrically.  Many new states will be unattainable states in which the program should never get under any conditions, but since in this case we do not explicitly select the next state, but it turns out as a superposition of all flags, with the wrong logic at least one of the flags can jumping into forbidden states and there is no indicator that would demonstrate this.  When we deal with flags that are actively changing, and the path of the program is tortuous and goes through many branches, until all options for all possible input symbols are tested, we can only <i>believe</i> that after the twentieth iteration the program will in the state that we expect. <br><br>  In the case of an automaton implementation, the <i>state</i> is a mathematical category.  At each moment of time it is uniquely determined, in particular, by a program counter.  We ourselves set the set of states that is needed to solve the control problem, and for each state we <i>explicitly choose, based on needs,</i> which state will be next if the <i>X</i> or <i>Y</i> command <i>arrives</i> .  If there are not enough states, you can arbitrarily increase their number to the required one by unambiguously prescribing the connections between them. <br><br>  I want to be understood correctly.  Implementing the program automatically, you are also not immune from typos or misconception.  By incorrectly simulating the device, you can set the transition to the wrong state, but this is not a software design error, but an engineering error, i.e.  it is not related to which path - automatic or non-automatic is chosen.  In case of non-automated implementation, a powerful source of potential logical errors is added to the same modeling errors and misprints with a name: <i>dynamic process as a sequence of actions resulting in the imposition of some intended result</i> . <br><br>  In the next part, we will return to the solid ground of practical algorithms by arranging competitions between the two implementations of the Display example, one of which is <i>developed</i> automatically, and the other is not, as well as consider the iteration process using the example of the automatic modification of the Display example. <br><br>  List of recommended literature.  If there is an amazing plot about automatic machines, write to me, I will add. <br><br>  ‚Üí <a href="https://dashingresearches.wordpress.com/2017/07/01/%25D0%25BC%25D0%25B0%25D1%2582%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D1%258C/">Lectures for beginners, for those who have forgotten and in general.</a> <br>  ‚Üí <a href="http://3ys.ru/vvedenie-v-teoriyu-tsifrovykh-avtomatov.html">Strong lectures with examples.</a>  <a href="http://3ys.ru/vvedenie-v-teoriyu-tsifrovykh-avtomatov.html">Part 1</a> <br>  ‚Üí <a href="http://3ys.ru/abstraktnyj-sintez-tsifrovykh-avtomatov/sintez-avtomata-po-skheme-algoritma.html">Strong lectures with examples.</a>  <a href="http://3ys.ru/abstraktnyj-sintez-tsifrovykh-avtomatov/sintez-avtomata-po-skheme-algoritma.html">Part 2</a> <br>  ‚Üí <a href="http://3ys.ru/abstraktnyj-sintez-tsifrovykh-avtomatov/sintez-avtomata-po-skheme-algoritma.html">Strong lectures with examples.</a>  <a href="http://3ys.ru/abstraktnyj-sintez-tsifrovykh-avtomatov/sintez-avtomata-po-skheme-algoritma.html">Part 3</a> </div><p>Source: <a href="https://habr.com/ru/post/332508/">https://habr.com/ru/post/332508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332496/index.html">Big Data at Raiffeisenbank</a></li>
<li><a href="../332500/index.html">Core ML Testing and Review</a></li>
<li><a href="../332502/index.html">Linux log files in order</a></li>
<li><a href="../332504/index.html">Who owns the data generated by devices from the Internet of things?</a></li>
<li><a href="../332506/index.html">How to confuse the analyst. Part Three Verbs and numerals</a></li>
<li><a href="../332516/index.html">Generalized copying of connected object graphs in C # and nuances of their serialization</a></li>
<li><a href="../332518/index.html">InnoDB cluster - it works, and it seems to be exactly as promised</a></li>
<li><a href="../332520/index.html">Moneyball on the exchange: how new technologies change not only trading, but also the work of hedge funds</a></li>
<li><a href="../332522/index.html">Amazon, Apple, and Microsoft Shares Equal to Due to Technical Failure</a></li>
<li><a href="../332524/index.html">On the role of interfaces in the context of existentialism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>