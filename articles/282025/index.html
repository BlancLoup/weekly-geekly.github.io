<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Increase Magento Performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... or the right work with collections. 

 I want to tell you about the errors that I saw on almost every project on Magento that had performance prob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Increase Magento Performance</h1><div class="post__text post__text-html js-mediator-article">  ... or the right work with collections. <br><br>  I want to tell you about the errors that I saw on almost every project on Magento that had performance problems.  Working with Magento, I sometimes have to audit someone else's code.  Therefore, I would like to share with you an experience that will help improve the performance of your sites and avoid mistakes in the future. <br><br>  This article is about Magento 1. *, but the described is also suitable for Magento 2. *. <br><a name="habracut"></a><br>  In almost every project where there are performance problems, you can come across something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs">$temp = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection()-&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($collection <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $product) { $product = $product-&gt;load($product-&gt;getId()); $temp[] = $product-&gt;getSku(); }</code> </pre>  <i><font color="#999999">Wrong</font></i> <br><br>  instead <br><br><pre> <code class="php hljs">$temp = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection()-&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'sku'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($collection <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $product) { $temp[] = $product-&gt;getSku(); }</code> </pre>  <i><font color="#999999">Right</font></i> <br><br>  The reasons for this are very simple: <br><br><ol><li>  No attributes needed after upload. </li><li>  So do the "programmers" on the Internet </li><li>  Downloading extra attributes on a ‚Äúno worse basis‚Äù </li></ol><br>  To understand what is wrong here and what we can do with performance, I suggest concentrating on working with collections: <br><br><ol><li>  <a href="https://habr.com/ru/post/282025/">Eav / Flat tables</a> </li><li>  <a href="https://habr.com/ru/post/282025/">Cache</a> </li><li>  <a href="https://habr.com/ru/post/282025/">Proper work with collections</a> </li></ol><br>  <a href="https://habr.com/ru/post/282025/">And of course the conclusions.</a> <br><br><hr><br><a name="eav_flat"></a><h1>  EAV / Flat tables </h1><br>  <b><abbr title="Entity Attribute Value">EAV</abbr></b> is a data storage approach where the entity to which the attribute belongs, the attribute itself and its value are spaced apart in different tables. <br><br>  In Magento, EAV entities include: products, categories, customers, and customer addresses.  The attributes themselves are stored in the eav_attribute table. <br><br>  Total attribute value types in Magento 5: text, varchar, int, decimal and datetime.  There is 1 more type - static, it differs from the other 5 in that it is in a table with an entity. <br><br>  The attribute table indicates which table or type of an attribute is present in, and Magento already knows where to write it and where to read it from. <br><br>  Such a storage of values ‚Äã‚Äãallows you to have simply settable attribute sets (when each entity can have its own attribute or not have it at all), adding a new attribute is just another line in the database.  Added a new value for 1 attribute for another store - a new line in the table of values ‚Äã‚Äãof this attribute. <br><br><div class="spoiler">  <b class="spoiler_title">How it is stored in the database</b> <div class="spoiler_text">  <b>Entity:</b> <br>  Product - catalog_product_entity, <br>  Category - catalog_category_entity, <br>  Customer - customer_entity, <br>  Customer address - customer_address_entity <br><br>  <b>Attribute:</b> <br>  eav_attribute <br>  catalog_eav_attribute <br>  customer_eav_attribute <br><br>  <b>Value:</b> <br>  * _text <br>  * _varchar <br>  * _int <br>  * _decimal <br>  * _datetime <br></div></div><br>  <b>Flat</b> is the usual approach for all of us, where everything lies in one place and no additional tables are needed to get the product and all its attributes without unnecessary work - SELECT * FROM WHERE label id = some kind of id and that's it. <br><br>  From EAV entities, the Flat view can be used only for categories and for products. <br><br><div class="spoiler">  <b class="spoiler_title">How it is stored in the database</b> <div class="spoiler_text">  <b>Product:</b> <br>  catalog_product_flat_1 <i><font color="#999999">// * _N store_view</font></i> <br>  <b>Category:</b> <br>  catalog_category_flat_1 <i><font color="#999999">// * _N store_view</font></i> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">In order to include an attribute in the Flat table and generally enable the use of Flat tables, do the following</b> <div class="spoiler_text">  <b>In the admin panel of Catalog&gt; Attributes&gt; Manage attributes</b> <br><br>  Magento will add an attribute to the Flat table if the attribute has 1 of the following values. <br><br><img src="https://habrastorage.org/files/702/783/c3a/702783c3aeed4c4289f1a7e7b7bdb554.png"><br><br>  <b>In the admin System&gt; Configuration&gt; Catalog</b> <br><br>  Magento will use Flat tables for the entities listed below. <br><br><img src="https://habrastorage.org/files/654/ac8/1e5/654ac81e5f184199a5f3001efa08fec1.png"><br></div></div><br>  <b>Note the following facts:</b> <br><br><ol><li>  Flat tables are used ONLY on the category pages, the list of products in the Group product, and indeed everywhere where the collection is used.  They are not used on the product page, in the admin, when using the load method on the model. </li><li>  After the inclusion of Flat tables, it is necessary to re-index, otherwise Magento will continue to use only EAV tables. </li><li>  After enabling Flat Tables, Magento continues to use EAV anyway, but also starts copying changes to the Flat table while saving changes. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Why is all this necessary and why not use the Flat approach everywhere?</b>  <b class="spoiler_title">Look at the summary table of pros and cons.</b> <div class="spoiler_text">  <b>EAV:</b> <br>  + More flexible system than Flat <br>  + When adding a new attribute, there is no need to re-index the data. <br>  + Virtually unlimited attributes <br>  + All attributes are always available. <br>  + Static attributes (sku, created_at, updated_at) are always present in the sample, even if they are not specified <br>  - Fatal error: Call to a member function getBackend () when sampling / filtering by a non-existing attribute <br>  - Performance <br><br>  <b>Flat:</b> <br>  + Performance <br>  + Only existing attributes that have been added to the Flat table can be applied to the selection / filtering. <br>  - A limit on the size of the row (up to 65,535 bytes, i.e. 85 varchar 255) and the number of columns (InnoDB up to 1000, some up to 4096) <br>  - Used only when working with collections (EAV is always used when loading) <br>  - The result is different from issuing a request for EAV (there are no static attributes) <br>  - After activation, re-indexing is required, otherwise EAV tables will be used <br>  - When adding a new attribute, it is necessary to re-index Flat tables. <br></div></div><br><hr><br><a name="cache"></a><h1>  Cache </h1><br>  Of course, each of you can tell me why we need to figure out how to speed up queries in the database and, in general, how collections work if the cache will save us and everything will be cached.  I will answer shortly - the cache will not save you.  None of the caches presented in Magento either caches collections automatically or does not work in your custom controllers and models that you use, for example, when importing data or counting something.  And besides, before it gets into the cache, you need to somehow put it in there and quickly show it to the user. <br><br>  Types of caches in Magento 1. *: <br><br><img src="https://habrastorage.org/files/061/3a4/f70/0613a4f70f484561b44d50c131ea1f59.png"><br><br><ul><li>  <b>Configuration</b> - caches configuration files </li><li>  <b>Layout</b> - caches layout files </li><li>  <b>Block HTML output</b> - caches phtml templates.  The default is used on the frontend only in the top menu and footer. </li><li>  <b>Translations</b> - csv translate files cached </li><li>  <b>Collections data</b> - caches collections that use the -&gt; initCache (...) method.  By default, only core_store, core_store_group, core_website collections are cached during initialization. </li><li>  <b>EAV types and attributes</b> - must cache eav attributes, <b>but</b> does not cache.  Used in 1 method that has never been called since Magneto CE 1.4 </li><li>  <b>Web services cache</b> - caches api.xml files </li><li>  <b>Page Cache</b> (FPC) - caches all HTML, caches only CMS, Category, Product pages.  Ignored if https protocol, get parameter? No_cache = 1, cookie NO_CACHE </li><li>  <b>DDL Cache</b> (Hidden) - caches DESCRIBE calls to the database, used in write operations </li></ul><br>  ... and neither caches collections automatically. <br><hr><br><a name="performance"></a><h1>  Proper work with collections </h1><br>  In order to show more clearly why something needs to be done differently than many are used to, I decided to give some performance tests of different approaches.  Let's start with the test bench.  For testing, I used: <br><br>  <b>Test bench:</b> <br>  OS X 10.10 <br>  3.1 GHz Intel Core i5 (4 cores) <br>  8GB <br><br>  <b>Magento configuration:</b> <br>  Magento EE 1.14.0 <br>  MySQL 5.5.38 <br>  PHP 5.6.2 <br><br>  <b>Content:</b> <br>  3 Categories <br>  2000 Products <br>  2000 CMS pages <br><br>  <b>Process:</b> <br>  For tests, an extension with 1 controller and 1 action was created, each test was performed 5 times, then the average time was calculated.  All results are shown in seconds. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test_Test_IndexController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mage_Core_Controller_Front_Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $temp = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $start = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Init values Loop start $temp[] = $product-&gt;getSku(); Loop end <span class="hljs-keyword"><span class="hljs-keyword">Or</span></span> Some code snippet $stop = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $stop - $start; } }</code> </pre><br>  <i><font color="#999999">Pseudo code</font></i> <br><h2>  Tests </h2><br><ol><li>  <a href="https://habr.com/ru/post/282025/">EAV / Flat with and without model reload</a> </li><li>  <a href="https://habr.com/ru/post/282025/">Collection caching</a> </li><li>  <a href="https://habr.com/ru/post/282025/">Proper use of count () and getSize ()</a> </li><li>  <a href="https://habr.com/ru/post/282025/">Proper use of getFirstItem and setPage (1,1)</a> </li></ol><br><a name="test_eav_flat"></a><h3>  EAV / Flat with and without model reload </h3><br>  <b>The cycle of the collection.</b>  <b>With load (reload) models inside the loop:</b> <br><br><pre> <code class="php hljs">$temp = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection()-&gt;addAttributeToSelect(...); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($collection <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $product) { $product = $product-&gt;load($product-&gt;getId()); $temp[] = $product-&gt;getSku(); }</code> </pre><br>  <b>The cycle of the collection.</b>  <b>Without load models inside:</b> <br><br><pre> <code class="php hljs">$temp = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection()-&gt;addAttributeToSelect(...); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($collection <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $product) { $temp[] = $product-&gt;getSku(); }</code> </pre><br>  <b>3 types of data sampling:</b> <br><br><ol><li>  addAttributeToSelect ('*');  <i><font color="#999999">// all attributes</font></i> </li><li>  addAttributeToSelect ('sku');  <i><font color="#999999">// 1 static attribute</font></i> </li><li>  addAttributeToSelect ('name');  <i><font color="#999999">// 1 standard attribute</font></i> </li></ol><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ef1/f61/ce3/ef1f61ce3c144ff19f02038a02b7feb4.png"><br><br>  As you probably noticed, the time without rebooting the models is several times less than when you reload the models.  Also, the time is even shorter when the Flat tables are turned on (i.e. there are no unnecessary joins and unions) and we select only the necessary attributes. <br><br>  In the first case, we perform a download with a bunch of joins ... and then do it again, but for the model and so 2000 times. <br><br>  The second time we do this is for attribute statics (it is in the same label as the product itself) and Magento does not need to make joins.  Therefore, time is less. <br><br>  The third time Magento need to add another nameplate where this attribute is stored. <br><br>  With Flat tables, everything is the same, and in 2 cases everything is identical - this is because both attributes are in table 1, hence the time is identical. <br><br>  I think the numbers speak for themselves. <br></div></div><br><a name="test_cache"></a><br><h3>  Collection caching </h3><br>  <b>Without cache:</b> <br><br><pre> <code class="php hljs">$collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>);</code> </pre><br>  <b>Using the initCache method:</b> <br><br><pre> <code class="php hljs">$collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>) -&gt;initCache(Mage::app()-&gt;getCache(),<span class="hljs-string"><span class="hljs-string">'our_data'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'SOME_TAGS'</span></span>));</code> </pre><br>  <b>Custom caching implementation:</b> <br><br><pre> <code class="php hljs">$cache = Mage::app()-&gt;getCache(); $collection = $cache-&gt;load(<span class="hljs-string"><span class="hljs-string">'our_data'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!collection) { $collection = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'collection/product'</span></span>)-&gt;getCollection()-&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>)-&gt;getItems(); $cache-&gt;save(serialize($collection),<span class="hljs-string"><span class="hljs-string">'our_data'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(Mage_Core_Model_Resource_Db_Collection_Abstract::CACHE_TAG)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $collection = unserialize($collection); }</code> </pre><br>  Consider a sample without using a cache, using the method that Magento offers us and with a crutch, which I have never seen ... the pile itself, based on the methods of the model cache.  Please note that for all the tests, after making a query, I downloaded the data and converted the collection to an array of objects. <br><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/029/5a4/bfa/0295a4bfac5f40eea34e2acf7799d8c6.png"><br><br>  Without the cache itself is not surprising ... everything is as usual. <br><br>  But using the Magentov cache, I was personally surprised when I saw that time had become more.  And about EAV, caching is generally a silly undertaking, because the EAV collection first loads entities from the product table (this is what is cached), and then selects the attribute values ‚Äã‚Äãand fills the objects with a separate query.  In Flat there everything from 1 table is being chased.  But nevertheless, the time is spent on working with the cache more than from the database (I tested it both with the file system and with redis - the differences are the 4th decimal point ... that is, it does not exist on 2k entities).  The essence of the InitCache method is that it first collects all the data into the collection itself (pagination, filters, events, and so on), creates a hash from the sql query and will search it in the cache, and if there is something there, then it is anseralizes, and then all the events and subsequent methods are launched.  This is the slowest procedure in the whole process; it is here that the cache is slower than a simple query in the database.  But it does not send a request to the database ... which is not so scary already. <br><br>  Separately, there is an example of the cache written by me on my knee, where we cache the final result of the collection, and bypassing all the events and reloading attributes.  This works for EAV and for Flat collections. <br></div></div><br><a name="test_count_getsize"></a><h3>  Proper use of count () and getSize () </h3><br>  <b>getSize ()</b> <br><br><pre> <code class="php hljs">$size = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>) -&gt;getSize();</code> </pre><br>  <b>count ()</b> <br><br><pre> <code class="php hljs">$size = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;addAttributeToSelect(<span class="hljs-string"><span class="hljs-string">'*'</span></span>) -&gt;count();</code> </pre><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9e1/591/fac/9e1591fac3514a519e79cc5f1474782d.png"><br><br>  The difference in methods is that <b>count ()</b> loads all the objects in the collection, and then the usual count counts the number of objects and returns the number to us.  <b>getSize</b> does not load the collection, but generates 1 more query to the database, where there are no limits, orders and a list of selectable attributes, there is only COUNT (*). <br><br>  An example of using both methods is: <br><br>  If you need to know if there are any values ‚Äã‚Äãin the database or how many there are, use getSize, if in any case you need a loaded collection, or already loaded, use count () - it will return you the number of elements loaded into the collection. <br></div></div><br><a name="test_getfirstitem"></a><h3>  Proper use of getFirstItem and setPage (1,1) </h3><br>  <b>getFirstItem ()</b> <br><br><pre> <code class="php hljs">$product = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;getFirstItem();</code> </pre><br>  <b>setPage (1,1)</b> <br><br><pre> <code class="php hljs">$product = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;getCollection() -&gt;setPage(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt;getFirstItem();</code> </pre><br>  <b>load ()</b> <br><br><pre> <code class="php hljs">$product = Mage::getModel(<span class="hljs-string"><span class="hljs-string">'catalog/product'</span></span>)-&gt;load(<span class="hljs-number"><span class="hljs-number">22</span></span>);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/eeb/0a4/afe/eeb0a4afe630406c85e5aa1ae69f611b.png"><br><br>  The problem with getFirstItem is that it loads the entire collection, and then simply returns the first item in foreach, and if it is not there, it returns an empty object. <br><br>  setPage (also known as $ this-&gt; setCurPage ($ pageNum) -&gt; setPageSize ($ pageSize)) limits the selection to exactly 1 record, which, as you can see, significantly speeds up the loading of the result. <br><br>  Even load is faster than getFirstItem, but note that load was slower than selecting one item from the collection.  This is due to the fact that load always works with EAV tables. <br></div></div><br><hr><br><a name="results"></a><h1>  findings </h1><br>  Summarizing everything written above, I want to advise all people working with Magento: <br><br><ul><li>  Never call the load method again on objects obtained from the collection. </li><li>  Load only necessary attributes. </li><li>  If applicable to the project, use flat tables. </li><li>  Use count to count the results of the loaded collection and getSize to get the number of all records. </li><li>  Do not use the getFirstItem method without setPage (1,1) or similar methods. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/282025/">https://habr.com/ru/post/282025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282015/index.html">Callbacks in JavaScript using the example of minions</a></li>
<li><a href="../282017/index.html">Cloud Digest # 4: OS, Infrastructure, and Virtualization</a></li>
<li><a href="../282019/index.html">About conferences</a></li>
<li><a href="../282021/index.html">Why should a book engineer when there is internet</a></li>
<li><a href="../282023/index.html">Microsoft Edge Web Summit 2016 Entries Available - Part 1</a></li>
<li><a href="../282027/index.html">Houdini: one of the most impressive CSS projects you've never heard of</a></li>
<li><a href="../282029/index.html">IDS / IPS Suricata rule appearance statistics for new threats</a></li>
<li><a href="../282031/index.html">8 mistakes when developing a mobile application</a></li>
<li><a href="../282033/index.html">April 23-24, from 12:00 to 12:00, we invite you to # 1 Global Chatbots Hackathon from Webinar.ru</a></li>
<li><a href="../282035/index.html">Weak [weak] links in the new version of Delphi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>