<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Container java-server code with the support of a permanent connection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer 
 Everything described in the article is a personal practical experience and does not pretend to the title of "truth in the last resort." 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Container java-server code with the support of a permanent connection</h1><div class="post__text post__text-html js-mediator-article"><h4>  Disclaimer </h4><br>  Everything described in the article is a personal practical experience and does not pretend to the title of "truth in the last resort." <br><br><h4>  Preamble </h4><br>  Hello.  I am fond of computer games.  My favorite direction in which I constantly try to improve and learn something new is browser-based multiplayer games. <br>  Apache Tomcat is used as a servlet container to create a prototype for a single idea.  It communicates with the client part of the http protocol.  For this type of game, the scheme is quite effective, and it is quite simple to implement. <br>  But one of the premature optimizations (yes, this is bad, but then I decided to allow myself this) was the idea to use a permanent connection between the server and the client, since  In such a scheme, no time is spent on opening / closing a connection in each request.  To implement the scheme, we considered the WebSocket API for Tomcat, but it became interesting to write your own bike, therefore, meet the story about the development under the cut. <a name="habracut"></a><br><br><h4>  Instruments </h4><br>  So, for the implementation of this idea were used: <br><ul><li>  NetBeans 7.2.1: it actually has all the java code written to solve this problem </li><li>  JDK 1.7 </li><li>  Netty: it was decided to use nio to make the server as productive as possible on a large number of connections, this framework perfectly suited. </li><li>  Socket IO: client side </li><li>  Apache Tomcat 7.0.27: for benchmarking </li><li>  Maven: to build all this stuff </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Architecture </h4><br><img src="https://habrastorage.org/storage2/aa8/33d/a84/aa833da84852ee97a3bfbffc795a5ae4.png"><br>  <b>First, consider the logic of the application:</b> <br><br>  The container is represented by the main class of <i>SocketServletContainer</i> .  It serves to start / stop the container, also contains methods for managing servlets.  I want to note that in the article the term servlet denotes an object containing a method with server code, and has nothing to do with the Servlet specification from JCP.  It's just easier for me to call such objects exactly servlets. <br><br>  Actually, we have the base class <i>Servlet</i> , from which all the user's servlets are inherited, the connection session class ( <i>SocketSession</i> ), which serves to store information about the session and to send messages to the user (why I did this, I will explain later).  The classes of the incoming and outgoing buffer ( <i>InputBuffer</i> and <i>OutputBuffer</i> ), respectively, were also implemented. <br><br>  It was also necessary to implement the auxiliary class <i>Config</i> , which is responsible for parsing the configuration file in xml format.  Mention should be made of the <i>QueueHandler</i> and <i>TaskHandler classes</i> . <br><br>  <i>QueueHandler</i> is a request queue handler and contains a method for adding an instance of the <i>Task</i> class for processing. <br>  <i>TaskHandler</i> implements the <i>Runnable</i> interface.  The run method contains the processing of the transmitted request. <br>  The <i>Task</i> class contains information about the incoming request (which servlet to access and the parameters passed to the server) and methods for working with the network (read \ write). <br><br>  <b>Now consider the organization of work with the network:</b> <br><br>  I will not describe in detail the work with Netty, because it has already been done before me (special thanks to <a href="https://habrahabr.ru/users/rena4ka/" class="user_link">Rena4ka</a> for her article on Netty).  Read on Habr√© or documentation on the official website, as you will be more convenient.  I will consider only the part that is necessary to understand the basic principles of a person who does not have programming experience with Netty. <br>  The <i>ServerPipelineFactory</i> class is a ChannelPipeline factory and is needed for Netty to function.  Also I had to implement 3 classes: <i>Decoder</i> , <i>Encoder</i> , <i>NioHandler</i> . <br>  The first 2 are the packet handlers that came to the server.  The decoder is responsible for correctly parsing the packet received from the network and returns an instance of the <i>Task</i> class.  The encoder is responsible for correctly recording the <i>Task</i> instance on the network and sending it to the client. <br>  <i>NioHandler</i> is essentially a network manager: accepts connections, sends tasks for processing and manages sessions. <br><br><h4>  Protocol </h4><br>  For communication between client and server, you need your own protocol.  I decided to make it fairly simple and textual. <br>  As a result, the client sends a query string to the server that looks like this: servlet_name [sysDiv] query_parameters. <br>  The format of the list of query parameters: name1 = value1, name2 = value2, ... <br><br>  <b>Example</b> : "TS [sysDiv] message = Hello habrahabr.ru". <br><br>  It should be noted that the protocol is symmetrical in the sense that the client receives a string indicating the servlet that generated the response and the list of transmitted parameters. <br><br>  And now we proceed directly to the consideration of the code of our container.  But first things first. <br><br><h4>  Configuration file format </h4><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">config</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag">&gt;</span></span>localhost<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">port</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">port</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">workThreadCount</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">workThreadCount</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">processThreadCount</span></span></span><span class="hljs-tag">&gt;</span></span>2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">processThreadCount</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">config</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  <b>workThreadCount</b> - the number of threads that messages receive from the network and write to the network (needed to initialize Netty). <br>  <b>processThreadCount</b> is the number of threads processing the common queue of requests that came to the server.  In them, in fact, there is a parsing of query strings, the work of the entire server code and the formation of responses. <br><br><h4>  SocketServletContainer </h4><br>  This class is a singleton because it is a ‚Äúcentral‚Äù class and it will be more convenient to contact it from other classes of the program.  And, of course, it means 1 copy of the server per application (therefore no thread safe implementation of the singleton is required).  Which, in my opinion, is logical. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketServletContainer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Channel channel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServerBootstrap networkServer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> QueueHandler queueHander; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Servlet&gt; servlets; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Config conf; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SocketServletContainer server= <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;SocketSession&gt; list= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;SocketSession&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;SocketSession&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SocketServletContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (server==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { server= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketServletContainer(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SocketServletContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ conf= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Config(<span class="hljs-string"><span class="hljs-string">"conf.xml"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,   -  Exception. try { conf.read(); } catch(Exception e) { throw new ContainerInitializeException(e.toString()); } servlets= new HashMap&lt;String, Servlet&gt;(); } public void start() { // Netty ExecutorService bossExec = new OrderedMemoryAwareThreadPoolExecutor(1, 400000000, 2000000000, 60, TimeUnit.SECONDS); ExecutorService ioExec = new OrderedMemoryAwareThreadPoolExecutor(conf.getWorkThreadCount(), 400000000, 2000000000, 60, TimeUnit.SECONDS); networkServer = new ServerBootstrap(new NioServerSocketChannelFactory(bossExec, ioExec, conf.getWorkThreadCount())); networkServer.setOption("backlog", 500); networkServer.setOption("connectTimeoutMillis", 10000); networkServer.setPipelineFactory(new ServerPipelineFactory()); channel = networkServer.bind(new InetSocketAddress(conf.getAddress(), conf.getPort())); //    queueHander= new QueueHandler(conf.getProcessThreadCount()); System.out.println("Ready"); } // ¬´¬ª   public void stop() { if (channel.isOpen()) { ChannelFuture future= channel.close(); future.awaitUninterruptibly(); } queueHander.stop(); } public QueueHandler getQueueHandler() { return this.queueHander; } //      public void registerServlet(Servlet servlet, String name) { //    -    HashMap. synchronized(servlets) { if (!servlets.containsKey(name)) { servlets.put(name, servlet); } } } public Servlet getServlet(String name) { return servlets.get(name); } }</span></span></code> </pre><br><h4>  Servlet </h4><br>  Everything is simple and clear.  The doRequest method is called when a packet arrives with an indication to invoke the servlet. <br>  <i>Sub</i> : The transfer of the session to the doRequest method is done with the intent that the servlet can get a List of all existing sessions and send them a message.  For example, when implementing a chat. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Servlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputBuffer input, OutputBuffer output, SocketSession session)</span></span></span></span>; }</code> </pre><br><h4>  Socket session </h4><br>  Each session has its own unique id.  There is a pool of id-nicknames for 20,000 connected clients.  If this limit is exceeded, the server, when trying to create a session, will log an error, send a non-client error message and close the channel. <br>  It is better to calculate the size of the pool empirically, ideally it should be a little more than the number of maximum possible simultaneously connected clients on your server. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketSession</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] idPool; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(idPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idPool==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { idPool= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">20000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;idPool.length;j++) { idPool[j]=<span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;idPool.length;j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idPool[j]==<span class="hljs-number"><span class="hljs-number">0</span></span>) { idPool[j]=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Channel channel; <span class="hljs-comment"><span class="hljs-comment">//      List  . public SocketSession(Channel channel) { this.channel= channel; this.id= generateId(); //    if (this.id==-1) { OutputBuffer out= new OutputBuffer(); out.setPar("error", "Connection limit error"); send(out, "System Servlet"); //  System.err.println("Connection limit error"); return; } SocketServletContainer.getInstance().getListSession().add(this); } public int getId() { return id; } //  .            . public void send(OutputBuffer output, String servletName) { synchronized(channel) { channel.write(new Task(servletName, output.toString())); } } // , ,      - ¬´¬ª  public void close() { synchronized(idPool) { idPool[this.id]= 0; } channel.close(); SocketServletContainer.getInstance().getListSession().remove(this); } }</span></span></code> </pre><br><h4>  InputBuffer </h4><br>  The constructor is initialized, the source string must contain a list of query parameters in the specified format. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputBuffer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, String&gt; map= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, String&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source)</span></span></span><span class="hljs-function"> </span></span>{ String[] par= source.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt; par.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!par[j].contains(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } String[] data= par[j].split(<span class="hljs-string"><span class="hljs-string">"="</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.length&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) { System.err.println(<span class="hljs-string"><span class="hljs-string">"Parsing Error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } map.put(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.get(key); } }</code> </pre><br><h4>  Outputbuffer </h4><br>  The class interface is quite understandable.  An important note is that you need to override the toString () method, since it is this method that is used to form the answer in the <i>SocketSession</i> class. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputBuffer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt; list= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key, String par)</span></span></span><span class="hljs-function"> </span></span>{ list.add(key+<span class="hljs-string"><span class="hljs-string">"="</span></span>+par); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder res= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt; list.size();j++) { res.append(list.get(j)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j!=list.size()-<span class="hljs-number"><span class="hljs-number">1</span></span>) { res.append(<span class="hljs-string"><span class="hljs-string">","</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.toString(); } }</code> </pre><br><h4>  Config </h4><br>  I will not provide the implementation of this class, because its interface is clear from what is used in the <i>SocketServletContainer</i> , and there are quite a lot of implementations of xml parsers on java on the Internet and, I hope, the reader will find the most suitable for it. <br>  I personally used a DOM parser. <br><br><h4>  Queuehandler </h4><br>  This class is also very simple to implement.  Inside it contains a thread pool that performs tasks ( <i>TaskHandler</i> ).  Planning I shifted to a reliable and proven implementation of threadPool.  To create a pool, use the Executors.newFixedThreadPool (n) factory. <br><br>  When the stop method is called, the existing tasks in the queue will be processed, but new <i>TaskHandlers</i> will not be accepted for processing. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExecutorService threadPool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadPoolSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueueHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ threadPoolSize= size; threadPool= Executors.newFixedThreadPool(threadPoolSize); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ threadPool.shutdown(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTaskToProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task task, SocketSession session)</span></span></span><span class="hljs-function"> </span></span>{ threadPool.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskHandler(task, session)); } }</code> </pre><br><h4>  Taskhandler </h4><br>  Everything here is also very simple.  The session of the player and the task to be processed ( <i>Task</i> ) are transferred to the constructor. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Task task; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SocketSession session; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TaskHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task task, SocketSession session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.task= task; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.session= session; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Servlet servlet= SocketServletContainer.getInstance().getServlet(task.getServletName()); OutputBuffer output= new OutputBuffer(); //  ,   . if (servlet==null) { output.setPar("error", "servlet not found"); session.send(output, "Error Message"); return; } //     servlet.doRequest(new InputBuffer(task.getBuffer()),output, session); //  . session.send(output, task.getServletName()); } }</span></span></code> </pre><br><h4>  Task </h4><br>  The <i>Task</i> object has the "servlet name" and "buffer" fields.  The buffer is a query parameter string. <br>  Static write / read methods are required to get instances of a class / write to the channel for Netty to work. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String servletName=<span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String buffer=<span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String servletName, String buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.servletName= servletName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer= buffer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServletName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servletName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; } <span class="hljs-comment"><span class="hljs-comment">//    public void get(ChannelBuffer buffer) { int length= buffer.readInt(); byte[] bytes= new byte[length]; buffer.readBytes(bytes); String input= new String(bytes); String[] data= input.split(java.util.regex.Pattern.quote("[sysDiv]")); if (data.length&lt;2) { System.err.println("Parsing error"); return; } this.servletName= data[0]; this.buffer= data[1]; } //    public void send(ChannelBuffer buffer) { String output= this.servletName + "[sysDiv]"+ this.buffer; buffer.writeInt(output.getBytes().length); buffer.writeBytes(output.getBytes()); } public static Task read(ChannelBuffer buffer) { Task task= new Task(); task.get(buffer); return task; } public static void write(Task task, ChannelBuffer buffer) { task.send(buffer); } }</span></span></code> </pre><br><h6>  Network part </h6><br>  As I promised, I will not consider in detail the work with netty, I‚Äôll just give the code and explain the points that relate to the implementation of logic. <br><br><h4>  ServerPipelineFactory </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerPipelineFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChannelPipelineFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChannelPipeline </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPipeline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Channels.pipeline(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Encoder(),<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Decoder(),<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NioHandler()); } }</code> </pre><br><h4>  Decoder </h4><br>  The packet comes to the server in the following format: the first 4 bytes are the length of the ‚Äúuseful‚Äù data, then the data itself.  <i>The decoder</i> reads, so that in the layers above, we may not think that the data has not yet arrived completely. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decoder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplayingDecoder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecoderState</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DecoderState { READ_LENGTH, READ_CONTENT; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(DecoderState.READ_LENGTH); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ctx.sendUpstream(e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ctx.sendUpstream(e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer, DecoderState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> READ_LENGTH: length = buffer.readInt(); checkpoint(DecoderState.READ_CONTENT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> READ_CONTENT: ChannelBuffer frame= buffer.readBytes(length); <span class="hljs-comment"><span class="hljs-comment">// task       Task task= Task.read(frame); checkpoint(DecoderState.READ_LENGTH); return task; default: throw new Error( "Shouldn't reach here" ); } } }</span></span></code> </pre><br><h4>  Encoder </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Encoder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneToOneEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext channelhandlercontext, Channel channel, Object obj)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Task,      if(!(obj instanceof Task)) { return obj; } Task task= (Task)obj; ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(); // task   Task.write(task, buffer); return buffer; } }</span></span></code> </pre><br><h4>  Niohandler </h4><br>  This object handles the main events of work with the network: connection of clients, receipt of messages, disconnection. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NioHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelUpstreamHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SocketSession session; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     session= new SocketSession(e.getChannel()); System.out.println("Has connect"); } @Override public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { session.close(); } @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) { if(e.getChannel().isOpen()) { //  Task       QueueHandler. Task message= (Task)e.getMessage(); SocketServletContainer.getInstance().getQueueHandler().addTaskToProcess(message, session); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) { //  .  ,    . session.close(); e.getCause().printStackTrace(System.err); ctx.getChannel().close(); } }</span></span></code> </pre><br><br><h4>  Servlet example </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TS</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Servlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputBuffer input, OutputBuffer output, SocketSession session)</span></span></span><span class="hljs-function"> </span></span>{ output.setPar(<span class="hljs-string"><span class="hljs-string">"request"</span></span>, input.getPar(<span class="hljs-string"><span class="hljs-string">"message"</span></span>)+session.getId()); } }</code> </pre><br><br><h4>  How it works or the main class of the application </h4><br>  Actually, the application is not so many lines of code, everything is simple and transparent. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String[] args )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ContainerInitializeException </span></span>{ SocketServletContainer server= SocketServletContainer.getInstance(); server.registerServlet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TS(), <span class="hljs-string"><span class="hljs-string">"TS"</span></span>); server.start(); } }</code> </pre><br><h4>  Some tests </h4><br>  Well, the container is written, it works.  I did not bother with creating a client-side wrapper for it, I limited myself to direct writing to the socket, it looks like this: <br><pre> <code class="java hljs">socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socket(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9999</span></span>); DataOutputStream dos= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataOutputStream(socket.getOutputStream()); DataInputStream dis= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataInputStream(socket.getInputStream()); String buffer= <span class="hljs-string"><span class="hljs-string">"TS[sysDiv]message=IloveJava"</span></span>; dos.writeInt(buffer.getBytes().length+<span class="hljs-number"><span class="hljs-number">4</span></span>); dos.writeInt(buffer.getBytes().length); dos.write(buffer.getBytes()); dos.flush();</code> </pre><br>  In general, as mentioned at the very beginning of the article, the creation of such a system is one of the premature optimizations that I decided to allow myself.  Therefore, it would be foolish not to conduct a couple of tests, since we all wrote this. <br><br>  Actually, I decided to compare this solution with the servlet container, working on http. <br>  For tests, a servlet was written that spins into Tomcat and a servlet that runs inside the created container. <br><br>  <i>Zam:</i> I intentionally compared the performance of the http protocol and solutions on sockets, since the web-socket, which Tomcat successfully supports, was not considered by me for the implementation of this game project. <br><br>  <b>Features of the test:</b> <br><ul><li>  Both servlets performed approximately the same operations, namely, they wrote the same string into the output stream. </li><li>  The test parameter I am interested in is the response time from the server when processing the request </li><li>  Measurements were made on localhost </li><li>  I received response time using standard Java language tools. </li><li>  I was not interested in specific numbers, but rather a comparison of the order of results, since the test was written very ‚Äúcrudely‚Äù </li><li>  For each test, 10,000 queries were performed with the same parameters, after which the average value was calculated </li></ul><br>  And the result is as follows: on average, processing 1 ‚Äúempty‚Äù servlet for Tomcat took <b>0, 99 ms</b> . <br>  The container described in the article coped with a similar task in <b>0, 09 ms</b> . <br><br>  We have 2 results that differ by an order of magnitude.  But given the fact that the idea of ‚Äã‚Äãusing sockets came to me not because of speed, but because of the need to be able to reach the server to the client, the result can be considered more than satisfactory. <br><br><h4>  TODO: </h4><br>  There is also a small list that could be implemented for a similar system, which I will also give: <br><br><ol><li>  Validation of input data.  In the input buffer, you can add the validate (String mask) method, which by the data type mask for the corresponding parameters would automatically convert them to the desired (not just string) type.  It might look something like this: validate (‚Äúmessage: String, count: int‚Äù); </li><li>  Add data encryption.  This is what the record is written to in the byte [] buffer, and not writeUTF8 (), although the protocol is textual.  You can implement interface Crypto {}, which would have 2 methods: code () and encode ().  And the implementation of such an interface should be passed to SocketServletContainer (), for convenient changing or selecting a cryptography algorithm. </li><li>  Working with annotations (as done in Tomcat) and deferred initialization of servlets. </li><li>  More "safe" parsing of the input buffer with escaping delimiter </li><li>  A bunch of other useful little things you might need in such a system. </li></ol><br><h4>  Instead of conclusion </h4><br>  The results of the container completely satisfied my expectations.  Using NIO allowed us to economically consume the flows and configure the container for the existing iron so that it worked as efficiently as possible. <br>  The functionality provided by the container makes it quite convenient to develop an application without worrying about ‚Äúlow-level‚Äù things, such as parsing packages, and so on (I, who was used to developing on tomcat, found everything quite convenient :)). <br><br>  But I still did not dare to use such a solution as the basis of a real project, because for me the presence of sockets, of course, would be very useful (for server-client feedback), but, in principle, not critical.  But the performance and reliability of Tomcat, proven over the years and thousands of developers, raises no questions. <br>  I plan to use the implemented system in ‚Äúnarrow‚Äù, but noncritical places, in which the http-protocol is not very good to use, for example, it is perfect for chat implementation. <br><br>  I hope this article will be interesting for readers and someone will be useful.  I tried to convey a complete picture, perhaps a little too far from the reasoning and the amount of code.  I am pleased to hear your questions and suggestions on the written material. </div><p>Source: <a href="https://habr.com/ru/post/188088/">https://habr.com/ru/post/188088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188074/index.html">This year, Google has already removed 100 million "pirated" links from issuing</a></li>
<li><a href="../188076/index.html">Simple-Science - Simple Experiments (Digest # 26)</a></li>
<li><a href="../188080/index.html">Overview of Embedded USB Hub with ST-Lab E-110 Card Reader</a></li>
<li><a href="../188082/index.html">We study STM32 in practice. Part 1. Screen connection from Siemens C55</a></li>
<li><a href="../188086/index.html">HackPoint. The experience of self-organization of the provincial hackathon from scratch</a></li>
<li><a href="../188090/index.html">Creating TMG Internet traffic reports based on MS Reporting Services</a></li>
<li><a href="../188092/index.html">Android component from scratch</a></li>
<li><a href="../188094/index.html">Order in the photo and video archives using the technique and a pair of scripts</a></li>
<li><a href="../188096/index.html">Failover Master-Slave Cluster on PostgreSQL</a></li>
<li><a href="../188098/index.html">Relations enikeyschika and people in work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>