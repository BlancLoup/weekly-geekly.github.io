<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 4: Adding JIT and Optimizer Support</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to Chapter 4 of the tutorial "Creating a programming language with LLVM." The previous chapters ( 1st , 2nd and 3rd ) described the implementa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 4: Adding JIT and Optimizer Support</h1><div class="post__text post__text-html js-mediator-article">  Welcome to Chapter 4 of the tutorial "Creating a programming language with LLVM."  The previous chapters ( <b><a href="http://habrahabr.ru/blogs/programming/119850/">1st</a></b> , <b><a href="http://habrahabr.ru/blogs/compilers/120005/">2nd</a></b> and <b><a href="http://habrahabr.ru/blogs/compilers/120424/">3rd</a></b> ) described the implementation of the simplest programming language and adding support for generating LLVM IR into it.  This chapter describes two new techniques: adding support for the optimizer and adding support for the JIT compiler.  These additions will demonstrate how to get good, efficient code for our programming language Kaleidoscope. <br><a name="habracut"></a><br><h1>  Simple folding of constants (constant folding) </h1><br>  Our demo to Chapter 3 is elegant and easily expandable.  Unfortunately, it generates far from perfect code.  IRBuilder, however, provides us with obvious optimizations when compiling simple code: <br><br><blockquote><pre> <code class="hljs pgsql">ready&gt; <b>def test(x) <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>+x;</b> <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> definition: define <span class="hljs-type"><span class="hljs-type">double</span></span> @test(<span class="hljs-type"><span class="hljs-type">double</span></span> %x) { entry: %addtmp = fadd <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">3.000000e+00</span></span>, %x ret <span class="hljs-type"><span class="hljs-type">double</span></span> %addtmp }</code> </pre></blockquote><br>  This code is not a literal transcription of AST, built by parsing the input data.  Otherwise, it would be: <br><br><blockquote><pre>  ready&gt; <b>def test (x) 1 + 2 + x;</b>
 Read function definition:
 define double @test (double% x) {
 entry:
         % addtmp = fadd double 2.000000e + 00, 1.000000e + 00
         % addtmp1 = fadd double% addtmp,% x
         ret double% addtmp1
 }
</pre></blockquote><br>  The <a href="http://en.wikipedia.org/wiki/Constant_folding">folding of</a> constants ( <a href="http://en.wikipedia.org/wiki/Constant_folding">constant folding</a> ), as we saw above, is a very often used and very important optimization: so much so that many developers of programming languages ‚Äã‚Äãsupport the folding of constants in AST. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With LLVM, you do not need to implement its support in AST, since all calls to build LLVM IR pass through <code>LLVM IR Builder</code> , which itself checks if it is possible to collapse constants.  It simply collapses the constant and returns a new constant instead.  to create instruction. <br><br>  Well, it was easy :).  In practice, we recommend that you always use <code>IRBuilder</code> when generating code.  It has no ‚Äúsyntax overhead‚Äù when used (you don‚Äôt have to disfigure the compiler with constant checks everywhere), and in some cases it can significantly reduce the number of generated LLVM IRs (especially for languages ‚Äã‚Äãwith macro preprocessors or those using many constants). <br><br>  On the other hand, <code>IRBuilder</code> limited by the fact that it does all the analysis of the code "as is", that is, with the already constructed code.  If you take a slightly more complicated example: <br><br><blockquote><pre>  ready&gt; <b>def test (x) (1 + 2 + x) * (x + (1 + 2));</b>
 ready&gt; Read function definition:
 define double @test (double% x) {
 entry:
         % addtmp = fadd double 3.000000e + 00,% x
         % addtmp1 = fadd double% x, 3.000000e + 00
         % multmp = fmul double% addtmp,% addtmp1
         ret double% multmp
 }
</pre></blockquote><br>  In this case, the left and right sides of the work are the same value.  We would really like to generate something like ‚Äútmp = x + 3;  result = tmp * tmp; "instead of double computing" x + 3 ". <br><br>  Unfortunately, no local analysis will be able to detect and correct this.  This requires two transformations: reassociation of expression (to add lexical identity) and elimination of common subexpressions ( <a href="http://en.wikipedia.org/wiki/Common_subexpression_elimination">Common Subexpression Elimination, CSE</a> ) to remove redundant addition instructions.  Fortunately, LLVM provides a wide range of optimizations that can be used as ‚Äúpasses‚Äù. <br><br><h1>  LLVM optimization passes </h1><br>  LLVM provides many passages of optimizations that do many different kinds of things and have different trade-offs.  Unlike other systems, LLVM has no place for the mistaken notion that one set of optimizations is correct for all languages ‚Äã‚Äãand is suitable for all occasions.  LLVM allows the compiler to be a performer, to fully decide on what optimization to use, in what order and in what situation. <br><br>  LLVM supports and includes both full passes ‚Äúby modules‚Äù and passes ‚Äúby functions‚Äù, which simply work on one function, without taking into account the others.  For more information about passages and how they work, see the document <a href="http://llvm.org/docs/WritingAnLLVMPass.html">How to Write a Pass</a> and <a href="http://llvm.org/docs/Passes.html">List of LLVM Passages</a> . <br><br>  For Kaleidoscope, we currently generate on-the-fly functions one at a time when entered by the user.  We do not aim to get the most out of optimization in the current form, but, nevertheless, we want to get easy and fast code.  Thus, we will select several optimizations ‚Äúby function‚Äù entered by the user.  If we wanted to do a ‚Äústatic Kaleidoscope compiler,‚Äù we would use almost the same code, except that we would postpone the launch of the optimizer until the entire file is parsed. <br><br>  In order to get functional optimizations, we need to create <code><a href="http://llvm.org/docs/WritingAnLLVMPass.html"></a> FunctionPassManager</code>  <code><a href="http://llvm.org/docs/WritingAnLLVMPass.html"></a> FunctionPassManager</code> , which stores and organizes LLVM optimizations that we want to run.  Then we can add a set of optimizations to run.  The code looks like this: <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">FunctionPassManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OurFPM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TheModule)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   .     ,  //       . OurFPM.add(new TargetData(*TheExecutionEngine-&gt;getTargetData())); //   AliasAnalysis  GVN. OurFPM.add(createBasicAliasAnalysisPass()); //   "peephole"  "bit-twiddling". OurFPM.add(createInstructionCombiningPass()); //  . OurFPM.add(createReassociatePass()); //   . OurFPM.add(createGVNPass()); //     (    ..). OurFPM.add(createCFGSimplificationPass()); OurFPM.doInitialization(); //   ,     . TheFPM = &amp;OurFPM; //    " ". MainLoop();</span></span></code> </pre></blockquote><br>  This code defines a <code>FunctionPassManager</code> named <code>"OurFPM"</code> .  When creating it, it is necessary to pass a pointer to the module.  Once this is done, we use a series of <code>"add"</code> calls to add LLVM passes.  The first pass in most cases is template, it is necessary so that subsequent optimizations know what data structures are used in the program.  The variable <code>"TheExecutionEngine"</code> is associated with the JIT, which we will get in the next section. <br><br>  In this case, we decided to add 4 passes of optimization.  The passages that we chose are a fairly standard set of ‚Äúcleansing‚Äù optimizations that are useful for a wide range of code.  I will not go into what they are doing, but believe me, they are a good starting point :). <br><br>  After setting up <code>PassManager</code> , we have to use it.  We run it after generating our new function (in <code>FunctionAST::Codegen</code> ), but before returning to the user: <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value *RetVal = Body-&gt;Codegen()) { <span class="hljs-comment"><span class="hljs-comment">//  . Builder.CreateRet(RetVal); //   ,    (). verifyFunction(*TheFunction);</span></span></code> </pre> <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  . TheFPM-&gt;run(*TheFunction);</span></span></code> </pre> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TheFunction; }</code> </pre></blockquote><br>  As far as you can see, it is quite simple.  <code>FunctionPassManager</code> optimizes and immediately updates <code>LLVM Function*</code> , improving (I really hope so) the function body.  Now we will try to test our code again: <br><br><blockquote><pre>  ready&gt; <b>def test (x) (1 + 2 + x) * (x + (1 + 2));</b>
 ready&gt; Read function definition:
 define double @test (double% x) {
 entry:
         % addtmp = fadd double% x, 3.000000e + 00
         % multmp = fmul double% addtmp,% addtmp
         ret double% multmp
 }
</pre></blockquote><br>  As expected, now we have a well-optimized code with preservation of the result of addition and its reuse. <br><br>  LLVM provides a wide range of optimizations that can be used under certain circumstances.  <a href="http://llvm.org/docs/Passes.html">Some documentation is available</a> on the various aisles, but it is not very complete.  Another good source of ideas for starters is viewing the passages that use llvm-gcc or llvm-ld.  The opt tool allows you to experiment with passes from the command line and see what they do. <br><br>  Now that we have some pretty good code from our front end, we can talk about how to execute it! <br><br><h1>  Adding a JIT compiler </h1><br>  A variety of tools can be applied to the code that is available in LLVM IR.  For example, you can run an optimization for it (as we did above), you can output it in text or binary forms, you can compile the code into an LLVM assembly file (.s) for some platform, or you can apply JIT to it compilation.  The great thing about LLVM IR is that it is ‚Äúone‚Äù between different parts of the compiler. <br><br>  In this section, we will add JIT compilation support for our interpreter.  The main idea of ‚Äã‚ÄãKaleidoscope is that the user can enter a function or a high-level expression and immediately get the result.  For example, when entering ‚Äú1 + 2;‚Äù, we must calculate and display 3, and when defining a function, we can call it from the command line. <br><br>  To begin, we will declare and initialize JIT.  This is done by adding a global variable and calling it in <code>main</code> : <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ExecutionEngine *TheExecutionEngine;</code> </pre> <pre> <code class="cpp hljs">... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ..</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  JIT.    . TheExecutionEngine = EngineBuilder(TheModule).create();</span></span></code> </pre> <pre> <code class="cpp hljs"> .. }</code> </pre></blockquote><br>  This creates an abstract <code>"Execution Engine"</code> , which can be either a compiler or an LLVM interpreter.  LLVM will automatically select the JIT compiler for you if it exists for your platform, otherwise it will return back to the interpreter. <br><br>  After creating <code>ExecutionEngine</code> , JIT is ready for use.  There are various useful APIs, but the simplest of these is the <code>"getPointerToFunction(F)"</code> method.  This JIT method compiles the specified LLVM function and returns a function pointer to the generated machine code.  In our case, this means that we can change the code that parses the top-level expression as follows: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTopLevelExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      . if (FunctionAST *F = ParseTopLevelExpr()) { if (Function *LF = F-&gt;Codegen()) { LF-&gt;dump(); //  .</span></span></code> </pre> <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// JIT-,   . void *FPtr = TheExecutionEngine-&gt;getPointerToFunction(LF); //     ( ,  double), //       . double (*FP)() = (double (*)())(intptr_t)FPtr; fprintf(stderr, "Evaluated to %f\n", FP());</span></span></code> </pre> <pre> <code class="cpp hljs"> }</code> </pre></blockquote><br>  Recall that we represent the top-level expression as an autonomous anonymous LLVM function that takes no arguments and returns a real number.  Since we use the LLVM JIT compiler on the native platform, you can simply cast the result to a functional type and directly call this function.  This means that there is no difference between JIT-compiled code and machine code that is statically linked into your application. <br><br>  With these only two changes, we can now see the work of Kaleidoscope! <br><br><blockquote><pre>  ready&gt; <b>4 + 5;</b>
 define double @ "" () {
 entry:
         ret double 9.000000e + 00
 }<font></font>
<font></font>
 Evaluated to 9.000000
</pre></blockquote><br>  Great, it looks like it works.  The dump of the function shows the ‚Äúno-argument function returning a double,‚Äù which we synthesize for each high-level expression entered.  This is only a demonstration of basic functionality, but can we do more? <br><br><blockquote><pre>  ready&gt; <b>def testfunc (xy) x + y * 2;</b>
 Read function definition:
 define double @testfunc (double% x, double% y) {
 entry:
         % multmp = fmul double% y, 2.000000e + 00
         % addtmp = fadd double% multmp,% x
         ret double% addtmp
 }
</pre><br>  ready&gt; <b>testfunc (4, 10);</b> <pre> define double @ "" () {
 entry:
         % calltmp = call double @testfunc (double 4.000000e + 00, double 1.000000e + 01)
         ret double% calltmp
 }<font></font>
<font></font>
 Evaluated to 24.000000
</pre></blockquote><br>  This shows that we can execute custom code, but there is one subtle point.  Note that we call the JIT on an anonymous function that calls <code>testfunc</code> , but never call it on testfunc itself.  In fact, that the JIT for all non-anonymous functions is transitively called and compiled from an anonymous function before being returned from <code>getPointerToFunction()</code> . <br><br>  JIT provides a number of other, more advanced interfaces for such things as freeing the memory allocated by machine code, recompiling functions for updating them, etc.  However, even with this simple code, we get surprisingly powerful features - check it out (I deleted the anonymous functions dump so you only see the idea :): <br><br><blockquote><pre>  ready&gt; <b>extern sin (x);</b>
 Read extern: 
 declare double @sin (double)
</pre><br>  ready&gt; <b>extern cos (x);</b> <pre> Read extern: 
 declare double @cos (double)
</pre><br>  ready&gt; <b>sin (1.0);</b> <pre> Evaluated to 0.841471
</pre><br>  ready&gt; <b>def foo (x) sin (x) * sin (x) + cos (x) * cos (x);</b> <pre> Read function definition:
 define double @foo (double% x) {
 entry:
         % calltmp = call double @sin (double% x)
         % multmp = fmul double% calltmp,% calltmp
         % calltmp2 = call double @cos (double% x)
         % multmp4 = fmul double% calltmp2,% calltmp2
         % addtmp = fadd double% multmp,% multmp4
         ret double% addtmp
 }
</pre><br>  ready&gt; <b>foo (4.0);</b> <pre> Evaluated to 1.000000
</pre></blockquote><br>  Wow, how did JIT find out about <code>sin</code> and <code>cos</code> ?  The answer is surprisingly simple: in this example, JIT started the function execution and got to the function call.  He realized that the function had not yet been compiled by JIT and called the standard set of procedures for calculating the function.  In this case, its body is not defined for the function, so the JIT will end up by calling <code>"dlsym("sin")"</code> .  Since <code>"sin"</code> defined in the JIT address space, it simply directly calls the library function. <br><br>  The LLVM JIT provides a number of interfaces (see the file <code>ExecutionEngine.h</code> ) to control how the receipt of an undefined function is handled.  This allows you to set up an explicit mapping between IR objects and addresses, allowing you to dynamically resolve function names on the fly, and even allow lazy JIT compilation of functions when they are first used. <br><br>  One of the interesting applications of this is that now we can expand the language by writing arbitrary C ++ code for performing operations.  For example, if we add: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// putchard -        0. extern "C" double putchard(double X) { putchar((char)X); return 0; }</span></span></code> </pre></blockquote><br>  Now we can produce simple output to the console using something like this code: <code>"extern putchard(); putchard(120);"</code>  which prints lowercase 'x' to the console (120 is the ASCII code for 'x').  Similar code can be used in Kaleidoscope to implement file I / O, console input, and many other features. <br><br>  This concludes the chapter on JIT and the optimizer.  At the moment, we can JIT-compile and optimize the code of a non-Turing-complete programming language, focused on user input.  Next, we will look at extending our language to control the flow of control, addressing some interesting issues of LLVM IR along the way. <br><br><h1>  Full code listing </h1><br>  And now, as always, a full listing of the code for our works, which you can collect as follows: <br><br><blockquote> <code># <b></b> <br> g++ -g toy.cpp `llvm-config --cppflags --ldflags --libs core jit native` -O3 -o toy <br> # <b></b> <br> ./toy <br></code> </blockquote><br>  When compiling on Linux, add the "-rdynamic" option.  This ensures that external functions at run time are properly resolved. <br><br>  But the code itself: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ExecutionEngine/ExecutionEngine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ExecutionEngine/JIT.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/PassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Passes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetData.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace llvm; //===----------------------------------------------------------------------===// // Lexer ( ) //===----------------------------------------------------------------------===// //     [0-255],   , //       enum Token { tok_eof = -1, //  ( ) tok_def = -2, tok_extern = -3, //  ( : , ) tok_identifier = -4, tok_number = -5 }; static std::string IdentifierStr; // ,  tok_identifier static double NumVal; // ,  tok_number /// gettok -       . static int gettok() { static int LastChar = ' '; //  . while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), 0); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   . if (LastChar == EOF) return tok_eof; //         ASCII int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (     ) //===----------------------------------------------------------------------===// /// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {} virtual Value *Codegen() = 0; }; /// NumberExprAST -       (, "1.0"). class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {} virtual Value *Codegen(); }; /// VariableExprAST -      (, "a"). class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;name) : Name(name) {} virtual Value *Codegen(); }; /// BinaryExprAST -      . class BinaryExprAST : public ExprAST { char Op; ExprAST *LHS, *RHS; public: BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {} virtual Value *Codegen(); }; /// CallExprAST -      . class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;ExprAST*&gt; Args; public: CallExprAST(const std::string &amp;callee, std::vector&lt;ExprAST*&gt; &amp;args) : Callee(callee), Args(args) {} virtual Value *Codegen(); }; /// PrototypeAST -    ""  , ///        (,  , ///    ). class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; public: PrototypeAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args) : Name(name), Args(args) {} Function *Codegen(); }; /// FunctionAST -     class FunctionAST { PrototypeAST *Proto; ExprAST *Body; public: FunctionAST(PrototypeAST *proto, ExprAST *body) : Proto(proto), Body(body) {} Function *Codegen(); }; //===----------------------------------------------------------------------===// // Parser (   ) //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -   /// ,  . getNextToken     ///     CurTok. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -      static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -     . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     . int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -       . ExprAST *Error(const char *Str) { fprintf(stderr, "Error: %s\n", Str);return 0;} PrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; } FunctionAST *ErrorF(const char *Str) { Error(Str); return 0; } static ExprAST *ParseExpression(); /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static ExprAST *ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //  . return new VariableExprAST(IdName); //  . getNextToken(); //  ( std::vector&lt;ExprAST*&gt; Args; if (CurTok != ')') { while (1) { ExprAST *Arg = ParseExpression(); if (!Arg) return 0; Args.push_back(Arg); if (CurTok == ')') break; if (CurTok != ',') return Error("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return new CallExprAST(IdName, Args); } /// numberexpr ::= number static ExprAST *ParseNumberExpr() { ExprAST *Result = new NumberExprAST(NumVal); getNextToken(); //   return Result; } /// parenexpr ::= '(' expression ')' static ExprAST *ParseParenExpr() { getNextToken(); //  (. ExprAST *V = ParseExpression(); if (!V) return 0; if (CurTok != ')') return Error("expected ')'"); getNextToken(); //  ). return V; } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr static ExprAST *ParsePrimary() { switch (CurTok) { default: return Error("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); } } /// binoprhs /// ::= ('+' primary)* static ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //           , //  ,    if (TokPrec &lt; ExprPrec) return LHS; // ,  ,    . int BinOp = CurTok; getNextToken(); // eat binop //       ExprAST *RHS = ParsePrimary(); if (!RHS) return 0; //  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec+1, RHS); if (RHS == 0) return 0; } //  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } } /// expression /// ::= primary binoprhs /// static ExprAST *ParseExpression() { ExprAST *LHS = ParsePrimary(); if (!LHS) return 0; return ParseBinOpRHS(0, LHS); } /// prototype /// ::= id '(' id* ')' static PrototypeAST *ParsePrototype() { if (CurTok != tok_identifier) return ErrorP("Expected function name in prototype"); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return ErrorP("Expected '(' in prototype"); //    . std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return ErrorP("Expected ')' in prototype"); //  . getNextToken(); //  ')'. return new PrototypeAST(FnName, ArgNames); } /// definition ::= 'def' prototype expression static FunctionAST *ParseDefinition() { getNextToken(); //  def. PrototypeAST *Proto = ParsePrototype(); if (Proto == 0) return 0; if (ExprAST *E = ParseExpression()) return new FunctionAST(Proto, E); return 0; } /// toplevelexpr ::= expression static FunctionAST *ParseTopLevelExpr() { if (ExprAST *E = ParseExpression()) { //   . PrototypeAST *Proto = new PrototypeAST("", std::vector&lt;std::string&gt;()); return new FunctionAST(Proto, E); } return 0; } /// external ::= 'extern' prototype static PrototypeAST *ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation () //===----------------------------------------------------------------------===// static Module *TheModule; static IRBuilder&lt;&gt; Builder(getGlobalContext()); static std::map&lt;std::string, Value*&gt; NamedValues; static FunctionPassManager *TheFPM; Value *ErrorV(const char *Str) { Error(Str); return 0; } Value *NumberExprAST::Codegen() { return ConstantFP::get(getGlobalContext(), APFloat(Val)); } Value *VariableExprAST::Codegen() { //      . Value *V = NamedValues[Name]; return V ? V : ErrorV("Unknown variable name"); } Value *BinaryExprAST::Codegen() { Value *L = LHS-&gt;Codegen(); Value *R = RHS-&gt;Codegen(); if (L == 0 || R == 0) return 0; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //   0  1   0.0  1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalContext()), "booltmp"); default: return ErrorV("invalid binary operator"); } } Value *CallExprAST::Codegen() { //      . Function *CalleeF = TheModule-&gt;getFunction(Callee); if (CalleeF == 0) return ErrorV("Unknown function referenced"); //    . if (CalleeF-&gt;arg_size() != Args.size()) return ErrorV("Incorrect # arguments passed"); std::vector&lt;Value*&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;Codegen()); if (ArgsV.back() == 0) return 0; } return Builder.CreateCall(CalleeF, ArgsV.begin(), ArgsV.end(), "calltmp"); } Function *PrototypeAST::Codegen() { //   : double(double,double)  .. std::vector&lt;const Type*&gt; Doubles(Args.size(), Type::getDoubleTy(getGlobalContext())); FunctionType *FT = FunctionType::get(Type::getDoubleTy(getGlobalContext()), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule); //   (F)     ,     'Name'. //     ,      . if (F-&gt;getName() != Name) { //   ,      . F-&gt;eraseFromParent(); F = TheModule-&gt;getFunction(Name); //   (F)   , . if (!F-&gt;empty()) { ErrorF("redefinition of function"); return 0; } //   (F)    , . if (F-&gt;arg_size() != Args.size()) { ErrorF("redefinition of function with different # args"); return 0; } } //     . unsigned Idx = 0; for (Function::arg_iterator AI = F-&gt;arg_begin(); Idx != Args.size(); ++AI, ++Idx) { AI-&gt;setName(Args[Idx]); //      . NamedValues[Args[Idx]] = AI; } return F; } Function *FunctionAST::Codegen() { NamedValues.clear(); Function *TheFunction = Proto-&gt;Codegen(); if (TheFunction == 0) return 0; //      . BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction); Builder.SetInsertPoint(BB); if (Value *RetVal = Body-&gt;Codegen()) { //  . Builder.CreateRet(RetVal); //   ,    (). verifyFunction(*TheFunction); //  . TheFPM-&gt;run(*TheFunction); return TheFunction; } //  ,   . TheFunction-&gt;eraseFromParent(); return 0; } //===----------------------------------------------------------------------===// // Top-Level parsing (  )   JIT //===----------------------------------------------------------------------===// static ExecutionEngine *TheExecutionEngine; static void HandleDefinition() { if (FunctionAST *F = ParseDefinition()) { if (Function *LF = F-&gt;Codegen()) { fprintf(stderr, "Read function definition:"); LF-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleExtern() { if (PrototypeAST *P = ParseExtern()) { if (Function *F = P-&gt;Codegen()) { fprintf(stderr, "Read extern: "); F-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (FunctionAST *F = ParseTopLevelExpr()) { if (Function *LF = F-&gt;Codegen()) { // JIT-,   . void *FPtr = TheExecutionEngine-&gt;getPointerToFunction(LF); //     ( ,  double), //       . double (*FP)() = (double (*)())(intptr_t)FPtr; fprintf(stderr, "Evaluated to %f\n", FP()); } } else { //      . getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': getNextToken(); break; //     . case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,     //   ("extern")   . //===----------------------------------------------------------------------===// /// putchard -        0. extern "C" double putchard(double X) { putchar((char)X); return 0; } //===----------------------------------------------------------------------===// // Main driver code (  ) //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); LLVMContext &amp;Context = getGlobalContext(); //    . // 1 -  . BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . fprintf(stderr, "ready&gt; "); getNextToken(); //  ,     . TheModule = new Module("my cool jit", Context); //  JIT.     . std::string ErrStr; TheExecutionEngine = EngineBuilder(TheModule).setErrorStr(&amp;ErrStr).create(); if (!TheExecutionEngine) { fprintf(stderr, "Could not create ExecutionEngine: %s\n", ErrStr.c_str()); exit(1); } FunctionPassManager OurFPM(TheModule); //   .     ,  //       . OurFPM.add(new TargetData(*TheExecutionEngine-&gt;getTargetData())); //   AliasAnalysis  GVN. OurFPM.add(createBasicAliasAnalysisPass()); //   "peephole"  "bit-twiddling". OurFPM.add(createInstructionCombiningPass()); //  . OurFPM.add(createReassociatePass()); //   . OurFPM.add(createGVNPass()); //     (    ..). OurFPM.add(createCFGSimplificationPass()); OurFPM.doInitialization(); //   ,     . TheFPM = &amp;OurFPM; //    " ". MainLoop(); TheFPM = 0; //   . TheModule-&gt;dump(); return 0; }</span></span></span></span></code> </pre></blockquote><br><br><h5> <b>PS  ,   :</b> </h5><ul><li> <b><a href="http://ru.wikipedia.org/wiki/JIT-%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">JIT-</a> [ <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">en</a> ]</b> </li><li> <b><a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D1%2582%25D0%25B8%25D0%25BC%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580%25D0%25B0"> </a> [ <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D1%2582%25D0%25B8%25D0%25BC%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)"> </a> ]</b> </li><li> <b><a href="http://habrahabr.ru/blogs/programming/102597/">. 5  1/2: llvm  back-end</a> [  ]</b> </li><li> <b><a href="http://habrahabr.ru/blogs/programming/101946/">. 8: </a> [  ]</b> </li><li> <b><a href="http://habrahabr.ru/blogs/hi/111021/">  </a> [  ]</b> </li><li> <b><a href="http://habrahabr.ru/blogs/programming/101838/">LLVM :   </a> [  ]</b> </li><li> <b><a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.97.3985%26rep%3Drep1%26type%3Dpdf">A Brief History of Just-In-Time</a> [pdf, en]</b> </li><li> <b><a href="http://llvm.org/docs/DebuggingJITedCode.html">Debugging JITed Code With GDB</a> [en]</b> </li><li> <b><a href="http://llvm.org/docs/doxygen/html/classllvm_1_1JIT.html">LLVM JIT Class Reference</a> [en]</b> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/120516/">https://habr.com/ru/post/120516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120504/index.html">RVM - detail</a></li>
<li><a href="../120505/index.html">Site optimization. Technological foundation. Part 2</a></li>
<li><a href="../120506/index.html">From August 1, Google stops supporting Firefox 3.5, IE7 and Safari 3</a></li>
<li><a href="../120507/index.html">Richard Feynman "IN SEARCH OF NEW LAWS"</a></li>
<li><a href="../120515/index.html">Fullscreen YouTube view</a></li>
<li><a href="../120517/index.html">About how to put chaos in order, do it every day, and not waste time on it</a></li>
<li><a href="../120520/index.html">How the cultural specificity is taken into account</a></li>
<li><a href="../120522/index.html">Test Fixer Software</a></li>
<li><a href="../120523/index.html">Sony Pictures website hacked, 1 million account data stolen</a></li>
<li><a href="../120524/index.html">Social projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>