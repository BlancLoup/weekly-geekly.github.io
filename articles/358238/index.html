<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Women's networks: who makes the choice for us?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The rise of interest in machine learning is largely due to the fact that models are able to give a significant increase in profits in areas related to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Women's networks: who makes the choice for us?</h1><div class="post__text post__text-html js-mediator-article">  The rise of interest in machine learning is largely due to the fact that models are able to give a significant increase in profits in areas related to the prediction of the behavior of complex systems.  In particular, the complex system whose behavior to predict is profitable is a person.  To detect fraud at an early stage, to identify the tendency of customers to outflow - these tasks arise regularly and have already become classic in Data Science.  Of course, they can be solved by various methods, depending on the preferences of a particular specialist and on the requirements of the business. <br><br>  We had the opportunity to use neural networks to solve the problem of predicting the behavior of people, and the specificity of the application area was associated with the beauty industry.  The main audience for the "experiences" were women.  We basically came to the question: can an artificial neural network understand a real neural network (human) in an area in which even the person himself has not yet realized his behavior.  As we answered this question and what we got in the end, you can find out further. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/zu/sd/qizusd7sneh9frxqtasmtspdkkg.jpeg"></div><a name="habracut"></a><br>  The British marketing agency offered our team to optimize marketing communications for several brands from the beauty industry.  To solve this problem, we had to carry out an assault on buyers from different sides.  As a result, we built a number of predictive and recommendatory models that help to find an individual approach to each of the buyers.  Along the way, we decided on several important business points, and his key KPIs have grown up. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Instead of massive bombardment with advertising, we use point personalized offers. </h3><br>  Any retailer wants to increase their sales.  To do this, we need to offer the goods that the customer will most likely buy, using the most optimal communication channel, and do it at the right time.  Thus, first of all, the store needs a recommendation system, as well as systematic orchestration of channels and several predictive models.  This AI task we took, <a href="http://cleverdata.ru/">CleverDATA</a> , commissioned by the agency Beauty Brains. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/gn/1k/u4gn1kxkfo8t7pxyelyma-9aapy.jpeg"></div><br>  In the arsenal of brands there was a history of customer purchases, a history of customer visits to the site, as well as information on mailings and reactions to mailings from each recipient.  Thus, we could see which emails the client received, which of them opened, which links it went to and what it led to. <br><br>  To begin with, we made a recommender system using classical methods: matrix decomposition, collaborative filtering, association rules, etc. Then we decided to experiment whether it was possible to do something more effective for our particular case, and we came to the recommendation system on neural networks. <br><br>  The advantage of the new experimental system was that it used, firstly, additional information about the products from their text descriptions, and secondly, the sequence of customer purchases was taken into account. <br><br>  Then we began to connect various channels of communication: first of all, the mailing list, which is one of the cheapest channels.  In addition, Facebook messages and advertisements via Adwords began to be delivered to recipients. <br><br>  As a result, we have prepared a self-driving solution for marketers of the customer, which is a daily set of highly personalized newsletters.  Naturally, the number of campaigns has significantly increased, and the number of recipients of each of them has dramatically decreased.  That is, we have provided the marketer with a set of ‚Äúmicro-campaigns‚Äù as an instrument, where each specific customer receives an offer with the most relevant product on individual conditions (with a personal discount, gifts, probes, if the latter are interested in the customer, etc.). <br><br>  In addition, we had at our disposal the knowledge gained from analyzing a large array of beauty blogs.  I already <a href="https://habrahabr.ru/company/lanit/blog/329892/">wrote</a> about the results of the analysis of this corpus <a href="https://habrahabr.ru/company/lanit/blog/329892/">in Habr√©</a> . <br><br>  Of course, in the mailing lists, LTV-prediction, prediction of outflow, calculation of loyalty, prediction of a suitable discount, as well as prediction of customer susceptibility to gifts and probes are used.  The more likely that the customer will make a purchase soon, the lower the discount he gets.  And if there were no purchases for a long time, a person falls into the group of customers whom the brand risks losing, and the discounts for it increase. <br><br>  Testing of the system was conducted during September-December 2017, as a result the project was recognized as successful.  Next, I will consider the specific case that we had to solve within the project. <br><br><h3>  We learn networks to understand people.  What tools to choose? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-i/nj/gh/-injgh86illomgdklgocphmbv5g.jpeg"></div>  <a href=""><i>A source</i></a> <br><br>  The number of people subscribed to the newsletter is usually much greater than the number of buyers.  Naturally, there is a group of addressees in which the probability of the first purchase is increased.  We can target additional advertising campaigns to these people, but we cannot launch additional campaigns on the entire contact database, since they require an additional budget. <br><br>  Those.  we need to predict people's behavior and run campaigns only on a narrow target audience.  There is no additional information about these potential customers, the brand only knows how they opened the letters and what links they followed.  Therefore, we came to the task of teaching the machine to understand the behavior of people. <br><br>  This problem can be solved in many ways.  We went in the direction of neural networks. <br><br>  So, we will work with the sequence of actions of the recipient of the mailing, <br>  recurrent neural networks are well suited for processing a series of events (they are often used for word processing).  About this family has been repeatedly written on Habr√© (for example, <a href="https://habrahabr.ru/post/342738/">here</a> or <a href="https://habrahabr.ru/company/dca/blog/274027">here</a> ).  Recurrent neural networks in their classical implementation have a number of characteristic problems, for example, they quickly forget.  If we train the classic recurrent neural network on the book, then by the middle of the chapter, it will forget how this chapter began. <br><br>  Today, LSTM neural networks, which have managed to overcome many of the problems of classical neural networks, have become widespread.  LSTM neural networks have memory: they operate on cells that can memorize, play, and forget information.  In addition, LTSM networks are good when events are separated by time lags with indefinite duration and boundaries. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/9f/vu/ki9fvul0bh-hfomr-4elleu51ji.jpeg"></div>  <a href=""><i>A source</i></a> <br><br>  In principle, you can train an LSTM neural network based on the actions of the recipients of the mailing list, but such a model will deal well with only one type of behavior, and the signs obtained from this model will be difficult to interpret and even harder to use in other models without looking inadvertently the future: if we train the model on a specific target action, then this model should have information about the future ‚Äî whether the person will perform the target action in the future on the model in the training sample of the training objects. <br><br>  If we are planning to use the result of the model in other models, then it is necessary to carefully monitor that the information about the future does not go along with the predictions of the model.  If information about the future inadvertently happens, the new model will be retrained.  Therefore, for later use, it will be more convenient to train on events without knowing their result, and to reduce the sequence of events into signs that could later be used in other predictive models.  And the autoencoder, or the autocoder can help us in this. <br><br>  About autoencoders on Habr√© can also be read, for example, <a href="https://habrahabr.ru/post/331382/">here</a> and <a href="https://habrahabr.ru/post/331552/">here</a> .  They are constructed so that they have the same dimension at the input and output, and the dimension in the middle is much smaller.  This restriction causes the neural network to look for generalizations and correlations in the sequence of events, so the auto-encoders are forced to somehow generalize the incoming data. <br><br>  In training such a network, the principle of reverse propagation of error is used, as in training with a teacher, however, we can require that the input signal and the output signal of the network be as close as possible.  As a result, we will train without using information about the result to which the sequence of actions led, i.e.  get training without a teacher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/gn/qx/clgnqxmacw_d14rifgui7ba0kj0.jpeg"></div>  <a href="https://towardsdatascience.com/applied-deep-learning-part-3-autoencoders-1c083af4d798"><i>Source of</i></a>  <i>The autocoder is able to effectively reduce the dimension of the feature space: the smaller the ‚Äúbottleneck‚Äù dimension, the stronger the compression, but the higher the information loss.</i> <br><br>  The general structure of our neural network is clear: it will be an autoencoder using LSTM cells.  It remains to decide how to encode the sequence of actions of a potential buyer.  One option is one-hot-encoding: the action is encoded by one, the other action alternatives are zero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n6/-r/u7/n6-ru7hpe5nltvvxi717lni4gwe.jpeg"></div><br>  The first problem that arises here is the way people go from receiving a marketing newsletter to purchasing on a website, which is different in length.  It is easy to cope with it: we take a fixed length of the sequence of vectors, discarding the excess, filling the missing with zeros.  The network quickly learns to understand that the extra zeros at the beginning of the sequence of events do not need to pay attention. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jz/3z/rp/jz3zrp40nonzs7om5t1o5suwzcs.jpeg"></div><br>  And now it‚Äôs worth thinking that different people need different times to get a letter, follow the links and make a purchase.  Time plays a significant role in understanding human behavior.  How to take into account the time sequence of client actions  We added the time difference between the events as an additional element of the vector encoding the actions of the recipient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mz/ya/ut/mzyautca2xt6zg6xsak2zgydsaq.jpeg"></div><br>  If the difference between events in seconds, in some cases, the time component of the vector component will reach 10 <sup>3</sup> -10 <sup>6</sup> , which will adversely affect the training of the network.  A better solution would be to use the logarithm of the time difference between the events.  For a successful neural network training, it is recommended to work with numbers in the range from zero to one, therefore it is even better to normalize the logarithm of the time difference and add it as another element of the recipient's action vector.  The time difference for the last event can be taken as the difference between the last event and the current point in time. <br><br>  At one of the brands we received datasets from several thousand companies sent to ~ 200,000 people.  Thus, the training sample consisted of approximately 200,000 vectors encoding a sequence of actions for mailing recipients. <br><br><h3>  From theory to practice </h3><br>  At the beginning of the encoder we set the layer of LSTM-cells, which will translate a series of events into a vector containing information about the entire sequence.  You can make a series of consecutive LSTM layers, gradually reducing their dimension.  To return the representation from the vector to the sequence of events, we repeat this vector n times before submitting it to the input of the LSTM decoder layer.  The general scheme of such an auto encoder on keras will take literally several lines and is shown below.  Note that the LSTM decoder layer should not return a vector, but a sequence, which is indicated by the parameter <b>return_sequences = True</b> . <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Input, LSTM, RepeatVector <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Model inputs = Input(shape=(timesteps, input_dim)) encoded = LSTM(latent_dim)(inputs) decoded = RepeatVector(timesteps)(encoded) decoded = LSTM(input_dim, return_sequences=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)(decoded) sequence_autoencoder = Model(inputs, decoded) encoder = Model(inputs, encoded)</code> </pre> <br>  If nothing is confused with the dimensions of the tensors, then the network will train.  In the future, to improve the quality of the model, we added several additional LSTM layers both to the encoder and to the decoder, and as the ‚Äúbottleneck‚Äù we used several ordinary fully connected layers of neurons, naturally, not forgetting Dropout, Batch Normalization and other techniques for training neural networks. <br><br>  For comparison, we tried to train the actor on convolutional neural networks (onvolution Neural Networks, CNN) on the same data set.  Convolutional layers help to establish patterns of behavior of objects and reduce the number of model parameters, which significantly speeds up learning.  About convolutional neural networks, too, there are articles on Habr√© ( <a href="https://habrahabr.ru/post/309508/">here</a> , <a href="https://habrahabr.ru/post/348000/">here</a> and, for example, <a href="https://habrahabr.ru/company/ods/blog/344888/">here</a> ), so we will not dwell on them in detail.  Schematically, the architecture of the autocoder on convolutional neural networks is as follows: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Input, Dense, Conv2D, MaxPooling2D, UpSampling2D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Model input_tensor = Input(shape=input_dim) x = Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(input_tensor) x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) x = Conv2D(<span class="hljs-number"><span class="hljs-number">8</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) x = Conv2D(<span class="hljs-number"><span class="hljs-number">8</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) encoded = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) x = Conv2D(<span class="hljs-number"><span class="hljs-number">8</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(encoded) x = UpSampling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))(x) x = Conv2D(<span class="hljs-number"><span class="hljs-number">8</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) x = UpSampling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))(x) x = Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = UpSampling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))(x) decoded = Conv2D(<span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) autoencoder = Model(input_tensor, decoded)</code> </pre> <br>  Since  the elements of tensors take values ‚Äã‚Äãin the range from 0 to 1, then you can use the function of cross-loss entropy (binary crossentropy). <br><br>  The CNN auto-encoder learning result on the quality metric was even higher than the LSTM auto-encoder, and the learning time is noticeably faster. <br><br>  In addition, it is possible to make an auto-encoder on CNN and LSTM: first several convolutional layers, then an auto-encoder based on LSTM, terminated by a decoder based on convolutional layers.  This auto-encoder will combine the positive aspects of both approaches.  In our experience, such an auto-encoder is slightly better than an auto-encoder on CNN and much better than an auto-encoder on LSTM in terms of quality metrics in a validation sample. <br><br>  After training, the encoder translates a sequence of actions for each recipient into a feature vector, and thus we get an analogue of word2vec for a series of events.  The resulting vector may be used in other predictive models, clustering, searching for people who are close in behavior, and also performing anomaly search. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/jw/gd/ntjwgdhi4dhvhyrszdnrfaj1bv0.jpeg"></div>  <i>The projection on the two-dimensional space of the vectors of behavior of the recipients of letters received by the auto-encoder (t-SNE)</i>  <i>Red dots are recipients making a purchase in the near future, blue dots are recipients who have not made a purchase.</i>  <i>It is seen that there are areas in which inert recipients predominate, and there are areas with a high concentration of future buyers.</i> <br><br>  In our case, we built a model that predicts the likelihood of buying the recipient of the letter.  The model on a number of basic signs gave roc-auc 0.74‚Äì0.77, and with the added vectors responsible for human behavior, roc-auc reached 0.84‚Äì0.88. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5y/6h/xr/5y6hxrdvciwdereamdepfneodbc.jpeg"></div>  <i>In the list of the most significant signs, the dominant position is occupied by signs from two auto-encoders: based on LSTM and CNN.</i> <br><br>  It must be recognized that the use of CNN-based autocoder for this task gave a better result, however, the LSTM autocoder gave a vector of smaller dimension and allowed roc-auc to be adjusted a little further.  If we use the signs based on the auto-encoder CNN + LSTM, then roc-auc is obtained in the range of 0.82-0.87. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/p8/rd/ifp8rdjz0eklrfyzig-r2cquu-0.jpeg"></div>  <i>Comparison of ROC curves of two models: roc-auc models on the main features 0.74-0.77, roc-auc models on the main features and signs of the autocoder 0.84-0.88.</i> <br><br><h3>  findings </h3><br>  Our experience confirmed the fact that it is possible to encode the behavior of people on the neural networks by means of an auto-encoder: in our case, the sequence of behavior of the distribution recipients was encoded using the auto-encoders on LSTM and on CNN-architectures.  The use of this approach is not limited to sending letters: the encoded behavior of objects can be used in other tasks that require working with human behavior: search for fraudulent actions, prediction of outflow, search for anomalies, etc. <br><br>  The proposed approach can be developed in the direction of variational auto-encoders, if there is a need for modeling the behavior of people. <br><br>  The fact that the CNN based autocoder copes with the task considered better than on LSTM suggests that behavior patterns allow for this task to extract more informative features than features based on temporal connections between events.  Nevertheless, on the prepared data set it is possible to use both approaches, and the total effect of the combined use of features of both auto-encoders gives an increase to roc-auc by 0.01-0.02. <br><br>  Thus, neural networks are able to understand from the behavior of a person that he is inclined to purchase, perhaps even before the person himself realizes this.  An amazing example of the fractality of our world: people's neurons help organize the training of neural networks in order to predict the result of the work of other people's neurons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jg/b2/o5/jgb2o5ayq8lfgprp-frfainrcns.jpeg"></div><br><div class="spoiler">  <b class="spoiler_title">By the way, there are vacancies in our company!</b> <div class="spoiler_text"><ul><li>  <a href="https://job.lanit.ru/vacancy/Pages/CD-14.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2018-05-15%26utm_campaign%3Dhabr">System engineer</a> </li><li>  <a href="https://job.lanit.ru/vacancy/Pages/CD-11.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2018-05-15%26utm_campaign%3Dhabr">Analyst</a> </li><li>  <a href="https://job.lanit.ru/vacancy/Pages/CD-02.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2018-05-15%26utm_campaign%3Dhabr">Java developer</a> </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/358238/">https://habr.com/ru/post/358238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358228/index.html">How we conduct experiments in humans. A / b testing for advanced</a></li>
<li><a href="../358230/index.html">Robot Tank on Raspberry Pi with OpenCV</a></li>
<li><a href="../358232/index.html">Support for HTTP / 2 Server Push technology in Node.js</a></li>
<li><a href="../358234/index.html">"Calendar tester" for May. Load service</a></li>
<li><a href="../358236/index.html">DevOps Moscow meetup: Monitoring</a></li>
<li><a href="../358242/index.html">AI.Hack St. Petersburg</a></li>
<li><a href="../358244/index.html">Playing Cap: how to put the cashier on the cashier's table</a></li>
<li><a href="../358246/index.html">Material Design 2.0 and Android P</a></li>
<li><a href="../358248/index.html">‚ÄúWe are starting! I said: let's start! ‚Äù, Or how we implemented the work with faststart-video for Android</a></li>
<li><a href="../358250/index.html">UI components on pixel shaders: write your first shader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>