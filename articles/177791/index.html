<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A radical approach to application development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: In 2007, in search of a web engine, I came across a very interesting and unusual lisp dialect. And after reading a few articles, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A radical approach to application development</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  From the translator: In 2007, in search of a web engine, I came across a very interesting and unusual lisp dialect.  And after reading a few articles, I was fascinated by its principles.  Since my main job is far from web programming, I do not use it professionally, but from time to time I return to it and gradually become ‚Äústormy‚Äù. <br><br>  For all the time familiar with this language, he almost never flashes, and in Russian there is almost no information about him.  Let's try to fill this gap.  Despite the fact that the <a href="http://software-lab.de/radical.pdf">original article</a> dates from the 2006th year, the topic is quite relevant. <br>  Many thanks for the help in translating Nadezhda Zakharova and the wonderful site <a href="http://notabenoid.com/book/39472">Notabenoid</a> . <br></blockquote><br><a name="habracut"></a><br><h2>  1. Introduction </h2><br>  I work as a consultant and developer of free software.  For twenty years, I and my partners have been working on projects such as image processing, computer-aided design, modeling, and various financial and business applications. <br><br>  For almost all of these projects, we used Lisp.  My daily work is to listen to customer requests, analyze business processes and develop software according to their needs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually, in business applications such as ERP or CRM, this is a process of constant change.  At the beginning of a new project, neither the developer nor the customer knows exactly what is needed, or what the final product should look like. <br><br>  This comes during an iterative process (some call it ‚Äúextreme programming‚Äù).  The client evaluates each new version, then strategies for further development of the program are discussed.  Often, unforeseen requirements force rewriting large parts of the project.  This does not mean that the project was poorly planned, because the process I describe is planning.  In an ideal world, software development is just planning, the time spent directly writing code should tend to zero. <br><br>  We need a programming language that allows us to express directly what we want the program to do.  We believe that the code should be as simple as possible, so that any programmer at any time can understand what is happening in the program. <br><br>  Over the years, the <a href="http://www.software-lab.de/down.html">Pico Lisp</a> system has evolved from a minimalist Lisp implementation to a specialized application server.  Please note, we are not talking about the tool for rapid prototyping.  At each stage of development, the result is a fully functional program, and not a prototype, which grows to the serial (possibly the latest) version.  On the contrary, it can be called a powerful tool of a professional programmer who is used to keeping his development environment in order and wants to express the logic of his application and data structure in a concise presentation. <br><br>  First we want to introduce you to Pico Lisp, explain why Pico at a low level is significantly different from other Lisp or development systems, and then show its advantages at higher levels. <br><br><h2>  2. Radical approach </h2><br>  Perhaps the community (Common-) Lisp will not be delighted with Pico Lisp, because it destroys some of the beliefs and dogmas that have become traditional.  Some of them are just myths, but they can cause excessive complexity, slowness of Lisp.  Practical experience with Pico Lisp proves that lightweight and fast Lisp is optimal for many types of efficient application development. <br><br><h3>  2.1.  Myth 1: Lisp needs compiler </h3><br>  In fact, this is the most important myth.  If you participated in Lisp group discussions, then you know that the compiler plays a major role.  It may appear that this is almost a synonym for the execution environment.  It is important for people what actions the compiler performs with the code and how effective it is.  If it seems to you that a Lisp program is slowly running, then you decide that you need a better compiler. <br><br>  The idea of ‚Äã‚Äãan interpreted Lisp is regarded as an old misconception.  Modern Lisp requires a compiler, and the interpreter is only a useful addition, and is needed for interactive debugging of the application.  It is too slow and bloated to execute programs that are already at the stage of readiness for release. <br><br>  We are sure that the opposite point of view is correct.  On the one hand (and not only from a philosophical point of view), a compiled Lisp program is no longer Lisp at all.  This violates the fundamental rule of "formal equivalence of code and data."  The resulting code does not contain S-expressions and cannot be processed by Lisp.  The source language (Lisp) is converted to another language (machine code) with inevitable incompatibilities on different machines. <br><br>  In practice, the compiler complicates the system as a whole.  Features such as multiple-linking strategies, typed variables, and macros have been developed to meet the needs of compilers.  The system is bloated because it must also support the interpreter, and accordingly, two different architectures. <br><br>  But is it worth the effort?  Of course, the execution speed is higher, and compiler creation is interesting for learning purposes.  But we argue that in everyday life a well-designed ‚Äúinterpreter‚Äù can often surpass the compiled system. <br><br>  You understand that in reality we are not talking about ‚Äúinterpretation‚Äù.  The Lisp system immediately converts the data passed to it into internal pointer structures called S-expressions.  True ‚Äúinterpretation‚Äù works with one-dimensional character codes, and this significantly slows down the execution process.  Lisp, on the other hand, ‚Äúcomputes‚Äù S-expressions by quickly following these pointer structures.  There are no searches, so nothing is really "interpreted."  But we will stick to this familiar term. <br><br>  A Lisp program as an S-expression forms a tree of executable nodes.  The code of these nodes is usually written in an optimized C or assembler, so the task of the interpreter is to transfer control from one node to another.  Because many of these built-in Lisp functions are very powerful and do a lot of computation, most of the execution time is on nodes.  The tree itself functions as a kind of glue. <br><br>  The Lisp compiler removes some of this glue and replaces some nodes with primitive or streaming functionality directly into machine code.  But, since in any case most of the execution time comes from built-in functions, these improvements are not as dramatic as, for example, the Java bytecode compiler, for which each node (bytecode) has relatively primitive functionality. <br><br>  Of course, compilation itself also takes quite a lot of time.  The application server often executes Lisp source files on the fly in one run and immediately discards the code as soon as it runs.  In such cases, either the initially slower compiler-based Lisp interpreter or the extra time spent by the compiler will significantly reduce overall performance. <br><br>  Pico Lisp's internal structures were originally designed for ease of interpretation.  Although they were completely written in C, and were not specifically optimized for speed of execution, there was never a problem of insufficient performance.  The first commercial system written in Pico Lisp was a system for processing and retouching images, as well as for creating page layouts for printing.  It was created in 1988 and was used on Mac II with a 12 MHz CPU and 8 MB RAM. <br><br>  Of course, there was no Lisp compiler, there were only low-level pixel manipulations and bezier functions written in C. Even then, when working on a computer that was hundreds of times slower than modern ones, no one complained about performance. <br><br>  For the sake of interest, I installed CLisp and compared it with Pico Lisp using simple tests as an example.  Of course, this does not mean that the test results show the usefulness of a particular system as an application server, but they give a rough idea of ‚Äã‚Äãthe performance of these systems.  At first, I tried to perform a simple recursive Fibonacci function. <br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> fibo (<span class="hljs-name"><span class="hljs-name">N</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> N <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> (<span class="hljs-name"><span class="hljs-name">fibo</span></span> (<span class="hljs-name"><span class="hljs-name">-</span></span> N <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">fibo</span></span> (<span class="hljs-name"><span class="hljs-name">-</span></span> N <span class="hljs-number"><span class="hljs-number">2</span></span>)) ) ) )</code> </pre> <br>  When I called this function with parameter 30 (fibo 30), I got the following results (testing was done on a Pentium-I 266 MHz laptop): <br><br><table><tbody><tr><td>  Pico (interpretation) </td><td>  12 seconds </td></tr><tr><td>  CLisp interpretation </td><td>  37 seconds </td></tr><tr><td>  CLisp compiled </td><td>  7 seconds </td></tr></tbody></table><br>  The CLisp interpreter is almost three times slower, and the compiler is almost twice as fast as Pico Lisp. <br><br>  However, the Fibonacci function is not a good example of a typical Lisp program.  It consists only of a primitive flow and arithmetic functions, which is easily optimized by the compiler and can be written directly in C if this is critical in time (in this case, the execution would take only 0.2 s) <br><br>  Therefore, I took another extreme case, with a function that performs extensive list processing: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> tst () (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> X) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">delete</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> X) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> X))))) '((abcabc) (bcdbcd) (cdecde) (defdef)) ) )</code> </pre><br>  Calling this function 1 million times, I received: <br><br><table><tbody><tr><td>  Pico (interpretation) </td><td>  31 seconds </td></tr><tr><td>  CLisp interpretation </td><td>  196 seconds </td></tr><tr><td>  CLisp compiled </td><td>  80 seconds </td></tr></tbody></table><br>  Now the CLisp interpreter is more than 6 times slower, but to my surprise even the compiled code is 2.58 times slower than Pico Lisp. <br><br>  Maybe CLisp has a slow compiler?  And maybe the code can be sped up with some tricks.  But these results still leave many doubts as to whether the overhead of compilation can be justified.  To mess around with compiler optimization is the last thing I want to do when it comes to application logic, and when the user still doesn't notice the delays. <br><br><h3>  2.2.  Myth 2: Lisp Requires Many Data Types </h3><br>  The Fibonacci function described in the example above can be accelerated by declaring the variable N as an integer.  But then this example will show how strongly the requirements of compiler support affect Lisp.  The compiler can produce more efficient code if the data types are hard coded.  Common Lisp supports many different data types, including various integer types, fixed / floating point types, fractional numbers, characters, strings, structures, hash tables, and vector types in addition to lists. <br><br>  On the other hand, Pico Lisp supports only three built-in data types ‚Äî numbers, symbols, and lists ‚Äî and it is quite fine for these types of data.  A Lisp system runs faster with fewer data types, because fewer options need to be checked at runtime.  Perhaps this will entail a less efficient use of memory, but a smaller number of types allows you to save space due to the fact that less bits are required for tags. <br><br>  The main reason for using all three types of data is simplicity, and the advantage in simplicity outweighs the benefit of speed and memory compensation. <br><br>  In fact, Pico Lisp at the lowest level uses only one type of data, cells that are used to form numbers, symbols, and lists.  A small number or minimum character occupy only one memory cell, dynamically increasing if necessary.  This memory model allows for efficient garbage collection and completely avoids fragmentation (as it would, for example, with vectors). <br><br>  At the highest level, you can always emulate other data types using these three primitive data types.  So, we emulate trees using lists, strings, classes, and objects using symbols.  While there are no performance problems, why complicate things? <br><br><h3>  2.3.  Myth 3: Dynamic binding is bad </h3><br>  Pico Lisp uses a simple implementation of dynamic surface binding.  The contents of the cell storing the value of the character are saved when entering a lambda expression or binding environment, and then a new value is set.  When returned, the original value is restored.  As a result, the current value of a symbol is determined dynamically by history and execution state, and not by static checks of the lexical environment. <br><br>  Perhaps for the interpreted system this is the simplest and fastest strategy.  To look at the cell value, no searches are required (only access to the cell value is required) and all characters (local or global) are treated the same.  On the other hand, the compiler can produce more efficient code for lexical binding, thus compiled Lisp code usually complicates everything because of the support of several types of binding strategies. <br><br>  Dynamic binding is a very powerful mechanism.  You can access the current value from any place, the variable itself and its value are always physically existing ‚Äúreal things‚Äù, and not what ‚Äúseem‚Äù (as is the case with lexical binding, and to some extent using transit characters in Pico Lisp (see below)). <br><br>  Unfortunately, big opportunities are impossible without big risks.  The programmer must be familiar with the basic principles in order to use their advantages and avoid traps.  However, as long as we adhere to the agreements recommended by Pico Lisp, the risks will be minimal. <br><br>  There are two types of situations where the results of calculations using dynamic linking can get out of the programmer‚Äôs control: <br><ol><li>  the symbol is associated with itself, and we are trying to change the meaning of the symbol; </li><li>  the problem of funarg (functional argument), when the value of a symbol is dynamically changed by a through code that is invisible in the environment of the current source code. </li></ol><br>  Such situations can be avoided by using transit characters. <br><br>  Transit characters are characters in Pico Lisp that look like strings (and are often used as strings) and that are only temporarily interned for the duration of the execution of one file with the source code (or only parts of it).  Thus, they have lexical capabilities comparable to static identifiers in C programs, only their behavior is completely dynamic, because they are normal characters in all other respects. <br><br>  So the rules are simple: whenever a function has to change the value of a variable passed to it or calculate the result of a passed Lisp expression (directly or indirectly), the parameters of this function should be written using transit characters.  Practical experience shows that such cases are rare in high-level software development processes and occur mainly in auxiliary libraries and system tools. <br><br><h3>  2.4.  Myth 4: Property Lists Is Bad </h3><br>  Properties is an elegant, clear way to associate information with symbols in addition to the value / function cell.  They are extremely flexible, since the number and type of data are not statically fixed. <br><br>  It seems that many think that property lists are too outdated and primitive to use them in our time.  Instead, more advanced data structures should be used.  Although this is true in some cases, depending on the total number of properties in a symbol, the payback threshold may be higher than expected. <br><br>  Previous versions of Pico Lisp have experimented with hash tables and self-balancing binary trees to store properties, but we have found that regular lists are more efficient.  We must take into account the cumulative effect of the entire system, and the overhead of both supporting a large number of internal data structures (see above) and more complex search algorithms is often greater than using simple linear search.  And when we also touch upon the issue of memory efficiency, the benefits of property lists definitely benefit. <br><br>  Pico Lisp implements properties in the form of a list of key-value pairs.  The only concession in favor of speed optimization is the ‚Äúmost recently used‚Äù scheme, which slightly accelerates repeated access, but we have no concrete signs that this was actually necessary. <br>  Another argument against properties is their declared global visibility.  This is as true as the fact that a global element in a C-structure or an instance variable in a Java object is global. <br><br>  Of course, in a global symbol, a property is also global, but in typical application development, properties are stored in anonymous characters, objects, or database elements that are available only in a well-defined context.  Therefore, the ‚Äúcolor‚Äù property can be used in a certain sense in one context, and in a completely different sense in another context, without any mutual interference. <br><br><h2>  3. Application Server </h2><br>  Based on this simple Pico Lisp machine, we have developed a vertically structured application server.  It unifies the database engine (based on the PicoLisp implementation of stored (persistent) objects as a first-class data type) and an abstract graphical interface (generating, for example, HTML or Java applets). <br><br>  A key element in this unified system is a Lisp-based markup language that is used to implement individual application modules. <br><br>  Whenever the application server requests a new view from the database, a document or report, or some other service, the Lisp source code file is loaded and executed on the fly.  This is similar to a URL request and then sent the HTML file in a traditional web server. <br><br>  However, Lisp expressions computed in such a scenario usually have the side effect of building and processing an interactive user interface. <br><br>  These Lisp expressions describe the structure of GUI components, their behavior in response to user actions and their interaction with database objects.  In short, they contain a complete description of the software module.  To make this possible, we found that it is important to adhere strictly to the Local Principle, and use the ‚ÄúPrefix Classes‚Äù and ‚ÄúCommunication Support Daemons‚Äù mechanisms (the latter two are described in <a href="http://www.software-lab.de/dbui.html">another document</a> ). <br><br><h3>  3.1.  The principle of Locality </h3><br>  As we said, business application development is a process of constant change.  The principle of Locality proved to be a great help in the development of such projects.  This principle requires that all information relating to one module should be stored with this module in one place.  This allows the programmer to focus only on one place where all this is stored. <br><br>  Of course, all this seems quite obvious, but in contrast, software development methodologies prescribe to encapsulate behavior and data and hide it from the rest of the application.  Usually, this leads to the fact that the application logic is written in one place (the source file), but the functions, classes and methods for implementing this logic are defined elsewhere.  Of course, this is a good recommendation, but it brings many problems, manifested in the need to constantly move to different storage locations: modifications and context switching occur simultaneously in several places.  If a function is outdated, some modules may also become outdated, but we forget to delete them. <br><br>  Thus, we believe that it is optimal to create an abstract library of functions, classes and methods - as universal as possible, constant in time and various applications, and used to build a strict markup language, which has a high degree of expressiveness for creating applications. <br><br>  This language must have a compact syntax and allow to describe all the static and dynamic aspects of the application.  Locally, in one place.  No need to define behavior in separate files. <br><br><h3>  3.2.  Lisp </h3><br>  And this is the very main reason why we stated from the very beginning that Lisp is the only language that suits us. <br><br>  Only Lisp allows you to process code and data in the same way, and this is the basis of the Pico Lisp application development model.  It allows you to intensively use functional blocks and calculated expressions that are freely mixed with static data and which can be both transmitted somewhere and stored in internal data structures at run time. <br><br>  As far as we know, in other languages ‚Äã‚Äãthis is impossible, at least with the same simplicity and elegance.  To some extent, this can be done with the help of scripting languages, using interpreted lines of text, but this solution will be rather limited and awkward.  And, as we described above, systems on a compiled Lisp can be too heavy and inflexible.  In order for all these data structures and code fragments to work smoothly, the dynamic surface referencing strategy is a great advantage, since expressions can be calculated without the need for binding the environment settings. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another reason is that Lisp allows you to directly manipulate complex data structures, such as characters and nested lists, without the need for explicitly declaring, allocating, initializing, or freeing these structures from memory. This contributes to the compactness and readability of the code and gives the programmer a powerful expression tool that allows you to do different things on the same line where other languages ‚Äã‚Äãrequire writing a separate module. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, since Pico Lisp does not make a formal distinction between database objects and internal characters, all of these advantages also apply to working with a database, leading to direct connection of operations with GUI and DB in one local context using identical code.</font></font><br><br><h2>  4. Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Lisp community seems to suffer from the paranoia of "inefficient" Lisp. This is probably due to the fact that for decades they have been forced to defend their language from the claims that "Lisp is slow" and "Lisp is bloated." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This was partly true. But on today's hardware, execution speed does not matter for many practical applications. And in those cases where it has, coding several critical functions in C usually solves this problem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's focus on more practical aspects. </font><font style="vertical-align: inherit;">Some may be surprised at how compact and fast a supposedly ancient Lisp system can be. </font><font style="vertical-align: inherit;">Thus, we must be careful not to make Lisp really ‚Äúbloated‚Äù, overloading the core of the language with more and more possibilities, but rather decide to use simple solutions that give complete flexibility to the programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pico Lisp can be seen as proof of the concept ‚ÄúLess can be more.‚Äù</font></font></div><p>Source: <a href="https://habr.com/ru/post/177791/">https://habr.com/ru/post/177791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177775/index.html">Package Manager for Xcode</a></li>
<li><a href="../177779/index.html">Apple reported on the results of the previous quarter</a></li>
<li><a href="../177781/index.html">Where is the market of electronic payment systems in Russia? Part 2. Plastic cards</a></li>
<li><a href="../177785/index.html">Fidonet's arrival on Android</a></li>
<li><a href="../177789/index.html">Impressions after prolonged use of Microsoft Surface RT</a></li>
<li><a href="../177793/index.html">Capture video from the camera and transmit it over the network</a></li>
<li><a href="../177795/index.html">Convenient library for working with media tags</a></li>
<li><a href="../177797/index.html">Organization of storage of intermediate tables for the CART algorithm</a></li>
<li><a href="../177799/index.html">I want to write tests</a></li>
<li><a href="../177801/index.html">Yandex.Maps-Time.Lapse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>