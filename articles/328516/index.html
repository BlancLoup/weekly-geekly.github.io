<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using NES-game research tools on the example of parsing the Felix The Cat compression format</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will explain how to use the tools described in the previous article for researching the Felix The Cat for NES game . My initial goal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using NES-game research tools on the example of parsing the Felix The Cat compression format</h1><div class="post__text post__text-html js-mediator-article">  In this article I will explain how to use the tools described in the previous <a href="https://habrahabr.ru/post/317796/">article</a> for researching the <i><b>Felix The Cat</b></i> for <b>NES game</b> .  My initial goal was, as usual, to parse the format of the levels of the game and add it to my universal level editor <a href="https://github.com/spiiin/CadEditor">CadEditor</a> , but during the study of the game it was found that the description of the levels is compressed (this is rare for NES games!), So I also took apart the format of data compression , and wrote a compressor that allows you to compress the edited levels in the same way as the game developers did. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ba9/63b/945/ba963b945f0f4bb9a56ee5ef207de846.png"></div><br><a name="habracut"></a><br><h3>  Block Search </h3><br>  First we check which blocks are used in the game.  To do this, you can use the utility of automatic search for <a href="https://github.com/spiiin/NesBlockFinder">NesBlockFinder</a> blocks.  All that needs to be done is to feed her with a dump of video memory of the loaded level ( <a href="http://spiiin.github.io/CadEditor/tutorial-tmnt2.html">detailed instructions</a> on how to do this, I will not dwell on the article in more detail, in order to quickly get to the main topic - parsing compression).  <b>NesBlockFinder</b> produces the following results: <br><br><img src="https://habrastorage.org/web/169/701/d74/169701d74e3446aebb5916ddd4e39a67.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you can see, the program found blocks of 2x2 in size in the ROM file, described by 4 separate arrays of 128 bytes <b>each</b> , and suggested the address of the beginning of the first array <b>0x17D2D</b> . <br><br>  Now you can change the bytes that make up one of the blocks entirely in the emulator to make sure that the blocks on the screen change: <br><br><img src="https://habrastorage.org/web/b6d/720/b57/b6d720b57e694745aa02dba04afcefb2.png"><br><br>  It can be clearly seen that the green block inside the bushes has changed. <br><br>  The next step is to mark the beginning and end of the block description arrays.  To do this, you can simply change the bytes before the detected block, and also take into account the fact that in most games the first block consists of only zeros (there is no special reason for this, but this is found in almost all games).  This is how the address of the beginning of the block description arrays is <b>detected</b> - <b>0x17D2A</b> (and, respectively, the addresses <b>0x17DAA, 0x17E2A, 0x17EAA</b> for arrays of the next quarters of blocks).  The end of the array is also easily calculated - the size of each of the parts is known (128 bytes), so the end of the last array will be located at address <b>0x17F2A</b> . <br><br>  The graphics on the NES are designed in such a way that, in addition to describing block numbers, developers need to store block attributes (color indexes of the palette), so you should always carefully study the data before the block array and immediately after it - most often block attributes will be described there.  This is also true for our <i><b>Felix The Cat</b></i> , behind an array of block descriptions lies an array of 128 bytes, in which for each block its attributes of the palette are indicated (in the upper two bits) and physical properties (in the lower six bits).  This is shown in the screenshot: <br><br><img src="https://habrastorage.org/web/2c7/b31/322/2c7b31322ccb42d18c9cee367fec0c84.png"><br><br>  On it the area of ‚Äã‚Äãattributes is highlighted and the high bits are changed in order to change the color of the test block. <br><br>  Using the obtained addresses, you can take a dump of video memory and a palette (for details, how to do this in the <a href="http://spiiin.github.io/CadEditor/tutorial-powerblade2.html">article</a> , section ‚ÄúStep 6. Finding the address of a video memory bank and level palette‚Äù) to build all the blocks used in the level. <br><br><h3>  Render blocks </h3><br>  To draw all the blocks, I used <b>Python</b> and <a href="http://jupyter.org/">Jupyter</a> laptops, as well as <b>C #</b> modules for building NES graphics from the <b>CadEditor</b> editor (for Python and C # gluing, I took the <a href="https://pypi.python.org/pypi/clr">clr</a> module, which allows you to load .NET assemblies from Python and call code from them). <br><br>  The basic block building code looks simple: <br><br><blockquote>  <font color="#808080"># CadEditor function for loading config files from file</font> <br>  Globals.  <font>loadData</font> <font>(</font> romName <font color="#66cc66">,</font> dumpName <font color="#66cc66">,</font> configName <font>)</font> <br><br>  <font color="#808080"># Create an instance of the plugin for drawing NES graphics</font> <br>  video <font color="#66cc66">=</font> Video <font>(</font> <font>)</font> <br><br>  <font color="#808080">#clr does not understand overloaded functions, so we explicitly set the prototype of the function we want to call</font> <br>  <font color="#808080">#Bitmap [] makeObjects (byte videoPageId, byte tilesId, byte palId, float scale, MapViewType drawType, int constantSubpal = -1);</font> <br>  makeObjects <font color="#66cc66">=</font> video.  <font>makeObjects</font> .  <font>Overloads</font> <font>[</font> System.  <font>Byte</font> <font color="#66cc66">,</font> System.  <font>Byte</font> <font color="#66cc66">,</font> System.  <font>Byte</font> <font color="#66cc66">,</font> System.  <font>Single</font> <font color="#66cc66">,</font> MapViewType <font color="#66cc66">,</font> System.  <font>Int32</font> <font>]</font> <br>  bb <font color="#66cc66">=</font> makeObjects <font>(</font> <font color="#ff4500">0x90</font> <font color="#66cc66">,</font> <font color="#ff4500">0</font> <font color="#66cc66">,</font> <font color="#ff4500">0</font> <font color="#66cc66">,</font> <font color="#ff4500">2.0</font> <font color="#66cc66">,</font> MapViewType. <font>Tiles</font> <font color="#66cc66">,</font> - <font color="#ff4500">1</font> <font>)</font> <br><br>  <font color="#808080"># Some magic for converting Python arrays into a C # array</font> <br>  blocks <font color="#66cc66">=</font> System.  <font>Array</font> <font>[</font> System.  <font>Drawing</font> .  <font>Image</font> <font>]</font> <font>(</font> bb <font>)</font> <br>  fn <font color="#66cc66">=</font> picPath + <font color="#483d8b">"blocks0.png"</font> <br>  <font color="#808080"># Gluing blocks into rectangular image</font> <br>  Utilsgdi.  <font>GlueImages</font> <font>(</font> blocks <font color="#66cc66">,</font> <font color="#ff4500">16</font> <font color="#66cc66">,</font> <font color="#ff4500">8</font> <font>)</font> .  <font>Save</font> <font>(</font> fn <font>)</font> <br>  <font color="#808080"># IPython function to display the saved image in a laptop</font> <br>  display <font>(</font> Image <font>(</font> filename <font color="#66cc66">=</font> fn <font>)</font> <font>)</font> </blockquote><br>  We get the following result: <br><br><img src="https://habrastorage.org/web/39d/f88/aff/39df88aff18f43eab88871ab2f283f28.png"><br><br>  ‚Üí <a href="https://github.com/spiiin/JupyterCadEditor/blob/master/CadEditor-Felix-render.ipynb">Commented laptop</a> <br><br><h3>  Level Description Format </h3><br>  Now that we have blocks, we need to find out how the level is going from them.  To do this, use the <a href="">NesAutoCorrupter</a> script.  On working with the old version of the script, I wrote a whole <a href="https://habrahabr.ru/post/259483/">article on Habr√©</a> , since then I have significantly improved it (now it works ten times faster and requires only two saves of the game, without the need for manual calculations), but detailed documentation on the new version has not yet prepared, therefore, I will limit myself to a brief description of working with him. <br><br>  You need to run the <i><b>autocorrupter4.lua</b></i> script in the <b>FCEUX</b> emulator, prepare 2 save files (just before loading the level and immediately after loading) and just press the "E" key to get started.  The script gets all the necessary data from these files and alternately changes each byte that was used between the two saves, and then checks if the image on the screen has changed.  The modified version of the script saves to files in the name of which the address of the modified byte is indicated. <br><br>  Consider the result of the script for <i><b>Felix The Cat</b></i> .  Pictures of change bytes with addresses <b>0x1B940, 0x1B942, 0x1B944</b> , etc. with step 2, I have collected for clarity in a gif-picture: <br><br><img src="https://habrastorage.org/web/a8e/49b/fa9/a8e49bfa93f941608eae27b94258add9.gif"><br><br>  It implies that the level is described by vertical lines, and a step of 2 bytes indicates that not just indices go to these addresses, but addresses (pointers) on the line. <br><br>  Also of interest is the address <b>0x1A904</b> , the change of which leads to the change of exactly one block in the second line, therefore, this is the area of ‚Äã‚Äãthe array description of the lines themselves: <br><br><img src="https://habrastorage.org/web/3b2/052/ee7/3b2052ee71a7499b9f696e06f4b04ce2.png"><br><br>  Now, poking at the bytes in the vicinity of these addresses and analyzing the result, we come to such interesting conclusions about the structure of the level: <br><br><ol><li>  At the address <b>0x1B940 there</b> is a large array of pointers on the line, from which all three starting levels are built (1-1, 1-2, 1-3).  Using pointers rather than indexes allows you to describe more than 256 lines (namely, 256x3 = <b>768 lines</b> ).  To move from the pointer (pointer in the address space of the NES CPU) to the absolute address in the ROM, you must add the address of the beginning of the bank in which it lies ( <b>0x10010</b> for the first level, other levels use other banks) to the pointer. </li><li>  Pointer to the first column = <b>0xA8ED</b> , translated to the absolute address - <b>0x1A8FD</b> , from this address and further the description of the lines goes, the height of each line is <b>24 bytes</b> (this is a constant for all levels of the game). </li><li>  Examine the description of one of the lines and note that if the block number in it is from <b>0x00</b> to <b>0x80</b> , then the block with the corresponding number is inserted directly into the final line;  if the number is greater than 0x80, then a whole strip of a different number of any blocks is inserted.  An interesting conclusion follows from this - the game uses RLE compression to describe chains of consecutive identical blocks, and these chains are assembled into a dictionary and are encoded with indices in this dictionary! </li><li>  Address of the RLE dictionary for the first level: <b>0x1B799</b> .  At this address recorded a pair of bytes (the <i><b>number of duplicate blocks, the number of block-repeat</b></i> ). </li></ol><br>  For example, consider the first line decompression. <br>  Compressed line description: <br><pre>  [81 30 82 07 4C 83] </pre>  And the dictionary: <br><pre>  [(24, 0x0) (17, 0x0) (2, 0x3) (2, 0x78)] </pre>  The first byte <b>81</b> encodes the first value from the dictionary ‚Äútake <b>17</b> times block <b>0</b> ‚Äù, followed by block <b>30</b> , then byte <b>82</b> , which means taking the second value from the dictionary - ‚Äútake <b>2</b> times block <b>3</b> ‚Äù, followed by blocks <b>07</b> and <b>4C</b> , and Finally, the value <b>83</b> is the third word from the dictionary ‚Äútake block <b>78</b> <b>2</b> times‚Äù.  The output line is: <br><pre>  [00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 30 03 03 07 4C 78 78] </pre>  Here is a visual explanation of this decompressed line: <br><br><img src="https://habrastorage.org/web/6f3/b9e/580/6f3b9e5805604fc9b98e99e144a361ce.png"><br><br>  Thus, you can already write the decompression of all lines: <br><br><blockquote>  <font color="#ff7700">def</font> decompressLine <font>(</font> d <font color="#66cc66">,</font> addr <font color="#66cc66">,</font> LINE_HEIGHT <font color="#66cc66">=</font> <font color="#ff4500">24</font> <font>)</font> : <br>  ans <font color="#66cc66">=</font> <font>[</font> <font>]</font> <br>  <font color="#ff7700">while</font> <font color="#008000">len</font> <font>(</font> ans <font>)</font> <font color="#66cc66">&lt;</font> LINE_HEIGHT: <br>  v <font color="#66cc66">=</font> d <font>[</font> addr <font>]</font> <br>  <font color="#808080"># regular tile</font> <br>  <font color="#ff7700">if</font> v <font color="#66cc66">&lt;</font> <font color="#ff4500">0x80</font> : <br>  ans.  <font>append</font> <font>(</font> v <font>)</font> <br>  <font color="#808080"># value from RLE dictionary</font> <br>  <font color="#ff7700">else</font> : <br>  cv <font color="#66cc66">=</font> v &amp; <font color="#ff4500">0x7F</font> <br>  repeatCount <font color="#66cc66">,</font> repeatTile <font color="#66cc66">=</font> compressedArr <font>[</font> cv <font>]</font> <br>  ans.  <font>extend</font> <font>(</font> <font>[</font> repeatTile <font>]</font> * repeatCount <font>)</font> <br>  addr + <font color="#66cc66">=</font> <font color="#ff4500">1</font> <br>  <font color="#ff7700">return</font> ans </blockquote><br>  And display them in the <b>CadEditor</b> level <b>editor</b> : <br><br><img src="https://habrastorage.org/web/6cb/69b/ceb/6cb69bceb1a54915827c35ef9bd9fa59.png"><br><br><h3>  Compressor </h3><br>  We were able to unpack the level and edit it, but to insert it back into the game, we also need an inverse algorithm that will compress the data, and it will do it no worse than the compressor from the developers, otherwise they will not fit in the allotted space.  You can, of course, modify pointers for data in order to place them in a separate bank and not use compression at all, but this is not always possible, and competition for compression quality with game developers is too interesting a task to pass by - if for decrypting the decompressor, you can use a ready-made dictionary obtained in an unknown way, then for the compressor it is necessary to learn how to make the compression dictionary yourself. <br><br>  The first idea of ‚Äã‚Äãcompiling a dictionary that came to my mind was simply <b><i>to write down a list of all the RLE chains found</i></b> and <b><i>sort it by replacement value</i></b> .  The replacement value is quite simple to calculate: it is necessary to calculate how many bytes will be saved on one replacement (chain length minus 1 byte) and multiplied by the number of possible replacements. <br><br>  Such an algorithm gave a result of <b>3879</b> bytes versus <b>3740</b> bytes in the original (~ 2% loss).  It seemed to me not enough, and I began to think about how the developers got better. <br><br>  The second idea was, after each replacement of the most advantageous chain, <b><i>immediately insert a word from the dictionary in its place</i></b> .  The result was <b>4695</b> bytes, much worse than it was.  I realized that it is impossible to replace the chain until the dictionary is completely filled - perhaps in the future there will be a more profitable replacement in the specific case (but less valuable from the point of view of the entire archive). <br><br>  Thus, it is necessary to cross both algorithms - keep a full dictionary in memory, but in a real replacement, update the value of all other replacements and re-sort it by the updated value (if we replaced, for example, a string of 16 zeros with a word in the dictionary, then all shorter chains of zeros will now occur 1 time less). <br><br>  However, such an implementation seemed to me too complex and instead I simply made the algorithm iterative ‚Äî at every step a complete possible dictionary is compiled, and then the data is compressed with notes, which word was <b>actually</b> used many times.  After this, the dictionary is sorted by real, not perceived value, and a forbidden dictionary is made from it from words that have never been used (or their use has brought the least value).  Then the cycle repeats, but so that words from the forbidden dictionary no longer fall into the potential dictionary.  The improvement operation can be repeated until the forbidden dictionary is no longer replenished.  Then it remains only to take from the real dictionary the maximum allowable number of values ‚Äã‚Äã(128 words) - this will be the best dictionary for compression.  Thus, finally, it turned out to ‚Äúcatch up‚Äù with the developers, and get the same <b>3740</b> compressed data as they have.  The situation repeated with the other levels - the results of the compressed data completely coincided with the original ones, although my dictionary was somewhat different. <br><br>  The final dictionary building function (somewhat confusing because I experimented with different parameters and dynamic replacement value).  The <b>forbidden</b> values ‚Äã‚Äãdictionary is passed to the <b>forbiddenArr</b> parameter. <br><br><blockquote>  <font color="#ff7700">def</font> rebuildCompress <font>(</font> screen <font color="#66cc66">,</font> forbiddenArr <font color="#66cc66">,</font> maxCompressSize <font color="#66cc66">=</font> <font color="#ff4500">256</font> <font color="#66cc66">,</font> LINE_LEN <font color="#66cc66">=</font> <font color="#ff4500">24</font> <font>)</font> : <br>  fullAns <font color="#66cc66">=</font> <font>[</font> <font>(</font> <font color="#ff4500">0</font> <font color="#66cc66">,</font> <font color="#ff4500">0</font> <font>)</font> <font>]</font> * maxCompressSize <br>  lines <font color="#66cc66">=</font> <font color="#008000">list</font> <font>(</font> chunks <font>(</font> screen <font color="#66cc66">,</font> LINE_LEN <font>)</font> <font>)</font> <br>  x <font color="#66cc66">=</font> <font color="#ff4500">0</font> <br>  <font color="#ff7700">while</font> x <font color="#66cc66">&lt;</font> maxCompressSize: <br>  ans <font color="#66cc66">=</font> <font>{</font> <font>}</font> <br>  <font color="#ff7700">for</font> line <font color="#ff7700">in</font> lines: <br>  repeats <font color="#66cc66">=</font> <font>[</font> <font color="#008000">list</font> <font>(</font> g <font>)</font> <font color="#ff7700">for</font> _ <font color="#66cc66">,</font> g <font color="#ff7700">in</font> groupby <font>(</font> line <font>)</font> <font>]</font> <br>  repeats <font color="#66cc66">=</font> <font>[</font> <font>(</font> g <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font color="#66cc66">,</font> <font color="#008000">len</font> <font>(</font> g <font>)</font> <font>)</font> <font color="#ff7700">for</font> g <font color="#ff7700">in</font> repeats <font>]</font> <br>  <font color="#ff7700">for</font> <font>(</font> tileNo <font color="#66cc66">,</font> tileCount <font>)</font> <font color="#ff7700">in</font> repeats: <br>  <font color="#808080">#for tc in xrange (tileCount, tileCount + 1):</font> <br>  <font color="#ff7700">for</font> tc <font color="#ff7700">in</font> <font color="#008000">xrange</font> <font>(</font> <font color="#ff4500">2</font> <font color="#66cc66">,</font> tileCount + <font color="#ff4500">1</font> <font>)</font> : <br>  compressPair <font color="#66cc66">=</font> tileNo <font color="#66cc66">,</font> tc <br>  <font color="#ff7700">if</font> compressPair <font color="#ff7700">in</font> ans: <br>  ans <font>[</font> compressPair <font>]</font> + <font color="#66cc66">=</font> <font color="#ff4500">1</font> <br>  <font color="#ff7700">else</font> : <br>  ans <font>[</font> compressPair <font>]</font> <font color="#66cc66">=</font> <font color="#ff4500">1</font> <br>  <font color="#808080"># calculation of replacement value - chain length * frequency of occurrence</font> <br>  <font color="#ff7700">def</font> calcPoints <font>(</font> v <font>)</font> : <br>  <font>(</font> t <font color="#66cc66">,</font> c <font>)</font> <font color="#66cc66">,</font> cnt <font color="#66cc66">=</font> v <br>  <font color="#ff7700">return</font> - <font>(</font> c- <font color="#ff4500">1</font> <font>)</font> * cnt <br><br>  ans <font color="#66cc66">=</font> <font color="#008000">sorted</font> <font>(</font> ans. <font>iteritems</font> <font>(</font> <font>)</font> <font color="#66cc66">,</font> key <font color="#66cc66">=</font> calcPoints <font>)</font> <br>  <font color="#808080">#filter and reverse values</font> <br>  newAns <font color="#66cc66">=</font> <font>[</font> <font>]</font> <br>  <font color="#ff7700">for</font> a <font color="#ff7700">in</font> ans: <br>  <font color="#ff7700">if</font> <font>(</font> a <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>)</font> <font color="#66cc66">&lt;</font> <font color="#ff4500">0x80</font> : <br>  newAns.  <font>append</font> <font>(</font> <font>(</font> a <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>[</font> <font color="#ff4500">1</font> <font>]</font> <font color="#66cc66">,</font> a <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>)</font> <font>)</font> <br><br>  newAns <font color="#66cc66">=</font> <font color="#008000">filter</font> <font>(</font> <font color="#ff7700">lambda</font> v: v <font color="#ff7700">not</font> <font color="#ff7700">in</font> forbiddenArr <font color="#66cc66">,</font> newAns <font>)</font> <br>  <font color="#ff7700">if</font> <font color="#008000">len</font> <font>(</font> newAns <font>)</font> <font color="#66cc66">==</font> <font color="#ff4500">0</font> : <br>  <font color="#ff7700">break</font> <br><br>  <font color="#808080">#HINT !!!</font>  <font color="#808080">If you can use it all</font> <br>  ansValue <font color="#66cc66">=</font> newAns <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font>[</font> <font color="#ff4500">1</font> <font>]</font> <br>  <font color="#808080">#newAns = filter (lambda x: x [1] == ansValue, newAns) #comment this for best results!</font> <br>  <font color="#808080">#newAns = sorted (newAns, key = lambda x: -x [0])</font> <br>  <font color="#808080">#print newAns</font> <br>  similar <font color="#66cc66">,</font> maxSimilar <font color="#66cc66">=</font> <font color="#ff4500">0</font> <font color="#66cc66">,</font> <font color="#ff4500">256</font> <br>  <font color="#ff7700">while</font> <font color="#008000">len</font> <font>(</font> newAns <font>)</font> <font color="#66cc66">&gt;</font> <font color="#ff4500">0</font> <font color="#ff7700">and</font> x <font color="#66cc66">&lt;</font> maxCompressSize <font color="#ff7700">and</font> similar <font color="#66cc66">&lt;</font> maxSimilar: <br>  curAns <font color="#66cc66">=</font> newAns <font>[</font> <font color="#ff4500">0</font> <font>]</font> <br>  lines <font color="#66cc66">,</font> findAtLeastOneReplace <font color="#66cc66">=</font> compressorReplace <font>(</font> lines <font color="#66cc66">,</font> curAns <font color="#66cc66">,</font> x <font>)</font> <br>  fullAns <font>[</font> x <font>]</font> <font color="#66cc66">=</font> curAns <br>  x + <font color="#66cc66">=</font> <font color="#ff4500">1</font> <br>  similar + <font color="#66cc66">=</font> <font color="#ff4500">1</font> <br>  newAns <font color="#66cc66">=</font> newAns <font>[</font> <font color="#ff4500">1</font> : <font>]</font> <br>  <font color="#ff7700">return</font> fullAns </blockquote><br><h3>  Second type of compression </h3><br>  It is a little disappointing that after various experiments and improvements in the algorithm, I came across the optimal method that the developers used, but at least my compressor worked no worse than theirs.  For all levels except the second one, the clamping results turned out to be the same, but with the second one an interesting moment was revealed - the decompressor broke on it.  It turned out that the authors of the game for the level inside the pyramid (2-2 and 2-3), used to compress the mosaic on the walls of the pyramids an additional kind of compression, which is to use the " <b>baselines</b> ". <br><br>  The last 4 values ‚Äã‚Äãof the <b>0xFC-0xFF</b> blocks are used to encode special commands. <br>  In this case, a command of two bytes ( <i><b>baseline_number, number of blocks from the baseline</b></i> ) can be used at the beginning of the line.  The level uses 4 baselines (their numbers are encoded from <b>0xFC</b> to <b>0xFF</b> ).  The first few blocks are taken from this line, and then the bottom part is drawn in the usual way. <br><br>  An example of such lines began on the screenshot: <br><br><img src="https://habrastorage.org/web/acf/658/100/acf658100b954c6b80bccabf3db3f330.png"><br><br>  On it are highlighted with repeating base lines.  This compression method works on other levels, but the baselines are not described for them (common tops of the lines), so the developers did not use it, but it would save a few more bytes that do not give practical use, but symbolic in the mental competition with the game developers . <br><br>  <a href="https://github.com/spiiin/JupyterCadEditor/blob/master/CadEditor-Felix-decompress.ipynb">The final commented laptop</a> with decompression and compression tests for all levels, which can be used for direct data compression and insertion into a ROM file. <br><br>  Thus, the use of compression with the help of the RLE-dictionary, as well as the preservation of the indices of repeating lines, allow compressing descriptions of levels of 18 kilobytes (256 x 3 x 24 blocks) to 4-5 kilobytes. </div><p>Source: <a href="https://habr.com/ru/post/328516/">https://habr.com/ru/post/328516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328504/index.html">Interesting questions on knowledge of C # and .NET mechanisms</a></li>
<li><a href="../328506/index.html">Implementation of the minimization of logical functions by the method of Kvayna \ Mac Klasky</a></li>
<li><a href="../328508/index.html">A blood test: from a light microscope to hematology analyzers</a></li>
<li><a href="../328510/index.html">GameDev from scratch: How to get out of chaos and start working</a></li>
<li><a href="../328512/index.html">Turns the screen on Android without pain</a></li>
<li><a href="../328518/index.html">Preview Rambler.iOS # 9</a></li>
<li><a href="../328520/index.html">Zero-day vulnerabilities in Wordpress and Vanilla Forums allow you to hack sites remotely</a></li>
<li><a href="../328522/index.html">Where is the money on the road (an algorithm that allows one and a half times to reduce costs in a taxi)</a></li>
<li><a href="../328526/index.html">WebGL Application Performance</a></li>
<li><a href="../328528/index.html">How protocols are arranged in Elixir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>