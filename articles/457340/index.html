<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 PostCSS plugins that will save time for your coder</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We, front-line vendors, have such a category of tools that do not solve the tasks before us, but rather influence the process of their solution. Chang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 PostCSS plugins that will save time for your coder</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/1b/7_/el/1b7_elrk3cworvip4qutltld9to.jpeg"></p><br><p>  We, front-line vendors, have such a category of tools that do not solve the tasks before us, but rather influence the process of their solution.  Change it.  Attitudes towards such tools are very different - starting from a mania in the spirit of ‚Äúlet's shove this thing everywhere, it's so cool‚Äù and ending with excuses like ‚Äúif it doesn‚Äôt solve business problems, then we don‚Äôt need it‚Äù.  But, anyway, today we will talk about PostCSS - one of these tools. </p><br><p>  The HYIP wave has long passed, and very little has been said about PostCSS lately.  Many newbies do not even know what it is.  I think it's time to look at this tool from the point of view of practical use in the most ordinary projects, where people solve problems rather than play with modern technologies. </p><a name="habracut"></a><br><h2 id="postcss-vs-sass">  PostCSS vs SASS </h2><br><p>  Oh ... Apparently I should say a few words about it.  I think now a rare typesetter has not met with preprocessors.  SASS or my favorite LESS, less commonly Stylus, is used on large projects and on small ones.  Someone is trying to squeeze the maximum out of them, someone is using a minimalist set - nesting, variables, imports.  But, anyway, these tools help with syntax questions.  They make it easier for us to write code. </p><br><p>  About two or three years ago, PostCSS was constantly compared to preprocessors.  And this is understandable.  Formally, it can be used to do everything the same, to make some syntax that will be more convenient than pure CSS.  But all this caused turbulences among the masses, mainly because everyone made something different with the help of PostCSS.  Countless unknown plugins, millions of combinations and no one except the author of this or that config understood how it works and what it does.  It's like Vim or Emacs - you can make a spaceship out of them, but teaching another developer to use them will be very difficult. </p><br><p>  But if these comparisons are discarded, then PostCSS is a tool that allows you to take our CSS and do something with it.  No one bothers to use SASS for the sake of syntax, and after assembly, insert PostCSS and do something with the result.  They do not contradict each other. </p><br><h2 id="staroe--ne-znachit-nerabotayuschee">  Old does not mean idle </h2><br><p>  Recently, we have fashionable to create combines that can do everything that only comes to mind, and their development never stops.  And if there are no fresh commits in the repository for a couple of months, then everything - we can assume that it is outdated and use it now - not comme il faut.  I exaggerate, of course, but I think you yourself noticed how absurd it sometimes comes. </p><br><p>  In the PostCSS world, usually one plugin solves one problem.  You can see elements of the Unix philosophy here.  From this a logical conclusion follows - if the plugin is already solving its problem, then nothing more needs to be done with it anymore.  You may come across plug-ins that have not been updated for years, but this does not mean that they suddenly stopped solving the tasks for which they were created. </p><br><p>  But let's get started ... I collected a dozen plug-ins, which in practice showed their ability to simplify the life of layout designers and save time during development.  But you can always add something in the comments. </p><br><h2 id="1-doiuse">  ‚Ññ1.  Doiuse </h2><br><p>  <a href="https://github.com/anandthakker/doiuse">https://github.com/anandthakker/doiuse</a> </p><br><p>  I think we all faced such a problem: you write code, check it in chrome - everything is ok.  Check in FF - approx.  And then in the mobile Safari everything falls apart.  Or in the edge.  And you sit and do not understand what is wrong.  Then you stare at the code for a long time, drink tea, and suddenly there comes an insight that some property is not supported in some kind of browser.  You go to <a href="https://caniuse.com/">caniuse</a> and see the confirmation of the obvious. </p><br><p><img src="https://habrastorage.org/webt/pm/dy/lw/pmdylwl6g5ahftjlsoikrqyckec.png"></p><br><p>  Of course, with experience hands themselves remember which properties to avoid, but anything can happen.  You can not sleep, there may be short deadlines and nerves, the list of browsers that need to be supported may change.  And then the experience will begin to fail.  Doiuse is a tool that helps a lot in such situations. </p><br><p>  The principle of operation is simple - we feed him a list of browsers and our CSS.  The plugin goes to the caniuse database and in real time gives us the answer that we were looking for from what is not supported. </p><br><p>  We can set the list of browsers directly in package.json.  Simple and convenient.  PostCSS uses <a href="https://github.com/browserslist/browserslist">browserslist</a> and, if you haven't seen it before, it looks like this: </p><br><pre><code class="plaintext hljs">"browserslist": [ "&gt; .5% and last 2 versions", "not dead", "not OperaMini all", "ie &gt;= 11", "Edge &gt;= 12" ]</code> </pre> <br><p>  There is also a doiuse config in which you can make it ignore certain property groups, if you are sure that this does not affect anything.  For example, if you use polifila or nothing will change from the loss of support for some property: </p><br><pre> <code class="plaintext hljs">ignore: [ 'will-change', 'object-fit' ]</code> </pre> <br><p>  The standard log that the plugin gives is not very readable.  It contains a lot of information and it is not very convenient to perceive it.  But this is a fixable matter.  In the same config we can do our function to form a log. </p><br><blockquote>  Use console.log to figure out how the object is structured, which passes PostCSS to this function.  There are many interesting things. </blockquote><p>  My practice has shown that the most convenient option is to display selectors and specific properties that are not supported without specifying browsers and lines of code.  If BEM or some analogs are used in the project, and the code of the components is distributed among individual files, then this approach allows you to quickly find the problem area without loading the brain. </p><br><pre> <code class="javascript hljs">onFeatureUsage(info) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = info.usage.parent.selector; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.prop}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.value}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status = info.featureData.caniuseData.status.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.missing) { status = <span class="hljs-string"><span class="hljs-string">'NOT SUPPORTED'</span></span>.red; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.partial) { status = <span class="hljs-string"><span class="hljs-string">'PARTIAL SUPPORT'</span></span>.yellow; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">:\n\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selector}</span></span></span><span class="hljs-string"> {\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property}</span></span></span><span class="hljs-string">;\n }\n`</span></span>); }</code> </pre> <br><p>  In order not to write special character sequences for colors in the console, you can connect the <a href="https://www.npmjs.com/package/colors">colors</a> package, it will be more convenient with it. </p><br><p>  When building, there will be approximately the following output in the console: </p><br><pre> <code class="plaintext hljs">NOT SUPPORTED: html { -ms-text-size-adjust: 100%; } NOT SUPPORTED: html { -webkit-text-size-adjust: 100%; } PARTIAL SUPPORT: body { display: flex; }</code> </pre> <br><h2 id="2-autoprefixer">  ‚Ññ2.  Autoprefixer </h2><br><p>  <a href="https://github.com/postcss/autoprefixer">https://github.com/postcss/autoprefixer</a> </p><br><p>  It is even embarrassing to talk about him, but too often I see people who in 2019 write prefixes with their hands and still assure those around them that they know exactly which ones are needed and which ones are not.  Such actions lead to the fact that the code is overgrown with a bunch of unnecessary prefixes and becomes completely unreadable.  This affects productivity.  On the other hand, if you need the support of dinosaurs, then you can always forget something.  So it‚Äôs worth getting rid of manual labor. </p><br><p>  The autoprefixer works all with the same caniuse base, uses the same browserslist and can add to CSS those prefixes that are really needed in the browsers we specified.  In this case, the code itself becomes cleaner, and the work goes faster. </p><br><h2 id="3-stylelint">  Number 3.  Stylelint </h2><br><p>  <a href="https://github.com/stylelint/stylelint">https://github.com/stylelint/stylelint</a> </p><br><p>  When you print a lot and quickly, then sooner or later you start to make many mistakes without noticing them.  The eye is washed out.  In the case of CSS, this can give a funny (actually not) effect; when you look at the browser, you see a problem with layout.  You look at the code - it's not there.  You look in the browser - it is.  And in the code - no.  As a result, you can search for a difficult problem for a long time, completely unaware that you just messed up.  That such was not, invented linter. </p><br><p>  Stylelint is a popular option.  He knows how to work with the syntaxes of the main preprocessors, knows about the latest trends in CSS, can be customized to your taste - configs are similar to those of eslint.  Formally, this tool can be used by itself, without PostCSS, but not to mention it here would be wrong. </p><br><h2 id="4-postcss-flexbugs-fixes">  ‚Ññ4.  Postcss-flexbugs-fixes </h2><br><p>  <a href="https://github.com/luisrudge/postcss-flexbugs-fixes">https://github.com/luisrudge/postcss-flexbugs-fixes</a> </p><br><p>  Or in a broader sense, <a href="https://github.com/MattDiMu/postcss-fixes">postcss-fixes</a> , which includes this plugin.  Slowly but surely, the flexes supplant the old approach to layout on floats.  This is good, but we all know that a set of bugs is associated with them.  These are described in the <a href="https://github.com/philipwalton/flexbugs">flexbugs</a> repository.  Some of them require special attention, but there are also a few that are so simple that they constantly fly out of my head.  For example, IE ignores the calc function in the shorthand property flex.  This is not so often necessary, but if necessary, the hands themselves can write an abridged version and then they have to think a long time what the problem is.  Fortunately, this case can be fixed automatically.  The postcss-flexbugs-fixes plugin comes to the rescue. </p><br><p>  In the calc example, he finds fragments like this in the code: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw ‚Äì 1px); }</code> </pre> <br><p>  And expand them: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw - 1px); }</code> </pre> <br><p>  Simple and convenient. </p><br><h2 id="5-postcss-preset-env">  ‚Ññ5.  Postcss-preset-env </h2><br><p>  <a href="https://github.com/csstools/postcss-preset-env">https://github.com/csstools/postcss-preset-env</a> </p><br><p>  Since we are talking about browser support, it will not be superfluous to say about postcss-preset-env.  Previously, <a href="https://cssnext.github.io/">cssnext</a> performed the same role.  This plugin will be useful if you are interested in new trends in CSS. </p><br><p><img src="https://habrastorage.org/webt/bu/kp/4h/bukp4htn6ewwkk4qznb8phjxzoa.jpeg"></p><br><p>  Many of the innovations are technically possible to implement with the old methods, it will just be long, verbose and ugly.  Preset-env helps to write code in a new way, save time on it, and then convert it into the old reliable version.  Of course, some things like custom properties are not implemented at all in older browsers, so folbekbacks will be used there. </p><br><p>  As you can guess from the name of the tool, it resembles the same preset Babel.  There is still a lot of converters assembled in one stable set.  Some transformations require the subsequent connection of polyfile scripts on the client, but most are implemented purely by CSS.  As far as I understand, for Stage2 + scripts are not needed.  In any case, did not encounter their necessity.  Correct me if I missed something there. </p><br><h2 id="6-postcss-animation">  ‚Ññ6.  Postcss-animation </h2><br><p>  <a href="https://github.com/zhouwenbin/postcss-animation">https://github.com/zhouwenbin/postcss-animation</a> </p><br><p>  I often hear from different people (mostly backenders who are not very strong in CSS) that they want to use separate animations from <a href="https://daneden.github.io/animate.css/">animate.css</a> , but they consider it a bad idea to include the entire library.  It is quite logical.  But as a result, they spend a lot of time trying to repeat these animations on their own. </p><br><p><img src="https://habrastorage.org/webt/hy/tw/wp/hytwwpkrfzjzsktmomybo51bea0.jpeg"></p><br><p>  The postcss-animation plugin speeds up this process a lot.  We write only the name of the animation, for example: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; }</code> </pre> <br><p>  And he pulls up the implementation from animate.css and inserts it into the code. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> bounce { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span>, 20%, 53%, 80%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.215, 0.610, 0.355, 1.000); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,0,0); } 40%, 43% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -30px, 0); } 70% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -15px, 0); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,-4px,0); } }</code> </pre> <br><h2 id="7-list-selectors">  ‚Ññ7.  List-selectors </h2><br><p>  <a href="https://github.com/davidtheclark/list-selectors">https://github.com/davidtheclark/list-selectors</a> </p><br><p>  When you have several designers and a lot of styles, the question arises about code review, that it would be nice sometimes to see the big picture with all the selectors that we have.  To know which IDs are used, whether there are tag selectors, or to what extent the adopted methodology is respected.  This is especially important when you check the beginner code, which can write strange things that will formally work, but will actually go against accepted agreements (these agreements are not well documented everywhere and it is possible to automate such things).  Most scroll through numerous files with styles to check the adequacy of selectors for a long time.  We need a way to isolate them and show them separately.  List-selectors just solves this problem. </p><br><p>  In the same way as doiuse, this plugin allows you to use your function to prepare information for display on the screen.  You can display only what interests you, or paint everything in different colors.  As an example: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'list-selectors'</span></span>).plugin(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inspect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>).inspect; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'SELECTORS:'</span></span>.blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.selectors, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'IDS:'</span></span>.red); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.simpleSelectors.ids, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).red); })</code> </pre> <br><p>  This example will have a long, long list of selectors: </p><br><pre> <code class="plaintext hljs">SELECTORS: [ '.mui-progress-bar', '.mui-progress-bar &gt; .indicator', '.mui-progress-bar &gt; .value', '.mui-progress-bar.-radial', '.mui-progress-bar.-radial &gt; .indicator', '.mui-progress-bar.-radial &gt; .indicator &gt; .background', '.mui-progress-bar.-radial &gt; .indicator &gt; .progress', '.mui-progress-bar.-radial &gt; .value', . . .</code> </pre> <br><h2 id="8-immutable-css">  ‚Ññ8.  Immutable-css </h2><br><p>  <a href="https://github.com/johno/immutable-css">https://github.com/johno/immutable-css</a> </p><br><p>  Another thing to watch out for is interrupting styles from third-party libraries.  If we hooked up some kind of library, and then we begin to write our styles for selectors from it, then in the end we get tangled code in which we cannot make out where it came from.  This can lead to random bugs, which then take too much time out of the blue.  The more times we redefine something, the more difficult it is to finally understand what is happening, although the problem itself, which needs to be solved, can be very simple.  In this situation, a tool called immutable-css may come in handy. </p><br><p>  In general, the principle of its operation is simple: it takes files with styles, if it finds matches by selectors - it begins to resent: </p><br><pre> <code class="plaintext hljs">! .button was mutated 2 times [line 93, col 1]: /css/basscss.css [line 3, col 1]: /css/custom.css [immutable-css] ! .left was mutated 2 times [line 291, col 1]: /css/basscss.css [line 4, col 1]: /css/custom.css [immutable-css]</code> </pre> <br><p>  The only problem with this tool is that it does not support non-CSS syntax.  So if in the project preprocessors are used, then it is necessary to compare already collected files.  But in general, if the task is to just make sure that no one accidentally rewrote styles from a third-party library, then this is not so important. </p><br><h2 id="9-bye-bye">  ‚Ññ9.  Bye-bye! </h2><br><p>  <a href="https://github.com/AoDev/css-byebye">https://github.com/AoDev/css-byebye</a> </p><br><p>  I think everyone is familiar with the situation when we gradually add some components to a working site.  Some of them are sent immediately to production, and some sit for a long time and wait for their turn (for example, we cast up, but we didn‚Äôt finish the backend).  Something could be an experiment or a temporary solution for the holidays.  There may be many situations, but they are united by the fact that we have a lot of components, and only a small part of them are used on the combat site.  It would be good to remove everything that is not used from the current build.  This can significantly reduce its size, as well as reduce the headache in the future, when you need to do a redesign, for example, and the question arises, what of all this really need to be rewritten now, and what is not. </p><br><p><img src="https://habrastorage.org/webt/l5/rl/e5/l5rle5k5yldudgr5rvtz7hotjom.gif"></p><br><p>  There are different approaches to this issue.  <a href="https://github.com/uncss/uncss">Uncss</a> comes to mind immediately.  This tool automatically determines which styles are used on the pages and removes unnecessary.  But in practice, this almost always leads to the fact that no one knows what is actually used and what is not.  And I‚Äôve been wondering all the time if this tool hasn‚Äôt removed anything unnecessary.  But this is probably my paranoia.  Although... </p><br><p>  Bye-bye is a simpler tool that we ourselves feed a list of selectors that need to be removed from CSS.  And you can use regular expressions.  If you apply BEM or something else in this spirit, then with one simple regular schedule you can remove a block with everything that applies to it.  Bye-bye! </p><br><p>  This approach was quite convenient.  It is immediately clear which styles are not yet used or were removed as unnecessary, while all the sources are in place, all the settings in one file, nothing is lost, it does not cause difficulties to make several different assemblies, and most importantly - the solution is simple and predictable. </p><br><h2 id="10-postcss-trolling">  ‚Ññ10.  Postcss trolling </h2><br><p>  <a href="https://github.com/juanfran/postcss-trolling">https://github.com/juanfran/postcss-trolling</a> </p><br><p>  All previous tools may slightly increase the productivity of your web designers, but this one just gives phenomenal results.  Highly recommend. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  PostCSS is a good help for the maker.  If they are not abused, of course.  For many time-consuming problems, there are ready-made solutions in the form of plug-ins, and although they often do not develop and seem to be abandoned, this does not prevent them from being used. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457340/">https://habr.com/ru/post/457340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457332/index.html">How to quickly see the interesting warnings that the PVS-Studio analyzer issues for C and C ++ code?</a></li>
<li><a href="../457334/index.html">TacacsGUI, Configuration Manager</a></li>
<li><a href="../457336/index.html">Consequences of late removal of wisdom teeth</a></li>
<li><a href="../457338/index.html">Blitz with Ilya Krasinsky: how to shoot bad hypotheses, why to dismiss the product and how to grow in a minimum of actions?</a></li>
<li><a href="../45734/index.html">Discuss how to deal with automatic spam?</a></li>
<li><a href="../457342/index.html">Signs from above: how did we save cartographers from unnecessary work and red eyes</a></li>
<li><a href="../457348/index.html">Deploy to PythonAnywhere from GitHub</a></li>
<li><a href="../457350/index.html">Why does the oscilloscope support cryptography?</a></li>
<li><a href="../457352/index.html">Information output on the customer‚Äôs display</a></li>
<li><a href="../457354/index.html">Obfuscation of data for performance tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>