<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arduino and timer interrupts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article "Timer interrupts" by E. 
 Foreword 


 Arduino board allows you to quickly and w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arduino and timer interrupts</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to your attention the translation of the article <a href="https://arduinodiy.wordpress.com/2012/02/28/timer-interrupts/">"Timer interrupts"</a> by E. </p><br><h3 id="predislovie">  Foreword </h3><br><p>  Arduino board allows you to quickly and with minimal resources solve a variety of tasks.  But where arbitrary time intervals are needed (periodic interrogation of sensors, high-precision PWM signals, long duration pulses) standard library delay functions are not convenient.  At the time of their action, the sketch is suspended and it becomes impossible to control it. </p><br><p>  In this situation, it is better to use the built-in AVR timers.  How to do this and not get lost in the technical jungle of datasheets, says a <a href="https://arduinodiy.wordpress.com/2012/02/28/timer-interrupts/">successful article</a> , the translation of which is offered to your attention. </p><br><p><img src="https://habrastorage.org/webt/3g/n_/iw/3gn_iwqe-tubwgqslsclzuaznki.png"></p><a name="habracut"></a><br><p>  This article discusses the AVR and Arduino timers and how to use them in Arduino projects and user circuits. </p><br><h3 id="chto-takoe-taymer">  What is a timer? </h3><br><p>  As in everyday life in microcontrollers, the timer is some thing that can give a signal in the future, at the moment that you set.  When this moment comes, the microcontroller is interrupted, reminding him to do something, for example, run a certain piece of code. </p><br><p>  Timers, like external interrupts, operate independently of the main program.  Instead of performing loops or repeating the <em>millis ()</em> delay, you can assign a timer to do its work, while your code does other things. </p><br><p>  So, suppose that there is a device that needs to do something, for example, the LED flashes every 5 seconds.  If you do not use timers, and write the usual code, then you need to set the variable at the time of ignition of the LED and constantly check whether the moment of its switching has come.  With a timer interrupt, you just need to set up an interrupt, and then start the timer.  The LED will flash exactly on time, regardless of the action of the main program. </p><br><h3 id="kak-rabotaet-taymer">  How does the timer work? </h3><br><p>  It acts by incrementing a variable called a <em>counting register</em> .  The counting register can read up to a certain value, depending on its size.  The timer increases its counter time after time until it reaches the maximum value, at this point the counter will overflow and reset back to zero.  The timer usually sets the flag bit to let you know that an overflow has occurred. </p><br><p>  You can check this flag manually or you can make a timer switch ‚Äî trigger an interrupt automatically when the flag is set.  Like any other interrupt, you can assign an interrupt service routine ( <em>Interrupt Service Routine</em> or <em>ISR</em> ) to execute a given code when the timer overflows.  ISR will reset the overflow flag itself, so using interrupts is usually the best choice because of simplicity and speed. </p><br><p>  To increase the counter values ‚Äã‚Äãat precise intervals, the timer must be connected to a clock source.  The clock source generates a constantly repeating signal.  Each time the timer detects this signal, it increments the counter value by one.  Since the timer operates from a clock source, the smallest unit of time is the clock period.  If you connect a 1 MHz clock signal, then the resolution of the timer (or the period of the timer) will be: </p><br><p>  T = 1 / f (f is the clock frequency) <br>  T = 1/1 MHz = 1/10 ^ 6 Hz <br>  T = (1 ‚àó 10 ^ -6) with </p><br><p>  So the timer resolution is one millionth of a second.  Although you can use an external clock source for timers, in most cases the internal source of the chip itself is used. </p><br><h3 id="tipy-taymerov">  Timer Types </h3><br><p>  In standard Arduino boards on an 8-bit AVR chip, there are several timers at once.  Atmega168 and Atmega328 chips have three timers Timer0, Timer1 and Timer2.  They also have a watchdog timer that can be used for crash protection or as a software reset mechanism.  Here are some features of each timer. </p><br><p>  Timer0: <br>  Timer0 is an 8-bit timer, which means that its counting register can store numbers up to 255 (i.e., unsigned byte).  Timer0 is used by standard Arduino time functions such as <em>delay ()</em> and <em>millis ()</em> , so it‚Äôs best not to confuse it if you care about the consequences. </p><br><p>  Timer1: <br>  Timer1 is a 16-bit timer with a maximum count value of 65535 (unsigned integer).  This timer uses the library Arduino Servo, consider this if you use it in your projects. </p><br><p>  Timer2: <br>  Timer2 - 8 bit and very similar to Timer0.  It is used in the Arduino <em>tone ()</em> function. </p><br><p>  Timer3, Timer4, Timer5: <br>  The ATmega1280 and ATmega2560 chips (installed in Arduino Mega variants) have three additional timers.  All of them are 16 bit and work similarly to Timer1. </p><br><h3 id="konfiguraciya-registrov">  Register Configuration </h3><br><p>  In order to use these timers in the AVR there are registers of settings.  Timers contain many such registers.  Two of them are the timer / counter control registers and the setting variables are called TCCRxA and TCCRxB, where x is the timer number (TCCR1A and TCCR1B, etc.).  Each register contains 8 bits and each bit stores a configuration variable.  Here is information from the Atmega328 datasheet: </p><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1A </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  five </td><td>  four </td><td>  3 </td><td>  2 </td><td>  one </td><td>  0 </td></tr><tr><td>  0x80 </td><td>  COM1A1 </td><td>  COM1A0 </td><td>  COM1B1 </td><td>  COM1B0 </td><td>  - </td><td>  - </td><td>  WGM11 </td><td>  WGM10 </td></tr><tr><td>  ReadWrite </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  R </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Initial value </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1B </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  five </td><td>  four </td><td>  3 </td><td>  2 </td><td>  one </td><td>  0 </td></tr><tr><td>  0x81 </td><td>  ICNC1 </td><td>  ICES1 </td><td>  - </td><td>  WGM13 </td><td>  WGM12 </td><td>  CS12 </td><td>  CS11 </td><td>  CS10 </td></tr><tr><td>  ReadWrite </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Initial value </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><p>  The most important are the last three bits in TCCR1B: CS12, CS11 and CS10.  They determine the clock frequency of the timer.  By choosing them in different combinations, you can order the timer to operate at different speeds.  Here is a datasheet that describes the effect of the select bits: </p><br><div class="scrollable-table"><table><thead><tr><th>  CS12 </th><th>  CS11 </th><th>  CS10 </th><th>  Act </th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  No clock source (Timer / Counter stopped) </td></tr><tr><td>  0 </td><td>  0 </td><td>  one </td><td>  clk_io / 1 (no division) </td></tr><tr><td>  0 </td><td>  one </td><td>  0 </td><td>  clk_io / 8 (frequency divider) </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td><td>  clk_io / 64 (frequency divider) </td></tr><tr><td>  one </td><td>  0 </td><td>  0 </td><td>  clk_io / 256 (frequency divider) </td></tr><tr><td>  one </td><td>  0 </td><td>  one </td><td>  clk_io / 1024 (frequency divider) </td></tr><tr><td>  one </td><td>  one </td><td>  0 </td><td>  External clock source at pin T1.  Clock down </td></tr><tr><td>  one </td><td>  one </td><td>  one </td><td>  External clock source at pin T1.  Front Clocking </td></tr></tbody></table></div><br><p>  By default, all these bits are set to zero. </p><br><p>  Suppose you want Timer1 to work at a clock frequency with one count per period.  When it overflows, you want to call an interrupt subroutine that switches the LED connected to pin 13 to the on or off state.  For this example, we write the Arduino code, but we will use the procedures and functions of the avr-libc library whenever it does not make things too complicated.  Proponents of pure AVR can customize the code as they see fit. </p><br><p>  First, we initialize the timer: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //  TCCR1A   0 TCCR1B = 0; //   Timer1 overflow: TIMSK1 = (1 &lt;&lt; TOIE1); //  CS10  ,      : TCCR1B |= (1 &lt;&lt; CS10); sei(); //    }</span></span></code> </pre> <br><p>  The TIMSK1 register is the Timer / Counter1 interrupt mask register.  It controls the interrupts that the timer can trigger.  Setting the TOIE1 bit tells the timer to interrupt when the timer overflows.  More on this later. </p><br><p>  When you set the CS10 bit, the timer starts counting and, as soon as an overflow interrupt occurs, an ISR (TIMER1_OVF_vect) is called.  This always happens when the timer overflows. </p><br><p>  Next, we define the ISR interrupt function: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_OVF_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Now we can define the loop loop () and switch the LED regardless of what happens in the main program.  To turn off the timer, set TCCR1B = 0 at any time. </p><br><h3 id="kak-chasto-budet-migat-svetodiod">  How often will the LED flash? </h3><br><p>  Timer1 is set to overflow interrupt and let's assume that you are using an Atmega328 with a clock frequency of 16 MHz.  Since the timer is 16-bit, it can read up to the maximum value (2 ^ 16 - 1), or 65535. At 16 MHz, the cycle is executed 1 / (16 ‚àó 10 ^ 6) seconds or 6.25e-8 s.  This means that 65535 counts will occur in (65535 ‚àó 6.25e-8 s) and the ISR will be called in approximately 0.0041 seconds.  And so over and over again, every four thousandth seconds.  It is too fast to see flicker. </p><br><p>  If we give the LED a very fast PWM signal with 50% coverage, the glow will appear continuous, but less bright than usual.  Such an experiment shows the amazing power of microcontrollers - even an inexpensive 8-bit chip can process information much faster than we are able to detect. </p><br><h3 id="delitel-taymera-i-rezhim-ctc">  Timer Divider and CTC Mode </h3><br><p>  To control the period, you can use a divider that allows you to divide the clock signal into different powers of two and increase the period of the timer.  For example, you would like the LED to flash at one second intervals.  In the TCCR1B register, there are three bits of CS that set the most appropriate resolution.  If you set the bits CS10 and CS12 using: </p><br><pre> <code class="cpp hljs">TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS10); TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS12);</code> </pre> <br><p>  then the clock source frequency will be divided by 1024. This gives the resolution of the timer 1 / (16 ‚àó 10 ^ 6/1024) or 6.4e-5 s.  Now the timer will overflow every (65535 * 6.4e-5s) or 4,194s.  This is too long. </p><br><p>  But there is another AVR timer mode.  It is called a reset timer by coincidence or CTC.  Instead of counting before overflow, the timer compares its counter with the one previously stored in the register.  When the count coincides with this variable, the timer can either set the flag or trigger an interrupt, just like in the case of overflow. </p><br><p>  To use CTC mode, you need to understand how many cycles you need to get an interval of one second.  Suppose that the division factor is still equal to 1024. </p><br><p>  The calculation will be as follows: </p><br><pre> <code class="plaintext hljs">(target time) = (timer resolution) * (# timer counts + 1) (# timer counts + 1) = (target time) / (timer resolution) (# timer counts + 1) = (1 s) / (6.4e-5 s) (# timer counts + 1) = 15625 (# timer counts) = 15625 - 1 = 15624</code> </pre> <br><p>  You must add an extra one to the number of samples because in CTC mode, if the counter coincides with the specified value, it will reset itself to zero.  The reset takes one clock period, which must be taken into account in the calculations.  In many cases, the error in one period is not too significant, but in high-precision tasks it can be critical. </p><br><p>  The setup () setting function will be as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(LEDPIN, OUTPUT); <span class="hljs-comment"><span class="hljs-comment">//  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //   CTC  //   CS10  CS12    1024 TCCR1B |= (1 &lt;&lt; CS10); TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //     sei(); //    }</span></span></code> </pre> <br><p>  You also need to replace the overflow interrupt with the interrupt by coincidence: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Now the LED will light up and go out for exactly one second.  And you can do anything in the loop ().  While you do not change the timer settings, the program has nothing to do with interrupts.  You have no restrictions on using the timer with different modes and settings of the divider. </p><br><p>  Here is a complete starting example that you can use as a basis for your own projects: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arduino  CTC  // avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //  CTC  TCCR1B |= (1 &lt;&lt; CS10); //      1024 TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //      sei(); //    } void loop() { //   } ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</span></span></code> </pre> <br><p>  Remember that you can use built-in ISR functions to extend timer functions.  For example, you need to poll the sensor every 10 seconds.  But the timer settings that provide such a long account without overflow are not.  However, you can use ISR to increment the counting variable once a second and then poll the sensor when the variable reaches 10. Using the CTC mode from the previous example, the interruption could look like this: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { seconds++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(seconds == <span class="hljs-number"><span class="hljs-number">10</span></span>) { seconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; readSensor(); } }</code> </pre> <br><p>  Since the variable will be modified inside the ISR, it must be declared as <em>volatile</em> .  Therefore, when describing variables at the beginning of the program, you need to write: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> byte seconds;</code> </pre> <br><h3 id="posleslovie-perevodchika">  Translator's epilogue </h3><br><p>  At one time, this article saved me a lot of time when developing a prototype measuring generator.  I hope that it will be useful to other readers. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453276/">https://habr.com/ru/post/453276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453258/index.html">Making a reverb pedal using PT2399 microcircuits (part 1)</a></li>
<li><a href="../453260/index.html">DPI setting features</a></li>
<li><a href="../453264/index.html">Virtuali-tee: a ‚Äúmedical T-shirt‚Äù that doesn‚Äôt cover but expose</a></li>
<li><a href="../453272/index.html">GitHub Sponsors: a new way to contribute to open source</a></li>
<li><a href="../453274/index.html">Hidden commission Yandex.Money in Samsung Pay</a></li>
<li><a href="../453278/index.html">Why don't engineers care about monitoring applications?</a></li>
<li><a href="../453280/index.html">Technical duty</a></li>
<li><a href="../453286/index.html">The most expensive mistake in my life: in detail about the attack on the port of the SIM card</a></li>
<li><a href="../453290/index.html">Data Science Digest (May 2019)</a></li>
<li><a href="../453292/index.html">"A little book about black holes"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>