<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 and USB-HID - it‚Äôs just</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the yard in 2014, and for the connection of microcontrollers with a PC, the most popular means is the usual serial port. It's easy to start working...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 and USB-HID - it‚Äôs just</h1><div class="post__text post__text-html js-mediator-article">  In the yard in 2014, and for the connection of microcontrollers with a PC, the most popular means is the usual serial port.  It's easy to start working with him, he is simple in understanding to the primitiveness - just a stream of bytes. <br>  However, all modern standards have excluded the COM port from the PC and you have to use USB-UART adapters to get access to your project on the MC.  He is not always at hand.  Such an adapter does not always work stably due to driver problems.  There are other disadvantages. <br>  But every time there is a conversation about whether to use USB or serial port, there are many fans of the logical simplicity of the UART.  And they have a reason.  However, is it good to have an alternative? <br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/512/75d/6b151275d8392a0eefe1c90524bebded.jpg"><br>  I have long been asked to tell how to organize packet data exchange between a PC and a MK using the example of the STM32F103.  I will give a ready-made working project and tell you how to adapt it to your needs.  And so you decide - you need it or not. <br><br>  We have a board with a modern low-cost microcontroller STM32F103C8 with built-in hardware USB support, I told about it earlier <br><img src="https://habrastorage.org/getpro/habr/post_images/ee0/b51/3ab/ee0b513ab61780097991d4b56e1f48a8.jpg"><br><a name="habracut"></a><br>  I said that the <b>serial port</b> has other disadvantages: <br>  - Often the COM port is not in the PC or laptop <br>  - the device needs to be fed separately <br>  - even if there is a COM port in the PC, the signal levels must be matched: the PC uses the RS232 interface with differential levels of signals + 15V and -15V, and microcontrollers use TTL levels (+ 5V, + 3.3V, unipolar). <br>  - Often in the system dozens of virtual COM ports are formed and finding the port that corresponds to your device may be difficult. <br>  In turn, <b>USB has been</b> with us for many years and has its advantages: <br>  -Ability to supply power from the HOST device <br>  - Convenient implementation of batch exchange <br>  -Ability to simultaneously connect to the device with several programs <br>  -Ability to uniquely identify the connected device <br>  - Hardware support in many modern MCs, which eliminates the need for adapters <br>  USB functionality is extremely rich, but it raises a problem ‚Äî it's not as simple to understand as with a serial interface.  There is a separate class of devices - USB-HID, which do not require the installation of drivers, specifically designed to interact with humans and various input-output devices.  Ideal for organizing data exchange with MK.  I personally like the batch exchange mode.  This is a convenient abstraction.  In addition, parsing packet messages is somewhat easier and more convenient than working with a simple stream of bytes. <br><br><h4>  HID profile selection </h4><br>  USB-HID is a fairly extensive class of devices, so first of all you have to choose which device we will create. <br>  We can create an emulation of a keyboard, mouse, joystick, and other input devices, and we can create our device so as not to depend on a fairly rigid standard framework and freely exchange data with a PC. <br>  I'll tell you how to make a <b>Custom HID</b> device.  This gives maximum freedom.  In order not to delay the article, I will try to tell as briefly as possible - there are many descriptions of the standard in the network and without me, but personally they helped me a little when it took to solve a specific task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Project structure </h4><br>  I use <a href="http://ravenium.ru/emblocks-ide/">EmBlocks</a> for development under STM32.  You can use any convenient environment, the project is not very difficult to adapt. <br>  Added to the <a href="http://ravenium.ru/stm32-emblocks-%25D0%25BC%25D0%25B8%25D0%25B3%25D0%25B0%25D0%25B5%25D0%25BC-%25D1%2581%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4%25D0%25B8%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25BC/">basic structure of the</a> project: <br><ul><li>  Folder <b>USB-FS</b> with the library "STM32F10x, STM32L1xx and STM32F3xx USB-FS-Device Driver" version 4.0.0. </li><li>  In the folders Inc and Src files: <br>  <b>platform_config.h</b> - here are the definitions related to the specific board and the MK family <br>  <b>stm32_it.h, stm32_it.c</b> - interrupt handlers are defined here <br>  <b>usb_conf.h, usb_endp.c</b> - this defines end points (Endpoint), sizes and addresses of their buffers, handler functions <br>  <b>usb_desc.h, usb_desc.c</b> - information about the device itself is collected here - how it will be determined when connected to a PC and the size and format of data packets are determined <br>  <b>hw_config.c</b> - here all work is collected with sending data to PC <br>  <b>hw_config.h, usb_istr.h, usb_prop.h, usb_pwr.h</b> <br>  <b>usb_istr.c, usb_prop.c, usb_pwr.c</b> - are needed for the USB-FS library to work, but it's not necessary to climb into them </li></ul><br>  We add all these files to any project using USB. <br><h4>  USB initialization </h4><br>  For correct operation of the USB module, the frequency of the MK is important.  Not all frequencies allow you to properly set the USB clocking.  In our case, we use a crystal oscillator at 8 MHz and MK operates at 72 MHz, and a USB module at 48 MHz. <br>  Just insert a few lines of code into main.c. <br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hw_config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usb_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usb_pwr.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Private variables ---------------------------------------------------------*/</span></span></span><span class="hljs-meta"> __IO uint8_t PrevXferComplete = 1; int main(void) { Set_System(); USB_Interrupts_Config(); Set_USBClock(); USB_Init(); while (1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bDeviceState == CONFIGURED) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (PrevXferComplete) { RHIDCheckState(); } } } }</span></span></code> </pre> <br></div></div><br>  In the <b>Set_System ()</b> function, the pin of the D + line <b>uplift</b> to the power is configured to programmatically connect / disconnect the device from the PC (not used in our board), the interrupt is set up, and the LEDs and buttons for the demonstration project are initialized. <br>  In <b>USB_Interrupts_Config (),</b> interrupts are configured depending on the MK family (F10x, F37x, L1x are supported). <br>  The <b>USB_Init ()</b> function starts the USB module.  If you need to temporarily disable USB operation for debugging, simply comment out this line. <br>  Further, in an infinite loop, it is checked whether it was possible to configure the USB module when connected to a PC.  If everything worked correctly and the device was successfully connected, the PC is on and is not in power saving mode, then the status will be CONFIGURED. <br>  Next, it is checked whether the previous data transfer to the PC was completed and, if so, it prepares for sending a new packet in the <b>RHIDCheckState ()</b> function <b>.</b> <br><br><h4>  Packet size and transmission frequency </h4><br>  USB-HID device can not initiate the transfer itself, because  bus coordination is handled by the host device - the PC  Therefore, when preparing the USB descriptor of our device, we write how often our device should be polled.  According to the specification, the maximum polling frequency is 1 kHz and the maximum size of a packet transmitted at a time is 64 bytes.  If this is not enough, you will have to use other modes of operation - like USB bulk, but you can‚Äôt do without drivers there. <br>  For setting the interaction with the PC are responsible 3 descriptor: <br><div class="spoiler">  <b class="spoiler_title">Device handle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USB Standard Device Descriptor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> RHID_DeviceDescriptor[RHID_SIZ_DEVICE_DESC] = { RHID_SIZ_DEVICE_DESC, <span class="hljs-comment"><span class="hljs-comment">//       USB_DEVICE_DESCRIPTOR_TYPE, // bDescriptorType - ,    .    - Device descriptor 0x00, 0x02, // bcdUSB -    USB  . 2.0 // ,    ,   USB.   ,       0x00, //bDeviceClass 0x00, //bDeviceSubClass 0x00, //bDeviceProtocol 0x40, //bMaxPacketSize -     Endpoint 0 ( ) //    VID  PID,    ,     . 0x83, 0x04, //idVendor (0x0483) 0x11, 0x57, //idProduct (0x5711) DEVICE_VER_L, DEVICE_VER_H, // bcdDevice rel. DEVICE_VER_H.DEVICE_VER_L    //    ,  ,    . //        //         VID/PID  . 1, //Index of string descriptor describing manufacturer 2, //Index of string descriptor describing product 3, //Index of string descriptor describing the device serial number 0x01 // bNumConfigurations -   .   . } ; /* CustomHID_DeviceDescriptor */</span></span></code> </pre><br></div></div><br>  In the comments everything is pretty transparent.  Pay attention to DEVICE_VER_L, DEVICE_VER_H - these are constants from usb_desc.h, which you can change to identify the version of your device. <br><br><div class="spoiler">  <b class="spoiler_title">Configuration descriptor (describes device capabilities)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USB Configuration Descriptor */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* All Descriptors (Configuration, Interface, Endpoint, Class, Vendor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> RHID_ConfigDescriptor[RHID_SIZ_CONFIG_DESC] = { <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">// bLength:    USB_CONFIGURATION_DESCRIPTOR_TYPE, // bDescriptorType:   -  RHID_SIZ_CONFIG_DESC, 0x00, // wTotalLength:          0x01, // bNumInterfaces:      0x01, // bConfigurationValue:    0x00, // iConfiguration:  ,     0xE0, // bmAttributes:  ,       USB 0x32, // MaxPower 100 mA:    100  /**************   ****************/ 0x09, // bLength:    USB_INTERFACE_DESCRIPTOR_TYPE, // bDescriptorType:   -  0x00, // bInterfaceNumber:    - 0 0x00, // bAlternateSetting:   ,     0x02, // bNumEndpoints -  . 0x03, // bInterfaceClass:   - HID //       ,    ,          //      HID- 0x00, // bInterfaceSubClass :  . 0x00, // nInterfaceProtocol :   0, // iInterface:  ,   //      ,    -  HID  /******************** HID  ********************/ 0x09, // bLength:  HID- HID_DESCRIPTOR_TYPE, // bDescriptorType:   - HID 0x01, 0x01, // bcdHID:   HID 1.1 0x00, // bCountryCode:   ( ) 0x01, // bNumDescriptors:    report  HID_REPORT_DESCRIPTOR_TYPE, // bDescriptorType:   - report RHID_SIZ_REPORT_DESC, 0x00, // wItemLength:  report- /********************    (endpoints) ********************/ 0x07, // bLength:   USB_ENDPOINT_DESCRIPTOR_TYPE, //   - endpoints 0x81, // bEndpointAddress:      1(IN) 0x03, // bmAttributes:    - Interrupt endpoint wMaxPacketSize, 0x00, // wMaxPacketSize: Bytes max 0x20, // bInterval: Polling Interval (32 ms) 0x07, /* bLength: Endpoint Descriptor size */ USB_ENDPOINT_DESCRIPTOR_TYPE, /* bDescriptorType: */ /* Endpoint descriptor type */ 0x01, /* bEndpointAddress: */ /* Endpoint Address (OUT) */ 0x03, /* bmAttributes: Interrupt endpoint */ wMaxPacketSize, /* wMaxPacketSize: Bytes max */ 0x00, 0x20, /* bInterval: Polling Interval (32 ms) */ } ; /* RHID_ConfigDescriptor */</span></span></code> </pre><br></div></div><br>  Here you should pay attention to the wMaxPacketSize constant - it defines the maximum packet size that we will exchange with the PC.  The project is set up so that when it changes, the size of the buffers also changes.  But do not forget that more than 0x40 according to the standard should not be specified.  With this constant, be careful - if the transmitted packet is different in size - there will be problems! <br>  The next constant with the comment bInterval is the device polling period in milliseconds.  32ms is set for our device. <br><br><div class="spoiler">  <b class="spoiler_title">Report Descriptor (describes the protocol)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> RHID_ReportDescriptor[RHID_SIZ_REPORT_DESC] = { <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE_PAGE (Generic Desktop) 0x09, 0x01, // USAGE (Vendor Usage 1) 0xa1, 0x01, // COLLECTION (Application) 0x85, 0x01, // REPORT_ID (1) 0x09, 0x01, // USAGE (Vendor Usage 1) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x01, // REPORT_COUNT (1) 0xb1, 0x82, // FEATURE (Data,Var,Abs,Vol) 0x85, 0x01, // REPORT_ID (1) 0x09, 0x01, // USAGE (Vendor Usage 1) 0x91, 0x82, // OUTPUT (Data,Var,Abs,Vol) 0x85, 0x02, // REPORT_ID (2) 0x09, 0x02, // USAGE (Vendor Usage 2) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x01, // REPORT_COUNT (1) 0xb1, 0x82, // FEATURE (Data,Var,Abs,Vol) 0x85, 0x02, // REPORT_ID (2) 0x09, 0x02, // USAGE (Vendor Usage 2) 0x91, 0x82, // OUTPUT (Data,Var,Abs,Vol) 0x85, 0x03, // REPORT_ID (3) 0x09, 0x03, // USAGE (Vendor Usage 3) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x26, 0xff, 0x00, // LOGICAL_MAXIMUM (255) 0x75, 0x08, // REPORT_SIZE (8) 0x95, RPT3_COUNT, // REPORT_COUNT (N) 0xb1, 0x82, // FEATURE (Data,Var,Abs,Vol) 0x85, 0x03, // REPORT_ID (3) 0x09, 0x03, // USAGE (Vendor Usage 3) 0x91, 0x82, // OUTPUT (Data,Var,Abs,Vol) 0x85, 0x04, // REPORT_ID (4) 0x09, 0x04, // USAGE (Vendor Usage 4) 0x75, 0x08, // REPORT_SIZE (8) 0x95, RPT4_COUNT, // REPORT_COUNT (N) 0x81, 0x82, // INPUT (Data,Var,Abs,Vol) 0xc0 // END_COLLECTION }</span></span></code> </pre><br></div></div><br>  This is the most important descriptor - it describes the protocol of the exchange and the functionality of the device.  Its formation is not the easiest task.  If you make a mistake in the formation of the descriptor - the device will stop working.  The descriptor format is very hard.  There is even a special utility <a href="http://www.usb.org/developers/hidpage/">HID Descriptor tool</a> .  And in the root of the project there is a file ‚ÄúRHID.hid‚Äù with the descriptor described above for editing in this utility.  But if you do not understand what you are doing, it is better not to go. <br>  For simplicity, I made two constants: <br>  <b>RPT3_COUNT</b> - OUTPUT buffer size in bytes for transmitting the packet to the MC (in the example - 1 byte) <br>  <b>RPT4_COUNT</b> - INPUT buffer size in bytes for transmitting the packet to the PC (4 bytes in the example) <br>  The size of any of these buffers should not exceed <b>wMaxPacketSize</b> .  Less is possible. <br>  By the way, you can transform a Custom HID into another HID device, for example, a keyboard or a joystick, just by rewriting ReportDescriptor and changing the class and subclass of the device in the configuration descriptor. <br><br><h4>  What is Report </h4><br>  Host (PC) and device (MK) exchange data packets of a predetermined structure - report.  There can be quite a lot of packages, they can be foreseen for all occasions - for example, a package with data about some events in the device, a package with data that the PC requested, a package with a command for the MC.  Anything.  But the structure of all packages must be described in the RHID_ReportDescriptor structure. <br>  PC and MK distinguish between ID reports, which is the first byte in the packet. <br>  In our example, there are 4 types of reports: <br><ul><li>  REPORT_ID = 1 and 2 - the MC command to turn on / off the LED1 / LED2.  It contains a 1-bit field with the desired state of the LED and supports sending both by the SET_REPORT method and the SET_FEATURE method (more on this later). </li><li>  REPORT_ID = 3 - sends one byte to the MC.  Just to show how to transfer MK data.  We will transfer the position of the slider. </li><li>  REPORT_ID = 4 is a report for transferring PC data.  Returns information about the current status of the LEDs, buttons (if any) and returns the transmitted in the report with ID = 3 bytes to show that the data has been received. </li></ul><br>  If you have not fully understood how to form a report descriptor, then simply change the RPT3_COUNT and RPT4_COUNT constants, setting the required size of outgoing and incoming (from PC point of view) packets.  The rest of the reports can simply not touch, they do not interfere.  Do not forget that the first byte must be a report ID. <br><br><h4>  Exchange cycle </h4><br>  So, we configured our device by setting the PID, VID, version number, configured the size of incoming and outgoing packets and are ready to go. <br>  Every 32ms, as we requested in the configuration descriptor, the host will poll us and, in the RHIDCheckState function, we check if we have something to send, then we create a data packet for the host. <br><div class="spoiler">  <b class="spoiler_title">RHIDCheckState - data sending function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Function Name : RHIDCheckState. * Description : Decodes the RHID state. * Input : None. * Output : None. * Return value : The state value. *******************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> btn1_prev, btn2_prev; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Buffer[RPT4_COUNT+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> RHIDCheckState(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> btn1=<span class="hljs-number"><span class="hljs-number">0</span></span>, btn2=<span class="hljs-number"><span class="hljs-number">0</span></span>; btn1 = GPIO_ReadInputDataBit(BTN1_PORT, BTN1_PIN); btn2 = GPIO_ReadInputDataBit(BTN2_PORT, BTN2_PIN); Buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; Buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = btn1; Buffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = btn2; Buffer[<span class="hljs-number"><span class="hljs-number">3</span></span>] = (GPIO_ReadInputDataBit(LED_PORT, LED1_PIN) | GPIO_ReadInputDataBit(LED_PORT, LED2_PIN)&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Reset the control token to inform upper layer that a transfer is ongoing */</span></span> PrevXferComplete = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Copy buffer date info in ENDP1 Tx Packet Memory Area*/</span></span> USB_SIL_Write(EP1_IN, Buffer, RPT4_COUNT+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable endpoint for transmission */</span></span> SetEPTxValid(ENDP1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (btn1 | btn2&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br></div></div><br>  The <b>uint8_t Buffer [RPT4_COUNT + 1]</b> array is defined as the size of the payload of the incoming (always viewed from the host's point of view) packet + byte ID.  This is important - if the buffer size is different - there will be problems.  Therefore, to change the buffer size, edit the value of the constant in usb_desc.h. <br>  In the function, we collect data in a packet, set the PrevXferComplete = 0 flag, which says that the data is sent, and call the USB_SIL_Write and SetEPTxValid library functions to send data to the host. <br>  That's it, the transfer of data to the host is complete. <br><br>  Data reception is a bit more complicated - there are two ways to send data to a device ‚Äî one of them is to use the Features described in the report descriptor, with the appropriate parameters via the <b>SET_FEAUTRE</b> function.  This is some kind of abstraction, for beautifully managing a device with a bunch of functions so that you can call meaningful functions, and not just send a stream of bytes. <br>  The second way is to work with the device as with a file ‚Äî simply write the package into it as to a file.  This method is called <b>SET_REPORT</b> .  In fact, it works a little slower. <br>  Our device supports both methods, which we told the host in the report descriptor. <br><br><h5>  SET_FEATURE processing </h5><br>  Data sent by the SET_FEAUTRE method is processed by usb_prop.c <br><br><div class="spoiler">  <b class="spoiler_title">HID_Status_In function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Function Name : HID_Status_In. * Description : HID status IN routine. * Input : None. * Output : None. * Return : None. *******************************************************************************/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HID_Status_In</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ BitAction Led_State; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Report_Buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Led_State = Bit_RESET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Led_State = Bit_SET; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Report_Buf[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Led_State != Bit_RESET) { GPIO_SetBits(LED_PORT,LED1_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPIO_ResetBits(LED_PORT,LED1_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Led_State != Bit_RESET) { GPIO_SetBits(LED_PORT,LED2_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPIO_ResetBits(LED_PORT,LED2_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 1&amp;2 */</span></span> Buffer[<span class="hljs-number"><span class="hljs-number">4</span></span>]=Report_Buf[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br></div></div><br>  Here we check the first byte in the report and process the rest of the packet according to it ‚Äî we control the LEDs or simply take the byte sent to us by the host and put it in the packet for later sending back to the RHIDCheckState function. <br>  Under Report_Buf, wMaxPacketSize bytes is reserved to fit into any packet that the host sends us. <br><br>  Data sent by the SET_REPORT method is processed in usb_endp.c <br><div class="spoiler">  <b class="spoiler_title">EP1_OUT_Callback function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Function Name : EP1_OUT_Callback. * Description : EP1 OUT Callback Routine. * Input : None. * Output : None. * Return : None. *******************************************************************************/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EP1_OUT_Callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ BitAction Led_State; <span class="hljs-comment"><span class="hljs-comment">/* Read received data (2 bytes) */</span></span> USB_SIL_Read(EP1_OUT, Receive_Buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Receive_Buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Led_State = Bit_RESET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Led_State = Bit_SET; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Receive_Buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Led_State != Bit_RESET) { GPIO_SetBits(LED_PORT,LED1_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPIO_ResetBits(LED_PORT,LED1_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Led_State != Bit_RESET) { GPIO_SetBits(LED_PORT,LED2_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPIO_ResetBits(LED_PORT,LED2_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Led 1&amp;2 */</span></span> Buffer[<span class="hljs-number"><span class="hljs-number">4</span></span>]=Receive_Buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } SetEPRxStatus(ENDP1, EP_RX_VALID); }</code> </pre><br></div></div><br>  Here, almost the same thing, you only need to pick up the data yourself by calling USB_SIL_Read (EP1_OUT, Receive_Buffer) and finally report that we ended up by calling SetEPRxStatus (ENDP1, EP_RX_VALID); <br><br>  We learned how to configure the device, transmit and receive data in packets of the required size with the frequency we need. <br>  We assemble the project and flash it into the device. <br>  It will work like this: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/tXuZpR0LMZI%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhioWfd_8KYIVg6A8M-lvmpN7vF-5g" frameborder="0" allowfullscreen=""></iframe><br><br>  The project supports interaction with the USB HID Demonstrator utility from ST Microelectronics. <br>  The Device capabilities page displays the capabilities described in the Report Descriptor. <br>  Input / Output transfer allows you to manually send data to the device and see the package that comes from it. <br>  Graphic view allows you to control LEDs, Led 1, Led 2 checkboxes by setting the corresponding Report ID, as well as transfer a byte with the slider (ReportID = 3) <br><img src="https://habrastorage.org/getpro/habr/post_images/1a5/d76/a97/1a5d76a97741feca055b76b65c7e7e23.png"><br><br>  I also wrote a small demo software that automatically determines the connection to the computer and the disconnection of our device by its VID and PID, displays the status - connected / disconnected by the indicator next to the Auto Connect checkbox <br><img src="https://habrastorage.org/getpro/habr/post_images/248/5b8/0a1/2485b80a183fdbfd8482aea83a16615c.png"><br>  Radio <b>Send Send</b> allows you to select the method for sending data to the device. <br>  <b>Report:</b> displays the packet received from the device byte-by-byte, starting with the ReportID. <br>  Clicking on the LEDs below - control the LEDs of the device.  Their status displays the current state of the device.  Read from the report from the device. <br>  Moving the slider, we send the Report with ID = 3 and the value corresponding to the position of the slider.  The device will return this value in 4 byte report. <br>  In the dropdown combo box, the HID devices found in the system are displayed, and if our device is found, its name is displayed. <br><br>  Download everything you need on <a href="https://github.com/RavWin/RHIDDemo">GitHub</a> .  Composed of: <br>  <b>DT</b> - HID Descriptor tool <br>  <b>tstHID-STM32F103</b> - project for EmBlocks <br>  <b>USB HID Demonstrator</b> - utility from ST Microelectronics <br>  <b>HIDSTM32.exe</b> - my Delphi demo soft on a similar feature, but not requiring configuration <br><br>  If you have any questions - write in the comments.  I will try to answer.  I tried not to drown the essence in a heap of trifles in order to develop a common understanding.  The rest can already be understood by studying the project.  But if you need to quickly make your device, and there is no time to climb into the jungle - I described everything that you need. <br><br>  <b>PS</b> By default, when the host goes into power saving mode, the device goes to sleep with it, and if you connect the device to a sleeping PC, it will also go into a slip.  Therefore, if we just plug the power supply into the device or are powered from the battery, then it will not work, considering that it is connected to the sleeping PC (configuration packages will not come from the power supply exactly).  I changed the library so that the device worked and when I connected, just the BP.  Therefore, the device will work both when connected to a PC and autonomously.  (It took me a long time to figure it out.) </div><p>Source: <a href="https://habr.com/ru/post/208026/">https://habr.com/ru/post/208026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208010/index.html">Suspicion of a secret telecommunications hub</a></li>
<li><a href="../208014/index.html">Backdoor in Linksys and Netgear routers</a></li>
<li><a href="../208016/index.html">Measuring the current-voltage characteristics of the transistor using a Cypress microcontroller</a></li>
<li><a href="../208020/index.html">1058 candidates selected for flight to Mars</a></li>
<li><a href="../208022/index.html">Siemens Logo! - ten years later</a></li>
<li><a href="../208028/index.html">‚ÄúAnd these people forbid us to poke around‚Äù: Huawei and the NSA</a></li>
<li><a href="../208030/index.html">Discoveries of the Outgoing Year - Another Useful Sleep Function</a></li>
<li><a href="../208032/index.html">The clash of two cultures: "I can" and "I can not"</a></li>
<li><a href="../208034/index.html">Machine learning. Yandex course for those who want to spend the New Year holidays with benefit</a></li>
<li><a href="../208036/index.html">OpenWorm - an international project to create a computer model of the worm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>