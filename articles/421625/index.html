<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous Python: Various Forms of Competitiveness</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the advent of Python 3 quite a bit of noise about ‚Äúasynchrony‚Äù and ‚Äúconcurrency‚Äù, it can be assumed that Python recently introduced these feature...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous Python: Various Forms of Competitiveness</h1><div class="post__text post__text-html js-mediator-article">  With the advent of Python 3 quite a bit of noise about ‚Äúasynchrony‚Äù and ‚Äúconcurrency‚Äù, it can be assumed that Python recently introduced these features / concepts.  But it is not.  We have used these operations many times.  In addition, beginners may think that asyncio is the only or best way to recreate and use asynchronous / parallel operations.  In this article, we will look at various ways to achieve concurrency, their advantages and disadvantages. <br><a name="habracut"></a><br><h4>  Definition of terms: </h4><br>  Before we dive into the technical aspects, it is important to have some basic understanding of the terms often used in this context. <br><br>  <b>Synchronous and asynchronous:</b> <br><br>  In <b>synchronous</b> operations, tasks are performed one after another.  In <b>asynchronous</b> tasks can be started and completed independently of each other.  One asynchronous task can be started and continue to execute while execution proceeds to a new task.  Asynchronous tasks <b>do not</b> block (do not make them wait for the task to complete) operations and are usually performed in the background. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, you should contact your travel agent to plan your next vacation.  You need to send a letter to your supervisor before flying away.  In synchronous mode, you first call the travel agency, and if you are asked to wait, then you will wait until you are answered.  Then you start writing a letter to the manager.  Thus, you perform tasks one after another.  <i>[synchronous execution, approx.</i>  <i>translator]</i> But if you are smart, then while you are asked to wait <i>[hang on the phone, approx.</i>  <i>translator]</i> you will begin to write an e-mail and when they talk to you again you will pause the spelling, speak and then finish the letter.  You can also ask a friend to call the agency, and write a letter yourself.  This is asynchronous, tasks do not block each other. <br><br>  <b>Competitiveness and concurrency:</b> <br><br>  Competition implies that two tasks are performed <u>together</u> .  In our previous example, when we looked at an asynchronous example, we gradually advanced either in the writing of the letter or in the conversation with the tour.  agency.  This is <b>competitiveness</b> . <br><br>  When we asked to call a friend and wrote a letter ourselves, the tasks were performed <b>in parallel</b> . <br><br>  Parallelism is essentially a form of competitiveness.  But concurrency depends on hardware.  For example, if there is only one core in a CPU, then two tasks cannot be executed in parallel.  They just divide the CPU time among themselves.  Then this is competitiveness, but not concurrency.  But when we have several cores <i>[like a friend in the previous example, which is the second core, approx.</i>  <i>translator]</i> we can perform several operations (depending on the number of cores) at the same time. <br><br>  Summing up: <br><br><ul><li>  Synchronicity: blocks operations (blocking) </li><li>  Asynchrony: does not block operations (non-blocking) </li><li>  Competitiveness: Joint Progress (Joint) </li><li>  Parallelism: parallel progress (parallel) </li></ul><br>  Parallelism implies competitiveness.  But competitiveness does not always imply concurrency. <br><br><h4>  Threads and Processes </h4><br>  Python has supported threads for a very long time.  Threads allow you to perform operations concurrently.  But there is a problem with the <b>Global Interpreter Lock (GIL)</b> because of which the threads could not provide true concurrency.  Nevertheless, with the advent of <b>multiprocessing,</b> you can use multiple cores using Python. <br><br>  <b>Threads</b> <br><br>  Consider a small example.  In the following code, the <i>worker</i> will execute asynchronously and simultaneously across multiple threads. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = threading.Thread(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Threads are queued, let's see when they finish!"</span></span>)</code> </pre> <br>  Here is an example of the output: <br><br><pre> <code class="python hljs">$ python thread_test.py All Threads are queued, let<span class="hljs-string"><span class="hljs-string">'s see when they finish! I am Worker 1, I slept for 1 seconds I am Worker 3, I slept for 4 seconds I am Worker 4, I slept for 5 seconds I am Worker 2, I slept for 7 seconds I am Worker 0, I slept for 9 seconds</span></span></code> </pre><br>  Thus, we launched 5 threads for collaboration and after their start (that is, after starting the worker function), the operation <b>does not wait</b> for the threads to finish before moving on to the next print statement.  This is an asynchronous operation. <br><br>  In our example, we passed the function to the Thread constructor.  If we wanted, we could implement a subclass with a method (OOP style). <br><br>  <u>Further reading:</u> <br><br>  To learn more about threads, use the link below: <br><br><ul><li>  <a href="https://pymotw.com/3/threading/index.html">pymotw.com/3/threading/index.html</a> </li></ul><br>  <b>Global Interpreter Lock (GIL)</b> <br><br>  GIL was introduced to make CPython memory handling easier and to provide better integration with C (for example, extensions).  GIL is a blocking mechanism when the Python interpreter launches only one thread at a time.  Those.  Only one stream can be executed in Python bytecode at a time.  GIL ensures that multiple threads are not executed <b>in parallel</b> . <br><br>  GIL in brief: <br><br><ul><li>  One thread can run at the same time. </li><li>  The Python interpreter switches between threads to achieve concurrency. </li><li>  GIL is applicable to CPython (standard implementation).  But such as, for example, Jython and IronPython do not have GIL. </li><li>  GIL makes single-threaded programs fast. </li><li>  GIL I / O operations do not usually interfere. </li><li>  GIL makes it easy to integrate non-thread-safe C libraries, thanks to GIL we have many high-performance extensions / modules written in C. </li><li>  For CPU dependent tasks, the interpreter checks every N ticks and switches threads.  Thus, one thread does not block the others. </li></ul><br>  Many see GIL as a weakness.  I consider this as a blessing, because such libraries as NumPy, SciPy, which occupy a special, unique position in the scientific community, were created. <br><br>  <u>Further reading:</u> <br><br>  These resources will allow to go deep into GIL: <br><br><ul><li>  <a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">www.dabeaz.com/python/UnderstandingGIL.pdf</a> </li><li>  <a href="https://habr.com/post/84629/">Article in Russian.</a>  <a href="https://habr.com/post/84629/"><i>[approx.</i></a>  <a href="https://habr.com/post/84629/"><i>translator]</i></a> </li><li>  <a href="https://habr.com/post/238703/">A little more about GIL.</a>  <a href="https://habr.com/post/238703/"><i>[approx.</i></a>  <a href="https://habr.com/post/238703/"><i>translator]</i></a> </li></ul><br>  <b>Processes (Processes)</b> <br><br>  To achieve concurrency in Python, a <b>multiprocessing</b> module has been added, which provides an API, and looks very similar if you have used <b>threading</b> before. <br><br>  Let's just go and change the previous example.  Now the modified version uses <b>Process</b> instead of <b>Flow</b> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = multiprocessing.Process(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Processes are queued, let's see when they finish!"</span></span>)</code> </pre><br>  What has changed?  I just imported a <b>multiprocessing</b> module instead of <b>threading</b> .  And then, instead of a stream, I used a process.  That's all!  Now, instead of multiple threads, we use processes that run on different CPU cores (unless, of course, your processor has several cores). <br><br>  Using the Pool class, we can also distribute the execution of a single function among several processes for different input values.  Example from official documents: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pool <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Pool(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(p.map(f, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]))</code> </pre><br>  Here, instead of going through the list of values ‚Äã‚Äãand calling the function f one by one, we actually run the function in different processes.  One process performs f (1), the other f (2), and the other f (3).  Finally, the results are again combined into a list.  This allows us to break the heavy calculations into smaller parts and run them in parallel for faster calculation. <br><br>  <u>Further reading:</u> <br><br><ul><li>  <a href="https://pymotw.com/3/multiprocessing/index.html">pymotw.com/3/multiprocessing/index.html</a> </li></ul><br>  <b>Module concurrent.futures</b> <br><br>  The concurrent.futures module is large and makes writing asynchronous code very easy.  My favorites <b>ThreadPoolExecutor</b> and <b>ProcessPoolExecutor</b> .  These implementers maintain a pool of threads or processes.  We send our tasks to the pool, and it runs the tasks in an accessible thread / process.  A <b>Future</b> object is returned, which can be used to query and retrieve the result upon completion of the task. <br><br>  Here is an example of ThreadPoolExecutor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ThreadPoolExecutor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sleep <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_after_5_secs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message pool = ThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">3</span></span>) future = pool.submit(return_after_5_secs, (<span class="hljs-string"><span class="hljs-string">"hello"</span></span>)) print(future.done()) sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(future.done()) print(future.result())</code> </pre><br>  I have an article about concurrent.futures <a href="http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html">masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html</a> .  It may be useful for a deeper study of this module. <br><br>  <u>Further reading:</u> <br><br><ul><li>  <a href="https://pymotw.com/3/concurrent.futures/">pymotw.com/3/concurrent.futures</a> </li></ul><br><h4>  Asyncio - what, how and why? </h4><br>  You probably have a question that many people in the Python community have - what does new asyncio bring?  Why was another asynchronous I / O needed?  Have we not already had threads and processes?  Let's watch! <br><br>  <b>Why do we need asyncio?</b> <br><br>  The processes are very expensive <i>[in terms of resource consumption, approx.</i>  <i>translator]</i> to create.  Therefore, for I / O operations, threads are mainly selected.  We know that I / O depends on external things ‚Äî slow disks or unpleasant network lags make I / O often unpredictable.  Now suppose we are using threads for I / O operations.  3 threads perform various I / O tasks.  The interpreter would have to switch between competitive streams and give each of them some time in turn.  Let's call the streams - T1, T2 and T3.  Three threads started their I / O operation.  T3 completes it first.  T2 and T1 are still waiting for I / O.  The Python interpreter switches to T1, but it is still waiting.  Well, the interpreter moves to T2, but it still waits, and then moves to T3, which is ready and executes the code.  Do you see this as a problem? <br><br>  T3 was ready, but the interpreter first switched between T2 and T1 - it incurred switching costs, which we could have avoided if the interpreter first switched to T3, right? <br><br>  <b>What is asynio?</b> <br><br>  Asyncio provides us with a cycle of events along with other cool things.  The event loop monitors I / O events and switches tasks that are ready and waiting for an I / O operation <i>[event loop is a software construct that waits for arrival and sends out events or messages in the program, approx.</i>  <i>translator]</i> . <br><br>  The idea is very simple.  There is an event loop.  And we have functions that perform asynchronous I / O operations.  We pass our functions to the event loop and ask it to run them for us.  The event loop returns the Future object to us, like a promise that in the future we will get something.  We hold on to the promise, check from time to time whether it matters (we are very impatient), and finally, when the value is received, we use it in some other operations <i>[i.e.</i>  <i>we sent a request, we were immediately given a ticket and told to wait until the result came.</i>  <i>We periodically check the result and as soon as it is received, we take a ticket and get the value from it, approx.</i>  <i>translator]</i> . <br><br>  Asyncio uses generators and korutiny for stopping and resuming tasks.  You can read the details here: <br><br><ul><li>  <a href="http://masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html">masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html</a> </li><li>  <a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html">masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a> </li></ul><br>  <b>How to use asyncio?</b> <br><br>  Before we begin, let's take a look at an example: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_sleep_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_date</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num, loop)</span></span></span><span class="hljs-function">:</span></span> end_time = loop.time() + <span class="hljs-number"><span class="hljs-number">50.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Loop: {} Time: {}"</span></span>.format(num, datetime.datetime.now())) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loop.time() + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) &gt;= end_time: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_sleep_func() loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">1</span></span>, loop)) asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">2</span></span>, loop)) loop.run_forever()</code> </pre><br>  Please note that the async / await syntax is for Python 3.5 and above only.  Let's go through the code: <br><br><ul><li>  We have the asynchronous function display_date, which takes a number (as an identifier) ‚Äã‚Äãand an event loop as parameters. </li><li>  The function has an infinite loop, which is interrupted after 50 seconds.  But during this period, she repeatedly prints the time and pauses.  The await function can wait for other asynchronous functions to complete (corutin). </li><li>  Pass the function to the event loop (using the ensure_future method). </li><li>  We start a cycle of events. </li></ul><br>  Whenever an await call occurs, asyncio understands that functions will probably take some time.  Thus, it pauses execution, starts monitoring any I / O event associated with it, and allows you to run tasks.  When asyncio notices that the suspended I / O function is ready, it resumes the function. <br><br><h4>  Making the right choice </h4><br>  We have just walked through the most popular forms of competition.  But the question remains - what should I choose?  It depends on the use cases.  From my experience, I tend to follow this pseudo code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_bound: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_very_slow: print(<span class="hljs-string"><span class="hljs-string">"Use Asyncio"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Use Threads"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Multi Processing"</span></span>)</code> </pre><br><ul><li>  CPU Bound =&gt; Multi Processing </li><li>  I / O Bound, Fast I / O, Limited Number of Connections =&gt; Multi Threading </li><li>  I / O Bound, Slow I / O, Many connections =&gt; Asyncio </li></ul><br>  <i>[Approx.</i>  <i>translator]</i> <br><br><ul><li>  <a href="https://compscicenter.ru/media/slides/python_2015_autumn/2015_12_07_python_2015_autumn_3KfewPJ.pdf">Lecture (presentation) in Russian about multi-threading and GIL.</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/421625/">https://habr.com/ru/post/421625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421607/index.html">‚ÄúWe don‚Äôt even try to run the old code, we don‚Äôt have such a task in principle‚Äù - Roman Elizarov about the development of Kotlin</a></li>
<li><a href="../421611/index.html">How World of Warcraft was created: an inside look at 20 years of development</a></li>
<li><a href="../421613/index.html">How we write articles on Habr: developer experience EastBanc Technologies</a></li>
<li><a href="../421615/index.html">The solution to the absence of prevProps in getDerivedStateFromProps</a></li>
<li><a href="../421619/index.html">Autonomous systems of the future. Classification, features and requirements</a></li>
<li><a href="../421629/index.html">Will robots take my job? (And if I am a humanist?)</a></li>
<li><a href="../421631/index.html">Review of the Lenovo ThinkPad X1 Carbon (2018) laptop: easy, convenient, powerful</a></li>
<li><a href="../421633/index.html">How to make a standard in 10 days</a></li>
<li><a href="../421637/index.html">Kids watch with GPS by September 1: what you can pay attention</a></li>
<li><a href="../421639/index.html">Chinese laptop Jumper EZBook X4 - backlit keyboard and new platform Gemini Lake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>