<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simulate sensor readings using an array of waypoints</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publication structure 


- Roll forward clause 
- Preparing a GPS track 
- How to get Krylov-Euler angles from an array of vectors 
- Imitation of gyr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simulate sensor readings using an array of waypoints</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b10/6ad/4f5/b106ad4f57fb4778ae0a95e4036b39fa.jpeg"><br><br><h4>  Publication structure </h4><br><ul><li>  Roll forward clause </li><li>  Preparing a GPS track </li><li>  How to get Krylov-Euler angles from an array of vectors </li><li>  Imitation of gyroscope readings </li><li>  The vector of acceleration of gravity and the direction of "north" </li><li>  Simulation of accelerometer, compass and barometer readings </li></ul><br><br>  To debug the algorithm, working with inertial navigation sensors, you may need to simulate the readings of these sensors.  For example, you have a debugging sequence of waypoints simulating a certain situation.  You can have some kind of GPS-track, which has features, or not having them.  In my case, there is a field test result, but the board is not ready yet (in production) - you need to do something. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Roll forward clause </h4><br>  It should be immediately noted that when moving, the 3D point does not give us information about the position of the body relative to the axis of movement.  If we imagine that a thread is stretched between the points of the path, and our object is a bead, then it will move along the thread clearly, and can rotate freely around the axis of motion.  As the direction of motion we will use the velocity vector and we will remember the reservation about the roll in the result. <br><br><img src="https://habrastorage.org/files/c90/ff9/74c/c90ff974cecb4be8998651801d18c026.jpg"><br><br><h4>  Preparing a GPS track </h4><br>  If you have a GPS track as source data, you need to first prepare it.  It is required to convert the existing file to a format from which data can be obtained.  I converted to GPX (since inside it is XML). <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">trkpt</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"12.345678"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"87.654321"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ele</span></span></span><span class="hljs-tag">&gt;</span></span>839<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ele</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span>2013-05-09T11:24:28.776Z<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extensions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mytracks</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"194.9"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">s</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"9.25"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extensions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">trkpt</span></span></span><span class="hljs-tag">&gt;</span></span> . . . <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">trkpt</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"12.345678"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"87.654321"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ele</span></span></span><span class="hljs-tag">&gt;</span></span>837<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ele</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span>2013-05-09T11:24:31.779Z<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extensions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mytracks</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"195.7"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">s</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"8.68"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extensions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">trkpt</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Next, we take any available database (for example, MySQL), create a label and fill it with data from the received XML.  The XML format may be different - the main thing is to find the latitude, longitude, altitude and time.  We create the first label, for example 'xml_src'.  All columns for ease of loading do string. <br><br><img src="https://habrastorage.org/files/c3e/7fc/05e/c3e7fc05e52c4a36b960805d1687cd05.png"><br><br>  Let's get some data.  For convenience, create a second table, for example, 'points'.  MySQL code: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points (lat,lon,h,dt) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(xx.lat <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) , <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(xx.lon <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) , <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(xx.ele <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) , <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(xx.<span class="hljs-string"><span class="hljs-string">`time`</span></span>, <span class="hljs-string"><span class="hljs-string">"T"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>), <span class="hljs-string"><span class="hljs-string">"Z"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> DATETIME) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xml_src <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xx;</code> </pre><br>  As a result, we have the following: <br><img src="https://habrastorage.org/files/8da/492/f9e/8da492f9e375409e91d713278473ed39.png"><br><br>  Then we translate latitude and longitude into meters (see the article <a href="http://habrahabr.ru/post/143898/">‚ÄúEntertaining Geodesy‚Äù</a> or use database tools, for example, in MSSQL, see the <a href="https://msdn.microsoft.com/ru-ru/library/microsoft.sqlserver.types.sqlgeography.shortestlineto.aspx">ShortestLineTo</a> method).  Convert to meters as follows.  We assume that the coordinates of the first point are X = 0, Y = 0. The coordinates of each subsequent point are relative to the first one.  We determine the distance between the points, first vertically, then horizontally in meters.  The function for calculating the distance is in the article <a href="http://special.habrahabr.ru/kyocera/p/179157/">‚ÄúDetermining the distance between geographic points in MySQL‚Äù</a> . <br><br><img src="https://habrastorage.org/files/1ee/413/b5f/1ee413b5f8f3474c998b8e9e80d9b694.png"><br><br>  We translate the time in seconds so that the first line has 0 seconds (just subtract the value of the first line from the rest). <br><br><div class="spoiler">  <b class="spoiler_title">Request for mysql</b> <div class="spoiler_text">  For convenience, we will create the third label 'track' and the function 'geodist' by the coordinates of two points returning the distance in meters. <br><pre> <code class="sql hljs">FUNCTION geodist(src_lat DECIMAL(9, 6), src_lon DECIMAL(9, 6), dst_lat DECIMAL(9, 6), dst_lon DECIMAL(9, 6) ) RETURNS decimal(11,3) DETERMINISTIC <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @dist := <span class="hljs-number"><span class="hljs-number">6371000</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">asin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">power</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((src_lat - <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(dst_lat)) * <span class="hljs-keyword"><span class="hljs-keyword">pi</span></span>() / <span class="hljs-number"><span class="hljs-number">180</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(src_lat * <span class="hljs-keyword"><span class="hljs-keyword">pi</span></span>() / <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(dst_lat) * <span class="hljs-keyword"><span class="hljs-keyword">pi</span></span>() / <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">power</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((src_lon - dst_lon) * <span class="hljs-keyword"><span class="hljs-keyword">pi</span></span>() / <span class="hljs-number"><span class="hljs-number">180</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>) )); RETURN @dist; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br>  Then we select the starting point and use its coordinates in the query.  We will measure the distance from this point to each next vertically and horizontally in meters. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> track (x, y, z, dt) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">42.302929</span></span> &gt; pp.lat, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) * geodist(<span class="hljs-number"><span class="hljs-number">42.302929</span></span>, <span class="hljs-number"><span class="hljs-number">18.891985</span></span>, pp.lat, <span class="hljs-number"><span class="hljs-number">18.891985</span></span>) , <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">18.891985</span></span> &gt; pp.lon, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) * geodist(<span class="hljs-number"><span class="hljs-number">42.302929</span></span>, <span class="hljs-number"><span class="hljs-number">18.891985</span></span>, <span class="hljs-number"><span class="hljs-number">42.302929</span></span>, pp.lon) , h , dt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> pp;</code> </pre><br></div></div><br>  As a result, we have the following: <br><img src="https://habrastorage.org/files/944/abc/25f/944abc25fe8d419a82b95d48828040c1.png"><br><br>  Now we need to get the coordinates of the point at regular intervals.  The fact that the second point appeared 4 seconds after the first, the third after 2 seconds, and the next after a second does not suit us so much.  Are we going to imitate the sensors?  And they measure values ‚Äã‚Äãat equal intervals of time. <br><br>  To obtain the coordinates of a point at regular intervals, we use interpolation.  As an interpolation tool we use a one-dimensional <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D0%25B1%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2581%25D0%25BF%25D0%25BB%25D0%25B0%25D0%25B9%25D0%25BD">cubic spline</a> .  I had Excel at hand, I wrote a macro in it (see spoiler).  At this stage we decide with what frequency each ‚Äúsensor‚Äù will work.  For example, all ‚Äúsensors‚Äù will give values ‚Äã‚Äã10 times per second.  That is, the interval between measurements is 0.1 seconds. <br><div class="spoiler">  <b class="spoiler_title">Cubic Spline on VB</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> interpolate() <span class="hljs-comment"><span class="hljs-comment">'------------------------ Dim i As Integer Const start_n As Integer = 0 Const n As Integer = 1718 Dim src_x(n) As Double Dim src_y(n) As Double Dim spline_x(n) As Double Dim spline_a(n) As Double Dim spline_b(n) As Double Dim spline_c(n) As Double Dim spline_d(n) As Double For i = start_n To n - 1 spline_x(i) = Application.ActiveWorkbook.ActiveSheet.Cells(i + 1, 1).Value spline_a(i) = Application.ActiveWorkbook.ActiveSheet.Cells(i + 1, 2).Value src_x(i) = spline_x(i) src_y(i) = spline_a(i) Next spline_c(0) = 0 Dim alpha(n - 1) As Double Dim beta(n - 1) As Double Dim a As Double Dim b As Double Dim c As Double Dim F As Double Dim h_i As Double Dim h_i1 As Double Dim z As Double Dim x As Double alpha(0) = 0 beta(0) = 0 For i = start_n + 1 To n - 2 h_i = src_x(i) - src_x(i - 1) h_i1 = src_x(i + 1) - src_x(i) If (h_i = 0) Or (h_i1 = 0) Then MsgBox ("!  " + CStr(i + 1) + "     X!   !") Exit Sub End If a = h_i c = 2 * (h_i + h_i1) b = h_i1 F = 6 * ((src_y(i + 1) - src_y(i)) / h_i1 - (src_y(i) - src_y(i - 1)) / h_i) z = (a * alpha(i - 1) + c) alpha(i) = -b / z beta(i) = (F - a * beta(i - 1)) / z Next spline_c(n - 1) = (F - a * beta(n - 2)) / (c + a * alpha(n - 2)) For i = n - 2 To start_n + 1 Step -1 spline_c(i) = alpha(i) * spline_c(i + 1) + beta(i) Next For i = n - 1 To start_n + 1 Step -1 h_i = src_x(i) - src_x(i - 1) spline_d(i) = (spline_c(i) - spline_c(i - 1)) / h_i spline_b(i) = h_i * (2 * spline_c(i) + spline_c(i - 1)) / 6 + (src_y(i) - src_y(i - 1)) / h_i Next '------------------------------- ' my Dim dx As Double Dim j As Integer Dim k As Integer Dim y As Double row_num = 1 For x = 0 To 3814 Step 0.1 i = 0 j = n - 1 Do While i + 1 &lt; j k = i + (j - i) / 2 If x &lt;= spline_x(k) Then j = k Else i = k End If Loop dx = x - spline_x(j) y = spline_a(j) + (spline_b(j) + (spline_c(j) / 2 + spline_d(j) * dx / 6) * dx) * dx Application.ActiveWorkbook.ActiveSheet.Cells(row_num, 3).Value = x Application.ActiveWorkbook.ActiveSheet.Cells(row_num, 4).Value = y row_num = row_num + 1 Next End Sub</span></span></code> </pre><br></div></div><br>  Interpolate in pairs: <br><ol><li>  Time is X </li><li>  Time - Y </li><li>  Time - Z </li></ol><br><img src="https://habrastorage.org/files/d71/5e1/0b7/d715e10b761e49c58043d513ee7e5bd1.png"><br><br>  The result is a table with the coordinates of the points of the ‚Äúobject‚Äù in which our ‚Äúsensors‚Äù are located.  The time interval between points is 0.1 seconds.  The time of appearance of the coordinates of a particular point is calculated by the formula t = n / 10, where n is the line number. <br><br><img src="https://habrastorage.org/files/37c/801/47f/37c80147fa764510a49f34d315107980.png"><br><br><h4>  How to get Krylov-Euler angles from an array of vectors </h4><br>  Take the movement of the nose of the aircraft from my previous <a href="http://habrahabr.ru/post/255005/">article</a> : <br><img src="https://habrastorage.org/files/085/cc2/a97/085cc2a97dc745aa893700b61822af40.png"><img src="https://habrastorage.org/files/997/849/1e8/9978491e80ac4e15a25e1dd98215038e.png"><br><br><img src="https://habrastorage.org/files/bd1/278/001/bd1278001084462aaf553ab7be6d3d71.png"><img src="https://habrastorage.org/files/abf/c5c/9ac/abfc5c9ac38946babd5308982d4ed048.png"><br><br>  The coordinates of the point meaning the nose are equal: <br><img src="https://habrastorage.org/files/b49/401/8ad/b494018ad0214b2284135175f605c698.png"><br><br>  Let's define all three turns.  To do this, we obtain the axis of the first rotation v and the angle of the first rotation alf around the axis.  Let the points of the path are the vertices of the vectors.  Then the axis is obtained by multiplying the neighboring vectors. <br><br>  v12 = v1 * v2 = (1; 0; 0) * (0; 1; 0) = (0; 0; 1) <br><br>  The angle is calculated as follows: <br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> vectors_angle(v1 As TVector, v2 As TVector) As Double v1 = normal(v1) v2 = normal(v2) vectors_angle = Application.WorksheetFunction.Acos(v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span></code> </pre><br>  Alf12 = 90. Now create a quaternion based on the resulting axes and angles: <br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> create_quat(rotate_vector As TVector, rotate_angle As Double) As TQuat rotate_vector = normal(rotate_vector) create_quat.w = <span class="hljs-built_in"><span class="hljs-built_in">Cos</span></span>(rotate_angle / <span class="hljs-number"><span class="hljs-number">2</span></span>) create_quat.x = rotate_vector.x * <span class="hljs-built_in"><span class="hljs-built_in">Sin</span></span>(rotate_angle / <span class="hljs-number"><span class="hljs-number">2</span></span>) create_quat.y = rotate_vector.y * <span class="hljs-built_in"><span class="hljs-built_in">Sin</span></span>(rotate_angle / <span class="hljs-number"><span class="hljs-number">2</span></span>) create_quat.z = rotate_vector.z * <span class="hljs-built_in"><span class="hljs-built_in">Sin</span></span>(rotate_angle / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span></code> </pre><br>  We get the first quaternion: <br><br>  (w = 0.7071; x = 0; y = 0; z = 0.7071) <br><br>  From the quaternion we get the rotation components: <br><pre> <code class="vbscript hljs"> sqw = w * w sqx = x * x sqy = y * y sqz = z * z bank = atan2(<span class="hljs-number"><span class="hljs-number">2</span></span> * (w * x + y * z), <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (sqx + sqy)) altitude = Application.WorksheetFunction.Asin(<span class="hljs-number"><span class="hljs-number">2</span></span> * (w * y - x * z)) heading = atan2(<span class="hljs-number"><span class="hljs-number">2</span></span> * (w * z + x * y), <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (sqy + sqz))</code> </pre><br>  The result of determining the first turn: course = 90, pitch = 0, roll = 0. <br><br>  We cannot calculate the remaining turns, because after the first turn, the local coordinate system of the aircraft no longer coincides with the global coordinate system.  To determine the second turn from the position of the nose of the aircraft No. 2 to the position No. 3, you must first cancel the first turn, that is, return the reporting system to the place and with it unfold a new resultant vector.  This requires obtaining the inverse quaternion of the first reversal and applying it to vectors ‚Ññ2 and ‚Ññ3 (obtaining the inverse quaternion and rotating the vector by the quaternion - see the <a href="http://habrahabr.ru/post/255005/">article</a> ). <br>  Reverse quaternion of the first turn (rotation counterclockwise along the Z axis): <br><br>  (w = 0.7071; x = 0; y = 0; z = -0.7071) <br><br>  After applying this quaternion, the second and third vectors are equal: <br>  v2 = (x = 1; y = 0; z = 0) <br>  v3 = (x = 0; y = 0; z = -1) <br><br><img src="https://habrastorage.org/files/400/592/3a7/4005923a7ff847bfa935797c016b47c4.png"><img src="https://habrastorage.org/files/b58/ad3/26c/b58ad326cb1c4f83bfe75534b9e6fe85.png"><br><br>  When the local coordinate system is aligned with the global one, it is possible to calculate the second quaternion and the components of the second rotation as described above: <br><br>  (w = 0.7071; x = 0; y = 0; z = -0.7071), <br>  course = 0, pitch = 90, roll = 0. <br><br>  Next, we must memorize the perfect turns in the local coordinate system.  To do this, we will create a separate quaternion and multiply the quaternions of turns into it: <br><img src="https://habrastorage.org/files/348/7bf/b5c/3487bfb5cc224cc1a81d048d05d1a02f.png"><br><br>  Then from the quaternion of the series of perfect turns we will receive the inverse quaternion for combining the reporting systems. <br><br>  Summarize.  To get the components of the turns on the list of vectors that indicate the direction of motion, you need to do the following: <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'  " " q_mul.w = 1 q_mul.x = 0 q_mul.y = 0 q_mul.z = 0 For row_n = M To N '     v1.x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - 1, 1).Value v1.y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - 1, 2).Value v1.z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - 1, 3).Value '     v2.x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 1).Value v2.y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 2).Value v2.z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 3).Value '        q_inv = myMath.quat_invert(q_mul) '    v1 = myMath.quat_transform_vector(q_inv, v1) '    '        (length(v1); 0; 0) ‚Äì    v2 = myMath.quat_transform_vector(q_inv, v2) '    '     r12 = myMath.vecmul(v1, v2) '   alf = myMath.vectors_angle(v1, v2) '     q12 = myMath.create_quat(r12, alf) '         '    ypr = myMath.quat_to_krylov(q12) Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 4).Value = ypr.heading Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 5).Value = ypr.altitude Application.ActiveWorkbook.ActiveSheet.Cells(row_n, 6).Value = ypr.bank '     q_mul = myMath.quat_mul_quat(q_mul, q12) '   Next</span></span></code> </pre><br>  In this macro for Excel, the vectors are read from the first three bars.  The result is written in 4, 5, 6 column. <br><br><h4>  Imitation of gyroscope readings </h4><br>  As you understand, the coordinates of the points are not suitable as input data - we need velocity vectors. <br><br>  It is easy to get speed and acceleration from the prepared data - the difference between the adjacent lines of the point coordinates table is the speed, the difference between the adjacent speed lines is the acceleration.  Just need to remember about the frequency of measurements.  In this case, we have 10 "measurements" per second.  This means that in order to get, for example, the speed in meters per second, you need to multiply the value of the corresponding cell by 10. <br><br><img src="https://habrastorage.org/files/fd3/19e/769/fd319e7697fc4d06b69566aec658eb33.png"><br><br>  Take the velocity vectors and get the rotation components. <br><br><img src="https://habrastorage.org/files/34b/9d0/9a0/34b9d09a0acd46dd82a016da1ec6ec57.png"><br><br>  Now about the gyroscope.  Gyro shows angular velocity.  Our components of turns in the local coordinate system at equal intervals of time - this is the angular velocity. <br><br>  In addition to obtaining the angular velocity, you need to add more noise.  There are two tangible components in the gyroscope noise - the sensor's own noise (uniform distribution) and the effect of the earth's rotation (if your ‚Äúsensor‚Äù is not in space).  The intrinsic noise level of the sensor is described in the specification (we study the datasheet on the simulated sensor).  My sensor has a resolution of 16 bits and has 4 measurement modes.  Each mode has its maximum: the first one has ¬± 250¬∫ / sec, ... the fourth one has ¬± 2000¬∫ / sec.  Sensitivity for the first mode 131 LSB / (¬∫ / s).  To calculate this in degrees, you need to use the formula: <br><br>  Sensitivity = Sensitivity_LSB * Maximum / Resolution = 131 * ¬± 250 / (2 ^ 16) = 131 * ¬± 250/65536 = ¬± 0.49972534 ¬∫ / sec. <br><br>  That is, the magnitude of the noise within one degree.  Formula for Excel: <br>  = (RIP () - 0.5) / N, where N is the number of simulated "measurements" per second. <br><br>  The earth rotates at a speed of 15 degrees per hour.  This is 0.0041667 degrees per second, which is much less than the measurement error.  For fun, you can calculate it. <br><br>  Suppose that the axis of rotation of the Earth coincides with the axis Z. Suppose also that the body is at the equator and the axis Y of the body is oriented strictly to the north (tangential).  Then the axis X of the body coincides with the tangent direction of rotation.  In this case, the axis of rotation of the Earth and the body along with it coincides with the axis Z of the body.  Let us visualize the displacement in the latitude of our body to the north.  Then the axis of rotation will rotate around the X axis clockwise by a number of degrees equal to the value of the new latitude.  When shifting to the northern hemisphere, it is a plus sign, to the southern one, it is a minus sign.  When the body is freely oriented in space, the free fall acceleration vector g will help us. <br><br><img src="https://habrastorage.org/files/b1a/3c0/d6b/b1a3c0d6bbd745869d1bc6534caee1e7.png"><img src="https://habrastorage.org/files/9ce/d64/f81/9ced64f815c94422ae369fd7cf49c651.png"><br><br>  To calculate the axis of rotation of the Earth in the local coordinate system, you need: <br><ol><li>  Multiply the vector g by the vector of the compass reading "north". </li><li>  Create a quaternion based on the resulting vector and angle.  We take latitude as the angle value. </li><li>  Expand the resulting quaternion vector compass "to the north." </li></ol><br><br>  To obtain the values ‚Äã‚Äãof the rotation of our body by the planet at the time of each measurement we do: <br><ol><li>  We calculate the vector of the axis of rotation of the planet using the current latitude from the source data. </li><li>  Calculate how much the planet has turned since the last measurement.  In our case, when measured 10 times per second, it will be 0.0041667 / 10 = 0.00041667. </li><li>  We build a quaternion on the basis of the axis vector and the rotation angle. </li><li>  We get the three components of the reversal (course, pitch, roll) and add to the readings of the ‚Äúsensor‚Äù. </li></ol><br><br>  In general, as a result, we get the table: <br><img src="https://habrastorage.org/files/835/f90/508/835f905088e54c25bf7c899c913a29c9.png"><br><br>  The last three columns are ‚Äúgyro readings‚Äù. <br><br><h4>  The vector of acceleration of gravity and the direction of "north" </h4><br>  Suppose that there is a unit vector C, which coincides with the tangent to the meridian and the direction "south" -&gt; "north".  Let the Y axis of our global coordinate system coincides with the vector C = (0, 1, 0).  And the vector of gravitational acceleration g is directed along the Z axis, but in the opposite direction.  g = (0, 0, -1).  Then, if we explicitly indicate the velocity vector of the body at the initial moment of time as H = (1, 0, 0), then all turns obtained on the basis of the rotations of the velocity vector will also be applicable for the rotations of the vectors g and C. Rotate these vectors should be inverse quaternion.  Reverse from the quaternion, which accumulates all the perfect turns of the velocity vector (q_mul). <br><br>  It is enough to add a couple of lines to the procedure for calculating the rotation angles.  Now it looks like this: <br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> calc_all() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> v1 As myMath.TVector <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> v2 As myMath.TVector <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> r12 As myMath.TVector <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> m12 As myMath.TMatrix <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> q12 As myMath.TQuat <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> q_mul As myMath.TQuat <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> q_inv As myMath.TQuat <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> ypr As myMath.TKrylov <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> alf As Double <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> row_n As Long <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> g As myMath.TVector <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> nord As myMath.TVector q_mul.w = <span class="hljs-number"><span class="hljs-number">1</span></span> q_mul.x = <span class="hljs-number"><span class="hljs-number">0</span></span> q_mul.y = <span class="hljs-number"><span class="hljs-number">0</span></span> q_mul.z = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> row_n = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">38142</span></span> v1.x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Value v1.y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).Value v1.z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).Value v2.x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">1</span></span>).Value v2.y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">2</span></span>).Value v2.z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">3</span></span>).Value gx = <span class="hljs-number"><span class="hljs-number">0</span></span> gy = <span class="hljs-number"><span class="hljs-number">0</span></span> gz = <span class="hljs-number"><span class="hljs-number">-1</span></span> nord.x = <span class="hljs-number"><span class="hljs-number">0</span></span> nord.y = <span class="hljs-number"><span class="hljs-number">1</span></span> nord.z = <span class="hljs-number"><span class="hljs-number">0</span></span> q_inv = myMath.quat_invert(q_mul) v1 = myMath.quat_transform_vector(q_inv, v1) v2 = myMath.quat_transform_vector(q_inv, v2) g = myMath.quat_transform_vector(q_inv, g) nord = myMath.quat_transform_vector(q_inv, nord) r12 = myMath.vecmul(v1, v2) alf = myMath.vectors_angle(v1, v2) q12 = myMath.create_quat(r12, alf) ypr = myMath.quat_to_krylov(q12) Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">4</span></span>).Value = ypr.heading Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">5</span></span>).Value = ypr.altitude Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number"><span class="hljs-number">6</span></span>).Value = ypr.bank Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>).Value = gx Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>).Value = gy Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>).Value = gz Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>).Value = nord.x Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>).Value = nord.y Application.ActiveWorkbook.ActiveSheet.Cells(row_n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>).Value = nord.z q_mul = myMath.quat_mul_quat(q_mul, q12) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span></code> </pre><br>  The first three columns are the velocity vector, with an explicitly indicated direction at the first point.  This is the input.  Then three columns - calculated rotation angles.  Further, the direction vector "to the north" and the vector of acceleration of free fall.  Finally, the three bars are simulated gyro readings. <br><br><img src="https://habrastorage.org/files/73c/d57/b4c/73cd57b4c1f34ba5bcc8e6992a4ade6d.png"><br><br><h4>  Simulation of accelerometer, compass and barometer readings </h4><br>  Since we have all the movement along the velocity vector, then the acceleration is also directed along the velocity vector - this means along the X axis. The acceleration sensor readings consist of three tangible components: the acceleration of free fall, the noise and the actual acceleration of the body: <br><br>  a = (x = length (a), 0, 0); <br>  A = a + (9.8 / N) * g + rnd, <br>  where a is the acceleration vector calculated from the input data, <br>  N is the number of simulated measurements per second, <br>  g is the vector of gravitational acceleration, <br>  rnd - noise. <br>  The magnitude of the noise again depends on the simulated sensor.  To calculate we look at the specification and use the same formula: <br><br>  Sensitivity = Sensitivity_LSB * Maximum / Resolution = 16.384 * ¬± 2/65536 = ¬± 0.0005 g = ¬± 0.0049 m / s2. <br><br>  Then you can slightly degrade the result and express the simulated acceleration sensor readings with simple formulas: <br>  Ax = length (a) + gx * 9.8 / N + random (0.01) - 0.005 <br>  Ay = gy * 9.8 / N + random (0.01) - 0.005 <br>  Az = gz * 9.8 / N + random (0.01) - 0.005 <br><br>  Compass measurement range in specifications is given in <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D0%25BB%25D0%25B0_(%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B0_%25D0%25B8%25D0%25B7%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F)">Teslah</a> .  Earth's magnetic field will be at the level of 0.00005 T = 50 uT.  Calculate the sensitivity of the same formula: <br><br>  Sensitivity = 15uT * ¬± 4800uT / 65536 = ¬± 1uT. <br><br>  This gives a variation within 4%.  Since the readings of the compass somehow lead to the vector "to the north", then you can simply take the calculated vector as the readings of the compass and "degrade" each component by 4%: <br>  mx = Cx + random (2) - 1 <br>  my = Cy + random (2) - 1 <br>  mz = Cz + random (2) - 1. <br><br>  With a barometer is still easier.  Their readings are given to a height in meters, the spread is usually within a meter (see specification, sometimes less).  If you need direct readings of the sensor in Pa - see <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0">barometric formula</a> .  And so <br><br>  h = Z + random (1) - 0.5. <br><br>  That's all.  Who liked - do not forget to put a plus sign.  If you want an article on the topic of the inverse problem (from sensors to points of the way) - write in the comments. </div><p>Source: <a href="https://habr.com/ru/post/255329/">https://habr.com/ru/post/255329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255317/index.html">openEMS is an open source electromagnetic simulator</a></li>
<li><a href="../255321/index.html">Create a fully automatic farm (finished implementation)</a></li>
<li><a href="../255323/index.html">We are switching from STM32 to the Russian K1986BE92QI microcontroller. Setting up the project in keil and flashing LED</a></li>
<li><a href="../255325/index.html">Malefactors use complex malware to attack Russian business</a></li>
<li><a href="../255327/index.html">Why one AJAX is not enough: WAMP protocol</a></li>
<li><a href="../255331/index.html">Vulnerability in Xamarin for Android: we replace dll and we eat for free</a></li>
<li><a href="../255333/index.html">New adware is embedded directly in the browser.</a></li>
<li><a href="../255337/index.html">How does a boiler house in Middle Akhtuba differ from a power center of a data center?</a></li>
<li><a href="../255339/index.html">Hardware room (about satellite network infrastructure and oscilloscope)</a></li>
<li><a href="../255343/index.html">How we fought xss / sql attack with Nginx and Naxsi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>