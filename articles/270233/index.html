<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About Parboiled</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. Why Parboiled? 
 Today, in the light of the rapid growth of the popularity of functional programming languages, parser combinators, tools that...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">ğŸ”</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">ğŸ“œ</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">â¬†ï¸</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">â¬‡ï¸</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About Parboiled</h1><div class="post__text post__text-html js-mediator-article"><h4>  Part 1. Why Parboiled? </h4><br>  Today, in the light of the rapid growth of the popularity of functional programming languages, parser combinators, tools that facilitate the analysis of mere mortals, are increasingly being used.  Libraries such as <a href="https://wiki.haskell.org/Parsec">Parsec</a> (Haskell) and <a href="https://bitbucket.org/camlspotter/planck">Planck</a> (OCaml) have already managed to prove themselves well in their ecosystems.  Their convenience and capabilities at one time prompted the creator of the Scala language, Martin Oderski, to add their analogue - <a href="https://github.com/scala/scala-parser-combinators">Scala Parser Combinators</a> (now rendered in <a href="http://mvnrepository.com/artifact/org.scala-lang.modules">scala-modules</a> ) to the standard library, and the knowledge and ability to use such tools - are attributed to mandatory requirements for Scala-developers <a href="http://www.scala-lang.org/old/node/8610">level A3</a> . <br><br>  This series of articles is devoted to the <a href="https://github.com/sirthias/parboiled">Parboiled</a> library, a powerful alternative and possible replacement for the Scala Parser Combinators.  In it, we will look in detail at working with the current version of the library - Parboiled2, and also pay attention to Parboiled1, since most of the existing code still uses it. <br><br>  <b>Cycle structure:</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Part 1. Why Parboiled? </li><li>  <a href="http://habrahabr.ru/post/270531">Part 2. Comparison of the text</a> </li><li>  <a href="http://habrahabr.ru/post/270609">Part 3. Data Extraction</a> </li><li>  <a href="http://habrahabr.ru/post/271003">Part 4. The harsh reality</a> </li></ul><br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Parboiled is a library that allows you to easily parse (parsit) markup languages â€‹â€‹(such as HTML, XML or JSON), programming languages, configuration files, logs, text protocols, and any text whatever.  Parboiled will come in handy if you want to develop your own domain-specific language ( <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> ): with its help, you can quickly get an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> and, remembering the <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">interpreter</a> pattern, execute the commands of your domain language. <br><br>  At the moment there are several versions of this library: <br><br><ul><li>  Parboiled for Java is the very first version of the library.  Written by Matthias Doeniz in Java and for Java.  It is still popular, although it is in the â€œend of lifeâ€ state.  If, by chance, you inherited it, or you consciously start a project in Java, I advise you to consider as an alternative <a href="https://github.com/fge/grappa">grappa</a> - fork Parboiled1, which is carefully maintained in a working condition by the user with the nickname <a href="https://github.com/fge">fge</a> . </li><li>  Parboiled - the library, now better known as Parboiled1, came into existence after Matthias was imbued with a rock.  He made a Scala-frontend for Parboiled, at the same time abandoning support for the Java version.  With the release of Parboiled2, the Scala version of Parboiled1 is no longer supported, but in spite of this, it is not worth it to debit it yet: <br><br><ul><li>  Parboiled2 has not yet learned all the features of Parboiled1; </li><li>  Parboiled1 is still used much more widely than Parboiled2, so if you are suddenly transferred to some old Scala project, there is a high chance to encounter it. </li></ul></li><li>  Parboiled2 is the newest version of the library, eliminating a number of flaws in PB1.  Works faster and, most importantly, supported by developers. </li></ul><br>  I wrote this article with an emphasis on Parboiled2 (by the way, I will continue to write about him in the masculine, without the word â€œlibraryâ€), but sometimes I will be distracted to talk about the important differences between the first and second versions. <br><br><h2>  Main features </h2><br>  Brief description of Parboiled2: <br><br><ul><li>  Follows the principles of <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> . </li><li>  Generates single pass parsers.  A separate lexer is not required. </li><li>  A type-safe DSL is used, which is a subset of the Scala language. </li><li>  Optimizations are performed at compile time. </li></ul><br>  In practice, this means: <br><br><ul><li>  You do not need to write a parser with your bare hands. </li><li>  Readability, comparable with the best grades of BNF (in my opinion, PB is even better). </li><li>  You can use all the power of PEG and freely parse recursive data structures, while regular expressions cannot <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">by definition</a> .  Yes, you will not parse either JSON or even the simplest arithmetic expression with regular expressions, let alone programming languages.  StackOverflow has a <a href="http://stackoverflow.com/a/1733489/1447225">well-known quote in the subject</a> : <br><blockquote>  Paris hilton to write an operating system. <br></blockquote></li><li>  Even if you need to parse the linear structure, Parboiled2 (when using proper optimizations) will work faster than regular expressions.  Evidence is given in the next section. </li><li>  Unlike parser generators such as <a href="http://www.antlr.org/">ANTLR</a> , you are freed from the hassle of separately generating code and then compiling it.  All Parboiled code is written in Scala, so you get syntax highlighting and type checking out of the box, as well as the lack of additional operations on grammar files, while the parser generated by ANTLR will have two phases of syntax parsing.  True, despite this, ANTLR is still more powerful, documented and more stable, and therefore it may be preferable in many ( <em>very</em> non-trivial) cases. </li><li>  Skalovsky parser combinators are slow.  So slow.  Indecent slowly.  Matthias compared performance of parsers for Jackson and JSON, written using Parboiled, Parboiled2 and Scala Parser Combinators.  With disappointing results for the latter can be found further in the text. </li><li>  Unlike <a href="http://martinfowler.com/bliki/LanguageWorkbench.html">Language Workbenches</a> , Parboiled is a small and easy-to-use library.  You do not need to download a poorly documented inhibiting monster and spend precious hours of life on the exhausting search for the right menus and buttons just to describe a small DSL.  On the other hand, you will not get a ready text editor with your DSL highlighted out of the box, instead you will have to write a plugin for Vim, Emacs or your IDE yourself, but this does not make Parboiled a less worthy alternative for developing small subject-oriented languages. </li><li>  Parboiled has successfully proven itself in <a href="https://github.com/sirthias/parboiled/wiki/Projects-using-parboiled">many projects</a> , including the bloody enterprise. </li></ul><br><h2>  New in version two </h2><br>  This section will be mainly useful and understandable to those who have already worked with the first version of the library.  Beginners, most likely, should return to this list after reading the entire series of articles. <br><br>  First of all, Parboiled2 successfully eliminates a number of childhood diseases of the first version: <br><br><ul><li> Now you can use more roomy rules than <code>Rule7</code> .  For this, the <a href="https://github.com/milessabin/shapeless">shapeless</a> library with its famous <code>HList</code> : now one rule can operate with a large number of values â€‹â€‹on the stack.  This also means that Parboiled2 has an additional dependency, which was not in PB1 - the shapeless library itself. </li><li>  Added missing constructions.  Thus, in Parboiled1, it was impossible to specify a dynamic number of repetitions for the <code>nTimes</code> rule and one had to use the softer <code>oneOrMore</code> rule, which did not give the required accuracy of the grammar description. </li><li>  Added built-in primitive terminals.  There was a new class <code>CharPredicate</code> , which contains such fields as <code>AlphaNumeric</code> , <code>Hex</code> , <code>Printable</code> , <code>Visible</code> and others. </li><li>  Added the ability to expand and narrow the predicate.  The need to exclude a few characters from the rule arose before, but now it can be easily taken and done, and not to create a white list of characters. </li></ul><br>  Besides: <br><br><ul><li>  Parboiled2 uses macros, which allows you to generate a grammar at the compilation stage, and not at runtime, as it was in Parboiled1.  This greatly increases the performance of your parser, as well as increases the number of checks.  In this connection, the <code>rule</code> block became mandatory, although Parboiled1 allowed in some cases to do without it.  You will notice this innovation first of all when you will do migration of an old code. </li><li>  Improved error reporting system. </li><li>  There is support for <a href="http://www.scala-js.org/">scala.js</a> .  The demo project can be viewed <a href="https://github.com/alexander-myltsev/parboiled2-scalajs-samples">here</a> . </li></ul><br><h2>  Performance comparisons </h2><br>  Parboiled1 is known for its sluggishness (in any case, in relation to parsers generated by ANTLR), due to the fact that all rule matching actions were performed in runtime and the compiler could not perform any significant optimizations on such a parser.  In Parboiled2, performance was put at the forefront and many things were redone on macros, so the compiler got a lot of freedom in optimizing, and the user got the long-awaited performance.  Below we will demonstrate what good results the developers have achieved. <br><br><h2>  Parboiled against JSON parsers written with straight hands </h2><br>  Parboiled is a generalized tool for creating parsers, and as you know, a specialized tool always turns out to be better than a generalized tool for solving its specialized task.  In the Java world, there are a small number of JSON parsers written by hand by ancient elven masters, and Alexander Myltsev (one of the Parboiled2 developers) tested how much Parboiled is losing in performance to these artifacts.  <a href="http://myltsev.name/ScalaDays2014/">The results</a> were quite optimistic, especially in the case of Parboiled2. <br><br><pre> <code class="diff hljs"> - â”‚ ,  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Parboiled1JsonParser â”‚ 85.64 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡ Parboiled2JsonParser â”‚ 13.17 â”‚ â–‡â–‡â–‡â–‡ Json4SNative â”‚ 8.06 â”‚ â–ˆâ–ˆâ– Argonaut â”‚ 7.01 â”‚ â–‡â–‡ Json4SJackson â”‚ 4.09 â”‚ â–‡</code> </pre> <br><h2>  Parboiled vs regular expressions </h2><br>  Thanks to the use of static optimizations, Parboiled2 is able to work much faster than regular expressions (at least those that come bundled with the Java class library).  Here are some confirmations from <a href="https://groups.google.com/forum/">the mailing list</a> : <br><br><pre> <code class="diff hljs"> - â”‚ ,  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Parboiled2 (warmup) â”‚ 1621.21 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡ Parboiled2 â”‚ 409.16 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡ Parboiled2 w/ better types (warmup) â”‚ 488.92 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡ Parboiled2 w/ better types â”‚ 134.68 â”‚ â–‡â–‡â–‡ Regex (warmup) â”‚ 621.95 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡ Regex â”‚ 620.38 â”‚ â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡</code> </pre> <br><h2>  Parboiled vs. Scala Parser Combinators </h2><br>  In the mailing list, you can find <a href="https://groups.google.com/forum/">another performance test</a> , which is in good agreement with the first (about JSON) and contains data for comparison with Scala Parser Combinators.  Everything is very, very sad. <br><br><pre> <code class="diff hljs"> - â”‚ ,  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Parboiled1JsonParser | 73.81 | â–‡ Parboiled2JsonParser | 10.49 | â– ParserCombinators | 2385.78 | â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡</code> </pre><br><h2>  What parboiled can't </h2><br>  Most articles about parser combinators start with exhausting explanations of what PEG is, what it is and why it should be feared.  In order to parse configs, a thorough understanding of this is not necessary, but you should still be aware of the limitations of this type of grammar.  So, Parboiled basically does not know how: <br><br><ul><li>  Parse left-recursive grammar.  It is beyond the power of all downstream parsers (top-down parsers), which include PEG.  However, the left-recursive grammar can be <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%25A3%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BB%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B8">adapted</a> . </li><li>  Disassemble grammars in indentation (indentation-based grammars), for example Python or YAML.  It is impossible to do this due to the fact that the generated parser is single pass, without a separate lexer.  Indentation is performed at the stage of lexical analysis.  This problem has a simple solution: write a preprocessor that <code>INDENT</code> virtual markers before ( <code>INDENT</code> ) and after ( <code>DEDENT</code> ) indenting.  In Parboiled1, there are <a href="https://github.com/sirthias/parboiled/wiki/Indentation-Based-Grammars">standard tools</a> for this, but for Parboiled2, a similar procedure so far will have to be done independently. </li><li>  Use streaming input.  PEGs use a return search, also <a href="https://en.wikipedia.org/wiki/Backtracking">known</a> as <a href="https://en.wikipedia.org/wiki/Backtracking">backtracking</a> .  Theoretically, this disadvantage can be eliminated by stream buffering, but nothing prevents you from writing a grammar in which you return to the very beginning.  Therefore, in order for this idea to work in practice, it is necessary to learn how to determine, by grammar, the boundaries of chunks, between which return is impossible.  Matthias is very <a href="https://groups.google.com/d/msg/parboiled-user/b7PH49fiFco/gGt46xe3Ae4J">interested</a> in the development of this feature, so its appearance is possible in the next releases. </li></ul><br>  In the next part, Iâ€™ll tell you how Parboiled describes a custom grammar, and we will write a simple recognizer for the tree-like format of the configuration files. </div><p>Source: <a href="https://habr.com/ru/post/270233/">https://habr.com/ru/post/270233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270223/index.html">Download and convert video to Rutube: from crutches to meta-programming</a></li>
<li><a href="../270225/index.html">Double cycle KCS. Just about knowledge management.</a></li>
<li><a href="../270227/index.html">Translation: how gitLab uses unicorn and unicorn-worker-killer</a></li>
<li><a href="../270229/index.html">Visual Studio Online: Continuous Integration and Testing</a></li>
<li><a href="../270231/index.html">How the second chip allows hackers to bypass the verification process of a bank card</a></li>
<li><a href="../270235/index.html">Programmer's resume: how to make it convenient?</a></li>
<li><a href="../270237/index.html">CONVERT web analytics and internet marketing conference: preliminary program</a></li>
<li><a href="../270241/index.html">Index-based programming or why do we need all these if, switch, ternary operator?</a></li>
<li><a href="../270243/index.html">Reaction to longevity: how we updated the Lingualeo frontend</a></li>
<li><a href="../270245/index.html">Smooth scroll on AngularJS using requestAnimationFrame + style tips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>