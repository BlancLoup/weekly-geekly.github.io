<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating systems from scratch; level 2 (upper half)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's time to write the file system. The file system does not write itself. In this half of the labs, we still implement the FAT32 file system, attach ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating systems from scratch; level 2 (upper half)</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" width="300" src="https://habrastorage.org/webt/2q/iv/tq/2qivtqrvziru8vxki6ybfggfmty.gif">  It's time to write the file system.  The file system does not write itself.  In this half of the labs, we still implement the FAT32 file system, attach the SD card driver to it and slightly interact with it through our interactive shell. </p><br><p>  <a href="https://habrahabr.ru/post/349248/">Null lab</a> </p><br><p>  First Laba: the <a href="https://habrahabr.ru/post/351082/">younger half</a> and the <a href="https://habrahabr.ru/post/351774/">older half</a> </p><br><p>  <a href="https://habrahabr.ru/post/352414/">The younger part</a> .  Continued under the cut. </p><a name="habracut"></a><br><h2 id="faza-2-32-bitnye-lipidy">  Phase 2: 32-bit lipids </h2><br><p> In this phase we will implement the FAT32 file system.  Exceptionally read-only at the moment.  The main work will be vestist in the directory <code>2-fs/fat32</code> . </p><br><h3 id="diski-i-faylovye-sistemy">  Disks and File Systems </h3><br><p>  The data on the disk is controlled by one or more file systems.  Similar to memory allocators, file systems are responsible for managing, allocating, and freeing memory.  The only difference is that this is not a fast RAM, but a slow and non-volatile memory.  In other words, all changes are saved at any time in the future.  Including after restarting the computer.  There are many different file systems.  Linux has EXT4.  On macOS there are HFS + and APFS.  On Windows, there is NTFS.  Some file systems are implemented for several operating systems at once.  FAT32 is one of those.  It is implemented for all major OSes including Linux, macOS and Windows.  It was originally used in later versions of DOS and earlier versions of Windows.  The main advantage of FAT32 is omnipresence.  This is one of the most koross-platform file systems. </p><br><p>  In order to allow more than one file system to be on the disk, this same disk can be divided into sections.  Each partition can be independently formatted for different file systems.  To split the disk into sections, the disk writes to a specific location where it starts, where it is downloaded and the type of file system that this section uses.  One of the widely used systems is Master Boot Record (Master Boot Record) or simply MBR for brevity.  The MBR contains a table of four entries describing the sections.  However, some sections can not be declared as used.  There are slightly more modern separation schemes like GPT, which among other things supports more than four sections. </p><br><p>  In this task, we will implement the code for reading the MBR from disk, which in turn includes one FAT32 partition.  This combination is used by our malinka: the MBR is also also FAT32. </p><br><h3 id="razbienie-diska">  Disk partitioning </h3><br><p>  This diagram shows the physical layout of the disk partition with MBR and FAT32: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b1/666/de9/6b1666de9b36135e0b2ae0700350e141.svg" alt="MBR and FAT32"></p><br><p>  The PDF of the <a href="https://web.stanford.edu/class/cs140e/notes/lec7/fat-structs.pdf">FAT structure</a> contains all the necessary information about the sizes and contents of these very structures.  Together with the minimum required description.  We will use the document when implementing our file system.  In addition, it will be useful to study the corresponding <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system">article</a> from Wikipedia. </p><br><h3 id="master-boot-record">  Master boot record </h3><br><p>  MBR is always in the zero sector of the disk.  The MBR contains four partition entries.  Each of these entries contains: the type of the partition, the offset of the partition in the sectors and different flags, such as whether this partition is bootable.  All other fields like CHS (cylinder, head, sector) can be completely ignored.  So does most modern implementations.  It is worth noting that the partition type for FAT32 is <code>0xB</code> or <code>0xC</code> . </p><br><h3 id="extended-bios-parameter-block">  Extended Bios Parameter Block </h3><br><p>  The first sector of the FAT32 partition contains an extended BIOS parameter block.  Abbreviated EBPB.  This block itself starts with a block of BIOS or BPB parameters.  Together they define all the necessary layout options for the FAT file system. </p><br><p>  There is one area in EBPB that needs special attention.  The one that determines the number of reserved sectors (number of reserved sectors).  This offset is from the beginning of the FAT32 partition in the sectors where the FAT can be found.  Immediately after the last FAT there will be an area containing data for the clusters.  Now we will look at the FATs in more detail, the data area, the clusters and that's it. </p><br><h3 id="klastery">  Clusters </h3><br><p>  All data stored in the FAT file system is divided into clusters.  In EBPB there is a field from which you can find how many sectors there are in each cluster (number of sectors per cluster).  The numbering of the clusters begins with the number 2. As can be seen from the diagram, the data for cluster 2 is located at the beginning of the data area.  The data for cluster 3 is located immediately after cluster 2 and so on. </p><br><h3 id="file-allocation-table">  File allocation table </h3><br><p>  <em>FAT</em> stands for file allocation table.  File allocation table  Based on the name FAT, this is a table (array) of FAT records.  In FAT32, each such recording has a size of 32 bits.  The size of the entire table is determined by the sectors per FAT and bytes per sectors from EPBP.  For redundancy, there can be more than one FAT in the file system (in the name of the most holy backup!).  The number of tables can also be found in EPBP.  Watch the field number of FATs. </p><br><p>  In addition to the entries behind the numbers 0 and 1, each of the FAT entries determines the status of the cluster.  The note number 2 determines the status of cluster 2. Run down 3 determines the status of cluster 3. And further along the list.  Each cluster has its own FAT entry. </p><br><p>  Records 0 and 1 are most likely: </p><br><ul><li>  Write 0: <code>0xFFFFFFFN</code> , which is ID. </li><li>  Record 1: The end of the cluster chain (EOC). </li></ul><br><p>  In addition to these two entries, all the rest correspond to a specific cluster from the data area.  Although FAT entries have a full size of 32 bits, only 28 bits are used.  The upper 4 bits are ignored.  And the values ‚Äã‚Äãmay be: </p><br><ul><li>  <code>0x?0000000</code> : Empty unused cluster. </li><li>  <code>0x?0000001</code> : Reserved. </li><li>  <code>0x?0000002</code> - <code>0x?FFFFFEF</code> : Data Cluster.  The specific value is the next cluster in the chain. </li><li>  <code>0x?FFFFFF0</code> - <code>0x?FFFFFF6</code> : Reserved. </li><li>  <code>0x?FFFFFF7</code> : Reserved or spoiled cluster. </li><li>  <code>0x?FFFFFF8</code> - <code>0x?FFFFFFF</code> : The last cluster in the chain.  Must be an EOC marker. </li></ul><br><h3 id="cepochka-klasterov">  Chain of clusters </h3><br><p>  Clusters form chains of clusters.  This is essentially a linked list of clusters.  If a cluster is used for data, its value contains either a reference to the next cluster or is an EOC marker indicating the end of the chain. </p><br><p>  As an example, consider a diagram with 8 FAT entries: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e2d/671/010/e2d671010c560307389ca8391a107b05.svg" alt="Chain of clusters"></p><br><p>  Clusters are colored by colors so that it can be easier to figure out which chain it belongs to.  The first two entries are ID and EOC.  Record 2 indicates that the corresponding cluster is a cluster of data and this chain (green) is one cluster in size.  Record 3 indicates that cluster 3 contains data and the next in the chain (blue) will be cluster 5 with data that refers to cluster 6, which terminates this chain.  Similarly, clusters 7 and 5 form a chain (red).  Cluster number 8 is free and not used. </p><br><h3 id="katalogi-i-zapisi">  Catalogs and Records </h3><br><p>  A cluster chain is data for a file or directory.  Directory - the essence of a special file, which contains the file names and all other metadata.  Inside the gurney is an array of catalog entries.  Each such record contains a name, a start cluster and whether this record is a directory or just a file. </p><br><p>  There is one special directory that is not associated with entries in other directories.  Root directory.  The starting cluster for the root directory can be found in EBPB.  Through all this, you can determine the location of all other files and directories. </p><br><p>  For historical reasons, each physical directory entry can be interpreted in as many different ways.  The attribute field also indicates one of these methods.  Here are these two variations: </p><br><ul><li>  Regular catalog entry.  (regular directory entry) </li><li>  Record for long file name.  (long file name entry) </li></ul><br><p>  A long file name (LFN) has been added to FAT32 in order to use file names longer than 11 characters.  If a record has a name longer than 11 characters, then it is preceded by LFN records.  However, these records are not physically sorted.  Instead, they contain a field to determine the sequence.  Thus, it will not be possible to rely on the physical order of LFN records. </p><br><h3 id="itak">  so </h3><br><p>  Before you continue, you need to understand the <a href="https://web.stanford.edu/class/cs140e/notes/lec7/fat-structs.pdf">structures of FAT</a> .  After that, try to answer the following questions: </p><br><blockquote>  <strong>How to determine whether the first sector contains an MBR structure?</strong>  [mbr-magic] <br><br>  The first sector of the disk may not contain the MBR.  How can I determine if the MBR is there or not? </blockquote><br><hr><br><blockquote>  <strong>What is the maximum number of FAT32 clusters?</strong>  [max clusters] <br><br>  FAT32 design implies a number of restrictions.  What is the maximum number of clusters in FAT32 and where do these restrictions come from?  And if you take FAT16, then there will be the same restrictions or other? </blockquote><br><hr><br><blockquote>  <strong>What is the maximum size of a single file?</strong>  [max-file-size] 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Are there any restrictions on the maximum file size?  If so, what is the maximum file size and what determines this boundary? <br><br>  <strong>Hint</strong> : Look at the entry structure in the directory. </blockquote><br><hr><br><blockquote>  <strong>How to determine if we have a LFN record or another?</strong>  [lfn-identity] <br><br>  If you look closely at the entries in the catalog, which ones exactly determine the LBN, the LFN in front of us or the usual entry?  Specifically, what are the bytes and what should they be? </blockquote><br><hr><br><blockquote>  <strong>How can I find <code>/a/b/c.txt</code></strong> [manual-lookup] <br><br>  Not forgetting EBPB, describe all the steps you take to find the initial cluster for the file <code>/a/b/c.txt</code> . </blockquote><br><h3 id="struktura-koda">  Code structure </h3><br><p>  Writing a file system is quite a serious thing.  FAT32 even though we will only read it, not an exception.  The code provided in the <code>2-fs/fat32</code> provides mainly the basic structure, but many design solutions and most of the implementation is entirely yours. </p><br><p>  Now we will deal with the description of what is already done.  Read the code from the directory <code>fat32/src</code> . </p><br><h3 id="treyty-faylovoy-sistemy">  File system traits </h3><br><p>  There you can find the module <code>traits</code> .  The entry point is <code>traits/mod.rs</code>  There you can find about seven traits and one structure.  When implementing the file system, we will also implement it all. </p><br><p>  There is one <code>Dummy</code> structure that provides a fictitious implementation of most traits.  This type can be used as a stub.  If you look at the code, then this cap is used in some places.  Maybe you need it. </p><br><p>  I advise you to read the code from <code>traits/</code> in the following order: </p><br><ul><li>  <code>BlockDevice</code> from <code>traits/block_device.rs</code> .  The file system will be decoupled by generics from the physical / virtual storage.  In other words, the file system will work on any device as long as this device implements <code>BlockDevice</code> .  In the process of implementation / testing, you can use the implementation of <code>BlockDevice</code> on top of a regular file.  In the name of convenience, of course!  But on the Malinka we <code>BlockDevice</code> wrap the SD card driver in <code>BlockDevice</code> together with the EMMC controller and all that.  Differences with almost no notice. </li><li>  <code>File</code> , <code>Dir</code> and <code>Entry</code> from <code>traits/fs.rs</code>  These traits determine what minimal properties a file, directory, or their generalization in the file system should have.  Pay attention to their dependence on each other.  For example, the <code>Entry</code> properties use the <code>File</code> type associated with it. </li><li>  <code>FileSystem</code> of <code>traits/fs.rs</code>  This trait defines file system properties.  Including through binding to the rest of the treyta.  For example, it requires a type that implements <code>File</code> for this file system.  This ensures that for every implementation of <code>FileSystem</code> there is only one implementation of <code>File</code> , <code>Dir</code> and <code>Entry</code> . </li><li>  <code>Metadata</code> and <code>Timestamp</code> from <code>traits/metadata.rs</code> .  Each <code>Entry</code> must be associated with some metadata that allows you to get information about a file or directory.  Metadata is responsible for this metadata.  And the <code>Timestamp</code> in turn, determines a set of properties for certain points in time.  This trait is used for things like file creation time. </li></ul><br><h3 id="kesh-ustroystvo">  Cache device </h3><br><div style="text-align:center;"><img title="No, we're talking about another cache." src="https://habrastorage.org/webt/y3/tt/b-/y3ttb-ifq09qkxhazvnbqubje_a.gif"></div><br><p>  Direct disk access is quite an expensive operation.  Therefore, all access will be performed on cached sectors.  The structure of <code>CachedDevice</code> can be found in the file <code>vfat/cache.rs</code> .  It provides transparent and explicit access to sector caches.  In fact, it is a wrapper over <code>BlockDevice</code> , which internally uses a <code>HashMap</code> as storage.  The key in the <code>HashMap</code> will be the sector number.  Once you implement <code>CachedDevice</code> , you can transparently use it as a cached version of <code>BlockDevice</code> .  In addition, <code>get()</code> and <code>get_mut()</code> methods are provided that allow you to directly refer to cached sectors. </p><br><p>  In addition, the <code>CachedDevice</code> structure must monitor the correspondence between logical sectors and physical sectors, which are defined by <code>EBPB</code> .  The <code>virtual_to_physical()</code> method is provided for <code>virtual_to_physical()</code> .  This same method should be used to determine how many physical sectors need to be read for a given logical sector. </p><br><h3 id="poleznosti">  Utility </h3><br><p>  The <code>util.rs</code> file contains one useful trait and its implementation for slices ( <code>&amp;[T]</code> ) and dynamic arrays ( <code>Vec&lt;T&gt;</code> ).  This can be used to transfer one to another while maintaining certain conditions.  For example, in order to build <code>&amp;[u32]</code> in <code>&amp;[u8]</code> you can use this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> util::SliceExt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>] = &amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(x.len(), <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { x.cast() }; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(y.len(), <span class="hljs-number"><span class="hljs-number">16</span></span>);</code> </pre> <br><h3 id="mbr-i-ebpb">  MBR and EBPB </h3><br><p>  The <code>MasterBootRecord</code> structure can be found in the <code>mbr.rs</code> file.  She is responsible for reading and analyzing the MBR from <code>BlockDevice</code> .  Similarly, you can use the <code>BiosParameterBlock</code> structure.  It can be found in the file <code>vfat/ebpb.rs</code>  She is responsible for reading and analyzing the BPB and EBPB sections of FAT32. </p><br><h3 id="shared">  Shared </h3><br><p>  The <code>Shared&lt;T&gt;</code> structure from <code>vfat/shared.rs</code> can be used for secure mutable access to type <code>T</code>  Useful in the implementation of the file system.  Especially when we need the ability to share FS from different parts of the code.  Before proceeding, make sure you understand how and why using <code>Shared&lt;T&gt;</code> useful. </p><br><h3 id="faylovaya-sistema">  File system </h3><br><p>  The core file system itself can be found in the file <code>vfat/vfat.rs</code>  Obviously this is a <code>VFat</code> structure.  As you can see, the structure contains a <code>CachedDevice</code> .  The implementation should wrap the supplied <code>BlockDevice</code> in <code>CachedDevice</code> . </p><br><blockquote>  <strong>What is the VFAT?</strong> <br><br>  VFAT is another Microsoft file system that is the predecessor of FAT32.  For various historical reasons, it has become synonymous with FAT32.  We will continue this silly tradition with not always correct names. </blockquote><p>  A partial implementation of the <code>FileSystem</code> properties for the <code>&amp;Shared&lt;VFat&gt;</code> already present.  In addition, you can see that the <code>from()</code> method returns <code>Shared&lt;VFat&gt;</code> .  The main task is to complete the implementation of the <code>from()</code> method and some required <code>FileSystem</code> properties for <code>&amp;Shared&lt;VFat&gt;</code> .  This pulls the implementation of the remaining structures that implement the necessary pieces of file system properties. </p><br><p>  More <code>vfat/</code> can be found: </p><br><ul><li>  <code>error.rs</code> .  Contains <code>Error</code> enumeration with possible errors during <code>FAT32</code> initialization. </li><li>  <code>file.rs</code>  Contains a <code>File</code> structure stub, which must implement the <code>traits::File</code> treit. </li><li>  <code>dir.rs</code>  Similar to <code>file.rs</code>  In addition, it contains blanks for structures as recorded on the disc. </li><li>  <code>entry.rs</code> .  Contains the <code>Entry</code> structure <code>Entry</code> , which should implement the <code>traits::Entry</code> treit. </li><li>  <code>metadata.rs</code> .  Contains <code>Data</code> , <code>Time</code> , <code>Attributes</code> structures for working with raw file properties.  And unfinished structures <code>Timestamp</code> , <code>Metadata</code> , which must implement the corresponding traits from the module <code>traits</code> . </li><li>  <code>fat.rs</code>  Contains the <code>FatEntry</code> structure.  This structure wraps FAT records and can be used for easy and easy reading of the corresponding FAT records. </li><li>  <code>cluster.rs</code> .  Contains a cluster structure that wraps a physical cluster number and can be used to read the logical cluster number. </li></ul><br><p>  When implementing a file system, you will need to add all this with the necessary code.  Do not be afraid to supplement any of these structures with methods that you find necessary.  However, do not change any of the provided definitions of traits or signatures of existing methods. </p><br><p>  Read now all the code from <code>vfat.rs</code> and make sure you understand what is happening there. </p><br><h3 id="realizaciya">  Implementation </h3><br><p>  Now we have everything you need to implement the FAT32 file system.  You can sell in the order in which you prefer. </p><br><blockquote>  <strong>Be sure to update all provided blanks!</strong> <br><br>  Make sure all your repository copies are up to date.  Get the latest versions of <code>2-fs</code> and <code>os</code> using <code>git pull</code> and fix everything you need. </blockquote><p>  We provide a set of fairly rigorous tests to verify implementation.  Before running the tests, run <code>make clean &amp;&amp; make fetch</code> in the <code>2-fs</code> directory.  It will load several files into <code>2-fs/files/resources/</code> .  These files are used by unit tests.  In this directory, you will find images that contain MBR, EBPB and FAT32 inside, as well as hashes, which are used to test different parts of the implementation.  Perhaps you will find it useful to analyze images using hex editors like * <em>Bless</em> on Linux or <strong>Hex Fiend</strong> on macOS. </p><br><p>  Tests can be run using the <code>cargo test</code> .  In order to see the debugging messages, you can run the <code>cargo test -- --nocapture</code> .  This prevents <code>stdout</code> and <code>stderr</code> from intercepting.  In addition, you can freely add your own tests in the number in which you find it necessary.  To prevent merge conflicts, it is recommended to add tests to a file with a name other than <code>tests.rs</code> . </p><br><p>  It is also recommended to follow these rules: </p><br><ul><li>  <strong>Use meaningful types wherever possible.</strong>  For example, instead of using <code>u16</code> for the time field, you can use the structure <code>Time</code> </li><li>  <strong>Avoid <code>unsafe</code> as much as possible.</strong>  Our implementation uses a total of four non- <code>union</code> strings with <code>unsafe</code> and three strings to handle the <code>union</code> .  Your implementation should try to follow it. </li><li>  <strong>Avoid duplication by using all sorts of helper methods.</strong>  It is often useful to put a generic behavior into an auxiliary method.  Try to do it when it makes sense. </li><li>  <strong>Make sure your implementation is independent of the cluster size or sector.</strong>  Do not hardcore any specific values ‚Äã‚Äãof sector sizes or cluster sizes.  Your implementation should work with any cluster sizes and sectors that are multiples of 512 and are taken from EBPB. </li><li>  <strong>Do not buffer twice unnecessarily.</strong>  Make sure you don‚Äôt read the sectors in memory if they are already in the cache.  Try to use memory without fanaticism. </li></ul><br><p>  You can do everything in the order in which you want.  But we recommend this procedure: </p><br><ol><li>  <strong>Implement the MBR parsing in <code>mbr.rs</code></strong>  Probably for implementation will require the use of <code>unsafe</code> .  But one line will suffice.  Most likely <a href="https://doc.rust-lang.org/nightly/std/slice/fn.from_raw_parts_mut.html">slice :: from_raw_parts_mut ()</a> or <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">mem :: transmute ()</a> .  <code>mem::transmute()</code> an incredibly powerful tool.  Avoid using it as much as it turns out.  Otherwise, you must fully understand what you are doing.  To implement <code>Debug</code> use <code>debug_struct()</code> from <code>Formatter</code> .     <code>CachedDevice</code>  <code>Debug</code> . </li><li> <strong>  EBPB  <code>ebpb.rs</code> .</strong>      MBR,       <code>unsafe</code> . </li><li> <strong>  MBR  EBPB.</strong>       .     <code>BlockDevice</code>  <code>Cursor&lt;&amp;mut [u8]&gt;</code> .         : <br><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:#?}"</span></span>, x);</code> </pre> </li><li> <strong> <code>CachedDevice</code>  <code>vfat/cached.rs</code> .</strong> </li><li> <strong> <code>VFat::from()</code>  <code>vfat/vfat.rs</code> .</strong>  <code>MasterBootRecord</code> , <code>BiosParameterBlock</code>  <code>CachedDevice</code>  .      MBR  EBPB. </li><li> <strong> <code>FatEntry</code>  <code>vfat/fat.rs</code> .</strong> </li><li> <strong> <code>VFat::fat_entry</code> , VFat::read_cluster <code> VFat::read_chain</code> .</strong>       <code>Cluster</code>     .          .       .     .      <code>VFat::fat_entry</code>    . </li><li> <strong> <code>vfat/metadata.rs</code> .</strong>  <code>Date</code> , <code>Time</code>  <code>Attributes</code>     ,    .      <a href="https://web.stanford.edu/class/cs140e/notes/lec7/fat-structs.pdf">  FAT</a> .  <code>Timestamp</code>  <code>Metadata</code>      ,                  <code>Entry</code> , <code>File</code>  <code>Dir</code> . </li><li> <strong> <code>Dir</code>  <code>vfat/dir.rs</code>  <code>Entry</code>  <code>vfat/entry.rs</code> .</strong> <br>       <code>Dir</code> ,     <code>Cluster</code>   <code>Shared&lt;VFat&gt;</code> .         <code>File</code>  <code>vfat/file.rs</code> .       ,   <code>Iterator&lt;Item=Entry&gt;</code>       <code>entries()</code> .   <code>entries()</code>     <code>unsafe</code> .        <code>VecExt</code>  <code>SliceExt</code> .  <a href="https://web.stanford.edu/class/cs140e/notes/lec7/fat-structs.pdf">  FAT</a> ‚Äî   ,    <code>Dir</code> . <br><br> <strong> Entry</strong> <br>       LFN,   ,   <code>union</code>     .      <code>VFatDirEntry</code> .     Rust    <a href="https://doc.rust-lang.org/nightly/reference/items/unions.html"></a> .       <a href="https://en.wikipedia.org/wiki/Union_type"></a> . <br><br>          .    ,  ,            .  <code>union</code>      .              . <br><br>         <code>.</code>  ,     LFN,  ,     .    <code>.</code>      . <br><br>         UTF-16    LFN.      <code>decode_utf16()</code> .     UTF-16      <code>Vec&lt;u16&gt;</code>     . <br> <strong><code>Dir::find()</code></strong> <br> <br>    <code>Dir::find()</code> <em></em>    <code>traits::Dir</code>  <code>Dir</code> .    ,  <code>Dir::find()</code>      .       .       <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html">eq_ignore_ascii_case()</a>       . </li><li> <strong> <code>File</code>  <code>vfat/file.rs</code> .</strong>    ,    <code>Cluster</code>    <code>Shared&lt;VFat&gt;</code> .   <code>traits::File</code>   <code>File</code> .     <code>entries()</code>  <code>Dir</code> . </li><li> <strong> <code>VFat::open()</code>  <code>vfat/vfat.rs</code> .</strong>  <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html">components()</a>  ,      <code>Path</code> .  ,  ,    <code>std</code> ,     ,      .      <code>read_dir()</code> , <code>is_file()</code> , <code>is_dir()</code>   . <br><br>   <code>Dir::find()</code> .  <code>VFat::open()</code>    .     17 .        <code>Dir</code>  . </li></ol><br><p>  ,       -    ,    ,      .     !  ,   ,     . </p><br><h2 id="sedlaem-sd-kartu">  SD- </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2t/mx/yu/2tmxyuyimqta_hpgwo9apx5jv2w.jpeg"></div><br><p>           SD-  Raspbrerry Pi 3,  <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign function interface</a>  FFI  .  FFI  Rust    <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html"> 19.1   Rust</a> .             .      <code>os/kernel/src/fs</code> . </p><br><h3 id="foregin-function-interface"> Foregin Function Interface </h3><br><p> FFI  Rust      ,       . ,    Rust,     <code>extern</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> outside_global: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outside_function</span></span></span></span>(param: <span class="hljs-built_in"><span class="hljs-built_in">i16</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; }</code> </pre> <br><p>     <code>outside_function</code>     <code>outside_global</code> .     : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = outside_function(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> global = outside_global; }</code> </pre> <br><p>  ,      <code>unsafe</code> . Rust  ,        .          .  ,         , Rust ,     .        <code>outside_function</code>  <code>outside_global</code>  .    . </p><br><p>    Rust   ,   (  )       .  Rust    (mangles) ,   .      . ,      ,                 .    <del>  </del>      <code>#[no_mangle]</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_me_maybe</span></span></span></span>(ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { .. }</code> </pre> <br><p>    ()        : </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_me_maybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; call_me_maybe(...);</code> </pre> <br><blockquote> <strong> Rust       ?</strong> [foreign-safety] <br><br> ,  Rust   ,     .   ,  Rust  ,  <em></em>  Rust ,        ,            Rust. </blockquote><br><hr><br><blockquote> <strong> Rust  ?</strong> [mangling] <br><br>       . C++  Rust .     ,       ?    ,  ,  Rust     . </blockquote><br><h3 id="drayver-sd-karty">  SD- </h3><br><p>        SD-  <code>os/kernel/ext/libsd.a</code> .        .  Those.     .    <code>os/kernel/src/sd.rs</code>   ,    . </p><br><p>      <code>wait_micros</code> ,       .          .           .         : </p><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/* * Sleep for `us` microseconds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_micros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> us)</span></span></span></span>;</code> </pre> <br><p>  ‚Äî    API   Rust-.   <code>Sd</code> ,    SD-   <code>new()</code> .    <code>BlockDevice</code>  <code>Sd</code> .     <code>unsafe</code>     .   ,   MBR   <code>kmain</code> . ,     .    ,  ,    . </p><br><blockquote> <strong></strong> :  64- ARM <code>unsigned int</code>     <code>u32</code>  Rust. </blockquote><br><hr><br><blockquote> <strong>    ?</strong> [foreign-sync] <br><br>     SD-    ( <code>sd_err</code> )      .         .       ? ,          Rust   <code>unsafe</code> -.      ?     ? <br><blockquote> <strong></strong> :   ! ( ,   )    ? </blockquote><br></blockquote><br><h3 id="faylovaya-sistema-1">  File system </h3><br><p>             .    <code>kernel/src/fs/mod.rs</code> . </p><br><p>    ,     .  ,       .  ,   ,     <code>static FILE_SYSTEM: FileSystem</code>   <code>kernel/src/kmain.rs</code> .   ,        . </p><br><p>           .     .    <code>FileSystem</code>  <code>kernel/src/fs/mod.rs</code> ,      FAT32      SD-.        <code>Sd</code> ( <code>BlockDevice</code> )   <code>initialize()</code> .    <code>FileSystem</code>  ,     <code>VFat</code> .    ,      <code>kmain</code> <em></em>  . </p><br><p>   ,     ( <code>/</code> )  SD-.     ,    ‚Äî    . </p><br><h2 id="faza-4-mosh">  4: Mo'sh </h2><br><p>       <code>cd</code> , <code>pwd</code> , <code>ls</code>  <code>cat</code>    .     <code>os/kernel/src/shell.rs</code> . </p><br><img title=",     " src="https://habrastorage.org/webt/el/45/xd/el45xdipxfj6eqieqj_x-rzkanu.gif"><br><h3 id="rabochiy-katalog">   </h3><br><p>       <em> </em> .    ( <code>cwd</code>  current working directory) ‚Äî   ,       .   <code>cwd</code>  <code>/a</code> ,      <code>hello</code>        <code>/a/hello</code> .  <code>cwd</code>   <code>/a/b/c</code> ,     <code>hello</code>      <code>/a/b/c/hello</code> .  <code>/</code>               ,   .        .     <code>/hello</code>        <code>hello</code>         . </p><br><p>             <code>cd &lt;dir&gt;</code> .     <code>cd /hello/there</code> ,  <code>cwd</code>   <code>/hello/there</code> .     <code>cd you</code> ,  <code>cwd</code>   <code>cd /hello/there/you</code> . </p><br><p>            .          ,      <code>cwd</code>     . </p><br><h3 id="komandy">  </h3><br><p>    ,         : <code>cd</code> , <code>pwd</code> , <code>ls</code>  <code>cat</code> .        : </p><br><ul><li> <code>pwd</code> (print the working directory).       . </li><li> <code>cd &lt;directory&gt;</code> (change (working) directory).      <code>directory</code> .   <code>directory</code> . </li><li> <code>ls [-a] [directory]</code> (list the files in a directory).     . <code>-a</code>  <code>directory</code>   .    <code>-a</code> ,     .        .  <code>directory</code>  ,       .        <code>directory</code> .      .  <code>-a</code>    <code>directory</code> .      .     ,    . </li><li> <code>cat &lt;path..&gt;</code> (concatenate files).       <code>path</code>   .       .         ‚Äî  .         UTF-8,    . </li></ul><br><p>           .       .        .       ‚Äî        ,   . ,     . </p><br><h3 id="realizaciya-1">  Implementation </h3><br><p>  <code>os/kernel/src/shell.rs</code>    .   <code>PathBuf</code>  ,     .   <code>PathBuf</code>     <code>cd</code> .            .       ,           . </p><br><p>  ,   ,           ‚Äî    .  Congratulations! </p><br><blockquote> <strong>,   bin-!</strong> <br><br>          .     ,   bin-.      ,    . </blockquote><br><hr><br><blockquote> <strong></strong> :    <code>PathBuf</code>  <code>Path</code>    . </blockquote><br><hr><br><blockquote> <strong></strong> :       <code>..</code>  <code>.</code>   <code>cd</code> . </blockquote><p>  So it goes. </p></div><p>Source: <a href="https://habr.com/ru/post/353024/">https://habr.com/ru/post/353024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353014/index.html">Introducing the new dialog item</a></li>
<li><a href="../353016/index.html">More than a state: British East India Trading Company</a></li>
<li><a href="../353018/index.html">Unit testing interfaces in Headless Chrome. Yandex lecture</a></li>
<li><a href="../353020/index.html">Check incoming data. The root cause of the vulnerability and attacks on Cisco IOS</a></li>
<li><a href="../353022/index.html">Metalsmith static site generator</a></li>
<li><a href="../353026/index.html">"Japan - Guam - Australia": Google is laying a new submarine cable</a></li>
<li><a href="../353028/index.html">Another example of automation or PowerShell + Google Apps Script</a></li>
<li><a href="../353030/index.html">Using rrd4j for OpenHab2 persistence</a></li>
<li><a href="../353034/index.html">An alternative look at the problem from Odnoklassniki with JPoint 2018</a></li>
<li><a href="../353036/index.html">Javascript MIDI Player</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>