<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node-SPICE: Simulation of transients in the electrical network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Today I want to talk about one of his projects, which was created as one of the tools for obtaining data for the thesis, and since at the momen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node-SPICE: Simulation of transients in the electrical network</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Today I want to talk about one of his projects, which was created as one of the tools for obtaining data for the thesis, and since at the moment he has completed his main task, I want to put him into the GPLv3-swimming - maybe it will be useful to someone still.  However, before giving the moorings, I decided to use the Intel Vtune Amplifier profiler to make sure that my simulation package for the tree-like power supply network optimally consumes the computing resources of the computer. <br><br> <a href="https://habrahabr.ru/company/intel/blog/301684/"><img src="https://habrastorage.org/files/a7f/3b1/077/a7f3b10778f44856be99a30e4ff19cf1.png"></a> <br><br>  Under the cut, details about myself, about the project and about performance optimization (which we managed to increase more than twice in half an hour) <br><a name="habracut"></a><br><h4>  <b>Introduction</b> </h4><br>  For the last 6 years I have been working on issues of energy saving and improving the quality of electricity at industrial facilities.  First of all, it is compensation of reactive power at the level of the consumer of the electric power, so that this most reactive power is not consumed from the industrial network of power supply.  Parallel to this task is the task of stabilizing the voltage in the nodes of loads, directly next to consumers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Imagine a conventional asynchronous motor.  Thousands of them.  Look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d04/b6b/bf6/d04b6bbf686d472da94c9bcfba7b8d6f.png"></div><br>  In various authoritative and not very sources, one can find statistical information that up to 70% of the generated electricity is consumed by asynchronous electric motors.  I do not think that the real figure is far from this value. <br><br>  So, have you ever noticed that if the old refrigerator starts at home, the light blinks?  This effect - flicker - occurs due to the fact that when starting the motor consumes current 5-7 times more than the nominal.  At the very first moments of start-up, there is no magnetization of the stator, the inductive resistance is minimal and the network is actually loaded with a rather small active resistance of the stator winding.  Then, when the engine starts to gain momentum, the stator magnetizes, the reactance of the stator winding increases and the current decreases. <br><br>  Now imagine the electrical network of the enterprise: <br><img src="https://habrastorage.org/files/0b4/8a2/f11/0b48a2f116b34553999c6a03f6d09827.png"><br>  <i>Fig.</i>  <i>1 - Main power circuits for power consumers: a - with distributed loads;</i>  <i>b - with concentrated loads;</i>  <i>in - block transformer - highway;</i>  <i>1 - substation switchboard;</i>  <i>2 - power distribution point;</i>  <i>3 - electric receiver;</i>  <i>4 - highway;</i>  <i>5 - tire assembly.</i> <br><br>  This is such a tree-shaped branched electrical network with many electrical receivers.  In general, you can draw it like this: <br><br><img src="https://habrastorage.org/files/08a/10d/bf1/08a10dbf1a5c4719832e001b8e28aba2.png"><br>  <i>Fig.</i>  <i>2 - Generalized block diagram of power consumers.</i> <br><br>  In the diagram in fig.  2, the <i>Ve</i> node is the connection point of the power supply network (industrial AC network, ship generator, wind generator inverter, etc.), as a result of which the node voltage becomes <i>Ue</i> .  To the source by means of an active-inductive supply line with resistance <i>Ze = Re + jLe</i> , a distribution node <i>V0 is</i> connected with a voltage <i>U0</i> , which is defined as: <br><br><img src="https://habrastorage.org/files/5e5/d90/d27/5e5d90d27abc4c93af4d8929958b10c4.png"><br><br>  where <i>I_ {e-0}</i> is the current consumed from the node <i>Ve</i> , which is equal to the sum of the currents consumed by the subordinate loads: <br><br><img src="https://habrastorage.org/files/92b/fe9/862/92bfe986298948ad98bf0844ae14d444.png"><br><br>  where <i>N</i> is the number of loads powered from a given node.  For the diagram in fig.  2 from the <i>Ve</i> node, all the load nodes in the system are powered - <i>V3 - V6</i> .  Node-loads <i>V3, V4 are</i> connected to node <i>V1</i> ;  and to node <i>V2</i> nodes-loads <i>V5, V6,</i> respectively. <br><br><h4>  <b>Why was Node-SPICE created?</b> </h4><br>  If one of the loads changes, the current changes in the whole circuit to the root, therefore, the voltage changes in the root, and behind it in all other nodes.  And if we need to stabilize the voltage at several points in the circuit, then the problem arises of doing it optimally, because the two stabilizers will influence each other.  To trace this effect on a variety of options, it is necessary to perform network simulation. <br><br>  The diagram in fig.  2 You can draw yourself in the Matlab Simulink package.  But there is one snag - if the scheme is large, or there are many of these schemes, then draw each scheme, run the simulation, remove and save the simulation results, transient graphs, damn dreary, and I decided that it would be faster to create my own modeler (fig) and more interesting (and here I was right). <br><br>  In order for the development to be even more interesting and useful, I, a severe Sishnik-piece of iron, decided to deal with C ++ as the development language at last. <br><br><h4>  <b>Installation</b> </h4><br>  The sources are a Visual Studio 2013 project and are uploaded to <a href="https://github.com/radiolok/node-spice">GitHub</a> . <br>  To build the application, you need to download the <a href="http://eigen.tuxfamily.org/">Eigen</a> linear algebra library and specify the path to the library folder using the system environment variable <i>$ (EIGEN_DIR)</i> .  Visual Studio will have to pick up the path to this folder and compile the application without any special rustling. <br><br>  To output and save graphs, the application uses the <a href="http://www.gnuplot.info/">gnuplot</a> package with the cairo module - gnuplot should be able to save images in PNG format.  You can verify this by running the set terminal png command in the gnuplot console.  Gnuplot should not swear at the wrong argument - gnuplot, which comes with octave, was the last one to sin.  The path to gnuplot must be in <i>$ (PATH)</i> . <br><br><h4>  <b>Application architecture</b> </h4><br>  The application was supposed to consist of modules independent of each other (Figure 3), but something went wrong: <br><br><img src="https://habrastorage.org/files/678/db0/5bb/678db05bbc1e4e31859e241c5a8c061f.png"><br>  <i>Fig.</i>  <i>3 - Program flow chart</i> <br><br>  The main modules of the system are: <br><br><ol><li>  Computing module Board.  In this module, the creation of Workbench desktops is made, in which the construction of load node diagrams is directly performed.  In addition, this module is responsible for the modeling process as a whole. </li><li>  Module Clock.  Responsible for computing clocking.  Currently implemented clocking on the principle of "fixed step".  Included in the Board Module </li><li>  Open module.  Responsible for reading the configuration file and data files in case there are any.  Included in the Board Module </li><li>  Save module.  Used to save the simulation results in files in raw or in image format.  Included in the Board Module </li><li>  Module Plot.  Responsible for plotting the result. </li></ol><br>  The interface of the program console - the types and parameters of power consumers, as well as the configuration of the load node are described in configuration files. <br><br>  The startup command looks like this: <br><br><pre><code class="bash hljs">node-spice.exe -f {   }</code> </pre> <br>  The format of the configuration file is text, consisting of lines of the form: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">command</span></span> -a -b -c 1 -d 2 -e 3</code> </pre> <br>  where a, b, c, d, e are parameter keys, some of which (a, b) have a boolean data type - active or inactive option or mode.  The other part, for example, c, d, e, has a textual or numeric value of the parameter. <br><br>  A configuration file in which a three-phase voltage source is connected via a quality analyzer to an electric motor and an unbalanced load is as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Sample configuration file</b> <div class="spoiler_text"><pre> <code class="bash hljs">//  5 . //    8192  setup -Off 2 -f 8192 //      wb0 load -t workbench -name wb0 //        //Ua = 310   50. //   R = 0,1 ,  L = 0,01 load -t <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> -name ideal3f -f 50 -Ua 310 -R 0.1 -L 0.01 //    //     ( -I), //( -U),   ( -S), //  ( -Phi), //    ( -P  -Q), //     ( -E) //       0,02c( -tRMS) //   (   ) 220 load -t analyzer -name analyzer //-I -U -S -Phi -tRMS 0.02 -Unom 220 -P -Q -E //  4A80B4Y3,      // -saveGraph        load -t acmotor -name 4A80B4Y3 -Rs 5.85 -Rr 3.0 -Ls 0.015 -Lr 0.023 -L0 0.350 -J 0.1 -p 2 -saveGraph //   //    t=1c( -On 1)    t=2c( -Off 2). load -t rlc -name rl1 -On 1 -Off 2 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 //       link -output ideal3f -input analyzer //      link -output analyzer -input 4A80B4Y3 //      link -output analyzer -input rl1 //     solve //          graph</code> </pre> </div></div><br>  On the Workbench desktop, there can be any number of elementary Node nodes connected in a tree-like configuration. <br><br>  Each node has an input for connecting a voltage source and an output for powering a subsequent load.  To the output of one node can be connected to the inputs of several child nodes.  The parent node sets the voltage at the terminals of the child node and requests the current consumed by it.  If the child node has its own child nodes, then the operation is performed recursively.  The behavior of the node is different - the voltage source, which is unique in the system.  After the simulation stage, the source is provided with information about the total current consumption and returns information about the current value of the voltage at the source output. <br><br><img src="https://habrastorage.org/files/070/07b/ad0/07007bad051f4911b63e657332a1336c.png"><br><br>  Regardless of their type of nodes have a common interface that allows you to create different hardware configurations.  The elementary node is added using the load command. <br><br>  General view of the load command: <br><br><pre> <code class="bash hljs">load -n { } -t { } [- ]</code> </pre> <br>  There are the following configuration keys common to all nodes: <br><br><div class="spoiler">  <b class="spoiler_title">Table 1 - common keys of elementary node configuration</b> <div class="spoiler_text"><table><tbody><tr><td>  Key </td><td>  Default value </td><td>  Description </td></tr><tr><td>  -name </td><td>  noname </td><td>  The unique name of the node.  There cannot be several nodes with the same name in the system. </td></tr><tr><td>  -wb </td><td>  None </td><td>  The name of the desktop on which the electrical receiver is located.  By default, the node is located on the last declared desktop. </td></tr><tr><td>  -On {c} </td><td>  0 </td><td>  The connection time of the elementary node.  The time is set in seconds.  The default value is "0" </td></tr><tr><td>  -Off {s} </td><td>  Equal to total simulation time </td><td>  Time off the elementary node.  Set in seconds.  You can turn off the voltage source. </td></tr><tr><td>  -t </td><td>  Without type </td><td>  Node type (discussed below). </td></tr><tr><td>  -Imax </td><td>  0 (unlimited) </td><td>  Overcurrent protection current. </td></tr><tr><td>  -width {pix} </td><td>  800 </td><td>  Graph Width </td></tr><tr><td>  -heigth {pix} </td><td>  600 </td><td>  Graph height </td></tr><tr><td>  -font </td><td>  Arial, 10 </td><td>  Text font on graphs </td></tr><tr><td>  -raw </td><td></td><td>  Saving file of raw graphics data </td></tr></tbody></table><br></div></div><br>  Implemented types of elementary Node nodes: <br><br><h5>  Desktop -t workbench. </h5><br>  It is assumed that each desktop is a kind of scheme and it should be possible to create nested schemes, i.e. nested desktops.  This feature is incorporated in the test version of the program (but, of course, not implemented :)).  Unique keys for the desktop are missing.  Since there may be several desktops, after the introduction of a second or more desktop for nodes, you should specify which desktop they belong to.  If the <i>-wb switch is</i> not specified, then the elementary node will be placed on the last created desktop. <br><br><h5>  Three phase voltage source -t acsource </h5><br>  In the current version of the software package there can be only one voltage source, which somewhat limits the capabilities of the program, but is sufficient for my task. <br><br>  I have little thoughts to take everything and rewrite, using a complex calculus, any number of sources and receivers of electricity of any configuration, but I tearfully implore myself if I sit down for it, then AFTER a thesis.  While holding on. <br><br><div class="spoiler">  <b class="spoiler_title">Acsource node configuration keys</b> <div class="spoiler_text"><table><tbody><tr><td>  Key </td><td>  Default value </td><td>  Description </td></tr><tr><td>  -Ua </td><td>  0 </td><td>  Amplitude value of voltage.  If not specified, the -Ud key is searched. </td></tr><tr><td>  -Ud </td><td>  0 </td><td>  Effective voltage </td></tr><tr><td>  -f </td><td>  50 </td><td>  AC source voltage frequency </td></tr><tr><td>  -R </td><td>  0 </td><td>  Internal source resistance </td></tr><tr><td>  -L </td><td>  0 </td><td>  Source inductance </td></tr><tr><td>  -phi </td><td>  0 </td><td>  Source Voltage Phase </td></tr></tbody></table><br></div></div><br>  Figure 5 shows the process of modeling a voltage source without load: <br><br><img src="https://habrastorage.org/files/da6/f59/135/da6f5913515a4de2b657172eb1b06349.png"><br>  <i>Fig.</i>  <i>5 - Graphs of current and voltage of the voltage source operating in idle mode</i> <br><br><h5>  Quality Analyzer -t analyzer </h5><br>  The consumption quality analyzer is included in any part of the system and analyzes various parameters of consumption.  This node is responsible for the construction of graphs. <br><br><div class="spoiler">  <b class="spoiler_title">Table 3 Analyzer node configuration keys</b> <div class="spoiler_text"><table><tbody><tr><td>  Key </td><td>  Default value </td><td>  Description </td></tr><tr><td>  -tRMS {s} </td><td>  one </td><td>  The period of calculation of the effective value of voltage and current </td></tr><tr><td>  -Collect </td><td>  - </td><td>  Indicates to show on the graph a summary graph, or phase charts. </td></tr><tr><td>  -Unom {B} </td><td>  220 </td><td>  Rated effective value of voltage.  Used to fix voltage dips </td></tr><tr><td>  -U </td><td>  - </td><td>  Check the voltage at the analyzer output </td></tr><tr><td>  -I </td><td>  - </td><td>  Register current consumption </td></tr><tr><td>  -Phi </td><td>  - </td><td>  Power factor registration (the -P and -S switches must be present) </td></tr><tr><td>  -S </td><td>  - </td><td>  Register full power (must be -U and -I keys) </td></tr><tr><td>  -P </td><td>  - </td><td>  Registration of active power (the -U and -I switches must be present) </td></tr><tr><td>  -Q </td><td>  - </td><td>  Registration of reactive power (the -S and -P switches must be present) </td></tr><tr><td>  -E </td><td>  - </td><td>  Recording of active energy consumption (the -P key must be present) </td></tr></tbody></table></div></div><br>  After the simulation, the node using the Plot module displays the required graphs and saves them to disk as images. <br><br><h5>  Asynchronous motor -t acmotor </h5><br>  This elementary node implements a mathematical model of an asynchronous electric motor. <br><br><div class="spoiler">  <b class="spoiler_title">Table 4 - Acmotor node configuration keys</b> <div class="spoiler_text"><table><tbody><tr><td>  Key </td><td>  Default value </td><td>  Description </td></tr><tr><td>  -Rs {ohm} </td><td>  0 </td><td>  Stator winding resistance </td></tr><tr><td>  -Rr {ohm} </td><td>  0 </td><td>  Rotor winding resistance </td></tr><tr><td>  -Ls {gn} </td><td>  0 </td><td>  Stator winding inductance </td></tr><tr><td>  -Lr {gn} </td><td>  0 </td><td>  Rotor winding inductance </td></tr><tr><td>  -Lm {gn} </td><td>  0 </td><td>  Leakage inductance </td></tr><tr><td>  -J {} </td><td>  0 </td><td>  Moment of inertia of the rotor </td></tr><tr><td>  -p {} </td><td>  0 </td><td>  The number of poles of the stator winding </td></tr><tr><td>  -Ms {N * m2} </td><td>  0 </td><td>  Static moment on the shaft </td></tr><tr><td>  -Tload {s} </td><td>  0 </td><td>  Load time </td></tr><tr><td>  -saveGraph </td><td>  None </td><td>  Activation of graphing the torque on the shaft and the rotational speed of the drive </td></tr></tbody></table><br></div></div><br>  Figure 6 shows the process of starting an asynchronous motor.  At time 1 s.  A torque of 700 N * m is applied to the shaft and the engine goes into operating mode. <br><br><img src="https://habrastorage.org/files/aed/e4e/db3/aede4edb33c54bf1aaad97798a8a4299.png"><br>  <i>Fig.</i>  <i>6 - Graphs of the frequency of rotation of the motor shaft, as well as the torque on the shaft and the static torque when the engine is started</i> <br><br><h5>  Parallel RLC - load -t rlc </h5><br>  This elementary node is a parallel connection of active resistance, inductance and capacitance.  Depending on the parameters, it allows modeling the following standard and non-standard modes of exposure to a voltage source: one- and two-phase load, asymmetrical load, short circuit in phase short and long in time, short circuit to earth in all phases, short and long in time. <br><br><div class="spoiler">  <b class="spoiler_title">Table 5 - Configuration keys for the rlc node</b> <div class="spoiler_text"><table><tbody><tr><td>  Key </td><td>  Default value </td><td>  Description </td></tr><tr><td>  -Ra {ohm} <br>  -Rb {ohm} <br>  -Rc {ohm} </td><td>  0 (disabled) </td><td>  Resistor in phase </td></tr><tr><td>  -R {ohm} </td><td>  0 (disabled) </td><td>  Resistance in all phases </td></tr><tr><td>  -La {gn} <br>  -Lb {h} <br>  -Lc {gn} </td><td>  0 (disabled) </td><td>  Inductance of the choke in phase </td></tr><tr><td>  -L {H} </td><td>  0 (disabled) </td><td>  Inductance of choke in all phases </td></tr><tr><td>  -Ca {uF} <br>  -Cb {uF} <br>  -Cc {uF} </td><td>  0 (disabled) </td><td>  Capacitor in phase </td></tr><tr><td>  -C {ŒºF} </td><td>  0 (disabled) </td><td>  Capacitor capacitance in all phases </td></tr></tbody></table><br></div></div><br>  Simulate short-term short circuit in the network: <br><br><pre> <code class="bash hljs">load -t acmotor -Rs 0.02 -Rr 0.02 -Ls 0.0008 -Lr 0.0002 -Lm 0.00015 -J 3 -p 2 -Ms 700 -Tload 1 load -t rlc -Ra 0.2 -Rb 0.2 -Rc 0.2 -On 1.5 -Off 1.6</code> </pre> <br><img src="https://habrastorage.org/files/589/251/306/589251306bbe49b3b256c854c4154632.png"><br><br>  KZ 0.1 s.  The speed does not have time to fall below the critical, the engine restores speed after removing the short circuit. <br><br><pre> <code class="bash hljs">load -t acmotor -Rs 0.02 -Rr 0.02 -Ls 0.0008 -Lr 0.0002 -Lm 0.00015 -J 3 -p 2 -Ms 700 -Tload 1 load -t rlc -Ra 0.2 -Rb 0.2 -Rc 0.2 -On 1.5 -Off 2</code> </pre> <br><img src="https://habrastorage.org/files/56a/3e9/005/56a3e90052ac41b7ad6b9f535ed92ead.png"><br><br>  CZ 0.5 s, the engine has time to brake and after switching on the engine torque becomes less than the torque on the shaft and the engine crashes <br><br><pre> <code class="bash hljs">load -t acmotor -Rs 0.02 -Rr 0.02 -Ls 0.0008 -Lr 0.0002 -Lm 0.00015 -J 3 -p 2 -Ms 700 -Tload 1 load -t rlc -Ra 0.2 -On 1.5</code> </pre> <br><img src="https://habrastorage.org/files/e06/f56/62f/e06f5662f69d434da433a67ca3241c96.png"><br><br>  The closure in Phase A. The speed practically does not sag, because of the peculiarities of the asynchronous electric motor, it only needs two phases.  The rotating magnetic field in the gap takes an oval shape and the shaft begins to vibrate with the frequency of the supply network. <br><br><h4>  <b>Code optimization</b> </h4><br>  In general, as it turned out, the main process of modeling itself was written quite accurately and no architectural changes were made according to the results of the modeling.  But the devil is in the details. <br>  Open Intel Vtune Amplifier, create a new project: <br><br><img src="https://habrastorage.org/files/a2e/0e8/d45/a2e0e8d455e448f39d9b750e03f6c7f1.png"><br><br>  Specify the path to our program and launch keys.  It would be nice to use the Binary / Symbol Search and Source Search buttons and specify the paths to the source code and binaries with Debud-symbols - then it will be more convenient to navigate through the project and the source code. <br><br>  We use the following config: <br><br><div class="spoiler">  <b class="spoiler_title">source_and_motor.txt one source, one motor</b> <div class="spoiler_text"><pre> <code class="bash hljs">//create new solve system: setup -Off 10 -f 3200 //128 ticks per period load -t workbench -name wb0 load -t acsource -name ideal3f -f 50 -Ud 220 -R 0.1 //-L 0.001 load -t motor -name motor5 -On 0.5 -Off 4 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t analyzer -name analyzer1 -tRMS 0.02 -U -I -P -E -Collect link -output ideal3f -input analyzer1 link -output analyzer1 -input motor5 solve graph</code> </pre></div></div><br>  All the above config files are in the / doc folder of the project. <br><br>  Let's start with the simplest basic hotspot with an interval of 1ms <br><br><img src="https://habrastorage.org/files/d31/721/d15/d31721d15d7a454b8247632689b4f568.png"><br><br>  And run. <br><table><tbody><tr><td>  Elapsed Time: </td><td>  52.548s </td></tr><tr><td>  CPU Time: </td><td>  37.460s </td></tr><tr><td>  Total Thread Count: </td><td>  1,035 </td></tr></tbody></table><br>  Top Hotspots: <br><img src="https://habrastorage.org/files/040/4c0/a28/0404c0a28c8c4e4ab5d4ae8edd45739e.png"><br><br>  Holy neutrons ... Of course, I knew that iostream is slow, but so much ... This, by the way, is disabling synchronization with <br><br><pre> <code class="cpp hljs">stdio ios_base::sync_with_stdio(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><img src="https://habrastorage.org/files/2b3/372/b5e/2b3372b5e4c14f298b03bb122426bb48.png"><br><br>  20 seconds of CPU time out of a total of 35 seconds.  More than 50% of the time.  It does not go into any gate. <br>  You can read more about how slow the threads are <a href="https://habrahabr.ru/post/246257/">here</a> .  It makes sense to rewrite everything to armored fprintf ().  I was also interested that the <i>cout</i> function appears in the table twice.  And for sure - the gnuplot layer creates temporary files and then deletes them.  Add the <i>-raw</i> key to the node to save the raw graph files.  There are keys - saved, no, not saved. <br>  Run the profiler.  Ha! <br><br><table><tbody><tr><td>  Elapsed Time: </td><td>  22.421s </td></tr><tr><td>  CPU Time: </td><td>  17.107s </td></tr><tr><td>  Total Thread Count: </td><td>  1,035 </td></tr></tbody></table><br>  Top Hotspots: <br><br><img src="https://habrastorage.org/files/fea/9fd/e55/fea9fde55c0e4ebcaa017f520f4e1030.png"><br><br>  The leaders are still file output, but consuming less than 5% of CPU time.  Serious success!  Watch Bottom-Up three <br><br><img src="https://habrastorage.org/files/b27/37b/5bf/b2737b5bfa5d4dec991e47e58af66925.png"><br><br>  The second and third place is taken by pointers and iterators: <br><br><img src="https://habrastorage.org/files/583/1ba/e6f/5831bae6f9534f0fa4a94fb98ef0183d.png"><br><br>  And that is quite logical - the place gets the power quality analyzer, because the latter does a lot of all the work. <br><br><img src="https://habrastorage.org/files/c6d/9e5/f68/c6d9e5f68bd44e07b8dc68b228c9bafd.png"><br><br>  This code was written as a test of the concept of sliding measurement mode.  As can be seen from the code, each new step of the solver is associated with a shift of a small (64-128 characters), but still an array.  It makes sense to use a ring buffer to solve this problem.  Then the operation of adding a new element will have the value O (1) instead of O (N). <br><br><img src="https://habrastorage.org/files/b10/fcc/d73/b10fccd73cc34437893835f4181a4e73.png"><br><br>  ‚ÄúWhy is this necessary?‚Äù You say, they say, the quality analyzer is one in the system, it is better to add motors to the config.  And you will be half right - we will definitely add the motors, only analyzers in the system can be exactly as much as in the system of nodes - this is a feature of my thesis. <br>  Let's look at what‚Äôs wrong with GetVoltage and GetCurrent bad: <br><br><img src="https://habrastorage.org/files/1bb/b0a/317/1bbb0a31710042ef86e4b66eec1d5348.png"><br><br>  Hmm, how about using links? <br><br><img src="https://habrastorage.org/files/90f/9d1/978/90f9d19783f64c8e96f02f6b114208b8.png"><br><br>  Restart profiling: <br><br><table><tbody><tr><td>  Elapsed Time: </td><td>  23.197s </td></tr><tr><td>  CPU Time: </td><td>  16.551s </td></tr><tr><td>  Total Thread Count: </td><td>  1,048 </td></tr></tbody></table><br>  Top Hotspots: <br><br><img src="https://habrastorage.org/files/83b/268/885/83b2688852894f81a13a119f8c194b41.png"><br><br>  Bottom-Up three shows that, again, the first in the list is our fprintf and pango, crawling out from under the gnuplot - we‚Äôll no longer be crawling into them (although it would be worth it). <br><br><img src="https://habrastorage.org/files/f1e/de5/140/f1ede51402644e369179e5e79f12565d.png"><br><br>  What really pleases is the fact that NewStep, from which a couple of steps to Solve took the lead.  Run the simulation for 40 seconds and see how the picture changes: <br><br><table><tbody><tr><td>  Elapsed Time: </td><td>  73.235s </td></tr><tr><td>  CPU Time: </td><td>  61.790s </td></tr><tr><td>  Total Thread Count: </td><td>  1,048 </td></tr></tbody></table><br><img src="https://habrastorage.org/files/1de/a09/ca1/1dea09ca1c3c4f32bc3d4d7f1f2bb7d5.png"><br><br>  The effect is scaled, so here we have nothing to do. <br><br>  Summarize <br><table><tbody><tr><td></td><td>  It was </td><td>  It became </td><td>  Effect </td></tr><tr><td>  CPU Time: </td><td>  37.460s </td><td>  16.551s </td><td>  226% </td></tr></tbody></table><br>  Not bad for half an hour of work? <br>  Add to the engine heel system: <br><br><div class="spoiler">  <b class="spoiler_title">source_and_motors.txt: One source five motors</b> <div class="spoiler_text"><pre> <code class="bash hljs">//create new solve system: setup -Off 10 -f 3200 //64 ticks per period load -t workbench -name wb0 load -t acsource -name ideal3f -f 50 -Ud 220 -R 0.1 //-L 0.001 load -t motor -name motor1 -On 0.5 -Off 5 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t motor -name motor2 -On 1 -Off 6 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t motor -name motor3 -On 1.5 -Off 7 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t motor -name motor4 -On 2 -Off 8 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t motor -name motor5 -On 2.5 -Off 9 -Rs 2 -Rr 0.8 -Ls 0.00991 -Lr 0.00991 -Lm 0.008419 -J 0.5 -p 2 -Ms 50 -Tload 2 -saveGraph//15kW load -t analyzer -name analyzer1 -tRMS 0.02 -U -I -P -E -Collect link -output ideal3f -input analyzer1 link -output analyzer1 -input motor1 link -output analyzer1 -input motor2 link -output analyzer1 -input motor3 link -output analyzer1 -input motor4 link -output analyzer1 -input motor5 solve graph</code> </pre></div></div><br>  From Bottom-Up three, little is clear: <br><br><img src="https://habrastorage.org/files/7a1/fed/bb9/7a1fedbb92074f5c84248a03fc9905f1.png"><br><br>  Now, if you look at the Caller counter, you can see where the resources go.  On the solution of matrix equations in the calculation of mat.  motor models - most of the time the Eigen library is running. <br><br><img src="https://habrastorage.org/files/3db/329/250/3db329250def462b8c1cfba278833bb8.png"><br><br>  We won‚Äôt get into the library; we‚Äôll better replace the motors with rl-loads.  They are much more important to me - you can create all sorts of different phase distortions, short circuits, disturbances and other joys. <br><br>  Since we don‚Äôt really need to count anything on one tick, we‚Äôll increase the clocking frequency of the solver, and we will increase the loads to 10 units. <br><br><div class="spoiler">  <b class="spoiler_title">source_and_rlc.txt One source and 10 RL loads</b> <div class="spoiler_text"><pre> <code class="bash hljs">//create new solve system: setup -Off 10 -f 6400 //128 ticks per period load -t workbench -name wb0 load -t acsource -name ideal3f -f 50 -Ud 220 -R 0.1 //-L 0.001 load -t rlc -name rl1 -On 1 -Off 34 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl2 -On 2 -Off 35 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl3 -On 3 -Off 36 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl4 -On 4 -Off 37 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl5 -On 5 -Off 38 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl11 -On 11 -Off 24 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl21 -On 12 -Off 25 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl31 -On 13 -Off 26 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl41 -On 14 -Off 27 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t rlc -name rl51 -On 15 -Off 28 -Ra 100 -Rb 100 -Rc 100 -La 0.01 -Lb 0.01 -Lc 0.01 load -t analyzer -name analyzer1 -tRMS 0.02 -U -I -P -E -Collect link -output ideal3f -input analyzer1 link -output analyzer1 -input rl1 link -output analyzer1 -input rl2 link -output analyzer1 -input rl3 link -output analyzer1 -input rl4 link -output analyzer1 -input rl5 link -output analyzer1 -input rl11 link -output analyzer1 -input rl21 link -output analyzer1 -input rl31 link -output analyzer1 -input rl41 link -output analyzer1 -input rl51 solve graph</code> </pre></div></div><br><table><tbody><tr><td>  Elapsed Time: </td><td>  11.008s </td></tr><tr><td>  CPU Time: </td><td>  6.485s </td></tr><tr><td>  Total Thread Count: </td><td>  1.245 </td></tr></tbody></table><br><img src="https://habrastorage.org/files/1ac/faf/848/1acfaf8484a8448c8e7be8e13371cc45.png"><br><br>  Fprintf we do not touch, but the main culprit: <br><br><img src="https://habrastorage.org/files/c7f/44f/6a3/c7f44f6a35074884b34e3c1bc73ad9ee.png"><br><br>  Here we copy the double [4] vectors into each other.  As you can see, vector copying by means of the vector itself is not very optimal.  Zababahay we ka cycle - for 4 elements, especially it is not necessary to run out: <br><br><img src="https://habrastorage.org/files/1e8/437/859/1e84378593ed4bdca8cc8bdffcb8ca2c.png"><br><br>  And the last time <br><table><tbody><tr><td>  Elapsed Time: </td><td>  9.563s </td></tr><tr><td>  CPU Time: </td><td>  6.386s </td></tr><tr><td>  Total Thread Count: </td><td>  1.245 </td></tr></tbody></table><br><img src="https://habrastorage.org/files/892/70f/6a1/89270f6a174a43c7809d59ade8c9028b.png"><br><br><img src="https://habrastorage.org/files/9fa/790/209/9fa790209e554aba810671a0dfa06cd0.gif"><br><br><h4>  <b>Findings:</b> </h4><br>  And they do not have.  I decided for myself that it was useless to upload brake applications in OpenSource and sat a little with a convenient and powerful profiling tool.  In contrast to the placement of timestamps inside the code, Vtune, as they say, ‚Äúpokes the muzzle‚Äù into a slow code, hinting that it would be nice to rewrite one or another piece. <br><br>  My application, in fact, can be infinitely optimized - for a crutch on a crutch.  You can throw out Eigen and rewrite Acmotor using Boost; you can write graph output on the same Boost; . <br><br>  By the way, <a href="https://software.intel.com/en-us/academic">here</a> you can get a free version of Intel parallel Studio for student and educational needs. </div><p>Source: <a href="https://habr.com/ru/post/301684/">https://habr.com/ru/post/301684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301668/index.html">10 years of Habrahabru: Top 10 most popular articles on our blog</a></li>
<li><a href="../301670/index.html">"I am the director" - a television broadcast at the junction of technology</a></li>
<li><a href="../301674/index.html">Am I a programmer, or just google well?</a></li>
<li><a href="../301676/index.html">Broadcaster for MacBook. Pivot</a></li>
<li><a href="../301682/index.html">Nutanix SX-1065 Xpress: Nutanix for the SMB Market</a></li>
<li><a href="../301692/index.html">DevCon 2016. Opening of the conference at 10:00! Connect to the online broadcast today</a></li>
<li><a href="../301696/index.html">Implementing an auto attendant based on Cisco solutions</a></li>
<li><a href="../301698/index.html">Improve multimedia application performance with hardware acceleration</a></li>
<li><a href="../301700/index.html">HowTo: Connect to Cisco VPN using Aladdin eToken on Linux (Ubuntu)</a></li>
<li><a href="../301702/index.html">Functional testing of Qt programs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>