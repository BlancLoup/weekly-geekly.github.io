<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intervals in C ++, part 4: to infinity and beyond</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last part, I talked about the concept of incremental (Iterable) and showed how they solve many problems inherent in standard intervals. Now I w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intervals in C ++, part 4: to infinity and beyond</h1><div class="post__text post__text-html js-mediator-article">  In the last <a href="http://habrahabr.ru/company/cpp_russia/blog/264975/">part,</a> I talked about the concept of incremental (Iterable) and showed how they solve many problems inherent in standard intervals.  Now I will expand this concept to make infinite interval programming more secure and efficient. <br><br>  <i>Disclaimer</i> : ideas in this post are more speculative than in previous ones.  I will be glad to <a href="http://meetingcpp.ru/">discuss</a> . <br><a name="habracut"></a><br>  In addition to the solved problems, which I mentioned in previous posts, there are still two.  It: <br><br><ol><li>  Some STL algorithms do not work at infinite intervals. </li><li>  Infinite or perhaps infinite intervals cause the difference_type to overflow </li></ol><br><h2>  Infinite iterators </h2><br>  <a href="http://habrahabr.ru/company/cpp_russia/blog/264473/">iota_range</a> is an infinite interval of integers, starting with some value and lasting forever.  This is a sorted direct interval.  Here are the algorithms of binary search, working with sorted direct intervals, will not work with him.  It is impossible to conquer infinity by dividing (a good phrase turned out) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Is it possible to fix the STL algorithms so that they do not break when receiving an infinite interval?  In their current form, no - it is impossible at the compilation stage to transmit information that any of the iterators denotes an infinite interval.  Think about this: the following code will work: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  : iota_range&lt;bigint&gt; rng; auto i = std::lower_bound(rng.begin(), std::next(rng.begin(), 10), 5);</span></span></code> </pre> <br><br>  but this will work "forever": <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ¬´¬ª :'-( iota_range&lt;bigint&gt; rng; auto i = std::lower_bound(rng.begin(), rng.end(), 5);</span></span></code> </pre><br><br>  If rng.begin () has the same type as rng.end (), the two calls return the same instance of lower_bound.  The function will not be able to determine whether it will work forever or not.  But if it is possible to allow the signal iterator to be of a different type, we will be able to carry out this check at the compilation stage. <br>  Suppose we have a type function (metafunction) called DenotesInfiniteSequence, which takes a pair of types (BeginType, EndType) and tells whether the sequence will be infinite.  We have already determined that if BeginType and EndType are the same, then the DenotesInfiniteSequence should return false, since it will not be able to verify this in any way.  But if they are different - for example, EndType will be of type unreachable_sentinel or something like that, then we will know at the compilation stage that the sequence is infinite. <br><br><h2>  Infinite intervals </h2><br>  Some intervals, by definition, will be infinite, even having an initial and final iterator of the same type. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    class zeros : public range_facade&lt;zeros&gt; { friend range_core_access; struct impl { bool sentinel; int current() const { return 0; } void next() {} bool equal(impl that) const { return sentinel == that.sentinel; } }; // begin()  end()   range_facade //  begin_impl  end_impl.      impl begin_impl() const { return {false}; } impl end_impl() const { return {true}; } }; //    Range CONCEPT_ASSERT(Range&lt;zeros&gt;()); int main() { //  for_each(zeros(), [](int i) {/*...*/}); }</span></span></code> </pre><br><br>  I would like to immediately catch such errors, but, obviously, the binary function DenotesInfiniteSequence cannot cope with this.  For zeros, the BeginType and EndType types will be the same, so the DenotesInfiniteSequence will return false. <br><br>  Therefore, it is necessary to construct a unary function of the IsInfinite types that takes an interval type. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,   Iterable  template&lt;typename Iterable&gt; struct is_infinite : std::integral_constant&lt;bool, true-or-false&gt; {};</span></span></code> </pre><br><br>  It can be used to define the concept of FiniteIterable. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    Concept Lite template&lt;typename T&gt; concept bool FiniteIterable = Iterable&lt;T&gt; &amp;&amp; !is_infinite&lt;T&gt;::value;</span></span></code> </pre><br><br>  Each FiniteIterable is iterable.  There is a parallel hierarchy of refinements: <br><br><img src="http://ericniebler.com/wp-content/uploads/2014/02/finite-iterable-hierarchy.dot_.notugly.png" alt="image"><br><br>  And all these concepts, by analogy with Range, do not need to be defined in the code.  The finiteness is orthogonal to the Iterable hierarchy, and it can be queried separately. <br><br>  But why FiniteIterable, and not InfiniteIterable?  It's all about the algorithms and their requirements.  There are no algorithms that require their interval arguments to be infinite.  Therefore, it would be useless to be able to write InfiniteIterable.  But an algorithm like lower_bound would like the interval to be finite.  From this and FiniteIterable. <br><br>  This means that all iterators model FiniteIterable by default, and the type must somehow learn to be infinite.  How?  You can specialize is_infinite.  Fortunately, tools for creating incrementors and spacing accept the optional parameter IsInfinite, so this is easy to do.  This is what the zeroes class now looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   class zeros : public range_facade&lt;zeros, true&gt; { // ... IsInfinite ...................^^^^ // ...  ,   ... }; // zeros ‚Äì  Range,    Finite CONCEPT_ASSERT(Range&lt;zeros&gt;()); CONCEPT_ASSERT(!FiniteIterable&lt;zeros&gt;());</span></span></code> </pre><br><br>  By adding the FiniteIterable concept, we give algorithms that need a limb to test this at the compilation stage. <br><br><h2>  Perhaps infinite intervals </h2><br>  Now we need to divide the intervals into categories.  In theory, either it is infinite or finite - is not it?  Actually, no.  Take istream.  It may be finite, it may not be.  Normally the flow stops, but sometimes ... <br><br>  The situation is complicated.  Is it necessary to prohibit the transfer of istream to the algorithm only because it can be infinite? <br><br><h2>  We count the uncountable </h2><br>  With infinite intervals, there is such a difficulty: all iterators and all incrementors have a related difference_type.  Alexander Stepanov writes about this: <br><br><blockquote>  DistanceType returns an integer type large enough to measure any sequence of successor applications that are valid for the type. </blockquote><br><br>  It turns out that we need a whole type of infinite size.  Is there a solution to this problem? <br><br><ol><li>  In C ++, a bigint is required - an integer type with infinite precision.  In other languages ‚Äã‚Äãit is.  C ++ is an excellent language for creating libraries, and the library is simply asking for this topic.  If there was such a type, it could be taken as the difference_type. </li><li>  Infinite intervals can use safe_int as difference_type.  safe_int behaves like an int, but can represent infinity.  It does not overflow.  The two most difficult problems with overflow are the difference_type - indefinite behavior and the inability to say after the fact what went wrong.  With safe_int, uncertainties can be avoided and subsequently find out what happened. </li><li>  You can offer an alternative implementation of safe_int, in which it throws an exception during an overflow. </li><li>  You could also see where the library uses the difference_type and allow the user to specify that another type will be used there.  For example, the distance calculation algorithm API may take an interval and an optional initial value.  It would by default work with difference_type {0}, but if you gave bigint to it, you would work with it differently, slower, but safer. </li><li>  You can ignore the problem.  And those who care about overflow can use the counting interval adapter (https://github.com/ericniebler/range-v3/blob/master/include/range/v3/view/counted.hpp) to make sure that the iterations stop before the difference_type overflows. </li><li>  Something else that did not occur to me. </li></ol><br><br>  I, of course, do not like everything that slows down the work of the algorithms, so std :: ptrdiff_t can be left as the default difference_type.  In addition, you need to develop interval interfaces so that users can specify a different difference_type if they care about overflow.  Therefore, I like options 4 and 5. Other library types like bigint or safe_int with certain restrictions would be nice to be able to apply - if the user could specify their use, changing the speed to security when he needs it. <br><br><h2>  The result, and what to do next </h2><br>  Perhaps, reading the previous posts, you were too optimistic: everything seemed to be starting to turn out, and now you are confused.  But it seems to me that we have made good progress compared to where we started from.  I described 5 problems with intervals using a couple of iterators.  The new concept of incrementors solves 3 of them, the 4th problem (infinite intervals) can theoretically be solved by improving this concept.  And there are several options for working with the 5th (overflow).  At least, a start. <br><br>  Some ask if I plan to bring my ideas to the C ++ Standardization Committee.  Of course.  When we get support for concepts in a language, there will be a need for a conceptualized version of STL, possibly operating in a different namespace. <br><br>  In the meantime, I will discuss the issue on the SG9 (Ranges) mailing list (http://www.open-std.org/mailman/listinfo/ranges).  This controversial issue will certainly be able to generate new ideas.  Interested urge to join the discussion. <br><br>  <i>The author brought his ideas to the committee and is now engaged in their implementation.</i> <i><br></i>  <i><b>Other articles of the cycle</b></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264201/">Intervals in C ++, part 1: Intervals with limiters</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264473/">Intervals in C ++, part 2: Infinite intervals</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264975/">Intervals in C ++, part 3: we represent incrementors (Iterable)</a></i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/265355/">https://habr.com/ru/post/265355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265341/index.html">Results of the campaign "I want ThinkServer", the first report</a></li>
<li><a href="../265343/index.html">Five reasons to try the new release of Intel Media Server Studio 2015 R6</a></li>
<li><a href="../265347/index.html">New Free Intel¬Æ DAAL Data Analytics Library</a></li>
<li><a href="../265349/index.html">Overview of payment aggregators for receiving payments</a></li>
<li><a href="../265351/index.html">The present and future of C ++. Interview with Eric Niebler</a></li>
<li><a href="../265357/index.html">Minimalistic Mobile Layout</a></li>
<li><a href="../265361/index.html">The evolution of marketing: from a small online store to a hypermarket</a></li>
<li><a href="../265365/index.html">Tinkoff Bank compromised customer account statements?</a></li>
<li><a href="../265367/index.html">Wikipedia is no longer blocked</a></li>
<li><a href="../265371/index.html">Nhibernate: Mapping Options, Query Options</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>