<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET Framework. Memory management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses some of the points about working with memory in the .NET Framework. The article describes the work of the GC, how the GC contro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET Framework. Memory management</h1><div class="post__text post__text-html js-mediator-article">  This article discusses some of the points about working with memory in the .NET Framework.  The article describes the work of the GC, how the GC controls its hip, modes of operation of the GC.  Examples are given for using memory around GC.  I outlined not only easily accessible information, but also that which is available only when studying dumps of applications written in .NET.  I hope the article turned out informative and not very boring.  The next article will be about the loader, JIT, and its data structures, such as Method Tables, Method Descriptors, and EEClass. <br><a name="habracut"></a><br><h1>  Theory </h1><br><h2>  Unmanaged memory </h2><br>  Virtual memory is a logical representation of memory that does not necessarily affect the physical memory of the process.  On 32-bit operating systems, 4Gb of virtual address space is allocated to processes.  The default is 2Gb on user mode.  We focus on user mode, not kernel mode. <br>  When a process needs to allocate memory, it must first reserve it, then it must fix the memory.  This backup / commit process can be performed in one or two steps, depending on how you use the API to manipulate virtual memory. <br>  Usually reserved memory is divided into the following parts: <br><ul><li>  Threads (and stacks); </li><li>  .Dll files; </li><li>  Virtual memory allocation; </li><li>  NT hip; </li><li>  Heap memory managers such as .NET GC. </li></ul><br>  Managed memory is allocated in parts.  Allocations of memory can be on 16, 32 and 64Kb.  They must be allocated in uninterrupted blocks, and if there are not enough memory regions to allocate, the process throws an OutOfMemoryException.  If the process cannot complete garbage collection, there is not enough memory for the internal structures of the garbage collector, the process will crash. <br>  You must examine the application and avoid even non-fatal OutOfMemoryException exceptions, because the process may be in an unstable state after this exception. <br>  The role of user mode memory managers is to manage virtual memory reservations.  Memory managers use several algorithms to achieve different goals in memory management, such as small fragmentation, redundancy of large blocks. <br>  Before a process can use memory, it must reserve and commit at least part of the memory.  These 2 steps can be performed using the <a href="http://msdn.microsoft.com/en-us/library/aa366887.aspx">VirtualAlloc</a> API, <a href="http://msdn.microsoft.com/en-us/library/aa366890.aspx">VirtualAllocEx</a> .  You can free up memory using <a href="http://msdn.microsoft.com/en-us/library/aa366892.aspx">VirtualFree</a> or <a href="http://msdn.microsoft.com/en-us/library/aa366894.aspx">VirtualFreeEx</a> .  Calling the last functions will change the state of the memory blocks from ‚Äúfixed‚Äù to ‚Äúfree‚Äù. <br>  We steal ideas from developers on c ++.  There are situations when using GC (we will talk about it later) for reasons of intensive work with memory is not possible.  Such situations are rare, and arise with specific limitations.  In this case, you can implement malloc and free.  Malloc makes a call to <a href="http://msdn.microsoft.com/en-us/library/aa366597.aspx">HeapAlloc</a> , and free is a call to <a href="http://msdn.microsoft.com/en-us/library/aa366701.aspx">HeapFree</a> .  You can create your own hip by calling <a href="http://msdn.microsoft.com/en-us/library/aa366599.aspx">HeapCreate</a> .  A complete list of functions for working with memory in the Windows environment can be found at - <a href="http://msdn.microsoft.com/en-us/library/aa366781.aspx">Memory Management Functions</a> . <br>  I am not a linux developer, so I cannot say what to replace the calls to these API functions.  Those who will also need to use these functions, I suggest to implement it using the <a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Abstract factory pattern pattern</a> , even if you are not going to transfer your application in the near future to the Mono platform.  The use of these functions is generally not very correct, as it creates some difficulties with portability, but in some very specific situations, in order to reduce the pressure on the GC, you have to use it. <br><br><h2>  Managed memory </h2><br>  The process memory consists of: <br><ul><li>  Managed Hips - save all managed objects that GC has not yet assembled; </li><li>  The bootloader headers are dynamic modules and storage for JIT compiled objects, such as method tables, method descriptions and EEClass (The next article will be devoted to JIT and its structures); </li><li>  Native heaps - heaps for native memory; </li><li>  Memory used for streams, their stacks and registers; </li><li>  Memory for storing native dll files, as well as for the native parts of managed dll files; </li><li>  Other virtual memory allocations are not suitable for one category described above; </li><li>  Not yet used areas of memory. </li></ul><br>  Well, here we come to the GC hip.  The garbage collector (GC) allocates and frees memory for managed code.  GC uses VirtualAlloc to reserve memory for its hip.  The heap size depends on the GC mode, and the version of the .NET Framework.  The size can be 16, 32 or 64Mb.  Hip GC is an inseparable block of virtual memory isolated from other process heaps and managed by the .NET Runtime.  Interestingly, the GC does not immediately capture the entire section of memory, but only as it grows.  The GC tracks the next free address at the end of the managed heap, and requests the next block of memory, if necessary, starting with it.  A separate heap is created for large objects (the .NET Framework 2.0, in 1.1 large objects are in the same heap as the generations are in, but in a different segment).  Large object - an object larger than 85000 bytes. <br>  Focus on the work of the GC.  GC uses 3 generations (0, 1, 2) and LOH (Hip for large objects).  Created objects fall into the zero generation.  As soon as the size of the zero generation reaches the threshold value (there is no more memory for it in the segment) and the creation of a new object is not possible, in the zero generation the garbage collection begins.  If there is a shortage of memory in the first generation segment, the garbage collection will be for the first generation, and for zero.  When collecting garbage for the 2nd generation, there will also be garbage collection for the first and zero generation. <br>  Objects survived after the generation of garbage in the zero generation go to the first, from the first to the second.  Based on the foregoing, it is highly not recommended to manually call garbage collection, as this can greatly affect the performance of your application (looking for examples when the garbage collection call is correct, please write in a comment to discuss this issue). <br>  For large objects there are no generations.  In the new .NET framework starting from 1.1, if an object that is at the end of the heap is deleted, the Private Bytes process is reduced. <br>  Very interesting issue of the GC - What actually happens when garbage collection?  GC performs several steps regardless of whether garbage collection occurs, for 0, 1, 2 generations, or full garbage collection.  So, the stages of garbage collection: <br><ul><li>  The initial stage of the GC - waits until all managed flows reach a point in execution, when it is safe to suspend them; </li><li>  Objects that have no links are marked as ready for deletion; </li><li>  GC plans segment sizes for generations and assesses the level of fragmentation in the heap after performing garbage collection; </li><li>  Removes items marked for deletion.  Enters these object addresses into the list of free space addresses if the GC is non-compact; </li><li>  Moves objects to lower addresses of a managed heap.  The most expensive operation; </li><li>  Resume managed threads. </li></ul><br>  Modes of operation GC: <br><ul><li>  Competing - created for GUI applications when response time is important.  Suspends the execution of an application several times during the garbage collection process giving it processor time to execute.  GC uses one hip and one stream; </li><li>  Non Compliant ‚Äî Suspends the application until the garbage collection is complete.  GC uses one hip and one stream; </li><li>  Server - maximum performance on a machine with multiple processors or cores.  GC uses one hip per processor, as well as one thread per core. </li></ul><br>  How to enable the desired mode GC.  In the configuration file, the configuration / runtime section: <br><ul><li>  Competing - &lt;gcConcurrent = true&gt;; </li><li>  Noncompetitive - &lt;gcConcurrent = false&gt;; </li><li>  Server - &lt;gcServer Enabled = true&gt;. </li></ul><br>  Increasing GC performance comes down to solving the following problems: <br><ul><li>  Frequent and large allocation of objects - causes the GC to collect garbage more often.  Frequent allocation of large objects can cause a large processor load, since the LOH garbage collection causes the second generation garbage collection; </li><li>  Allocating memory in advance - creates several problems.  Firstly, it causes GC to collect garbage more often, and secondly, it allows objects to survive the assembly; </li><li>  Many ancestors or pointers - when moving objects and reducing fragmentation, all pointers will have to be changed, in accordance with the new addresses of objects.  Objects can be at reduced fragmentation are spaced apart in different directions of the segment in the heap.  All this can negatively affect the speed of execution; </li><li>  A lot of objects that have time to get into the next generation, and do not live there for long - objects that survive the garbage collection, get into the next generation, but do not stay there for a long time.  They put pressure on the next generation, and can cause costly garbage collection operations in this generation; </li><li>  Objects that cannot be moved (GCHandleType.Pinned, Interop, fixed) - increases the fragmentation of the memory of generations and the GC can search for a contiguous area of ‚Äã‚Äãmemory for a new object longer. </li></ul><br>  GC uses links to determine if it is possible to free up memory occupied by an object.  Before you perform garbage collection, GC begins with ancestors and goes up the links building them in the form of a tree.  Using a list of links to all objects, it determines objects that are inaccessible and ready for garbage collection. <br>  There are several types of links: <br><ul><li>  Strong link.  Existing reference to a ‚Äúlive‚Äù object.  This prevents the object from garbage collection; </li><li>  Weak link  The existing link to a ‚Äúlive‚Äù object, but allowing you to remove the object that is referenced during garbage collection.  This type of links can be used for example for a caching system. </li></ul><br>  I wanted to write about the finalization, but the information on it is complete.  The only thing to note is that an additional stream of finalization is added to each process, and the process can be suspended, if blocking this stream is blocked, and the crash of the finalization stream leads to the crash of the entire application starting from .NET Framework 2.0, in previous versions there will be a restart of the stream. <br><br><h1>  Some examples of working with memory without GC </h1><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.ConstrainedExecution; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TestApplication</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> NativeMethods internal static class NativeMethods { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Virtual memory #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> VirtualAlloc [Flags()] public enum AllocationType : uint { MEM_COMMIT = 0x1000, MEM_RESERVE = 0x2000, MEM_RESET = 0x80000, [Obsolete("Windows XP/2000: This flag is not supported.")] MEM_LARGE_PAGES = 0x20000000, MEM_PHYSICAL = 0x400000, MEM_TOP_DOWN = 0x100000, [Obsolete("Windows 2000: This flag is not supported.")] MEM_WRITE_WATCH = 0x200000, } [Flags()] public enum MemoryProtection : uint { PAGE_EXECUTE = 0x10, PAGE_EXECUTE_READ = 0x20, PAGE_EXECUTE_READWRITE = 0x40, [Obsolete("This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. It is not supported by the CreateFileMapping function until Windows Vista with P1 andWindows Server 2008.")] PAGE_EXECUTE_WRITECOPY = 080, PAGE_NOACCESS = 0x01, PAGE_READONLY = 0x02, PAGE_READWRITE = 0x04, [Obsolete("This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.")] PAGE_WRITECOPY = 0x08, PAGE_GUARD = 0x100, PAGE_NOCACHE = 0x200, PAGE_WRITECOMBINE = 0x400, } [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] internal static extern IntPtr VirtualAlloc( IntPtr lpAddress, IntPtr dwSize, AllocationType flAllocationType, MemoryProtection flProtect); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> VirtualFree [Flags()] public enum FreeType : uint { MEM_DECOMMIT = 0x4000, MEM_RELEASE = 0x8000, } [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] [return: MarshalAs(UnmanagedType.Bool)] internal static extern bool VirtualFree( IntPtr lpAddress, IntPtr dwSize, FreeType dwFreeType); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Heap #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HeapCreate [Flags()] public enum HeapOptions : uint { Empty = 0x00000000, HEAP_CREATE_ENABLE_EXECUTE = 0x00040000, HEAP_GENERATE_EXCEPTIONS = 0x00000004, HEAP_NO_SERIALIZE = 0x00000001, } [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] internal static extern IntPtr HeapCreate( HeapOptions flOptions, IntPtr dwInitialSize, IntPtr dwMaximumSize); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HeapDestroy [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] [return: MarshalAs(UnmanagedType.Bool)] internal static extern bool HeapDestroy( IntPtr hHeap); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HeapAlloc [Flags()] public enum HeapAllocFlags : uint { Empty = 0x00000000, HEAP_GENERATE_EXCEPTIONS = 0x00000004, HEAP_NO_SERIALIZE = 0x00000001, HEAP_ZERO_MEMORY = 0x00000008, } [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] internal static extern unsafe void* HeapAlloc( HeapHandle hHeap, HeapAllocFlags dwFlags, IntPtr dwBytes); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HeapFree [Flags()] public enum HeapFreeFlags : uint { Empty = 0x00000000, HEAP_NO_SERIALIZE = 0x00000001, } [DllImport( "kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)] [return: MarshalAs(UnmanagedType.Bool)] internal static extern unsafe bool HeapFree( HeapHandle hHeap, HeapFreeFlags dwFlags, void* lpMem); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Memory handles #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> VirtualMemoryHandle internal sealed class VirtualMemoryHandle : SafeHandle { public VirtualMemoryHandle(IntPtr handle, IntPtr size) : base(handle, true) { Size = size; } [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] override protected bool ReleaseHandle() { return NativeMethods.VirtualFree( handle, Size, NativeMethods.FreeType.MEM_RELEASE); } public unsafe void* GetPointer(out IntPtr sizeOfChunk) { return GetPointer(IntPtr.Zero, out sizeOfChunk); } public unsafe void* GetPointer(IntPtr offset, out IntPtr sizeOfChunk) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsInvalid || (offset.ToInt64() &gt; Size.ToInt64())) { sizeOfChunk = IntPtr.Zero; return (void*)IntPtr.Zero; } sizeOfChunk = (IntPtr)(Size.ToInt64() - offset.ToInt64()); return (byte*)handle + offset.ToInt64(); } public unsafe void* GetPointer() { return GetPointer(IntPtr.Zero); } public unsafe void* GetPointer(IntPtr offset) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsInvalid || (offset.ToInt64() &gt; Size.ToInt64())) { return (void*)IntPtr.Zero; } return (byte*)handle + offset.ToInt64(); } public override bool IsInvalid { get { return handle == IntPtr.Zero; } } public IntPtr Size { get; private set; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HeapHandle internal sealed class HeapHandle : SafeHandle { public HeapHandle(IntPtr handle) : base(handle, true) { } [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] override protected bool ReleaseHandle() { return NativeMethods.HeapDestroy(handle); } public unsafe void* Malloc(IntPtr size) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsInvalid) { return (void*)IntPtr.Zero; } return NativeMethods.HeapAlloc( this, NativeMethods.HeapAllocFlags.Empty, size); } public unsafe bool Free(void* lpMem) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (lpMem == null) { return false; } return NativeMethods.HeapFree( this, NativeMethods.HeapFreeFlags.Empty, lpMem); } public override bool IsInvalid { get { return handle == IntPtr.Zero; } } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> class Program { static void Main() { IntPtr memoryChunkSize = (IntPtr)(1024 * 1024); IntPtr stackAllocation = (IntPtr)(1024); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Example 1 Console.WriteLine("Example 1 (VirtualAlloc, VirtualFree):"); IntPtr memoryForSafeHandle = NativeMethods.VirtualAlloc( IntPtr.Zero, memoryChunkSize, NativeMethods.AllocationType.MEM_RESERVE | NativeMethods.AllocationType.MEM_COMMIT, NativeMethods.MemoryProtection.PAGE_EXECUTE_READWRITE); using (VirtualMemoryHandle memoryHandle = new VirtualMemoryHandle(memoryForSafeHandle, memoryChunkSize)) { Console.WriteLine( (!memoryHandle.IsInvalid) ? ("Allocated") : ("Not allocated")); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!memoryHandle.IsInvalid) { bool memoryCorrect = true; unsafe { int* arrayOfInt = (int*)memoryHandle.GetPointer(); long size = memoryHandle.Size.ToInt64(); for (int index = 0; index &lt; size / sizeof(int); index++) { arrayOfInt[index] = index; } for (int index = 0; index &lt; size / sizeof(int); index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arrayOfInt[index] != index) { memoryCorrect = false; break; } } } Console.WriteLine( (memoryCorrect) ? ("Write/Read success") : ("Write/Read failed")); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Example 2 Console.WriteLine("Example 2 (HeapCreate, HeapDestroy, HeapAlloc, HeapFree):"); IntPtr heapForSafeHandle = NativeMethods.HeapCreate( NativeMethods.HeapOptions.Empty, memoryChunkSize, IntPtr.Zero); using (HeapHandle heap = new HeapHandle(heapForSafeHandle)) { Console.WriteLine( (!heap.IsInvalid) ? ("Heap created") : ("Heap is not created")); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!heap.IsInvalid) { bool memoryCorrect = true; unsafe { int* arrayOfInt = (int*)heap.Malloc(memoryChunkSize); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arrayOfInt != null) { long size = memoryChunkSize.ToInt64(); for (int index = 0; index &lt; size / sizeof(int); index++) { arrayOfInt[index] = index; } for (int index = 0; index &lt; size / sizeof(int); index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arrayOfInt[index] != index) { memoryCorrect = false; break; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!heap.Free(arrayOfInt)) { memoryCorrect = false; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { memoryCorrect = false; } } Console.WriteLine( (memoryCorrect) ? ("Allocation/Write/Read success") : ("Allocation/Write/Read failed")); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Example 3 Console.WriteLine("Example 3 (stackalloc):"); unsafe { bool memoryCorrect = true; int* arrayOfInt = stackalloc int[(int)stackAllocation.ToInt64()]; long size = stackAllocation.ToInt64(); for (int index = 0; index &lt; size / sizeof(int); index++) { arrayOfInt[index] = index; } for (int index = 0; index &lt; size / sizeof(int); index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arrayOfInt[index] != index) { memoryCorrect = false; break; } } Console.WriteLine( (memoryCorrect) ? ("Allocation/Write/Read success") : ("Allocation/Write/Read failed")); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Example 4 Console.WriteLine("Example 4 (Marshal.AllocHGlobal):"); unsafe { bool memoryCorrect = true; var globalPointer = Marshal.AllocHGlobal(memoryChunkSize); int* arrayOfInt = (int*)globalPointer; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IntPtr.Zero != globalPointer) { try { long size = memoryChunkSize.ToInt64(); for (int index = 0; index &lt; size / sizeof(int); index++) { arrayOfInt[index] = index; } for (int index = 0; index &lt; size / sizeof(int); index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arrayOfInt[index] != index) { memoryCorrect = false; break; } } } finally { Marshal.FreeHGlobal(globalPointer); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { memoryCorrect = false; } Console.WriteLine( (memoryCorrect) ? ("Allocation/Write/Read success") : ("Allocation/Write/Read failed")); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> Console.ReadKey(); } } }</span></span></code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/44208/">https://habr.com/ru/post/44208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442070/index.html">Companies have finally attended to the development of IoT devices and their security.</a></li>
<li><a href="../442072/index.html">RxJava2 + Retrofit 2. Modify the adapter to handle the absence of the Internet on Android</a></li>
<li><a href="../442074/index.html">Stylish waterfall from RiME in the game engine: make the water flow</a></li>
<li><a href="../442076/index.html">VKontakte has released an instant messenger for PC, very similar to Telegram</a></li>
<li><a href="../442078/index.html">Working with the Jira API with Python</a></li>
<li><a href="../442080/index.html">Micrometer Connection for Java Web Application</a></li>
<li><a href="../442082/index.html">How to simplify the study of Oracle database: "gentleman's set of" scripts</a></li>
<li><a href="../442084/index.html">Antiquities: a twenty year old camera on diskettes</a></li>
<li><a href="../442086/index.html">How was Love Kubernetes in Mail.ru Group on February 14</a></li>
<li><a href="../442088/index.html">SEC accused Ilona Mask of violating the ban on the publication of important data on Tesla in social networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>