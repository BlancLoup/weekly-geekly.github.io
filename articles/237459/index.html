<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to develop an API with backward compatibility. Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Sergey Konstantinov, in Yandex I lead the development of the Maps API. I recently shared my experience with backward compatibility w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to develop an API with backward compatibility. Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  Hello!  My name is Sergey Konstantinov, in Yandex I lead the development of the Maps API.  I recently shared my experience with backward compatibility with my colleagues.  My report consisted of two unequal parts.  The first, large, is devoted to how to properly develop the API, so that later it would not be excruciatingly painful.  The second is about what to do if you need to refactor something and do not break backward compatibility on the way. <br><br><video>  http://video.yandex.ru/users/ya-events/view/3161/ </video><br><br>  If you look at Wikipedia, then backward compatibility will be written there that this is the preservation of the system interface when new versions are released.  In fact, for end users, backward compatibility means that the code written for the previous version of the system works functionally in the next version as well. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a developer, backward compatibility primarily implies that the once accepted obligation to provide any functionality cannot be canceled, corrected or ceased to be supported. <br><a name="habracut"></a><br>  Why do I have to commit?  First, you save time and money for your users.  It is naive to think that it is cheaper to maintain backward compatibility.  In fact, you simply smear the cost of customer support.  One production pack can cost much more than the entire development of an entire product. <br><br>  Secondly, you support your karma.  Conscious scrapping of backward compatibility frustrates users much more than bugs.  People do not like it when they are clearly shown indifference to their problems. <br><br>  Third, backward compatibility is a competitive advantage.  It implies the ability to upgrade to newer versions without development costs, a guarantee that the service will not break production. <br><br><h2>  Backward compatibility: the right architecture </h2><br>  What can be done at the design stage so that later it would not be painfully painful?  There are three preliminary points to make.  First, backward compatibility is not free.  Building the right architecture entails overhead.  You will have to think more, enter more entities, write redundant code. <br><br>  Secondly, before embarking on development, it is necessary to designate the area of ‚Äã‚Äãresponsibility, clearly clarifying what will be supported.  Minimize situations where some publicly available API is not described in the documentation.  Never give read (and, especially, write) entities whose format is not described. <br><br>  Third, it is assumed that your API is designed correctly and structured by abstraction levels. <br><br>  Suppose we understood and understood all this.  It's time to move on to the rules that we learned from our nearly five-year experience. <br><br><h3>  Rule number 1: more interfaces </h3><br>  In the limit in your public documentation there should not be a single signature that accepts specific types, not interfaces.  An exception can be made for base global classes and explicitly subordinate components. <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">interface</span></span> IGeoObject : IChildOnMap, ICustomizable, IDomEventEmitter, IParentOnMap { <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> IEventManager events; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> IGeometry geometry; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> IOptionManager options; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> IDataManager properties; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> IDataManager state; } <span class="hljs-attribute"><span class="hljs-attribute">Map</span></span> getMap(); <span class="hljs-attribute"><span class="hljs-attribute">IOverlay</span></span> getOverlay(); <span class="hljs-attribute"><span class="hljs-attribute">IParentOnMap</span></span> getParent(); <span class="hljs-attribute"><span class="hljs-attribute">IGeoObject</span></span> setParent(IParentOnMap parent)</code> </pre> <br>  Why does this help avoid the loss of backward compatibility?  If an interface is declared in the signature, you will have no problems when you have a second (third, fourth) interface implementation.  Atomized responsibility of objects.  The interface does not impose conditions on what the transmitted object should be: it can be either a descendant of a standard object or an independent implementation. <br><br>  Why is this useful when designing an API?  The allocation of interfaces is first necessary for the developer to restore order in his head.  If your method accepts an object with 20 fields and 30 methods as a parameter, it is highly recommended to think about what exactly is needed from these fields and methods. <br><br>  As a result of this rule, you should get a lot of fractional interfaces at the output.  Your signatures should not require more than 5 ¬± 2 properties or methods from the input parameter.  You will get an idea of ‚Äã‚Äãwhich properties of your objects are important in the context of the overall system architecture, and which are not.  As a result, interface redundancy will decrease. <br><br><h3>  Rule number 2: hierarchy </h3><br>  Your objects should be arranged in a hierarchy: who interacts with whom.  When the interfaces that you present to your objects overlap this hierarchy, you will get a certain hierarchy of interfaces.  Now the most important thing: the object has the right to know only about the objects of the next levels. <br><br>  Why does this help avoid the loss of backward compatibility?  The overall connectedness of the architecture is reduced, fewer connections - fewer side effects.  And if you change an object, you can only touch its neighbors in the tree. <br><br>  To achieve this in obvious ways is not always possible.  The necessary methods and properties need to be forwarded along the chain through intermediate links (taking into account the level of abstraction, of course!).  Thus, you automatically get a set of extension points, which can then come in handy. <br><br><h3>  Rule number 3: contexts </h3><br>  Consider any intermediate level hierarchy as an informational context for the underlying stage. <br><br>  Example: <br>  <code>Map</code> = map context (observed area of ‚Äã‚Äãthe map + scale). <br>  <code>IPane</code> = positioning context in client coordinates. <br>  <code>ITileContainer</code> = positioning context in tile coordinates. <br><br><img src="https://habrastorage.org/files/b20/68e/3e3/b2068e3e3fe9473699b35cb66713286c.png"><br><br>  Your object tree can be viewed as a hierarchy of contexts.  Each level of the hierarchy must correspond to some level of abstraction. <br><br>  Why does this help avoid the loss of backward compatibility?  A properly constructed context tree will almost never change when refactoring: information flows may appear, but they are very unlikely to disappear.  The context rule allows you to effectively isolate hierarchy levels from each other. <br><br>  This is useful when designing an API, as it is much easier to keep in mind the information scheme of a project than a full tree.  A description of objects in terms of the contexts they provide allows you to correctly distinguish levels of abstraction. <br><br><h3>  Rule number 4: consistency </h3><br>  In this case, I use the term consistency in the ACID paradigm for databases.  This means that between transactions the state of the objects must always be valid.  Any object must provide a complete description of its state at any time and a complete set of events that allows you to track all changes to your state. <br><br>  Similar patterns violate consistency: <br><br><pre> <code class="hljs pgsql">obj.name = <span class="hljs-string"><span class="hljs-string">'-'</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something obj.setOptions(<span class="hljs-string"><span class="hljs-string">'-'</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something obj.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>();</code> </pre><br>  <em>In particular, the rule follows from this: avoid the update, build, apply methods.</em> <br><br>  This helps to avoid loss of backward compatibility, since  The external observer can always completely restore the state and history of the object through its public interface.  In addition, such an object can always be replaced or cloned, without having knowledge of its internal structure. <br><br>  When you have organized such an interaction, that there is a state of the object and an event of its change, the range of methods and events of your objects becomes less diverse and more consistent.  It will become easier for you to allocate interfaces and keep it all in your head. <br><br><h3>  Rule number 5: events </h3><br>  Organize interaction between objects using events, and in both directions. <br><br>  Consider two examples of how you can organize the interaction between the button and the layout: <br><br><pre> <code class="hljs lua">button.onStateChange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { layout.setCaption(state.caption); } layout.onClick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { button.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(); }</code> </pre><br>  vs <br><br><pre> <code class="hljs actionscript">button.onStateChange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fire(<span class="hljs-string"><span class="hljs-string">'statechange'</span></span>); } layout.onClick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fire(<span class="hljs-string"><span class="hljs-string">'click'</span></span>) }</code> </pre><br>  The second interaction scheme is obtained natively if the consistency requirement is met: <br><br><ul><li>  each of the objects knows when the state of the other object has changed; </li><li>  Each of the objects can completely figure out the state of the other. </li></ul><br><br>  In the first case, the button and the layout know the details about each other's internal structure, in the second - no. <br><br>  This helps to avoid loss of backward compatibility, since  events are not necessary for execution for both objects: you can easily maintain such implementations of both objects that react only to a part of events and display only a part of the state of the second object.  If you have a third object that needs to respond to the same action - you will not have problems. <br><br>  If you correctly completed the previous four steps, you get a standard pattern: you have, state, events about its change, the underlying object that listens to this event and reacts to it in some way.  Your organization of interaction between objects is significantly unified.  The interaction between objects is thus based on common methods and events, rather than private ones, i.e.  will contain much less specific objects <br><br><h3>  Rule # 6: Delegation </h3><br>  The sixth rule logically follows from the first five.  You have built the whole system, you have interfaces and events, levels of abstraction.  Now you need as far as possible to transfer all the logic to the lower level of abstraction.  Since the implementation and functionality of the lower level of abstraction (layout, interaction protocols, etc) most often changes, the interface to the lower level of abstraction should be as general as possible. <br><br>  With this approach, connections between objects become as abstract as possible.  You can safely rewrite the objects of the lower level of abstraction as a whole if necessary. <br><br><h3>  Rule number 7: tests </h3><br>  Write tests on the interface. <br><br><h3>  Rule number 8: external sources </h3><br>  In the absolute majority of cases, the biggest problems with maintaining backward compatibility arise from the non-preservation of backward compatibility by other services.  If you do not control the adjacent service (data source), bring the versioned wrapper to it on your side. <br><br><h2>  Backward compatibility: refactoring </h2><br><h3>  Before embarking </h3><br>  Clarify the situation: <br><br><ul><li>  If the declared functionality has never worked, you are free to make any decision: to repair, change, throw out; </li><li>  If something looks like a bug, this is not a reason to rush to repair it; </li><li>  Check the tests on the interface of the object you are going to refactor and the related objects; </li><li>  If there are no tests, write them; </li><li>  Never begin any refactoring without tests; </li><li>  Testing should include checking the compliance of the behavior of the old and the new version of the API; </li></ul><br><br>  One and a half methods of refactoring: <br><br><ul><li>  If you did everything correctly and the interaction of objects is done according to the ‚Äústate-state change event‚Äù scheme, then often you will be able to rewrite the implementation, leaving the old fields and methods for backward compatibility; </li><li>  Use optional fields, methods and fallbacks in interfaces - correctly selected defaults will allow you to increase functionality. </li></ul><br><br><h3>  From release to release </h3><br>  Get yourself a notebook of peace of mind: <br><br><ul><li>  If you incorrectly named the entity - it will be incorrectly called until the next major release. </li><li>  If you made an architectural error, it will exist until the next major release. </li><li>  Write yourself a problem in a notebook and try not to think about it until the next major release. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/237459/">https://habr.com/ru/post/237459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237441/index.html">History: QuakeLive native Linux downloader</a></li>
<li><a href="../237443/index.html">The keyboard of the new generation - "10th"</a></li>
<li><a href="../237445/index.html">Appeared RTM release (for manufacturers) Ubuntu for smartphones</a></li>
<li><a href="../237447/index.html">V2V, V2I, technology and the possible future of road transport</a></li>
<li><a href="../237455/index.html">You cannot upload files to the server in mobile Safari 8.0</a></li>
<li><a href="../237461/index.html">Social games. Start and Promotion</a></li>
<li><a href="../237465/index.html">RailsClub 2014: Interview With Kirill Gorin</a></li>
<li><a href="../237467/index.html">Smartphones Sony Xperia Z3 and Z3 Compact went on sale</a></li>
<li><a href="../237469/index.html">I was asked to hack the program at the interview</a></li>
<li><a href="../237471/index.html">How to tame the processor core *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>