<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What every programmer should know about compiler optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="High-level programming languages ‚Äã‚Äãcontain many abstract programmer constructs, such as functions, conditional operators, and cycles ‚Äî they make us am...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What every programmer should know about compiler optimization</h1><div class="post__text post__text-html js-mediator-article">  High-level programming languages ‚Äã‚Äãcontain many abstract programmer constructs, such as functions, conditional operators, and cycles ‚Äî they make us amazingly productive.  However, one of the drawbacks of writing code in a high-level language is the potential significant reduction in the speed of the program.  Therefore, the compilers are trying to automatically optimize the code and increase the speed of work.  Nowadays, optimization logic has become very complex: compilers convert loops, conditional expressions, and recursive functions;  remove whole blocks of code.  They optimize the code for the processor architecture to make it really fast and compact.  And it‚Äôs very cool, because it‚Äôs better to focus on writing a readable code than to do manual optimizations that are difficult to understand and maintain.  In addition, manual optimizations may prevent the compiler from performing additional and more efficient automatic optimizations.  Instead of writing optimization with your hands, it would be better to focus on the design of the architecture and on efficient algorithms, including parallelism and the use of library features. <br><br>  This article focuses on the Visual C ++ compiler optimizations.  I'm going to discuss the most important optimization techniques and solutions that the compiler has to apply in order to apply them correctly.  My goal is not to tell you how to manually optimize the code, but to show why you should trust the compiler to optimize your code yourself. <a name="habracut"></a>  This article is by no means a description of the full set of optimizations that the Visual C ++ compiler does; it will show only the really important ones that you‚Äôll need to know about.  There are other important optimizations that the compiler is not able to perform.  For example, replacing an inefficient algorithm with an effective one or changing the alignment of the data structure.  We will not discuss such optimizations in this article. <br><br><h3>  Definition of compiler optimizations </h3>  Optimization is the process of converting a code fragment into another fragment that is functionally equivalent to the original, in order to improve one or several of its characteristics, of which the speed and size of the code are the most important.  Other characteristics include the amount of energy consumed for code execution and compile time (as well as JIT compile time if the resulting code uses JIT). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Compilers are constantly being improved, the approaches they use are improved.  Despite the fact that they are not perfect, often the most correct approach is to leave low-level optimizations to the compiler, rather than trying to do them manually. <br><br>  There are four ways to help the compiler optimize more efficiently: <ol><li>  Write readable code that is easy to maintain.  Do not think of various Visual C ++ OOP features as the worst enemy of performance.  The latest version of Visual C ++ will be able to reduce the overhead from OOP to a minimum, and sometimes even completely get rid of them. </li><li>  Use compiler directives.  For example, tell the compiler to use a function calling convention that is faster than the default. </li><li>  Use built-in compiler functions.  These are special functions, the implementation of which is provided by the compiler automatically.  Remember that the compiler has a deep knowledge of how to efficiently arrange a sequence of machine instructions so that the code runs as fast as possible on the specified software architecture.  Currently, the Microsoft .NET Framework does not support built-in functions, so managed languages ‚Äã‚Äãcannot use them.  However, Visual C ++ has extensive support for such functions.  However, you should not forget that, although their use will improve the performance of the code, it will also have a negative impact on readability and portability. </li><li>  Use profile-guided optimization (PGO).  Thanks to this technology, the compiler knows more about how the code will behave during operation and optimizes it accordingly. </li></ol><br><br>  The purpose of this article is to show you why you can trust the compiler to perform optimizations that apply to inefficient, but readable code (the first method).  I will also make a brief overview of profile-guided optimizations and mention some compiler directives that will allow you to improve part of your source code. <br><br>  There are many compiler optimization techniques, ranging from simple transformations, such as constants to convolutions, to complex ones, such as instruction scheduling.  In this article, we will limit ourselves to the most important optimizations that can significantly improve the performance of your code (by two-digit percent) and reduce its size by substitution of functions (function inlining), COMDAT optimizations and loop optimizations.  I will discuss the first two approaches in the next section, and then show you how you can control the execution of optimizations in Visual C ++.  In conclusion, I will briefly talk about the optimizations that are used in the .NET Framework.  Throughout the article, I will use Visual Studio 2013 for all examples. <br><br><h3>  Link-Time Code Generation </h3> Code generation at the linking stage (Link-Time Code Generation, LTCG) is a technique for performing whole program optimizations (WPO) on C / C ++ code.  The C / C ++ compiler processes each source code file separately and produces the corresponding object file.  In other words, the compiler can optimize only a single file, instead of optimizing the entire program.  However, some important optimizations may be applicable only to the entire program.  You can use these optimizations only during linking, and not at compile time, since the linker has a complete understanding of the program. <br><br>  If LTCG is enabled (the <code>/GL</code> flag), then the compiler driver ( <code>cl.exe</code> ) will only call the front end ( <code>c1.dll</code> or <code>c1xx.dll</code> ) and will postpone the work of the back end ( <code>c2.dll</code> ) until linking.  The resulting object files contain C Intermediate Language (CIL), not machine code.  Then the linker is called ( <code>link.exe</code> ).  He sees that the object files contain CIL code, and calls the back end, which, in turn, runs WPO and generates binary object files so that the linker can put them together and form the executable file. <br><br>  The front end also performs some optimizations (for example, a convolution of constants), regardless of whether optimizations are turned on or off.  However, all important optimizations are performed by the back end, and they can be controlled using compilation keys. <br><br>  LTCG allows back end to perform many optimizations aggressively (using the <code>/GL</code> compiler keys with <code>/O1</code> or <code>/O2</code> and <code>/Gw</code> , as well as using the <code>/OPT:REF</code> and <code>/OPT:ICF</code> link keys).  In this article I will discuss only inlining and COMDAT optimization.  A complete list of LTCG optimizations is provided in the documentation.  It is useful to know that the linker can perform LTCG on native, native-managed and purely managed object files, as well as on safe-managed (safe managed) object files and safe.netmodules. <br><br>  I will work with the program from two source code files ( <code>source1.c</code> and <code>source2.c</code> ) and a header file ( <code>source2.h</code> ).  The <code>source1.c</code> and <code>source2.c</code> are shown in the listing below, and the header file containing the prototypes of all <code>source2.c</code> functions is so simple that I will not give it. <br><br><pre> <code class="hljs pgsql">// source1.c #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdio.h&gt; // scanf_s <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> printf. #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Source2.h" <span class="hljs-type"><span class="hljs-type">int</span></span> square(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x; } main() { <span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">5</span></span>, m; scanf_s("%d", &amp;m); printf("The square of %d is %d.", n, square(n)); printf("The square of %d is %d.", m, square(m)); printf("The cube of %d is %d.", n, <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>(n)); printf("The sum of %d is %d.", n, sum(n)); printf("The sum of cubes of %d is %d.", n, sumOfCubes(n)); printf("The %dth prime number is %d.", n, getPrime(n)); }</code> </pre><br><pre> <code class="hljs pgsql">// source2.c #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; // sqrt. #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdbool.h&gt; // <span class="hljs-type"><span class="hljs-type">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>. #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Source2.h" <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x*x; } <span class="hljs-type"><span class="hljs-type">int</span></span> sum(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-type"><span class="hljs-type">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= x; ++i) result += i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-type"><span class="hljs-type">int</span></span> sumOfCubes(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-type"><span class="hljs-type">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= x; ++i) result += <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } static <span class="hljs-type"><span class="hljs-type">bool</span></span> isPrime(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= (<span class="hljs-type"><span class="hljs-type">int</span></span>)sqrt(x); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x % i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> getPrime(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-type"><span class="hljs-type">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> candidate = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count != x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPrime(candidate)) ++count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre><br>  The file <code>source1.c</code> contains two functions: the function <code>square</code> , which calculates the square of an integer, and the main function of the program <code>main</code> .  The main function calls the square function and all functions from <code>source2.c</code> with the exception of the <code>isPrime</code> .  The file <code>source2.c</code> contains 5 functions: <code>cube</code> to raise an integer to a third power, <code>sum</code> to count the sum of integers from 1 to a given number, <code>sumOfCubes</code> to count the sum of cubes of integers from 1 to a given number, <code>isPrime</code> to check the number for simplicity, <code>getPrime</code> to get a prime number with a given number.  I missed error handling, since it is of no interest in this article. <br><br>  The code is very simple, but useful.  We have several functions that do simple calculations, some of which contain loops.  The <code>getPrime</code> function is the most complex, <code>getPrime</code> it contains a <code>while</code> , inside of which it calls the <code>isPrime</code> function, which also contains a loop.  I will use this code to demonstrate one of the important optimizations of the function inlining compiler and several additional optimizations. <br><br>  Consider the result of the compiler under three different configurations.  If you deal with the example yourself, you will need an assembler output file (obtained using the <code>/FA[s]</code> compiler key) and a map file (obtained using the linker <code>/MAP</code> key) to study the COMDAT optimization performed (the linker will report them , if you turn on the <code>/verbose:icf</code> and <code>/verbose:ref</code> ) keys.  Make sure all keys are correct and continue reading the article.  I will use the C ( <code>/TC</code> ) compiler to make the generated code easier to learn, but everything described in the article also applies to C ++ code. <br><br><h3>  Debug Configuration </h3>  The Debug configuration is used mainly because all back end optimizations are turned off if you specify the <code>/Od</code> key without the <code>/GL</code> key.  In this configuration, the resulting object files contain a binary code that exactly matches the source code.  You can examine the assembler output files and the map file to verify this.  A configuration is equivalent to a Debug configuration in Visual Studio. <br><br><h3>  Compile-Time Code Generation Release Configuration </h3>  This configuration is similar to the Release configuration (in which the <code>/O1</code> , <code>/O2</code> or <code>/Ox</code> switches are specified), but it does not include the <code>/GL</code> switch.  In this configuration, the final object files contain an optimized binary code, but at the same time the optimization of the entire program level is not performed. <br><br>  If you look at the generated assembly listing file for <code>source1.c</code> , you will notice that two important optimizations have been performed.  The first call to the <code>square</code> function, <code>square(n)</code> , was replaced by the value computed at compile time.  How did this happen?  The compiler noticed that the function body is not enough, and decided to substitute its contents instead of the call.  Then the compiler noticed that in the calculation of the value there is a local variable <code>n</code> with a known initial value, which did not change between the initial assignment and the function call.  Thus, he came to the conclusion that it is safe to calculate the value of the multiplication operation and substitute the result ( <code>25</code> ).  The second call to the <code>square</code> function, <code>square(m)</code> , was also inline, i.e., the function body was substituted for the call.  But the value of the variable m is unknown at the time of compilation, so the compiler was unable to calculate in advance the value of the expression. <br><br>  Now turn to <code>source2.c</code> 's assembly listing file, which is much more interesting.  The call to the <code>cube</code> function in the <code>sumOfCubes</code> function was inline.  This, in turn, allowed the compiler to perform loop optimization (for more details, see the ‚ÄúCycle Optimization‚Äù section).  In the <code>isPrime</code> function, SSE2 instructions were used to convert <code>int</code> to <code>double</code> when calling <code>sqrt</code> and converting from <code>double</code> to <code>int</code> when getting a result from <code>sqrt</code> .  In fact, <code>sqrt</code> volunteered once before the start of the cycle.  Note that the <code>/arch</code> switch tells the compiler that x86 uses SSE2 by default (most x86 processors and x86-64 processors support SSE2). <br><br><h3>  Link-Time Code Generation Release Configuration </h3>  This configuration is identical to the Release configuration in Visiual Studio: the optimizations are enabled and the <code>/GL</code> compiler key is specified (you can also explicitly specify <code>/O1</code> or <code>/O2</code> ).  Thus, we tell the compiler to generate object files with CIL code instead of assembly object files.  This means that the linker will call the back end of the compiler to run WPO, as described above.  Now we will discuss a few WPOs to show the great benefits of LTCG.  Generated assembly code listings for this configuration are available online. <br><br>  While the inline function is enabled (the <code>/Ob</code> key, which is turned on, if you have turned off optimization), the <code>/GL</code> key allows the compiler to inline functions defined in other files regardless of the <code>/Gy</code> key (we will discuss it a little later).  The linker <code>/LTCG</code> optional and only affects the linker. <br><br>  If you look at the assembly listing file for <code>source1.c</code> , you may notice that calls to all functions except <code>scanf_s</code> were inline.  As a result, the compiler was able to calculate the functions <code>cube</code> , <code>sum</code> and <code>sumOfCubes</code> .  Only the <code>isPrime</code> function <code>isPrime</code> not inline.  However, if you manually inlined it in <code>getPrime</code> , then the compiler would still execute inline <code>getPrime</code> in <code>main</code> . <br><br>  As you can see, inlining functions is important not only because the function call is optimized, but also because it allows the compiler to perform many additional optimizations.  Inline usually increases performance by increasing code size.  Excessive use of this optimization leads to the phenomenon called code bloat.  Therefore, each time a function is called, the compiler calculates the costs and benefits, and then decides whether to inline the function. <br><br>  Because of the importance of inlining, the Visual C ++ compiler provides great opportunities for its support.  You can tell the compiler to never inline a set of functions using the <code>auto_inline</code> directive.  You can also tell the compiler specific functions or methods using <code>__declspec(noinline)</code> .  You can also mark a function with the <code>inline</code> and advise the compiler to execute the inline (although the compiler may decide to ignore this advice if it considers it bad).  The <code>inline</code> has been available since the first C ++ version, it appeared in C99.  You can use the <code>__inline</code> compiler <code>__inline</code> keyword for both C and C ++: this is convenient if you want to use older versions of C that do not support this keyword.  The <code>__forceinline</code> (for C and C ++) causes the compiler to always inline a function, if possible.  Last but not least, you can tell the compiler to expand the recursive function of the specified or indefinite depth by inlining using the <code>inline_recursion</code> directive.  Note that at present the compiler does not have the ability to control inline in the place of the function call, and not in the place of its declaration. <br><br>  The <code>/Ob0</code> disables inlining completely, which is useful during debugging (this switch works in the Debug configuration in Visual Studio).  The <code>/Ob1</code> tells the compiler that only functions marked with <code>inline</code> , <code>__inline</code> , <code>__forceinline</code> should be considered as candidates for <code>__forceinline</code> .  The <code>/Ob2</code> only works when the specified <code>/O[1|2|x]</code> and tells the compiler to consider all functions for inlining.  In my opinion, the only reason for using the <code>inline</code> and <code>__inline</code> is to control inlining for the <code>/Ob1</code> . <br><br>  The compiler may not always zainlaynit function.  For example, during a virtual call to a virtual function: the function cannot be inline, because the compiler does not know exactly which function will be called.  Another example: a function is called via a pointer to a function instead of a call through its name.  You should try to avoid such situations so that inlineing is possible.  A complete list of all such conditions can be found in MSDN. <br><br>  Inline functions are not the only optimization that can be applied at the program level as a whole.  Most optimizations work most effectively at this level.  In the rest of this article, I will discuss a specific class of optimizations called COMDAT optimizations. <br><br>  By default, during module compilation, all code is stored in a single section of the resulting object file.  The linker works at the section level: it can delete sections, merge them, or reorder.  This prevents him from performing three very important optimizations (a two-digit percentage) that help reduce the size of the executable file and increase its performance.  The first removes unused functions and global variables.  The second one collapses identical functions and global constants.  The third reorders the functions and global variables so that, during execution, the transitions between the physical memory fragments are shorter. <br><br>  To enable these linker optimizations, you must ask the compiler to package functions and variables into separate sections using the compiler keys <code>/Gy</code> (function level linking) and <code>/Gw</code> (global data optimization).  These sections are called COMDATs.  You can also mark a given global variable using <code>__declspec( selectany)</code> to tell the compiler to package the variable in COMDAT.  Further, using the linker <code>/OPT:REF</code> key, you can get rid of unused functions and global variables.  Key <code>/OPT:ICF</code> helps to minimize identical functions and global constants (ICF is Identical COMDAT Folding).  The <code>/ORDER</code> switch will force the linker to place COMDATs in the final images in a specific order.  Note that all linker optimizations do not need the <code>/GL</code> .  The <code>/OPT:REF</code> and <code>/OPT:ICF</code> switches must be turned off during debugging for obvious reasons. <br><br>  You should use LTCG whenever possible.  The only reason for abandoning LTCG is that you want to distribute the resulting object files and library files.  Recall that they contain CIL-code instead of machine.  CIL-code can only be used by the compiler and linker of the same version with which they were generated, which is a significant limitation, because developers will have to use the same version of the compiler to use your files.  In this case, if you do not want to distribute a separate version of the object files for each version of the compiler, then you should use code generation instead.  In addition to the version limit, the object files are many times larger than the corresponding assembler object files.  However, do not forget about the huge advantage of object files with CIL-code, which is the ability to use WPO. <br><br><h3>  Cycle optimization </h3>  The Visual C ++ compiler supports several types of loop optimizations, but we will discuss only three: loop unrolling, automatic vectorization, and loop-invariant code motion.  If you modify the code from <code>source1.c</code> so that <code>sumOfCubes</code> is passed to <code>sumOfCubes</code> instead of n, then the compiler will not be able to calculate the value of the parameters, you have to compile the function so that it can work for any argument.  The final function will be well optimized, which is why it will have a large size, which means the compiler will not inline it. <br><br>  If you code with the <code>/O1</code> key, no optimizations to <code>sumOfCubes</code> will be applied.  Compiling with the <code>/O2</code> key will give speed optimizations.  At the same time, the code size will increase significantly, <code>sumOfCubes</code> loop inside the <code>sumOfCubes</code> function will be unwound and vectorized.  It is very important to understand that vectorization will not be possible without inlineing the cube function.  Moreover, unwinding the cycle will also not be as effective without inlineing.  A simplified graphical representation of the resulting code is shown in the following picture (this graph is valid for both x86 and x86-64). <br><br><img src="http://habrastorage.org/files/f9d/1e9/018/f9d1e90184004050a73b1f90bd1130cc.png"><br><br>  In this diagram, the green rhombus shows the entry point, and the red rectangles show the exit points.  Blue diamonds represent the conditional operators that will be executed when the <code>sumOfCubes</code> function is <code>sumOfCubes</code> .  If SSE4 is supported and x is greater than or equal to 8, then SSE4 instructions will be used to perform 4 multiplications at a time.  The process of performing the same operation for several variables is called vectorization.  Also the compiler unwinds this cycle twice.  This means that the body of the loop will be repeated twice for each iteration.  As a result, the execution of eight multiplication operations will occur in 1 iteration.  If <code>x</code> less than 8, then the code without optimizations will be used to perform the function.  Note that the compiler inserts three exit points instead of one - thus reducing the number of transitions. <br><br>  The unwinding of cycles is performed by repeating the cycle body several times within one iteration of a new (unwound) cycle.  This improves performance, because the operations of the cycle itself will be performed less frequently.  In addition, this allows the compiler to perform additional optimizations (for example, vectorization).  The disadvantage of unwinding cycles is an increase in the amount of code and the load on the registers.  But despite this, depending on the body of the cycle, such optimization can increase productivity by a two-digit percentage. <br><br>  Unlike x86 processors, all x86-64 processors support SSE2.  Moreover, you can take advantage of AVX / AVX2 instructions on the latest x86-64 processors from Intel and AMD with the <code>/arch</code> switch.  Specifying <code>/arch:AVX2</code> , you tell the compiler to also use the FMA and BMI instructions. <br><br>  Currently, the Visual C ++ compiler does not allow controlling the unwinding of loops.  But you can influence it with <code>__forceinline</code> and <code>loop</code> directives with the <code>no_vector</code> option (the latter turns off the <code>no_vector</code> specified cycles). <br><br>  If you look at the generated assembler code, you may notice that additional optimizations can be applied to it.  But the compiler has already done an excellent job anyway and there is no need to spend much more time on analysis in order to apply minor optimizations. <br><br>  The <code>someOfCubes</code> function <code>someOfCubes</code> not the only one whose loop has been unwound.  If you modify the code and pass <code>m</code> to the <code>sum</code> function instead of <code>n</code> , then the compiler will not be able to calculate its value and it will have to generate the code, the loop will be unwound twice. <br><br>  In conclusion, we will look at such optimization as the removal of loop invariants.  Take a look at the following code: <br><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= x; ++i) { ++<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>; result += i; } printf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  The only change we have made is to add an additional variable, which is incremented at each iteration, and finally displayed on the console.  It is easy to see that this code is easily optimized by moving the incremental variable out of the frame: just assign it to <code>x</code> .  This optimization is called the removal of the loop invariant (loop-invariant code motion).  The word "invariant" shows that this technique is applicable when a part of the code does not depend on expressions that include a loop variable. <br><br>   :      ,          .     ? ,   <code>x</code>  .       ,      <code>count</code>  .        x  count,     !  ,  <code>x</code> ,   <code>count</code>   .  ,     .  ,  Visual C++  ,          ,       <code>x</code> . <br><br>    ,           ,        ,     ,     .          . <br><br><h3>   </h3>     <code>O1</code> , <code>/O2</code> , <code>/Ox</code> ,         <code>optimize</code> : <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optimize( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"[optimization-list]"</span></span></span><span class="hljs-meta">, {on | off} )</span></span></code> </pre><br>    optimization list   ,         : <code>g</code> , <code>s</code> , <code>t</code> , <code>y</code> .    <code>/Og</code> , <code>/Os</code> , <code>/Ot</code> , <code>/Oy</code> . <br><br>   c  <code>off</code>        .     <code>on</code>    . <br><br>  <code>/Og</code>    ,        ,    ,   .  <code>LTCG</code> ,  <code>/Og</code>   WPO. <br><br>  <code>optimize</code>    ,   ,       :    ,    . ,         ,      profile-guided- (PGO),        ,    ,       .     ,        . Visual Studio   ,       ,     . <br><br><h3>   .NET </h3>  .NET  ,       .       (C# compiler)  JIT-.       . ,           .        JIT-. JIT-   .NET 4.5   SIMD.   JIT-   .NET 4.5.1 (  RyuJIT)  SIMD. <br><br>      RyuJIT  Visual C++     ?  ,  RyuJIT    ,     ,   Visual C++  . ,       ,          <code>true</code>     ,     .  RyuJIT          . ,    SSE4.1,  JIT-    SSE4.1    <code>subOfCubes</code> ,       .   ,  RyuJIT       , . .  JIT-    .    Visual C++       ,         .      Microsoft   .NET Native             Visual C++.          Windows Store. <br><br>         .  C#  Visual Basic          <code>/optimize</code> .   JIT-     <code>System.Runtime.CompilerServices.MethodImpl</code>       <code>MethodImplOptions</code> .  <code>NoOptimization</code>  ,  <code>NoInlining</code>   ,   <code>AggressiveInlining</code> (  .NET 4.5)  JIT- ,      . <br><br><h3>  Total </h3>   ,     ,         .      Visual C++.      ,   ,         .            ,   Visual C++.     ,      . Visual C++  ,  .         2. </div><p>Source: <a href="https://habr.com/ru/post/250199/">https://habr.com/ru/post/250199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250189/index.html">How Evernote Finds Text in Images</a></li>
<li><a href="../250191/index.html">Binary operations on ordered sets</a></li>
<li><a href="../250193/index.html">Flames in CSS</a></li>
<li><a href="../250195/index.html">Ubuntu 14.04 + Asterisk 11 + CDR-Stats</a></li>
<li><a href="../250197/index.html">How to be ready or DR on Nutanix: asynchronous replication</a></li>
<li><a href="../250201/index.html">Load balancing: basic algorithms and methods</a></li>
<li><a href="../250203/index.html">What Mono 4.0.0 prepares for us</a></li>
<li><a href="../250205/index.html">From React to Riot 2.0</a></li>
<li><a href="../250207/index.html">Technologies that improve the resiliency of VPS</a></li>
<li><a href="../250209/index.html">PVS-Studio for Microsoft Visual Studio Community 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>