<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to generate random bracket sequences</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 When testing algorithms, I often have a problem to generate a random binary tree. Moreover, Wishlist is not reduced to any random tree, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to generate random bracket sequences</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  When testing algorithms, I often have a problem to generate a random binary tree.  Moreover, Wishlist is not reduced to any random tree, but taken from a uniform distribution.  Despite the seeming simplicity, to effectively build such a tree is not at all trivial. <br><br>  The title of this article contains the words "bracket sequence".  There is something more behind these words, because with the help of brackets one can describe very diverse objects, including binary trees.  On Habr√© a <a href="http://habrahabr.ru/post/165295/">separate post</a> was devoted to this fact. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I will discuss several ways to generate a random bracket sequence, including in linear time, and then give an example of converting a sequence into a binary tree.  Interesting? <br><br><a name="habracut"></a><br><h3>  Task </h3><br>  <i>Given a given <i>n,</i> generate the correct bracket sequence according to a uniform distribution over all correct sequences of length 2 <i>n</i> .</i> <br><br><h3>  Inventory </h3><br>  It is known that the number of regular bracket sequences of length 2 <i>n</i> is equal to the <i>nth</i> Catalan number <img src="https://habrastorage.org/getpro/habr/post_images/68f/fdf/98e/68ffdf98e9827659970bf57157f8c816.gif">  .  To calculate the numbers Catalan exist explicit <br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/9a9/38d/8dc9a938daaa70626a23bf88ece54700.gif"><br>  and recursive <br><img src="https://habrastorage.org/getpro/habr/post_images/204/d00/e70/204d00e701e85737c60ddfd93e4bee44.gif"><br>  formulas. <br><br>  We need a random number generator.  For a given <i>n</i> , it will generate an equally probable random number from 0 to <img src="https://habrastorage.org/getpro/habr/post_images/808/83b/9d1/80883b9d1b56bfbef5dc4c897431ee8d.gif">  .  We also need a random permutation generator above lists.  In python, it is called random.shuffle.  It will be enough for us that it works in linear time and on the sequence 1,2, ..., <i>n</i> generates a random permutation according to a uniform distribution. <br><br><h3>  Three ways to say "Avos" </h3><br><h4>  Dynamic programming forces </h4><br>  There is such an idea that all correct bracket sequences can be numbered.  And, for example, <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">there</a> is a detailed description of how to do this.  So, you can implement such a plan. <br><ul><li>  We consider the n-th number of Catalan. </li><li>  We generate a random number from 1 to <img src="https://habrastorage.org/getpro/habr/post_images/68f/fdf/98e/68ffdf98e9827659970bf57157f8c816.gif">  . </li><li>  By the forces of dynamic programming and combinatorial counting, we restore the bracket sequence by its number. </li></ul><br>  The plan is almost perfect.  Those.  the plan is quite good, if <i>n</i> is small, less than 30. But if n turns out to be about 1,000, you need long arithmetic, the algorithms by reference instead of the promised square will work cubic time, and in general, dynamic programming is not good for you.  I think we will have to sweat a lot to meet this plan, at least in <img src="https://habrastorage.org/getpro/habr/post_images/278/fc6/c8d/278fc6c8dccf1314830570eb00f3bce4.gif">  .  Let's look for alternative ways. <br><br><h4>  Try and check </h4><br>  Take another look at the explicit formula for the Catalan numbers. <br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/9a9/38d/8dc9a938daaa70626a23bf88ece54700.gif">  . <br>  In fact, it means that there are a lot of correct bracket sequences. <br><br>  We will call a sequence <i>balanced</i> if the number of opening and closing brackets in it is the same.  For example, the sequences <code>")(()"</code> , <code>"()()"</code> are balanced, and the sequence <code>"()))"</code> is not.  Obviously, any correct sequence is balanced.  Total of all possible balanced sequences of length <i>2n</i> exists <img src="https://habrastorage.org/getpro/habr/post_images/ac7/0bf/f05/ac70bff05dbe64654f2cf7868287afb9.gif" title="\ binom {2n} {n}">  .  If you randomly select one of these sequences, then it will be correct with probability <img src="https://habrastorage.org/getpro/habr/post_images/eae/892/531/eae8925311b1bec2d5eef2992633d89c.gif"><br><br>  New plan. <br><ol><li>  We generate a random balanced bracket sequence according to a uniform distribution. </li><li>  We check it for correctness. </li><li>  If the sequence is correct, then output.  If not, then go back to step 1. </li></ol><br>  Let's start with the first paragraph: how to generate such a random bracket sequence.  Let's take an arbitrary balanced sequence and shuffle it through random.shuffle. <br><pre> <code class="python hljs"> seq = [<span class="hljs-string"><span class="hljs-string">'('</span></span>, <span class="hljs-string"><span class="hljs-string">')'</span></span>] * n random.shuffle(seq)</code> </pre><br>  If you sit with a piece of paper and a pen, you can understand that for any balanced bracket sequence <i>x</i> exists exactly <img src="https://habrastorage.org/getpro/habr/post_images/552/5e1/3ef/5525e13ef5c5e4122d7d96cbdf745b4f.gif">  permutations that translate an arbitrary initial balanced sequence to <i>x</i> .  This means that random.shuffle generates any balanced sequence with equal probability.  We get the algorithm. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryAndCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> seq = [<span class="hljs-string"><span class="hljs-string">')'</span></span>, <span class="hljs-string"><span class="hljs-string">'('</span></span>] * n <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> correct(seq)): random.shuffle(seq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq</code> </pre><br>  It remains to estimate the time of work.  The correct and random.shuffle procedures work per line.  How many iterations will be the main loop?  We know that the correct bracket sequence is generated with probability <img src="https://habrastorage.org/getpro/habr/post_images/98f/d7b/139/98fd7b139e864325bf737711b225a2c3.gif">  .  Then we can say that we have a coin, in which the eagle falls out with probability <img src="https://habrastorage.org/getpro/habr/post_images/98f/d7b/139/98fd7b139e864325bf737711b225a2c3.gif">  .  It is necessary to calculate the mathematical expectation of the number of throws until the eagle falls out. <br><br>  Alternatively, you can paint the expectation of the formula and get something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/30f/0b2/dcd30f0b2f8c65c46392416f3a7bd193.gif"><br>  Or take advantage of <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">well-known facts</a> .  One way or another, mat.  the waiting time of the entire algorithm will be <img src="https://habrastorage.org/getpro/habr/post_images/0a9/2e5/787/0a92e57877c9e6866e50e52592429895.gif">  . <br><br><h4>  Try and correct </h4><br>  Well, but what if we need a really big sequence?  Sequence per million characters. <br><br>  The linear algorithm is no longer so trivial.  Back in 1992, a <a href="http://dl.acm.org/citation.cfm%3Fid%3D136030">separate article by</a> Mike Atkinson and Georges Seck was devoted to him.  I will state here my vision of what is written in the article. <br><br>  We need a magic function <i>f</i> .  The input function must take a balanced bracket sequence, and the output to return the correct same length.  It is important to make the function scatter the sequences evenly, namely, for each correct sequence <i>y there</i> was exactly <i>n</i> +1 balanced sequence <i>x</i> , such that <i>f (x) = y</i> .  If the function can be calculated for linear time, then the matter is in the hat. <br><br>  We generate bracket bracket sequence <i>x</i> according to uniform distribution and return f (x). <br><br>  All the trick in the function.  If you want, you can stop and try to come up with one yourself.  It does not work, nothing terrible.  Now I will get a rabbit from the world of mathematics from the cylinder, and everyone will be fine. <br><br>  Suppose we have a counter, and initially it is zero.  Run through the sequence.  For each opening bracket we will add a point, for each closing - to subtract. <br><pre> <code class="python hljs">balance = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq: balance += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span></code> </pre><br>  The graph below shows how the <code>balance</code> counter changes as you move along the sequence. <br><br><img src="https://habrastorage.org/storage3/d71/44c/acc/d7144cacce6dbc637359059ae4b460d9.png"><br><br>  Sequences colored with individual colors are called indecomposable.  Those.  In general, a sequence is indecomposable if the counter on it takes a zero value only at the starting and ending point.  You can see that indecomposable sequences fall into two categories: those that lie entirely above the zero level, and those that are lower.  The first will be called positive sequences, the second - negative. <br><br>  Calculate the total length of negative subsequences and divide it in half.  The resulting value is called a sequence defect.  The correct sequences have zero defect.  If we replace all the brackets in the correct sequence of length 2 <i>n</i> with inverse, the defect will be <i>n</i> . <br><br>  Attention, rabbit!  Chang-Feller theorem.  The number of bracket sequences of length 2 <i>n</i> with defect <i>k</i> is equal to the <i>n-</i> th Catalan number <img src="https://habrastorage.org/getpro/habr/post_images/68f/fdf/98e/68ffdf98e9827659970bf57157f8c816.gif" title="C_n">  and does not depend on <i>k</i> . <br><br>  The theorem is interesting in that it breaks all balanced sequences of length 2 <i>n</i> into <i>n + 1</i> classes of the same size, and among the classes there is a separate one containing all the correct bracket sequences.  So, you can try to come up with a function that would encode each sequence <i>x</i> with defect <i>k</i> with the correct sequence <i>y</i> , and you could unambiguously reconstruct <i>x</i> using the sequence <i>y</i> and defect <i>k</i> . <br><br>  If we manage to come up with such a function, then we get that for every correct sequence there are exactly <i>n + 1</i> balanced with defects from 0 to <i>n</i> .  It seems simple. <br><br><h5>  Attempt 1. </h5><br>  Let's take all negative subsequences and invert them, i.e.  replace brackets with opposite ones. <br><img src="https://habrastorage.org/getpro/habr/post_images/5c7/a78/845/5c7a788456abc0ae9cd45b2dfe3214c9.gif" title="\ texttt {() {\ color {red})) ((} (()) {\ color {red}) (}} \ rightarrow \ texttt {() {\ color {green} (())} (( )) {\ color {green} ()}}"><br>  Plus such a function, it retains the positions of all indecomposable sequences.  Minus - we lose all the information about which subsequence was negative and which is positive.  Even knowing that the defect was 3, we cannot restore the initial sequence from the example. <br><br><h5>  Attempt 2. </h5><br>  Let's reverse all negative subsequences, and then move them to the end. <br><img src="https://habrastorage.org/getpro/habr/post_images/4b3/65b/f14/4b365bf14a255aaafd760a6d4fd7e637.gif" title="\ texttt {() {\ color {red})) ((} (()) {\ color {red}) (}} \ rightarrow \ texttt {() (()) {\ color {green} (() )} {\ color {green} ()}}"><br>  Now, knowing the defect, we can recover the negative subsequences.  But we lost the position where they were. <br><br><h5>  Attempt 3. </h5><br>  Take an arbitrary indecomposable negative sequence and tear off the extreme brackets from it, and invert the result. <br><img src="https://habrastorage.org/getpro/habr/post_images/f34/9f9/0e7/f349f90e7330c702886c424dd7383296.gif" title="\ texttt {) {\ color {red}) () (} (} \ rightarrow \ texttt {\ color {green} () ()}"><br>  We call this operation tricky inversion and denote it by <i>g</i> .  Because the sequence is indecomposable and negative, the result will always be the correct bracket sequence.  The trick of <i>g</i> is that, on the one hand, it is reversible, and on the other, we have two extra brackets with which we can encode the position of a negative subsequence. <br><br>  We finish Attempt 2, but now we take out the negative sequences in the reverse order and slyly invert them through the function <i>g</i> : <br><img src="https://habrastorage.org/getpro/habr/post_images/e07/77b/0aa/e0777b0aa19cbdad72a0f21933700520.gif" title="\ texttt {() {\ color {red})) ((} (()) {\ color {red}) (}} \ rightarrow \ texttt {() {\ color {blue} \ bf [} (() ) {\ color {blue} \ bf [} {\ color {blue} \ bf]} {\ color {green} e}} _ {\ texttt {\ color {red}) (}} \ texttt {{\ color {blue} \ bf]} {\ color {green} ()}} _ \ texttt {\ color {red})) ((}"><br>  As can be seen from the example, the position of the negative subsequence can be noted in the released brackets.  I have them highlighted in blue and made square.  The letter <i>e</i> means an empty sequence. <br><br>  Find out which brackets are green and which blue ones can be by defect, which means that you can restore the initial sequence itself.  This is what you need! <br><br>  Atkinson and Sack proposed a recursive formula for the function f: <br><img src="https://habrastorage.org/storage3/236/82c/3a4/23682c3a4997a92cd344a48c2d4933d0.png"><br>  Here <img src="https://habrastorage.org/getpro/habr/post_images/afa/be9/d80/afabe9d808e93fbe09b29977a6800dc7.gif" title="\ alpha">  indecomposable subsequence, and <img src="https://habrastorage.org/getpro/habr/post_images/9c1/513/083/9c15130838f0b6f8438ae27175e6718d.gif">  - the remainder. <br><br>  Below I enclose the implementation of the algorithm on Python with expanded recursion.  It is easy to understand that the algorithm works linear time. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryAndFix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> seq = [<span class="hljs-string"><span class="hljs-string">'('</span></span>, <span class="hljs-string"><span class="hljs-string">')'</span></span>] * n random.shuffle(seq) stack = [] result = [] balance = <span class="hljs-number"><span class="hljs-number">0</span></span> prev = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range( len(seq) ): balance += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seq[pos] == <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> balance == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seq[prev] == <span class="hljs-string"><span class="hljs-string">'('</span></span>: result.extend( seq[ prev : pos + <span class="hljs-number"><span class="hljs-number">1</span></span> ] ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) stack.append( [ <span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v == <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq[ prev + <span class="hljs-number"><span class="hljs-number">1</span></span> : pos ] ] ) prev = pos + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> lst <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(stack): result.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) result.extend(lst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><br><h3>  Tree generation </h3><br>  If you have read this far, I am very happy.  All that's left is to convert the sequence to a tree. <br><br>  The bracket sequences of length 2 <i>n</i> perfectly encode trees of arbitrary arity with <i>n</i> + 1 vertices.  Indeed, run the search in depth.  When entering a vertex, we write an opening bracket, at the exit - a closing one. <br><br>  At the same time, trees of arbitrary arity from <i>n</i> + 1 can be put in one-to-one correspondence with binary trees from <i>n</i> vertices.  All that is needed is to first write down trees of arbitrary arity in the form of ‚Äúleft child - right neighbor‚Äù, and then rename the right neighbor to right child. <br><br><img src="https://habrastorage.org/storage3/382/ba9/919/382ba9919e65762d208d8effb5911711.png"><br><br>  Thank you for being with us! <br><br><h3>  Links </h3><br><ul><li>  <a href="http://dl.acm.org/citation.cfm%3Fid%3D136030">"Uniform Random Generation of Balanced Parenthesis Strings" DB Arnold, MR Sleep, 1980</a> - the first article on the generation of random bracket sequences. </li><li>  <a href="http://dl.acm.org/citation.cfm%3Fid%3D136030">"Generating binary trees at random" MD Atkinson, J.-R.</a>  <a href="http://dl.acm.org/citation.cfm%3Fid%3D136030">Sack, 1992</a> </li><li>  <a href="http://pastebin.com/mGwGDUh1">Script on Pastin</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/191298/">https://habr.com/ru/post/191298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191280/index.html">Google Play - we work legally!</a></li>
<li><a href="../191282/index.html">LinkMeUp. Release 6. Information security and attack history</a></li>
<li><a href="../191288/index.html">Razer Ouroboros and Blackwidow overview. Or how I changed the keyboard with the mouse</a></li>
<li><a href="../191290/index.html">Locating a user using Google Play Services</a></li>
<li><a href="../191296/index.html">We write backend for a mobile application in a few minutes</a></li>
<li><a href="../191302/index.html">What happens after buying a startup?</a></li>
<li><a href="../191304/index.html">Caliber 1.0 released</a></li>
<li><a href="../191306/index.html">About InfiniBand: how we reduced ping from 7 Œºs to 2.4 Œºs (and test results)</a></li>
<li><a href="../191308/index.html">Browsers and the frequency of their fall</a></li>
<li><a href="../191310/index.html">Motorola Wireless Networks Based on WING5 Architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>