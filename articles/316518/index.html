<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OSPF protocol in Quagga (one zone)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the continuation of the articles about the device routing tables and about the implementation of the BGP protocol in Quagga, in this article I will...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OSPF protocol in Quagga (one zone)</h1><div class="post__text post__text-html js-mediator-article">  In the continuation of the articles about the device <a href="https://habrahabr.ru/post/306084/">routing tables</a> and about the implementation of the <a href="https://habrahabr.ru/post/310736/">BGP</a> protocol in Quagga, in this article I will discuss how the OSPF protocol works.  I will limit myself to one OSPF zone without redistributing routes from other routing protocols. <br><a name="habracut"></a><br>  As usual, I will not describe in detail the operation and configuration of the OSPF protocol, and I will <a href="https://habrahabr.ru/post/156695/">refer to you</a> where you can read more about it.  I will confine myself only to the most important information for further understanding of the article. <br><br>  Unlike the RIP or BGP protocols, which compare incoming routes from different neighbors and select the best ones according to some criteria, the OSPF protocol builds a topological map of the network and routes the shortest routes to the corresponding ip networks.  To gather information about the network topology, routers exchange among themselves pieces of information about directly connected networks and their OSPF neighbors.  These pieces of topological information are called LSA (Link State Advertisement) and from them, like a puzzle, you can assemble a complete topological map of the network.  How are the LSA, we will look at later, but now we turn to the algorithm for finding the shortest path. <br><br><h1>  Algorithm for finding the shortest path </h1><br>  To find the shortest path, Dijkstra's algorithm is used, whose work will be considered in the following example.  We have five routers interconnected by links, as shown in the figure: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/50b/405/485/50b4054852484de4a6c822352180d41c.jpg"></div><br>  R1 is the root router that runs the shortest path algorithm.  The numbers on the links show the cost (cost) of the link.  The task is to find the shortest path from router R1 to each of the other routers, i.e.  the way at which the total cost of links is minimal. <br><br>  As a result, for each router we need to calculate two things: <br><br><ol><li>  The cost of the path from R1 to this router. </li><li>  Which next-hop uses R1 to reach this router. </li></ol><br>  This information is necessary for R1 to correctly compile the routing table.  Inside each router we will indicate the current cost to it.  Next we will indicate the current next-hop that R1 uses to reach this router.  Green will mark the routers to which the shortest path is calculated. <br><br>  Thus, at the initial stage, we have the shortest path only to the router R1 itself, equal to 0. To the other routers, the values ‚Äã‚Äãare infinite, and the next-hop are unknown. <br><br>  Now we will take a sequence of steps, each of which will improve the cost of the paths to the routers, and ultimately we will calculate the shortest paths to all of them. <br><br><h4>  Step 1. Look at the neighbors of the root router. </h4><br>  The neighbors of the root router R1 are the routers R2 and R3.  For each of them, we set the cost of the path equal to the cost of the corresponding link and the next-hop is equal to the R2 or R3 router itself, as shown in the figure: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/ccd/575/065/ccd5750651a94d748ebc885ccd340d4d.jpg"></div><br><h4>  Step 2. Choose the best of the remaining. </h4><br>  At this step, we look at all the remaining routers, i.e.  routers to which the shortest path has not yet been found (white) and choose from them the router with the lowest cost of the path to it.  In our case, this is R2 router with a cost of 1. We can safely repaint this router in green, there is no shorter way for it. <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/7e2/0dc/f29/7e20dcf29f6d4cbaa7dc0d0ff9ce01e4.jpg"></div><br>  In the figure, it is painted in a darker green color, since this router will come in handy in step 3. <br><br><h4>  Step 3. We look at the neighbors of the selected router. </h4><br>  This step is similar to step 1, but instead of R1, we are looking at the neighbors of the dark green router selected in the previous step.  For each neighbor, we calculate the cost of the path through the selected router.  If the cost of such a path is less than the current value, then we assign a new cost to the neighbor, and simply copy the next-hop from the selected router.  It turns out this picture: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/3c4/82c/680/3c482c680f5c49b4a787aaad1100148c.jpg"></div><br>  Now repeat steps 2 and 3 until all routers turn green.  At stage 2, we have one router necessarily turns green, so that this process will end sooner or later. <br><br>  So, choose the best of the remaining ones, repaint green (router R5): <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/830/c1a/ce3/830c1ace3ffc496781ee27c34bfaf3a8.jpg"></div><br>  We look at the neighbors of the selected router, improve the cost, copy the next-hop: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/e6e/7ad/c3e/e6e7adc3e3f94555ab43f7e51f0e0fe4.jpg"></div><br>  It can be seen that R3 has changed next-hop, which was copied from R5.  Choose the best: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/dae/16c/ea0/dae16cea0604426c902276a510e5dc25.jpg"></div><br>  We look at the remaining neighbor: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/254/488/7b1/2544887b15b84b26a300d5a8c9ec45f6.jpg"></div><br>  And we get the final result: <br><br><div style="text-align:center;"><img width="60%" height="60%" src="https://habrastorage.org/files/5da/cac/e48/5dacace48d244f83bed5cdaa5eea091a.jpg"></div><br>  Now we have the cost of the paths to each of the routers, as well as which next-hop to use on the root router to achieve them.  Those.  we are almost ready to create a routing table.  However, for direct application in networks, the above algorithm requires some modernization. <br><br><h1>  Shortest Path Algorithm Update </h1><br>  The above algorithm works only with point-to-point links, when each link connects two routers.  Real routers can be connected to each other via an Ethernet network that allows more than 2 routers to connect to one segment, as shown in the figure. <br><br><div style="text-align:center;"><img width="40%" height="40%" src="https://habrastorage.org/files/b1e/2c1/0a8/b1e2c10a899f4a3281c70e83d6aaeb6a.jpg"></div><br>  In the OSPF protocol, such a network is called transit.  To solve this problem in OSPF, each transit network is represented by a separate node in the graph.  Those.  when calculating the shortest path, the topology will look like this: <br><br><div style="text-align:center;"><img width="40%" height="40%" src="https://habrastorage.org/files/af0/5b7/cf6/af05b7cf695646eb9083cf3389e164a0.jpg"></div><br>  Node N1 is just the transit network.  Now we have each link connects only two nodes, and we can apply the shortest path algorithm.  When calculating the cost of the path, only the cost of the link from the router to the transit network is taken into account, and from the transit network to the router it is considered equal to 0. <br><br>  Since the transit network is a logical entity, one of the routers should take the responsibility to create the necessary topological information describing the transit network.  To do this, in OSPF, in each transit network, a Designated Router (DR) is selected, which, in addition to information about itself, also has the obligation to announce information about the transit network. <br><br>  In addition, in the routing table there are routes not to routers, but to ip networks.  The issue with transit networks is solved simply.  Since transit networks are represented by vertices in the graph, the cost of routes to transit networks is calculated during the operation of the shortest path search algorithm.  Other networks, for example, networks to which only one OSPF router is connected, are considered final (stub) networks and are advertised by the routers to which they are connected.  Knowing the cost of the shortest path to each router, you can easily calculate the cost of the route to all end networks connected to it. <br><br><h1>  Link State Advertisement (LSA) </h1><br>  As I said, in order for each router to create a network topology and apply the shortest path search algorithm to it, the routers exchange small pieces of information with each other, called Link State Advertisement LSA.  LSA come in different types and convey different information.  For our case with a single zone, two types of LSA are important - LSA type 1 and LSA type 2. Each LSA type 1 describes a router.  LSA type 2 describes the transit network.  If we omit the various service information, then these LSA can be schematically represented as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/38a/2f0/352/38a2f03522444d86b8a8361a70da3558.jpg"></div><br>  Below is a brief description of the LSA fields. <br><br><h4>  LSA Type 1 (Router LSA). </h4><br>  In the LSA header, we need three fields: <br><br><ul><li>  Type of.  Indicates the type of LSA.  In our case, this is type 1, or Router LSA. </li><li>  LSID.  LSA ID.  In our case, the LSID is equal to the Router ID of the router that creates the LSA. </li><li>  Adv Router.  ID of the router that created the LSA.  In our case, it is also equal to the Router ID of the router that creates the LSA, i.e.  matches the LSID. </li></ul><br>  Below is information about the links of our router.  Information about the link depends on the type of link.  A router can have links of three different types: <br><br>  <b>Transit network.</b>  For a link of this type, the following information is transmitted: <br><br><ul><li>  Link ID - ip-address of the Designated Router interface connected to the transit network. </li><li>  Link Data - ip-address of the interface of the router itself connected to the transit network. </li><li>  Metric - link cost. </li></ul><br>  <b>Point to point.</b>  For a point-to-point link, it is transmitted: <br><br><ul><li>  Link ID - ip-address of the neighbor interface. </li><li>  Link Data - ip-address of the interface of the router itself. </li><li>  Metric - link cost. </li></ul><br>  <b>The ultimate (stub) network.</b>  For her transmitted: <br><br><ul><li>  Link ID - the actual IP address of the network. </li><li>  Link Data - network mask. </li><li>  Metric - link cost. </li></ul><br><h4>  LSA Type 2 (Network LSA) </h4><br>  The LSA type 2 transmits the transit network information and is advertised specifically selected for each Designated Router network. <br><br>  The LSA header contains four important fields: <br><br><ul><li>  Type of.  In our case, this is type 2, or Network LSA. </li><li>  LSID.  LSA ID.  In our case, the LSID is equal to the ip-address of the Designated Router interface connected to the transit network; </li><li>  Adv Router.  ID of the router that created the LSA.  In our case, it is equal to Designated Router ID. </li><li>  Mask.  Net mask </li></ul><br>  Next comes the information about routers connected to the transit network.  For each such router, its Router ID is indicated. <br><br>  Each LSA corresponds to a graph node and, depending on the type, represents either a router or a transit network.  Having all the LSA is now easy to create a network topology.  For this, it is sufficient to note that the Link ID of the transit link of the router corresponds to the LSID of the transit network, and vice versa, the Attached Router ID of the transit network corresponds to the LSID of the router connected to the transit network. <br><br>  For example, the figure shows a small network: <br><br><div style="text-align:center;"><img width="50%" height="50%" src="https://habrastorage.org/files/678/289/2ea/6782892eaa034944878af188df3f784e.jpg"></div><br>  corresponding to her LSA: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70a/b76/6de/70ab766de67b41edb935e5e346d3a8ad.jpg"></div><br>  and topology: <br><br><div style="text-align:center;"><img width="40%" height="40%" src="https://habrastorage.org/files/382/8e5/274/3828e52745aa4c9aab53070a34b54236.jpg"></div><br>  All created and received LSAs are stored in a database called LSDB (LSA Database).  The main thing that is needed from this database is to be able to add LSAs to it, iterate over all LSAs of a particular type and search for LSAs by key fields from the LSA header. <br><br>  You can view a list of all LSAs in LSDB and their fields using the <b>show ip ospf database commands</b> (displays all LSA headers), <b>show ip ospf database route</b> (displays full information on LSA type Router) and <b>show ip ospf database network</b> (displays full information on LSA network type). <br><br><h1>  Implementation in Quagga </h1><br>  In Quagga, the entire LSA storage base (LSDB) is split into several bases, separate for each type of LSA, as shown in the figure: <br><br><div style="text-align:center;"><img width="90%" height="90%" src="https://habrastorage.org/files/55a/155/945/55a155945dc6414481709dc64899f8c9.jpg"></div><br><br>  Each base for storing a separate type of LSA is arranged in the same way and stores the LSAs contained in it in the form of a prefix tree described in the previous <a href="https://habrahabr.ru/post/306084/">article</a> .  The prefix is ‚Äã‚Äãa combination of LSID and Adv Router.  The combination of these fields is unique for each LSA of a particular type within a zone. <br><br>  When a new LSA is received, this LSA is added to LSDB and the computation of the shortest route starts.  The process begins with an LSA corresponding to the router itself.  Based on the information contained in it, a new node is created in memory corresponding to the root node in the topology.  Next, LSDBs sequentially derive LSA, corresponding to the neighboring nodes in the topology, create new nodes and calculate the shortest paths and the next-hop to them, as described in the shortest path algorithm.  In parallel, for the processed nodes, routes to transit networks are added to the OSPF routing table. <br><br>  After the topology has been built and the shortest paths have been calculated, all nodes corresponding to the routers are viewed, and all their final (stub) networks are added to the OSPF routing table.  Routes to transit networks have already been added to the routing table. <br><br>  In the final step, all nodes in the topology are removed from memory, and routes from the OSPF routing table are transferred to the zebra daemon.  The scheme of this process is shown in the figure. <br><br><div style="text-align:center;"><img width="40%" height="40%" src="https://habrastorage.org/files/deb/9ba/834/deb9ba83493641aca011b82e819c501a.jpg"></div></div><p>Source: <a href="https://habr.com/ru/post/316518/">https://habr.com/ru/post/316518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316500/index.html">The loudest cyber attacks on critical infrastructures</a></li>
<li><a href="../316504/index.html">Infrastructure in a box: Schneider Electric container data centers</a></li>
<li><a href="../316506/index.html">Brilliance and misery php. Language evolution from 4.x to 7.1</a></li>
<li><a href="../316512/index.html">How IT professionals work. Daniel Pivovarov, Vscale</a></li>
<li><a href="../316516/index.html">Low-level optimization and measurement of code performance on R</a></li>
<li><a href="../316520/index.html">Own platform. Part 0.1 Theory. Little about processors</a></li>
<li><a href="../316522/index.html">Five aspects of information security that will change with the development of fifth-generation mobile networks</a></li>
<li><a href="../316524/index.html">Attackers exploit the 0day vulnerability in the Tor web browser for cyber attacks</a></li>
<li><a href="../316526/index.html">About broadband microwave switches from Peregrine Semiconductor</a></li>
<li><a href="../316528/index.html">Adding admob ads to an android app using firebase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>