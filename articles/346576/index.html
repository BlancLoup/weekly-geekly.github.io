<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 


 In the article I will describe the idea of ‚Äã‚Äãstorage in a fairly well-known KDB column database, as well as examples of how to access th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KDB</h1><div class="post__text post__text-html js-mediator-article"><p> <a href="https://habrahabr.ru/post/346576/"><img src="https://habrastorage.org/webt/ch/ny/7h/chny7huettmiohatz4bxrjkh24q.jpeg" alt="cdvp"></a> </p><br><p>  Hi, Habr! </p><br><p>  In the article I will describe the idea of ‚Äã‚Äãstorage in a fairly well-known <a href="https://kx.com/">KDB</a> column database, as well as examples of how to access this data.  The base has existed since 2001, and at the moment it occupies high places on websites with a comparison of similar systems (see, for example, <a href="https://www.influxdata.com/time-series-database/">here</a> ) </p><a name="habracut"></a><br><h1 id="zachem">  What for? </h1><br><h2 id="hranenie-time-series">  Time Series Storage </h2><br><p>  If you have currency fluctuations every second for the last 20 years, the relational database will not be the fastest and most effective solution for storing and processing the accumulated (that is, slightly more than 120 * 10 ^ 9 lines for 200 currencies).  In this case, it is most logical to use a fast column database, which means KDB will help us. </p><br><p>  Similarly, if you do not store numbers, as in the example above, but serialized objects.  In this case, the task of storing a large number of rows adds the complication of the large size of each row. </p><br><h2 id="vychisleniya">  Calculations </h2><br><p>  After you have a large amount of data, tasks on analyzing this data often begin to arise - finding correlations between them, creating aggregations, etc. That is, this requires the ability to write a function (with cycles, conditions, everything is supposed) would be executed as close as possible to the data (ideally in the database itself), so as not to drive the data over the network. </p><br><h2 id="production-ready">  Production ready </h2><br><p>  Having solved all the direct technical problems, you will have the following: </p><br><ul><li>  Backup </li><li>  Replication (+ active-active services work) </li><li>  <a href="https://ruhighload.com/post/%25D0%25A8%25D0%25B0%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B3%2B%25D0%25B8%2B%25D1%2580%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Sharding</a> </li><li>  Support for major technologies and programming languages ‚Äã‚Äã(Java, .Net, R, etc.) </li></ul><br><h1 id="kak-ono-rabotaet-na-odnom-servere">  How does it work on one server? </h1><br><p>  Physical data in KDB is stored at minimal cost.  So, a column with integers is just a sequence of integers that is stored in a single file on disk. </p><br><h2 id="fizicheskoe-hranenie">  Physical storage </h2><br><p>  As mentioned above, KDB is a column database, i.e.  each column is stored separately.  In reality, a column is just a separate file, nothing more than.  That is, a table t with columns a, b, c and d will simply represent on the disk a folder "t", in which there are four files - a, b, c and d.  And plus a small metadata file.  If you need to copy the table - you can simply copy the files (and make the metadata generate).  If you need to transfer some data to a new server - just copy the files. </p><br><p>  As any reader understands, storing millions of objects in one file is extremely inefficient.  In this case, even the task of re-sorting will be solved already difficult and expensive (after all, you can‚Äôt take everything into memory - it‚Äôs not so much).  From here in KDB (as in every decent column database) the entire table is initially divided into sections (see the sectionsitions), see the <a href="http://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/">documentation</a> .  Sections are assigned to the entire database and most often are just a date. </p><br><p>  The latter already slightly complicates the file structure.  If you have two tables (t1 and t2), and they have a date column (we divide data by folders according to it), then the following structure will be on the disk: </p><br><pre><code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>2017.01.01 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>t1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>t2 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>2017.01.02 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>t1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>t2</code> </pre> <br><p>  That is, in the folder with the date there are folders with tables, in which there are files with columns. </p><br><p>  Data is always stored on the disk without the possibility of changing or deleting it.  You can only add more data.  Those.  if you need to update or discard data for date d, take them all into memory ( <code>select from t where date = d</code> ), do all the necessary operations, save for date d1, and then change the folder names on the disk. </p><br><p>  After we have learned to share files on a disk, you can still optimize their storage using compression (for example, gzip or <a href="https://google.github.io/snappy/">google snappy</a> ).  An effective column base must be able to do it on its own, for otherwise it will be necessary to compress either the file system (ie, store uncompressed data in the RAM cache), or not compress the data at all (and increase IO) or compress the data already in the application layer (and lose possibility of compression of adjacent lines). </p><br><p>  In addition to efficient data storage, KDB provides the ability to quickly read data into memory.  For this, the table must be ordered, that is, one to choose from: </p><br><ul><li>  The data in each section is kept intact.  That is, if we have a table t with date (partition) columns, as well as b, c and d, then to execute the query <code>select v from t where date=2017.01.01 and k=12</code> will have to load all data from columns k and v for a specific date.  Or, in the language of relational databases, you have to do an index scan. </li><li>  One of the columns will be sorted.  If we continue the example above and sort the data by column k, then the query <code>select v from t where date=2017.01.01 and k=12</code> will work much faster - KDB will load only part of the data into memory, it will find them for logarithm.  What is important - from this attribute the table does not grow on the disk, i.e.  no additional data is required. </li><li>  One of the columns will be unique.  In this case, KDB will additionally create a hash table for the values, which will make an index seek in the example <code>select v from t where date=2017.01.01 and k=12</code> .  Obviously, in this case, the hash table is stored nearby and takes away precious space. </li><li>  Multiple columns are grouped.  In essence, this is about the same as the primary key index in relational databases.  In such a table, a tuple of identical column values ‚Äã‚Äãis stored together; moreover, a hash table is separately stored, by which you can immediately refer to the desired value.  That is, for queries of the form <code>select v from t where date=2017.01.01 and k=12</code> , index seek will occur, and KDB will instantly jump to the desired value on the disk.  However, queries of the form <code>select v from t where date=2017.01.01 and k&lt;12 and k &gt; 10</code> will do an index scan, since the hash table will not sort the data.  However, the task is easily solved with the help of an additional table and a sorted column. </li></ul><br><h2 id="rdb-i-hdb">  RDB and HDB </h2><br><p>  The attentive reader will note that the two statements above are somewhat difficult to combine: the <em>data in KDB can be stored sorted</em> and <em>cannot be inserted into the table on the disk in the middle, you can only add to the end</em> .  To combine this two statements (and not to lose in performance), KDB uses the following approach: </p><br><ul><li>  All historical data is stored in <a href="https://code.kx.com/q/tutorials/startingq/hdb/">HDB (historical DB)</a> .  They are stored compressed and orderly on disk, they can be quickly read into memory and analyzed. </li><li>  All data for the last day is stored in <a href="https://code.kx.com/q/cookbook/w-q/">RDB (realtime DB)</a> , whose task is to collect data from the application as soon as possible.  In this case, the numbers can be stored in RAM (the last day of 20 years is unlikely to take up much space), which will allow them to be quickly accessed even if they are not sorted.  If the data stream is large enough, of course, you can remove numbers from RAM at the time they are flushed to disk. </li></ul><br><p>  If it is completely superficial, then the algorithm of RDB operation is as follows: </p><br><ol><li>  We take data from the application </li><li>  Once in N seconds / minutes, we reset the data to disk and call the user function to which we transfer the reset.  She is: <br>  2.1.  Or appends newly arrived data to an object in memory (filtering, aggregating, whatever) <br>  2.2.  Does nothing (after all, we do not always need the current day to analyze history) </li><li>  At the end of the day - we take away all the data accumulated in the RDB, sort / group them and drop them in HDB </li></ol><br><h1 id="q">  Q </h1><br><p>  Speaking about KDB, one cannot but mention the Q language, on which all queries (and all functions) in KDB are built.  If the functions of the sample more or less everything is clear (see the example above - <code>select v from t where date=2017.01.01 and k=12</code> ), then the rest of the things look a bit more unusual. </p><br><p>  The idea of ‚Äã‚ÄãQ can be associated with the proverb <em>brevity - the sister of talent</em> . </p><br><p>  So, create a new variable: </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  Simplify the request - we do not need and to list the conditions: </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  Add grouping and aggregation: </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  rename column: </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c: <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  Back to first request </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  And rename the column </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>; tv: `v1 xcol tv;</code> </pre> <br><p>  Sort the column: </p><br><pre> <code class="hljs sql">tv: <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>; tv: `v1 xcol tv; tv: `v1 xasc tv;</code> </pre> <br><p>  Or, more conveniently, we will combine the query into a more familiar one line: </p><br><pre> <code class="hljs sql">tv: `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre> <br><p>  Wrap our query into a function (the ':' symbol at the beginning of the expression means return, not assignment, as was the case in the examples above): </p><br><pre> <code class="hljs pgsql">f: {[] tv: `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>=<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>,k=<span class="hljs-number"><span class="hljs-number">12</span></span>; :tv; }</code> </pre> <br><p>  Add parameters: </p><br><pre> <code class="hljs pgsql">f: {[i_d; i_k] tv: `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>=i_d,k=i_k; :tv; }</code> </pre> <br><p>  And we will call the function (in the end we will not write ";" - this will give us output to the console, as a useful side effect): </p><br><pre> <code class="hljs pgsql">f: {[i_d; i_k] tv: `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>=i_d,k=i_k; :tv; }; f[<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>; <span class="hljs-number"><span class="hljs-number">12</span></span>]</code> </pre> <br><p>  Let's pass the arguments in the dictionary, so that later it would be more convenient to forward them from other functions (without an explicit return, that is, without ":", the result of the last expression is considered the result of the lambda operation): </p><br><pre> <code class="hljs pgsql">f: {[d] i_d: d[`<span class="hljs-type"><span class="hljs-type">date</span></span>]; i_k: d[`key]; `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>=i_d,k=i_k; }; f[(`<span class="hljs-type"><span class="hljs-type">date</span></span>`key)!(<span class="hljs-number"><span class="hljs-number">2017.01</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span>;<span class="hljs-number"><span class="hljs-number">12</span></span>)]</code> </pre> <br><p>  In the last example, we did several things at once: </p><br><ol><li>  Declared a dictionary using the expression <code>(`date`key)!(2017.01.01;12)</code> </li><li>  Transferred the dictionary to the function </li><li>  Read the variables from the dictionary <code>i_d: d[`date]</code> ; </li></ol><br><p>  Next, we add a throwing error for the case when there is no data: </p><br><pre> <code class="hljs pgsql">f: {[d] i_d: d[`<span class="hljs-type"><span class="hljs-type">date</span></span>]; i_k: d[`key]; r: `v1 xasc `v1 xcol <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>=i_d,k=i_k; $[<span class="hljs-number"><span class="hljs-number">0</span></span> = count r;<span class="hljs-string"><span class="hljs-string">'`no_data;:r]; }; f[(`date`key)!(2017.01.01;12)]</span></span></code> </pre> <br><p>  So, now our function will throw an exception with the words "no_data" for the case when there is no data in the table for our query. <br>  The construction of <code>$[1=0;`true;`false]</code> is a <a href="http://code.kx.com/q/ref/control/">conditional transition</a> in which the condition is first, then the expression that should be executed if the condition is true.  At the end is an <em>else</em> block.  However, in reality it is rather pattern matching than if, for the following construction is also admissible: <code>$[a=0;`0; a=1;`2; `unknown]</code> <code>$[a=0;`0; a=1;`2; `unknown]</code>  <code>$[a=0;`0; a=1;`2; `unknown]</code> .  That is, on all odd positions (except the last one) there are conditions, on all even ones - what needs to be done.  And at the end - the else block. </p><br><p>  As seen in the examples, the language is logical (albeit concise).  In Q there is: </p><br><ul><li>  Lambda </li><li>  Conditional transitions </li><li>  Cycles </li><li>  Special instructions for joining tables (including complex joines, pivot tables) </li><li>  The ability to add modules (for example, to calculate analytics on the GPU at the same time) </li></ul><br><h1 id="i-v-zaklyuchenii">  And in conclusion </h1><br><ul><li>  If you are working with a large amount of data - KDB will help you </li><li>  If you have time series analysis tasks - KDB will help you </li><li>  If you have a task of fast recording (and subsequent analysis) of a large data stream - KDB will help you </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346576/">https://habr.com/ru/post/346576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346562/index.html">Richard Hamming: Chapter 23. Mathematics</a></li>
<li><a href="../346564/index.html">Richard Hamming: Chapter 19. Modeling - II</a></li>
<li><a href="../346566/index.html">Richard Hamming: Chapter 4. Computer History - Software</a></li>
<li><a href="../346572/index.html">The tale of total brute force, or the tormenting wait of the decrypt</a></li>
<li><a href="../346574/index.html">Selfish problems: traffic jams and the Braes paradox</a></li>
<li><a href="../346578/index.html">How to train mdl pnmt obratty skrschnya</a></li>
<li><a href="../346580/index.html">How will be organized trading in Bitcoin futures on the Chicago Stock Exchange</a></li>
<li><a href="../346582/index.html">Risk management in the fairy tale of A.S. Pushkin ‚ÄúOn the Fisherman and the Fish‚Äù</a></li>
<li><a href="../346584/index.html">How to do typical tasks in a web application on React JS</a></li>
<li><a href="../346586/index.html">How to build a community. Translation of the book "Social Architecture": The Myth of Individual Intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>