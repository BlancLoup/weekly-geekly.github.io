<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UDP and C # Reactive Extensions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I read a post about UDP and C # async / await , in which the description of solving a simple task of polling devices over UDP by one client. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UDP and C # Reactive Extensions</h1><div class="post__text post__text-html js-mediator-article">  Recently I read a post about <a href="http://habrahabr.ru/post/238377/">UDP and C # async / await</a> , in which the description of solving a simple task of polling devices over UDP by one client.  Solving a problem with async \ await really reduces the amount of code compared to the manual implementation of asynchronous calls.  On the other hand, it creates many problems with the synchronization of tasks, competitive access to data and exception handling.  The resulting solution is very error prone.  The original version of the author contained non-release resource errors. <br><br>  Can it be made easier and more reliable? <br><a name="habracut"></a><br><br><h4>  What is the actual problem? </h4><br>  The problem is in the <code>UdpClient.Receive</code> (- <code>Async</code> ) method.  This method is not reenterable, that is, if the client is already waiting for the arrival of the datagram, then you cannot call this method again.  Even if the error does not come out, then it is quite possible to get the datagram expected by another ‚Äústream‚Äù.  Therefore, you need to write additional code that synchronizes user actions and the state of the <code>UdpClient</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      async \ await and Tasks Parallel Library does not have ready-made synchronization tools.  It is necessary either to write code with your hands, as in the original article, or to use ready-made libraries, like <a href="http://msdn.microsoft.com/en-us/library/hh228603(v%3Dvs.110).aspx">TPL Dataflow</a> .  But, alas, Dataflow is very heavy. <br><br><h4>  Reactive Extensions </h4><br>  Instead of TPL Dataflow, you can use Reactive Extensions (RX).  RX describes asynchronous data streams (asynchronous sequences).  RX has many functions for creating and manipulating data flows.  RX allows you to work not only with IO, but also with ‚Äúevent streams‚Äù generated by interface elements.  This allows the entire program to be described as a set of data streams. <br><br><h5>  Code example </h5>  To solve the original problem, you will need to add the <code>Rx-Main</code> library from NuGet to the project and write several helpers: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IObservable&lt;UdpReceiveResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceiveObservable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UdpClient client</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client.ReceiveAsync().ToObservable(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IObservable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendObservable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UdpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client.SendAsync(msg, bytes, ip, port).ToObservable(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IObservable&lt;UdpReceiveResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceiveStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UdpClient client</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.Defer(() =&gt; client.ReceiveObservable()).Repeat(); }</code> </pre><br>  The first two helpers transform Task into IObservable (one-element asynchronous sequence) using an extension method. <br>  The last helper shows an example of sequence manipulation. <br>  <code>Observable.Defer</code> - defers a call to the sequence constructor in a parameter before the subscriber appears. <br>  The extension method <code>.Repeat()</code> repeats the infinite source sequence. <br>  Together, the two methods create an endless loop of getting datagrams from a socket. <br><br>  Now the method of sending and receiving data: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IObservable&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; SendReceiveUdpAsync(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] msg, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ip, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeOut) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client.SendObservable(msg, msg.Length, ip, port) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> receiveStream <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.RemoteEndPoint.Address.ToString() == ip &amp;&amp; r.RemoteEndPoint.Port == port <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> r.Buffer; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o.Take(<span class="hljs-number"><span class="hljs-number">1</span></span>).Timeout(TimeSpan.FromMilliseconds(timeOut)); }</code> </pre><br>  Yes, RX supports Linq for asynchronous sequences. <br>  This Linq expression is quite difficult to understand without knowing RX, but its essence is very simple: after receiving the result from the <code>SendObservable</code> stream <code>SendObservable</code> subscribe to the <code>receiveStream</code> stream and get only those elements that satisfy the predicate in <i>where</i> to return the buffer from the received datagram.  Then one result of the resulting sequence is taken and a timeout is hung. <br><br>  The most important part of the code is the <code>receiveStream</code> definition: <br><pre> <code class="cs hljs">receiveStream = client.ReceiveStream().Publish().RefCount();</code> </pre><br><br><h5>  Hot, cold and warm sequences </h5>  When you work with RX sequences, it is important to know their ‚Äútemperature‚Äù. <br><br>  Cold sequences are those that appear when a subscriber appears in a sequence and disappear when the subscriber ceases to exist. <br>  The <code>ReceiveStream</code> extension <code>ReceiveStream</code> returns just such a sequence.  This means that each subscriber will have his own sequence, that is, there will be several calls to <code>UdpClient.ReceiveAsync</code> and the problem described at the beginning cannot be solved. <br><br>  Hot sequences - which exist independently of the subscribers.  For example, the sequence of mouse movements of the user.  The <code>Publish</code> function in the code above allows you to turn a cold sequence into a hot one.  But it carries another problem.  If the <code>UdpClient</code> constructor <code>UdpClient</code> not specify the port and call <code>Receive</code> before the <code>Send</code> call, an error will occur. <br><br>  Therefore, we need an intermediate option - the sequence should be common for all subscribers and should exist as long as there is at least one subscriber.  This sequence is called ‚Äúwarm‚Äù and is created by calling <code>RefCount</code> . <br><br><h5>  Subscribe to events </h5>  For testing, I also wrote a ‚Äúserver‚Äù function: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IDisposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Listen</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;UdpReceiveResult, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]&gt; process</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiveStream.Subscribe(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = process(r); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.SendObservable(msg, msg.Length, r.RemoteEndPoint); }); }</code> </pre><br>  The Subscribe method allows you to specify the action that will be called on each element of the asynchronous sequence.  You can also specify an action for the end of the sequence and for the exception. <br><br>  Also note that RX supports async \ await, that is, you do not need to know RX to use code built on the basis of asynchronous sequences. <br><br><h4>  Conclusion </h4><br>  The resulting code does not contain a single loop, a single explicit synchronization, or a single thread or task creation.  At the same time, the code is completely asynchronous and secure. <br>  RX is definitely worth exploring, even if you won't use it.  The main part of Rx was invented by applying the principle of duality of monads to standard interfaces IEnumerable and IEnumerator, so the RX was compact and powerful.  In addition, RX is also available for JavaScript, C ++, Java, Scala and Python, Ruby. <br><br>  The source code together with the client and the server was posted on github - <a href="https://github.com/gandjustas/UdpRxSample">github.com/gandjustas/UdpRxSample</a> . </div><p>Source: <a href="https://habr.com/ru/post/238445/">https://habr.com/ru/post/238445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238433/index.html">Is it possible to create a lightsaber from the point of view of modern science?</a></li>
<li><a href="../238437/index.html">The whole truth about venture capital investors, part 2</a></li>
<li><a href="../238439/index.html">The evolution of intelligent networks # Genesis</a></li>
<li><a href="../238441/index.html">Create a virtual mPOS terminal</a></li>
<li><a href="../238443/index.html">ESP8266: What's inside the ‚Äúpopular wi-fi‚Äù?</a></li>
<li><a href="../238447/index.html">Yii 2.0 RC</a></li>
<li><a href="../238449/index.html">Align the block to the center of the page.</a></li>
<li><a href="../238451/index.html">3D printing of protein molecules</a></li>
<li><a href="../238453/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 127 (September 22 - 28, 2014)</a></li>
<li><a href="../238457/index.html">The main types of search queries that online store users use, is your website ready for them? (Part 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>