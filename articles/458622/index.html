<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automation for the smallest. Part One (which is after zero). Network virtualization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous issue, I described the network automation framework. According to reviews from some people, even this first approach to the problem ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automation for the smallest. Part One (which is after zero). Network virtualization</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habr.com/ru/post/453516/">previous issue,</a> I described the network automation framework.  According to reviews from some people, even this first approach to the problem has already arranged some questions on the shelves.  And it makes me very happy, because our goal in the cycle is not to plaster the anzibl with Python scripts, but to build a system. <br><br>  The same framework sets the order in which we will deal with the question. <br>  And the network virtualization, to which this issue is dedicated, does not really fit into the subject of ADSM, where we disassemble automation. <br><br>  But let's take a look at it from a different angle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a long time, many services have been using the same network.  In the case of a carrier, these are 2G, 3G, LTE, broadband access and B2B, for example.  In the case of DC: connectivity for different clients, the Internet, block storage, object storage. <br><br>  And all services require isolation from each other.  This is how overlay networks appeared. <br><br>  And all the services do not want to wait for the person to configure them manually.  That is how the orchestrators and SDN appeared. <br><br>  The first approach to the systematic automation of the network, or rather its parts, has long been undertaken and implemented in many places: VMWare, OpenStack, Google Compute Cloud, AWS, Facebook. <br><br>  Here with him today and ponder. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b14/278/742/b142787424b1da02432df0291faaca95.jpg" width="800"></a> <br><a name="habracut"></a><br><h1>  Content </h1><br><ul><li>  <b>The reasons</b> </li><li>  <b>Terminology</b> </li><li>  <b>Underlay - physical network</b> </li><li>  <b>Overlay - virtual network</b> <br><br><ul><li>  Overlay with ToR'a </li><li>  Overlay from host </li><li>  On the example of Tungsten Fabric <br><br><ul><li>  Communication within a single physical machine </li><li>  Communication between VMs located on different physical machines. </li><li>  Exit to the outside world </li></ul><br></li></ul><br></li><li>  <b>FAQ</b> </li><li>  <b>Conclusion</b> </li><li>  <b>useful links</b> </li></ul><br><hr><br><br><h1>  The reasons </h1><br>  And since we started talking about this, it is worth mentioning the prerequisites for network virtualization.  In fact, this process did not begin yesterday. <br><br>  Probably, you have often heard that the network has always been the most inert part of any system.  And this is true in all senses.  The network is the basis on which everything rests, and it is quite difficult to make changes on it - services do not tolerate when the network is lying.  Often, decommissioning a single node can add up most of the applications and affect many customers.  This is partly why the network team can resist any changes - because now it somehow works ( <i>we may not even know how</i> ), and here we need to configure something new, and it is not known how it will affect the network. <br><br>  In order not to wait for networkers to drop VLANs and not to prescribe any services on each node of the network, people have come up with the use of overlays ‚Äî overlay networks ‚Äî of which there is a great variety: GRE, IPinIP, MPLS, MPLS L2 / L3VPN, VXLAN, GENEVE, MPLSoverUDP, MPLSoverGRE, etc. <br><br>  Their appeal lies in two simple things: <br><br><ul><li>  Only end nodes are configured - no need to touch transit nodes.  This significantly speeds up the process, and sometimes even allows you to exclude the network infrastructure department from the process of entering new services. </li><li>  The load is hidden deep inside the headers - the transit nodes do not need to know anything about it, about the addressing on the hosts, the routes of the superimposed network.  And this means you need to store less information in the tables, it means to take a simpler / cheaper device. </li></ul><br>  In this not quite high-grade release, I do not plan to disassemble all possible technologies, but rather describe the framework of work of overlay networks in DC. <br><br>  The whole series will describe a data center consisting of rows of racks of the same type, in which the same server hardware is installed. <br><br>  This equipment runs virtual machines / containers / serverless, implementing services. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/525/54b/f0352554b58d82955bd7c08f3034cd4f.jpg" width="600" title="Dataline Nord DC"><br><br><hr><br><br><h1>  Terminology </h1><br>  In the loop, I will call the <b>server a</b> program that implements the server side of client-server communication. <br><br>  Physical machines in racks will <b>not</b> be called servers. <br><br>  <b>The physical machine</b> is an x86 rack-mounted computer.  The most commonly used term is <b>host</b> .  So let's call it " <b>machine</b> " or <b>host</b> . <br><br>  <b>A hypervisor</b> is an application running on a physical machine that emulates the physical resources on which Virtual Machines are started.  Sometimes in literature and networks the word ‚Äúhypervisor‚Äù is used as a synonym for ‚Äúhost‚Äù. <br><br>  <b>A virtual machine</b> is an operating system running on a physical machine on top of the hypervisor.  For us, in this cycle it is not so important whether it really is a virtual machine or just a container.  Let's call it " <b>VM</b> " <br><br>  <b>Tenant</b> is a broad concept that I will define in this article as a separate service or a separate client. <br><br>  <b>Multi-tenancy</b> or multi-tenancy - using the same application by different clients / services.  At the same time, the isolation of clients from each other is achieved due to the architecture of the application, rather than separately-running instances. <br><br>  <b>ToR - Top of the Rack switch</b> - a switch mounted in a rack to which all physical machines are connected. <br><blockquote>  In addition to the topology of ToR, different providers practice End of Row (EoR) or Middle of Row (although the latter is a scornful rarity and I did not see MoR abbreviations). <br></blockquote>  <b>Underlay network</b> or underlying network or underlay ‚Äî physical network infrastructure: switches, routers, cables. <br><br>  <b>Overlay network</b> or overlay network or overlay is a virtual network of tunnels running on top of the physical. <br><br>  <b>L3-factory or IP-factory</b> - a terrific invention of mankind, which allows for interviews not to repeat STP and not to learn TRILL.  A concept in which the entire network down to the access level is exclusively L3, without a VLAN and consequently huge stretched broadcast domains.  Where does the word "factory" come from here? <br><br>  <b>SDN</b> - Software Defined Network.  Hardly needs any introduction.  An approach to network management when changes on the network are performed not by a person, but by a program.  Usually means taking Control Plane beyond the end network devices to the controller. <br><br>  <b>NFV</b> - Network Function Virtualization - virtualization of network devices, suggesting that some of the network functions can be run as virtual machines or containers to speed up the introduction of new services, organize Service Chaining and more simple horizontal scalability. <br><br>  <b>VNF</b> - Virtual Network Function.  Specific virtual device: router, switch, firewall, NAT, IPS / IDS, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/501/33c/ca950133ca98bd1e2ca613342432c535.png" width="700"><br><blockquote>  I now intentionally simplify the description to a specific implementation in order not to confuse the reader much.  For a more thoughtful reading, refer it to the <a href="https://habr.com/ru/post/458622/">Links</a> section.  In addition, Roma Gorga, who criticizes this article for inaccuracies, promises to write a separate issue about server and network virtualization technologies, which is deeper and more attentive to details. </blockquote><br><hr><br>  Most networks today can be clearly divided into two parts: <br><br>  <b>Underlay</b> is a physical network with a stable configuration. <br>  <b>Overlay</b> - an abstraction over underlay to isolate tenants. <br><br>  This is true both for the DC case (which we will discuss in this article) and for the ISP (which we will not analyze, because we already had it in the <a href="https://linkmeup.ru/sdsm">UFSR</a> ).  With enterprise networks, of course, the situation is somewhat different. <br><br>  Network focused image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/133/b41/5f8/133b415f8b32264e2fa877f4a4139267.png" width="800"><br><br><hr><br><br><h1>  Underlay </h1><br>  Underlay is a physical network: hardware switches and cables.  Devices in the underlay know how to get to the physical machines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/d04/880/117d04880232fa2c00ef303cf5f059a0.png" width="800"><br><br>  It relies on standard protocols and technologies.  Not least because hardware devices still work on proprietary software that does not allow chip programming or implementation of their protocols, respectively, compatibility with other vendors and standardization are needed. <br><blockquote>  But someone like Google can afford the development of its own switches and the rejection of generally accepted protocols.  But LAN_DC is not Google. <br></blockquote>  Underlay changes relatively rarely because its task is basic IP connectivity between physical machines.  Underlay knows nothing about the services running on top of him, clients, tenants - he only needs to deliver the package from one machine to another. <br>  Underlay can be for example: <br><br><ul><li>  IPv4 + OSPF </li><li>  IPv6 + ISIS + BGP + L3VPN </li><li>  L2 + TRILL </li><li>  L2 + STP </li></ul><br>  The Underlay network is configured in the classic way: CLI / GUI / NETCONF. <br><br>  Manually, scripts, proprietary utilities. <br><br>  The next article of the cycle will be devoted to the underlay in more detail. <br><br><hr><br><h1>  Overlay </h1><br>  Overlay - a virtual network of tunnels stretched over the Underlay, it allows the VMs of one client to communicate with each other, while providing isolation from other clients. <br><br>  Client data is encapsulated in any tunneling headers for transmission over a common network. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/3ed/8d2/9c13ed8d2e6cec8f1b9fe500660f1c47.png" width="800"><br><br>  So VMs of one client (one service) can communicate with each other through Overlay, without even knowing what path the package actually goes. <br><br>  Overlay can be for example the same as I mentioned above: <br><br><ul><li>  GRE tunnel </li><li>  VXLAN </li><li>  EVPN </li><li>  L3VPN </li><li>  GENEVE </li></ul><br>  An overlay network is usually configured and maintained through a central controller.  From it, the configuration, Control Plane and Data Plane are delivered to devices that route and encapsulate client traffic.  <a href="https://habr.com/ru/post/458622/">Below</a> we analyze it in examples. <br><br>  <b>Yes, this is pure SDN.</b> <br><br>  There are two fundamentally different approaches to the organization of Overlay-network: <br><br><ol><li>  Overlay with ToR'a </li><li>  Overlay from host </li></ol><br><br><h2>  Overlay with ToR'a </h2><br>  Overlay can begin on an access switch (ToR) that is in a rack, as is the case, for example, in the case of a VXLAN fabric. <br><br>  This is a time-tested mechanism on the ISP networks and all network equipment vendors support it. <br><br>  However, in this case, the ToR switch must be able to separate different services, respectively, and the network administrator must cooperate to a certain extent with the administrators of the virtual machines and make changes (albeit automatically) in the device configuration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/0a1/87d/5e30a187dd5796e2a4232cb4e9db0b97.png" width="600"><br><br>  Here I will refer the reader to an article on <a href="https://habr.com/ru/post/344326/">VxLAN on the habr of</a> our old friend <a href="https://habr.com/ru/users/bormoglotx/">@bormoglotx</a> . <br>  This <a href="https://www.enog.org/wp-content/uploads/presentations/enog-16/18-Scaleway-P14-fabric-ENOG16.pdf">presentation with ENOG</a> describes in detail the approaches to building a DC network with an EVPN VXLAN factory. <br><br>  And for a more complete immersion in reality, you can read tsiskinu book <a href="https://www.cisco.com/c/dam/en/us/td/docs/switches/datacenter/nexus9000/sw/vxlan_evpn/VXLAN_EVPN.pdf">A Modern, Open, and Scalable Fabric: VXLAN EVPN</a> . <br><blockquote>  I note that VXLAN is only a method of encapsulation and tunnel termination can occur not on ToR'e, but on a host, as it happens in the case of OpenStack, for example. <br><br>  However, the VXLAN factory where overlay starts at ToR is one of the well-established overlay network designs. <br></blockquote><br><h2>  Overlay from host </h2><br>  Another approach is to start and terminate tunnels on end hosts. <br>  In this case, the network (Underlay) remains as simple and static as possible. <br>  And the host itself does all the necessary encapsulations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d7/400/c60/5d7400c60036ba0b6666bb0f733c172f.png" width="600"><br><br>  This will require, of course, run a special application on the hosts, but it is worth it. <br><br>  First, it is easier to start the client on a linux machine or, let's say, in general, while the switch will most likely have to access proprietary SDN solutions for now, which kills the idea of ‚Äã‚Äãmulti-vendor. <br><br>  Secondly, the ToR switch in this case can be left as simple as possible, both from the point of view of the Control Plane and the Data Plane.  Indeed, it doesn‚Äôt need to communicate with the SDN controller, and it is enough to store the network / ARPs of all connected clients ‚Äî also, you only need to know the IP address of the physical machine, which greatly simplifies the switching / routing tables. <br><br><hr><br>  In the ADSM series, I choose the overlay approach from the host - then we only talk about it and we will not return to the VXLAN factory. <br><br><hr><br>  The easiest way to look at examples.  And as an experimental we will take the OpenSource SDN platform OpenContrail, now known as <a href="https://tungsten.io/">Tungsten Fabric</a> . <br><blockquote>  At the end of the article I will give some thoughts on the analogy with OpenFlow and OpenvSwitch. <br></blockquote><br><h2>  On the example of Tungsten Fabric </h2><br>  Each physical machine has a <b>vRouter</b> - a virtual router that knows about the networks connected to it and which clients they belong to - in fact - a PE router.  For each client, it maintains an isolated routing table (read VRF).  And actually vRouter does Overlay'no tunneling. <br><br>  A little more about vRouter - at the end of the article. <br><br>  Each VM located on the hypervisor connects to the vRouter of this machine via the <a href="https://en.wikipedia.org/wiki/TUN/TAP">TAP interface</a> . <br><br>  <b>TAP</b> - Terminal Access Point - a virtual interface in the linux kernel that allows network interaction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/fc4/20f/7a2fc420f086b1588236ddc7d4f1c97e.png" width="500"><br><br>  If there are several networks behind vRouter, then for each of them a virtual interface is created, to which an IP address is assigned - it will be the address of the default gateway. <br>  All networks of one client are placed in one <b>VRF</b> (one table), different - in different. <br>  <i>I will make a reservation here that everything is not so simple, and send an inquisitive reader to the end of the article</i> . <br><br>  In order for vRouters to communicate with each other, and accordingly the VMs behind them, they exchange routing information via an <b>SDN controller</b> . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3cd/6c5/c73/3cd6c5c7399e314b779a4b9ecf18e17e.png" width="900"></a> <br><br>  To get to the outside world, there is an exit point from the matrix ‚Äî the <b>VNGW</b> virtual network gateway ( <i>my term</i> ). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d8/75f/a55/4d875fa552a4f144fb9338fa0093235c.png" width="900"></a> <br><br><hr><br>  Now consider the examples of communications - and there will be clarity. <br><br><br><h3>  Communication within a single physical machine </h3><br>  VM0 wants to send a packet to VM2.  Suppose for now that this is a VM of one client. <br><br><h4>  Data plane </h4><br><ol><li>  VM-0 has a default route to its eth0 interface.  The package is sent there. <br>  This eth0 interface is actually virtually connected to the vRouter virtual router via the tap0 interface tap0. </li><li>  vRouter analyzes which interface the packet came to, that is, which client (VRF) it belongs to, checks the address of the recipient with the routing table of this client. </li><li>  Finding that the recipient is on the same machine after another port, vRouter simply sends the packet to it without any additional headers - in this case, there is already an ARP entry on vRouter. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6be/2e5/1f0/6be2e51f0530a6fc7e9f2c6370c6e0d2.png" width="700"><br><br>  The packet in this case does not fall into the physical network - it was routed inside vRouter. <br><br><br><h4>  Control plane </h4><br>  When the virtual machine starts, the hypervisor tells it: <br><br><ul><li>  Her own IP address. </li><li>  The default route is via the vRouter's IP address on this network. </li></ul><br>  vRouter through a special API hypervisor reports: <br><br><ul><li>  What you need to create a virtual interface. </li><li>  What it (VM) needs to create a Virtual Network. </li><li>  To which VRF it (VN) to tie. </li><li>  Static ARP entry for this VM ‚Äî what interface is its IP address and what MAC address is it associated with. </li></ul><br><blockquote>  And again, the real interaction procedure is simplified in order to understand the concept. <br></blockquote><img src="https://habrastorage.org/getpro/habr/post_images/e14/f52/d49/e14f52d4935eb6d5fd5213c1bd3baeec.png" width="800"><br><br>  Thus, all VMs of a single client on a given machine vRouter sees how directly connected networks can be routed between them. <br><br><hr><br>  But VM0 and VM1 belong to different clients, respectively, are in different tables vRouter'a. <br><br>  Whether they can communicate directly with each other depends on the vRouter settings and network design. <br>  For example, if both clients' VMs use public addresses, or NAT occurs at the vRouter itself, then direct routing to the vRouter can be done. <br><br>  In the opposite situation, it is possible to intersect address spaces - you need to go through a NAT server to get a public address - this looks like going out to external networks, which are described below. <br><br><hr><br><br><h3>  Communication between VMs located on different physical machines. </h3><br><h4>  Data plane </h4><br><ol><li>  The beginning is exactly the same: VM-0 sends a packet with a VM-7 destination (172.17.3.2) in its default. </li><li>  vRouter receives it and this time sees that the addressee is on another machine and is available through the Tunnel0 tunnel. </li><li>  First, he hangs the MPLS tag, which identifies the remote interface, so that on the reverse side of the vRouter can determine where to put this packet without additional lukapov. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/322/f94/328/322f943287f0e8956acc02654bdae580.png" width="1000"></a> <br></li><li>  Tunnel0 has source 10.0.0.2, recipient: 10.0.1.2. <br>  vRouter adds GRE (or UDP) headers and a new IP to the original packet. </li><li>  In the vRouter routing table there is a default route through the address ToR1 10.0.0.1.  There and sends. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9a/696/b8a/b9a696b8a0e97aba81107a3ad112f001.png" width="700"><br><br></li><li>  ToR1 as a member of the Underlay network knows (for example, via OSPF) how to get to 10.0.1.2, and sends the packet along the route.  Please note that ECMP is enabled here.  In the illustration, two nextopes and different streams will be decomposed into them according to a hash.  In the case of a real factory, there will most likely be 4 nextopes. <br><br>  At the same time, he does not need to know what is under the external IP header.  That is, in fact, under the IP there can be a sandwich from IPv6 over MPLS over Ethernet over MPLS over GRE over over over Greco. </li><li>  Accordingly, on the receiving side, vRouter removes the GRE and, using the MPLS tag, understands which interface this packet should be sent to, strips it and sends it to its original form to the recipient. </li></ol><br><br><h4>  Control plane </h4><br>  When you start the machine, everything happens as described above. <br><br>  And plus the following: <br><br><ul><li>  For each client, vRouter allocates an MPLS tag.  This is the service label L3VPN, according to which customers will be divided within the same physical machine. <br><blockquote>  In fact, the MPLS-tag is always highlighted by vRouter, because it is not known in advance that the machine will interact only with other machines behind the same vRouter, and this is most likely not the case. <br></blockquote></li><li>  vRouter establishes a connection with the SDN controller via BGP protocol (or similar to it ‚Äî in the case of TF, this is XMPP 0_o). </li><li>  Through this session, vRouter informs the SDN controller the routes to the connected networks: <br><br><ul><li>  Network address </li><li>  Encapsulation Method (MPLSoGRE, MPLSoUDP, VXLAN) </li><li>  MPLS client label </li><li>  Your IP address as nexthop </li></ul><br></li><li>  The SDN controller receives such routes from all connected vRouters, and reflects them to others.  That is, he stands Route Reflector'om. </li></ul><br>  The same thing happens in the opposite direction. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e3a/b17/5aae3ab177a4ed58279e4c767618f770.png" width="1000"></a> <br><br>  Overlay can change at least every minute.  Something like this happens in public clouds when customers regularly start and shut down their virtual machines. <br><br>  The central controller assumes all the difficulties with maintaining the configuration and monitoring of the switching / routing tables on the vRouter. <br><br>  Roughly speaking, the controller is locked with all vRouters via BGP (or a protocol similar to it) and simply sends routing information.  BGP, for example, already has an Address-Family to transmit the <a href="https://tools.ietf.org/html/rfc4023">MPLS-in-GRE</a> or <a href="https://tools.ietf.org/html/rfc7510">MPLS-in-UDP</a> encapsulation method. <br><br>  At the same time, the configuration of the Underlay-network does not change in any way, which, by the way, is much more difficult to automate by an order of magnitude, and easier to break with an awkward movement. <br><br><hr><br><br><h3>  Exit to the outside world </h3><br>  Somewhere the simulation must end, and from the virtual world you need to go to the real one.  And you need a <s>payphone</s> gateway. <br><br>  Practice two approaches: <br><br><ol><li>  Put a hardware router. </li><li>  Any appliance is launched that implements the functions of the router (yes, after SDN, we also ran into VNF).  Let's call it a virtual gateway. </li></ol><br><blockquote>  The advantage of the second approach in cheap horizontal scalability - not enough power - launched another virtual machine with a gateway.  On any physical machine, without the need to search for free racks, units, power supply, buy the piece of hardware itself, carry it, install, switch, tune, and then change the faulty components in it. <br><br>  The drawbacks of the virtual gateway are that the unit of the physical router is still orders of magnitude more powerful than the multi-core virtual machine, and its software, tailored to its hardware basis, is much more stable ( <i>no</i> ).  It is difficult to deny the fact that the hardware and software complex just works, requiring only configuration, while launching and servicing the virtual gateway is an exercise for powerful engineers. <br></blockquote>  With one foot, the gateway looks into the Overlay virtual network, like a regular Virtual Machine, and can interact with all other VMs.  At the same time, it can terminate the networks of all clients on itself and, accordingly, carry out routing between them. <br><br>  With the other leg, the gateway is already looking into the backbone network and knows how to get on the Internet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/930/3d2/d1a/9303d2d1a6777510d3bc87bc19349da2.png" width="800"><br><br><br><h4>  Data plane </h4><br>  That is, the process looks like this: <br><br><ol><li>  VM-0, having defaulted to the same vRouter, sends a packet with the addressee in the outside world (185.147.83.177) to the eth0 interface. </li><li>  vRouter receives this packet and makes a destination address in the routing table ‚Äî finds the default route through the VNGW1 gateway through Tunnel 1. <br>  He also sees that this is a GRE tunnel with SIP 10.0.0.2 and DIP 10.0.255.2, and you also need to first hang the MPLS tag of this client that VNGW1 expects. <br></li><li>  vRouter packs the original packet in MPLS, GRE, and new IP headers and sends them to ToR1 10.0.0.1 by default. </li><li>  Anderlee network delivers the packet to the VNGW1 gateway. </li><li>  The VNGW1 gateway removes the GRE and MPLS tunneling headers, sees the destination address, consults its routing table, and understands that it is directed to the Internet ‚Äî that is, via Full View or Default.  If necessary, produces NAT-broadcast. </li><li>  From VNGW to a border, there can be a regular IP network, which is unlikely. <br>  There may be a classic MPLS network (IGP + LDP / RSVP TE), it may be back factory with a BGP LU or a GRE tunnel from VNGW to a border through an IP network. <br>  Be that as it may, VNGW1 performs the necessary encapsulations and sends the original packet towards the border. </li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9e/49b/c01/d9e49bc0141200d07b7dbd6710495c83.png" width="1000"></a> <br><br>  Traffic in the opposite direction passes the same steps in the opposite order. <br><br><ol><li>  Border drops package to VNGW1 </li><li>  He undresses him, looks at the recipient's address and sees that he is available through the Tunnel1 tunnel (MPLSoGRE or MPLSoUDP). </li><li>  Accordingly, it hangs the MPLS tag, the GRE / UDP header and the new IP and sends it to its ToR3 10.0.255.1. <br>  The destination address of the tunnel is the IP address of the vRouter, followed by the target VM - 10.0.0.2. </li><li>  Anderley network delivers the package to the desired vRouter'a. </li><li>  The target vRouter removes GRE / UDP, identifies the interface by MPLS tag and sends a bare IP packet to its TAP interface associated with the eth0 VM. </li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f49/892/d4df4989216a42c06343ba883b8f5db2.png" width="1000"></a> <br><br><br><h4>  Control plane </h4><br>  VNGW1 establishes a BGP neighborhood with an SDN controller, from which it receives all routing information about clients: which IP address (vRouter'om) which client is located, and which MPLS tag is it identified. <br><br>  Similarly, he himself tells the SDN controller the default route with the label of this client, indicating itself as nexthop.  And then this default comes to vRouters. <br><br>  On VNGW, route aggregation or NAT translation usually occurs. <br><br>  And in the other direction in the session with boarders or Route Reflectors, he gives exactly this aggregated route.  And from them gets the default route or Full-View, or something else. <br><br>  In terms of encapsulation and traffic exchange, VNGW is no different from vRouter. <br>  If you expand the area a bit, then you can add other network devices to VNGW and vRouters, such as firewalls, traffic cleaning or traffic enrichment farms, IPS, and so on. <br><br>  And with the help of sequential creation of the VRF and the correct announcement of the routes, you can force traffic to loop as you like, which is called Service Chaining. <br><br>  That is, here the SDN controller acts as a Route-Reflector between VNGW, vRouters and other network devices. <br><br>  But in fact, the controller also releases information about ACL and PBR (Policy Based Routing), forcing individual traffic flows to go differently than the route tells them. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/917/7f6/97a/9177f697a1ff4a7560153286ac04f287.png" width="1000"></a> <br><br><hr><br><br><h1>  FAQ </h1><br><br>  <b>Why do you always make a GRE / UDP remark?</b> <br><br>  Well, in general, it can be said that it is specific to Tungsten Fabric - you can not take it into account at all. <br><br>  But if you take, then TF itself, while still being OpenContrail, supported both encapsulations: MPLS in GRE and MPLS in UDP. <br><br>  UDP is good because in the Source Port in its header it is very easy to encode a hash function from the original IP + Proto + Port, which will allow balancing. <br><br>  In the case of GRE, alas, there are only external headers IP and GRE, which are the same for all encapsulated traffic and we are not talking about balancing - few people can look so deep inside the packet. <br><br>  Until some time, routers, if they knew how to use dynamic tunnels, then only in MPLSoGRE, and only very recently, did they learn in MPLSoUDP.  Therefore, you always have to make a remark about the possibility of two different encapsulations. <br><br>  In fairness, it is worth noting that TF fully supports L2 connectivity using VXLAN. <br><br><br>  <b>You promised to draw parallels with OpenFlow.</b> <br>  They are indeed asking for it.  vSwitch in the same OpenStack does very similar things using VXLAN, which, by the way, also has a UDP header. <br><br>  In Data Plane, they work about the same, the Control Plane is significantly different.  Tungsten Fabric uses XMPP to deliver route information to the vRouter, while OpenStack is running Openflow. <br><br><br>  <b>Can I have a little more about vRouter?</b> <br>  It is divided into two parts: vRouter Agent and vRouter Forwarder. <br><br>  The first is launched in the User Space of the host OS and communicates with the SDN controller, exchanging information about routes, VRF and ACL. <br><br>  The second implements Data Plane - usually in Kernel Space, but it can also run on SmartNICs - network cards with a CPU and a separate programmable switching chip, which allows you to remove the load from the host‚Äôs CPU and make the network faster and more predictable. <br><br>  Another possible scenario is when vRouter is a DPDK application in User Space. <br><br>  vRouter Agent down the settings on the vRouter Forwarder. <br><br><br>  <b>What is the virtual network?</b> <br>  I mentioned at the beginning of the VRF article that they say each tenant is tied to its own VRF.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if this was sufficient for a superficial understanding of the work of the overlay network, then the next iteration should be clarified. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, in the virtualization mechanisms, the essence of the Virtual Network (which can be considered as a proper name) is introduced separately from clients / tenants / virtual machines ‚Äî quite an independent thing. And this Virtual Network through the interfaces can already be connected to one tenant, to another, to two, and at least where. So, for example, Service Chaining is implemented, when traffic needs to be passed through certain nodes in the right sequence, simply creating and setting up a Virtual Network in the correct sequence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, as such, there is no direct correspondence between the Virtual Network and the tenant.</font></font><br><br><hr><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very superficial description of the virtual network with an overlay from the host and an SDN controller. But whatever virtualization platform you take today, it will work in a similar way, be it VMWare, ACI, OpenStack, CloudStack, Tungsten Fabric or Juniper Contrail. They will differ in the types of encapsulations and headers, protocols for delivering information to end network devices, but the principle of a software-configured overlay network running on a relatively simple and static underlay network will remain the same.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be said that the domain of creating a private cloud for today, SDN based on the overlay network has won. </font><font style="vertical-align: inherit;">However, this does not mean that Openflow has no place in the modern world - it is used in OpenStacke and in the same VMWare NSX, as far as I know, it is used by Google to configure the underlay network. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below, I gave references to more detailed materials if I want to study the issue further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what about our Underlay? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in general, nothing. </font><font style="vertical-align: inherit;">He did not change all the way. </font><font style="vertical-align: inherit;">All he needs to do in the case of an overlay from the host is to update routes and ARPs as vRouter / VNGW appears and disappears and to drag packets between them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's formulate a list of requirements for the Underlay network.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To be able to use some kind of routing protocol, in our situation - BGP. </font></font></li><li>   ,   ,     - . </li><li>  ECMP ‚Äî   . </li><li>   QoS,     ,  ECN. </li><li>  NETCONF ‚Äî   . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I devoted very little time to the work of the Underlay-network itself. </font><font style="vertical-align: inherit;">This is because later in the series I‚Äôll focus on her, and we will only touch Overlay in passing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, I severely limit us all, using as an example the network of DCs built in the Kloza factory with pure IP routing and overlay from the host. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, I am sure that any network that has a design can be described in formal terms and automated. </font><font style="vertical-align: inherit;">It's just that I aim here to understand the approaches to automation, and not to confuse everyone in general, solving the problem in general. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the framework of ADSM, Roman Gorge and I plan to publish a separate issue about the virtualization of computing power and its interaction with network virtualization. </font><font style="vertical-align: inherit;">Stay in touch.</font></font><br><br><br><h1>  useful links </h1><br><ul><li> <a href="https://tungstenfabric.github.io/website/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tungsten Fabric Archvitecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://youtu.be/Kr6WIYPts8I%3Ft%3D3157">about:cloud</a> . 6   .,         TF. </li><li> <a href="https://docs.openvswitch.org/en/latest/intro/what-is-ovs/">What Is Open vSwitch?</a> </li><li> <a href="https://habr.com/ru/post/344326/">  VxLAN</a> . </li><li> <a href="https://tools.ietf.org/html/rfc7348">RFC 7348. Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks. <br></a> </li><li> <a href="https://www.enog.org/wp-content/uploads/presentations/enog-16/18-Scaleway-P14-fabric-ENOG16.pdf">Scaleway approach to VXLAN EVPN Fabric</a> .      ,  Underlay, Overlay,   -  . </li></ul><br><h5>  </h5><br><ul><li> <a href="https://www.linkedin.com/in/roman-gorge-2b15896b/%3ForiginalSubdomain%3Dse"> </a> ‚Äî    linkmeup,       .    .            . </li><li> <a href="https://www.alexander-shalimov.com/"> </a> ‚Äî         .    . </li><li> <a href="https://www.linkedin.com/in/valentine-sinitsyn-b8b3a23a/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valentina Sinitsyna</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - my colleague and expert in the field of Tungsten Fabric. </font><font style="vertical-align: inherit;">For comments and edits.</font></font></li><li> <a href="http://illustrators.ru/users/rabbits_manufactory"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artem Chernobay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - linkmeup illustrator. </font><font style="vertical-align: inherit;">For KDPV.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Limonov. </font><font style="vertical-align: inherit;">For meme "automato".</font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/458622/">https://habr.com/ru/post/458622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../4586/index.html">"Soup" explains its policy</a></li>
<li><a href="../45860/index.html">Website creation in Veliky Novgorod and other provincial cities</a></li>
<li><a href="../458604/index.html">Why the two largest electronics manufacturers joined forces in a new GPU project</a></li>
<li><a href="../458606/index.html">Run OpenVPN in Docker in 2 seconds</a></li>
<li><a href="../458614/index.html">Creating a React-Hook usePosition () to get and track browser coordinates</a></li>
<li><a href="../458624/index.html">How we learned to draw texts on Canvas</a></li>
<li><a href="../458626/index.html">StealthWatch: basic concepts and minimum requirements. Part 1</a></li>
<li><a href="../45863/index.html">Mini photo studio at home</a></li>
<li><a href="../458630/index.html">A small history of developing your game on pure Windows Forms + –° # in my 16 years</a></li>
<li><a href="../458634/index.html">‚ÄúDÃ∂oÃ∂nÃ∂'Ã∂t be evil‚Äù or what Facebook is hiding from us</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>