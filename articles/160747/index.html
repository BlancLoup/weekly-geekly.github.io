<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Balancing Accuracy and Performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are several important aspects that must be taken into account when creating an application that performs any calculations, or more precisely, fl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Balancing Accuracy and Performance</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/086/94d/c82/08694dc82a3ca8854fc88d49995648ed.jpg"><br>  There are several important aspects that must be taken into account when creating an application that performs any calculations, or more precisely, floating point operations.  What do we expect and plan to get from such applications (in most cases, scientific)?  First of all, we are interested in the accuracy of calculations - the result should be closest to the ‚Äúcorrect‚Äù one.  The other side of the coin is the stability of the results and portability of the application.  It is important for us to be able to get the same, consistently repeating from start to start result, and on different machines / architectures.  And last but not least, the point is performance.  How fast will our application run with all this, and when will we get the results of our calculations? <br><br>  The Intel compiler has a set of options that are responsible for controlling the optimization of floating-point calculations.  Consider the most interesting key ‚Äìfp-model, which, judging by the description in the documentation, controls the semantics of calculations over floating point numbers.  By the way, it is worth noting that there are similar keys in other compilers, not only Intel's, we will also talk about this.  In fact, with the help of this key we will be able to control the balance between performance and accuracy of calculations.  Possible values ‚Äã‚Äãthat can be specified in the option ‚Äìfp-model: <i>precise, fast [= 1 | 2], strict, source, [no-] except (Linux *) or except [-] (Windows *)</i> .  Let's see what they give when compiling our code. <br><a name="habracut"></a><br>  All these keys allow, in the end, to control the following compiler rules and answer the corresponding questions: <br><br>  <b>Safety of values ‚Äã‚Äã(value safety)</b> <br>  Can the compiler produce transformations that can change the result? <br>  For example, in safe mode, the compiler will not optimize the x / x expression to 1.0, because at runtime the value may be 0 or NaN.  Also, changing the sequence of calculations (in particular, the law of associativity or distributivity) can be prohibited. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Accuracy in calculating expressions (floating-point expression evaluation)</b> <br>  How should the compiler round off intermediate results (which accuracy should be chosen)? <br><br>  <b>Access to environment (floating-point environment access)</b> <br>  Can the application change the environment settings (for example, rounding rules) at run time?  In general, the FP environment is a set of registers that controls the operation of the FPU (Floating-point unit, floating-point co-processor).  It includes control of rounding mode, exceptions, working with non-normalized numbers (dropping to 0), exception masks and other functions.  With default keys it is assumed that the application does not have access to the FPU environment. <br><br>  <b>The operation of multiplication-addition (contractions)</b> <br>  Should the compiler generate multiply-add (Fsed multiply-add, FMA) operations, which allow to combine multiplication and addition in one instruction (no intermediate rounding up to N bits is required after multiplication before addition, unlike a pair of separate instructions)?  Addition is performed on a more accurate internal representation, and only after it rounding occurs.  This allows you to increase accuracy. <br><br>  <b>Precise floating point exceptions</b> <br>  Does the compiler take into account the possibility of exceptions when working with floating point operations? <br>  Under certain conditions (for example, division by zero), an FPU may generate an exception.  By default, exception semantics is disabled.  It is worth noting that allowing exceptions and connecting exception semantics is not the same thing.  In the latter case, the compiler takes into account the fact that operations with "floating" numbers can generate an exception.  By the way, since the FPU is a separate part of the processor, an exception will not be generated immediately, but only when the CPU reaches (it checks for FPU exceptions) the following instruction over floating point numbers. <br><br>  So, these 5 basic questions can be controlled by the compiler options as follows: <br><table><tbody><tr><td>  <b>option</b> </td><td>  <b>security</b> </td><td>  <b>accuracy</b> </td><td>  <b>Fma</b> </td><td>  <b>environment</b> </td><td>  <b>exceptions</b> </td></tr><tr><td>  precise <br>  source <br></td><td>  varies </td><td>  code <br>  code </td><td>  Yes </td><td>  not </td><td>  not </td></tr><tr><td>  strict </td><td>  varies </td><td>  code </td><td>  not </td><td>  Yes </td><td>  Yes </td></tr><tr><td>  fast = 1 <br>  (default) <br></td><td>  insecure </td><td>  unknown </td><td>  Yes </td><td>  not </td><td>  not </td></tr><tr><td>  fast = 2 </td><td>  insecure </td><td>  unknown </td><td>  Yes </td><td>  not </td><td>  not </td></tr><tr><td>  except <br>  except- <br></td><td>  does not change </td><td>  code <br>  code </td><td>  does not change </td><td>  does not change </td><td>  Yes <br>  not </td></tr></tbody></table><br>  Let's say we figured out what controls these options.  Let's use examples to try to understand how to use them and for what. <br><br>  For example, take the Kahan summation algorithm, which allows for more accurate results when summing up floating point numbers. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KahanSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum=<span class="hljs-number"><span class="hljs-number">0</span></span>, Y, T; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> C=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//A running compensation for lost low-order bits. for (int i=0; i&lt;n; i++) { Y = A[i] - C; //So far, so good: C is zero. T = sum + Y; //Alas, sum is big, Y small, so low-order digits of Y are lost. C = T - sum - Y; //(T - sum) recovers the high-order part of Y; //subtracting y recovers -(low part of y) sum = T; //Next time around, the lost low part will be added to y in a fresh attempt. } return sum; }</span></span></code> </pre> <br>  This algorithm will be very sensitive to possible optimizations by the compiler.  If we apply algebraic transformations that the compiler can easily perform for a given model fast, we get the following: <br><br>  Since C is out of cycle and is a constant equal to 0, then <br><br><pre> <code class="cpp hljs">Y = A[i] - C ==&gt; Y = A[i] T = sum + Y ==&gt; T = sum + A[i] sum = T ==&gt; sum = sum + A[i]</code> </pre><br>  As a result, after optimization, we get the usual summation in the cycle, and this is far from what we expected.  Therefore, it is important to prohibit the compiler to carry out such permutations and optimization, by setting, for example, the fp-model precise flag. <br><br>  By the way, various combinations of these options are interesting, because there is a feeling that precise and source do the same thing.  All models are divided into 3 groups: <br><br>  ‚Ä¢ A: precise, fast, strict <br>  ‚Ä¢ B: source <br>  ‚Ä¢ C: except <br><br>  Accordingly, they can be ‚Äúmixed‚Äù, but with certain reservations: <br>  ‚Ä¢ You cannot use fast and except together, and because fast is the default model, you cannot add except without other options from groups A and B. <br>  ‚Ä¢ You can specify only one model from group A and one from group B. If you specify more than one, the last one in the compilation line (the one to the right) will be used. <br>  ‚Ä¢ If the except is specified more than once, the last option will also be used. <br><br>  Therefore, in the general case, precise and source will set the same model for working with floating-point numbers.  But if you set fast and source together, then source will set the accuracy with which intermediate results should be rounded (according to the name, the accuracy used in the code will be used). <br><br>  What about other compilers?  There everything seems to be the same and the meaning remains the same - with the help of keys, the same 5 basic rules of the compiler are controlled when working with floating-point numbers, only the keys are different by default.  For example, if you take the Microsoft compiler, then even the names of the options and models there are the same as those of the Intel compiler.  For example, the fp: precise flag, which is the default.  By the way, the emphasis there (by default) is still on the safety of computations, while Intel has an emphasis on performance (key fast = 1). <br>  But there are differences in the behavior of the compiler - with the precise option, the Microsoft compiler will use the maximum precision (extended), that is, the code <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x; ... x = a*b + c*d;</code> </pre><br>  will be interpreted by the compiler like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x; ... <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> tmp1 = a*b; <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> tmp2 = c*d; <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> tmp3 = tmp1+tmp2; x = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) tmp3;</code> </pre><br>  Of course, the nuances are significant, but if you understand what to control and how, you can easily switch to another compiler, the main thing is that it gives the developer this control. <br><br>  By the way, MSDN has an excellent <a href="http://msdn.microsoft.com/en-us/library/aa289157(v%3Dvs.71).aspx">article</a> on this topic, which describes in detail the behavior of the Microsoft compiler, and discusses many examples. <br><br>  We will return to one more example, this time in Fortran (I mentioned the scientific topic at the beginning): <br><br><pre> <code class="hljs">REAL T0, T1, T2; ... T0 = 4.0E + 0.1E + T1 + T2</code> </pre><br>  The question is, how will this expression be considered with the ‚Äìfp-model fast key?  Based on the label presented above, it can be assumed that addition can be performed in any order, single (single), double (double), or extended double (extended) accuracy will be used when calculating intermediate results, while the constant value can be calculated in advance. <br><br>  For example, the compiler can interpret our code as follows: <br><br><pre> <code class="hljs">REAL T0, T1, T2; ... T0 = (T1 + T2) + 4.1E;</code> </pre><br>  Or <br><br><pre> <code class="hljs">REAL T0, T1, T2; ... T0 = (T1 + 4.1E) + T2;</code> </pre><br>  If the -fp-model source option is set (or -fp-model precise, they are equivalent in the case of separate use), addition will be performed strictly in the order specified in the code, single precision will be used (as in the code), the constant can be calculated in advance, using the default rounding: <br><br><pre> <code class="hljs">REAL T0, T1, T2; ... T0 = ((4.1E + T1) + T2);</code> </pre><br>  Well, the most "hard" level of control over accuracy -fp-model strict. <br>  In this case, we get something like this: <br><br><pre> <code class="hljs">REAL T0, T1, T2; ... T0 = REAL ((((REAL)4.0E + (REAL)0.1E) + (REAL)T1) + (REAL)T2);</code> </pre><br>  As with all models other than fast, the precision specified in the code is used (single in this case).  The constant is not calculated in advance because we do not know which rounding mode will be set during the execution of the application. <br><br>  Actually, this is all that I wanted to talk about in this post.  The topic of working with floating-point numbers is very extensive, and there is something else to tell about ... let's say, besides the considered options, there are also flags prec-div, prec-sqrt, -ftz, -assume: protect_parens, IEEE 754-2008 standard, which supported in many compilers and in which there is a lot of curious things ... so with proper interest, we will continue this conversation. </div><p>Source: <a href="https://habr.com/ru/post/160747/">https://habr.com/ru/post/160747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160733/index.html">Cisco UCS unboxing</a></li>
<li><a href="../160735/index.html">About components and interfaces</a></li>
<li><a href="../160739/index.html">Using WinAPI on Surface</a></li>
<li><a href="../160743/index.html">Kickstarter vs white labels</a></li>
<li><a href="../160745/index.html">Freescale i.MX6</a></li>
<li><a href="../160749/index.html">How search tips save human life every day</a></li>
<li><a href="../160751/index.html">Yandex money began to carry out part of the Internet payments on the plastic card of the poison as withdrawals from an ATM</a></li>
<li><a href="../160753/index.html">Microsoft launches Google-criticized Bing ad campaign</a></li>
<li><a href="../160755/index.html">AWS: IAM Roles for Servers</a></li>
<li><a href="../160757/index.html">In Syria, turned off the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>