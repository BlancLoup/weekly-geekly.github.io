<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compression without loss of information. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="First part. 

 In the second part, arithmetic coding and the Burrows-Wheeler transformation will be considered (the latter is often undeservedly forgo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compression without loss of information. Part two</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/142242">First part.</a> <br><br>  In the second part, arithmetic coding and the Burrows-Wheeler transformation will be considered (the latter is often undeservedly forgotten in many articles).  I will not consider the LZ family of algorithms, since there were already quite good articles about them in Habr√©. <br><br>  So, let's start with arithmetic coding - in my opinion, one of the most elegant (in terms of the idea) compression methods. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Introduction </h4><br>  In the first part, we looked at Huffman coding.  Despite the fact that this is an excellent, time-tested algorithm, it (like any others) is not without its drawbacks.  We illustrate the weak point of the Huffman algorithm with an example.  When coding by the Huffman method, the relative frequency of the appearance of characters in the stream approaches frequencies that are multiple of a power of two.  By the Shannon theorem, let me remind you, the best compression will be achieved if each symbol with frequency f is encoded with -log <sub>2</sub> f bits.  Let's build a small chart (I apologize in advance, since I am not strong in building beautiful charts). <br><img src="https://habrastorage.org/storage2/7e2/fbb/6ec/7e2fbb6ec0c651d40bfb09fc77a89006.png"><br><br>  As you can see, in cases where the relative frequencies are not powers of two, the algorithm clearly loses its effectiveness.  It is easy to check on a simple example of a stream of two symbols <i>a</i> and <i>b</i> with frequencies 253/256 and 3/256, respectively.  In this case, ideally we will need <img src="https://habrastorage.org/storage2/b27/94d/11b/b2794d11b7ec64825c779443d55ae406.png">  that is, 24 bits.  At the same time, the Huffman method encodes these characters with codes 0 and 1, respectively, and the message will take 256 bits, which, of course, is less than 256 bytes of the original message (remember, we assume that initially each character is in byte size), but still 10 times less than optimum. <br><br>  So, we proceed to the consideration of arithmetic coding, which will allow us to get the best result. <br><br><h4>  Arithmetic coding </h4><br><br>  Like the Huffman method, arithmetic coding is an entropy compression method.  Encoded data are presented in the form of a fraction, which is selected so that the text can be presented most compactly.  What does this really mean? <br><br>  Consider the construction of a fraction on the interval [0,1) (this interval is chosen for convenience of calculation), and for example, the input data in the form of the word "box".  Our task will be to divide the initial interval into subintervals with lengths equal to the probabilities of the appearance of characters. <br><br>  Create a probability table for our input text: <br><br><table><tbody><tr><td>  Symbol </td><td>  Frequency </td><td>  Probability </td><td>  Range </td></tr><tr><td>  ABOUT </td><td>  2 </td><td>  0.4 </td><td>  [0.0, 0.4) </td></tr><tr><td>  TO </td><td>  one </td><td>  0.2 </td><td>  [0.4, 0.6) </td></tr><tr><td>  R </td><td>  one </td><td>  0.2 </td><td>  [0.6, 0.8) </td></tr><tr><td>  B </td><td>  one </td><td>  0.2 </td><td>  [0.8, 1.0) </td></tr></tbody></table><br><br>  Here, "Frequency" means the number of occurrences of a character in the input stream. <br><br>  We assume that these quantities are known both for encoding and decoding.  When encoding the first character of the sequence (in our case, ‚Äú <b>K</b> orob‚Äù), the whole range from 0 to 1 is used. This range must be divided into segments according to the table. <br>  The interval corresponding to the current encoded symbol is taken as the working interval.  The length of this interval is proportional to the frequency of occurrence of the symbol in the stream. <br>  After finding the interval for the current symbol, this interval is extended, and in turn is divided in accordance with the frequencies, as well as the previous ones (that is, for our example, in step 2 we must divide the interval from 0.4 to 0.6 into subintervals as how they did it in the first step).  The process continues until the last character of the stream is encoded. <br>  In other words, the i-th symbol will be assigned an interval <br><img src="https://habrastorage.org/storage2/053/b4a/edc/053b4aedccf85a80f040d278d37f03f1.png"><br>  where N is the number of characters in the alphabet, p <sub>i</sub> is the probability of the i-th character. <br><br>  In our case, it looks like this. <br><br><img src="https://habrastorage.org/storage2/834/554/ecf/834554ecf7d2b7b7aa2027186c79de9e.png"><br><br>  So, we have successively narrowed the interval for each character of the input stream, until we get the interval from 0.45312 to 0.4544 on the last character.  That is what we will use when encoding. <br><br>  Now we need to take any number lying in this interval.  Let it be 0.454.  Surprisingly (and for me, when I first studied this method, it was quite surprising), this number, in combination with the values ‚Äã‚Äãof the frequencies of the symbols, is enough to completely restore the original message. <br><br>  However, for successful implementation, the fraction must be represented in binary form.  Due to the feature of representing fractions in binary form (recall that some fractions having a finite number of digits in the decimal system have an infinite number of digits in binary), encoding is usually performed based on the upper and lower limits of the target range. <br><br>  How does decoding happen?  Decoding occurs in a similar way (not in the reverse order, but in a similar way). <br><br>  We start with an interval from 0 to 1, broken down according to the frequencies of the characters.  We check which interval our number falls into (0.454).  The character corresponding to this interval will be the first character of the sequence.  Next, we extend this interval to the full scale, and repeat the procedure. <br><br>  For our case, the process will look like this: <br><img src="https://habrastorage.org/storage2/d2e/7ec/68c/d2e7ec68c7155233c6c0c98dc8c1dce9.png"><br><br>  Of course, nothing prevents us from continuing to reduce the interval and increase accuracy, getting more and more new "characters".  Therefore, when encoding in this way, you need to either know in advance the number of characters of the original message, or limit the message to a unique character so that its end can be accurately determined. <br><br>  When implementing the algorithm, some factors should be taken into account.  Firstly, the algorithm in the form presented above can only encode short chains due to the limitation of bit depth.  To avoid this limitation, real algorithms work with integers and operate with fractions, the numerator and denominator of which are an integer. <br><br>  To estimate the degree of compression of arithmetic coding, we need to find the minimum number N, such that during the compression of the last character, we can certainly find a number in the binary representation of which, after N characters, only zeros go.  For this, the length of the interval must be no less than 1/2 <sup>N.</sup>  It is known that the length of the interval will be equal to the product of the probabilities of all symbols. <br><br>  Consider the sequence of symbols <i>a</i> and <i>b</i> proposed at the beginning of the article with probabilities 253/256 and 3/256.  The length of the last working interval for a chain of 256 characters will be equal to <br><img src="https://habrastorage.org/storage2/b0a/e7f/41f/b0ae7f41ffca3952ced7d506b86f7e23.png"><br><br>  In this case, the required N will be equal to 24 (23 gives too large an interval, and 25 will not be minimal), that is, we will spend on coding only 24 bits, against 256 bits of the Huffman method. <br><br><h4>  Burrows - Wheeler Transformation </h4><br>  So, we found out that compression methods show different efficiency on different data sets.  Proceeding from this, a quite logical question arises: if compression algorithms work better on certain data, is it possible to perform some operations with data before compression to improve their ‚Äúquality‚Äù? <br><br>  Yes it is possible.  For illustration, consider the Burrows-Wheeler transform, which turns a data block with complex dependencies into a block whose structure is easier to model.  Naturally, this transformation is also completely reversible.  The authors of the method are David Wheeler and Michael Burrows (according to the wiki, he now works at Google). <br><br>  So, the Burrows-Wheeler algorithm (hereinafter, for brevity, I will call it BTW - Burrows-Wheeler Transform) transforms the input block into a form more convenient for compression.  However, as practice shows, the usual methods obtained as a result of the block conversion are not as successful as they were specially designed for this, therefore, for practical use, the BWT algorithm cannot be considered separately from the corresponding data coding methods, but since our goal is to learn how it works, Nothing wrong with that. <br><br>  In the original article, published in 1994, the authors proposed the implementation of coding on three algorithms: <br><ul><li>  Actually, BWT </li><li>  Transform Move-to-Front, known in Russian literature as moving a stack of books </li><li>  Statistical compression encoder obtained in the first two stages of data. </li></ul><br><br>  True, the second step can be replaced by another similar algorithm, or completely eliminated due to the complexity of the coding phase.  It is important to understand that BWT <i>does not affect the size of the data</i> , it only changes the location of the blocks. <br><br><h5>  Transform algorithm </h5><br><br>  BWT is a block algorithm, that is, it operates on data blocks, and knows in advance about the composition of block elements of a certain size.  This makes it difficult to use BWT in cases where character-by-character compression or on-the-fly compression is necessary.  In principle, such an implementation is possible, but the algorithm will turn out ... not very fast. <br><br>  The principle of conversion is extremely simple.  Consider it on the classic "book" example - the word "abracadabra", which perfectly suits us according to several criteria: there are many repeated symbols in it, and these symbols are distributed fairly evenly over the word. <br><br>  The first step in the conversion will be to compile a list of cyclic permutations of the source data.  In other words, we take the source data, and move the last character to the first place (or vice versa).  We perform this operation until we get the original string again.  All strings obtained in this way will be all cyclic permutations.  In our case, it looks like this: <br><br><pre><code class="cpp hljs">          </code> </pre> <br><br>  We will consider this as a matrix of characters, where each cell is one character, respectively, the string corresponds to the whole word.  We mark the source row and sort the matrix. <br>  Sorting is done first by the first character, then for those lines where the first character matches - by the second, and so on.  After this sorting, our matrix will look like this: <br><br><pre> <code class="cpp hljs">   ‚Äì          </code> </pre><br><br>  In general, this transformation is almost complete: all that remains to be done is to write down the last column, while not forgetting to remember the number of the original row.  By doing this, we get: <br><br><pre> <code class="cpp hljs">¬´&gt;&gt;&lt;&lt;¬ª</code> </pre><br><br>  or differently <br><br><pre> <code class="cpp hljs">¬´¬ª,<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  As you can see, the distribution of characters has become much better: now 4 out of 5 characters ‚Äúa‚Äù stand side by side, like both symbols ‚Äúb‚Äù. <br><br><h5>  Reversibility </h5><br>  As I already mentioned, the transformation is completely reversible.  This is understandable, because otherwise there would be no point in it.  So how to restore the original appearance of the message? <br><br>  First we need to sort our characters in order.  This will give us the string "aaaaabbdkrr."  Since our cyclic permutation matrix was sorted in order, this sequence of letters is nothing but the first column of our cyclic permutation matrix.  In addition, we know the last column (in fact, the result of the transformation itself).  So, at this stage, we can restore the matrix to something like this: <br><br><table><tbody><tr><td>  but </td><td>  ... </td><td>  R </td></tr><tr><td>  but </td><td>  ... </td><td>  d </td></tr><tr><td>  but </td><td>  ... </td><td>  but </td></tr><tr><td>  but </td><td>  ... </td><td>  to </td></tr><tr><td>  but </td><td>  ... </td><td>  R </td></tr><tr><td>  b </td><td>  ... </td><td>  but </td></tr><tr><td>  b </td><td>  ... </td><td>  but </td></tr><tr><td>  d </td><td>  ... </td><td>  but </td></tr><tr><td>  to </td><td>  ... </td><td>  but </td></tr><tr><td>  R </td><td>  ... </td><td>  b </td></tr><tr><td>  R </td><td>  ... </td><td>  b </td></tr></tbody></table><br><br>  Since the matrix was obtained by a cyclic shift, the symbols of the last and first columns form pairs.  Sorting these pairs in ascending order, we will get the first two columns.  Then, these two columns and the last form three characters already, and so on. <br>  In the end, we completely restore the matrix, and since we know the number of the line containing the original data, we can easily get their original form. <br><br>  In other words, the restoration is carried out as follows: <br><ol><li>  Attach the characters of the last column to the left to the characters of the first </li><li>  Sort all columns except last </li></ol><br><br>  These two steps need to be repeated until the matrix is ‚Äã‚Äãcompletely filled. <br><br>  For our example, the first four steps of recovery will look like this: <br><pre> <code class="cpp hljs"> -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...  -&gt;  -&gt;  -&gt;  -&gt;...</code> </pre><br><br><h5>  Resource costs when working </h5><br>  After we have proved the reversibility of the data, we will prove that in order to implement the algorithm, it is not necessary to store the entire matrix in memory.  Indeed, if we completely stored a matrix corresponding to, for example, a block of 1 megabyte in size, then we would need a tremendous amount of memory - because the matrix is ‚Äã‚Äãsquare.  Naturally, this option is invalid. <br><br>  For the inverse transformation, in addition to the actual data, we need an inverse transformation vector - an array of numbers, the size of which is equal to the number of characters in the block.  Thus, memory costs for linear conversion grow linearly with the size of the block. <br><br>  During the inverse transformation, the same actions were performed to obtain the next column of the matrix.  Namely, the new line was obtained by combining the character of the last column of the old line and the known characters of the same line.  Of course, after sorting, the new row was moved to another position in the matrix.  It is important that when adding any column, the movement of rows to the new position should be the same.  To get the vector of the inverse transform, you need to determine the order of obtaining the characters of the first column from the characters of the last one, that is, sort the matrix by new row numbers <br><br><img src="http://habrastorage.org/storage2/e9c/74d/a9f/e9c74da9f8adc190f8903783494fdda2.png"><br><br>  The transformation vector is formed from the values ‚Äã‚Äãof line numbers: {2,5,6,7,8,9,10,1,3,0,4}. <br><br>  Now you can easily get the original string.  Take an element of the vector of the inverse transform that corresponds to the number of the original row in the matrix: T [2] = 6.  In other words, as the first character of the source line, you must take the sixth character of the string "rdacraaabb" - the symbol "a". <br>  After that, we look at which symbol has moved the found symbol ‚Äúa‚Äù to the second position among the same with it.  To do this, we take the number from the transform vector of the string from which the character ‚Äúa‚Äù was taken: this is number 6. <br>  Then we look at the line having the number 6 and choose the last character from there - the symbol ‚Äúb‚Äù.  Continuing this procedure for the remaining characters, we will easily restore the original string. <br><br><h5>  Moving a stack of books </h5><br><br>  Moving a stack of books is an intermediate algorithm that the authors recommend using after BWT and before direct coding.  The algorithm works as follows. <br><br>  Consider the string "rdakraaabb", obtained by us on BWT in the previous section.  In this case, our alphabet consists of 5 characters.  Ordering them, we get <br>  M = {a, b, d, k, p}. <br><br>  So, we use on our line an algorithm for moving a stack of books.  The first character of the string ("p") is in the alphabet in 4th place.  This number (4) we write to the output block.  Then we put the newly used symbol in the first place, and repeat the process with the second symbol, then with the third, and so on.  The processing will look like this (under the ‚Äúnumber‚Äù I assume the number that will go to the output stream): <br><br><table><tbody><tr><td>  Symbol </td><td>  Alphabet </td><td>  room </td></tr><tr><td>  R </td><td>  abcdr </td><td>  four </td></tr><tr><td>  d </td><td>  rabdk </td><td>  3 </td></tr><tr><td>  but </td><td>  drabk </td><td>  2 </td></tr><tr><td>  to </td><td>  adrbk </td><td>  four </td></tr><tr><td>  R </td><td>  frame </td><td>  3 </td></tr><tr><td>  but </td><td>  rkadb </td><td>  2 </td></tr><tr><td>  but </td><td>  arcdb </td><td>  0 </td></tr><tr><td>  but </td><td>  arcdb </td><td>  0 </td></tr><tr><td>  but </td><td>  arcdb </td><td>  0 </td></tr><tr><td>  b </td><td>  arcdb </td><td>  four </td></tr><tr><td>  b </td><td>  barcd </td><td>  0 </td></tr></tbody></table><br><br>  The result will be a sequence <br><pre> <code class="bash hljs">43243200040</code> </pre><br><br>  At this stage, it is not entirely clear what is the use of this algorithm.  In fact, there is a use.  Consider a more abstract sequence: <br><pre> <code class="bash hljs"></code> </pre><br><br>  For a start, just encode it using the Huffman method.  For clarity, we assume that the costs of storing a tree using moving a stack of books, and without it, are the same. <br>  The probabilities of the appearance of all four characters in our case are equal to ¬º, that is, the encoding of each character requires 2 bits.  It is easy to calculate that the encoded string will take 40 bits. <br>  Now let's change the string with the algorithm for moving a stack of books.  At the beginning of the alphabet has the form <br><pre> <code class="bash hljs">M={,,,}.</code> </pre><br><br>  After using the algorithm, the string will be <br><pre> <code class="bash hljs">10002000030000300003</code> </pre><br><br>  In this case, the frequency of the appearance of characters will change greatly: <br><table><tbody><tr><td>  Symbol </td><td>  Frequency </td><td>  Probability </td><td>  Huffman Code </td></tr><tr><td>  0 </td><td>  15 </td><td>  3/4 </td><td>  0 </td></tr><tr><td>  3 </td><td>  3 </td><td>  3/20 </td><td>  ten </td></tr><tr><td>  2 </td><td>  one </td><td>  1/20 </td><td>  110 </td></tr><tr><td>  one </td><td>  one </td><td>  1/20 </td><td>  111 </td></tr></tbody></table><br><br>  In this case, after encoding, we get a sequence of 15 + 6 + 3 + 3 = 27 bits, which is much less than 40 bits, which are obtained without moving a stack of books. <br><br><h5>  Conclusion </h5><br>  So, in this article, arithmetic coding was considered, as well as transformation algorithms, allowing to obtain a more ‚Äúconvenient‚Äù compression stream.  It should be noted that the use of algorithms such as BWT is very dependent on the input stream.  Efficiency is influenced by such factors as the lexigraphic sequence of characters, the directions of the bypass of the encoder (compression from left to right or right to left), block size, and so on.  In the next part of the article I will consider some more complex algorithm used in real coders (which one I haven‚Äôt decided yet). <br><br><h5>  Literature </h5><br><ul><li>  Vatolin D., Ratushnyak A., Smirnov M. Yukin V. Data Compression Methods.  Device archivers, image and video compression;  ISBN 5-86404-170-X;  2003 </li><li>  Lidovsky V.V. Information Theory: Tutorial.  - M .: Sputnik +, 2004. </li><li>  Semenyuk V.V. Economical coding of discrete information.  - SPb .: SPbGITMO (TU), 2001. </li><li>  Witten IH, Neal RM, Cleary JG Arithmetic Coding for Data Compression, CACM, 1987. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/142492/">https://habr.com/ru/post/142492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142485/index.html">Samsung Galaxy M sample video</a></li>
<li><a href="../142486/index.html">Details on the float property</a></li>
<li><a href="../142489/index.html">Habr - not a place for sublimation</a></li>
<li><a href="../142490/index.html">The way of independent developers on the example of a game that they do not promote in an article with a complex and abstract name about the way of independent ...</a></li>
<li><a href="../142491/index.html">Nikolai Grebnev (CUSTIS) - What is DDD? - report from the ADD conference</a></li>
<li><a href="../142493/index.html">Development of software development on the technology of "cloud computing"</a></li>
<li><a href="../142495/index.html">Anonymous are going to attack the official Formula 1 site</a></li>
<li><a href="../142497/index.html">Linux VMWare View 5.0 client with ‚ÄúUSB probros‚Äù</a></li>
<li><a href="../142499/index.html">The trial between Google and Oracle: analyzes the origin of several lines of code</a></li>
<li><a href="../142501/index.html">Interesting future: Velcro will climb on the walls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>