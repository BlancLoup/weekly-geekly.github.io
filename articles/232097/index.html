<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a simple interpreter in C ++ using TDD, part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The lexer was written in the first part , and the parser in the second part . Further development of the calculator and the facade for the entire inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a simple interpreter in C ++ using TDD, part 3</h1><div class="post__text post__text-html js-mediator-article">  The <a href="http://habrahabr.ru/post/231657/">lexer was written</a> in the <a href="http://habrahabr.ru/post/231657/">first part</a> , and the <a href="http://habrahabr.ru/post/232081/">parser</a> in the <a href="http://habrahabr.ru/post/232081/">second part</a> .  Further development of the calculator and the facade for the entire interpreter, as well as code refactoring to eliminate duplication will be considered. <br><br><h4>  Calculator </h4><br>  Let's get to the fun part.  The calculation of the expression in the postfix entry can be done in two ways: through recursion, implicitly using the process stack, or using an explicit stack.  We implement the second option.  An algorithm using an explicit stack is: <br><br><ul><li>  If an operand is fed to the input, it is placed on top of the stack. </li><li>  If the sign of the operation is input, the corresponding operation is performed on the required number of values ‚Äã‚Äãextracted from the stack, taken in the order of addition.  The result of the operation is placed on top of the stack. </li><li>  After complete processing of the input character set, the result of evaluating the expression lies at the top of the stack. </li></ul><br>  In this article I will not implement the execution context and the calculation of several expressions.  Therefore, the initial test list will be short: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  If the input list is empty, return 0. </li><li>  If the input list with one number, return this number. </li><li>  If input [1 2 +], return 3. </li></ul><br>  Create a new test class and add the first test. <br><br><pre><code class="cpp hljs">TEST_CLASS(EvaluatorTests) { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEST_METHOD(Should_return_zero_when_evaluate_empty_list) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({}); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, result); } };</code> </pre> <br><a name="habracut"></a><br>  Usually add an empty function to the required namespace. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Evaluator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// namespace Evaluator</span></span></code> </pre><br>  Let's write the second test. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_return_number_when_evaluate_list_with_number) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({ _1 }); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, result); }</code> </pre><br>  Just return what was last in the list.  It would be easier to do, but then you still need to add a loop. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { result = token; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Further - more difficult.  Let's try to calculate an expression with one operator. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_eval_expression_with_one_operator) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({ _1, _2, plus }); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, result); }</code> </pre><br>  In order for this test to pass, add just one character to the code. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token.Type() == TokenType::Number) { result += token; } }</code> </pre><br>  That was enough to pass the test.  Let's try to break this algorithm by calculating the result of multiplication. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_eval_expression_with_one_multiplication) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({ _2, _3, mul }); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">6.0</span></span>, result); }</code> </pre><br>  The test does not pass, as the addition is rigidly scored.  A more complex implementation is needed, taking into account the type of operator.  Add a branch and replace the variable with the result on the container. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; result{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pop = [&amp;]() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = result.back(); result.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token.Type() == TokenType::Number) { result.push_back(token); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token == Token(Operator::Plus)) { result.push_back(pop() + pop()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token == Token(Operator::Mul)) { result.push_back(pop() * pop()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pop(); }</code> </pre><br>  Note that this algorithm can already perform more complex calculations.  Let's do a test operator minus.  Its complexity is that you can confuse arguments by pulling them from the stack. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_eval_expression_with_one_subtraction) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({ _2, _3, minus }); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, result); }</code> </pre><br>  In general, according to the C ++ standard, no assumptions can be made regarding the order in which the function arguments are calculated.  Therefore, it is necessary to remove operands from the stack in explicit order. <br><br><pre> <code class="cpp hljs"> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token == Token(Operator::Minus)) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = pop(); result.push_back(pop() - d); }</code> </pre><br>  A similar test for division. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_eval_expression_with_one_division) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Evaluator::Evaluate({ _5, _2, div }); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">2.5</span></span>, result); }</code> </pre><br>  In the beginning, I wrote a test for division, using the expression <code>4/2=2</code> , and it immediately passed, despite the fact that the division operation was not added.  This was due to the fact that the last number added to it was retrieved from the stack, which, by coincidence, turned out to be equal to the result of the expression.  That is why the tests immediately after writing should fall, otherwise there is a high probability that the test does not actually test anything. <br><br><pre> <code class="cpp hljs"> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token == Token(Operator::Div)) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = pop(); result.push_back(pop() / d); }</code> </pre><br>  To make sure that everything works as it should, add the last test to calculate a complex expression. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_eval_complex_expression) { <span class="hljs-comment"><span class="hljs-comment">// (4+1)*2/(4/(3-1)) = 4 1 + 2 * 4 3 1 - / / = 5 double result = Evaluator::Evaluate({ _4, _1, plus, _2, mul, _4, _3, _1, minus, div, div }); Assert::AreEqual(5.0, result); }</span></span></code> </pre><br>  It passes, but it was intended.  There is quite a bit of duplication in our function.  We take it into a separate class and refactor. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Detail::<span class="hljs-function"><span class="hljs-function">StackEvaluator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tokens)</span></span></span></span>; evaluator.Evaluate(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluator.Result(); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Class Detail :: StackEvaluator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackEvaluator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StackEvaluator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tokens &amp;tokens) : m_current(tokens.cbegin()), m_end(tokens.cend()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; m_current != m_end; ++m_current) { EvaluateCurrentToken(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_stack.empty() ? <span class="hljs-number"><span class="hljs-number">0</span></span> : m_stack.back(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvaluateCurrentToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(m_current-&gt;Type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Operator: EvaluateOperator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Number: EvaluateNumber(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvaluateOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> second = PopOperand(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> first = PopOperand(); m_stack.push_back(BinaryFunctionFor(*m_current)(first, second)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvaluateNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_stack.push_back(*m_current); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopOperand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> back = m_stack.back(); m_stack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> back; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)&gt; &amp;BinaryFunctionFor(Operator op) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Operator, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)&gt;&gt; functions{ { Operator::Plus, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::plus&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() }, { Operator::Minus, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::minus&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() }, { Operator::Mul, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::multiplies&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() }, { Operator::Div, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::divides&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() }, }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> found = functions.find(op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(found == functions.cend()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Operator not found."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found-&gt;second; } Tokens::const_iterator m_current, m_end; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; m_stack; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace Detail</span></span></code> </pre><br></div></div><br><h4>  Interpreter </h4><br>  To simplify the work of the client, we will write a small function, which is a facade for the entire interpreter.  Let's start with a couple of integration tests. <br><br><pre> <code class="cpp hljs">TEST_CLASS(InterpreterIntegrationTests) { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEST_METHOD(Should_interprete_empty_experssion) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Interpreter::InterpreteExperssion(<span class="hljs-string"><span class="hljs-string">L" "</span></span>); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, result); } TEST_METHOD(Should_interprete_experssion) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = Interpreter::InterpreteExperssion(<span class="hljs-string"><span class="hljs-string">L"1+2"</span></span>); Assert::AreEqual(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, result); } };</code> </pre><br>  Let's write the implementation of the <code>InterpreteExperssion</code> function in the already existing <code>Interpreter</code> namespace. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpreteExperssion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::wstring &amp;expression)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Evaluator::Evaluate(Parser::Parse(Lexer::Tokenize(expression))); }</code> </pre><br>  Hurray, tests pass, then all parts of the interpreter interact as planned. <br><br><h4>  Refactoring </h4><br>  Now that the entire code is covered with tests, you can see if there is duplication on a global scale and eliminate it.  Immediately struck by a bunch of identical <code>switch</code> that perform checks on the type of token.  And in the token itself, both the number and the operator are stored simultaneously.  In order to get away from the conditional statements in each method, use the visitor template.  Create an abstract class <code>TokenVisitor</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenVisitor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ~TokenVisitor() {} };</code> </pre><br>  For simplicity, virtual methods will have an empty default implementation.  For security, we declare the destructor as protected and non-virtual in order to prevent the possibility of deletion through a pointer to this class.  Add a method to the token that accepts a visitor and transfer the ill-fated <code>switch</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;visitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(m_type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Operator: visitor.VisitOperator(m_operator); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Number: visitor.VisitNumber(m_number); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } }</code> </pre><br>  Now let's look at the <code>ShuntingYardParser</code> class and its <code>ParseCurrentToken</code> method. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCurrentToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(m_current-&gt;Type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Operator: ParseOperator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Number: ParseNumber(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } }</code> </pre><br>  The similarity is obvious.  Inherit this class from the abstract visitor and rename the <code>Parse*</code> methods to <code>Visit*</code> .  After that, the class will considerably lose weight, and the <code>Parse</code> method will look like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; m_current != m_end; ++m_current) { m_current-&gt;Accept(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackHasNoOperators(); }); }</code> </pre><br>  We will do the same with the <code>StackEvaluator</code> class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackEvaluator</span></span></span><span class="hljs-class"> :</span></span> TokenVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { token.Accept(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator op)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> second = PopOperand(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> first = PopOperand(); m_stack.push_back(BinaryFunctionFor(op)(first, second)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number)</span></span></span><span class="hljs-function"> override </span></span>{ m_stack.push_back(number); } };</code> </pre><br>  It would be possible not to use inheritance and virtual functions at all, replacing everything with templates, but then all support from the IDE will be lost and you will have to rely only on implicit agreements.  Now let's deal with the remaining <code>switch</code> and <code>union</code> <code>switch</code> .  Here the state pattern can be useful, which, by the way, implicitly uses <code>std::function</code> .  We proceed by analogy.  Create a <code>TokenConcept</code> private abstract class inside the token class, which will contain operations that depend on the type of token.  The specific implementation of the concept will be stored in <code>std::shared_ptr&lt;const TokenConcept&gt;</code> , since the token is immutable, then it is completely safe to make the state shared. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenConcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~TokenConcept() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TokenType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Invalid token type"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Operator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Invalid token type"</span></span>); } };</code> </pre><br>  Let's not get rid of <code>TokenType</code> completely so as not to break the tests.  Now we add the implementations for the number and the operator, then we replace the logic in the token methods with the reference to the concept. <br><br><div class="spoiler">  <b class="spoiler_title">Token class after refactoring</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Token</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenConcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~TokenConcept() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TokenType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Invalid token type"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Operator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Invalid token type"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumberToken</span></span></span><span class="hljs-class"> :</span></span> TokenConcept { NumberToken(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) : m_number(val) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;visitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ visitor.VisitNumber(m_number); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_wstring(m_number); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other.Type() == Type() &amp;&amp; other.ToNumber() == m_number; } <span class="hljs-function"><span class="hljs-function">TokenType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Number; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m_number; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OperatorToken</span></span></span><span class="hljs-class"> :</span></span> TokenConcept { OperatorToken(Operator val) : m_operator(val) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;visitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ visitor.VisitOperator(m_operator); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Interpreter::ToString(m_operator); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other.Type() == Type() &amp;&amp; other.ToOperator() == m_operator; } <span class="hljs-function"><span class="hljs-function">TokenType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } <span class="hljs-function"><span class="hljs-function">Operator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Operator m_operator; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Token(Operator val) : m_concept(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;OperatorToken&gt;(val)) {} Token(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) : m_concept(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;NumberToken&gt;(val)) {} <span class="hljs-function"><span class="hljs-function">TokenType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_concept-&gt;Type(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenVisitor &amp;visitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ m_concept-&gt;Accept(visitor); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_concept-&gt;ToOperator(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_concept-&gt;ToNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_concept-&gt;Equals(*right.m_concept); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Token &amp;token)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token.m_concept-&gt;ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TokenConcept&gt; m_concept; };</code> </pre><br></div></div><br>  Note that not a single test broke during refactoring, although the type of code has changed quite significantly.  Go ahead and delete the <code>TokenType</code> enumeration, since it is used only in the <code>Token</code> class.  Before that, we change the tests <code>Should_get_type_for_operator_token</code> and <code>Should_get_type_for_number_token</code> so that they do not use the type of token, slightly adjusting their semantics. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_check_for_equality_operator_tokens) { Assert::AreEqual(minus, minus); Assert::AreNotEqual(minus, plus); Assert::AreNotEqual(minus, _1); } TEST_METHOD(Should_check_for_equality_number_tokens) { Assert::AreEqual(_1, _1); Assert::AreNotEqual(_1, _2); Assert::AreNotEqual(_1, minus); }</code> </pre><br>  After deleting an enumeration, the problem of comparing tokens of different types arises.  You do not want to use RTTY, so we will slightly <code>TokenConcept</code> base class by adding double dispatch support for the <code>Equals</code> operation. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenConcept</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualsToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualsToOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumberToken</span></span></span><span class="hljs-class"> :</span></span> TokenConcept { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualsToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == m_number; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other.EqualsToNumber(m_number); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OperatorToken</span></span></span><span class="hljs-class"> :</span></span> TokenConcept { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqualsToOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == m_operator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenConcept &amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other.EqualsToOperator(m_operator); } };</code> </pre><br>  The derived classes in the <code>Equals</code> method perform the first dispatch step to determine the type of the first token, after which the second token makes a comparison with the already known type.  Tokens of different types are not equal by default, so derived classes need to override only one method that takes an argument of the appropriate type. <br><br><h4>  Conclusion </h4><br>  In this article, I tried to move away from the usual topics of TDD materials, focusing more on theory and delve into the practical application of this technique.  As shown, even in C ++, you can develop through testing without much difficulty.  Moreover, it is easy to get started, given the presence of built-in test support for C ++ projects in Visual Studio.  Of course, writing more complex systems requires more complex libraries, such as Boost.Test, Google.Test, or CppUTest, as well as libraries for creating mock objects, such as Google.Mock, or Turtle.  And not all scripts can be tested only with the help of unit tests.  But, nevertheless, the writing of unit tests and the development through testing markedly help in writing code, simplify its modification in the future and give confidence that everything works exactly as planned. <br><br>  If readers are interested, I can write the second part in a similar style, in which the implementation of the remaining items from the list at the beginning of the first part of this article will be described. <br><br><h4>  Resources </h4><br>  Below is the entire code in the final version: <br><br><div class="spoiler">  <b class="spoiler_title">Interpreter.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;map&gt; #include &lt;memory&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } struct TokenVisitor { virtual void VisitNumber(double) {} virtual void VisitOperator(Operator) {} protected: ~TokenVisitor() {} }; class Token { struct TokenConcept { virtual ~TokenConcept() {} virtual void Accept(TokenVisitor &amp;) const = 0; virtual std::wstring ToString() const = 0; virtual bool Equals(const TokenConcept &amp;other) const = 0; virtual bool EqualsToNumber(double) const { return false; } virtual bool EqualsToOperator(Operator) const { return false; } virtual double ToNumber() const { throw std::logic_error("Invalid token type"); } virtual Operator ToOperator() const { throw std::logic_error("Invalid token type"); } }; struct NumberToken : TokenConcept { NumberToken(double val) : m_number(val) {} void Accept(TokenVisitor &amp;visitor) const override { visitor.VisitNumber(m_number); } std::wstring ToString() const override { return std::to_wstring(m_number); } bool EqualsToNumber(double value) const override { return value == m_number; } bool Equals(const TokenConcept &amp;other) const { return other.EqualsToNumber(m_number); } double ToNumber() const override { return m_number; } private: double m_number; }; struct OperatorToken : TokenConcept { OperatorToken(Operator val) : m_operator(val) {} void Accept(TokenVisitor &amp;visitor) const override { visitor.VisitOperator(m_operator); } std::wstring ToString() const override { return Interpreter::ToString(m_operator); } bool EqualsToOperator(Operator value) const override { return value == m_operator; } bool Equals(const TokenConcept &amp;other) const { return other.EqualsToOperator(m_operator); } Operator ToOperator() const override { return m_operator; } private: Operator m_operator; }; public: Token(Operator val) : m_concept(std::make_shared&lt;OperatorToken&gt;(val)) {} Token(double val) : m_concept(std::make_shared&lt;NumberToken&gt;(val)) {} void Accept(TokenVisitor &amp;visitor) const { m_concept-&gt;Accept(visitor); } operator Operator() const { return m_concept-&gt;ToOperator(); } operator double() const { return m_concept-&gt;ToNumber(); } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { return left.m_concept-&gt;Equals(*right.m_concept); } friend inline std::wstring ToString(const Token &amp;token) { return token.m_concept-&gt;ToString(); } private: std::shared_ptr&lt;const TokenConcept&gt; m_concept; }; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail /// &lt;summary&gt; /// Convert the expression string to a sequence of tokens. /// &lt;/summary&gt; inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer namespace Parser { inline int PrecedenceOf(Operator op) { return (op == Operator::Mul || op == Operator::Div) ? 1 : 0; } namespace Detail { class ShuntingYardParser : TokenVisitor { public: void Parse(const Tokens &amp;tokens) { for(const Token &amp;token : tokens) { token.Accept(*this); } PopToOutputUntil([this]() {return StackHasNoOperators(); }); } const Tokens &amp;Result() const { return m_output; } private: void VisitOperator(Operator op) override { switch(op) { case Operator::LParen: PushCurrentToStack(op); break; case Operator::RParen: PopToOutputUntil([this]() { return LeftParenOnTop(); }); PopLeftParen(); break; default: PopToOutputUntil([&amp;]() { return LeftParenOnTop() || OperatorWithLessPrecedenceOnTop(op); }); PushCurrentToStack(op); break; } } void VisitNumber(double number) override { m_output.emplace_back(number); } bool StackHasNoOperators() const { if(m_stack.back() == Token(Operator::LParen)) { throw std::logic_error("Closing paren not found."); } return false; } void PushCurrentToStack(Operator op) { return m_stack.emplace_back(op); } void PopLeftParen() { if(m_stack.empty() || m_stack.back() != Operator::LParen) { throw std::logic_error("Opening paren not found."); } m_stack.pop_back(); } bool OperatorWithLessPrecedenceOnTop(Operator op) const { return PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(op); } bool LeftParenOnTop() const { return static_cast&lt;Operator&gt;(m_stack.back()) == Operator::LParen; } template&lt;class T&gt; void PopToOutputUntil(T whenToEnd) { while(!m_stack.empty() &amp;&amp; !whenToEnd()) { m_output.push_back(m_stack.back()); m_stack.pop_back(); } } Tokens m_output, m_stack; }; } // namespace Detail /// &lt;summary&gt; /// Convert the sequence of tokens in infix notation to a sequence in postfix notation. /// &lt;/summary&gt; inline Tokens Parse(const Tokens &amp;tokens) { Detail::ShuntingYardParser parser; parser.Parse(tokens); return parser.Result(); } } // namespace Parser namespace Evaluator { namespace Detail { class StackEvaluator : TokenVisitor { public: void Evaluate(const Tokens &amp;tokens) { for(const Token &amp;token : tokens) { token.Accept(*this); } } double Result() const { return m_stack.empty() ? 0 : m_stack.back(); } private: void VisitOperator(Operator op) override { double second = PopOperand(); double first = PopOperand(); m_stack.push_back(BinaryFunctionFor(op)(first, second)); } void VisitNumber(double number) override { m_stack.push_back(number); } double PopOperand() { double back = m_stack.back(); m_stack.pop_back(); return back; } static const std::function&lt;double(double, double)&gt; &amp;BinaryFunctionFor(Operator op) { static const std::map&lt;Operator, std::function&lt;double(double, double)&gt;&gt; functions{ { Operator::Plus, std::plus&lt;double&gt;() }, { Operator::Minus, std::minus&lt;double&gt;() }, { Operator::Mul, std::multiplies&lt;double&gt;() }, { Operator::Div, std::divides&lt;double&gt;() }, }; auto found = functions.find(op); if(found == functions.cend()) { throw std::logic_error("Operator not found."); } return found-&gt;second; } std::vector&lt;double&gt; m_stack; }; } // namespace Detail /// &lt;summary&gt; /// Evaluate the sequence of tokens in postfix notation and get a numerical result. /// &lt;/summary&gt; inline double Evaluate(const Tokens &amp;tokens) { Detail::StackEvaluator evaluator; evaluator.Evaluate(tokens); return evaluator.Result(); } } // namespace Evaluator /// &lt;summary&gt; /// Interpret the mathematical expression in infix notation and return a numerical result. /// &lt;/summary&gt; inline double InterpreteExperssion(const std::wstring &amp;expression) { return Evaluator::Evaluate(Parser::Parse(Lexer::Tokenize(expression))); } } // namespace Interpreter</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">InterpreterTests.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CppUnitTest.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Interpreter.h"</span></span></span><span class="hljs-meta"> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange const Token plus(Operator::Plus), minus(Operator::Minus); const Token mul(Operator::Mul), div(Operator::Div); const Token pLeft(Operator::LParen), pRight(Operator::RParen); const Token _1(1), _2(2), _3(3), _4(4), _5(5); TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ plus, Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ _1, plus, Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ _1, plus, _2, mul, _3, div, pLeft, _4, minus, _5, pRight }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_check_for_equality_operator_tokens) { Assert::AreEqual(minus, minus); Assert::AreNotEqual(minus, plus); Assert::AreNotEqual(minus, _1); } TEST_METHOD(Should_check_for_equality_number_tokens) { Assert::AreEqual(_1, _1); Assert::AreNotEqual(_1, _2); Assert::AreNotEqual(_1, minus); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; TEST_CLASS(ParserTests) { public: TEST_METHOD(Should_return_empty_list_when_put_empty_list) { Tokens tokens = Parser::Parse({}); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_parse_single_number) { Tokens tokens = Parser::Parse({ _1 }); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_parse_num_plus_num) { Tokens tokens = Parser::Parse({ _1, plus, _2 }); AssertRange::AreEqual({ _1, _2, plus }, tokens); } TEST_METHOD(Should_parse_two_additions) { Tokens tokens = Parser::Parse({ _1, plus, _2, plus, _3 }); AssertRange::AreEqual({ _1, _2, plus, _3, plus }, tokens); } TEST_METHOD(Should_get_same_precedence_for_operator_pairs) { Assert::AreEqual(Parser::PrecedenceOf(Operator::Plus), Parser::PrecedenceOf(Operator::Minus)); Assert::AreEqual(Parser::PrecedenceOf(Operator::Mul), Parser::PrecedenceOf(Operator::Div)); } TEST_METHOD(Should_get_greater_precedence_for_multiplicative_operators) { Assert::IsTrue(Parser::PrecedenceOf(Operator::Mul) &gt; Parser::PrecedenceOf(Operator::Plus)); } TEST_METHOD(Should_parse_add_and_mul) { Tokens tokens = Parser::Parse({ _1, plus, _2, mul, _3 }); AssertRange::AreEqual({ _1, _2, _3, mul, plus }, tokens); } TEST_METHOD(Should_parse_complex_experssion) { Tokens tokens = Parser::Parse({ _1, plus, _2, div, _3, minus, _4, mul, _5 }); AssertRange::AreEqual({ _1, _2, _3, div, plus, _4, _5, mul, minus }, tokens); } TEST_METHOD(Should_skip_parens_around_number) { Tokens tokens = Parser::Parse({ pLeft, _1, pRight }); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_parse_expression_with_parens_in_beginning) { Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, _3 }); AssertRange::AreEqual({ _1, _2, plus, _3, mul }, tokens); } TEST_METHOD(Should_throw_when_opening_paren_not_found) { Assert::ExpectException&lt;std::logic_error&gt;([]() {Parser::Parse({ _1, pRight }); }); } TEST_METHOD(Should_throw_when_closing_paren_not_found) { Assert::ExpectException&lt;std::logic_error&gt;([]() {Parser::Parse({ pLeft, _1 }); }); } TEST_METHOD(Should_parse_complex_experssion_with_paren) { // (1+2)*(3/(4-5)) = 1 2 + 3 4 5 - / * Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, pLeft, _3, div, pLeft, _4, minus, _5, pRight, pRight }); AssertRange::AreEqual({ _1, _2, plus, _3, _4, _5, minus, div, mul }, tokens); } }; TEST_CLASS(EvaluatorTests) { public: TEST_METHOD(Should_return_zero_when_evaluete_empty_list) { double result = Evaluator::Evaluate({}); Assert::AreEqual(0.0, result); } TEST_METHOD(Should_return_number_when_evaluete_list_with_number) { double result = Evaluator::Evaluate({ _1 }); Assert::AreEqual(1.0, result); } TEST_METHOD(Should_eval_expression_with_one_operator) { double result = Evaluator::Evaluate({ _1, _2, plus }); Assert::AreEqual(3.0, result); } TEST_METHOD(Should_eval_expression_with_one_multiplication) { double result = Evaluator::Evaluate({ _2, _3, mul }); Assert::AreEqual(6.0, result); } TEST_METHOD(Should_eval_expression_with_one_subtraction) { double result = Evaluator::Evaluate({ _2, _3, minus }); Assert::AreEqual(-1.0, result); } TEST_METHOD(Should_eval_expression_with_one_division) { double result = Evaluator::Evaluate({ _5, _2, div }); Assert::AreEqual(2.5, result); } TEST_METHOD(Should_eval_complex_expression) { // (4+1)*2/(4/(3-1)) = 4 1 + 2 * 4 3 1 - / / = 5 double result = Evaluator::Evaluate({ _4, _1, plus, _2, mul, _4, _3, _1, minus, div, div }); Assert::AreEqual(5.0, result); } }; TEST_CLASS(InterpreterIntegrationTests) { public: TEST_METHOD(Should_interprete_empty_experssion) { double result = Interpreter::InterpreteExperssion(L" "); Assert::AreEqual(0.0, result); } TEST_METHOD(Should_interprete_experssion) { double result = Interpreter::InterpreteExperssion(L"1+2"); Assert::AreEqual(3.0, result); } }; }</span></span></span></span></code> </pre><br></div></div><br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D1%2582%25D1%2580%25D0%25B5%25D1%2582%25D1%258C%25D0%25B5%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      ¬´__¬ª <br><br>        <a href="http://wcipeg.com/wiki/Shunting_yard_algorithm">PEGWiki</a> . <br><br>     Jeff Langr. Modern C++ Programming with Test-Driven Development. ‚Äî The Pragmatic Programmers, 2013. </div><p>Source: <a href="https://habr.com/ru/post/232097/">https://habr.com/ru/post/232097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232087/index.html">Automating the mounting of samba partitions on Mac OS</a></li>
<li><a href="../232089/index.html">Simple MVC model implementation with template hierarchy support</a></li>
<li><a href="../232091/index.html">Intel Pro 2500 - new SSD series with hardware encryption</a></li>
<li><a href="../232093/index.html">NASA confirms the performance of the "impossible" wave engine that does not use reactive mass - EmDrive</a></li>
<li><a href="../232095/index.html">ERPXE like a magic pill</a></li>
<li><a href="../232099/index.html">Clean and dirty test environments</a></li>
<li><a href="../232103/index.html">Node.js + HTML5 + js = online action game. Play on Node.js</a></li>
<li><a href="../232107/index.html">Motivation in a person‚Äôs life, or my little experience (introduction)</a></li>
<li><a href="../232109/index.html">The Rosetta interplanetary station measured the surface temperature of the comet Churyumov-Gerasimenko</a></li>
<li><a href="../232111/index.html">XBMC Media Player Renamed to Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>