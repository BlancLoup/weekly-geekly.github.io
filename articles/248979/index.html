<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenMP Regions Analysis with Intel¬Æ VTune ‚Ñ¢ Amplifier XE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenMP * is a fairly popular parallel programming model, especially for high-performance computing. But in order to achieve this high performance, Ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenMP Regions Analysis with Intel¬Æ VTune ‚Ñ¢ Amplifier XE</h1><div class="post__text post__text-html js-mediator-article">  OpenMP * is a fairly popular parallel programming model, especially for high-performance computing.  But in order to achieve this high performance, OpenMP constructions often have to be ‚Äútuned‚Äù.  And here you can not do without a good profiler.  Most profilers produce performance data associated with functions or cycles, but do not provide pictures of specific OpenMP regions.  As a result, the programmer loses context.  And without an OpenMP context, diagnosing imbalances or overhead becomes very difficult. <br>  Intel VTune Amplifier XE <a href="http://habrahabr.ru/company/intel/blog/204058/">can profile OpenMP regions</a> .  The latest version of 2015 Update 2 makes the analysis much simpler and more understandable, thanks to the presentation of data in "OpenMP terms".  The tool shows the time of parallel and consecutive regions, the difference between the actual and idealized execution time of a region, a breakdown into parallel loops, and the CPU load for each region separately. <br>  The user can more easily understand where to invest the efforts in the first place, thanks to the metric of "potential gain".  The classification of overheads helps determine the cause of inefficiency - for example, waiting due to load imbalance or ‚Äúlock‚Äù due to synchronization. <br>  This article describes some types of OpenMP problems identified by the VTune Amplifier, as they need to be understood and resolved. <br><br><img src="https://habrastorage.org/files/64d/cca/f23/64dccaf23be147c6aa68b92e35dbdf48.png"><br><a name="habracut"></a><br><h1>  Configuration </h1><br>  Good news: with the latest versions of VTune Amplifier and Intel Compiler, almost nothing needs to be set up.  Only set one environment variable (example for Linux): <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KMP_FORKJOIN_FRAMES_MODE=3</code> </pre> <br>  After that, simply run any type of analysis of your OpenMP application, for example, Advanced Hotspots.  The following product versions are used in this post: <br><ul><li>  <a href="https://software.intel.com/en-us/articles/whats-new-intel-vtune-amplifier-xe-2015-update-2">Intel VTune Amplifier XE 2015 update 2</a> </li><li>  <a href="https://software.intel.com/en-us/articles/intel-parallel-studio-xe-2015-update-2-composer-edition-for-windows">Intel Parallel Studio XE Composer Edition 2015 update 2</a> </li></ul><br>  Setting a variable is necessary temporarily, some of the functionality is still experimental.  In future updates, this will not be necessary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Inefficiency evaluation: sequential code and CPU utilization </h1><br>  For starters, it is recommended to look at the CPU utilization histogram in the Summary panel.  It contains the work time of the entire program (elapsed time), divided by the load levels of the processor cores.  This includes only useful time, i.e.  burning cycles during active spinning is not taken into account. <br><br><img src="https://habrastorage.org/files/abd/660/2e5/abd6602e58e6403eb1216aa27ac6e116.png"><br><br>  Ideally, in a parallel application, most of the time should fall on the ‚Äúgreen‚Äù zone, when most of the cores are working simultaneously.  The picture above shows the test result from the Intel Xeon Phi coprocessor.  Most of the 224 hardware threads are idle, which can be two main reasons: <br>  1. Most of the serial part - if there is no parallelism initially. <br>  2. Low efficiency of parallel regions - the code is parallel, but some bottlenecks limit scalability. <br>  Now look at the ‚ÄúOpenMP Analysis‚Äù section on the Summary panel: <br><br><img src="https://habrastorage.org/files/784/eb2/125/784eb21255bc4fcd9168f7564019fb45.png"><br><br>  The execution time (elapsed time) is divided into serial (Serial Time) and parallel (Parallel Region Time).  If the sequential time is large, look for ways to reduce the sequential part.  Either parallelize where this has not been done yet, or do other optimization, for example, micro-architecture, if the algorithm does not parallel.  The more hardware threads on the machine, the stronger the negative effect from consecutive sites.  In our test, 93.4% of the execution time is carried out in a sequential code, which is the main limiting factor ( <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2590%25D0%25BC%25D0%25B4%25D0%25B0%25D0%25BB%25D0%25B0">Amdal law</a> ). <br><br>  If we want to further explore the consecutive area, switch to the Bottom-up tab, select the grouping by ‚Äú/ OpenMP Region / Thread / Function ..‚Äù and filter by master stream (Master Thread) in the line ‚Äú[Serial - outside any region]‚Äù . <br><br><img src="https://habrastorage.org/files/677/f7a/1d8/677f7a1d8b92405c88b55cc9563c815f.png"><br><br>  Here at Bottom-up, it can be seen that a consecutive segment takes 21.571 seconds, most of the total execution time.  However, the CPU time (total for all threads) is much more in parallel sections - the OpenMP region on line 179 spends 164 seconds, and this is only one region.  Filtering by master thread is necessary because there may be many OpenMP worker threads that just wait for the master thread to execute the sequential code.  And they are waiting actively, burning CPU cycles - this time should be excluded if we want to concentrate on the sequential code itself.  In our test, this is only 20.713 seconds of CPU time.  And on the Intel Xeon Phi multi-core coprocessor, this kills performance ‚Äî Amdahl's law in action. <br><br>  The overall effectiveness of parallel regions can be assessed on the ‚ÄúOpenMP Region CPU Usage Histogram‚Äù on the Summary tab.  This is the same as CPU usage histogram, but attached to a specific parallel region.  Below is the CPU load from the same test on Intel Xeon Phi, but for the OpenMP region on line 153. Here the load is much better - most of it is close to perfect, the rest is shifted to the right of zero.  Those.  On this parallel region, the number of cores is more than the average for the program, which is expected. <br><br><img src="https://habrastorage.org/files/fae/75a/89e/fae75a89e68f4b52825f585ffa7fbada.png"><br><br><h1>  Search for opportunities for optimization: potential gain </h1><br>  Let us examine another example.  We analyzed NAS Parallel Benchmarks (NPB) for possible problems in the performance of OpenMP regions. <br><br>  Test configuration: <br><ul><li>  CPU: Intel Xeon processor E5-2697 v2 @ 2.70GHz, 24 cores / 48 threads. </li><li>  OS: RHEL 7.0 x64 </li><li>  Compiler: Intel Parallel Studio XE Composer Edition 2015 update 2 </li><li>  Workload: NPB 3.3.1, ‚ÄúCG - Conjugate Gradient, irregular memory access and communication‚Äù module, class B. </li></ul><br>  The number of OpenMP streams is set to 24, which corresponds to the number of physical cores.  The CPU utilization histogram shows a good load, but still not perfect - considerable time was spent with only 2-6 cores simultaneously occupied.  The program is parallel, but does not always use all 24 cores: <br><br><img src="https://habrastorage.org/files/ffa/9cf/af4/ffa9cfaf4b994562a180f3ecae2555c4.png"><br><br>  Consistent time in NPB is negligible and not a problem.  But pay attention to the ‚ÄúPotential Gain‚Äù metric (highlighted in pink): <br><br><img src="https://habrastorage.org/files/fe4/267/315/fe4267315860443abc9407efb8e89e4c.png"><br><br>  Potential Gain is the difference in execution time between the actual measurement and the ideal case, if the load on all the threads were perfectly balanced and the OpenMP runtime overhead would be zero.  Those.  Potential Gain - the potential gain from optimization, this is the maximum time you can win by improving parallel execution.  This metric may be more important than execution time and processor time, since  it focuses you not just on the most costly region, but on the region in which you most likely will get the best result from optimization (what do you usually look for, otherwise why profile?). <br><br>  In the picture above, the Potential Gain, highlighted in pink, says that optimizing all parallel regions to an ideal state can reduce the execution time of the entire program by 3.975s or 34.9% - there is something to fight for, although we will not reach the ideal of course. <br><br>  So far, we have operated with the metrics of the entire application - let's go deeper, to the level of parallel regions.  Summary contains the top 5 OpenMP regions for potential gain.  In our case, the entire potential gain (3.958c) is concentrated in one region on line 514. This is good for us - the problem is narrowed down to one single region. <br><br><h1>  Determining the causes of inefficiency of a parallel region </h1><br>  When we have focused on a specific region, click on it in Summary and follow the hyperlink to Bottom-up, which itself is grouped by OpenMP regions and highlights the one we need: <br><br><img src="https://habrastorage.org/files/64d/cca/f23/64dccaf23be147c6aa68b92e35dbdf48.png"><br><br>  The Bottom-up table contains various statistics about parallel regions: region execution time (elapsed time), potential gain, number of OpenMP workflows, number of occurrences in a region (instance count).  CPU time is divided into effective time (the code of the application itself), spin time (active waiting time), and overhead time (overhead).  The time of active waiting is significant and highlighted in pink - 92.159s.  Before digging deeper, let's take a quick look at the source code.  Our parallel region on line 514 consists of many parallel ‚Äú! $ Omp do‚Äù cycles.  This is bad news, because our metrics are for the entire region, and it is unclear which cycles to assign them to: <br><br><img src="https://habrastorage.org/files/ffb/8d6/a0c/ffb8d6a0cfaf4886becc1e24ad48021d.png"><br><br>  And again, the good news is that VTune Amplifier can break data not only by parallel regions, but also by OpenMP barriers.  As is known, all ‚Äú#omp for‚Äù or ‚Äú! $ Omp do‚Äù constructions have synchronization barriers, unless the ‚Äúnowait‚Äù option is specified.  Since  VTune Amplifier recognizes these barriers, we can see the execution time and CPU for each barrier, i.e.  and for each parallel cycle within the region.  Here you need to create custom grouping by ‚Äú/ OpenMP Region / OpenMP Barrier Type / OpenMP Barrier / ..‚Äù - see the small button on the right in the grouping line. <br><br>  After grouping by barriers, everything becomes clearer.  First, most of the time and the potential gain comes from the Loop barrier on line 572 (highlighted in the screenshot, the line did not fit): <br><br><img src="https://habrastorage.org/files/e1e/8c0/904/e1e8c09048e34d6b8a830e01abf14703.png"><br><br>  Secondly, we expand the Spin Time column by categories, and we see that all active waiting is due to an imbalance (Imbalance is highlighted in pink).  Thirdly, the column ‚ÄúOpenMP Loop Schedule Type‚Äù says that our parallel loop has static dispatch. <br><br><h1>  Unbalance correction </h1><br>  The loop on line 572 contains only ‚Äú! $ Omp do‚Äù, without any ‚Äúschedule‚Äù options.  Therefore, the default dispatch type is static, which is what the profiler said. <br><br><img src="https://habrastorage.org/files/6b3/da3/229/6b3da322959c4e68b30f48e4020148a2.png"><br><br>  Since  the cycle suffers from imbalance, it is logical to try dynamic dispatching - let the load be distributed automatically: <br><br><img src="https://habrastorage.org/files/644/75e/7bc/64475e7bc09246f08fa3cfd4b4ed3548.png"><br><br><h1>  Analysis and correction of overhead </h1><br>  After moving to dynamic dispatch, the performance of the loop became even worse.  Execution time increased from 10.445s to 11.102s: <br><br><img src="https://habrastorage.org/files/7df/40b/99b/7df40b99b5194631a8695f9666c22716.png"><br><br>  The picture in the table has changed - the imbalance and spin time disappeared, which means we still fixed it, not bad at all.  But now a new problem has been highlighted - 74.99c CPU time goes into scheduling overhead.  OpenMP runs too much inside. <br><br>  The ‚ÄúOpenMP Loop Chunk‚Äù column has changed from the original 3125 to 1. This means that each iteration is dispatched individually, while the number of calculations per iteration is quite small - see the code above.  The pieces of work for OpenMP threads are very small, and it‚Äôs necessary to distribute them among threads very often - the runtime works too intensively, it spends a lot of CPU time.  Parallelism is too fine granular. <br><br>  Chunk size or Grain size is equal to the default unit for dynamic dispatch.  Check the assumption of too small granularity - increase it to 20: <br><br><img src="https://habrastorage.org/files/65e/839/863/65e839863c6b4f14b76a7382108e91fa.png"><br><br>  We look into the results of profiling.  Imbalance and overhead are now spending only about 1 second of CPU time.  The cycle barrier on line 572 went down in the list of hot cycles, because its potential gain decreased to 0.077s from the initial 3.133s.  The cycle execution time dropped from 10.445s to 8.928s.  The CPU time for the entire parallel region has decreased from ~ 250s to ~ 213s.  So we got some performance gains, albeit less potential 3x seconds: <br><br><img src="https://habrastorage.org/files/719/594/b7a/719594b7afa5483bbb99f0b87d51f89a.png"><br><br><h1>  Conclusion </h1><br>  Performance analysis of OpenMP applications with VTune Amplifier XE has become more natural - the tool operates with terms and concepts of OpenMP, rather than hardware and system metrics.  You can analyze bottlenecks from the general to the particular, starting with the evaluation of the sequential part and the processor utilization for the entire application, and check the CPU utilization for a particular parallel region.  The potential gain metric focuses the developer on the most interesting opportunities for optimization.  The breakdown of data by barriers allows analyzing regions with multiple parallel cycles. <br>  Bottom-up OpenMP statistics help determine the cause of inefficiency.  The type of dispatch, chunk size, the number of threads and calls to the region, the categorization of active waiting time and overhead - all this will help to understand what limits the performance: imbalance, fine granularity, synchronization objects, or something else. <br><br>  References: <br>  - OpenMP analysis - Intel OpenMP and VTune Amplifier XE library collaboration, both of which are available in the <a href="https://software.intel.com/en-us/intel-parallel-studio-xe">Intel Parallel Studio XE 2015</a> Professional edition. <br>  - Official site and additional materials on <a href="https://software.intel.com/en-us/intel-vtune-amplifier-xe">VTune Amplifier XE</a> . <br>  - A more complete and detailed <a href="https://software.intel.com/en-us/articles/profiling-openmp-applications-with-intel-vtune-amplifier-xe">article about OpenMP problems identified by VTune Amplifier</a> (Eng.) </div><p>Source: <a href="https://habr.com/ru/post/248979/">https://habr.com/ru/post/248979/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248969/index.html">Panoramic passive radar</a></li>
<li><a href="../248971/index.html">Static analysis of PHP code on the example of symfony2</a></li>
<li><a href="../248973/index.html">27 years of Arctic ice in one minute</a></li>
<li><a href="../248975/index.html">Interval repetition on LinguaLeo</a></li>
<li><a href="../248977/index.html">Results of 2014: Windows threats and exploitation</a></li>
<li><a href="../248981/index.html">Dynamic do-it-yourself java code compilation</a></li>
<li><a href="../248983/index.html">How-to: Automate accounting tasks hosting provider</a></li>
<li><a href="../248985/index.html">CSS Auditing: Style Sheets Shouldn't Be Horrible</a></li>
<li><a href="../248987/index.html">CTB-Locker - a new modification of the FileCoder cryptographer</a></li>
<li><a href="../248991/index.html">Automatic Age Assessment System for Face Images</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>