<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32F3DISCOVERY, accelerometers, stepper motors and a bit of magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear Khabrovcanin. I want to tell you about my work, which is usually done by students of the last years of technical universities (ye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32F3DISCOVERY, accelerometers, stepper motors and a bit of magic</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear Khabrovcanin.  I want to tell you about my work, which is usually done by students of the last years of technical universities (yes, that is a bad word on the letter ‚ÄúD‚Äù). <br><br>  The aim of the work was to develop a system for sensing and controlling a mobile robot.  Behind these loud words is not very big, but for me an interesting task. <br><br>  Closer to the point.  We have a microprocessor, a pack of sensors, a stepping engine and it is necessary that the microprocessor reads data from the sensors (accelerometers and gyroscopes), sends this information to a PC, receives the engine control command from a computer, rotated the engine. <br><a name="habracut"></a><br><h4>  Purchase: </h4><br>  He stopped his choice on the following components: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚Ä¢ STM32F3DISCOVERY, since it has an accelerometer and gyroscope already installed on board.  Yes, and under the STM32, there are already many ready-made examples, which should have facilitated the task (partly facilitated). <br>  ‚Ä¢ Digital accelerometers LIS331DH, 3-axis, high-precision (from 2g to 8g).  In general, almost the entire LIS * series is very good and fits the requirements. <br>  ‚Ä¢ The step engine FL42STH25-0404A, well, here that the favorite department was lying around, it went into business. <br><br>  An interesting point is that in the course of the work I searched for articles and information specifically on STM32F3, and I was surprised that there are not as many of them as expected (for example, on STM32F4 many times more examples and information).  Yes, you say that there is almost no difference, and you will be partly right, but working with the periphery they have in some places different.  That's why I decided to deposit my 5 kopecks to work with this microprocessor. <br><br><h4>  Quietly understand: </h4><br>  We take out the STM32F3DISCOVERY from the box, connect it to the PC and launch it.  The demoprogram shows that when the deviations of the light bulb blink, that is, the sensors are working.  We shout ‚ÄúHurray!‚Äù And crawl into the code to understand and actually implement the necessary. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/07d/dfe/4bd/07ddfe4bd7f2e43116b74e7e1a22d90c.jpg" alt="image"><br><br>  A lot of necessary, but first decided to stay on how to reach external sensors (not airborne).  Accelerated axel, connect.  Axels have 2 interfaces for connection: SPI and I2C.  I decided to stop at SPI, because  I had to deal with it on ATTINY2313 (implemented it programmatically) and thought that there shouldn't be any problems with hardware SPI at all. <br><br><h4>  Wanted as easier, it turned out as always </h4><br><img src="https://habrastorage.org/storage2/4ce/691/07a/4ce69107ad86e8cf02166721579077e5.png"><br>  Connection: MISO - MISO, MOSI - MOSI, SCK - SCK, CS can be hung on any leg, as we will pull it programmatically. <br>  First we need to initialize SPI.  In this example, the work goes with SPI2, since the built-in gyroscope (or Axel, I do not remember exactly) works through the first SPI: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPI2_Configuration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_5); <span class="hljs-comment"><span class="hljs-comment">// SCK GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_5); // MISO GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_5); // MOSI SPI_InitTypeDef SPI_InitStructure; SPI_StructInit(&amp;SPI_InitStructure); SPI_I2S_DeInit(SPI2); SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low; SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b; SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; SPI_InitStructure.SPI_Mode = SPI_Mode_Master; SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; SPI_InitStructure.SPI_CRCPolynomial = 7; SPI_Init(SPI2, &amp;SPI_InitStructure); /* Configure the Priority Group to 1 bit */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); /* Configure the SPI interrupt priority */ NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); /* Initialize the FIFO threshold */ SPI_RxFIFOThresholdConfig(SPI2, SPI_RxFIFOThreshold_QF); SPI_Cmd(SPI2, ENABLE); }</span></span></code> </pre> <br>  We are trying to read data from the WHO_AM_I register: <br> <code>getValue = getRegisterValue(&amp;AXELx, 0x0F);</code> <br>  Where <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRegisterValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AXEL_TypeDef* AXELx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address)</span></span></span><span class="hljs-function"> </span></span>{ AXELx-&gt;CS_Port-&gt;BRR = AXELx-&gt;CS_Pin; SPI_I2S_SendData16(SPI2, <span class="hljs-number"><span class="hljs-number">0x8000</span></span>|(address&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE)); AXELx-&gt;CS_Port-&gt;BSRR = AXELx-&gt;CS_Pin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPI_I2S_ReceiveData16(SPI2); }</code> </pre><br>  Here it is necessary to note an important nuance that we need to pull the CS of the accelerometer, which we are addressing, in time, as pressing CS to the ground initiates the start of data transfer (because of this moment I had severe plugs and problems, plus not all axels successfully soldered and some It turned out to be non-working, which stopped my work for about two weeks. O_o).  Then we send the address of the register with which we will work (read / write), read or write with the second byte. <br><br>  Well, we will write like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRegisterValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AXEL_TypeDef* AXELx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ AXELx-&gt;CS_Port-&gt;BRR = AXELx-&gt;CS_Pin; SPI_I2S_SendData16(SPI2,((<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)address&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>)|(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)data); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE)); AXELx-&gt;CS_Port-&gt;BSRR = AXELx-&gt;CS_Pin; SPI_I2S_ReceiveData16(SPI2); }</code> </pre><br>  For correct operation, the sensors also need to be initialized, namely, indicate that we will read on all three axes and indicate the operating frequency (the value of the control word and its formation are viewed in the datasheet on the axel). <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Axel_Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AXEL_TypeDef* AXELx)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment"><span class="hljs-comment">/* Enable Axel CS Pin */</span></span> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_Pin = AXELx-&gt;CS_Pin; GPIO_Init(AXELx-&gt;CS_Port, &amp;GPIO_InitStructure); setRegisterValue(AXELx, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>); }</code> </pre><br>  With the sensors finished, hooray!  Now let's move on to the management of stepper motors. <br><br><h4>  The quieter you go, the further you'll get </h4><br><img src="https://habrastorage.org/storage2/d2b/3e1/0a2/d2b3e10a28d1cdccb95c40ff96f16ec7.png"><br>  The driver VNH3SP30 was used to control the stepper motor.  True, it allows you to control only one of the two windings of a stepper motor, so we need 2 such scarves. <br><br>  Thus, to control one winding, we need 3 outputs from the microcontroller (one carrier frequency and 2 directions), for the entire engine - 6. <br><br>  Define ports for convenience: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_PULSE_PORT GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_PULSE_PIN GPIO_Pin_2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_DIR1_PORT GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_DIR1_PIN GPIO_Pin_0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_DIR2_PORT GPIOE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> A_DIR2_PIN GPIO_Pin_8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_PULSE_PORT GPIOE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_PULSE_PIN GPIO_Pin_12 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_DIR1_PORT GPIOE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_DIR1_PIN GPIO_Pin_10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_DIR2_PORT GPIOE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> B_DIR2_PIN GPIO_Pin_14</span></span></code> </pre><br>  And we initialize them: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StepMotorSetup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB | RCC_AHBPeriph_GPIOE, ENABLE); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; GPIO_InitStructure.GPIO_Pin = A_PULSE_PIN; GPIO_Init(A_PULSE_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = B_PULSE_PIN; GPIO_Init(B_PULSE_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = A_DIR1_PIN; GPIO_Init(A_DIR1_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = B_DIR1_PIN; GPIO_Init(B_DIR1_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = A_DIR2_PIN; GPIO_Init(A_DIR2_PORT, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = B_DIR2_PIN; GPIO_Init(B_DIR2_PORT, &amp;GPIO_InitStructure); }</code> </pre><br>  In order to make 1 step the engine needs to turn on the motor windings in the necessary order, that is, to send control signals to the driver <br><br>  The mask of control signals is as follows: <br><pre> <code class="cpp hljs">u8 WireConFullStep[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">4</span></span>] = {{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre><br>  And now we take a step in the right direction.  The direction in this case is determined by the direction of detour by the mask of control signals: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_ResetBits(A_DIR1_PORT, A_DIR1_PIN); GPIO_ResetBits(A_DIR2_PORT, A_DIR2_PIN); GPIO_ResetBits(B_DIR1_PORT, B_DIR1_PIN); GPIO_ResetBits(B_DIR2_PORT, B_DIR2_PIN); GPIO_ResetBits(A_PULSE_PORT, A_PULSE_PIN); GPIO_ResetBits(B_PULSE_PORT, B_PULSE_PIN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WireConFullStep[index][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { GPIO_SetBits(A_DIR1_PORT, A_DIR1_PIN); GPIO_SetBits(A_PULSE_PORT, A_PULSE_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WireConFullStep[index][<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { GPIO_SetBits(A_DIR2_PORT, A_DIR2_PIN); GPIO_SetBits(A_PULSE_PORT, A_PULSE_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WireConFullStep[index][<span class="hljs-number"><span class="hljs-number">2</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { GPIO_SetBits(B_DIR1_PORT, B_DIR1_PIN); GPIO_SetBits(B_PULSE_PORT, B_PULSE_PIN); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WireConFullStep[index][<span class="hljs-number"><span class="hljs-number">3</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { GPIO_SetBits(B_DIR2_PORT, B_DIR2_PIN); GPIO_SetBits(B_PULSE_PORT, B_PULSE_PIN); } }</code> </pre><br><br>  For convenience, we define a step counterclockwise and a step clockwise: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CWStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DoStep(CurIndex); CurIndex+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurIndex &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) CurIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CCWStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DoStep(CurIndex); CurIndex-=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) CurIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  And now we will write a function, with the help of which we will rotate the engine for the required number of steps in the right direction: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Steps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 dir, s16 n)</span></span></span><span class="hljs-function"> </span></span>{ s16 i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dir) { CWStep(); udelay(<span class="hljs-number"><span class="hljs-number">15000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CCWStep(); udelay(<span class="hljs-number"><span class="hljs-number">15000</span></span>); } } }</code> </pre><br>  In this function, time delays are inserted so that the stepper motor has time to take a step before we send the command of the next step. <br><br>  The power in our hands is becoming more and more and we move on to the next stage - sending data to the PC and controlling the SD from the PC. <br><br><h4>  USB communication </h4><br>  To work with USB, I used one of the examples of working with USB, namely the VirtualComport_Loopback (look for the Internet in the STM32 USB-FS-Device development kit).  In this demo, the connected stm32 to the PC was defined as a virtual com-port, and sent back all received data.  Well, this is great for us!  We take this example, break the loop of exchange and voila - use it. <br><br>  The only problem that arose was that the application on .Net did not want to connect to the virtual com-port if the microprocessor constantly interrogated the sensor and sent the data to the PC (interestingly, the third-party Hercules program, which I used for debugging, perfectly opened the port).  Therefore, I decided to add the wait for pressing the User Button, after which the constant interrogation of sensors and the exchange of information with the PC had already begun. <br><br>  Actually, the following code came out: <br>  USB initialization: <br><pre> <code class="cpp hljs"> Set_System(); Set_USBClock(); USB_Interrupts_Config(); USB_Init();</code> </pre><br>  We wait until we click the User Button: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Data exhange via USB */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bDeviceState == CONFIGURED &amp;&amp; UserButtonPressed != <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } }</code> </pre><br>  Handler on pressing UserButton: <br><pre> <code class="cpp hljs">__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> UserButtonPressed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI0_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((EXTI_GetITStatus(USER_BUTTON_EXTI_LINE) == SET)&amp;&amp;(STM_EVAL_PBGetState(BUTTON_USER) != RESET)) { <span class="hljs-comment"><span class="hljs-comment">/* Delay */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">0x7FFFF</span></span>; i++); <span class="hljs-comment"><span class="hljs-comment">/* Wait for SEL button to be pressed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(STM_EVAL_PBGetState(BUTTON_USER) != RESET); <span class="hljs-comment"><span class="hljs-comment">/* Delay */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">0x7FFFF</span></span>; i++); UserButtonPressed++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButtonPressed &gt; <span class="hljs-number"><span class="hljs-number">0x2</span></span>) { UserButtonPressed = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Clear the EXTI line pending bit */</span></span> EXTI_ClearITPendingBit(USER_BUTTON_EXTI_LINE); } }</code> </pre><br><br><h4>  Conclusion </h4><br>  In this article, I lowered many of the points for pinouting and connecting devices to each other, circuit boards, and some other details (working with the ADC) and tried to focus on working with the periphery.  Unfortunately, the assembled working model was handed over to the university (hopefully, future generations will be interested in this work and continue it), with the result that I cannot demonstrate its work, but I still have several photos.  Here, for example, a photo when we conducted an experiment to determine the amplitude of the acceleration when moving the physical model of the vehicle along a sinusoidal surface with different stiffness of the air suspension. <br><img src="http://habrastorage.org/storage2/a47/80a/cec/a4780acecc409bf1f67589827156487b.jpg"><br><br>  I will also attach a project for IAR under STM32F3.  There is a lot of "bad" code there, as it was written mostly on the principle "just to make it work, and as soon as possible."  For any comments on the code, and not only, I will be grateful. <br><br>  <a href="">dl.dropboxusercontent.com/u/61862295/VirtualComport_Loopback.rar</a> <br><br>  I would like to express my gratitude to the university, which taught me a lot during these long 6 years, and to my diploma supervisor, who was moderately responsive and always helped me with ‚Äúscientific‚Äù activities. <br><img src="http://habrastorage.org/storage2/110/447/fc2/110447fc2a60dc33152cd7d0fddfea12.jpg"><br><br><h4>  Sources used: </h4><br>  1. STM32F3 Discovery kit firmware package, including 28 examples and preconfigured projects for 4 different IDEs <a href="http://www.st.com/web/en/catalog/tools/PF258154">www.st.com/web/en/catalog/tools/PF258154</a> <br>  2. Datasheets for all listed devices. </div><p>Source: <a href="https://habr.com/ru/post/183856/">https://habr.com/ru/post/183856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183846/index.html">We use a component from a standard Android application in our project.</a></li>
<li><a href="../183848/index.html">Beautiful CSS3 menu</a></li>
<li><a href="../183850/index.html">Musical rehearsals: now and through the Internet</a></li>
<li><a href="../183852/index.html">Convenient music download from vkontakte</a></li>
<li><a href="../183854/index.html">Introduction to Spring Frameworks: Spring MVC</a></li>
<li><a href="../183858/index.html">Keyboard input using IME</a></li>
<li><a href="../183862/index.html">SCO resumes litigation against IBM over UNIX rights</a></li>
<li><a href="../183864/index.html">NASA is asking for help in finding dangerous asteroids to neutralize them</a></li>
<li><a href="../183866/index.html">Watch MKV on Apple TV from Plex</a></li>
<li><a href="../183868/index.html">Add links to site pages in CKEDITOR 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>