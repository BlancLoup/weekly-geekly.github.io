<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Static) Selection of optimal containers in C ++ programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today I would like to talk again about static analysis. And again about C ++. But unlike PVS-Studio, we will not search for any errors in our p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Static) Selection of optimal containers in C ++ programs</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Today I would like to talk again about static analysis.  And again about C ++.  But unlike PVS-Studio, we will not search for any errors in our programs (although they are looking not only for errors), but for places that are not optimally written.  And one of these places is the choice of a container for data in the program.  If I am interested in you, then welcome under the cat! <br><a name="habracut"></a><br><h3>  Problem </h3><br>  At CoreHard 2018 Autumn (a very good conference, come) I told you that C ++ compilers are poorly optimized at the moment.  And <a href="https://www.youtube.com/watch%3Fv%3DdAmhGElNUX0%26t%3D1795s">one</a> of my complaints was that compilers cannot optimize the use of containers in our programs.  Let's look at a few code examples. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  It would seem that in such a simple case the compiler should be able to optimize this function and simply throw out a variable declaration of type std :: vector, since starting from C ++ 14 the compiler is allowed to remove dynamic memory allocations, but the compiler does not.  The reason is that at the moment only one C ++ compiler implements optimization for the removal of dynamic allocations - Clang.  All the other compilers just do not know how to do it yet.  But even Clang can do this in a limited number of cases. <br><br>  In this case, we could replace std :: vector with std :: array, provided that the size of the vector to be allocated is not too large, since we may simply not have enough stack for such a replacement.  Such a replacement will remove a rather expensive memory allocation on the heap, and the advantage is that when using std :: array, the compiler can already throw std :: array out of a function at all! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we are talking about performance optimization, I propose to consider the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In this case, we see the use of extremely inefficient in the case of std :: vector operation - insertion at the beginning of the container.  All C ++ programmers know that it is extremely bad to do, as it causes all elements to shift each time, which leads to high costs of copying / moving.  Much nicer in this case would be to replace std :: list, which doesn‚Äôt care where the insertion takes place, or std :: deque (although it is in this case you can perfectly see that you don‚Äôt just need to use insert. But this is just an example, not more :) <br><br>  Let's look at another sample code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In this case, we can notice that we can replace std :: list without pain (yes, I know that rarely anyone uses it) with std :: forward_list.  In this case, we will absolutely lose nothing, but we will get memory savings.  Naturally, the compiler now does not optimize them. <br><br>  A similar trick can also be done in the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Here we can see that what we really need is not std :: deque, but std :: stack.  You can‚Äôt call this optimization, because std :: stack is an adapter, and by default it uses std :: deque inside (unless the user specifies otherwise).  Here you can talk more about semantic optimization, i.e.  simplifying code to understand.  From my point of view, this is also important.  If you ask, ‚ÄúMaybe such a replacement also gives a performance boost?‚Äù, I will answer ‚ÄúMaybe.  See implementation details in your version of the standard library. ‚Äù <br><br>  Well, I think enough examples.  Each of you can come up with a lot of them too. <br><br><h3>  Means used </h3><br>  To implement the static analyzer, I used the Clang Static Analzyer (CSA) and Clang Tidy, which are included in the LLVM distribution.  I chose these tools, because I consider them the most promising among the open means of static analysis.  In addition, Clang provides one of the highest quality parsers of the C ++ language, which other static analyzers cannot boast of (unless of course they use libclang). <br><br>  Both CSA and Clang Tidy are static analyzers, both of which are part of LLVM.  What is the difference?  The difference is that Clang Tidy is designed to write simple checks, which basically consist in finding a pattern on an abstract syntax tree, displaying a warning and possibly replacing it automatically with another one.  You can read more about Clang Tidy <a href="https://www.youtube.com/watch%3Fv%3DWHgXn_ufY90">here</a> . <br><br>  CSA is designed to write more ‚Äúserious‚Äù and resource-intensive (both in terms of implementation and in terms of execution time / memory consumption) checks.  There, for example, a symbolic execution mechanism is available. <br><br>  I decided to implement the check in CSA, since it does not seem banal to me, moreover, in the future it will become harder and harder.  And it was decided to run through Clang Tidy, since this static analyzer has <a href="https://clang.llvm.org/extra/clang-tidy/Integrations.html">many</a> integrations with various IDEs. <br><br><h3>  How are we going to (try) to solve problems </h3><br>  First of all, it is worthwhile to introduce a couple of quite strong restrictions, which are mainly related to the fact that this is only a prototype so far: <br><br><ul><li>  Analysis only at the level of functions;  This restriction means that there will be no analysis between functions, as well as between translation units.  The restriction on the analysis between functions was imposed to simplify the implementation of this analysis and in the future can be relatively easily corrected by running a static analysis for the entire translation unit, and not just for each function.  The limitation on the analysis between translation units is imposed by the existing limitations in the CSA, which will soon be fixed (commits are already merging into the upstream); </li><li>  Support for only a limited number of containers.  This is relatively easily fixed in the future by adding new rules for new containers. </li><li>  Use for the analysis tree only abstract syntax.  Since prototyping is the simplest type of analysis.  For more accurate results, of course, you can try using at least a symbolic implementation, but this method has its drawbacks.  More details about the methods can be found <a href="https://www.viva64.com/ru/b/0592/">here</a> . </li></ul><br>  Now in the prototype the following simple algorithm is implemented: <br><br><ul><li>  First, in the abstract syntax tree, we find the vertices that are responsible for declaring container type variables that we support. </li><li>  Then we find the operations that relate to these containers, classify them and store this information in a temporary cache. </li><li>  After reaching the end of the function, we analyze the collected statistics and, based on the predefined rules, issue a recommendation on the use of a container. </li></ul><br>  The classification of operations on containers at the moment is as follows (will be expanded in the future): <br><br><ul><li>  Adding an item to the beginning of the container. </li><li>  Add an item to the middle of the container. </li><li>  Add an item to the end of the container. </li><li>  Remove item from the beginning of the container. </li><li>  Remove the item from the middle of the container. </li><li>  Remove item from end of container. </li></ul><br>  The classification is currently incomplete, and even this list does not work quite correctly.  For example, the insert operation, even if it is performed at the beginning, the analyzer classifies as an insert in the middle, although in fact this is not at all the case. <br><br><h3>  Combating False Positives </h3><br>  In any static analysis, the main headache is the false positives.  If there are too many, useful messages are lost in the trash.  Therefore, in this case we have to act very conservatively and issue warnings only in cases when we are really confident in our diagnostics and we can quite say that there is really something wrong in some place in the code. <br><br>  If we are talking about compiler optimization, then it is still sadder - correct optimization cannot change the behavior of the program according to the Standard C ++ (otherwise the cost to such an optimizer).  And pessimization should not introduce optimization either :) So here we have to be much more careful in our decisions. <br><br>  In this analyzer, this struggle resulted in the fact that if the analyzer sees that some unsupported operation is currently being performed, the analysis for this container is disabled. <br><br><h3>  Disadvantages and possible solutions </h3><br>  This method has several problems. <br><br>  The first problem is that for the analyzer at the moment all the code branches are equally probable.  More precisely, he does not even know about such a thing as different branches of code execution. <br>  This translates into problems with analysis for something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  Most likely, in our application, these code branches are not equal to the likelihood of execution, since in the real world, <b>usually the</b> pointer usually indicates something normal, and not nullptr.  In the same LLVM there are static heuristics on this account.  For example, it takes into account both the above case with comparing pointers with nullptr, and comparing each other for equality of the values ‚Äã‚Äãof two floating point variables, and some other interesting cases.  But it looks more and more like crutches, and from my point of view, the real solution to this problem is to add dynamic analysis or instrumentation. <br><br>  The second problem is the lack of support for custom containers.  We live in the world of C ++, they love cycling here (let's leave the discussion of the reasons for this not always a bad thing beyond the scope of this article) everything, including our containers.  Examples are all the same LLVM, LibreOffice and many others.  In this regard, the question arises - how to analyze and containers are not from the library STL?  After all, I would like to include analysis for as many containers as possible. <br><br>  There are different ways to solve the problem. <br><br>  The first is that the user annotates his containers in some way (a special kind of comment, C ++ attributes, something else).  With this method, the problem is that you need to understand how to conduct annotation in general, what information we need for a qualitative analysis.  Another problem may be the modification of the code of the containers themselves, which is not always possible. <br><br>  The second method offers the user a mechanism for writing their own rules.  At the moment, the analyzer has the rules embedded into the source code of the analyzer itself, and if the user wants to add his own rules, he will need to download the source code of the analyzer, build it, figure out how to write checks, write, rebuild, and so on.  You can provide the user with a way to set his checks on some DSL, where the user writes only checks for his containers, and the analyzer itself is engaged in the whole routine.  I consider this method as more promising than the previous one. <br><br>  Also, automatic replacement of containers is not supported, as this functionality is not in the CSA (but is in Clang Tidy).  But in difficult cases it is not always a trivial task to perform autochange, and the analyzer is more likely to work in a semi-manual mode. <br><br><h3>  Possible uses </h3><br>  I see several applications for this type of analysis: <br><br><ol><li>  As a static analyzer.  Everything is simple - another static analysis check that you run as your heart desires (by hand, automatically in the IDE during development, on CI, etc.), where you may be given a hint that somewhere you could pick up a better container. </li><li>  Like compiler optimization.  In some cases, we can guarantee that replacing the container will not adversely affect performance.  For example, replacing std :: vector for small sizes known at compile time for std :: array or replacing std :: list with std :: forward_list when we don‚Äôt need doubling and we don‚Äôt take the size from the list.  The compiler could replace containers with more optimal ones and without our knowledge, as it already does for a very large number of things. </li><li>  As a dynamic analyzer.  This is the direction that seems to me the most promising for this type of analysis.  After all, with the help of knowledge about the program execution profile, for example, we can get such important information for us as the probabilities of each code branch.  And this is necessary for a more accurate assessment.  And with such an analysis one can already think in the direction of integration with PGO ... </li></ol><br>  It is also worth noting that this method is applicable of course not only for C ++ programs.  I would really like to see this kind of static analysis \ optimization in the compiler and for other programming languages.  For example, the SAP static analyzer for ABAP already knows how to carry out a static analysis of optimality at a basic level, which is good news.  If you know similar projects for other programming languages ‚Äã‚Äã- write in the comments and I will add to the article! <br><br><h3>  Works in similar directions </h3><br>  For the world C ++, I have not found such analyzers anywhere.  For the ABAP world, I have already mentioned the analyzer above, which can find inefficient operations for some part of standard containers, but as far as I know, quite a simple static analysis is implemented there. <br><br>  Much more interesting work is <a href="http://www.cs.technion.ac.il/~yahave/papers/pldi09.pdf">Chameleon</a> - a dynamic analyzer for Java, which is very cleverly done.  They twirled the JVM a little, and during the work they collect various statistics on the use of containers, and depending on the current load profile they choose certain containers and replace them automatically during the work.  Unfortunately, the source is closed and there is no chance to get them (I tried). <br><br>  I also recommend looking at the various works (there are a lot of them) on <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25BB">SETL</a> .  In them, the authors also often raised questions about the automatic selection of the container. <br><br><h3>  Links </h3><br><ol><li>  Current implementation on <a href="https://github.com/ZaMaZaN4iK/llvm-project">GitHub</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DWHgXn_ufY90">C ++ Russia 2017: Yuri Efimochev, clang-tidy: a journey inside C ++ Abstract Syntax Tree</a> </li><li>  <a href="http://www.cs.technion.ac.il/~yahave/papers/pldi09.pdf">Chameleon: Adaptive Selection of Collections</a> </li><li>  <a href="https://github.com/haoNoQ/clang-analyzer-guide">Clang Static Analyzer guide</a> </li><li>  <a href="https://t.me/CompilerDev">Russian-language chat</a> on the development of compilers in the Telegram.  If you are interested - go, it is very interesting there.  Just be careful with flood - they immediately punish him :) </li></ol><br>  Instead of a conclusion, I would like to focus on the fact that this is only a prototype so far and it has too many ‚Äúholes‚Äù in its implementation.  In this article, I just want to share with you the idea of ‚Äã‚Äãsuch an analysis and its popularization.  Well, maybe someone will be interested in this topic and there will be a desire to connect to the project - I will be just happy!  In addition, you can always collect this analyzer from yourself to try it on your test examples. <br><br>  If you have something to supplement the material, faced with a similar task, or simply have some information that may be useful on this topic - please do not hesitate and share this information in the comments. <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/455379/">https://habr.com/ru/post/455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455369/index.html">Certification of database administrators and much more on the anniversary DevConfX (June 21-22 in Moscow)</a></li>
<li><a href="../45537/index.html">About Fallout 3, modifications and additions</a></li>
<li><a href="../455371/index.html">Stable current source from 5 ŒºA to 20 mA</a></li>
<li><a href="../455373/index.html">How to adjust the law of Spring to make it lifting for small providers? Cancel it</a></li>
<li><a href="../455377/index.html">IoT architecture</a></li>
<li><a href="../455381/index.html">Technical support 3CX responds: seizure of SIP-traffic on the PBX server</a></li>
<li><a href="../455383/index.html">How to start programming a newbie for free</a></li>
<li><a href="../455387/index.html">Understanding Machine Learning in the Elastic Stack (aka Elasticsearch, aka ELK)</a></li>
<li><a href="../455389/index.html">Haxe 4: What's new?</a></li>
<li><a href="../45539/index.html">The Japanese have released a browser with three engines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>