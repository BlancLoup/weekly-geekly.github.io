<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qualifying round of the Russian Code Cup 2014: results and analysis of tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last Sunday, the qualifying round of the Russian Code Cup 2014 took place. It was attended by 802 programmers, who showed the best results in four qua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qualifying round of the Russian Code Cup 2014: results and analysis of tasks</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/mailru/blog/225743/"><img src="https://habrastorage.org/getpro/habr/post_images/dec/5a0/582/dec5a0582fb8e2e9dee2d9433a3b6b23.jpg"></a> <br><br>  Last Sunday, the qualifying round of the <a href="http://www.russiancodecup.ru/">Russian Code Cup 2014</a> took place.  It was attended by 802 programmers, who showed the best results in four qualifications.  At this stage, the participants had to solve six problems in 3 hours, which is one hour and one task more than in the qualifying rounds.  And the tasks were significantly more complicated than the previous ones.  During the competition of the 802-x only 444 participants were able to solve at least one problem.  A total of 3271 solutions were sent, of which 1402 were correct. <br><a name="habracut"></a><br>  Most solutions on GNU C ++ - 1516. <br>  Java 7 solutions - 333. <br>  Java solutions 8 - 106. <br><br>  The first task A was solved by Gennady Korotkevich (tourist) in 2:52 minutes.  Gennady also solved problems B, C, and D at 7:05, 24:29, and 13:05 minutes, respectively.  Task E was first solved by Dmitry Egorov (Dmitry_Egorov) at 40:59 minute.  Task F was one of the most difficult in the entire history of the Russian Code Cup - of all the participants, only three people solved it correctly, and the first task F was solved by the winner of the RCC 2013 Peter Mitrichev (Petr) for 2:25:46. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Pavel Kunyavsky (PavelKunyavskiy) was the first to handle all the tasks in 2 hours and 47 minutes.  Only 6 tasks were solved by 3 people, 100 people solved 5 and more problems.  The last in the cherished top 50 was Roman Bilyi (RomaWhite), who passed the fifth task 2 hours 30 minutes after the start. <br><br>  For the will to win, we note Egor Kulikov (Egor), who entered the top 50, having passed one of the tasks on his 7th attempt.  As well as Petr Mitrichev (Petr), who, not thinking up how to solve task C, refused to try to solve it, first solved the most difficult task F. And then, returning to task C, he passed it 4 minutes before the end and finally took 3 a place. <br><br>  The territorial distribution of participants in this round was as follows: <br><table><tbody><tr><td>  Russia </td><td>  515 </td></tr><tr><td>  Ukraine </td><td>  112 </td></tr><tr><td>  Belarus </td><td>  77 </td></tr><tr><td>  Kazakhstan </td><td>  26 </td></tr><tr><td>  USA </td><td>  17 </td></tr><tr><td>  Armenia </td><td>  eight </td></tr><tr><td>  Uzbekistan </td><td>  eight </td></tr><tr><td>  Switzerland </td><td>  6 </td></tr><tr><td>  Germany </td><td>  four </td></tr><tr><td>  Latvia </td><td>  four </td></tr><tr><td>  Austria </td><td>  2 </td></tr><tr><td>  Bulgaria </td><td>  2 </td></tr><tr><td>  Great Britain </td><td>  2 </td></tr><tr><td>  Georgia </td><td>  2 </td></tr><tr><td>  Moldova </td><td>  2 </td></tr><tr><td>  Poland </td><td>  2 </td></tr><tr><td>  Republic of Singapore </td><td>  2 </td></tr><tr><td>  Azerbaijan </td><td>  one </td></tr><tr><td>  Argentina </td><td>  one </td></tr><tr><td>  Ireland </td><td>  one </td></tr><tr><td>  Canada </td><td>  one </td></tr><tr><td>  Cyprus </td><td>  one </td></tr><tr><td>  Lithuania </td><td>  one </td></tr><tr><td>  The Republic of Korea </td><td>  one </td></tr><tr><td>  Slovakia </td><td>  one </td></tr><tr><td>  Turkey </td><td>  one </td></tr><tr><td>  Sweden </td><td>  one </td></tr><tr><td>  Japan </td><td>  one </td></tr></tbody></table>  At the same time for the first time in the Russian Code Cup were participants who do not know the Russian language from Austria, Argentina and Japan!  As one of them admitted, he translated the conditions of the tasks of the round through online translation services. <br><br>  The fight in the qualifying round was tense.  As a result, 50 strongest programmers reached the final.  We will tell about them in detail later. <br><br>  <b>Task A. <a href="https://www.russiancodecup.ru/championship/round/9/problem/A/">Analysis of tasks</a></b> <br><br>  <b>Idea:</b> Anna Malova <br>  <b>Realization:</b> Andrey Komarov <br>  <b>Analysis:</b> Andrey Komarov <br><br>  In the task it is required to make a plan for the analysis of the tasks so that the total duration of the analysis is minimal.  Tasks must understand in order from first to <i>m</i> th.  The time to parse one task is <i>t</i> seconds.  Replacing the jury member who is reviewing the task is <i>c</i> seconds.  If the same jury member deals with several tasks in a row, then replacement is not required.  About each member of the jury it is known which tasks he wants to disassemble, and which - no. <br><br>  This problem is solved by a greedy algorithm.  Choose a jury member who is able to solve the maximum number of tasks, starting with the first one.  Let him know how to solve <i>k</i> problems.  Then, choose one who knows how to solve the maximum number of tasks, starting with the <i>kth</i> .  We will continue this way until all the tasks are resolved.  Then the answer to the problem is <i>m ¬∑ t + q ¬∑ c</i> , where <i>q</i> is the number of substitutions made. <br><br>  Why is this the best answer?  Suppose that at some point a jury member was chosen who wants to analyze not the maximum number of tasks.  Then, from the fact that it will be replaced by someone who knows how to disassemble more and give it more to disassemble, the answer can only improve. <br><br>  This solution works for <i>O (n ¬∑ m).</i> <br><br>  You could also write a simple solution using dynamic programming.  <i>dp</i> [ <i>i</i> ] [ <i>j</i> ] is equal to the minimum time that is spent if I have analyzed the tasks and the <i>i-</i> th has analyzed the <i>j-</i> th jury member.  This array can be easily calculated as <i>O (n <sup>2</sup> m)</i> . <br><br>  <b>Problem B. <a href="https://www.russiancodecup.ru/championship/round/9/problem/B/">On a distant Amazon</a></b> <br><br>  <b>Idea:</b> Vitaly Aksenov <br>  <b>Implementation:</b> Demid Kucherenko <br>  <b>Analysis:</b> Demid Kucherenko <br><br>  In this task, it is necessary to construct a directed graph consisting of <i>n</i> vertices, in which the following conditions are satisfied: <br><ul><li>  there should be no cycles in the column; </li><li>  a maximum of one edge leads to each vertex; </li><li>  the graph must have exactly <i>a</i> vertices from which outgoing edges exist; </li><li>  the graph must have exactly <i>b</i> vertices into which incoming edges exist. </li></ul><br>  To begin with, let's look at cases when the answer is ‚ÄúIMPOSSIBLE‚Äù.  These are cases when at least one of the following conditions is met: <br><ul><li>  there are more mothers than daughters; </li><li>  mothers are greater than <i>n</i> -1 (all cannot be mothers); </li><li>  daughters are greater than <i>n</i> -1. </li></ul><br>  If such a graph can be constructed, then first we construct a chain of <i>a</i> edges.  So we will have <i>a</i> +1 woman involved, and there will be <i>a</i> mothers and <i>a</i> daughters.  After that, we supplement the daughters of any mothers so that the daughters become exactly <i>b</i> .  It may happen that some women are neither mothers nor daughters, but this does not contradict the condition of the problem. <br><br>  <b>Problem C. <a href="https://www.russiancodecup.ru/championship/round/9/problem/C/">Laboratory in Physics</a></b> <br><br>  <b>Idea:</b> Vitalik Aksenov <br>  <b>Realization:</b> Artem Vasilyev <br>  <b>Analysis:</b> Artem Vasilyev <br><br>  In this task, it is required to determine what water temperature can be obtained by mixing water from two vessels with cold and hot water.  It was necessary to respond to several such requests at a given temperature. <br><br>  We write the water temperature formula if we mix cold water from a vessel with volume <i>c <sub>i</sub></i> and hot water from a vessel with volume <i>h <sub>j</sub> : T = p / q = (C ¬∑ c <sub>i</sub> + H ¬∑ h <sub>j</sub> ) / (c <sub>i</sub> + h <sub>j</sub> )</i> this formula, we get that <i>(H ¬∑ q - p) / (p - C ¬∑ q) = c <sub>i</sub> / h <sub>j</sub></i> Thus, we reduced the problem to the following: an irreducible fraction and a set of numerators and denominators are given, is it possible to choose the numerator and denominator to get a given fraction? <br><br>  We introduce the notation <i>A <sub>x</sub></i> - the set of all <i>c <sub>i</sub></i> / x, where <i>c <sub>i</sub></i> is divisible by <i>x</i> .  Similarly, <i>B <sub>y</sub></i> is the set of all <i>h <sub>i</sub></i> / y, where <i>h <sub>i</sub></i> is divisible by <i>y</i> .  Then the irreducible fraction <i>p / q</i> can be represented if and only if <i>A <sub>p</sub></i> and <i>B <sub>q</sub></i> intersect.  It should be noted that the total size of all sets <i>A <sub>x</sub></i> and <i>B <sub>y</sub></i> is <i>O</i> ( <i>M</i> log <i>M</i> ), where <i>M</i> is the limit on the volume of vessels (in this problem, <i>M</i> is 10 <sup>5</sup> ). <br><br>  When <i>A <sub>x</sub></i> and <i>B <sub>y are</sub></i> represented as sorted lists, one query can be executed for <i>O (M / max (x, y))</i> .  If we represent <i>A <sub>x</sub></i> and <i>B <sub>y</sub></i> as bit sets, then we get a solution in <i>O</i> ( <i>M</i> / 64) per request. <br><br>  The quickest solution is obtained, except for the answers for the same fraction several times.  In this case, it is possible to prove a more accurate estimate for the time the solution works.  Let us prove the estimate <i>O ((M + k) sqrt (M))</i> , where <i>k</i> is the number of queries.  If the maximum of <i>p</i> and <i>q is</i> greater than <i>sqrt (M)</i> , then the query can be executed in <i>O (sqrt (M))</i> by looking at all the elements of the smaller one from the sets.  We estimate the sum of the execution times of all other queries.  Requests running in <i>O (M / x) are</i> no more than 2 <i>x</i> .  Summing over all x, and taking into account that x is not greater than <i>sqrt (M)</i> , we get the estimate <i>O ((M + k) sqrt (M)) The</i> total running time of the solution: <i>O ((M + k) sqrt (M))</i> . <br><br>  <b>Task D. <a href="https://www.russiancodecup.ru/championship/round/9/problem/D/">Designing saws</a></b> <br><br>  <b>Idea:</b> Nikolay Vedernikov <br>  <b>Realization:</b> Nikolay Vedernikov <br>  <b>Analysis:</b> Nikolay Vedernikov <br><br>  The task requires counting the number of permutations, such that: <br><ul><li>  <i>a <sub>2 ¬∑ i</sub></i> <sub>-1</sub> ‚â§ <i>a <sub>2 ¬∑ i</sub></i> </li><li>  <i>a <sub>2 ¬∑ i</sub></i> ‚â• <i>a <sub>2 ¬∑ i + 1</sub></i> </li></ul><br>  For all <i>i</i> from 1 to <i>n</i> ‚ÅÑ 2. We call such a permutation an <i>increasing sawtooth</i> . <br><br>  Note that the number of such permutations is equal to the number of permutations that have numbers in odd positions that are larger than their neighbors.  Bijective correspondence: <i>b <sub>i</sub> = n - a <sub>i</sub></i> .  We call such a permutation a decreasing sawtooth.  This is useful to us further to solve the problem. <br><br>  Obviously, if the length of the permutation is 0 or 1, then the answer is 1. <br><br>  Suppose we know the answer for all lengths from 0 to <i>n</i> , find the answer for <i>n</i> +1.  We will consider the total number of sawtooth sequences.  In order to get the number of increasing, you need to divide the total number of sequences by 2, since the number of increasing is equal to the number of decreasing. <br><br>  Let <i>n</i> +1 be put on the position 2 ¬∑ <i>k</i> , then first we have an increasing saw-tooth with a length of 2 ¬∑ <i>k</i> ‚àí1, and then an increasing length with a length of <i>n</i> ‚àí2 ¬∑ <i>k</i> +1.  For the first 2 ¬∑ <i>k</i> ‚àí1 positions, we can choose any of the <i>n</i> numbers.  Total, we find that the number of permutations of length <i>n</i> +1, for which the number <i>n</i> +1 is at the position 2 ¬∑ <i>k</i> : <i>ans</i> <sub>2 ¬∑</sub> <sub><i>k</i> ‚àí1</sub> ¬∑ <i>ans</i> <sub><i>n</i> ‚àí2 ¬∑ <i>k</i> +1</sub> ¬∑ <i>Binom</i> ( <i>n</i> , 2 ¬∑ <i>k</i> ‚àí1) . <br><br>  Let <i>n</i> +1 be put on the position 2 ¬∑ <i>k</i> +1, then first we have a decreasing sawtooth with a length of 2 ¬∑ <i>k</i> , and then an increasing length of <i>n</i> ‚àí2 ¬∑ <i>k</i> .  For the first 2 ¬∑ <i>k</i> positions, we can choose any of the <i>n</i> numbers.  In total, we find that the number of permutations of length <i>n</i> +1, for which the number <i>n</i> +1 in the position 2 ¬∑ <i>k</i> +1 is: <i>ans</i> <sub>2 ¬∑ <i>k</i></sub> ¬∑ <i>ans</i> <sub><i>n</i> ‚àí2 ¬∑ <i>k</i></sub> ¬∑ <i>Binom</i> ( <i>n</i> , 2 ¬∑ <i>k</i> ). <br><br>  Total, the total number of sawtooth sequences of length <i>n</i> +1: <i>ans</i> <sub><i>n</i> +1</sub> = ‚àë <sup><i>n</i></sup> <sub><i>k</i> = 0</sub> <i>ans</i> <sub><i>k</i></sub> ¬∑ <i>ans</i> <sub><i>n ‚àí k</i></sub> ¬∑ <i>Binom (n, k)</i> . <br><br>  <b>Task E. <a href="https://www.russiancodecup.ru/championship/round/9/problem/E/">Salary</a></b> <br><br>  <b>Idea:</b> Anna Malova <br>  <b>Realization:</b> Pavel Krotkov <br>  <b>Analysis:</b> Pavel Krotkov <br><br>  In this problem, a directed graph is given.  All edges could be classified into three parts: <br><ul><li>  in any arrangement of salaries and bonuses at the vertices of this edge, the condition of leadership will be fulfilled; </li><li>  to fulfill the conditions of the leadership, it is necessary either to change the salary with a bonus in both tops of this edge, or not to change on one; </li><li>  to fulfill the conditions of the leadership, it is necessary to change the salary with a bonus at exactly one of the vertices of this edge. </li></ul><br>  Let us forget about all the edges of the first type and about the orientation of the edges of the second and third types.  After this, we merge the vertices reachable from each other along edges of the second type.  After this, the task of checking whether the requirement of the manual can be fulfilled reduces to checking whether the resulting graph can be colored in two colors, which can be solved by a detour in depth. <br><br>  To obtain the minimum number of vertices in which you need to swap salary with a bonus, modify this depth-first search.  After traversing and coloring in two colors of the next connected component, we calculate the number of vertices (of the original graph, before combining by edges of the second type) painted in the same color, and, if necessary, invert the coloring. <br><br>  <b>Problem F. <a href="https://www.russiancodecup.ru/championship/round/9/problem/F/">Robot</a></b> <br><br>  <b>Idea:</b> Boris Minaev <br>  <b>Realization:</b> Boris Minayev, Artem Vasiliev <br>  <b>Analysis:</b> Boris Minayev, Artem Vasilyev <br><br>  The task is to calculate the number of different paths from one cell of the field to another in a certain number of steps.  At the same time, a robot that performs actions cannot visit the final cell earlier than the last turn.  Also, the robot can only walk one quarter of an infinite plane. <br><br>  First, let's find the number of ways to get from one cell to another without the condition that you cannot visit the final cell before the last turn.  Such a task can be solved independently according to the coordinates, and then go through how many moves were performed on one coordinate, and how many on the other.  How to solve a problem in a one-dimensional case?  Let the robot initially have a coordinate <i>x <sub>1</sub></i> , and at the end should have a coordinate <i>x <sub>2</sub></i> .  Let <i>a</i> = |  <i>x <sub>2</sub></i> - <i>x <sub>1</sub></i> |, and in total <i>t</i> moves were made.  Then the number of different methods will be equal to the number of combinations of <i>t</i> for ( <i>t</i> - <i>a</i> ) / 2 (in this case, <i>t</i> - <i>a</i> must be non-negative and even).  However, it should be noted that the robot can only have a positive coordinate in the process of traveling.  To do this, simply subtract from the result the number of ways to get out of the cell - <i>x <sub>1</sub></i> to <i>x <sub>2</sub></i> .  This is true, since between the paths from <i>x <sub>1</sub></i> , which violate the requirement of the positivity of the coordinate, as well as all the paths from - <i>x <sub>1,</sub></i> one-to-one correspondence can be shown.  The paths corresponding to each other will have mirror first parts (until the entrance to cell 0) and common second parts. <br><br>  Let us return to the consideration of the two-dimensional problem.  Suppose we have already counted the number of ways to get to each coordinate from one cell to another (for each fixed length of the journey).  To calculate similar values ‚Äã‚Äãfor a two-dimensional task, you need to sort out the amount of time spent on each coordinate, and then multiply the corresponding values ‚Äã‚Äãin the already calculated arrays, and also multiply by the number of different ways to choose which moves will correspond to which coordinates.  To calculate these values ‚Äã‚Äãquickly, you can use the Fourier transform.  To reduce the problem to the multiplication of polynomials, it is necessary to get rid of the presence in the formula of the number of combinations.  To do this, write it through factorials.  By grouping the terms, we get that we can divide the <i>i-</i> th elements of the original arrays by <i>i</i> !, Multiply the resulting polynomials, and then multiply the value in the <i>i-</i> th digit by <i>i</i> !  In the task, the module on which it is necessary to perform all operations was chosen in such a way that it can be used to perform a fast Fourier transform. <br><br>  Now consider how to take into account the fact that the robot can not enter the final cell until the last turn.  We will consider the answer using dynamic programming.  Let the number of ways to reach the cell in less than <i>t</i> moves be counted.  To calculate this value for <i>t</i> moves, consider the total number of ways to do it in <i>t</i> moves and subtract from it all the methods that go into the final cell before turn <i>t</i> .  To do this, let's go through the number of the first move, in which the robot visits the final cell and multiply the corresponding number of ways by the number of ways to get out of the cell ( <i>x <sub>2</sub> , y <sub>2</sub></i> ) and return to it in the remaining time.  At the same time, the robot can visit the final cell as many times as necessary (in the second part). <br><br>  Note that the solution described above works for <i>t <sup>2</sup></i> .  For a faster solution, you should reason in terms of generating functions.  Denote <i>f (x) = f <sub>0</sub> x <sup>0</sup> + f <sub>1</sub> x <sup>1</sup> +‚Ä¶ + f <sub>t</sub> x <sup>t</sup> + ...</i> , where <i>f <sub>i</sub></i> is not the answer.  Similarly, we define <i>count (x)</i> - the generating function for the number of paths, without taking into account the condition of the first entry into the final cell on the last turn, <i>cycle (x)</i> - generating function for the number of paths from the final cell to itself.  From the recurrence relations for <i>f <sub>i</sub></i> , we can derive the relation to the generating functions: <i>f (x) = count (x) - f (x) cycle (x)</i> , whence <i>f (x) = count (x) / (cycle (x) + 1) = count (x) (cycle (x) + 1) <sup>-1</sup></i> .  To calculate <i>f,</i> it is necessary to calculate the first <i>t</i> + 1 terms of the fraction on the right-hand side.  This can be done by calculating the inverse of <i>cycle (x)</i> + 1 polynomial modulo <i>x <sup>t + 1</sup></i> , and multiplying <i>count (x)</i> with the result.  Taking the inverse polynomial modulo <i>x <sup>t + 1</sup></i> can be performed in <i>O</i> ( <i>t</i> log <i>t</i> ) time using the fast Fourier transform.  Total running time: <i>O</i> ( <i>t</i> log <i>t</i> ). </div><p>Source: <a href="https://habr.com/ru/post/225743/">https://habr.com/ru/post/225743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225723/index.html">How to use Tomita-parser in your projects. Practical course</a></li>
<li><a href="../225727/index.html">Swift + CoreData + A bit of a file</a></li>
<li><a href="../225735/index.html">ZeptoLab and Codeforces join forces</a></li>
<li><a href="../225739/index.html">NASA Announces Mars Design Competition</a></li>
<li><a href="../225741/index.html">UK rewrites the rules of the road under the "robot"</a></li>
<li><a href="../225745/index.html">Python, tone shift and Pianoputer</a></li>
<li><a href="../225749/index.html">Do I need support LaTeX on Habr√©?</a></li>
<li><a href="../225751/index.html">Creating audio plug-ins, part 4</a></li>
<li><a href="../225755/index.html">Creating audio plug-ins, part 5</a></li>
<li><a href="../225757/index.html">The controversy around high-frequency trading is gaining momentum again</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>