<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to unleash the power of HTML5 Canvas for games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTML5-enabled browsers and the HTML5 platform for Windows 8 Metro are today becoming serious candidates for developing modern games. 

 Thanks to canv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to unleash the power of HTML5 Canvas for games</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/c75/781/380/c757813808343e4fa69f23631d284c92.png"><br><br>  HTML5-enabled browsers and the HTML5 platform for Windows 8 Metro are today becoming serious candidates for developing modern games. <br><br>  Thanks to canvas, you have access to a hardware-accelerated surface on which you can display the content of your game and with the help of some tricks and tricks you can achieve excellent rendering performance up to 60 frames per second.  Such continuity is really important in games, because the smoother the game (animation), the better the player feels. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The purpose of this article is to give you some tips on how to get the most out of HTML5 Canvas.  The article consists of two main parts [you read the first].  <a href="http://blogs.msdn.com/davrous">David Rousset</a> will soon publish the second part. <br><br>  In the article, I will show the key ideas on the same example - this is the effect of a 2D tunnel that I wrote for the <a href="http://video.fr.msn.com/watch/video/techdays-2012-session-technique-coding4fun/zqy7cm8l">Coding4Fun</a> session at TechDays 2012 in France. <br><a name="habracut"></a><br><br>  I was inspired to write this effect by my code for Commodore AMIGA, which I wrote when I was a young author of the demoscene in the distant 80s :).  Today it uses only <b>canvas</b> and <b>Javascript</b> , although the original code was based only on 68000 assembler: <br><br> <a href="http://jsfiddle.net/nxjSR/1/"><img src="http://img-fotki.yandex.ru/get/6004/25193168.12/0_56894_7c2ee3e9_XL.jpg"></a> <br>  <a href="http://jsfiddle.net/nxjSR/1/">Example on JSFiddle</a> (note that the texture is wired into the code). <br><br>  The full code is available for download here: <a href="">http://www.catuhe.com/msdn/canvas/tunnel.zip</a> ( <a href="http://narod.ru/disk/45280929001.6a6038cf0bc275d991420fc17590ca48/tunnel.zip.html">copy to J.Narod</a> ). <br><br>  The purpose of this article is to explain not how the tunnel is programmed, but how you can take the existing code and optimize it in order to achieve the best real-time performance. <br><br><h2>  Using hidden canvas to read image data </h2><br>  The first thing I want to talk about is how you can use canvas to optimize the reading of image data.  Indeed, in almost every game you need graphics for sprites or background images.  Canvas has a very convenient method for drawing images: <i>drawImage</i> .  This function can be used to display a sprite to the canvas element, since you can specify the source and destination areas for drawing. <br><br>  But sometimes this is not enough.  For example, when you want to apply some effects to the original image.  Or when the original image is not just a picture, but a more complex resource for your game (for example, the map from which you need to read data). <br><br>  In such cases, you need access to internal image data.  But the <i>image</i> tag does not provide a way to read the contents.  This is where canvas comes to the rescue! <br><br>  In essence, every time you need to read the contents of an image, you can use an invisible (non-displayable) canvas.  The key idea is to load the image, and when it is loaded, you just have to map it to the canvas element that is not inserted into the DOM.  You now have access to [copied] pixels of the original image through the corresponding pixels of the canvas (which is very simple). <br><br>  The code for this technique is as follows (used in the 2D tunnel effect to read the tunnel texture): <br><br><pre><code class="hljs coffeescript">var loadTexture = function (name, <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>) { var texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); var textureData; var textureWidth; var textureHeight; var result = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span> load texture.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, function () { var textureCanvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>-screen canvas <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Setting the canvas to right size textureCanvas.width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;-- <span class="hljs-string"><span class="hljs-string">"this"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the image textureCanvas.height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height; result.width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width; result.height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height; var textureContext = textureCanvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); textureContext.drawImage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); result.data = textureContext.getImageData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height).data; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(); }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Loading texture.src = name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; };</code> </pre> <br><br>  When using this code, keep in mind that the texture is loaded asynchronously, so you need to pass a function through the <i>then</i> parameter to continue working your code: <br><br><pre> <code class="hljs lua">// Texture var texture = loadTexture(<span class="hljs-string"><span class="hljs-string">"soft.png"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // Launching the render QueueNewFrame(); });</code> </pre> <br><br><h2>  Using the hardware scaling feature </h2><br>  Modern browsers and Windows 8 support canvas <strong>hardware acceleration</strong> .  This means, in particular, that you can use the <strong>GPU</strong> to scale content on canvas. <br><br>  In the case of the 2D tunnel effect, the algorithm requires processing each pixel of the canvas.  For example, for canvas with a size of 1024x768, it is necessary to process 786432 pixels.  To ensure the continuity of the display, it must be done 60 times per second, which corresponds to the processing of <strong>471,85920</strong> pixels per second! <br><br>  Obviously, any solution that helps you <strong>reduce the</strong> number of pixels will result in a noticeable performance <strong>improvement</strong> . <br><br>  I repeat, canvas provides such a tool!  The following code shows how to use hardware acceleration to scale the internal canvas buffer to the external size of the DOM object: <br><br><pre> <code class="hljs pgsql">// Setting hardware scaling canvas.width = <span class="hljs-number"><span class="hljs-number">300</span></span>; canvas.style.width = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.innerWidth + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">200</span></span>; canvas.style.height = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.innerHeight + <span class="hljs-string"><span class="hljs-string">'px'</span></span>;</code> </pre> <br><br>  Note the difference between the size of the DOM object ( <i>canvas.style.width</i> and <i>canvas.style.height</i> ) and the size of the canvas working <i>buffer</i> ( <i>canvas.width</i> and <i>canvas.height</i> ). <br><br>  If there is a difference between these two sizes, the capabilities of iron are used to scale the working buffer ‚Äî in our case, this is just a great function: we can work at a lower resolution and allow the GPU to scale the result to fill the DOM object (using the excellent free blur filter to smooth the result ). <br><br>  In this example, the rendering is in the 300x200 area, and the GPU scales to fit your window. <br><br>  This feature is widely supported by all modern browsers, so you can count on it. <br><br><h2>  Rendering cycle optimization </h2><br>  When you develop a game, you probably should have a rendering cycle in which you draw all the components of the game (background, sprites, glasses, etc.).  This loop is a bottleneck in your code and should be as optimized as possible to make sure your game runs quickly and smoothly. <br><br><h3>  RequestAnimationFrame </h3><br>  One of the interesting features that came with HTML5 is the <i>window.requestAnimationFrame</i> function.  Instead of using <i>window.setInterval</i> to create a timer that calls your draw cycle every (1000/16) milliseconds (to achieve the cherished 60fps), you can delegate this responsibility to the browser using <i>requestAnimationFrame</i> .  Calling this method says that you want the browser to call your code as soon as it is possible to update the graphical representation. <br><br>  The browser will turn on your request inside its drawing schedule and synchronize you with its drawing and animation code (CSS, transitions, etc.).  This solution is also interesting due to the fact that your code will not be called when the window is not visible (minimized, completely blocked, etc.). <br><br>  This can help with performance, since the browser can optimize parallel rendering (for example, if your rendering cycle is too slow) and still produce smooth animations. <br><br>  The code is pretty obvious (note the use of browser prefixes): <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intervalID = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> QueueNewFrame = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame) <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame(renderingLoop); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.msRequestAnimationFrame) <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.msRequestAnimationFrame(renderingLoop); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRequestAnimationFrame) <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRequestAnimationFrame(renderingLoop); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRequestAnimationFrame) <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRequestAnimationFrame(renderingLoop); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.oRequestAnimationFrame) <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.oRequestAnimationFrame(renderingLoop); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { QueueNewFrame = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; intervalID = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setInterval(renderingLoop, <span class="hljs-number"><span class="hljs-number">16.7</span></span>); } };</code> </pre> <br>  To use this function, you just need to call it at the end of your draw cycle to subscribe to the next frame: <br><br><pre> <code class="hljs matlab">var renderingLoop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueueNewFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; };</span></span></code> </pre> <br><br><h3>  DOM Access (Document Object Model) </h3><br>  To optimize your rendering cycle, you should use at least one golden rule: DO NOT TAKE A DOM.  Although modern browsers are specifically optimized in this place, reading the properties of DOM objects is still too slow for a fast rendering cycle. <br><br>  For example, in my code, I used the Internet Explorer 10 profiler ( <strong>available in the F12 developer tools</strong> ) and the results are obvious: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4dc/06b/79e/4dc06b79e3044531765fe2e468fc2f6f.png" alt="performance DOM"></a> <br><br>  As you can see, accessing the width and height of the canvas takes a very long time in the rendering loop! <br><br>  The original code looked like this: <br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderingLoop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = -canvas.height / <span class="hljs-number"><span class="hljs-number">2</span></span>; y &lt; canvas.height / <span class="hljs-number"><span class="hljs-number">2</span></span>; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = -canvas.width / <span class="hljs-number"><span class="hljs-number">2</span></span>; x &lt; canvas.width / <span class="hljs-number"><span class="hljs-number">2</span></span>; x++) { ... } } };</code> </pre> <br><br>  You can replace the canvas.width and canvas.height properties with two variables with the correct values ‚Äã‚Äãset in advance: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderingLoop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = -<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">canvasHeight</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; y &lt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">canvasHeight</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = -<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">canvasWidth</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; x &lt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">canvasWidth</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; x++) { ... } } };</code> </pre> <br><br>  Simple, isn't it?  It may not be very easy to understand, but believe me, it is worth a try! <br><br><h3>  Preliminary calculations </h3><br>  According to the profiler, the <i>Math.atan2</i> function is somewhat slow.  In fact, this operation is not embedded inside the CPU, so the JavaScript runtime must do some operations to calculate the result. <br><br>  <i>[Lane. Although, from a technical point of view, it can be assumed that a specific implementation of the JS-runtime can rely on the hardware instruction fpatan, no one guarantees a priori.</i>  <i>The ECMAScript5 specification for mathematical functions suggests that they are (obviously) approximations and recommends using the algorithms of the Sun Microsystems mathematical library (http://www.netlib.org/fdlibm).</i>  <i>In any case, whatever the implementation of the atan2 function, it does not make it <a href="">elementary</a> and fast.]</i> <br><br> <a href=""><img src="http://img-fotki.yandex.ru/get/6204/25193168.11/0_5686e_adc8616b_L.jpg" alt="performance atan2"></a> <br><br>  In general, if you can arrange a preliminary calculation for some long-running code, it is always a good idea.  Here, before starting my rendering cycle, I calculate the values ‚Äã‚Äãfor <i>Math.atan2</i> : <br><br><pre> <code class="hljs pgsql">// precompute arctangent var atans = []; var <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = -canvasHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>; y &lt; canvasHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = -canvasWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>; x &lt; canvasWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>; x++) { atans[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++] = Math.atan2(y, x) / Math.PI; } }</code> </pre> <br><br>  The <i>atans</i> array <i>can</i> then be used inside the draw loop for an obvious increase in performance. <br><br><h3>  Avoid using Math.round, Math.floor and parseInt </h3><br>  The point about using <i>parseInt</i> makes sense in our case: <br> <a href=""><img src="http://img-fotki.yandex.ru/get/6105/25193168.12/0_56871_1726d9fe_L.jpg" alt="performance parseInt"></a> <br><br>  When you work with canvas, you need to use integer coordinates (x and y) to point to the pixels.  However, all your calculations are made using floating point numbers and sooner or later you will need to convert them to integers. <br><br>  JavaScript provides <i>Math.round</i> , <i>Math.floor,</i> or even <i>parseInt</i> functions for converting numbers to integers.  But these functions do some extra work (in particular, they check ranges or check that values ‚Äã‚Äãreally are numbers; parseInt generally converts its parameter to a string in the first place!).  So within my drawing cycle, I need a faster way to convert numbers. <br><br>  Recalling my old assembler code, I decided to use a small trick: instead of using <i>parseInt, it is</i> enough just to shift the number to the right by 0. The runtime will move the floating-point number from the corresponding register to the integer one and apply a hardware conversion.  Shifting the number to the right by 0 will leave the number unchanged and return you an integer value. <br><br>  The source code was: <br><pre> <code class="hljs lisp">u = parseInt((<span class="hljs-name"><span class="hljs-name">u</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? texture.width + (<span class="hljs-name"><span class="hljs-name">u</span></span> % texture.width) : (<span class="hljs-name"><span class="hljs-name">u</span></span> &gt;= texture.width) ? u % texture.width : u)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  The new code looks like this: <br><br><pre> <code class="hljs lisp">u = ((<span class="hljs-name"><span class="hljs-name">u</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? texture.width + (<span class="hljs-name"><span class="hljs-name">u</span></span> % texture.width) : (<span class="hljs-name"><span class="hljs-name">u</span></span> &gt;= texture.width) ? u % texture.width : u) &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  Of course, this solution requires you to be sure of the correctness of the transmitted number :) <br><br><h3>  Final result </h3><br>  Applying all the described optimizations results in the following report: <br> <a href=""><img src="http://img-fotki.yandex.ru/get/6204/25193168.12/0_56872_e8fc7b4e_L.jpg" alt="final performance"></a> <br><br>  As you can see, now the code looks well optimized using only key functions. <br><br>  We started with this original, non-optimized tunnel: <br><br> <a href="http://jsfiddle.net/xCs6e/1/"><img src="http://img-fotki.yandex.ru/get/6204/25193168.12/0_56893_44770ee_XL.jpg"></a> <br>  <a href="http://jsfiddle.net/xCs6e/1/">JSFiddle example</a> <br><br>  And they came to this result after optimization: <br><br> <a href="http://jsfiddle.net/nxjSR/1/"><img src="http://img-fotki.yandex.ru/get/6004/25193168.12/0_56894_7c2ee3e9_XL.jpg"></a> <br>  <a href="http://jsfiddle.net/nxjSR/1/">JSFiddle example</a> <br><br>  <i>[lane: these screenshots are made on the translator‚Äôs computer, on which fps does not reach the cherished 60fps, but is spinning pretty close to this - about 50fps in IE10.]</i> <br><br>  We can estimate the contribution of each optimization by the following diagram showing the frame rate on my computer: <br><br><img src="http://img-fotki.yandex.ru/get/6204/25193168.11/0_5686f_1d2ad076_L.jpg" alt="comparing performance"><br><br><h2>  Moving on </h2><br>  With these key points in mind, you are now ready to develop fast and smooth games for modern browsers and Windows 8! </div><p>Source: <a href="https://habr.com/ru/post/141482/">https://habr.com/ru/post/141482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141477/index.html">Why i hate frameworks</a></li>
<li><a href="../141478/index.html">Authentication as a licensing mechanism</a></li>
<li><a href="../141479/index.html">Interception of WEB traffic through the WPAD protocol using Intercepter-NG</a></li>
<li><a href="../141480/index.html">An ISO standard has appeared in Ruby</a></li>
<li><a href="../141481/index.html">School fun or multiplayer game without sockets and p2p</a></li>
<li><a href="../141483/index.html">Free VPN from Comodo</a></li>
<li><a href="../141484/index.html">Charity and sponsorship (crowdfunding): two different forms of financing font development</a></li>
<li><a href="../141486/index.html">Where do ux specialists come from</a></li>
<li><a href="../141487/index.html">What It Worth Thinking About, Keeping Your Data in the Cloud. Part 2</a></li>
<li><a href="../141489/index.html">Path internship at USABILITYLAB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>