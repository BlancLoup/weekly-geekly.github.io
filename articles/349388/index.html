<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We forward Steam API calls from Wine to GNU / Linux and back with Nim</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GNU / Linux players have a lot of problems. One of them is the need to install a separate Steam client for each Windows game from Steam. The situation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We forward Steam API calls from Wine to GNU / Linux and back with Nim</h1><div class="post__text post__text-html js-mediator-article"><p>  GNU / Linux players have a lot of problems.  One of them is the need to install a separate Steam client for each Windows game from Steam.  The situation is aggravated by the need to install a native Steam client for ported and cross-platform games. <br><img src="https://habrastorage.org/webt/h6/ad/8m/h6ad8m2tfoak1abb7kayqozqb9s.png"><br>  But what if you find a way to use one client for all games?  You can take the native client as a basis, and let Windows games access it just like, for example, OpenGL or the GNU / Linux sound subsystem ‚Äî Wine.  On the implementation of this approach and will be discussed further. </p><a name="habracut"></a><br><h1 id="istina-v-wine">  Truth in wine </h1><br><p> Wine can work with Windows libraries in two modes: third-party (or native in English terminology) and built-in (builtin).  The third-party library is perceived by Wine as a file with the <code>*.dll</code> extension, which needs to be loaded into memory and to work with it, as with the Windows entity.  It is in this mode that Wine works with all libraries that it knows nothing about.  The built-in mode implies that Wine should process the call to the library in a special way and redirect it to a previously created wrapper with the extension <code>*.dll.so</code> , which can access the operating system and its libraries.  Read more about it <a href="https://wiki.winehq.org/Wine_Developer%27s_Guide/Architecture_Overview">here</a> . </p><br><p>  Fortunately, most of the interaction with the Steam client occurs just through the <code>steam_api.dll</code> library, which means the task is reduced to the implementation of the <code>steam_api.dll.so</code> wrapper, which will refer to the GNU / Linux analogue - <code>libsteam_api.so</code> . </p><br><p>  Creating such a wrapper process is well-known and <a href="https://wiki.winehq.org/Winelib_User%2527s_Guide">documented</a> .  You need to take the source library for Windows, get a spec file for it using <code>winedump</code> , write the implementations of all the functions in the spec file and compile-link it all with the help of <code>winegcc</code> .  Or ask the <code>winemaker</code> to do all the routine work. </p><br><h1 id="dyavol-kroetsya-v-detalyah">  The devil is in the details </h1><br><p>  At first glance, the task is simple.  Especially considering that <code>winedump</code> can create wrappers automatically in the presence of the header files of the source library, and the header files are published by Valve for game developers on the <a href="https://partner.steamgames.com/">official website</a> .  So, after creating a wrapper through <code>winedump</code> , turning on the built-in <code>steam_api.dll</code> mode in <code>winecfg</code> and compiling, we launched our native Steam, then the game itself and ... The game crashes! </p><br><div class="spoiler">  <b class="spoiler_title">Look in the log</b> <div class="spoiler_text"><pre> trace: steam_api: SteamAPI_RestartAppIfNecessary_ ((uint32) [hidden])
 trace: steam_api: SteamAPI_RestartAppIfNecessary_ () = (bool) 0
 trace: steam_api: SteamAPI_Init_ ()
 Setting breakpad minidump AppID = [hidden]
 Steam_SetMinidumpSteamID: Caching Steam ID: [hidden] [API loaded no]
 trace: steam_api: SteamAPI_Init_ () = (bool) 1
 trace: steam_api: SteamInternal_ContextInit_ ((void *) 0x7ee468)
 trace: steam_api: SteamAPI_GetHSteamPipe_ ()
 trace: steam_api: SteamAPI_GetHSteamPipe_ () = (HSteamPipe) 0x1
 trace: steam_api: SteamAPI_GetHSteamUser_ ()
 trace: steam_api: SteamAPI_GetHSteamUser_ () = (HSteamUser) 0x1
 trace: steam_api: SteamAPI_GetHSteamPipe_ ()
 trace: steam_api: SteamAPI_GetHSteamPipe_ () = (HSteamPipe) 0x1
 trace: steam_api: SteamInternal_CreateInterface_ ((char *) "SteamClient017")
 wine: Unhandled privileged instruction at address 0x7a3a3c92 (thread 0009), starting debugger ...
 Unhandled exception: privileged instruction in 32-bit code (0x7a3a3c92).
</pre><br><p>  Note: this log is more informative than that generated by the wrapper generated by the method described above, but this does not change the essence of the problem. </p></div></div><br><p>  Judging by the log, our wrapper works (!) Exactly until the moment when the <code>SteamInternal_CreateInterface</code> function is <code>SteamInternal_CreateInterface</code> .  What is wrong with her?  After reading the documentation and correlating it with the header files, we find that this function returns a pointer to an object of the <code>SteamClient</code> class. </p><br><p>  I think those who are familiar with ABI C ++ have already understood what the catch is.  The root of the problem in calling conventions.  The C ++ standard does not imply binary compatibility of programs compiled by different compilers, and in our case the game for windows is compiled into MSVC, while native Steam is in GCC.  Since all calls to the <code>steam_api.dll</code> function follow the C language calling conventions, this problem is not observed.  As soon as the game receives an instance of the <code>SteamClient</code> class from its native Steam and tries to call its method (which follows the C ++ agreement of thiscall), an error occurs.  To fix the problem, you should first identify the key differences in conventions for the used compilers. </p><br><table><thead><tr><th>  MSVC </th><th>  Gcc </th></tr></thead><tbody><tr><td>  Places a pointer to an object in the ECX register. </td><td>  Waits to find a pointer to an object in the stack at the top position. </td></tr><tr><td>  Waiting for the stack to be cleared by the called method. </td><td>  Waiting for the stack to clear the calling code. </td></tr></tbody></table><br><p>  [ <a href="http://www.angelcode.com/dev/callconv/callconv.html">source</a> ] </p><br><p>  At this stage, it is worth making a small digression and mentioning that attempts to solve the problem indicated in the title have already been made, and even quite successfully.  There is a <a href="https://github.com/sirnuke/steambridge">SteamBridge</a> project that uses two separate libraries - for Windows and for GNU / Linux.  The library for Windows is compiled using MSVC and calls the library for GNU / Linux, which is replaced by Wine and compiled using GCC in a similar pattern.  The problem of the methods is solved with the help of assembler inserts on the side of the Windows library and wrapping each object while transferring it in the direction of the MSVC code.  This solution is somewhat redundant, since it requires an additional non-platform compiler to build and introduces an extra entity, but the idea of ‚Äã‚Äãwrapping the returned objects is robust.  We will borrow it! </p><br><p>  Luckily for us, Wine already has the ability to work with call agreements.  It is enough to declare a method with <code>thiscall</code> attribute.  Thus, it is necessary to create wrappers for all methods of all classes, and in the implementation of methods simply call methods from the original class (the link to which is stored in a wrapper).  The wrapper will look like this: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ISteamClient_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HSteamPipe </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSteamPipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thiscall</span></span></span><span class="hljs-function">))</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">// -  private: ISteamClient * internal; }</span></span></code> </pre> <br><pre> <code class="hljs kotlin">HSteamPipe ISteamClient_::CreateSteamPipe() { TRACE(<span class="hljs-string"><span class="hljs-string">"((ISteamClient *)%p)\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); HSteamPipe result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>-&gt;CreateSteamPipe(); TRACE(<span class="hljs-string"><span class="hljs-string">"() = (HSteamPipe)%p\n"</span></span>, result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  A similar operation, only in the opposite direction, should be carried out for classes transferred from MSVC code to GCC, namely <code>CCallback</code> and <code>CCallResult</code> .  The task is routine and uninteresting, because the best solution would be to delegate it to the script for code generation.  After several attempts to put everything together, the game begins to work. </p><br><div class="spoiler">  <b class="spoiler_title">Log fragment</b> <div class="spoiler_text"><pre> trace: steam_api: SteamAPI_RestartAppIfNecessary_ ((uint32) [hidden])
 trace: steam_api: SteamAPI_RestartAppIfNecessary_ () = (bool) 0
 trace: steam_api: SteamAPI_Init_ ()
 Setting breakpad minidump AppID = [hidden]
 Steam_SetMinidumpSteamID: Caching Steam ID: [hidden] [API loaded no]
 trace: steam_api: SteamAPI_Init_ () = (bool) 1
 trace: steam_api: SteamInternal_ContextInit_ ((void *) 0x7ee468)
 trace: steam_api: SteamAPI_GetHSteamPipe_ ()
 trace: steam_api: SteamAPI_GetHSteamPipe_ () = (HSteamPipe) 0x1
 trace: steam_api: SteamAPI_GetHSteamUser_ ()
 trace: steam_api: SteamAPI_GetHSteamUser_ () = (HSteamUser) 0x1
 trace: steam_api: SteamAPI_GetHSteamPipe_ ()
 trace: steam_api: SteamAPI_GetHSteamPipe_ () = (HSteamPipe) 0x1
 trace: steam_api: SteamInternal_CreateInterface_ ((char *) "SteamClient017")
 trace: steam_api: SteamInternal_CreateInterface_ (): (ISteamClient *) 0x7a7a04c8 wrapped as (ISteamClient_ *) 0x7c49bc70
 trace: steam_api: SteamInternal_CreateInterface_ () = (ISteamClient_ *) 0x7c49bc70
 trace: steam_api: GetISteamUser ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamUser019")
 trace: steam_api: GetISteamUser () = (ISteamUser *) 0x7c4bcc40
 trace: steam_api: GetISteamFriends ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamFriends015")
 trace: steam_api: GetISteamFriends () = (ISteamFriends *) 0x7c4b8650
 trace: steam_api: GetISteamUtils ((ISteamClient *) 0x7c49bc70, (HSteamPipe) 0x1, (char *) "SteamUtils008")
 trace: steam_api: GetISteamUtils () = (ISteamUtils *) 0x7c4b7930
 trace: steam_api: GetISteamMatchmaking ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamMatchMaking009")
 trace: steam_api: GetISteamMatchmaking () = (ISteamMatchmaking *) 0x7c4c03c0
 trace: steam_api: GetISteamMatchmakingServers ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamMatchMakingServers002")
 trace: steam_api: GetISteamMatchmakingServers () = (ISteamMatchmakingServers *) 0x7c4b5450
 trace: steam_api: GetISteamUserStats ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMUSERSTATS_INTERFACE_VERSION011")
 trace: steam_api: GetISteamUserStats () = (ISteamUserStats *) 0x7c4b5e10
 trace: steam_api: GetISteamApps ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMAPPS_INTERFACE_VERSION008")
 trace: steam_api: GetISteamApps () = (ISteamApps *) 0x7c4b73a0
 trace: steam_api: GetISteamNetworking ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamNetworking005")
 trace: steam_api: GetISteamNetworking () = (ISteamNetworking *) 0x7c49cd40
 trace: steam_api: GetISteamRemoteStorage ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMREMOTESTORAGE_INTERFACE_VERSION014")
 trace: steam_api: GetISteamRemoteStorage () = (ISteamRemoteStorage *) 0x7c4c1610
 trace: steam_api: GetISteamScreenshots ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMSCREENSHOTS_INTERFACE_VERSION003")
 trace: steam_api: GetISteamScreenshots () = (ISteamScreenshots *) 0x7c4b70b0
 trace: steam_api: GetISteamHTTP ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMHTTP_INTERFACE_VERSION002")
 trace: steam_api: GetISteamHTTP () = (ISteamHTTP *) 0x7c4b5c50
 trace: steam_api: GetISteamUnifiedMessages ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMUNIFIEDMESSAGES_INTERFACE_VERSION001")
 trace: steam_api: GetISteamUnifiedMessages () = (ISteamUnifiedMessages *) 0x7c49e680
 trace: steam_api: GetISteamController ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "SteamController005")
 trace: steam_api: GetISteamController () = (ISteamController *) 0x7c49bfd0
 trace: steam_api: GetISteamUGC ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMUGC_INTERFACE_VERSION009")
 trace: steam_api: GetISteamUGC () = (ISteamUGC *) 0x7c49cad0
 trace: steam_api: GetISteamAppList ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMAPPLIST_INTERFACE_VERSION001")
 trace: steam_api: GetISteamAppList () = (ISteamAppList *) 0x7c49c450
 trace: steam_api: GetISteamMusic ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMMUSIC_INTERFACE_VERSION001")
 trace: steam_api: GetISteamMusic () = (ISteamMusic *) 0x7c49cbf0
 trace: steam_api: GetISteamMusicRemote ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMMUSICREMOTE_INTERFACE_VERSION001")
 trace: steam_api: GetISteamMusicRemote () = (ISteamMusicRemote *) 0x7c49e710
 trace: steam_api: GetISteamHTMLSurface ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMHTMLSURFACE_INTERFACE_VERSION_003")
 trace: steam_api: GetISteamHTMLSurface () = (ISteamHTMLSurface *) 0x7c49ccb0
 trace: steam_api: GetISteamInventory ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMINVENTORY_INTERFACE_V001")
 trace: steam_api: GetISteamInventory () = (ISteamInventory *) 0x7c49d0c0
 trace: steam_api: GetISteamVideo ((ISteamClient *) 0x7c49bc70, (HSteamUser) 0x1, (HSteamPipe) 0x1, (char *) "STEAMVIDEO_INTERFACE_V001")
 trace: steam_api: GetISteamVideo () = (ISteamVideo *) 0x7c49cb60
 trace: steam_api: SetOverlayNotificationPosition ((ISteamUtils *) 0x7c4b7930, (ENotificationPosition) 0x2)
 trace: steam_api: SteamInternal_ContextInit_ ((void *) 0x7ee468)
 trace: steam_api: SetWarningMessageHook ((ISteamUtils *) 0x7c4b7930, (SteamAPIWarningMessageHook_t) 0x52ebb0)
</pre></div></div><br><p>  It would seem: is the end of a fairy tale?  And no! </p><br><h1 id="dobro-pozhalovat-v-versionnyy-ad">  Welcome to versioned hell! </h1><br><p>  It soon becomes clear that our design is fully viable only for games compiled using the same header files that we have available.  And we only have the latest version of the Steam API, other versions of Valve do not publish (and this was given under a closed license).  On the other hand, we also have the latest version of Steam, but this does not prevent it from working with old versions of the Steam API.  How does he do it? </p><br><p>  The answer is hidden in this line of the log: <code>trace:steam_api:SteamInternal_CreateInterface_ ((char *)"SteamClient017")</code> .  It turns out that the client stores information about all the classes of all versions of SteamAPI, and steam_api.dll only requests the client with an instance of the desired class of the desired version.  It remains only to find exactly where it is stored.  To begin with, we will try the ‚Äúforehead‚Äù approach: we will try to find the string "SteamClient016" in <code>libsteam_api.so</code> .  Why not "SteamClient017"?  Because we need to find the location of all versions of the Steam API classes, and not just the version to which <code>libsteam_api.so</code> belongs. </p><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"SteamClient017"</span></span> libsteam_api.so   libsteam_api.so  $ grep <span class="hljs-string"><span class="hljs-string">"SteamClient016"</span></span> libsteam_api.so $</code> </pre> <br><p>  It looks like <code>libsteam_api.so</code> has nothing like that.  Then we will try to go through all the libraries of the Steam client. </p><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"SteamClient017"</span></span> *.so   steamclient.so    steamui.so  $ grep <span class="hljs-string"><span class="hljs-string">"SteamClient016"</span></span> *.so   steamclient.so  $</code> </pre> <br><p>  And here is what we need!  Hang the Gabe Newell icon, if any, and open <code>steamclient.so</code> in IDA.  A quick keyword search yields a curious set of strings: <code>CAdapterSteamClient0XX</code> , where XX is the version number.  What is even more curious is that the file contains the lines <code>CAdapterSteamYYYY0XX</code> , where XX is still the version number, and YYYY is the name of the Steam API for all other interfaces.  Analysis of cross-references allows you to effortlessly find a table of virtual methods for each of the classes with such names.  Thus, the total scheme for each class will look like this: <br><img src="https://habrastorage.org/webt/hf/e4/4i/hfe44isvt4vsanajaro-oesru0k.png"><br>  The method table is found, only we have absolutely no information about the signatures of these methods.  But this problem was <a href="https://toster.ru/answer%3Fanswer_id%3D1156239">solved</a> by calculating the maximum depth of the stack to which the method is trying to gain access.  So you can make a utility that will receive <code>steamclient.so</code> as input, and create a list of classes of all versions, as well as their methods, as output.  It remains only on the basis of this list to generate the class wrapper code for the method conversion.  The task does not look simple, especially considering that the method signatures themselves are still not known to us, we only know the stack depth at which the method arguments end.  The situation is aggravated by the peculiarities of the return of some structures by value, namely the presence of a hidden argument to the memory where the structure should be written.  This pointer, in all calling conventions, is retrieved from the stack by the called function, because it can be easily calculated using the <code>ret $4</code> instruction in methods from <code>steamclient.so</code> .  But even so, the amount of non-trivial code generation is huge. </p><br><h1 id="yavlenie-geroya">  The appearance of the hero </h1><br><p>  For any new or just not very popular programming language, the first question is about its niche.  <a href="https://nim-lang.org/">Nim</a> is no exception.  He is often criticized for trying to ‚Äúsit on all chairs at once,‚Äù implying fullness with a large number of features in the absence of one clear direction of development.  Among these features, two can be particularly highlighted: </p><br><ul><li>  compilation in C and, as a result, cross-platform; </li><li>  excellent support for metaprogramming (the same language for run-time and compile-time code, direct manipulation of the <abbr title="Abstract Syntax Tree">ASD</abbr> ). </li></ul><br><p>  It is this combination that will make the process of writing a wrapper painless as a result. <br>  First, create the main <code>steam_api.nim</code> file and the file with the <code>steam_api.nims</code> compilation <code>steam_api.nims</code> : </p><br><div class="spoiler">  <b class="spoiler_title">steam_api.nim</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> specname {.strdefine.} = <span class="hljs-string"><span class="hljs-string">"steam_api.spec"</span></span> <span class="hljs-meta"><span class="hljs-meta"># spec     ,        `-d:specname=/path/to/steam_api.spec`    {.strdefine.}     `specname`. #    ,       ‚Äî </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"steam_api.spec"</span></span></span><span class="hljs-meta">. {.passL: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"'"</span></span></span><span class="hljs-meta"> &amp; specname &amp; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"'"</span></span></span><span class="hljs-meta">.} #     spec     . #   TRACE    wine,      proc trace*(format: cstring) {.varargs, importc: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TRACE"</span></span></span><span class="hljs-meta">, header: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"#include &lt;stdarg.h&gt; #include "</span></span></span><span class="hljs-meta">wine/debug.h</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" WINE_DEFAULT_DEBUG_CHANNEL(steam_api);"</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">.} #  varargs ,       ,  importc ‚Äî         ,  header ‚Äî        ,   . #  , Nim      TRACE.    ,    TRACE    . #    winedump',           . {.emit:[</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved) { "</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, trace, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta">(%p, %u, %p)\n</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">", instance, reason, reserved); //     ,        switch (reason) { case DLL_WINE_PREATTACH: return FALSE; /* prefer native version */ case DLL_PROCESS_ATTACH: DisableThreadLibraryCalls(instance); NimMain(); //      Nim break; } return TRUE; } "</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">].}</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">steam_api.nims</b> <div class="spoiler_text"><pre> <code class="hljs mel">--app:lib #    steam_api.dll.so,     --passL:<span class="hljs-string"><span class="hljs-string">"-mno-cygwin"</span></span> #     winegcc  --passC:<span class="hljs-string"><span class="hljs-string">"-mno-cygwin"</span></span> #       ,   <span class="hljs-string"><span class="hljs-string">`--`</span></span>,      --passC:<span class="hljs-string"><span class="hljs-string">"-D__WINESRC__"</span></span> #        Nim --os:windows #     linux, wine    WinAPI --noMain #     <span class="hljs-string"><span class="hljs-string">`DllMain`</span></span>,   ,  Nim    --cc:gcc #     C #    <span class="hljs-string"><span class="hljs-string">`switch`</span></span>,    <span class="hljs-string"><span class="hljs-string">`--`</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-string"><span class="hljs-string">"gcc.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"/usr/bin/winegcc"</span></span>) #         <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-string"><span class="hljs-string">"gcc.linkerexe"</span></span>, <span class="hljs-string"><span class="hljs-string">"/usr/bin/winegcc"</span></span>) #     <span class="hljs-string"><span class="hljs-string">`switch`</span></span>  <span class="hljs-string"><span class="hljs-string">`--`</span></span> ?</code> </pre> </div></div><br><p>  It does not look very simple, but this is only due to the fact that we swung at many things at once.  Here, both cross-compilation, and importing functions from C header files, and compilation features for Wine ... Despite seeming complexity, nothing complicated happened, we just directly implemented some parts of C source code that Nim doesn‚Äôt know anything about and cannot , and at the same time described for Nim how to call the TRACE macro from the header files of Wine (these files were also told about themselves). </p><br><p>  We now turn to the most delicious - macros and code generation.  Since we do not have complete information on method signatures, we will emulate instances of classes from C code, since we only need to emulate a virtual method table.  So, let us have a file that describes the methods and classes of the Steam API as follows: </p><br><pre> ! CAdapterSteamYYY0XX
 [+] &lt;method 1 stack depth&gt;
 [+] &lt;method 2 stack depth&gt;
 ...
</pre><br><p>  The <code>+</code> sign is optional and will serve as an indicator of a hidden argument. <br>  This file can be obtained by analyzing <code>steamclient.so</code> .  It should make a table.  The keys to it will be strings of the form <code>CAdapterSteamYYYY0XX</code> , and the values ‚Äã‚Äãwill be an array of references to functions that call the corresponding methods in an object that is implicitly passed to the structure field passed to them through the <code>ECX</code> .  Writing all of this in assembly language is not very convenient, especially considering that it would be nice to add some kind of journaling, so select the minimum assembler fragment: </p><br><div class="spoiler">  <b class="spoiler_title">Stack to the execution of the fragment</b> <div class="spoiler_text"><pre> [...]
 [...]
 [...]
 [return address] &lt;= ESP
 [argument 1]
 [argument 2]
 [???]
</pre></div></div><br><pre> <code class="hljs mel">push %ecx #       (   ) push $&lt;    &gt; #      (    ) #     <span class="hljs-number"><span class="hljs-number">3</span></span> (      ) call &lt; Nim&gt; #  ,   Nim add $0x4, %esp #      pop %ecx #     ret $&lt; &gt; #      </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Stack after calling Nim function</b> <div class="spoiler_text"><pre> [assembly return address] &lt;= ESP
 [method number]
 [object pointer =% ecx]
 [return address]
 [argument 1]
 [argument 2]
 [???]
</pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Stack after returning from fragment</b> <div class="spoiler_text"><pre> [return address to assembler fragment]
 [method number]
 [object pointer =% ecx]
 [return address]
 [argument 1]
 [argument 2]
 [???] &lt;= ESP
</pre></div></div><br><p>  It remains to generate the designated functions Nim.  It is necessary to generate one function for each depth of the stack encountered in the file and one more for calls with a hidden argument.  We will call these functions pseudo-methods for brevity. </p><br><div class="spoiler">  <b class="spoiler_title">Here is an example of such a function.</b> <div class="spoiler_text"><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> pseudoMethod4(methodNo: uint32, obj: ptr WrappedObject, retAddress: pointer, argument1: pointer) : uint64 {.cdecl.} = #   pseudoMethod&lt; &gt; # methodNo -         <span class="hljs-number"><span class="hljs-number">0</span></span> # obj -     # retAddress -      ( ) # argument1 - ,    #  uint64,    ,    <span class="hljs-number"><span class="hljs-number">64</span></span>     EAX  EDX  <span class="hljs-number"><span class="hljs-number">32</span></span>   EAX. #  cdecl  ,         <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Method No %d was called for obj=%p and return to %p\n"</span></span>, methodNo, obj, retAddress) <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"(%p)\n"</span></span>, argument1) <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Origin = %p\n"</span></span>, obj.origin) let vtableaddr = obj.origin.vtable <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Origins VTable = %p\n"</span></span>, vtableaddr) #         let maddr = cast[ptr <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span>(obj: pointer argument1: pointer): uint64](cast[uint32](vtableaddr) + methodNo*<span class="hljs-number"><span class="hljs-number">4</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Method address to call: %p\n"</span></span>, maddr) let themethod = maddr[] #     <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Method to call: %p\n"</span></span>, themethod) let res = themethod(obj.origin, argument1) #    (   GCC) <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>(<span class="hljs-string"><span class="hljs-string">"Result = %p\n"</span></span>, res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapIfNecessary(res) #   -   ,      .</code> </pre> </div></div><br><p>  Let‚Äôs leave behind the implementation of the <code>wrapIfNecessary</code> function and proceed to the description of the code that generates the fragments described above.   ,     .       ,     spec- ‚Äî   . </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="hljs markdown">from strutils import splitLines, split, parseInt from tables import initTable, <span class="hljs-code"><span class="hljs-code">`[]`</span></span>, <span class="hljs-code"><span class="hljs-code">`[]=`</span></span>, pairs, Table type StackState<span class="hljs-bullet"><span class="hljs-bullet">* = tuple #       depth: int #   swap: bool #     Classes*</span></span> = Table[<span class="hljs-string"><span class="hljs-string">string, seq[StackState</span></span>]] ## ,    :  ‚Äî   (CAdapterSteamYYY0XX),  ‚Äî      const cdfile {.strdefine.} = "" #     ,        proc readClasses(): Classes {.compileTime.} = #  compileTime   ,         result = initTable[<span class="hljs-string"><span class="hljs-string">string, seq[StackState</span></span>]]() # result ‚Äî  ,       let filedata = slurp(cdfile) #       <span class="hljs-code"><span class="hljs-code">`slurp`</span></span>,           for line in filedata.splitLines(): if line.len == 0: continue elif line[<span class="hljs-string"><span class="hljs-string">0</span></span>] == '!': let curstr = line[<span class="hljs-string"><span class="hljs-string">1..^1</span></span>] #       result[<span class="hljs-string"><span class="hljs-string">curstr</span></span>] = newSeq[<span class="hljs-string"><span class="hljs-string">StackState</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) else: let depth = parseInt(line) let swap = line[0] == '+' #        "+"    #           result[curstr].add((depth: depth, swap: swap)) #          #  ,    result     </code> </pre> </div></div><br><p>     .   <code>readClasses</code>   ,     ,             : <code>const classes = readClasses()</code> .   -,    ,  . </p><br><div class="spoiler"> <b class="spoiler_title">     -</b> <div class="spoiler_text"><pre> <code class="hljs markdown">static: #   static ,        . var declared: set[<span class="hljs-string"><span class="hljs-string">uint8</span></span>] = {} #  ,       var swpdeclared: set[<span class="hljs-string"><span class="hljs-string">uint8</span></span>] = {} #  ,          proc eachMethod(k: string, methods: seq[<span class="hljs-string"><span class="hljs-string">StackState</span></span>], sink: NimNode): NimNode {.compileTime.} = #       <span class="hljs-code"><span class="hljs-code">`k`</span></span>      <span class="hljs-code"><span class="hljs-code">`sink`</span></span> # NimNode -   .            . result = newStmtList() #     let kString = newStrLitNode k #     ,   # Unified Call Syntax       ,    newStrLitNode(k), k.newStrLitNode()  k.newStrLitNode (   ) result.add quote do: # quote -  ,     ,     ,  <span class="hljs-code"><span class="hljs-code">`do`</span></span>        <span class="hljs-code"><span class="hljs-code">`sink`</span></span>[<span class="hljs-string"><span class="hljs-string">`kString`</span></span>] = newSeq[<span class="hljs-string"><span class="hljs-string">MethodProc</span></span>](<span class="hljs-link"><span class="hljs-link">2</span></span>) # ,          for i, v in methods.pairs(): if v.swap: #  ,    swpdeclared.incl(v.depth.uint8) #      else: declared.incl(v.depth.uint8) #          . #        <span class="hljs-code"><span class="hljs-code">`&amp;`</span></span>. #        . let asmcode = """ push %ecx #       push $0x""" &amp; i.toHex &amp; """ #       call <span class="hljs-code"><span class="hljs-code">`pseudoMethod""" &amp; $v.depth &amp; (if v.swap: "S" else: "") &amp; # if-elif-else  case-of-else      """`</span></span> #   add $0x4, %esp #      pop %ecx #       ECX      ret $""" &amp; $(v.depth-4) &amp; """ #        """ var tstr = newNimNode(nnkTripleStrLit) # nnkTripleStrLit          tstr.strVal = asmcode #         let asmstmt = newTree(nnkAsmStmt, newEmptyNode(), tstr) #        <span class="hljs-code"><span class="hljs-code">`asm """&lt;&gt;"""`</span></span> let methodname = newIdentNode("m" &amp; k &amp; $i) #     <span class="hljs-code"><span class="hljs-code">`m&lt; &gt;&lt; &gt;`</span></span> result.add quote do: #             proc <span class="hljs-code"><span class="hljs-code">`methodname`</span></span> () {.asmNoStackFrame, noReturn.} = #   #  asmNoStackFrame   ,       #  noReturn  ,            <span class="hljs-code"><span class="hljs-code">`asmstmt`</span></span> #  add(<span class="hljs-code"><span class="hljs-code">`sink`</span></span>[<span class="hljs-code"><span class="hljs-code">`kString`</span></span>], <span class="hljs-code"><span class="hljs-code">`methodname`</span></span>) #  quote          ,       UCS   </code> </pre> </div></div><br><p>     .      .   ,   ,   ‚Äî   Nim,        (  ).          . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="hljs markdown">proc makePseudoMethod(stack: uint8, swp: bool): NimNode {.compileTime.} = ##     . result = newProc(newIdentNode("pseudoMethod" &amp; $stack &amp; (if swp:"S" else: ""))) #       "pseudoMethod<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name"></span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>[<span class="hljs-string"><span class="hljs-string">S</span></span>]" #   <span class="hljs-code"><span class="hljs-code">`quote`</span></span>   ,      result.addPragma(newIdentNode("cdecl")) #  {.cdecl.} let nargs = max(int(stack div 4) - 1 - int(swp), 0) #          ,    let justargs = genArgs(nargs) #   ,   -      "argument1: uint32"  "argument<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">nargs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>: uint32" let origin = newIdentNode("origin") let rmethod = newIdentNode("rmethod") var mcall = genCall("rmethod", nargs) #    ,   -   "rmethod(argument1, ... , argument<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">nargs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>)" mcall.insert(1, origin) #       var argseq = @[<span class="hljs-string"><span class="hljs-string"> #    newIdentNode("uint64"), #   newIdentDefs(newIdentNode("methodNo"), newIdentNode("uint32")), #    newIdentDefs(newIdentNode("obj"), newIdentNode("uint32")), #    (   uint32   ) newIdentDefs(newIdentNode("retAddress"), newIdentNode("uint32")), #   </span></span>] if swp: #     -   argseq.add(newIdentDefs(newIdentNode("hidden"), newIdentNode("pointer"))) #      argseq &amp;= justargs[<span class="hljs-string"><span class="hljs-string">1..^1</span></span>] var originargs = @[<span class="hljs-string"><span class="hljs-string"> #      newIdentNode("uint64"), newIdentDefs(newIdentNode("obj"), newIdentNode("uint32")), </span></span>] &amp; justargs[<span class="hljs-string"><span class="hljs-string">1..^1</span></span>] let procty = newTree(nnkProcTy, newTree(nnkFormalParams, originargs), newTree(nnkPragma, newIdentNode("cdecl"))) #     let args = newTree(nnkFormalParams, argseq) result[<span class="hljs-string"><span class="hljs-string">3</span></span>] = args #      let tracecall = genTraceCall(nargs) #    ,  -  trace   ,    result.body = quote do: #    trace("Method No %d was called for obj=%p and return to %p\n", methodNo, obj, retAddress) <span class="hljs-code"><span class="hljs-code">`tracecall`</span></span> let wclass = cast[<span class="hljs-string"><span class="hljs-string">ptr WrappedClass</span></span>](<span class="hljs-link"><span class="hljs-link">obj</span></span>) #     -   <span class="hljs-code"><span class="hljs-code">`uint32`</span></span>  <span class="hljs-code"><span class="hljs-code">`ptr WrappedClass`</span></span> let <span class="hljs-code"><span class="hljs-code">`origin`</span></span> = cast[<span class="hljs-string"><span class="hljs-string">uint32</span></span>](<span class="hljs-link"><span class="hljs-link">wclass.origin</span></span>) trace("Origin = %p\n", <span class="hljs-code"><span class="hljs-code">`origin`</span></span>) let vtableaddr = wclass.origin.vtable trace("Origins VTable = %p\n", vtableaddr) let maddr = cast[<span class="hljs-string"><span class="hljs-string">ptr `procty`</span></span>](<span class="hljs-link"><span class="hljs-link">cast[uint32](vtableaddr</span></span>) + shift*4) trace("Method address to call: %p\n", maddr) let <span class="hljs-code"><span class="hljs-code">`rmethod`</span></span> = maddr[<span class="hljs-string"></span><span class="hljs-string"></span>] trace("Method to call: %p\n", <span class="hljs-code"><span class="hljs-code">`rmethod`</span></span>) if swp: #         ,      let asmcall = genAsmHiddenCall("rmethod", "origin", nargs) #         ,     ,       result.body.add quote do: trace("Hidden before = %p (%p) \n", hidden, cast[<span class="hljs-string"><span class="hljs-string">ptr cint</span></span>](<span class="hljs-link"><span class="hljs-link">hidden</span></span>)[<span class="hljs-string"></span><span class="hljs-string"></span>]) <span class="hljs-code"><span class="hljs-code">`asmcall`</span></span> #     trace("Hidden result = %p (%p) \n", hidden, cast[<span class="hljs-string"><span class="hljs-string">ptr cint</span></span>](<span class="hljs-link"><span class="hljs-link">hidden</span></span>)[<span class="hljs-string"></span><span class="hljs-string"></span>]) return cast[<span class="hljs-string"><span class="hljs-string">uint64</span></span>](<span class="hljs-link"><span class="hljs-link">hidden</span></span>) #           ,  ,         else: #         result.body.add quote do: let res = <span class="hljs-code"><span class="hljs-code">`mcall`</span></span> trace("Result = %p\n", res) return wrapIfNecessary(res) #  <span class="hljs-code"><span class="hljs-code">`wrapIfNecessary`</span></span>     </code> </pre> </div></div><br><p>    .                .           quote,        ,        .    ,       . </p><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="hljs markdown">macro makeTableOfVTables(sink: untyped): untyped = #         # <span class="hljs-code"><span class="hljs-code">`sink`</span></span> - -,    . result = newStmtList() #    result.add quote do: # <span class="hljs-code"><span class="hljs-code">`sink`</span></span>      untyped,           ,     NimNode <span class="hljs-code"><span class="hljs-code">`sink`</span></span> = initTable[<span class="hljs-string"><span class="hljs-string">string, seq[MethodProc</span></span>]]() #    let classes = readClasses() #    readClasses,        for k, v in classes.pairs: result.add(eachMethod(k, v, sink)) #   - for i in declared: # ,  <span class="hljs-code"><span class="hljs-code">`declared`</span></span>     ,   ,       eachMethod . result.insert(0, makePseudoMethod(i, false)) #     ,  Nim,   ,      for i in swpdeclared: result.insert(0, makePseudoMethod(i, true)) when declared(debug): #     <span class="hljs-code"><span class="hljs-code">`-d:debug`</span></span>,       stdout    , echo(result.repr) #      ,     #     <span class="hljs-code"><span class="hljs-code">`result`</span></span>  NimNode   <span class="hljs-code"><span class="hljs-code">`untyped`</span></span>,     #   . var vtables: Table[string, seq[MethodProc]] makeTableOfVTables(vtables)</code> </pre> </div></div><br><p>       <code>steam_api.dll</code> .      GNU/Linux           Steam API,     . ,      : </p><br><div class="spoiler"> <b class="spoiler_title">   CCallback</b> <div class="spoiler_text"><pre> <code class="hljs markdown">proc run(obj: ptr WrappedCallback, p: pointer) {.cdecl.} = #     CCallback. trace("[<span class="hljs-string"><span class="hljs-string">%p</span></span>](<span class="hljs-link"><span class="hljs-link">%p</span></span>)\n", obj, p) let originRun = (obj.origin.vtable + 0)[] # <span class="hljs-code"><span class="hljs-code">`+`</span></span>      ,       let originObj = obj.origin asm """ mov %[obj], %%ecx #          ECX mov %%esp, %%edi # ESP   EDI, ..      push %[p] #     call %[mcall] #   mov %%edi, %%esp #   ::[obj]"g"(<span class="hljs-code"><span class="hljs-code">`originObj`</span></span>), [p]"g"(<span class="hljs-code"><span class="hljs-code">`p`</span></span>), [mcall]"g"(<span class="hljs-code"><span class="hljs-code">`originRun`</span></span>) :"eax", "edi", "ecx", "cc" """</code> </pre> </div></div><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> ,     ,     Steam API   .      ,  , ,        . Nim      . -  : ¬´       ?¬ª.       .   ‚Äî      <code>echo</code> ( <code>print</code>  Nim).    Nim   <code>repr</code>  <code>treeRepr</code> ,             ,    . </p><br><p>      Nim.                  ,     ,     ,     . </p><br><p> ,    ,         ,       ,    .  ,          ,  : </p><br><ul><li>  <code>wrapIfNeccessary</code>       ; </li><li>  -    ; </li><li>   Steam   ; </li><li>     <code>steam_api.dll</code> (       ); </li><li>    <code>steamclient.so</code>  <code>libsteam_api.so</code> ,   ; </li><li>    ,         ( ,   <code>asmNoStackFrame</code> ,   ). </li></ul><br><p>  ,   ,     .  ,         ,         . </p><br><p>           github: </p><br><ul><li>  <a href="https://github.com/xomachine/SteamForwarder/tree/8f2b8cea17da8718dfd8a87fbd2677d475abb54a"> master</a>    Nim        Steam API; </li><li>  <a href="https://github.com/xomachine/SteamForwarder/tree/a7dea4b6a87086b93d4165090d85ec8134985962"> devel</a>    Nim,        . </li></ul><br><p>           ,   .      ,     ,      . </p><br><p> ,        Nim   ,        ,  <code>echo "Hello, world!"</code>  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349388/">https://habr.com/ru/post/349388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349378/index.html">Security Operations: protection against cyber threats in ServiceNow</a></li>
<li><a href="../349380/index.html">Angular 5: Unit tests</a></li>
<li><a href="../349382/index.html">DigiCert bought Symantec Website Security: implications for users of SSL / TLS certificates</a></li>
<li><a href="../349384/index.html">The slowest way to speed up a program on Go</a></li>
<li><a href="../349386/index.html">Team Leader. To be or not to be, that is the question</a></li>
<li><a href="../349392/index.html">Sublime Text 3 is alive. (Setup and operation)</a></li>
<li><a href="../349394/index.html">The release of the first beta cross-platform XAML UI-toolkit Avalonia</a></li>
<li><a href="../349396/index.html">Configuring VoIP GSM Gateway Yeastar Neogate TGXXX Series for 3CX</a></li>
<li><a href="../349398/index.html">Safely speeding up the Erlang application using NIF on Rust</a></li>
<li><a href="../349400/index.html">FastTrack Training. "Network Basics". "Basics of switching or switches." Part one. Eddie Martin December 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>