<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Switch from bash to zsh</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To switch from bash to zsh, you need to know the basic differences between them - without this, it will be difficult to initialize zsh to ~/.zshrc . 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Switch from bash to zsh</h1><div class="post__text post__text-html js-mediator-article"><p> To switch from bash to zsh, you need to know the basic differences between them - without this, it will be difficult to initialize zsh to <code>~/.zshrc</code> . </p><br><p>  I did not find a brief description of these differences when I switched myself, and I had to spend a lot of time reading the zsh documentation.  I hope this article will make it easier for you to go to zsh. </p><br><h2 id="zachem-perehodit">  Why go </h2><br><p>  For a start, is it worth spending your time and attention on the transition?  To learn another sh dialect, less common than POSIX sh or bash, to re-engage in setting up the working environment ... </p><br><p>  In my opinion, if you spend a lot of time in the console, you like Vim or Emacs and you have already spent a lot of time setting them up for yourself - definitely worth it!  Zsh is very similar in spirit to them: this is a very complex and flexible program, whose capabilities are <em>completely</em> unknown to most, but after spending some time setting it up you can get a <strong>very comfortable working environment for you</strong> . </p><a name="habracut"></a><br><p>  As for the study of the sh dialect ... the benefits of this are probably very few, but the minimum described in this article should be enough to set up zsh, and no one offers you to write new scripts in the zsh dialect.  In general, this is no different from the need to minimally know VimL or Emacs Lisp exclusively for configuring Vim / Emacs. </p><br><p>  In the internet a bunch of articles and presentations describing specific features zsh, greatly simplified someone's life.  I will not list them, because everyone needs different features, and in zsh there are options for every taste.  Instead, I will describe the key features of zsh that allowed these features to be implemented: </p><br><ul><li>  Zsh does not use readline for user input.  Instead, use your own editor ZLE (Zsh Line Editor).  This made it possible to implement many features: convenient editing of multi-line commands, syntax highlighting right in the process of entering commands, special "paste" processing from the clipboard so as not to execute randomly inserted text, flexible control of hot keys, undo (including canceling the result of autocompletion and deployment) glob-s) ... plus integrate the editor's functionality with zsh, which allows you to control its behavior through the usual zsh functions (for example, syntax highlighting is implemented like this). </li><li>  Incredibly complex and flexible command completion mechanism.  It strongly depends on the context, so when you press <code>&lt;Tab&gt;</code> in different places of the command line, different things will be added: command names, their parameters, files, user and server names, process numbers, variable names, array indices and hash keys, zsh syntax elements , names of colors and fonts, network interfaces, system packages ... in short, in general, everything that can be autocompleted.  And it can be monitored in detail, up to a change in the auto-completion logic for a specific context of a particular command. </li><li>  A huge number (177 in zsh-5.2) options that change the behavior of zsh.  With their help, you can, for example, change the supported syntax and enable (including partially) compatibility modes with sh / bash / ksh / csh.  They allow you to have such a significant influence on the work that in zsh you had to make a separate "zsh compatibility mode", which many functions usually include with the first command, because only this gives them a guarantee that the code of this function will be understood by zsh exactly as expected. author. </li><li>  Preference for the most concise, concise syntax - so that you need to type as little text as possible to perform typical, even if quite complex, tasks.  In the code, where readability is important in a month is definitely a minus.  But on the command line - definitely a plus. </li><li>  Modular organization of settings through frameworks (like oh-my-zsh and prezto), plugins, themes, etc.  In fact, there is nothing specific to zsh, exactly the same can be done for bash, but ... for some reason, for zsh, all this is already there, but for bash - not (and if there is, then very few people know about it) .  And this makes it possible to relatively quickly build your version of the zsh settings from the ready-made cubes (as an example, watch the video of the <a href="https://github.com/zsh-users/antigen">zsh Antigen plug-in manager</a> ), just as it is hung with Vim plug-ins. </li></ul><br><h2 id="otlichiya-i-sovmestimost">  Differences and Compatibility </h2><br><p>  Once again I will clarify that I will describe exactly the <em>differences</em> from bash, and not the full set of zsh features.  Most of the functionality you are familiar with works in zsh in the same way as in bash.  But there are often zsh-specific ways to do about the same thing.  This is due to the fact that zsh pays a lot of attention to compatibility with other shells, so in zsh plus their features they dragged a lot of other shells - and as a result received several alternative ways of doing the same thing. </p><br><h2 id="terminy">  Terms </h2><br><ul><li>  <strong>Parameter:</strong> ordinary variable - scalar (string, integer, fractional), array, associative array (hash).  Variables are mainly called environment variables, i.e.  exported scalar parameters. </li><li>  <strong>Argument: a</strong> parameter (in the traditional sense) of a called command or function (function arguments are available through the parameters <code>$@</code> , <code>$1</code> , ...). </li><li>  <strong>Template:</strong> Glob.  As a rule, templates imply a coincidence with real-life files, but in some cases they are applied to a string or a parameter value.  There is also support for full-fledged regulars, but mostly globs are used as templates for matching or searching / replacing. </li><li>  <strong>Flags:</strong> set in parentheses <em>before</em> what they should affect.  For parameters, are specified between the opening brace and the parameter name: <code>${(kv@)some_hash}</code> .  For templates, they can be at the beginning or middle: <code>*CaseImportant(#i)CaseIgnored*.txt</code> . </li><li>  <strong>Qualifiers:</strong> are set in parentheses after the template, specifying its properties not related to the file name: <code>*(/^F)</code> . </li><li>  <strong>Modifiers:</strong> are set each after a colon, are applied in turn by changing the current value.  For parameters, they are specified after the parameter name: <code>$PWD:h:t</code> , <code>${some_param:h:t}</code> .  For templates, are specified before the closing parenthesis of qualifiers: <code>*(:e)</code> . </li></ul><br><h2 id="tekuschie-nastroyki">  Current settings </h2><br><p>  Many built-in commands display the current state when they are run without arguments (plus they often have an argument that draws output in the style of zsh commands, which is quite convenient). </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   setopt #     setopt KSH_OPTION_PRINT; setopt #       bindkey #      ,    zsh for m in $(bindkey -l); bindkey -M $m -L #   (- ) zstyle zstyle -L #   (  ),    zsh alias -L #    ,    zsh alias -s -L #   () typeset #   (),    zsh typeset -p</span></span></code> </pre> <br><p>  This is not a complete list, but for most tasks in the process of (analyzing) setting up zsh it should be enough. </p><br><p>  It may also be useful to run <code>zsh -f</code> - this starts zsh in the default state (without executing any startup scripts except <code>/etc/zshenv</code> , which most systems don‚Äôt have). </p><br><h2 id="setopt-i-emulate">  setopt and emulate </h2><br><ul><li>  In case of option names, case and underscore have no value, plus the prefix "no" can be added before any option. </li><li>  Calling for the same option <code>setopt</code> with the prefix "no" and <code>unsetopt</code> without "no" (as well as vice versa!) Do the same thing. </li><li>  The <code>setopt</code> output uses small letters without underscores, the documentation uses large letters with underscores.  This creates some inconvenience - when searching in the documentation you need to guess where to insert underscores to find the necessary option. </li><li>  The <code>emulate</code> command allows you to set a group of options in bulk to the state of compatibility with sh, ksh, csh or the default state for zsh.  Many functions in zsh begin with the <code>emulate -L zsh</code> command, which allows the key options to be set to the default for zsh for the duration of the function ‚Äî without this, most non-trivial functions may break due to the options set by the user (for example, there is an option that controls how Arrays are indexed - from 1 or from 0). </li></ul><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#         setopt nonumericglobsort setopt NO_numericglobsort setopt NO_NUMERIC_GLOB_SORT setopt _N_O_numERICglob_SORT_ unsetopt NUMERIC_GLOB_SORT unsetopt numericglobsort</span></span></code> </pre> <br><p>  At the beginning of using zsh, for more familiar work after bash, I would recommend the following options: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    fd unsetopt MULTIOS #  ~‚Ä¶  file completion  =   setopt MAGIC_EQUAL_SUBST #   escape sequence  echo  -e setopt BSD_ECHO #      setopt INTERACTIVE_COMMENTS #  $(cmd)  $PS1 etc. setopt PROMPT_SUBST</span></span></code> </pre> <br><p>  There is also the <code>SH_WORD_SPLIT</code> option, and formally, for the usual work after bash, it must also be enabled, but I would not recommend it: the behavior of zsh without this option is more convenient and logical, it is better to get used to it.  It is responsible for how <code>cmd $PARAM</code> will work if the value of <code>$PARAM</code> is a string containing spaces: in bash, <code>cmd</code> will get several arguments, and in zsh it will take one (as if they called <code>cmd "$PARAM"</code> ).  And if <code>$PARAM</code> is an array, then zsh will give <code>cmd</code> one argument for each non-empty element of the array (even if these elements contain spaces). </p><br><p>  (Basically, this article describes the behavior of zsh with default options, otherwise every second sentence would have to be clarified in the style of "but with all such options, it all works differently.") </p><br><h2 id="parametry">  Options </h2><br><ul><li>  Agreement: for the names of scalar parameters (strings, integers and fractional numbers) <em>usually</em> use <code>$</code> letters, and for arrays (ordinary and associative) - <code>$</code> . </li><li>  Through <code>typeset -U</code> you can declare an array with unique elements (attempts to add already existing elements will be ignored). </li><li>  <code>typeset -T</code> you can associate an array with a scalar in the <code>$PATH</code> format.  Several of these related parameters have already been created: <code>$PATH</code> and <code>$path</code> , <code>$FPATH</code> and <code>$fpath</code> , <code>$MANPATH</code> and <code>$manpath</code> , <code>$CDPATH</code> and <code>$cdpath</code> .  For related parameters, it does not matter which of them we change - both change at once.  Therefore, in zsh, with such parameters almost always work through arrays ( <code>$path</code> , <code>$fpath</code> , ...) - this is much more convenient. </li><li>  Some scalar parameters are also related, for example, <code>$PS1</code> , <code>$PROMPT</code> and <code>$prompt</code> (although, they are more likely just synonyms for one parameter). </li></ul><br><h3 id="massivy">  Arrays </h3><br><ul><li>  Indexed with 1. </li><li>  You can use negative indices (from the end of the array). </li><li>  You can use slices. </li><li>  When used as a scalar - combine the elements through the gap. </li><li>  Scalar indexing returns string characters. </li><li>  The global returns an array, so the index can be used as a global qualifier: <code>*([2,-2])</code> . </li></ul><br><h2 id="shablony">  Templates </h2><br><ul><li>  <code>**/</code> - matches the subdirectory of any nesting level, including the absence of a subdirectory </li><li>  <code>&lt;1-2&gt;</code> - matches the number in the specified range in the file name, and the beginning and end of the range can be omitted </li><li>  <code>(1|2)</code> is an alternative (also - grouping brackets when using the <code>EXTENDED_GLOB</code> option) </li><li>  if you enable the <code>EXTENDED_GLOB</code> option, you can optionally use <code>#</code> (repeat the previous element), <code>~</code> and <code>^</code> (exclusion from a match) in the templates </li></ul><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        , #         5   example, #     .txt ls -l **/*(&lt;5-&gt;|example)*.txt</span></span></code> </pre> <br><h2 id="flagikvalifikatorymodifikatory">  Flags / Qualifiers / Modifiers </h2><br><p>  Only templates have qualifiers, they allow you to specify additional file selection criteria: by type (file / directory / symlink / etc.), Rights, time (changes / etc.), Size ... You can sort and index selected files.  It is possible to include for this particular template a match of the initial <code>*</code> with names beginning with a dot.  You can enable the removal of this template from the command line arguments if it does not match any files. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  5-   , #         "a", #    ls -ld *a*(D/om[1,5])</span></span></code> </pre> <br><p>  If you turn on the <code>EXTENDED_GLOB</code> option, you can use flags in templates: for files, case-sensitivity management is of interest, and if there is a match with the parameter / line, there are other useful flags. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    ls -ld .[cC][oO][nN][fF][iI][gG]* setopt extendedglob; ls -ld .(#i)Config*</span></span></code> </pre> <br><p>  There are much more flags available for parameters: outputting all (including empty) array elements even in quotes, performing join or split on a given substring, outputting only keys and / or associative array values, screening with different types of quotes and inverse operation, etc. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#       echo ${(k)some_hash} #  $PATH       ":", #          echo ${(s&lt;:&gt;qq)PATH}</span></span></code> </pre> <br><p>  Both for templates and for parameters, modifiers can be used: deleting the last element of the path, deleting all elements of the path except the last, removing / leaving the extension, escaping and inverse operation, searching and replacing substrings, etc. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     (   #  ,       ) echo $PWD:h:t #   ( )     , #     "fil"  "FIL" (   ) echo **/*(@:t:s/fil/FIL/)</span></span></code> </pre> <br><h2 id="autoload--uz">  autoload -Uz </h2><br><p>  In addition to the traditional way to load code via <code>source /path/to/file.sh</code> or <code>. /path/to/file.sh</code>  <code>. /path/to/file.sh</code> in zsh autoloading code is actively used at the time of the first function call. </p><br><p>  To search for a file with the desired function, <code>$FPATH</code> is used - a variable similar in format to <code>$PATH</code> , containing a list of directories in which a file with the same name as the function being loaded is searched. </p><br><p>  When <code>autoload</code> called <code>autoload</code> no files from the disk are read, and their presence is not even checked - all this will happen when the function is first called.  It is almost always necessary to <code>autoload</code> arguments <code>-U</code> to the <code>autoload</code> (cancels the effect of the current alias for the uploaded file, because alias often configured by the user can disrupt third-party functions) and <code>-z</code> (optional clarification that the uploaded file is in zsh format, but safer than always ask). </p><br><pre> <code class="bash hljs">fpath=(~/my-zsh-functions <span class="hljs-variable"><span class="hljs-variable">$fpath</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -Uz fn fn</code> </pre> <br><p>  The contents of the <code>~/my-zsh-functions/fn</code> file can be in one of these three formats: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,  - : echo "  fn"</span></span></code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        : fn() { echo "  fn" }</span></span></code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,  fn: fn() { fn2 } fn2() { echo "   fn" } echo "    fn" #       fn: fn "$@" echo "    fn"</span></span></code> </pre> <br><h2 id="zkbd">  zkbd </h2><br><p>  When you first run zsh, it often turns out that some of the buttons like the F1 / Backspace / Delete / cursor work incorrectly.  This is due to the fact that the vast majority of console applications use readline and the correct configuration of these buttons is read from <code>/etc/inputrc</code> and <code>~/.inputrc</code> , and zsh does not. </p><br><p>  The problem is solved in the forehead - you need to see which escape sequences issue the necessary buttons in your terminal and specify the necessary handlers for these escape sequences in <code>~/.zshrc</code> .  Like that: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">'^[[A'</span></span> up-line-or-history <span class="hljs-comment"><span class="hljs-comment"># Up bindkey '^[[B' down-line-or-history # Down #  ..</span></span></code> </pre> <br><p>  You can watch the sequences issued by the buttons by running <code>cat &gt;/dev/null</code> and pressing <code>Ctrl-V</code> in front of the desired button.  (And yet, yes, doing this in 2017 I felt a bit strange ...) But with zsh, there is a utility utility, <code>zkbd</code> , that automates this process.  To do this, you must connect it to <code>~/.zshrc</code> , after which you will have an associative <code>$key</code> array containing the necessary escape sequences: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -Uz zkbd [[ ! -f ~/.zkbd/<span class="hljs-variable"><span class="hljs-variable">$TERM</span></span>-<span class="hljs-variable"><span class="hljs-variable">${${DISPLAY:t}</span></span>:-<span class="hljs-variable"><span class="hljs-variable">$VENDOR</span></span>-<span class="hljs-variable"><span class="hljs-variable">$OSTYPE</span></span>} ]] &amp;&amp; zkbd <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/.zkbd/<span class="hljs-variable"><span class="hljs-variable">$TERM</span></span>-<span class="hljs-variable"><span class="hljs-variable">${${DISPLAY:t}</span></span>:-<span class="hljs-variable"><span class="hljs-variable">$VENDOR</span></span>-<span class="hljs-variable"><span class="hljs-variable">$OSTYPE</span></span>} [[ -n <span class="hljs-variable"><span class="hljs-variable">$key</span></span>[Up] ]] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> -- <span class="hljs-variable"><span class="hljs-variable">$key</span></span>[Up] up-line-or-history [[ -n <span class="hljs-variable"><span class="hljs-variable">$key</span></span>[Down] ]] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> -- <span class="hljs-variable"><span class="hljs-variable">$key</span></span>[Down] down-line-or-history <span class="hljs-comment"><span class="hljs-comment">#  ..</span></span></code> </pre> <br><p>  I do not elaborate in detail which commands (such as <code>up-line-or-history</code> ) which buttons should be assigned because, first, you do not have to assign everything, but only those that do not work out of your box, and second, if you think As for what everyone should do, Home or Backspace all converge, here's a search in the history of Up and Down can be done in quite different ways, and the functions in these cases must also be assigned to these buttons. </p><br><p>  (By the way, you can set the Escape character ( <code>^[</code> ) in the bindkey parameter with a real character, typing it using <code>Ctrl-V</code> , and two ordinary characters <code>^[</code> , and two characters <code>\e</code> .) </p><br><h2 id="zstyle">  zstyle </h2><br><p>  This is a built-in way to use context-sensitive settings.  It is in many ways similar to the usual parameters, except for the name and value of the <code>zstyle</code> parameter, <code>zstyle</code> allows <code>zstyle</code> to specify a "context" template.  And then get the values ‚Äã‚Äãrelated to the current context.  This approach is actively used to customize the work of autocompletions, but it can also be used for your scripts. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   my-param=default  3-  , #        (  #    zstyle,      ) #        % zstyle ':my-app:*:*' my-param default #   my-param=val-one  ,    #  ( )    "one" % zstyle ':my-app:one:*' my-param val-one #   my-param=val-two  ,    #  ( )    "two" % zstyle ':my-app:*:two' my-param val-two #   my-param   result    % zstyle -s ':my-app:a:b' my-param result % echo $result default % zstyle -s ':my-app:one:b' my-param result % echo $result val-one % zstyle -s ':my-app:a:two' my-param result % echo $result val-two % zstyle -s ':my-app:one:two' my-param result % echo $result val-one</span></span></code> </pre> <br><h2 id="zmodload">  zmodload </h2><br><p>  Part of the additional functionality of zsh is not implemented in regular scripts loaded via <code>autoload -Uz</code> , but as system libraries <code>*.so</code> .  They are used, for example, to provide access to PCRE regular expressions, math functions, sockets, etc.  Such libraries are loaded via <code>zmodload</code> . </p><br><h2 id="raznoe">  miscellanea </h2><br><p>  To intercept signals, in addition to the standard <code>trap '‚Ä¶;code;‚Ä¶' INT</code> you can use functions with special names: <code>TRAPINT() { ‚Ä¶;code;‚Ä¶ }</code> . </p><br><p>  Many constructions like <code>if</code> , <code>while</code> , etc.  there is an abbreviated form (an example is above, where the value of all bindkey modes was displayed). </p><br><p>  Suddenly, the zsh-specific equivalent of <code>echo</code> ‚Äî the <code>print</code> command ‚Äî turned out to be quite handy when learning zsh.  She knows a lot of things, but from the most useful: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    print -l $path #        , #        print -a -C 2 "${(kv@)ZSH_HIGHLIGHT_STYLES}" | sort #   %-   $PS1 print -P '%Bbold%b %F{red}current%f dir is: %~'</span></span></code> </pre> <br><p><del>  </del>     zsh,       //   <a href="https://github.com/unixorn/awesome-zsh-plugins">Awesome-   zsh</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326580/">https://habr.com/ru/post/326580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326570/index.html">How to talk with artificial intelligence?</a></li>
<li><a href="../326572/index.html">Creating a single-player game: from idea to prototype</a></li>
<li><a href="../326574/index.html">TCP / IP basics for future dilettantes</a></li>
<li><a href="../326576/index.html">Test Data Generator for C ++</a></li>
<li><a href="../326578/index.html">My C ++ I / O streams using std :: streambuf</a></li>
<li><a href="../326582/index.html">The story of how the parser turned into a full-fledged IRCO bot for Telegrams</a></li>
<li><a href="../326584/index.html">Notes on Cisco Catalyst: VLAN setup, password reset, IOS operating system flashing</a></li>
<li><a href="../326588/index.html">How to make your IDEA IDE level</a></li>
<li><a href="../326590/index.html">Mail.Ru Group Online Course News: Restarting Advanced C ++ Programming</a></li>
<li><a href="../326592/index.html">Fat programs - speed factors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>