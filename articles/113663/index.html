<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extend log4net. Competitive Logging</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The log4net library is known and does not need to be presented. It has almost everything you need, "out of the box." However, there are specific situa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extend log4net. Competitive Logging</h1><div class="post__text post__text-html js-mediator-article">  The <a href="http://logging.apache.org/log4net/">log4net</a> library is known and does not need to be presented.  It has almost everything you need, "out of the box."  However, there are specific situations in which it is necessary to add / expand library functionality.  Specific situation: there is some library that performs logging via log4net to some logger (or several - not the essence).  This library is used in N services.  How to make logging happen in a single file?  Under the cut, an explanation of why FileAppender + MinimalLock is not appropriate, and the implementation of the Appender, which solves the problem.  Separately, I want to say that the issue of logging in the database, network, etc.  The article is not considered, because  This is a much more serious task, which (especially for large systems) requires a lot of thought and implementation. <br><br><a name="habracut"></a><br><br>  Immediately make a reservation about the test environment, since in my arguments I will rely on the test results.  The i7 processor (4 cores, 8 taking into account hyper-threading), the application log4net.Extensions.Console performs in 8 threads an entry in the log with an arbitrary Sleep after writing.  The number of entries in the log is 10,000. The BulkStarter application launches 10 instances of log4net.Extensions.Console and waits for them to complete.  Thus, 10 processes, with 8 threads each, write to a single file.  All temporal characteristics were obtained in this test with the help of <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx">Stopwatch</a> (high resolution timer to clock cycles). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  FileAppender + MinimalLock </h2><br>  In log4net, for writing logs to a file there is a FileAppender.  It has an exclusive lock feature (used by default) and the so-called MinimalLock.  ExclusiveLock when initializing log4net opens the file for writing with the ability to read for other processes.  MinimalLock performs file opening / closing for each record in the file.  Accordingly, ExclusiveLock does not suit us at all (since the file for all processes, except the first one that captured the lock on the file, will be unavailable), and MinimalLock has a number of serious flaws: <br><ul><li>  Very slow (from 1:56 of the test, the actual calls to the logging method took 1:40); </li><li>  A conflict of locks, when several processes try to get a stream for writing (and this means not writing to the log). </li></ul>  FileAppender configuration example with Minimal Lock: <br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">appender</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FileAppender"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"log4net.Appender.FileAppender"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"D:\1\test-minlock.log"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lockingModel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"log4net.Appender.FileAppender+MinimalLock"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"log4net.Layout.PatternLayout"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">conversionPattern</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"%message%n"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">appender</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  ConcurrentMinimalLock </h2><br>  In search of a worthy replacement, I came across a 2008 article on the Code Project - <a href="http://www.codeproject.com/KB/cs/concurrentlog.aspx">Logging into single file from multi-process</a> .  The article describes the implementation of ConcurrentMinimalLock, in which messages are buffered, and the file is opened in a loop (until the lock is set yet).  It seems to be all right, but the time to call the logging method is 1:04 of 1:20.  Those.  still long.  And this is also taking into account the fact that this is partially asynchronous logging (if the application is hard-closed, all of the queues will be lost). <br><br><h2>  ConcurrentFileAppender </h2><br>  In my research, I was very surprised that no one wants to use banal mutexes ( <a href="http://msdn.microsoft.com/en-us/library/system.threading.mutex.aspx">Mutex</a> ), because their main purpose is cross-process synchronization.  Therefore, I decided to write my own Appender, which would perform synchronization between processes using a mutex.  To create an Appender, you need the following: <br><ul><li>  Inherit from the abstract class log4net.Appender.AppenderSkeleton; </li><li>  Implement the ActivateOptions method in which Appender is initialized; </li><li>  Implement the Append methods that accept one LoggingEvent and a LoggingEvent array. </li><li>  Implement the OnClose method, which clears resources (Dispose analog in log4net). </li></ul>  The main idea is to add messages to the synchronized queue (using the Monitor), and in a separate thread, write to the file using a named mutex (using the full path to the file) to synchronize file access. <br><br><h3>  ActivateOptions </h3><br>  At the time of initialization, we open the FileStream in write mode, but at the same time specify FileShare read-write.  Those.  other processes will be able to read-write to this file in parallel.  Sorry there is no way to make the file read-only for anyone who is not a ConcurrentFileAppender to those.  support could not edit files (by chance, of course) online.  The fact that we keep the file open gives us the opportunity not to waste too much time on opening, as is done in previous implementations. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActivateOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// flush     base.ActivateOptions(); //       var path = SystemInfo.ConvertToFullPath(Path); var dir = System.IO.Path.GetDirectoryName(path); if (!Directory.Exists(dir)) Directory.CreateDirectory(dir); _loggingEvents = new Queue&lt;LoggingEvent&gt;(QueueInitialCapacity); FileStream stream = null; Mutex mutex = null; try { stream = File.Open(path, FileMode.Append, FileAccess.Write, FileShare.ReadWrite); mutex = CreateMutex(path); _thread = new Thread(ThreadProc) { Name = "ConcurrentFileAppenderListener", IsBackground = true // logging thread should not prevent an application exit }; _thread.Start(); _stream = stream; stream = null; _mutex = mutex; mutex = null; if (FlushOnProcessExit) AppDomain.CurrentDomain.ProcessExit += delegate { OnProcessExit(path); }; } finally { if (stream != null) stream.Dispose(); if (mutex != null) mutex.Close(); } }</span></span></code> </pre><br><br><h3>  Threadproc </h3><br>  The method is trite in a loop to check the queue for non-empty.  If the queue is non-empty, we copy its contents, clear it and dump it to disk. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThreadProc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> culture = CultureInfo.InvariantCulture; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_nonEmptyQueue) <span class="hljs-comment"><span class="hljs-comment">//      bool     { Thread.Sleep(QueueEmptyCheckTimeoutInMilliseconds); continue; } lock (QueueSyncRoot) { _currentProcessingEvents = _loggingEvents.ToArray(); _loggingEvents.Clear(); _nonEmptyQueue = false; } Flush(_mutex, _stream, culture, _currentProcessingEvents); _currentProcessingEvents = null; } }</span></span></code> </pre><br><br><h3>  Flush </h3><br>  The messages accumulated in the queue are first written to the buffer, and then this buffer is completely removed to the disk in order not to make consecutive calls to Write.  Another important point is to perform Seek before writing, since the current position of the file cursor is cached. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flush</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mutex mutex, FileStream stream, CultureInfo culture, ICollection&lt;LoggingEvent&gt; events</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events.Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringWriter(culture)) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events) RenderLoggingEvent(sw, e); buffer = Encoding.GetBytes(sw.ToString()); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mutex.WaitOne(); stream.Seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, SeekOrigin.End); stream.Write(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); stream.Flush(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { mutex.ReleaseMutex(); } }</code> </pre><br><br><h3>  Final implementation </h3><br>  In the end, the base class ConcurrentAppenderSkeleton was written: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConcurrentAppenderSkeleton</span></span> : <span class="hljs-title"><span class="hljs-title">AppenderSkeleton</span></span>, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Gets a name for a </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="Mutex"/&gt;</span></span></span><span class="hljs-comment">. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected abstract string UniqueMutexName { get; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Performs initialization of an appender. Should throw exception if cannot be initialized. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected abstract void ActivateOptionsInternal(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Prepares data to a flushing. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;para&gt;</span></span></span><span class="hljs-comment">This method executes in a thread safe context (under </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="Monitor"/&gt;</span></span></span><span class="hljs-comment"> lock).</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/para&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="events"&gt;</span></span></span><span class="hljs-comment">Logging events.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">A prepared data.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> protected abstract object PrepareData(LoggingEvent[] events); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Flushes prepared data. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;para&gt;</span></span></span><span class="hljs-comment">This method executes in a thread-safe context (under mutex).</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/para&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/remarks&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="data"&gt;</span></span></span><span class="hljs-comment">A prepared data to a flushing.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected abstract void Flush(object data); }</span></span></code> </pre><br>  And the heirs: ConcurrentFileAppender and ConcurrentForwardingAppender (by analogy with <a href="http://logging.apache.org/log4net/release/sdk/log4net.Appender.BufferingForwardingAppender.html">BufferingForwardingAppender</a> ).  The latter allows you to write (Flush) to the set of other Appenders.  It is important that these other Appenders do not make exclusive locks (i.e., you cannot use FileAppender + ExclusiveLock), and they will be synchronized with the mutex. <br><br>  For test purposes, I added a setting in which place to synchronize on the mutex: either immediately before receiving messages from the queue, or just for writing to a file.  In the first case, there is an increase in the number of queues (due to longer locks, since they include formatting and writing), but some reduction in input-output costs (since 10 entries of 10K are made faster than 100 of 1KB).  In the second case, the queue does not grow very much, being in the lock is minimal (only the time for the I / O itself), which is more scalable. <br><br><h2>  Tests </h2><br>  Let me remind you that the test is a logging 500 MB out of 10 processes with 8 threads each.  The table below shows the results for various tests.  ConcurrentFileAppender will be displayed in abbreviated form as File, ConcurrentForwardingAppender (recorded in FileAppender + MinimalLock) as Fwd + Min, and an exotic variant - ConcurrentForwardingAppender, where recording is conducted in FileAppender with ConcurrentMinimalLock will be denoted as Fwd + Con.  Sleep time to poll the queue - 10ms.  Mutex.WaitOne for write-only will be designated as IO, for formatting and recording - Whole. <br><br><table><tbody><tr><td>  Time (s) \ Test </td><th>  Minlock </th><th>  Concurrent minlock </th><th>  File io </th><th>  File whole </th><th>  Fwd + Min IO </th><th>  Fwd + Min Whole </th><th>  Fwd + Con IO </th><th>  Fwd + Con Whole </th></tr><tr><th>  Total time </th><td>  116,6 </td><td>  79.7 </td><td>  11.27 </td><td>  11.6 </td><td>  11.96 </td><td>  11.61 </td><td>  11.7 </td><td>  11.61 </td></tr><tr><th>  logger.Debug </th><td>  100.36 </td><td>  64.68 </td><td>  0.08 </td><td>  0.07 </td><td>  0.07 </td><td>  0.07 </td><td>  0.08 </td><td>  0.07 </td></tr><tr><th>  Wed  queue length </th><td>  - </td><td>  - </td><td>  9 </td><td>  40 </td><td>  185 </td><td>  169 </td><td>  17 </td><td>  25 </td></tr></tbody></table><br>  As can be seen from the table, when using a mutex lock only at the time of I / O, the message queue is smaller, which somewhat increases reliability.  If you need to use RollingFileAppender functionality, it makes sense to use ConcurrentForwardingAppender in conjunction with ConcurrentMinimalLock, although it is better to write your own version of Lock, which will not do double buffering. <br><br>  The two main advantages of Concurrent * Appenders are multiprocessing and the virtual absence of slowing down the main application while logging is enabled. <br><br><h2>  PS </h2><br>  In the process of registration of the article I noticed an error in counting the total time and calling the logger.Debug method.  With not my appenders, everything turned out to be even worse, and with my even better :) But I didn‚Äôt begin to update the original results table, because  very long, sorry (the error is that in log4net.Extensions.Console access to the Stopwatch instance was out of sync + it was necessary to divide the value by 8). <br><br>  References: <br><ul><li>  <a href="http://logging.apache.org/log4net/">Official log4net page</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/system.threading.mutex.aspx">System.Threading.Mutex</a> - a class that implements the mutex functionality in the .NET Framework </li><li>  <a href="http://www.codeproject.com/KB/cs/concurrentlog.aspx">Logging into single file from multi-process</a> (logging into one file from multiple processes) </li></ul>  Files: <br><ul><li>  <a href="http://narod.ru/disk/5551013001/log4net.Extensions.zip.html">Appender implementation and test applications</a> </li><li>  <a href="http://narod.ru/disk/5551321001/log4net-run-result.zip.html">Run results + ods file with extended results table</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/113663/">https://habr.com/ru/post/113663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113654/index.html">Formal description of L4 hardware microkernel</a></li>
<li><a href="../113655/index.html">Accident in Oversan Scalaxi</a></li>
<li><a href="../113657/index.html">Using Xapian Full-Text Search Library in Python</a></li>
<li><a href="../113658/index.html">"Hello World" BPMN2.0 or Activiti Introduction</a></li>
<li><a href="../113660/index.html">The Japanese announced the simplest emergency phone</a></li>
<li><a href="../113670/index.html">BUNKER DataCenter - Radiation Threat Canceled</a></li>
<li><a href="../113671/index.html">Presented tablet Galaxy Tab 2</a></li>
<li><a href="../113672/index.html">We work with jQuery Templates. Part Three, jQuery Templates Plus</a></li>
<li><a href="../113673/index.html">Personal account of the Beeline Internet (Corbin) and intrusive surveys</a></li>
<li><a href="../113675/index.html">How to please your favorite February 14</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>