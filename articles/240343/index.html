<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Ebean made friends with Gradle and made peace with IntelliJ Idea</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I finally matured to start my web project. Another todo-manager who aggregates tasks from the sources I need. It was planned as a project for the soul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Ebean made friends with Gradle and made peace with IntelliJ Idea</h1><div class="post__text post__text-html js-mediator-article">  I finally matured to start my web project.  Another todo-manager who aggregates tasks from the sources I need.  It was planned as a project for the soul, so clean and correct.  No compromise in architecture and technology.  Only best-practices, only hardcore.  And, of course, all this is going to push a button in your favorite Intellij IDEA. <br><br>  After 7 years of Java, the last two mixed with Scala, I wanted to try Groovy.  For assembly, of course, Gradle is popular and convenient.  The rails seemed too "hackneyed", so I decided to use Spring for the web, and moreover, using the modern, through the <a href="http://projects.spring.io/spring-boot/">Spring Boot</a> .  And everything was just wonderful, only with ORM did not work out.  At work, we sawed out Hibernate, the customer personally disliked (do not laugh, and it happens - a separate story) and replaced with his bicycle.  Negative experience and unwillingness to pull a monster for the sake of a couple of entities made their own - there is no hard way for Hiberneyt!  I wanted to try something completely different.  By chance, stumbled upon <a href="http://www.avaje.org/">Ebean</a> , which was chosen. <br><br>  After the final stack was collected, work began to boil.  But here's a bad luck, the wagon with the functional has not yet moved from its place.  Under the cut sincere excuse why. <br><a name="habracut"></a><br><h4>  <b>Ebean</b> </h4><br>  This opensource ORM framework, in my opinion, was created by the heaters of the classic JPA implementations, just to please the hipsters.  Of the key features: <br><ul><li>  familiar mapping (uses java.persistence annotations); </li><li>  simple API; </li><li>  easy to set up; </li><li>  flexible fetching related entities; </li><li>  partial sampling; </li><li>  tracking changes; </li><li>  lack of sessions; </li><li>  native transaction support; </li><li>  asynchronous loading; </li><li>  and even auto tuning! </li></ul><br>  That is all that is needed for a regular, non-enterprise web application.  The authors of the framework did a really great job.  I think it was not for nothing that he was added as one of the regular ORM in Play!  First, it scares that the <a href="http://www.avaje.org/">site</a> is somehow poorly updated, and the development has stopped.  But no, GitHub has a very fresh version of <a href="https://github.com/ebean-orm/avaje-ebeanorm">avaje-ebeanorm</a> 4.x.  And thanks to Play's community and popularity, the project continues to evolve.  As proof of activity on GitHub: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/31f/dee/376/31fdee376c794300bf392f16a68b71e6.png"><br><br>  Here are some examples of what basic requests look like in Ebean: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// find an order by its id Order order = Ebean.find(Order.class, 12); // find all the orders List&lt;Order&gt; list = Ebean.find(Order.class).findList(); // find all the orders shipped since a week ago List&lt;Order&gt; list = Ebean.find(Order.class) .where() .eq("status", Order.Status.SHIPPED) .gt("shipDate", lastWeek) .findList();</span></span></code> </pre> <br>  Creating, saving and updating entities: <br><pre> <code class="java hljs">Order order = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Order(); order.setOrderDate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date()); ... <span class="hljs-comment"><span class="hljs-comment">// insert the order Ebean.save(order); //If the bean was fetched it will be updated Order order = Ebean.find(Order.class, 12); order.setStatus("SHIPPED"); ... // update the order Ebean.save(order);</span></span></code> </pre><br>  Work with partial objects: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// find order 12 // ... fetching the order id, orderDate and version property // .... nb: the Id and version property are always fetched Order order = Ebean.find(Order.class) .select("orderDate") .where().idEq(12) .findUnique(); // shipDate is not in the partially populated order // ... so it will lazy load all the missing properties Date shipDate = order.getShipDate(); // similarly if we where to set the shipDate // ... that would also trigger a lazy load order.setShipDate(new Date());</span></span></code> </pre><br>  Inspired by the examples, the final decision was made to use the latest, actively supported version 4.1.8.  Combat mood.  Added a dependency to build.gradle: <br><br><pre> <code class="javascript hljs">compile(<span class="hljs-string"><span class="hljs-string">'org.avaje.ebeanorm:avaje-ebeanorm:4.1.8'</span></span>)</code> </pre><br>  Created configuration: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@PropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"config/db.properties"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EbeanConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> DbConfig dbConfig <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">EbeanServer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebeanServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EbeanServerFactory.create(serverConfig()) } <span class="hljs-function"><span class="hljs-function">ServerConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serverConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerConfig( dataSourceConfig: dataSourceConfig(), name: <span class="hljs-string"><span class="hljs-string">"main"</span></span>, ddlGenerate: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ddlRun: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, defaultServer: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, register: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, namingConvention: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MatchingNamingConvention() ) } <span class="hljs-function"><span class="hljs-function">DataSourceConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSourceConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSourceConfig(driver: dbConfig.driver, username: dbConfig.username, password: dbConfig.password, url: dbConfig.url) } }</code> </pre><br>  And the test entity: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> UUID id Integer value }</code> </pre><br>  I already rubbed my hands in anticipation of the beloved profit'a all.  But ... there are no fairy tales, and of course, everything fell at the start with <i>java.lang.IllegalStateException: Bean class xxxTestEntity is not enhanced?</i> <br><br>  Usually people read the documentation only when something goes wrong.  And it is even good.  It turns out that for normal operation, Ebean needs to expand the bytecode of .class files at the assembly stage, i.e.  immediately after compilation.  Why do you need it?  Almost all ORMs are built into classes, just the majority get out differently.  Hibernate, for example, creates a proxy runtime through <a href="https://github.com/cglib/cglib">cglib</a> to intercept access to Lazy collections.  Transparently honest lazy without such hacks just do not.  Ebean, along with all, supports lazy loading, plus partial objects, and also tracks changes in each field in order not to send too much to the server during a save operation. <br><br>  Early versions of the library supported two approaches to proxying: patching a .class file and instructing class code when loading via ClassLoader (it was required to connect an agent at the start of the JVM).  Over time, for simplicity, support left only the first option. <br><br>  Hmm ... Difficult, but ... People somehow live with Ebean in the Play Framework?  It turns out that the ORM itself is supplied with a separate <a href="https://github.com/ebean-orm/avaje-ebeanorm-agent">ebeanorm-agent</a> library, which is able to expand the compiled .class file byte code, and the SBT on which Play keeps it successfully uses.  Since in Play the assembly of the code is only internal, everything works like a clock.  And no one, probably, doesn‚Äôt guess what is going on behind the scenes. <br><br><h4>  <b>Gradle</b> </h4><br>  But the question is, is there such a thing for Gradle?  For Maven there is exactly a plugin.  But for Gradle, I found absolutely nothing (maybe I looked badly).  At first I was upset, and even thought of quitting this venture ... But at the last moment I got ready and decided what would have happened to finish the job. <br><br><h5>  So, do the missing plugin! </h5><br>  The easiest way to add your own build tools to Gradle is to create the <i>buildSrc</i> module in the project root directory.  The code from this module will be automatically available in all other build scripts (all options are described <a href="http://www.gradle.org/docs/current/userguide/custom_plugins.html">here</a> ). <br><br>  Next we create build.gradle inside the <i>buildSrc</i> directory: <br><pre> <code class="javascript hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'groovy'</span></span> repositories { mavenCentral() } dependencies { <span class="hljs-comment"><span class="hljs-comment">//      compile 'org.avaje.ebeanorm:avaje-ebeanorm-agent:4.1.5' }</span></span></code> </pre><br>  Although the <i>buildSrc</i> approach does not require the creation of a plugin (you can simply write and call code from a Groovy script), we will go the right way, extending the Gradle API.  After all, for sure, later, you will want to arrange it all as a finished product and put it somewhere for general use. <br><br>  The main idea of ‚Äã‚Äãthe plugin is that after each compilation step of Java, Groovy or Scala, find and process the compiler-created .class files that will be used by Ebean.  This task is solved like this: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EbeanPlugin</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Project</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - ! private static def supportedCompilerTasks = ['compileJava', 'compileGroovy', 'compileScala'] //     ,   void apply(Project project) { //        def params = project.extensions.create('ebean', EbeanPluginParams) //  ,    ... def tasks = project.tasks //...         supportedCompilerTasks.each { compileTask -&gt; tryHookCompilerTask(tasks, compileTask, params) } } private static void tryHookCompilerTask(TaskContainer tasks, String taskName, EbeanPluginParams params) { try { def task = tasks.getByName(taskName) //      , ..  task.doLast({ completedTask -&gt; //        enhanceTaskOutput(completedTask.outputs, params) }) } catch (UnknownTaskException _) { ; //    } } private static void enhanceTaskOutput(TaskOutputs taskOutputs, EbeanPluginParams params) { //      ,      taskOutputs.files.each { outputDir -&gt; if (outputDir.isDirectory()) { def classPath = outputDir.toPath() // ,        def fileFilter = new EbeanFileFilter(classPath, params.include, params.exclude) //     new EBeanEnhancer(classPath, fileFilter).enhance() } } } } //   ,      build.gradle class EbeanPluginParams { String[] include = [] String[] exclude = [] }</span></span></code> </pre><br><br>  Next, it's up to the expander itself.  The algorithm is very simple: first, we recursively collect all .class files inside the base directory suitable for the filter, and then pass them through the ‚Äúagent‚Äù.  The processing itself is simple: there is an entity ‚Äî a transformer, as well as a wrapper assistant for processing from the input stream.  Having created and connected both of us, all that remains is to open the file and call transform (...), simultaneously placing a bunch of catch for possible errors.  Everything in the collection looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EBeanEnhancer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Path classPath </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> FileFilter fileFilter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EBeanEnhancer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path classPath)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(classPath, { file -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }) } EBeanEnhancer(Path classPath, FileFilter fileFilter) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classPath = classPath <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileFilter = fileFilter } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enhance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ collectClassFiles(classPath.toFile()).each { classFile -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileFilter.accept(classFile)) { enhanceClassFile(classFile); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enhanceClassFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File classFile)</span></span></span><span class="hljs-function"> </span></span>{ def transformer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transformer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemClassBytesReader(classPath), <span class="hljs-string"><span class="hljs-string">"debug="</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//0-9 -&gt; none - all def streamTransform = new InputStreamTransform(transformer, getClass().getClassLoader()) def className = ClassUtils.makeClassName(classPath, classFile); try { classFile.withInputStream { classInputStream -&gt; def enhancedClassData = streamTransform.transform(className, classInputStream) if (null != enhancedClassData) { //transformer returns null when nothing was transformed try { classFile.withOutputStream { classOutputStream -&gt; classOutputStream &lt;&lt; enhancedClassData } } catch (IOException e) { throw new EbeanEnhancementException("Unable to store an enhanced class data back to file $classFile.name", e); } } } } catch (IOException e) { throw new EbeanEnhancementException("Unable to read a class file $classFile.name for enhancement", e); } catch (IllegalClassFormatException e) { throw new EbeanEnhancementException("Unable to parse a class file $classFile.name while enhance", e); } } private static List&lt;File&gt; collectClassFiles(File dir) { List&lt;File&gt; classFiles = new ArrayList&lt;&gt;(); dir.listFiles().each { file -&gt; if (file.directory) { classFiles.addAll(collectClassFiles(file)); } else { if (file.name.endsWith(".class")) { classFiles.add(file); } } } classFiles } }</span></span></code> </pre><br>  How filters are made to show no sense (or shame).  This can be any implementation of the java.io.FileFilter interface.  And in fact, this functionality is not required. <br><br>  FileSystemClassBytesReader is another matter.  This is a very important element of the process.  It reads the associated .class files if the transformer needed them.  For example, when a subclass is being analyzed, the ebean-agent requests a superclass through the ClassBytesReader in order to check it for the @MappedSuperclass annotation.  Without this <i>java.lang.IllegalStateException: Bean class xxxSubClassEntity is not enhanced?</i>  flies without hesitation. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileSystemClassBytesReader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassBytesReader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path basePath; FileSystemClassBytesReader(Path basePath) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.basePath = basePath; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getClassBytes(String className, ClassLoader classLoader) { def classFilePath = basePath.resolve(className.replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>) + <span class="hljs-string"><span class="hljs-string">".class"</span></span>); def file = classFilePath.toFile() def buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[file.length()] <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { file.withInputStream { classFileStream -&gt; classFileStream.read(buffer) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EbeanEnhancementException(<span class="hljs-string"><span class="hljs-string">"Failed to load class '$className' at base path '$basePath'"</span></span>, e); } buffer } }</code> </pre><br>  In order to call the plugin by the beautiful 'ebean' identifier, you need to add the ebean.properties file to the buildSrc / resources / META-INF folder: <br><pre> <code class="hljs cs">implementation-<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=com.avaje.ebean.gradle.EbeanPlugin</code> </pre><br>  Everything.  Plugin ready. <br><br>  And finally, we add some wonderful lines to the build.gradle of the main project: <br><br><pre> <code class="javascript hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'ebean'</span></span> <span class="hljs-comment"><span class="hljs-comment">// property-     ebean { //    include = ["com.vendor.product"] exclude = ["SomeWeirdClass"] }</span></span></code> </pre><br>  This is the story of Ebean‚Äôs successful encounter with Gradle.  Everything is going and working as needed. <br><br>  You can download the plugin on the GitHub <a href="https://github.com/khomich/gradle-ebean-enhancer">gradle-ebean-enhancer</a> .  Unfortunately, for now everything is damp and the code needs to be copied to buildSrc.  In the near future we will finish and send it to Maven Central and the Gradle repository. <br><br><h4>  <b>IntelliJ Idea</b> </h4><br>  <b>Good news:</b> for Idea 13 there is a <a href="https://github.com/ykrasik/idea-ebean-enhancer">plugin</a> from Yevgeny Krasik, for which many thanks to him!  The plugin ‚Äúlistens‚Äù to the build process and, hot on the heels of the compiler, extends .class files.  I need this to launch and debug Spring Boot application from Idea itself, because it is so much more convenient and familiar. <br><br>  <b>The bad news: the</b> plugin works with the old version of the agent library 3.2.2.  The product of its activity is incompatible with Ebean 4.x and results in strange start actions. <br><br>  <b>Solution:</b> make a fork on github and rebuild the plugin for the correct version. <br><br>  Everything went like clockwork.  The application has started.  The test entity was able to save and load. <br><br>  In fact, it was possible not to write about it ... but there is one ‚Äúbut‚Äù.  As soon as I started building the hierarchy of entities and BaseEntity appeared with @MappedSuperclass, <i>java.lang.IllegalStateException: Bean class xxxSubClassEntity is not enhanced?</i>  here again. <br><br>  javap showed that for some reason all subclasses are not extended.  Why-yyyy?  Why? <br><br>  It turned out that the IDE-plugin crept into an annoying error.  When expanding the current class, the transformer, as always, tries to analyze the subclass as well.  To do this, I remind you that he needs to provide an implementation of the ClassBytesReader.  Only for some reason, the implementation of the IDE plug-in, instead of binary data, ‚Äúfed‚Äù the source code to Groovy to the transformer, with which he ‚Äúchoked‚Äù. <br><br>  So that the fork was very helpful.  It was: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//virtualFile       Groovy if (virtualFile == null) { return null; } try { return virtualFile.contentsToByteArray(); // o_O ? } catch (IOException e) { throw new RuntimeException(e); }</span></span></code> </pre><br>  It became: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (virtualFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { compileContext.addMessage(CompilerMessageCategory.ERROR, <span class="hljs-string"><span class="hljs-string">"Unable to detect source file '"</span></span> + className + <span class="hljs-string"><span class="hljs-string">"'. Not found in output directory"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Module fileModule = compileContext.getModuleByFile(virtualFile); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> VirtualFile outputDirectory = compileContext.getModuleOutputDirectory(fileModule); <span class="hljs-comment"><span class="hljs-comment">//      final VirtualFile compiledRequestedFile = outputDirectory.findFileByRelativePath(classNamePath + ".class"); if (null == compiledRequestedFile) { compileContext.addMessage(CompilerMessageCategory.ERROR, "Class file for '" + className + "' is not found in output directory", null, -1, -1); return null; } try { return compiledRequestedFile.contentsToByteArray(); } catch (IOException e) { throw new RuntimeException(e); }</span></span></code> </pre><br>  Profit!  I admit that the author of the plugin did not use the ORM framework very much.  Although, the only thing I can complain about is the absence of imputed error messages.  After all, it is somehow sad to observe a quietly not working product. <br><br>  The complete, corrected plug-in code can be found in the only fork at the time of this writing on the GitHub <a href="https://github.com/khomich/idea-ebean-enhancer">idea-ebean-enhancer</a> .  There is also a link to a zip ready for installation. <br><br><h4>  <b>Results</b> </h4><br>  IntelliJ Idea users finally got a fully working plugin, with support for the latest version of Ebean. <br><br>  Along with Maven, Gradle also got an extension to support this ORM framework. <br><br>  I hope that the way I have made will help readers to dare to try, what kind of beast is this <b>Ebean</b> .  After all, it seems that all significant obstacles on this path have been overcome.  Well, or at least inspire to go the same way and delight in the insides of some unfamiliar library. <br><br>  It also seemed pretty funny to me that writing the code took significantly less time than preparing this publication. </div><p>Source: <a href="https://habr.com/ru/post/240343/">https://habr.com/ru/post/240343/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240329/index.html">25 PHP developers you can subscribe to</a></li>
<li><a href="../240333/index.html">WinJS 3.0 - release for all platforms</a></li>
<li><a href="../240337/index.html">Startup: "Idea", "Implementation", "Sales" ...</a></li>
<li><a href="../240339/index.html">Documentation for the mod_xml_radius module from FreeSWITCH</a></li>
<li><a href="../240341/index.html">How to search for clients for a small regional web studio</a></li>
<li><a href="../240345/index.html">New 0day vulnerability in Windows is exploited in-the-wild</a></li>
<li><a href="../240347/index.html">Why do business hackathons?</a></li>
<li><a href="../240349/index.html">Expressive JavaScript: Functions</a></li>
<li><a href="../240351/index.html">Announcement of the first meeting of Java User Group Sevastopol</a></li>
<li><a href="../240357/index.html">5 popular javascript hacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>