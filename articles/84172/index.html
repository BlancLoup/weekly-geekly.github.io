<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple and effective method to reflect http DDoS from 50mbit using nginx and iptables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 I offer you a simple and at the same time effective method of dealing with http DDoS. Based on the Xeon 2.5GHz / 4Gb RAM / SAS server, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple and effective method to reflect http DDoS from 50mbit using nginx and iptables</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr! <br>  I offer you a simple and at the same time effective method of dealing with http DDoS.  Based on the Xeon 2.5GHz / 4Gb RAM / SAS server, you can repel an attack up to about 300 Mbps (the value is obtained by an extrapolation method). <br><br><h5>  Implementation method </h5><br>  The system parameters are fine tuned.  So the north will be able to withstand more connections from the botnet than the channel to the server can skip. <br><br><h5>  Application area </h5><br>  Fight Http DDoS on a dedicated server or VPS.  The maximum possible power to deter DDoS attacks is limited by the physical capabilities of the server and the bandwidth of the channel. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  SEO under DDoS </h5><br>  Your site will be correctly indexed during the attack, which will allow you to maintain your position in the search engines.  Especially true for sites with large SEO budgets. <br><br><h5>  Cost and effectiveness </h5><br>  At the time of the attack will have to abandon some of the services of your site.  You may have to expand the channel bandwidth, move the site to a more powerful server.  Efficiency is achieved by maximizing the scalability of the system.  Provides rapid build-up of hardware resources with an increase in attack power. <a name="habracut"></a><br><br><h5>  Method Description </h5><br>  I will talk about the application of the method and the results achieved, based on a real case of the fight against http DDoS attack. <br><br>  I had two Xeon 2.5GHz / 4Gb RAM / SAS servers, the first for PHP, the second for the database.  All settings were made on the first server. OC - Debian 4, the site was with ~ 60k traffic.  The frontend was nginx.  The system kernel was configured by default.  The standard ban tool for ip - iptables in a particular case has coped with a botnet attack of up to 7K in size. <br>  In the case of a more powerful attack will have to install ipset. <br><br><h4>  The history of the fight against DDoS </h4><br><h5>  The first day.  Network stack overflow </h5><br>  The IP address allocated under DOS will stop responding to any requests (ping, http, ssh), while the rest of the IP server will continue to work properly.  If the server has several IPs then the site under DOS will fall, the work of other sites on the server and ssh will not be broken. <br>  By default, the Debian OS and other OSes are not able to support the huge number of connections created by the botnet.  You need to make changes to the kernel settings to strengthen the TCP / IP stack.  I will not elaborate on the configuration of the kernel, I will give only an example of such a configuration. <br><br> <code>net.ipv4.conf.all.accept_redirects = 0 <br> net.ipv4.conf.eth0.accept_redirects = 0 <br> net.ipv4.conf.default.accept_redirects = 0 <br> net.core.rmem_max = 996777216 <br> net.core.wmem_max = 996777216 <br> net.ipv4.tcp_rmem = 4096 87380 4194304 <br> net.ipv4.tcp_mem= 786432 1048576 996777216 <br> net.ipv4.tcp_wmem = 4096 87380 4194304 <br> net.ipv4.tcp_max_orphans = 2255360 <br> net.core.netdev_max_backlog = 10000 <br> net.ipv4.tcp_fin_timeout = 10 <br> net.ipv4.tcp_keepalive_intvl = 15 <br> net.ipv4.tcp_max_syn_backlog = 2048 <br> net.ipv4.tcp_synack_retries = 1 <br> kernel.msgmnb = 65536 <br> kernel.msgmax = 65536 <br> kernel.shmmax = 494967295 <br> kernel.shmall = 268435456 <br> net.core.somaxconn= 16096</code> <br> <br>  Similarly, you can read about the parameters in the documentation, for example <a href="">debian.telenet.ru/doc/sysctl.conf</a> , and better search through google.com for the latest articles on this topic. <br>  Carefully change the kernel configuration and restart the server ... <br>  So.  Our system is able to withstand the onslaught of bots.  But celebrating the victory is still very early.  Due to the huge number of connections, PHP and database processes completely ‚Äúeat up‚Äù memory and processor resources, so the load average value exceeds 100 points. <br>  Necessary to cut parasitic connections <br><br><h5>  Disadvantages of bots search with the netstat command </h5><br>  The anti-dos administrator, whom I addressed with the problem, suggested a method for finding bots with the netstat command.  In the process of applying this method, I noticed several significant flaws.  Consider them in detail: <br>  1. Creating a blacklist takes a lot of time, which does not allow us to frequently update blacklist <br>  2. Effective bots search is possible only when the web server is stopped.  At this time, the site is not available to customers and there is a risk of improper site indexing by search engines. <br>  3. The blacklist can get IP search robots, which is unacceptable <br><br>  Realizing the ineffectiveness of the proposed method, I began to create my own search method and ban bots which should <br>  1. ensure the continued stable operation of the web server (site) <br>  2. guarantees the least probability in the blacklist of search robots <br><br><h5>  Second day.  Possibilities of server hardware + nginx </h5><br>  Xeon 2.5GHz / 4Gb RAM / SAS DoS server with <i>GET / HTTP / 1.1</i> requests <i>.</i> <br><ol><li>  Experiment A. The web server (in this case, nginx) is stopped <br>  Inbound traffic 6085.2 kbits / sec <br>  Outgoing traffic 5342.1 kbits / sec </li><li>  Experiment B. Nginx gives empty HTML (return 444;) <br>  56 Mbps inbound traffic <br>  Outgoing traffic 54 Mbit / s </li><li>  Experiment B. Nginx gives HTML of about 2 Kb in size - this is a page with a small message like ‚Äúwe apologize for the interruptions in the work of the site‚Äù <br>  57 Mbps inbound traffic <br>  Outgoing traffic 353 Mbps </li></ol><br>  &lt;...&gt; * <br><br>  Based on the experiment, we can draw the following conclusions: <br><br>  a) You can completely abandon filtering if there is enough channel capacity and no inbound / outbound traffic ratios. <br>  Your site will be available to customers at the cost of huge parasitic traffic. <br>  Frivolous solution to completely abandon filtering.  Attackers can increase the power of DoS so that the gigabit channel will fall. <br><br>  b) When we ban absolutely all bots, the parasitic traffic from the botnet will be only 5 Mbit / s.  Banning all bots is also impossible, it will take too many resources.  In addition, the probability of a ban of search robots is high. <br><br>  It is also necessary to pay attention to the fact that outgoing traffic with the latter case exceeded 100 Mbit / s.  This means that the server connected to the 100 Mbps port will become very difficult to access via ssh due to the full load of the channel.  To avoid such trouble, I recommend setting the return of empty HTML or return 444 in nginx before the bot filtering setup is complete. <br><br><h5>  Nginx bots search </h5><br>  In this case, the server is attacked by requests <i>: "GET / HTTP / 1.1"</i> . <br>  We make an assumption that good customers make no more than 2 simultaneous requests to the main page of the site.  We consider clients who open more than 3 simultaneous connections by attacking bots and ban their IP addresses on the firewall. <br><br>  The assumption was confirmed experimentally.  Based on the analysis of the http http requests per day from 120,000 IP addresses, only with 19 IPs, more than 2 simultaneous requests were made. <br><br>  To implement the search bots create a special request processing. <br>  <i>request: ‚ÄúGET / HTTP / 1.1‚Äù</i> in nginx. <br> <code>error_log /var/log/nginx/error.log; <br> &lt;‚Ä¶&gt; <br> location =/ { <br> limit_conn one 3; <br> root /home/www/site.ru; <br> } <br></code> <br>  IP addresses from which more than 3 simultaneous connections were opened will be recorded in error.log with a message limiting connections by zone.  Based on the error log, we can build the blacklist ip of the attacking botnet. <br><br><h5>  Filtering bots in iptables </h5><br>  It is important to notice.  IPtables are not suitable for filtering a large number of addresses.  With the number of chains&gt; 2K iptables, the ksoftirqd process begins to consume 100% of the CPU, which leads to an extremely high server load.  The problem is solved by installing ipset or reducing the number of rules in iptables. <br>  In this case, the ipset installation was postponed in case of emergency.  The server did not have a built-in KVM and rebuilding the kernel was risky. <br><br>  Let's start creating a blacklist.  In the ban, we will place only the most aggressive bots, so as not to overload iptables. <br><br> <code>#   <br> cat /var/log/nginx/error.log | grep "limiting connections by zone" | grep "request: \"GET / HTTP/1.1"| awk '{print $12}'| awk -F"," '{print $ <br> 1}'| sort | uniq -c | sort -nr &gt; /tmp/botnet.blacklist <br> #    <br> cat /dev/null &gt; /tmp/iptables_ban.sh <br> #  DROP   50    <br> awk '{print "iptables -A INPUT -p tcp --dport 80 -s " $2 " -j DROP" }' botnet.blacklist | head -n 50 &gt;&gt; /tmp/iptables_ban.sh <br> #  blacklist <br> bash /tmp/iptables_ban.sh <br> #    <br> cat /dev/null &gt; /home/www/nginx_log/error.log <br> [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`</code> <br> <br>  Add the script to the cron with a frequency of several minutes.  We select the frequency by experience.  I did every 5 minutes. <br><br> <code>*/5 * * * * /root/script/ban.sh</code> <br> <br>  As a result, iptables will be updated with new bots. <br><br>  Filtration scheme <br><img src="http://kuzmin.tv/_habr/nginx_ddos/iptables-botnet-drop.gif" alt="ddos nginx iptables"><br><br><h4>  Third day.  Total </h4><br>  This method has provided stable access for clients to the site.  Correct indexing in the PS was confirmed by the fact that the site retained its position in the issue.  Server load did not go beyond reasonable limits la no more than 6-7 points.  Outgoing traffic from the server did not exceed 100 Mbps.  To repel an attack&gt; 7K botnet, iptables is quite enough. <br><br>  DDoS as a natural disaster and avoid damage is impossible. <br>  Some customers, during the failure of your service, will go to competitors. <br>  You will have to incur some processing costs for programmers, administrators or the purchase of additional equipment. <br>  Your resource is actively promoted in PS (yandex, google) which means that the risk of incorrect indexation is critical and, as a result, the failure of positions in the issue. <br>  The main task is to minimize the damage from DDoS. <br><br>  In my case, the DDoS attack stopped the next day after the start of filtering.  The DoS customer was not willing to spend more money to increase the attack. <br><br>  In most cases, DDoS is a competitive online weapon.  Clients are almost instantly able to go to your competitors if your resource will malfunction. <br><br>  I believe that the fight against DDoS is not in the bots bath, but in creating conditions in which your total damage from an attack is comparable to the costs of its initiators.  The customer must spend, for example, 50 000 rubles.  in order to cause you damage in 50 000 rub., competitors are not economically profitable to organize such attacks. <br><br>  The method described in this article is not a panacea, it is only part of a set of measures to reflect DoS.  The development plan for a large service should take into account risks and suggest measures to reduce the negative effects of attacks. <br><br>  I hope my article will be useful to the community of developers and administrators of web applications. <br><br>  ___ <br>  * I removed a paragraph about 300Mbps from the text, because  He reasonably causes complaints. <br><br>  ‚ÄúOver 300 Mbit / s, we will‚Äú push ‚Äùto the limit ...‚Äù - true for HDD video / audio output, i.e.  "Heavy" files.  For HTML files this statement is unfair. <br><br>  Paragraph deleted text: <br>  ‚ÄúAccording to the results of the experiment, it is clear that the server is able to withstand an increase in attack of approximately 300 Mbit / s.  Over 300 Mbit / s, we will ‚Äúrest‚Äù in the limit of random read SAS disks.  So, we have a good margin of safety and a high probability of effectively repelling an attack while maintaining the availability of our web services to customers. ‚Äù </div><p>Source: <a href="https://habr.com/ru/post/84172/">https://habr.com/ru/post/84172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../84165/index.html">JVM from the inside - memory organization inside the Java process</a></li>
<li><a href="../84168/index.html">The old man ZEOS 386SL-25Mhz 4Mb. Outside and inside</a></li>
<li><a href="../84169/index.html">Web development for iPhone</a></li>
<li><a href="../84170/index.html">Spider-robot, which itself learns to walk</a></li>
<li><a href="../84171/index.html">Very useful in the household box: WD TV Live - HD media player</a></li>
<li><a href="../84175/index.html">Cheerful video game "Tanks Online"</a></li>
<li><a href="../84178/index.html">All with the Day of the Geek!</a></li>
<li><a href="../84179/index.html">Personality vector</a></li>
<li><a href="../84183/index.html">Demonstration of a virtual journey on Earth using Google Galaxy Liquid</a></li>
<li><a href="../84184/index.html">Iterator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>