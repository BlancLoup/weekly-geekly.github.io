<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Approaches to versioning database changes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much better disciplinary restrictions to remove instrumental expansion 
 The author of the article 
 Introduction 


 When developing an information s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Approaches to versioning database changes</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Much better disciplinary restrictions to remove instrumental expansion</em> <br>  The author of the article </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  When developing an information system, that is, a program aimed at storing, working with data, processing, analyzing and visualizing a database, one of the cornerstones is the task of developing a database.  When I first began to ask myself this question, it seemed that whatever I did, it would still be crooked. </p><br><p>  During 5 years of development of several corporate IS, I have set and tried to solve questions, how to make this or that aspect of database development convenient.  I was looking for tools to help do something with the database, methodology.  Surprisingly, there are few developments in this area.  And in each approach you can immediately see - this is impossible, it will be inconvenient here, there are too many disciplinary rules (see the epigraph) ... In this article I tried to collect those trips that I consider most effective, and one, in addition to the collected ones, will present the crown of my quest, which I consider the most "armor-piercing." </p><a name="habracut"></a><br><h2 id="evolyuciya-problemy">  Evolution of the problem </h2><br><p>  I will give an example of how a database development task can become a problem and evolve.  If the global formulation of the problem with all the features is interesting at once, you can skip this paragraph. </p><br><ol><li>  There is one instance of the DB, it is prod, and the users work on it, and the programmers watch and change the data and the circuit.  It seems comfortable, everything is very simple, nothing superfluous, Occam's razor and all that. </li><li>  Hmm, but programmers program right on the prod right away - and if they do something wrong?  Will they overwrite the data, or delete something important?  Yes, or simply load the server in search of the desired optimization.  Any solution to such an already existing situation will be bad for users.  No, it would be necessary to separate the database for dev development from prod.  The question arises - how to transfer changes from dev to prod? </li><li>  Hmm, how can we keep track of when and what has changed in the database?  We follow the application code, and the code of the stored procedures and everything else in the database?  Will we script some scripts with <em>alter</em> 's?  And how to <em>create create</em> ?  After all, he is repeatedly non-rolling, unlike <em>alter</em> 'a. </li><li>  Hmm, all the programmers are on the same dev-server, it‚Äôs a test for users.  That is, testing users may stumble upon what the programmer has not yet completed, which should not be visible to the user.  Or just broken.  It would be necessary to separate the dev with test. <br>  (in fact, many IP can not pay much attention to this problem) </li><li>  But the same situation with programmers - if two programmers change the database, then there may be some artifacts.  One changes something, and the application to this is not yet ready - and for all the project does not start.  It would be necessary for each programmer on the DB.  So that each has its own sandbox.  And when the database is very large? </li><li>  Oops, how do you transfer all changes to prod now?  If you use the comparison schemes, then the database of one programmer will overwrite the changes of another programmer.  And how to transfer changes from one programmer to another instance?  Transfer backup from prod to each programmer?  And then change it as a roll on this backup?  No, nonsense, somehow here some scripts should play a role. </li><li>  Wait, what about the data that should be the same for all instances (directories and persistent directories)?  Will they be transferred with backups?  Or still script <em>insert</em> 's or <em>merge</em> ' s and version scripts?  And how to run them - always all at once, or is it only those that have changed?  And how to regulate the order? </li><li>  And it seems that it happens that there are such data and procedures that should be different in different instances!  Settings, replication, communication with other services.  With <em>sharding</em> .  How to deal with them?  Transfer of backup and subsequent change script, its for each instance?  This is possible, but not all differences can be done - for example, <em>memory optimized tables</em> cannot be converted to regular tables, not counting the fact that it can be impossible to raise backup with them when the test server or programmer instance does not have enough memory . <br>  By the way, I ran into this when I needed to make <em>memory optimized tables</em> for 20 GB, and even when the prod had a whole system of synchronization with another system, which should not be on other instances. </li><li>  Mmm, and how to make it so that you can easily raise a whole new DB instance at once?  What if all the settings of both the database and SQL Server are scripted and versioned? <br>  This is convenient when each programmer has his own SQL Server, and not when the server is one with a bunch of databases.  Or sharding.  Or a new test loop for a new big business feature. </li></ol><br><p>  Some of the points of this evolution may seem redundant and generally inventing problems for yourself, but when solved with a convenient tool, database development will become almost as simple and painless as the development of ordinary application code. </p><br><p>  Having collected in one heap all possible problems associated with the development of the database, which I saw when developing information systems, I came to a global formulation of the problem statement in my vision. </p><br><h2 id="polnaya-universalnaya-postanovka-zadachi">  Full universal formulation of the problem </h2><br><p>  <strong>Tasks and problems that may arise during the development of the database:</strong> </p><br><ol><li>  Must be versioned: <br>  <strong>A.</strong> DB schema.  That is, you need to be able to save the history of database schema changes in any form. <br>  <em>This is the most basic goal</em> , on which all other possibilities are hung.  Versioning the database schema is the cornerstone of database development.  There may be two ways.  You can save the flow of changes in all database objects with one global stream, and you can somehow version each specific object.  I think (see p6) that the second way is in the end much more practical. <br>  <strong>B.</strong> Some data: dynamic references, persistent references (persistent, static). <br>  <em>The goal is important</em> if the application code depends on this data (then they will be persistent).  That is, if a table corresponds to one enum in the code.  Or, otherwise, the <em>goal is secondary, but very useful for controlling the</em> addition / change of static and not-so data, as well as for automating the deployment of database changes and release of different contours (P2) - if there are more than one. <br>  <strong>C.</strong> Data conversion scripts (migration scripts).  They can be associated with either a change in the database schema or a business task.  For such changes, order is important, and sometimes repeated execution is required. <br>  Not all IP such scripts will exist.  But, <em>if they exist, this goal is required</em> . <br>  <strong>D.</strong> DB Settings. <br>  Examples of important database settings that should be versioned - if the <em>service broker</em> should be enabled (it is required for <em>sql dependency</em> ), <em>change tracking</em> (it can be used for more complex caches), the <em>read_committed_snapshot</em> option should be the required <em>user</em> database for the application, setting up error alerts , setting support for <em>memory optimized tables</em> .  The advantage of saving and versioning database settings is that you can easily make a new database that works completely the same as the main one.  And that in a convenient form, you can conduct a <em>code review</em> , coordinate changes.  And also just to have a story - what, when and by whom it was made. <br>  <strong>E.</strong> Some other objects of SQL Server are jobes, some server settings, alerts, logins, linked servers (for integration with other systems). <br>  This may be necessary when the test circuits must completely repeat the prod, along with the processing in the jobs.  That seems like a completely normal situation. <br>  In addition, if all the settings, Jobs, etc. are scripted, then you can easily pick up a new contour.  I launched one script - and the entire new SQL environment is fully working. </li><li>  Many contours are needed: one prod (or maybe not one! - for example, when sharding, or when the product is boxed and each client has its own database), many test ones are not just two test contours (prod-test, dev-test) , but also along the contour for each programmer, or along the contour for a large feature. <br>  <strong>A. The</strong> support of many contours means that it must be possible to change one contour into any other contour, without spoiling it and not wiping out the changes that it already may also have. <br>  That is, if each programmer has his own sandbox database, changes to one programmer need to be transferred not only to prod, but to all other instances.  Even if there another programmer did something, too. <br>  <strong>B.</strong> It happens that the circuit may differ slightly in different circuits - for example, additional objects (views, storages) are needed in the test environment, and maybe vice versa, a piece of database, integration with another system, etc. should be excluded from some test circuit.  Also in the case when there is <em>memory optimized tables</em> in one instance, and in the other they do not fit in memory and these tables should be normal. <br>  <strong>C.</strong> In different circuits, the versioned data may be different - for example, application launch settings, access to other systems.  Also test data for test contours. <br>  You can draw an analogy with the case when different programmers, or on different publish-host applications must have different <strong>app.config</strong> files - which is achieved using the Visual Studio <em>app config transformation</em> feature.  Similarly, something in the database may differ in different instances. <br>  <strong>D.</strong> Same for database and server settings.  For example, on prod / prod-test, all jobs are needed, and on local databases, programmers do not have everything.  Support for <em>memory optimized tables</em> - on prod'e needed, but on other circuits may not be. <br>  <strong>E</strong> When restoring a backup from a prod to another instance, you need to be able to bring the restored database into compliance with the desired path. <br>  Sometimes this may not be possible (again, if there are <em>memory optimized tables</em> ), but if it is possible, then this is a very handy feature when you need to transfer all the data from one DB Instance to another, which is most easily done by transferring backup. </li><li> Tasks related to the database version: <br>  <strong>A.</strong> When a programmer makes changes to the database, not all of which need to be in the prod, you need to leave unnecessary ones - if the programmer made them for his test purposes - and transfer them to the prod (and other instances) only necessary. <br>  It‚Äôs convenient for a programmer to leave everything he wants in his sandbox, although transferring to other instances is exactly what is needed.  That is, if he has made for himself some kind of convenient and necessary view only for him, a procedure, or even a table - this should not fall on prod. <br>  This clause is almost equivalent to 2bc, but here it means that there may be database objects that can be not versioned, but simply manually created in your sandbox. <br>  <strong>B.</strong> Nakat to some specific version of the database (larger than the current on the selected contour). <br>  This is necessary if the development of the database is separate from the development of the application.  If the database changes go along with the application change, then there should be no different future versions of the database.  That is, there should be an ‚Äúnot ready / spoils / not supported by the application approach ‚Äî don't commit, at least to the common repository branch‚Äù.  And if there are changes in the database, they should be backward compatible.  For example, deleting / renaming a column should be accompanied by a corresponding change in the application, and adding should not be necessary.  In article 3 ( <a href="https://habrahabr.ru/post/312970/">Evolutionary database design</a> ), the author calls such changes <em>destructive</em> - I agree with this term. <br>  <strong>C.</strong> <del>  Rollback to the old version </del>  , by analogy with a simple <em>git checkout</em> with the usual programming of the application - is impossible in general.  Because, in the presence of data in the tables, it is impossible to convert them to the old (that is, arbitrary) scheme. </li><li>  Sometimes it can be useful to create a clean database with this schema and given reference books (or without reference books) - for tests, for example. <br>  <strong>A.</strong> When testing automation ( <em>continuous integration</em> ), you can create a fresh, clean database for running tests, or with filling with random data (I don‚Äôt know free tools for this, <a href="http://www.red-gate.com/products/sql-development/sql-data-generator/">redgate</a> , <a href="https://www.devart.com/dbforge/sql/data-generator/">devart</a> have paid <a href="https://www.devart.com/dbforge/sql/data-generator/">tools</a> ) or a subset of working data ( <a href="http://jailer.sourceforge.net/exporting-data.htm">Jailer</a> can help with this). <br>  In practice, real benefit from this can be extracted only if this process is simple and quick as a click of a finger - otherwise no one will do it.  After all, you can use the usual test database. </li><li>  If some change has already been done, in the normal mode, provide for it not to be rolled again, or make the changes idempotent. <br>  In practice, the rule ‚Äúmake all changes idempotent‚Äù is too disciplinary.  Much better disciplinary restrictions to remove instrumental expansion. </li><li><p>  For each database object you need to be able to see the history of its changes. <br>  <strong>A.</strong> For control, you need to be able to see what changes will be rolled up in specific SQL scripts (‚Äúcumulative scripts‚Äù). <br>  <strong>B.</strong> <em>Code review is</em> highly desirable.  Moreover, an explicit <em>alter</em> statement is preferable to comparing <em>create table</em> statements (on the basis of which diff is made and subsequently rolled), since it is better to control actions from the database, rather than the declaration.  And for procedures and similar objects, you must be able to see the diff of the body. </p><br></li><li>  Used tools need licenses.  With the <em>shared db</em> approach (which can provoke problems and conflicts of changes - see p2), one is enough (when only one specially selected person rolls back changes), and at the approach, when each programmer has his own database, each programmer is licensed. </li></ol><br><p>  In my practice, I was guided by the following points: </p><br><ul><li>  1 and 2 - from cover to cover; </li><li>  3a; </li><li>  3b did not use it, because always in my projects the databases with the application were a complete one system and were fully developed together; </li><li>  4 - I tried to use it, but the tests as a whole did not take root very well because they require an additional resource, well, or paradigm rearrangements for TDD; </li><li>  5 - required; </li><li>  6 - important, although quite rare; </li><li>  licenses were not required because the tool for the chosen approach is free. </li></ul><br><p>  So I consider all items as mandatory except 3b and 4. </p><br><h2 id="podhody">  Approaches </h2><br><p>  I came to the conclusion that it is advisable to highlight the approaches: </p><br><ol><li>  Comparison of target database and source database. </li><li>  Comparing the scripted schema (and data) with the target database. </li><li>  Based on sequential (incremental) manual SQL scripts. </li><li>  Based on manual independent SQL scripts whose structure repeats the DB schema. </li></ol><br><p>  In this list, approaches are sorted by increase in utility. </p><br><h3 id="pohozhie-stati">  Similar articles </h3><br><ol><li>  <a href="https://habrahabr.ru/post/121265/">https://habrahabr.ru/post/121265/</a> - briefly describes approaches 2, 3. There is also an approach with a sequence of idempotent changes, but I throw it away because of the too high complexity of supporting the idempotentness of scripts when there are many of them.  Apart from the fact that it is easy to run 1000 scripts, even if they do not change anything as a result, it also takes time (and the size of the run-up log file).  There should be an approach ‚Äúif the change is already rolled, do not repeat its roll‚Äù (p5). </li><li>  <a href="https://habrahabr.ru/post/258005/">https://habrahabr.ru/post/258005/</a> - a combination of approaches 3 and 1 - based on redgate SQL Source Control and redgate SQL Compare.  (The article describes poorly the work with the database, basically it is about the love for Atlassian) - as I understood, at first, when committing, they roll scripts onto DB QA, then by comparing the scheme it is transferred to prod. </li><li>  <a href="https://habrahabr.ru/post/312970/">https://habrahabr.ru/post/312970/</a> is a good long article, the approach is very similar to the previous article.  CI is used to make changes to the QA database on every commit, and an artifact-accumulative script of database changes is rolled out to roll onto the prod.  The meaning of this artifact is not very clear if the scripts themselves are in a commit.  The quintessence in the <a href="">picture</a> . </li></ol><br><p>  In general, I would be extremely wary of the idea of ‚Äã‚Äãautomating scripts over commit ‚Äî sometimes it happens that commits are made unprepared or incomplete.  The disciplinary rule ‚Äúcommit only ready code to the master‚Äù in practice works very poorly.  It is better to avoid it by improving the tools - for this there is a class of <em>continuous integration</em> tools (for example, <a href="https://www.jetbrains.com/teamcity/whatsnew/">TeamCity</a> from <a href="https://www.jetbrains.com/">JetBrains</a> or absolutely free <a href="https://jenkins.io/">Jenkins</a> ).  I am for the roll-out of scripts on the database to occur exclusively consciously by a human programmer, and only at the right moments in time - which should not be associated with the commit. </p><br><h2 id="1-sravnenie-shem-celevoy-bd-i-bd-istochnika">  1 Comparison of target database and source database </h2><br><h3 id="instrument">  Tool </h3><br><p>  <a href="http://www.red-gate.com/products/sql-development/sql-compare/">Redgate SQL Compare</a> .  There is also <a href="http://compalex.net/">http://compalex.net/</a> , but it only works with php.  There are other tools for comparing database schemas. </p><br><h3 id="metodologiya">  Methodology </h3><br><p>  In addition to the prod database, it is the target database, the dev database is being made, it is the source database. </p><br><p>  Changes are made in the source database in some way.  Moreover, this source database is not test in the conventional sense, because you cannot do anything with it - it is understood that all changes (at least, changes to the database schema) must be transferred to the target database.  Further, these changes can be scripted, but these scripts are not used in any way afterwards, because if you use them and roll them in any way, then the whole point of the approach disappears, comparing the schemes becomes meaningless.  These scripts can only play the role of a change history.  But which may be different from reality, because you can change something visually in Management Studio (or another GUI for the database) and forget to script it.  Or scripted wrong.  Then, at the moment of deployment to the target database, a diff script is created (with the help of the tool) that rolls in, bringing the target database to a state of equal circuit with the source. </p><br><h3 id="plyusy">  pros </h3><br><ul><li>  For those who are afraid to write sql.  Changes in the source database can be made by visual means (on the other hand, I do not consider this a good practice). </li><li>  Scripts need to be written only for data conversion (again, I believe that scripts for the programmer should be the starting point, and you should not leave them). </li></ul><br><h3 id="minusy">  Minuses </h3><br><ul><li>  Everything that is connected with several circuits (n2) is impossible. <br>  If I make changes on my selected test sandbox database, I have to transfer these changes to the source database for the prod.  If you do this in the same way, then it gives a hole - transferring those random or personal changes that I made to my database (I can do everything in my sandbox, everything, everything, everything, right?).  After all, only the necessary changes are scripted, but all are transferred.  In addition, I will jam the changes that another programmer suffers. </li><li>  If there are at least some differences in the second circuit, you need to make another source database for it.  That is, if there are any settings or data different from the prod in the test loop, then either a second source database is needed for it, or in some other way to solve this problem. </li><li>  Lack of control over change transfer scripts - the scripts generated by the tool will be rolled.  Sometimes it can be bad, you need to take into account the specifics.  For example, some changes require the re-creation of a table.  What you need to do or very carefully, or do not do (if the table is often used, very large). <br>  If we take this diff script, look at it and edit it, then again the whole point of comparing the schemes disappears - you can write the scripts right away. </li><li>  The scripted history of object changes may differ from the real one.  Because the tool compares exactly the scheme of the bases, and not the scripts - you can (by chance, of course) change something and not add it to the scripts.  Or add to the scripts is not entirely correct. </li><li>  Anyway, additional efforts and tools are needed to support: <br>  - migration scripts (data conversion), <br>  - versioning of reference books and persistent data. </li><li>  The tool does not override the database settings and SQL Server settings. </li><li>  If someone else rolls something on the source database, it will drag too when deployed. </li><li>  The target database is dependent on another database in the sense that prod must be bundled with its source. </li><li>  There are no free tools, but redgate SQL Compare is expensive.  And you need a license for the tool on all hosts that will be migrated to any target database. </li></ul><br><h3 id="podhod-ne-reshaet-zadachi">  <strong>The approach does not solve the problem</strong> </h3><br><ul><li>  1b - it is implied that for this purpose it is necessary to use SQL Data Compare;  1c;  1d;  1e. </li><li>  For 2 - additional and very significant efforts.  It‚Äôs easier to drop several contours than to support them. </li><li>  3a - the tool overrides the schema changes of either all objects or selected ones.  That is, when deploying, you need to view a list of all objects and uncheck unnecessary ones.  In principle, this solves the problem, but ... Nobody will do that.  Again, the rule is ‚Äúmuch better disciplinary restrictions to remove instrumental expansion‚Äù.  Something is missing .gitignore file type. </li><li>  6 - additional efforts are needed, the history of changes may differ from the real one. </li></ul><br><h2 id="2-cravnenie-zaskriptovannoy-shemy-i-dannyh-s-celevoy-bd">  2 Comparison of the scripted schema (and data) with the target database </h2><br><h3 id="instrument-1">  Tool </h3><br><p>  I do not know which tool could compare two DB schemas not by the bases themselves, but by the scripts.  Therefore, this approach is theoretical.  But, if you find or make such a tool, it seems that the approach would be quite good.  Especially if this tool could compare data. </p><br><h3 id="metodologiya-1">  Methodology </h3><br><p>  The role of the source database here would play a directory with scripts that completely create the database ‚Äî both the schema and the versioned data (directories, persistent directories).  That is, the programmer makes changes to these scripts, runs a tool that compares the entire directory with the target database and creates a diff script, which is either saved for <em>code review</em> , or rolled up immediately. <br>  Since there is no tool, one can only fantasize about how this tool could compare data and settings of the database and SQL Server. </p><br><h3 id="plyusy-1">  pros </h3><br><ul><li>  The task of the history of changes in each object of the database (p6) is perfectly solved. </li><li>  The sandbox task (p3a) was solved perfectly, as well as in the remaining approaches based on scripts.  No changes needed - do not make scripts. </li></ul><br><h3 id="minusy-1">  Minuses </h3><br><ul><li>  Similar to approach 1, everything that is connected with several contours (n2) is impossible. </li><li>  Similar to approach 1, there is no control over the rolling scripts. </li><li>  The same problem with migration scripts. </li></ul><br><h3 id="podhod-ne-reshaet-zadachi-1">  <strong>The approach does not solve the problem</strong> </h3><br><ul><li>  1c. </li><li>  1d, 1e - it is unknown which tool. </li><li>  For 2 - additional and very significant efforts.  It‚Äôs easier to drop several contours than to support them. </li></ul><br><h2 id="3-na-osnove-posledovatelnyh-inkrementalnyh-ruchnyh-sql-skriptov">  3 Based on sequential (incremental) manual SQL scripts </h2><br><h3 id="instrument-2">  Tool </h3><br><p>  <a href="https://flywaydb.org/">flyway db</a> .  Perhaps there are alternatives ( <a href="https://github.com/lecaillon/Evolve">https://github.com/lecaillon/Evolve</a> - I'm not ready to talk about this tool, but it seems to be doing something similar). </p><br><h3 id="metodologiya-2">  Methodology </h3><br><p>  The approach methodology is the simplest.  Enchantingly simple.  As required, sql-scripts of changes are written - arbitrary, both for changing the schema and for changing the data.  It does not matter which scripts.  Files are numbered, folded into a daddy.  At the right time, the tool is launched, which in the order of numbering rolls in new, that is, not yet executed script files on the selected database.  Rolled remembers in a special plate, that is, the script will not be re-executed. </p><br><p>  This is how Qiwi works.  Or I worked when I participated in the development of the payment system.  But there without tools, tools are replaced by disciplinary rules.  There are several QA-employees who monitor the special git repository and roll in new scripts, first on the test database - see if anything has broken, then, if everything is fine, on prod. </p><br><h3 id="plyusy-2">  pros </h3><br><ul><li>  Extremely, extremely simple.  You write a script, you put it in a daddy, and that's it.  I think thanks to this, this approach is the most common. </li><li>  Full (absolutely full) control on the rolled changes.  No script generation. </li><li>  Including it is possible to store both data (p1b), migration scripts (p1c), and settings for both the database and SQL Server (p1de) in scripts. </li><li>  You can roll up to a specific version (p3b). </li><li>  The problem of many contours has been solved, but without differences in them (n2a). </li></ul><br><h3 id="minusy-2">  Minuses </h3><br><ul><li>  It is impossible to single out a history of changing a single object, <em>alter</em> 's for one object are scattered across many scripts, many files. </li><li>  With the parallel work of two programmers, they can create scripts with the same numbers. </li><li>  Since the approach is scripted, there are not enough features: <br>  - Some scripts would like to roll when they change.  That is, he added a line to the script of the versioned reference book, and it turned out, and the line appeared in the table.  In this form, you can store a history of data changes (see approach 4). <br>  - Some scripts would like to roll in with each deploy'e - this is, for example, some sort of cleaning, entering of persistent directories that must be versioned (therefore, they cannot be entered manually into the database). </li><li>  The sequence of arbitrary scripts is extremely difficult to understand.  Creating tables, their <em>alter</em> 's, adding lines to directories, migrations are scattered almost randomly in one sequence.  I would like to have an alphabetical sorting of files, various daddies.  In a word, I want to see the database structure in the scripts.  You can, of course, come up with something - make a bunch of daddies, make a huge bat, launch the tool on these daddies in the right order ... Yes, this is the beginning of the next approach, the 4th. </li></ul><br><h3 id="podhod-ne-reshaet-zadachi-2">  <strong>The approach does not solve the problem</strong> </h3><br><ul><li>  2bcde, </li><li>  6b. </li></ul><br><h2 id="4-na-osnove-ruchnyh-nezavisimyh-sql-skriptov-struktura-kotoryh-povtoryaet-shemu-bd">  4 Based on manual independent SQL scripts whose structure repeats the database schema. </h2><br><h3 id="instrument-3">  Tool </h3><br><p>  <a href="http://www.liquibase.org/">liquibase</a> .  Perhaps there are alternatives ( <a href="http://www.red-gate.com/products/sql-development/sql-source-control/">redgate SQL Source Control</a> , <a href="https://www.quora.com/What-are-the-alternatives-to-LiquiBase">https://www.quora.com/What-are-the-alternatives-to-LiquiBase</a> - but I don‚Äôt quite know how they work). </p><br><h3 id="metodologiya-3">  Methodology </h3><br><h4 id="ideya">  Idea </h4><br><p>  To create and modify the schema for each database object, create a file in which there will be a script responsible for this object - so when versioning files, we get the change history for each object.  We put these files in daddies, repeating the structure of the database.  Since the sequence of execution of scripts is important, we enter control files containing a sequence of roll up scripts, and the tool makes writing these control files simple enough and decides what change to roll and what doesn‚Äôt, if it was already rolled up or filtered.  In addition, if you need a difference in something in different DB instances, enter the values ‚Äã‚Äãof the variables that the tool uses, modifying the scripts for each instance as necessary.  In addition, you can enter filters on scripts, and, depending on the context (‚Äúonly schema change‚Äù, ‚Äúonly directories import‚Äù, ‚Äúcreate / update only such a piece of scheme‚Äù) filter scripts. </p><br><p>  To change a table, you need to add a script (changeset) with the <em>alter</em> or <em>create index</em> operator or some other file to its <em>create</em> file.  Or, you can modify the existing corresponding changeset, if it is possible to make it re-rolling. </p><br><p>  To change the procedure / function / trigger / view you need to change the code in the file corresponding to this object.  In order for this script to be re-rolling, you need to create this object with an empty body in the first changeset, and the <em>alter</em> operator with the desired body in the second (sorry, SQL Server has no <em>create or alter</em> operator).  Then the first changeset will be executed only once, and the second - when changed. </p><br><p>  Well, for the deploy directly, we do the bat-file (s) that launch the tool with the necessary context and settings.  Thus, the required deploy will be launched by running the appropriate bat'nik. </p><br><p>  You can configure the launch logs (which changesets to execute and how long) are saved.  Adding them to .gitignore. </p><br><h4 id="fayly">  Files </h4><br><p>  Make the following folder structure: </p><br><p>  - <strong>&lt;DB name&gt;</strong> </p><br><ul><li>  <strong>CLR_Objects</strong> <br>  There will be 1 sql-file for each CLR assembly.  In this file, first <em>drop function</em> , then <em>drop assembly</em> , then <em>create assembly</em> , then <em>create function</em> .  The assemblies themselves will have to be stored in the script as <em>base64</em> , but you can make a simple tool that automates this conversion: <br><pre><code class="cs hljs">Clipboard.SetText(<span class="hljs-string"><span class="hljs-string">"0x"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(‚Äú‚Äù, File.ReadAllBytes(path).Select(b =&gt; b.ToString(<span class="hljs-string"><span class="hljs-string">"x2"</span></span>))) )</code> </pre> </li><li>  <strong>Tables</strong> <br>  There will be a table for each table in the directory in which the table and script creation files for the versioned directory are separate. <br>  - &lt;table name1&gt; <br>  - &lt;table name2&gt; <br>  - ... </li><li>  <strong>Types</strong> <br>  There will be 1 sql-file for each type. </li><li>  Functions <br>  There will be 1 sql-file for each function. </li><li>  <strong>Views</strong> <br>  There will be 1 sql file for each view. </li><li>  <strong>Stored_procedures</strong> <br>  There will be 1 sql-file for each stored procedure. </li><li>  <strong>Triggers</strong> <br>  There will be 1 sql-file for each trigger. </li><li>  <strong>Migration_Scripts</strong> <br>  There will be a sequence of data change scripts. </li></ul><br><p>  - <strong>core</strong> <br>  There will be the tool itself and its configuration files. </p><br><p>  As you can see, the idea of ‚Äã‚Äãthese folders is to repeat the database schema and match each object to its one file. </p><br><p>  In the head folder <strong>&lt;DB name&gt; there</strong> will be files: </p><br><ol><li>  Database creation script ( <em>create database</em> , <em>alter database</em> - settings, users, roles) <br>  <strong>create_db.sql</strong> </li><li>  File (s) with scripts that change SQL Server settings and the database itself ( <em>sp_configure</em> , <em>sp_add_job</em> and its brethren, <em>sysmail_add_account_sp</em> and its brethren, <em>alter database</em> etc).  Although scripts Jobs can be stored for convenience in various files. <br>  <strong>config_db.sql</strong> </li><li>  File with a sequence of roll up tables.  The <em>includeAll</em> tool <em>command</em> executes scripts in alphabetical order, which incorrectly creates tables due to the presence of links in them, so you need a file that governs the sequence of rolling tables. <br>  <strong>tables.xml</strong> </li><li>  File with a sequence of roll up view.  Views can depend on each other, so their roll order is important. <br>  <strong>views.xml</strong> </li><li>  A file with a sequence of data change scripts.  Ordering is also important for data migrations. <br>  <strong>migrations.xml</strong> </li><li>  File with commands tool how to create a database schema.  It will contain links to files 1 and 2 with the creation and configuration of the database and server, and then to the folders <strong>CLR_Objects</strong> , <strong>Tables</strong> (more precisely, the file <strong>tables.xml</strong> ), <strong>Types</strong> , <strong>Functions</strong> , <strong>Views</strong> (more precisely, the file <strong>views.xml</strong> ), <strong>Stored_Procedures</strong> , <strong>Triggers</strong> - precisely in this sequence.  Also in this file, you can set values ‚Äã‚Äãfor variables that scripts will depend on - if there are differences in different instances of the database. <br>  <strong>master_Scheme.xml</strong> </li><li>  File with all commands tool.  It first contains a link to the previous schema creation file, then additional actions - data conversion / migration / data cleaning (link to the <strong>Migration_Scripts</strong> folder, or rather, the file <strong>migrations.xml</strong> ) <br>  <strong>master.xml</strong> </li></ol><br><p>  Note that the sequence is not important for creating / modifying stored procedures, triggers, functions, and types.  Therefore, it is enough to <em>includeAll command of the</em> tool that rolls them in alphabetical order. </p><br><h4 id="kak-ispolzovat">  How to use </h4><br><p>  For each use case, you need to create a bat file that runs the tool with the appropriate context ‚Äî for example, <strong>deploy_local_scheme.bat</strong> , <strong>deploy_local_full.bat</strong> , <strong>deploy_prod_scheme.bat</strong> , <strong>deploy_prod_full.bat</strong> , <strong>deploy_ &lt;programmer&gt; .bat</strong> etc.  In one project, I had as many as 18 such files - there was a whole system of data migration, and it was necessary to regulate when to perform which migration. </p><br><p>  In addition to the context, the bat file itself must contain the <em>connection string</em> and the name of the tool command. <br>  Possible commands: </p><br><ul><li>  <em>update</em> .  The main command to execute all the necessary changesets. </li><li>  <em>status</em> .  Shows what changesets will be rolled up. </li><li>  <em>udpateSQL</em> .  Shows a full sql script that collects all the rollout changesets. </li><li>  <em>changelogSync</em> .  Pushes new changesets as executed without rolling them.  It should be used when the change is rolled by hand.  Should be used as seldom as possible. </li></ul><br><p>  For the convenience of viewing the execution logs, I also output them to a text file: <br> <code>&gt; %outputfilename% 2&gt;&amp;1</code> </p> <br><p>  Changesets can be tagged with attributes: </p><br><ul><li>  <em>runOnChange</em> - if <code>=true</code> instructs the tool to roll a changeset when it changes (if you write <code>=false</code> , then after changing the changeset there will be an error like "a rolled changeset has been changed"); </li><li>  <em>runAlways</em> - indicates to roll a changeset on every deploy. </li></ul><br><p>  If you need to change the schema so that some data modification scripts break down, that is, migration scripts (for example, if you need to change the table name, columns, delete something), then you need to write the corresponding <em>alter</em> or <em>sp_rename</em> in the file corresponding to this table, and change the necessary scripts accordingly.  Further, for one-time scripts, you need to make them so that the tool does not give an error that the thumbnail changeset has changed.  This is achieved in two ways - either the <em>changelogSync</em> command, or manually change the corresponding row in the tool table by updating the md5-sum there ‚Äî the tool's value will prompt it. </p><br><h3 id="plyusy-3">  pros </h3><br><ul><li>  Full (absolutely full) control on the rolled changes.  Just as in approach 3. </li><li>  Similar to approach 2, it is very convenient to carry out <em>code review</em> , look at the change history of all objects. </li><li>  Differences in contours (n2bcde) are supported by variables.  That is, you can make a bat-file on the contour, in which the values ‚Äã‚Äãof variables will be specified, and this value can be used in the script, or changese can be labeled with <em>labels</em> that can be filtered or not depending on the contour. </li><li>  Even a clean database can be created (p4). </li></ul><br><h3 id="minusy-3">  Minuses </h3><br><ul><li>  Difficult in the initial setup.  But this is only the difficulty of entry.  When using such complexity there is no need - just add the changeset script to the desired file, and that's it. </li><li>  In a long-term development, when one table needs to be changed many times over time, in some cases changesets with the <em>alter table</em> operator will multiply.  But in most cases this will not happen - if you always write reusable changesets.  This is a minus with respect to approach 2 (in which you can edit the <em>create</em> statements), but for approach 3, this is an improvement ‚Äî in general, all changes will be added linearly one after another. </li><li>  The tool is very poorly maintained and developed.  It is written by one person as a hobby.  But today's functionality is enough.  In addition, the tool is simple, you can do it yourself in a month. </li></ul><br><h3 id="podhod-ne-reshaet-zadachi-3">  <strong>The approach does not solve the problem</strong> </h3><br><p>  Only optional in my vision p3b.  Victory. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330662/">https://habr.com/ru/post/330662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330650/index.html">Ruby on Rails agreement. Part 4</a></li>
<li><a href="../330654/index.html">Dialectics of Neural Machine Translation</a></li>
<li><a href="../330656/index.html">Integration React and DataTables - not as hard as advertised</a></li>
<li><a href="../330658/index.html">How to make a beautiful avatar? New social media marketing</a></li>
<li><a href="../330660/index.html">Attention! Hackers have begun to use the SambaCry vulnerability to crack Linux systems</a></li>
<li><a href="../330664/index.html">It was in the evening. An autoscale load-balanced web service using the example of Bitrix in the Google Cloud Platform</a></li>
<li><a href="../330666/index.html">Internet Magnets 5 - Lighthouses and Messages (Personal, Public, and Updates)</a></li>
<li><a href="../330668/index.html">Self-made drive emulator for Amiga</a></li>
<li><a href="../330670/index.html">Configuring Reverse Proxy Apache (Debian 8) with automatic issue of Let's Encrypt</a></li>
<li><a href="../330672/index.html">Making a dragon bot in Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>