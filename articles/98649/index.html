<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparative testing of software RAID performance. Linux vs FreeBSD (mdadm vs gmirror)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Opinion with regards to various VS I have long been formed - it all depends on the tasks. But no, no, yes, there is a desire to dig dee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparative testing of software RAID performance. Linux vs FreeBSD (mdadm vs gmirror)</h1><div class="post__text post__text-html js-mediator-article"> <b>Introduction</b> <br>  Opinion with regards to various <b>VS</b> I have long been formed - it all depends on the tasks.  But no, no, yes, there is a desire to dig deeper, to find out who is still stronger - Bruce Lee or Jackie Chan, Stallone or Schwarzenegger, mdadm or gmirror. <br>  The test does not claim absolute objectivity; rather, it is even subjective in terms of the hardware used.  But anyway, numbers are numbers. <br>  Who are interested, please come under cat. <br><a name="habracut"></a><br><br>  <b>Test stand</b> <br>  Motherboard: ECS 865GV-M <br>  Processor: Intel¬Æ Celeron¬Æ CPU 2.00GHz <br>  HDD 1 (system): SATA-II 160Gb Western Digital WD1600AAJS (connected to mother) <br>  HDD 2.3 (RAID): SATA-II 1.5Tb Western Digital [WD15EARS] (connected to the Promise) <br>  SATA controller: Promise SATA300 TX4 PCI, 4-port SATA300 <br>  RAM: 1280Mb <br>  * God knows what configuration, but, as they say, the rich, and so happy. <br><br>  <b>Start</b> <br>  Information about the utilities used in the test: <br>  <i>Bonnie ++</i> <br>  As the name implies, <i>Bonnie ++ is</i> based on the Bonnie benchmark.  There are many different types of file operations and different programs use them in different ways.  Bonnie ++ tests some of them and displays the result for each of the tests.  Distributed under the GPL2 license. <br>  There are two sections of operations in tests.  The first is the IO test, which simulates the behavior of some database applications.  The second is a test for creating, reading and deleting a large number of small files. <br>  Website: <a href="http://www.coker.com.au/bonnie%2B%2B/">www.coker.com.au/bonnie++</a> <br>  <i>Iozone</i> <br>  <i>IOzone</i> is a console utility for measuring file system speed.  The speed of such operations as read, write, re-read, re-write, read backwards, read strided, fread, fwrite, random read, pread, mmap, aio_read, aio_write is tested.  The results are output to a file, the data from which can be used to plot graphs in Excel. <br>  Website: <a href="http://www.iozone.org/">www.iozone.org</a> <br>  <i>DD</i> <br>  I think that the reader is familiar with this wonderful tool, so I will limit myself to quoting the wiki. <br>  "Dd (English dataset definition - the definition of a set of data) - a Unix program designed to both copy and convert files" 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Test OS:</b> <br>  1.FreeBSD 8.0 RELEASE i386 <br>  2.Debian Lenny 5.0.5 i386 <br><br>  <b>Training</b> <br>  FreeBSD: <br> <code>   <br> #gmirror load <br>      <br> #gmirror label -v gm0 /dev/ad6 /dev/ad10 <br>    UFS + Soft Updates <br> #newfs -U /dev/mirror/gm0 <br>   <br> #mkdir /raid <br>  <br> #mount /dev/mirror/gm0 /raid</code> <br>  Linux: <br> <code>  <br> debian:/home/iam# mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/sd[bc]1 <br>    mdadm.conf <br> debian:/home/iam# mdadm --detail --scan &gt;&gt; /etc/mdadm/mdadm.conf <br>   EXT3 <br> debian:/home/iam#mkfs.ext3 /dev/md0 <br>    <br> debian:/home/iam#mkdir /raid <br>  <br> debian:/home/iam#mount /dev/md0 /raid</code> <br> <br>  <b>Let's go (with)</b> <br>  The first to go into battle is bonnie ++, we start with the default settings. <br> <code># bonnie++ -d /raid/ -m 'FREEBSD_gmirror' -u root &gt; out.csv &amp;&amp; cat out.csv | bon_csv2html &gt; gmirror.html</code> <br>  About keys: <br>  -d: set the program in which directory to create temporary files <br>  -m: report header <br>  -u: from whom to run <br>  Then I redirected the output of the program to the file&gt; out.csv, then with the help of bon_csv2html translated into readable html. <br>  <b>Results:</b> <br>  <b>freebsd</b> <br><img src="http://s003.radikal.ru/i202/1007/9f/0ddc1a1ff0c0.png" alt="image"><br>  <b>linux</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/db5/628/f12/db5628f1264634e007d3190dee06d642.png" alt="image"><br>  <b>freebsd</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/134/28b/ec9/13428bec9a42f079334caa26337a121c.png" alt="image"><br>  <b>linux</b> <br><img src="http://s47.radikal.ru/i115/1007/de/a5ed97d04b11.png" alt="image"><br><br>  * I confess, in Linux I didn‚Äôt get readable html, so I fixed the result of html from FreeBSD <br>  In the screenshots, we see the result of the team, let's go in order. <br>  <b>Size 2512M</b> - RAM * 2 <br>  Sequential Output (Sequential Output) Sequential Input (Last Input) <br>  <b>Per char</b> <br>  These are the read results for a single byte.  Demonstrate the ability of the OS to buffer such operations. <br>  <b>Block</b> <br>  read-write blocks of size 8192 bytes. <br>  <b>Rerite</b> <br>  I think does not need an explanation <br>  <b>Random Seeks</b> (random reads) <br>  Seeks - the number of random read operations <br>  <b>Sequential Create</b> (sequential file creation) <br>  <b>Random Create</b> (random / random file creation) <br>  I think that now the reader does not understand only the lines filled with +++ characters - the test was completed so quickly that the program cannot display the result. <br><br>  Now add some instructions to the program. <br> <code># bonnie++ -d /raid/ -m 'FREEBSD_gmirror' -n 100:16384:0:20 -u root &gt; out.csv &amp;&amp; cat out.csv | bon_csv2html &gt; gmirror_1.html</code> <br>  -n100: 16384: 0: 20: speak to create 100 files from 0 to 16384 b in 20 subdirectories <br>  <b>Results:</b> <br>  <b>freebsd</b> <br><img src="http://s15.radikal.ru/i188/1007/a1/3831e38a35fe.png" alt="image"><br>  <b>linux</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/552/6d7/e95/5526d7e957fd6a39d4db54ab60b9c88b.png" alt="image"><br>  <b>freebsd</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/16f/67c/7ea/16f67c7ea45ef0e27bc1d8e2e6cfcd17.png" alt="image"><br>  <b>linux</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/240/f4e/e01/240f4ee013c0f733ede8a9c2cde3c358.png" alt="image"><br>  * attentive reader will notice the difference in the versions of the program.  Well, put the latest available in ports / repositories. <br><br>  <b>Waters:</b> <br>  As you can see the results of the program are broken for better perception.  I will ignore the launch of the program with the default settings, focus on the last four screenshots. <br>  <b>Sequential Output</b> <br>  As can be seen in the ‚Äúbyte-byte‚Äù Per Char test, Linux flies to the spot so quickly that FreeBSD with its 169 KB / s does not even have time to go to the initial boot process.  22183 KB / s on Linux versus 169 KB / s on FreeBSD.  CPU usage is minimal. <br>  In a test where the record size is 8192 B, FreeBSD wins with almost a double margin.  48840 KB / s on FreeBSD versus 28895 KB / s on Linux.  But FreeBSD loaded the CPU twice as much. <br>  The rewrite test showed a slight difference, 23306 KB / s on FreeBSD versus 18529 KB / s on Linux.  From which it can be concluded that the caching mechanisms of the tested OS are approximately equal in efficiency. <br>  <b>Sequential Input</b> (Last Input) <br>  Here, the victory is clearly for Linux.  Per Char 350 KB / s on FreeBSD versus 26435 KB / s on Linux.  Blocks in 8192 b, 67290 KB / s FreeBSD versus 86610 KB / s on Linux. <br>  <b>Random Seeks</b> (random reads) <br>  Linux wins this test, 165.1s on FreeBSD versus 148.5c on Linux. <br><br>  Let's go to the last two screens. <br>  <b>Sequential Create</b> (sequential creation) <br>  In this test, you create / read / delete files sequentially.  Let me remind the reader that we create 100 files in 20 subdirectories of arbitrary size from 0 to 16 KB. <br>  Speed ‚Äã‚Äãis measured in files per second.  Creating a FreeBSD 103 file / s against 3099 files / s for Linux, I also ask you to pay attention to the CPU load.  Reading, 1556 files / s in FreeBSD versus 34204 files / s in Linux.  Delete 12206 files / s from FreeBSD against 14,121 files / s from Linux.  Linux, with a huge gap from the pursuer, breaks the finishing tape. <br>  <b>Random Create</b> (arbitrary / random creation) <br>  And here, Linux is the undisputed leader.  Creating, FreeBSD 100 files / s against 20187 files / s for Linux.  Reading, 166 files / s in FreeBSD versus 3299 files / s in Linux.  Deleting 9139 files / s from FreeBSD against 11638 files / s from Linux <br><br>  Summing up the results of bonnie ++, it can be noted that Linux, with some exceptions, won a landslide victory.  Operations to create a large number of small files occur many times faster than in FreeBSD.  But I advise the reader not to rush to the final conclusions, not everything is so obvious.  Go ahead. <br><br>  <b>With <i>bonnie ++</i> , we‚Äôll finish this and move on to the next tool, <i>Iozone</i> .</b> <br>  Having played enough with various startup keys, having read the documentation, the following command was born: <br> <code># iozone -Raz -b /home/iam/results_all.xls -f /raid/1 -g 1g</code> <br>  * In fact, I am cunning, I spied the team in the test results on the program website)) <br>  About keys: <br>  -R: tell the program to create a report file <br>  -a: fully automatic mode, the recording size is automatically selected from 4k to 16m (4k..8k..16k..32k .... 16384k) <br>  -f: specify the file on our array <br>  -g: maximum file size is 1Gb (for -a mode) <br>  -z: forces the program started in automatic mode to use small recording sizes for large files (i.e. from 4k to 16m (4k..8k..16k..32k .... 16384k)) <br><br>  For clarity, I will give the results in graphs.  With the specified keys, the program creates a pretty weighty report file, in the charts I highlighted the most interesting, in my opinion, results. <br>  <b>The first will be a test for writing.</b> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/e8a/049/4fd/e8a0494fded18cab789b51dd8955bacb.jpg" alt="image"><br><img src="http://s50.radikal.ru/i127/1007/c4/c60ebcd76fd4.jpg" alt="image"><br><img src="http://s003.radikal.ru/i201/1007/a2/248a32829f97.jpg" alt="image"><br>  The results shown in the first chart do not leave FreeBSD any chance.  When creating a file of 16Mb in size from 4 kilobytes to 16 megabytes, the average Linux value is ~ 204 MB / s, FreeBSD 44.7 MB / s. <br>  The file is 128 MB in size, and when the block size reaches 128KB, the picture changes dramatically and FreeBSD confidently takes the lead.  The mean values ‚Äã‚Äãare: Linux ~ 47.8 MB / s, FreeBSD 48.3 MB / s. <br>  The file size is 1Gb.  FreeBSD maintains the same speed as the two previous files.  Linux, on the contrary, slowed down a lot.  The mean values ‚Äã‚Äãare: Linux ~ 33 MB / s, FreeBSD 48.5 MB / s. <br>  As you can see with smaller files, Linux handles much faster, as we have already noticed.  With a 1Gb file, FreeBSD takes revenge.  It is also revealing that FreeBSD maintains the same speed regardless of file size. <br><br>  <b>Next on the list we are reading.</b> <br><img src="http://i060.radikal.ru/1007/47/db3ccfff0552.png" alt="image"><br><img src="https://habrastorage.org/getpro/geektimes/post_images/4f1/0a3/cab/4f10a3cabb7d612a6ced38bfa7c0a24a.png" alt="image"><br><img src="http://s50.radikal.ru/i127/1007/fc/07f038d9aa29.jpg" alt="image"><br>  First we give the file the size of 16 Mb.  The competitors go almost hull to hull. <br>  Average values: Linux ~ 534 MB / s, FreeBSD ~ 538 MB / s. <br>  File 128 Mb.  From the start, Linux leaves with grinding, but already at the 64 KB checkpoint, his opponent catches up with him and a fierce struggle begins, the first time to finish is Linux.  Average values: Linux ~ 515 MB / s, FreeBSD ~ 380 MB / s. <br>  When they reach our heavyweight, the test OSs bite at the start. <br>  File size of 1Gb.  Linux leaving FreeBSD to swallow the smoke at the start goes into the gap, as you can see, the speed reaches 1Gb / s.  After the breakpoint (starting at 128KB block size), FreeBSD keeps a little behind the leader.  Average values: Linux ~ 553 MB / s, FreeBSD ~ 369 MB / s. <br>  Linux reads much faster than FreeBSD.  Regardless of file size. <br><br>  <b>Randomized (random) recording</b> <br><img src="http://s42.radikal.ru/i095/1007/f7/b6c1988f5524.jpg" alt="image"><br><img src="http://i056.radikal.ru/1007/af/45c950dbfae7.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/geektimes/post_images/a70/0aa/f76/a700aaf761e2d9b35338624bf24f5ccd.jpg" alt="image"><br>  File 16 Mb.  The results speak for themselves, in Linux we see a smooth curve, FreeBSD from something goes to the pitstop after a checkpoint of 1Mb and barely falls short of the finish.  Average results: Linux ~ 356.8 MB / s, FreeBSD ~ 255.5 MB / s. <br>  File 128 Mb.  FreeBSD obviously didn‚Äôt come across and shows depressing results, Linux to the finish also felt wrong, the difference between the block sizes of 8 Mb and 16 Mb is striking.  Average results: Linux ~ 6 MB / s, FreeBSD ~ 3.8 MB / s. <br>  File 1 Gb.  As with the sequential creation of a large-sized file, FreeBSD confidently comes forward, Linux catches the opponent only to the finish.  Average results: Linux ~ 12 MB / s, FreeBSD ~ 26 MB / s. <br><br>  <b>Random (random) reading</b> <br><img src="http://s45.radikal.ru/i109/1007/b1/f8fdc86b3312.jpg" alt="image"><br><img src="http://i062.radikal.ru/1007/ec/b59540bef329.jpg" alt="image"><br><img src="http://i073.radikal.ru/1007/0e/6474520fb766.jpg" alt="image"><br>  The first graph, Linux, was only slightly ahead, but was already overtaken by a 32 KB checkpoint.  Next, the contenders moved flush, with very little FreeBSD benefits.  Average results: Linux ~ 523 MB / s, FreeBSD ~ 458 MB / s. <br>  The picture with the test results of the file size of 128 Mb differs very little from the first one, with the only difference that the clear leader, starting from the block size of 64 KB, was not identified.  Average results: Linux ~ 476 MB / s, FreeBSD ~ 362 MB / s. <br>  The last graph gives us a clear understanding that Linux is far in the forefront, when reading large files.  Average results: Linux ~ 523 MB / s, FreeBSD ~ 274 MB / s. <br><br>  <b>Toward the close of the test results all known utility DD.</b> <br>  Create a 1 Gb file of 4 KB blocks <br>  FreeBSD: 49.02 MB / s <br>  Linux: 23.9 MB / s <br>  We read this file in blocks of 4 KB <br>  FreeBSD: 342.7 MB / s <br>  Linux: 788 MB / s <br><br>  Create a 1 Gb file of 64 KB blocks <br>  FreeBSD: 48.64 MB / s <br>  Linux: 35.0 MB / s <br>  We read this file in blocks of 64 KB <br>  FreeBSD: 350.14 MB / s <br>  Linux: 617 MB / s <br><br>  Create a 1 Gb file of 1 Mb blocks <br>  FreeBSD: 47.98 MB / s <br>  Linux: 23.9 MB / s <br>  We read this file in blocks of 4 KB <br>  FreeBSD: 348.51 MB / s <br>  Linux: 460 MB / s <br><br>  Create a file of 1000 Mb in size from blocks of 100 Mb <br>  FreeBSD: 44.24 MB / s <br>  Linux: 37.7 MB / s <br>  We read this file in blocks of 4 KB <br>  FreeBSD: 308.61 MB / s <br>  Linux: 459 MB / s <br><br>  Create a file of 100 Gb in size from 1 Gb blocks <br>  FreeBSD: 31.7 MB / s <br>  Linux: 14.7 MB / s <br>  We read this file in blocks of 4 KB <br>  FreeBSD: 57.48 MB / s <br>  Linux: failed to get result <br><br>  FreeBSD is clearly faster than Linux when creating files.  Linux is more powerful in reading files. <br><br>  Listings dd <br>  <b>Freebsd</b> <br>  * dd output to FreeBSD I did a little tweaking for readability <br> <code>   1Gb   4k <br> # /usr/bin/time -h dd if=/dev/zero of=testfile bs=4k count=262144 <br> 262144+0 records in <br> 262144+0 records out <br> 1073741824 bytes transferred in 20.888121 secs (49,02 Mbytes/sec) <br> 21.05s real 0.45s user 11.12s sys <br>      4k <br> *   <br> # /usr/bin/time -h dd if=testfile of=/dev/null bs=4k count=262144 <br> 262144+0 records in <br> 262144+0 records out <br> 1073741824 bytes transferred in 2.987966 secs (342,7 Mbytes/sec) <br> 2.99s real 0.15s user 2.82s sys <br> <br> # /usr/bin/time -h dd if=/dev/zero of=testfile bs=64k count=16384 <br> 16384+0 records in <br> 16384+0 records out <br> 1073741824 bytes transferred in 21.050771 secs (48,64 Mbytes/sec) <br> 21.05s real 0.08s user 8.12s sys <br> # /usr/bin/time -h dd if=testfile of=/dev/null bs=64k count=16384 <br> 16384+0 records in <br> 16384+0 records out <br> 1073741824 bytes transferred in 2.924540 secs (350,14 Mbytes/sec) <br> 2.92s real 0.05s user 2.86s sys <br> <br> # /usr/bin/time -h dd if=/dev/zero of=testfile bs=1m count=1024 <br> 1024+0 records in <br> 1024+0 records out <br> 1073741824 bytes transferred in 21.341423 secs (47,98bytes/sec) <br> 21.57s real 0.00s user 7.87s sys <br> <br> # /usr/bin/time -h dd if=testfile of=/dev/null bs=1m count=1024 <br> 1024+0 records in <br> 1024+0 records out <br> 1073741824 bytes transferred in 2.938155 secs (348,51 Mbytes/sec) <br> 2.94s real 0.00s user 2.92s sys <br> <br> # /usr/bin/time -h dd if=/dev/zero of=testfile bs=100m count=10 <br> 10+0 records in <br> 10+0 records out <br> 1048576000 bytes transferred in 22.601393 secs (44,24 Mbytes/sec) <br> 22.86s real 0.00s user 7.89s sys <br> <br> # /usr/bin/time -h dd if=testfile of=/dev/null bs=100m count=10 <br> 10+0 records in <br> 10+0 records out <br> 1048576000 bytes transferred in 3.240300 secs (308,61 Mbytes/sec) <br> 3.26s real 0.00s user 3.25s sys <br> <br> # /usr/bin/time -h dd if=/dev/zero of=testfile bs=1g count=100 <br> 100+0 records in <br> 100+0 records out <br> 107374182400 bytes transferred in 3229.788959 secs (31,7 Mbytes/sec) <br> 53m50.33s real 0.00s user 14m40.89s sys <br> # /usr/bin/time -h dd if=testfile of=/dev/null bs=1g count=100 <br> 100+0 records in <br> 100+0 records out <br> 107374182400 bytes transferred in 1781.360638 secs (57,48 Mbytes/sec) <br> 29m41.67s real 0.00s user 6m44.73s sys</code> <br> <br>  <b>Linux</b> <br> <code>debian:/raid# dd if=/dev/zero of=testfile bs=4k count=262144 <br> <br> 262144+0   <br> <br> 262144+0   <br> <br>  1073741824  (1,1 GB), 45,0159 c, 23,9 MB/c <br> <br> debian:/raid# dd if=testfile of=/dev/null bs=4k count=262144 <br> <br> 262144+0   <br> <br> 262144+0   <br> <br>  1073741824  (1,1 GB), 1,36295 c, 788 MB/c <br> <br> debian:/raid# dd if=/dev/zero of=testfile bs=64k count=16384 <br> <br> 16384+0   <br> <br> 16384+0   <br> <br>  1073741824  (1,1 GB), 28,2238 c, 38,0 MB/c <br> <br> debian:/raid# dd if=testfile of=/dev/null bs=64k count=16384 <br> <br> 16384+0   <br> <br> 16384+0   <br> <br>  1073741824  (1,1 GB), 1,73935 c, 617 MB/c <br> <br> debian:/raid# dd if=/dev/zero of=testfile bs=1M count=1024 <br> <br> 1024+0   <br> <br> 1024+0   <br> <br>  1073741824  (1,1 GB), 30,711 c, 35,0 MB/c <br> <br> debian:/raid# dd if=testfile of=/dev/null bs=1M <br> <br> 1024+0   <br> <br> 1024+0   <br> <br>  1073741824  (1,1 GB), 2,33447 c, 460 MB/c <br> <br> debian:/raid# dd if=/dev/zero of=testfile bs=100M count=10 <br> <br> 10+0   <br> <br> 10+0   <br> <br>  1048576000  (1,0 GB), 27,8344 c, 37,7 MB/c <br> <br> debian:/raid# dd if=testfile of=/dev/null bs=100M count=10 <br> <br> 10+0   <br> <br> 10+0   <br> <br>  1048576000  (1,0 GB), 2,28437 c, 459 MB/c <br> <br> debian:/raid# dd if=/dev/zero of=testfile bs=1024M count=100 <br> <br> 100+0   <br> <br> 100+0   <br> <br>  107374182400  (107 GB), 7315,88 c, 14,7 MB/c <br> <br> debian:/raid# dd of=testfile if=/dev/null bs=1024M count=100 <br> <br> 0+0   <br> <br> 0+0   <br> <br>  0  (0 B), 7,5694e-05 c, 0,0 kB/c</code> <br> <br>  <b>Epilogue</b> <br>  The idea to test, as I already wrote, was born spontaneously.  Initially, I just wanted to assemble Software RAID for backups on a budget machine, and then this <b>VS</b> , <s>his mother</s> , got into it.  For me, the choice is obvious - FreeBSD, it is a bit faster when creating files, especially when creating large files.  Just what I need.  Having carried out this test, I was only once again convinced of the correctness of the occupied position with regards to different holly war - it all depends on the tasks. <br>  Although I‚Äôm not speaking the whole truth again.  The choice in favor of FreeBSD was made before the test.  Since I just know this OS much better than Linux, and I like it a lot more.  If we look at the results objectively, then I, absolutely deservedly, will give the victory to Linux.  Having run again according to the test results, there is no doubt about it. <br>  Someone can fairly notice, but why did you ‚Äúbother‚Äù so much with these tests, already bonnie ++ told you everything, but no.  I used to approach everything thoughtfully, with feeling, sensibly.  Yes, and the free time that appeared allowed to experiment. <br>  How competent and informative my report is for you to decide, I am not a professional in * nix, my journey to this fascinating world began relatively recently. <br>  Thanks to those who mastered. <br><br>  PS <br>  In the preparation of the material used: <br>  1. Linux Administrator's Guide.  Authors: Nemeth E., Snyder G., Trent H. <br>  2. FreeBSD.  Detailed guide.  Michael Lucas. <br>  3. google.com <br>  4. / dev / hands and / dev / head =) <br>  This report was prepared with the active help of comrades with unixadmins.su, a special thank you. </div><p>Source: <a href="https://habr.com/ru/post/98649/">https://habr.com/ru/post/98649/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../98640/index.html">Programmers "above average"</a></li>
<li><a href="../98641/index.html">Negative experience of ordering iPhone 4 in Apple Store UK - how to disappoint a customer</a></li>
<li><a href="../98642/index.html">13 anti-tips to the developer who wants to write a good website</a></li>
<li><a href="../98643/index.html">Can an Apple iOS server appear for ARM servers?</a></li>
<li><a href="../98648/index.html">Take an invite from the troll</a></li>
<li><a href="../98651/index.html">Search for cheap 3G Internet among Moscow offers</a></li>
<li><a href="../98656/index.html">Russian equipment. Part 5. Natex FlexCon</a></li>
<li><a href="../98659/index.html">In game consoles add support for 3G</a></li>
<li><a href="../98661/index.html">Hooray, honest militiamen in our country</a></li>
<li><a href="../98669/index.html">Well, a very stylish all-in-one PC from Lenovo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>