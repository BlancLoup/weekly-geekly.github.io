<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural generation of three-dimensional models</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Procedural generation is a great thing! The most interesting thing is to work with graphics, especially three-dimensional - the result is immediately ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural generation of three-dimensional models</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/860/d0e/35a/860d0e35a619325aa811a75a51bc4416.jpg"><br><br>  Procedural generation is a great thing!  The most interesting thing is to work with graphics, especially three-dimensional - the result is immediately visible.  Just a couple of instructions are enough to create a cloud of triangles like in the image above. <br><br>  Procedural generation of models can help save the size of the distribution, add customization of game characters, at worst, you can simply use it to create special effects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using the example of the <a href="http://unity3d.com/">Unity</a> engine and C #, I will show how you can work with models and turn text into graphics.  Most of the given code can be easily ported to other frameworks and languages. <br><br><h2>  Triangle </h2><img align="right" src="https://habrastorage.org/storage3/590/8bc/29d/5908bc29dfc2d3c2d13db9c2486b7cff.gif"><br>  Let's start with the simplest form - a triangle.  In Unity and in many other engines, a popular way of describing models is used: using arrays of vertices, triangles and normals.  Additionally, the vertex <a href="http://ru.wikipedia.org/wiki/UV-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">uv coordinates</a> are used for texturing.  To work with models there is a class <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh.html">Mesh</a> , in which there is a separate array for each data set.  The coordinates of the vertices are stored in <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh-triangles.html">Mesh.vertices</a> , in <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh-triangles.html">Mesh.triangles</a> - the indexes of the vertices in groups of three.  And in <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh-normals.html">Mesh.normals</a> and <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh-uv.html">Mesh.uv</a> are normal vectors and coordinates of uv-maps, the indices of which must coincide with the indices of the corresponding vertices, i.e. the order in the arrays must be the same.  I will show an example to make it clearer. <br><a name="habracut"></a><br>  Let's make a function that accepts three vertices of the triangle as input, and gives the finished model one.  Let's start with the basics. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vertex0, Vector3 vertex1, Vector3 vertex2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {vertex0, vertex1, vertex2}; mesh.triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre> <br>  We pack three vertices into an array and pass to the meshu.  The triangle is described elementarily, but there is a nuance that needs to be remembered.  If you look at the model from the outside, then the vertices of its triangles should be positioned clockwise.  This is done so that during drawing it is possible to cut off the triangles that ‚Äúdo not look into the camera,‚Äù and process them separately.  The order of the vertices is calculated very simply, so this filtering method is very efficient.  If we take the <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">product of</a> two vectors, then we can find the third vector perpendicular to the plane formed by the factors.  If you run through the triangle and count the pieces, you can find out the order of the vertices.  By the way, we also need these perpendicular vectors to describe the models - this is normal.  The normal is considered as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross((vertex1 - vertex0), (vertex2 - vertex0)).normalized;</code> </pre><br>  First two vectors were made of three points, and then they were multiplied.  This normal will be the same on all vertices of the triangle. <br><br><pre> <code class="cs hljs">mesh.normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {normal, normal, normal};</code> </pre><br>  It remains to add uv-coordinates, for three vertices it is easy. <br><br><pre> <code class="cs hljs">mesh.uv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)};</code> </pre><br>  Well, that's all, the triangle is ready.  Now you can use it. <br><br><div class="spoiler">  <b class="spoiler_title">Triangle</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vertex0, Vector3 vertex1, Vector3 vertex2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross((vertex1 - vertex0), (vertex2 - vertex0)).normalized; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh { vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {vertex0, vertex1, vertex2}, normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {normal, normal, normal}, uv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)}, triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br><h2>  Quadrilateral </h2><img align="right" src="https://habrastorage.org/storage3/122/201/fb4/122201fb49c078f32ea308f0572aa0ff.gif"><br>  In addition to the triangles, there is another popular primitive for modeling - a quadrilateral, or a quad, if you prefer. <br><br>  To describe a quadrilateral droplet is more difficult, you need to add one vertex with its characteristics and an additional triangle.  I slightly changed the input parameters compared to the triangle, now I need to specify the lower left corner and two sides, with real Quads Mesh in Unity still does not work. <br><br>  I remind you that the vertices are still recorded clockwise. <br><br><div class="spoiler">  <b class="spoiler_title">Quadrilateral</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Quad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 width, Vector3 length</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross(length, width).normalized; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh { vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { origin, origin + length, origin + length + width, origin + width }, normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { normal, normal, normal, normal }, uv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }, triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br>  Now that we have two basic primitives, we can build any model. <br><br><h2>  Plane </h2><img align="right" src="https://habrastorage.org/storage3/fe1/730/bdc/fe1730bdcedb93cd625ca2579a0439c4.gif"><br>  Let's experiment with the assembly of models on the example of a plane.  Take a lot of squares and lay the joint into a joint. <br><br>  Laziness is the engine of progress, so we will use <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh.CombineMeshes.html">Mesh.CombineMeshes</a> to build the squares into the model.  This method takes as input a <a href="http://docs.unity3d.com/Documentation/ScriptReference/CombineInstance.html">CombineInstance</a> structure in which you can specify the model, its index, and the transformation matrix.  For us, only the first is important, the rest is ignored. <br><br>  The starting position of the plane, the width and length of the segment, the number of segments are fed to the input of the method.  In a double loop, all the squares are added to the CombineInstance array, after which the array is assembled into the finished model. <br><br><div class="spoiler">  <b class="spoiler_title">Plane</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Plane</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 width, Vector3 length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lengthCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombineInstance[widthCount * lengthCount]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; widthCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; lengthCount; y++) { combine[i].mesh = Quad(origin + width * x + length * y, width, length); i++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.CombineMeshes(combine, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br><h2>  Parallelepiped </h2><img align="right" src="https://habrastorage.org/storage3/0d6/4de/1dd/0d64de1ddf3eced717275d3348c115dd.gif"><br>  Laying tiles on the plane is too simple, it's time to move to the third dimension. <br><br>  Cubes are well made from squares.  Even better, using our pseudo-squares, you can make not only cubes, but also parallelepipeds.  Only shhh!  Don't tell anyone. <br><br>  Only six quadrangles are needed.  Knowing the length, width and height of the parallelepiped, one can calculate all its vertices.  It is convenient to first find two opposite corners of the parallelepiped, and then rebuild everything else from them.  It also makes sense to center the model.  How it looks in practice can be viewed below. <br><br><div class="spoiler">  <b class="spoiler_title">Parallelepiped</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cube</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 width, Vector3 length, Vector3 height</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> corner0 = -width/<span class="hljs-number"><span class="hljs-number">2</span></span> - length/<span class="hljs-number"><span class="hljs-number">2</span></span> - height/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> corner1 = width/<span class="hljs-number"><span class="hljs-number">2</span></span> + length/<span class="hljs-number"><span class="hljs-number">2</span></span> + height/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombineInstance[<span class="hljs-number"><span class="hljs-number">6</span></span>]; combine[<span class="hljs-number"><span class="hljs-number">0</span></span>].mesh = Quad(corner0, length, width); combine[<span class="hljs-number"><span class="hljs-number">1</span></span>].mesh = Quad(corner0, width, height); combine[<span class="hljs-number"><span class="hljs-number">2</span></span>].mesh = Quad(corner0, height, length); combine[<span class="hljs-number"><span class="hljs-number">3</span></span>].mesh = Quad(corner1, -width, -length); combine[<span class="hljs-number"><span class="hljs-number">4</span></span>].mesh = Quad(corner1, -height, -width); combine[<span class="hljs-number"><span class="hljs-number">5</span></span>].mesh = Quad(corner1, -length, -height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.CombineMeshes(combine, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br><br><h2>  Octahedron </h2><br>  The octahedron is much like a cube, its vertices are very easy to calculate, the biggest difficulty is to figure out the order of the vertices in the triangles.  The octahedron fits into the sphere, so it makes sense to build it along the radius of this sphere.  All vertices are elementary, so I will not stop here. <br><br><div class="spoiler">  <b class="spoiler_title">Octahedron</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Octahedron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  var v0 = new Vector3(0, -radius, 0); //   var v1 = new Vector3(-radius, 0, 0); var v2 = new Vector3(0, 0, -radius); var v3 = new Vector3(+radius, 0, 0); var v4 = new Vector3(0, 0, +radius); //  var v5 = new Vector3(0, radius, 0); var combine = new CombineInstance[8]; combine[0].mesh = Triangle(v0, v1, v2); combine[1].mesh = Triangle(v0, v2, v3); combine[2].mesh = Triangle(v0, v3, v4); combine[3].mesh = Triangle(v0, v4, v1); combine[4].mesh = Triangle(v5, v2, v1); combine[5].mesh = Triangle(v5, v3, v2); combine[6].mesh = Triangle(v5, v4, v3); combine[7].mesh = Triangle(v5, v1, v4); var mesh = new Mesh(); mesh.CombineMeshes(combine, true, false); return mesh; }</span></span></code> </pre><br></div></div><img align="right" src="https://habrastorage.org/storage3/c8a/73e/56e/c8a73e56eba3cf962270c9ea600412ad.gif"><br>  Although there is one more thing.  Until now, many of the vertices in our models were duplicated, although, as you may have heard, when creating models, on the contrary, they always try to reduce the number of vertices and triangles.  Why is the cube and octahedron wrong?  Let me show with an example, here is the octahedron assembly code with the minimum number of vertices necessary: <br><br><div class="spoiler">  <b class="spoiler_title">Octahedron with common vertices at triangles</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Octahedron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">6</span></span>]; v[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, -radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); v[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-radius, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); v[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, -radius); v[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(+radius, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); v[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, +radius); v[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh { vertices = v, triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>} }; mesh.RecalculateNormals(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre></div></div><br>  In the end, I applied <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mesh.RecalculateNormals.html">Mesh.RecalculateNormals</a> , which automatically counts the normals, it's easier. <br><br>  Look at the difference in lighting between the two octahedra in the next picture.  In the first case, the shader has to interpolate between normals, looking completely different directions, so the lighting is unrealistic.  And in the second case, all the faces are sharp, clear.  General normals are suitable for spheres, smooth surfaces, or if you need to hide a small number of polygons.  And for our case, the peaks need more. <br><br><h2>  Tetrahedron </h2><img align="right" src="https://habrastorage.org/storage3/6bb/59c/3b0/6bb59c3b0bae28d5cf49e8516f8ab850.gif"><br>  Now you can take on the interesting figures.  Calculating vertices even for a simple tetrahedron will require a five for school geometry, so I‚Äôm just warning you, if you don‚Äôt remember what is divided in the sine, it‚Äôs best to look at the textbook first, as I had to do. <br><br>  Refresh your memory?  We continue. <br><br>  Let our tetrahedron stand on one of the faces, then you can add the opposite vertex right away: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">4</span></span>]; v[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  The remaining vertices must form an equilateral triangle.  Their coordinates can be found using sines and cosines.  In Unity, there are functions <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Sin.html">Mathf.Sin</a> and <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Cos.html">Mathf.Cos</a> , which are calculated in radians.  We divide the circle into three parts and find three points on it: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmentAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentAngle = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { v[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(Mathf.Sin(currentAngle), <span class="hljs-number"><span class="hljs-number">0</span></span>, Mathf.Cos(currentAngle)); currentAngle += segmentAngle; }</code> </pre><br>  It is already possible to assemble a pyramid from these vertices, but this will not be a tetrahedron, because in a real tetrahedron all the faces are the same.  For a real tetrahedron, the base of the pyramid needs to be slightly reduced and shifted below.  Here again, the sines and cosines will come in handy, but in order to use them, we swell a little and see one corner on <a href="http://en.wikipedia.org/wiki/Tetrahedron">Wikipedia</a> .  ‚ÄúEdge central angle‚Äù is the angle between the radii of the described sphere intersecting the vertices of the tetrahedron.  Hmm, or something like that, I managed to get confused while formulating a thought.  In general, adding this angle we get the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tetrahedralAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">119.4712f</span></span> / <span class="hljs-number"><span class="hljs-number">180</span></span>;</code> </pre><br>  And in the loop: <br><br><pre> <code class="cs hljs">v[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(Mathf.Sin(currentAngle) * Mathf.Sin(tetrahedralAngle), Mathf.Cos(tetrahedralAngle), Mathf.Cos(currentAngle) * Mathf.Sin(tetrahedralAngle));</code> </pre><br>  Not so difficult, I hope everyone understood everything.  This is how it looks in the end, with the addition of scaling: <br><br><div class="spoiler">  <b class="spoiler_title">Tetrahedron more difficult</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tetrahedron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tetrahedralAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">109.4712f</span></span> / <span class="hljs-number"><span class="hljs-number">180</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmentAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentAngle = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">4</span></span>]; v[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { v[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(radius * Mathf.Sin(currentAngle) * Mathf.Sin(tetrahedralAngle), radius * Mathf.Cos(tetrahedralAngle), radius * Mathf.Cos(currentAngle) * Mathf.Sin(tetrahedralAngle)); currentAngle = currentAngle + segmentAngle; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombineInstance[<span class="hljs-number"><span class="hljs-number">4</span></span>]; combine[<span class="hljs-number"><span class="hljs-number">0</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">1</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">2</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">3</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.CombineMeshes(combine, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br>  But the same tetrahedron without mathematics, with hard-coded vertices, feel the difference: <br><br><div class="spoiler">  <b class="spoiler_title">Tetrahedron easier</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tetrahedron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, -radius * <span class="hljs-number"><span class="hljs-number">0.333f</span></span>, radius * <span class="hljs-number"><span class="hljs-number">0.943f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(radius * <span class="hljs-number"><span class="hljs-number">0.816f</span></span>, -radius * <span class="hljs-number"><span class="hljs-number">0.333f</span></span>, -radius * <span class="hljs-number"><span class="hljs-number">0.471f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-radius * <span class="hljs-number"><span class="hljs-number">0.816f</span></span>, -radius * <span class="hljs-number"><span class="hljs-number">0.333f</span></span>, -radius * <span class="hljs-number"><span class="hljs-number">0.471f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombineInstance[<span class="hljs-number"><span class="hljs-number">4</span></span>]; combine[<span class="hljs-number"><span class="hljs-number">0</span></span>].mesh = Triangle(v0, v1, v2); combine[<span class="hljs-number"><span class="hljs-number">1</span></span>].mesh = Triangle(v1, v3, v2); combine[<span class="hljs-number"><span class="hljs-number">2</span></span>].mesh = Triangle(v0, v2, v3); combine[<span class="hljs-number"><span class="hljs-number">3</span></span>].mesh = Triangle(v0, v3, v1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.CombineMeshes(combine, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br><br><h2>  Icosahedron </h2><img align="right" src="http://habrastorage.org/storage3/813/0ba/553/8130ba55335789d5750e55af02eb9af8.gif"><br>  Finally, the most delicious - icosahedron.  If you align the icosahedron and look at it from the right angle, you can see that its two vertices lie on one axis below each other, and the rest are on two circles. <br><br>  On each circle there are five of them, and therefore the interval between them is 72 degrees.  The offset between the circles is 36 degrees.  To align the vertices, we again need the <a href="http://en.wikipedia.org/wiki/Icosahedron">magic angle from Wikipedia</a> : ‚ÄúIf you‚Äôre at latitude (1/2) ‚âà ¬± 26.57 ¬∞ ".  Translated into Russian, this means that the magic angle is <a href="https://www.google.ru/search%3Fq%3Darctan(1%252F2)%2Bin%2Bdegrees">one second arctangent</a> . <br><br>  In the end, everything looks like a tetrahedron, just two circles and a bit more complicated coupling of vertices.  Immediately add two vertices, count one half, then the other.  We collect in triangles in four portions. <br><br><div class="spoiler">  <b class="spoiler_title">Icosahedron</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icosahedron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> magicAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">26.565f</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmentAngle = Mathf.PI * <span class="hljs-number"><span class="hljs-number">72</span></span> / <span class="hljs-number"><span class="hljs-number">180</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentAngle = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">12</span></span>]; v[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); v[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, -radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { v[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(radius * Mathf.Sin(currentAngle) * Mathf.Cos(magicAngle), radius * Mathf.Sin(magicAngle), radius * Mathf.Cos(currentAngle) * Mathf.Cos(magicAngle)); currentAngle += segmentAngle; } currentAngle = Mathf.PI*<span class="hljs-number"><span class="hljs-number">36</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">6</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>; i++) { v[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(radius * Mathf.Sin(currentAngle) * Mathf.Cos(-magicAngle), radius * Mathf.Sin(-magicAngle), radius * Mathf.Cos(currentAngle) * Mathf.Cos(-magicAngle)); currentAngle += segmentAngle; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombineInstance[<span class="hljs-number"><span class="hljs-number">20</span></span>]; combine[<span class="hljs-number"><span class="hljs-number">0</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">1</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">2</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">4</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">3</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">4</span></span>], v[<span class="hljs-number"><span class="hljs-number">5</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">4</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">5</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">5</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">11</span></span>], v[<span class="hljs-number"><span class="hljs-number">7</span></span>], v[<span class="hljs-number"><span class="hljs-number">6</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">6</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">11</span></span>], v[<span class="hljs-number"><span class="hljs-number">8</span></span>], v[<span class="hljs-number"><span class="hljs-number">7</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">7</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">11</span></span>], v[<span class="hljs-number"><span class="hljs-number">9</span></span>], v[<span class="hljs-number"><span class="hljs-number">8</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">8</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">11</span></span>], v[<span class="hljs-number"><span class="hljs-number">10</span></span>], v[<span class="hljs-number"><span class="hljs-number">9</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">9</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">11</span></span>], v[<span class="hljs-number"><span class="hljs-number">6</span></span>], v[<span class="hljs-number"><span class="hljs-number">10</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">10</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">2</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">6</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">11</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>], v[<span class="hljs-number"><span class="hljs-number">7</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">12</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">4</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">8</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">13</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">5</span></span>], v[<span class="hljs-number"><span class="hljs-number">4</span></span>], v[<span class="hljs-number"><span class="hljs-number">9</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">14</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">5</span></span>], v[<span class="hljs-number"><span class="hljs-number">10</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">15</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">6</span></span>], v[<span class="hljs-number"><span class="hljs-number">7</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">16</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">7</span></span>], v[<span class="hljs-number"><span class="hljs-number">8</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">17</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">8</span></span>], v[<span class="hljs-number"><span class="hljs-number">9</span></span>], v[<span class="hljs-number"><span class="hljs-number">4</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">18</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">9</span></span>], v[<span class="hljs-number"><span class="hljs-number">10</span></span>], v[<span class="hljs-number"><span class="hljs-number">5</span></span>]); combine[<span class="hljs-number"><span class="hljs-number">19</span></span>].mesh = Triangle(v[<span class="hljs-number"><span class="hljs-number">10</span></span>], v[<span class="hljs-number"><span class="hljs-number">6</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); mesh.CombineMeshes(combine, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mesh; }</code> </pre><br></div></div><br><h2>  Conclusion </h2><br>  If you carefully read the code in the article, you probably noticed that there are a lot of unnecessary calculations, the same Mathf.Cos (magicAngle) from the example above.  If desired, it can be counted only once and put into a variable, it will not be so clear and understandable, but faster. <br><br>  In addition, the generated models are not the most convenient uv-cards, it would be nice to fix them, but for this you have to redo a lot of code, and so far it will come down. <br><br>  And where are the spheres and cylinders?  - you ask.  The editor of articles on Habrahabr, of course, is wonderful, but navigating through large volumes of text in it is not very convenient, so I will leave the spheres for the next time. <br><br>  Sources and binaries for different platforms can be downloaded from the links below. <br><br>  <b>Note: The code for the links below is outdated; see the <a href="https://github.com/Syomus/ProceduralToolkit">Procedural Toolkit for the</a> latest version.</b> <br><br>  <a href="http://basmanovdaniil.github.io/ProceduralExperiments/Web%2520PGMesh.html">Unity Web Player</a> |  <a href="">Windows</a> |  <a href="">Linux</a> |  <a href="">Mac</a> |  <a href="https://github.com/BasmanovDaniil/ProceduralExperiments">Sources on GitHub</a> <br><br><img src="http://habrastorage.org/storage3/7f0/31f/a43/7f031fa43c1e01f86e8cff846d7b374c.gif"></div><p>Source: <a href="https://habr.com/ru/post/194620/">https://habr.com/ru/post/194620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../194596/index.html">DARPA is developing a reusable drone to deliver satellites into orbit</a></li>
<li><a href="../194602/index.html">Would you like to spend 70 days in bed? Nasa pays $ 18,000 for total idleness</a></li>
<li><a href="../194604/index.html">Quasar IV: Ninja's ‚ÄúChiffon‚Äù Who Is Too Good to Be True</a></li>
<li><a href="../194616/index.html">Objective Europa project: a trip to Europe ... one way</a></li>
<li><a href="../194618/index.html">Ion.Sound - plugin for playing sounds. Creation and features</a></li>
<li><a href="../194626/index.html">Interesting moments that you might not know about C # (Array)</a></li>
<li><a href="../194628/index.html">0 AD - free real-time strategy collects money on Indiegogo</a></li>
<li><a href="../194632/index.html">Render a landscape in WebGL - 2</a></li>
<li><a href="../194636/index.html">New mobile A / B testing framework from Facebook. Navigation panel redesign for iOS 5.6 & 7</a></li>
<li><a href="../194638/index.html">Bioprinter do it yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>