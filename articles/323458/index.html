<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What to base React applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Every time you start writing a React application, you somehow choose some option: 


- copy-paste your previous project 
- some kind of boilerplate or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What to base React applications</h1><div class="post__text post__text-html js-mediator-article"><p>  Every time you start writing a React application, you somehow choose some option: </p><br><ul><li>  copy-paste your previous project </li><li>  some kind of boilerplate or even a generator (like Yeoman) </li><li>  ready framework not requiring configuration </li><li>  write everything from scratch </li></ul><br><p>  Each method has its strengths and weaknesses, both in the long and in the short distance. </p><br><p>  Some solutions hide complexity at the beginning, allowing you to make a quick start.  This is something like a turnkey solution, but as a result such solutions may not be flexible enough and difficult to adjust.  On the other hand, in the beginning everything may seem slightly monstrous and slow, and in order to start you need to tinker a bit, but then the advantages will become obvious.  There is always the opportunity to do everything from scratch, exactly the way you want, but in this case you will be responsible for countless aspects and you will need very deep knowledge in all the technologies involved. <a name="habracut"></a></p><br><p>  Obviously, having a standard inside the company is extremely useful when it comes to developing several projects, so any team can be switched to any project.  Or in the case of a design studio that constantly creates new and new projects.  In this case, the creation of the base should take as little time as possible.  A common standard approach allows teams and developers to share knowledge, you can maintain a certain base of standard solutions, best practices, etc. </p><br><p>  Market analysis shows that there are several fairly stable projects that provide some kind of infrastructure for creating websites on React.  I chose several of them, trying to ensure that all candidates, for clarity, had as different a nature as possible. </p><br><h1 id="kandidaty">  Candidates </h1><br><ul><li>  <a href="https://zeit.co/blog/next">Zeit Next.js</a> , about which I wrote a separate article <a href="https://habrahabr.ru/post/323588/">Create an isomorphic / universal application on Next.JS + Redux</a> </li><li>  <a href="http://electrode.io/">Walmart labs electrode</a> </li><li>  <a href="https://github.com/facebookincubator/create-react-app">Facebook Create React App</a> (+ some parts of custom solution) </li><li>  Kastomschina, for example, in my article <a href="https://habrahabr.ru/post/323500/">Simplify a universal / isomorphic application on React + Router + Redux + Express</a> <br><ul><li>  <a href="https://webpack.js.org/">Webpack</a> to build + <a href="https://github.com/andywer/webpack-blocks">Webpack Blocks</a> for easy configuration </li><li>  <a href="https://expressjs.com/">ExpressJS</a> server </li><li>  <a href="http://redux.js.org/">Redux</a> for state management </li><li>  <a href="https://reacttraining.com/react-router">React Router</a> for code structuring and navigation </li><li>  <a href="https://github.com/kirill-konshin/create-react-server">Create React Server</a> to tie everything together in server rendering. </li></ul></li></ul><br><h1 id="chto-nuzhno-pomnit-razrabatyvaya-sovremennoe-prilozhenie">  What you need to remember when developing a modern application </h1><br><h2 id="keshiruemye-chasti">  Cacheable parts </h2><br><p>  If you collect the entire application into one giant JS file, it will be loaded forever, while users will watch the download animation.  Studies show that users prefer to leave sites that do not have time to load in 3 seconds. </p><br><ul><li>  <strong>Next.js</strong> automatically creates a separate chunk for each page. </li><li> <strong>Electrode</strong> , <strong>Create React App</strong> and <strong>custom</strong> use React Router.  Webpack, in turn, has the so-called code-splitting, which works great with the React Router.  By the way, dynamic <code>import()</code> now <a href="https://webpack.js.org/guides/code-splitting-import">supported by Webpack 2</a> .  For those who still sit on the Webpack 1.x, <a href="https://github.com/airbnb/babel-plugin-dynamic-import-webpack">too, there is a solution</a> .  Electrode has a <a href="https://github.com/electrodejs/electrode-redux-router-engine">special archetype</a> as a solution. </li></ul><br><h2 id="upravlenie-statikoy">  Static Management </h2><br><p>  On the one hand, the application should deliver as much as possible at once, so as not to go over the network once more for resources (pictures, styles, scripts), for example, so-called.  vendor-chunk with all libraries, important CSS scripts.  But at the same time, we want to deliver as little as possible, only what is necessary on this page. </p><br><ul><li>  <strong>Create React App</strong> does not modify the Webpack configuration, so here the span </li><li>  <strong>Next.js</strong> , <strong>Electrode</strong> and <strong>custom</strong> allow you to modify the Webpack config and thus change what plug-ins go through plug-ins </li></ul><br><h2 id="server-side-rendering">  Server side rendering </h2><br><p>  The application can download all the necessary data and generate ready-made HTML, which together with the data will be given to the client, thus virtually eliminating the delay between the initial download and the moment when at least something appears on the site, at least for viewing.  We don‚Äôt say about the possibility of using all this, this is a separate topic. </p><br><p>  Google ranks sites using response time as well.  Despite the fact that search engines are able to render AJAX sites, this is bad for the position, so the site must provide a version that search engines can digest.  There is a problem with this, if we want to load all the data, and not just the main content area, how to let the server render know that all the downloads are finished?  There is no established approach for this yet.  In the custom version, we can parse the component tree and pull out, for example, the static <code>getInitialProps</code> method (by analogy with Next.js), and when all these methods return their values, then it can be rendered. </p><br><ul><li>  <strong>Create React App</strong> server rendering is not trained, and is unlikely to ever learn </li><li>  <strong>Next.js</strong> and <strong>Electrode</strong> is the main feature </li><li>  If we are all building from scratch (i.e. <strong>caste</strong> ), then this will also have to be built </li></ul><br><p>  In order for the components themselves to say what they need from the data, Relay + GraphQL was invented, but the disadvantages outweigh its advantages.  It needs a separate server.  He is wildly verbally (the scheme itself + mutations are monstrously cumbersome).  The complexity of the code you need to write for the simplest actions almost kills all bonuses.  Explaining it to someone from the team from scratch is also problematic.  In addition, a special Babel transform is required, as well as a utility for downloading and compiling the schema.  As a result, you still get something incompatible with SEO.  We have to admit that if you only consume the existing GraphQL API, then the situation is a little better.  This is a rather promising technology, I want to believe that the guys will manage to make it more friendly.  It is also worth noting such a thing as the Apollo Framework. </p><br><p>  During the study, I created a couple of libraries that can help with Server Side Rendering: </p><br><ul><li>  <a href="https://habrahabr.ru/post/323500">Create React Server</a> (for <strong>custom</strong> ) </li><li>  <a href="https://habrahabr.ru/post/323588">Next.js and Redux</a> </li></ul><br><h2 id="proizvoditelnost-server-side-rendering">  Server Side Rendering Performance </h2><br><p>  At some point, server performance will cease to be enough for rendering components.  In this case, some components can begin to cache. </p><br><ul><li>  <strong>Electrode</strong> has a plugin, and for combat mode, all code is taken from pre-compiled files. </li><li>  <strong>Next.js</strong> doesn't provide anything for this yet, but the code compiles and saves everything. </li><li>  In a <strong>custom</strong> solution, as usual, everything will have to be done by yourself, there are ways to simplify the process, for example, through the <a href="https://habrahabr.ru/post/323500">Create React Server</a> , but they do not control the saving of compiled code for the server </li><li>  <strong>Create React App</strong> server rendering does not have </li></ul><br><h2 id="css-preprocessors">  CSS preprocessors </h2><br><p>  Many people use LESS / SASS / Stylus / PostCSS in order to use variables and mix-ins in their styles, so the code is cleaner and more concise. </p><br><ul><li>  <strong>Electrode</strong> and <strong>Next.js</strong> do not provide anything for this, you can customize the Webpack config, but this is not highly recommended </li><li>  <strong>The Create React App</strong> does not support at all, and they even have an explanation (TL; DR; use composition) </li><li>  In a <strong>custom</strong> project, you can use regular Webpack Loaders. </li></ul><br><p>  In any of the candidates, you can always create a separate build process / watch'a for SASS / LESS styles, such as in the Create React App, but you need to somehow connect the resulting CSS to the application (you can import it directly into the Create React App).  In this case, Critical CSS and Hot Module Reloading, as well as Server-Side Rendering styles become your concern, which negates the advantages of non-custom solutions. </p><br><h2 id="integraciya-so-storonnimi-ui-bibliotekami">  Integration with third-party UI libraries </h2><br><p>  Obviously, using the best libraries for interfaces, we improve the look of the product, speed up its creation, especially if we are talking about things like Twitter Bootstrap or Material Design.  These libraries usually come bundled with CSS that needs to be included in the application in some way. </p><br><ul><li>  <strong>In Next.js,</strong> you can connect styles directly to <code>_document.js</code> (the main template), but then the style file should be in the <code>static</code> directory;  if you use preprocessors, then it is better to include CSS from under your other files with styles (well, connect them via custom <code>_document</code> and a collector or a custom Webpack config) </li><li>  <strong>Electrode</strong> allows you to import CSS directly;  it is also possible through a custom HTML template (but then it must again be included in the build);  or again custom webpack loader </li><li>  <strong>Create React App</strong> allows you to import CSS </li></ul><br><h2 id="critical-css--above-the-fold-css">  Critical CSS / Above The Fold CSS </h2><br><p>  Roughly speaking, certain styles can be loaded along with HTML, so users will never see the so-called.  flash non-stylized content (FOUC).  It is useful, but not critical at all.  modern networks are quite productive and the style table weighing up to 100KB is nothing at all. </p><br><ul><li>  <strong>Electrode</strong> has a special plugin </li><li>  <strong>Next.js</strong> uses CSS in JSX so CSS is always included directly in the component. </li><li>  For the rest, you can make something of your own. </li></ul><br><h2 id="podderzhka-skinov">  Skins support </h2><br><p>  This is a rare case that is far from necessary for everyone, but many applications support different skins for different brands or just for the convenience of users (well, for example, a dark or light color scheme). </p><br><ul><li>  <strong>Next.js</strong> uses CSS in JS, so you can use the JS approach, make a function for CSS and type styles in variables, and receive the variables themselves as arguments </li><li>  <strong>Electrode</strong> uses CSS modules that have no variables. </li><li>  If you use CSS preprocessors with a kind of build procedure, then basic styles can be filled with variables, create several input points with different overrayd variables and include one of the points in the application (Twitter Bootstrap works this way, for example) </li></ul><br><h2 id="ekosistema-i-soobschestvo">  Ecosystem and community </h2><br><p>  Living inside an ecosystem, well-designed and documented, is always more pleasant than sorting out a bunch of small libraries: less trouble with dependencies, the ability to follow the direction given by the authors, lots of examples.  I remember the phrase that if you do not use the framework, then in the end you will write it yourself. </p><br><ul><li>  <strong>Electrode has</strong> ~ 500 stars on Github, the active community responds to tickets and questions on StackOverflow.  <a href="http://www.electrode.io/docs/get_started.html">The documentation is</a> messy and not very clear, with terribly bloated examples, but if you look at it, you can live. </li><li>  <strong>Next.js has</strong> ~ 9000 stars on Github, a super fast response to pull requests and tickets.  There is <a href="">documentation for simple and complex cases</a> , a <a href="https://github.com/zeit/next.js/tree/master/examples">huge number of examples</a> for all occasions. </li><li>  The <strong>Create React App</strong> ~ 21.500 stars on Github, this is the largest community.  The framework itself is so small and primitive that there is nothing special to document there, but the authors managed to write a bunch of <a href="">examples and recipes</a> . </li><li>  In the <strong>custom</strong> application, you are by yourself, all the examples, documentation, communities are scattered all over the Internet, you need to search for everything, choose the most intelligent solutions, and you get the only knowledge carrier, which is very bad for a company.  You will also have to write the documentation yourself. </li></ul><br><h2 id="testy">  Tests </h2><br><p>  I think no one will argue that in the modern world there are nowhere without tests. </p><br><ul><li>  <strong>Electrode</strong> uses PhantomJS for honest browser tests and individual server tests; this is the best coverage possible. </li><li>  <strong>Create React App</strong> comes with the Jest, it is good, but it does not start in the browser, so the poet is not quite honest coverage </li><li>  For <strong>Next.js</strong> and <strong>custom</strong> we do everything ourselves </li></ul><br><h2 id="boilerplate-konfiguraciya-nachalnaya-stoimost">  Boilerplate configuration, initial cost </h2><br><p>  Since we plan to do many projects based on one standard, we want to have as little hassle as possible with the initial setup and launch of our solutions.  For this, it is desirable that initialization fetches as few files and configs as possible. </p><br><ul><li>  <strong>Next.js</strong> and <strong>Create React App</strong> go without any configuration at all, just put the necessary files in accordance with the agreement and everything will magically work </li><li>  <strong>Electrode</strong> comes bundled with a generator for Yeoman that produces just a monstrously huge mountain of files, you have to spend time getting used to what's where it lies.  In this mountain, literally everything: configs, server code, code for server pages, client code, and until I found a way to optimize it at least somehow. </li><li>  <strong>A custom</strong> will always have a certain amount of code that cannot be disposed of.  But if you are doing dozens of projects, then at some point you must form some repeating patterns that can be moved into an abstraction.  And maybe even open-sorsnut;).  Honestly, the same can be done with <strong>Electrode</strong> , and it seems to me that they themselves will come to this. </li></ul><br><h2 id="krivaya-obucheniya-v-nachale-i-v-slozhnyh-sluchayah-slozhnost-kastomizacii-podderzhka-v-buduschem">  Learning curve at the beginning and in difficult cases, complexity of customization, support in the future </h2><br><p>  Suppose you work with an application as part of a team, in which case you will have to train your colleagues in some way.  Documentation and fixed patterns are a good basis for easy sharing of knowledge within and between teams. </p><br><p>  The ability to customize anything should also be present, because  we live in real life and anything in it can change at any time, but the requirements are not eternal.  And I really would not want to rest against some kind of rigid limitation of the framework. </p><br><ul><li>  <strong>The Create React App</strong> is the easiest to understand at the beginning, but it generally does not provide any means for modification.  Its source code is rather harsh, so if you plan to make an ‚Äúeject‚Äù (that is, take out all the scripts for the build, all configs and other guts to the outside), then it‚Äôs better to give up this direction in favor of the custom.  The package includes linter.  Since there is no API at all, and the number of agreements is minimal, upgrades will be painless. </li><li>  <strong>Next.js</strong> takes care of some aspects, understanding how it does it will take a little time.  Most simple cases have examples, but when something complicated or nonstandard is required, it is easier to shoot yourself, the code turns to mush and is supplemented by a large number of shaky third-party solutions.  By and large, any step to the side threatens with pain.  Linter is not included.  A similar picture with an upgrade, API is minimal, agreements are easy to follow. </li><li>  Since <strong>Electrode is</strong> heavily based on the configuration and most of the scripts are open from the very beginning, this causes a slight shock at the beginning, but as soon as you figure it all out, life will quickly become easier.  This way you will be better prepared for more complex cases.  Unfortunately, a decent amount of witchcraft still occurs under the hood, so it will never be easy at all.  The kit includes a perfectly customized ESLint.  Here with the upgrade all the worse.  Since the number of guts sticking out is rather large, the chance of breaking something in the future is also great. </li><li>  In <strong>custom,</strong> you are on your own.  As you do, so be it.  You are looking for the best practices yourself, you choose solutions yourself, and so from the beginning to the last day of the project.  With agreyd everything is very bad at all, anything can break down at any time. </li></ul><br><h2 id="internacionalizaciya">  Internationalization </h2><br><p>  For convenience, lines with localization should be in a standard format, with substitutions and declensions.  It is desirable in one that can be easily perceived by translation companies, because it is they who will be the most busy with them. </p><br><p>  None of the frameworks provided provide any means for translation.  However, they are easy to add.  After searching, I found out that the centralized asynchronous loader works best, in which case each language becomes a separate chunk.  This can be achieved by creating a function that takes a language as a parameter and returns asynchronously loaded strings for the language.  Something like <code>const loadStrings(lang) =&gt; import('./strings/'+lang)</code> (this construction is unlikely to work right away, but the essence should be clear, you can create Webpack Context'ov before it to guarantee a bunch of 1 language = 1 chunk. </p><br><p>  Libraries: <a href="https://formatjs.io/">FormatJS</a> and <a href="https://github.com/format-message/format-message">Format Message</a> (and that and that works with the so-called <a href="http://userguide.icu-project.org/formatparse/messages">ICU Format</a> ). </p><br><p>  It is best to organize strings by tokens, i.e.  <code>{TOKEN: {en: 'English', fr: 'French'}}</code> , this is easier for developers and translators.  The reverse approach, where the "as if token" is the English string, which did not justify itself. </p><br><h2 id="sravnenie">  Comparison </h2><br><table><thead><tr><th>  Discipline \ Name </th><th>  React App </th><th>  Electrode </th><th>  Next.js </th><th>  Custom </th></tr></thead><tbody><tr><td>  <strong>Dynamic routes</strong> </td><td>  Yes </td><td>  Yes </td><td>  DIY </td><td>  Yes </td></tr><tr><td>  <strong>Server rendering</strong> </td><td>  not </td><td>  Yes </td><td>  Yes </td><td>  DIY </td></tr><tr><td>  <strong>SSR optimization</strong> </td><td>  no ssr </td><td>  Yes </td><td>  not </td><td>  DIY </td></tr><tr><td>  <strong>CSS</strong> </td><td>  Yes </td><td>  Yes </td><td>  nightmare </td><td>  DIY easy </td></tr><tr><td>  <strong>Preprocessors</strong> </td><td>  nightmare </td><td>  nightmare </td><td>  nightmare </td><td>  DIY easy </td></tr><tr><td>  <strong>Critical CSS</strong> </td><td>  DIY </td><td>  plugin </td><td>  not </td><td>  DIY </td></tr><tr><td>  <strong>Community</strong> </td><td>  great </td><td>  there is </td><td>  there is </td><td>  you're on your own </td></tr><tr><td>  <strong>Tests</strong> </td><td>  jest </td><td>  phantom </td><td>  DIY </td><td>  DIY </td></tr><tr><td>  <strong>Base code</strong> </td><td>  zero </td><td>  lot </td><td>  zero </td><td>  lots of </td></tr><tr><td>  <strong>Configuration</strong> </td><td>  zero </td><td>  lot </td><td>  zero </td><td>  lots of </td></tr><tr><td>  <strong>Documentation</strong> </td><td>  the good </td><td>  so-so </td><td>  in stock </td><td>  scattered </td></tr><tr><td>  <strong>Simple training</strong> </td><td>  sat down and went </td><td>  acceptable </td><td>  easy </td><td>  nightmare </td></tr><tr><td>  <strong>Further training</strong> </td><td>  easier to die </td><td>  heavy </td><td>  heavy </td><td>  nightmare </td></tr><tr><td>  <strong>Server engine</strong> </td><td>  nginx </td><td>  node </td><td>  node </td><td>  node </td></tr><tr><td>  <strong>Customization</strong> </td><td>  eject and death </td><td>  acceptable </td><td>  nightmare </td><td>  anything </td></tr><tr><td>  <strong>Initial installation</strong> </td><td>  easy </td><td>  verbally </td><td>  easy </td><td>  nightmare </td></tr><tr><td>  <strong>Predictability</strong> </td><td>  the good </td><td>  so-so </td><td>  bad </td><td>  nightmare </td></tr><tr><td>  <strong>Upgrades</strong> </td><td>  chic </td><td>  not bad </td><td>  so-so </td><td>  nightmare </td></tr></tbody></table><br><h1 id="verdikt">  Verdict </h1><br><p>  If you are not going to engage in server rendering (you do not sell anything, the application is not indexed by Google, and generally private), then you can safely look in the direction of the <strong>Create React App</strong> , it is the most popular and simple.  It can even customize a little.  Only do not eject, it is not worth it. </p><br><p>  If server rendering is needed, and you are ready to put up with some restrictions, then choose <strong>Electrode</strong> (as a condition, you also should not be intimidated by a large number of files, verbose and configurations).  This is also a good choice if you are worried about performance. </p><br><p>  If you are ready to put up with even greater restrictions and love minimalism, then look at <strong>Next.js.</strong> </p><br><p>  And finally, there is always a <strong>custom</strong> .  Fortunately, libraries like <a href="https://github.com/andywer/webpack-blocks">Webpack Blocks</a> , <a href="https://github.com/kirill-konshin/create-react-server">Create React Server</a> , <a href="https://reacttraining.com/react-router">React Router</a> , <a href="http://redux.js.org/">Redux,</a> and others make life much easier.  The only problem is the exchange of knowledge and the development of processes for the rapid creation of applications without repeating the same code every time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323458/">https://habr.com/ru/post/323458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323446/index.html">We are looking for speakers at Go meetup April 14</a></li>
<li><a href="../323448/index.html">Features of the development of mobile MMO RTS. Part 4</a></li>
<li><a href="../323450/index.html">Localization of indie games at Unity: hidden costs</a></li>
<li><a href="../323452/index.html">Visual Studio 2017 and new features of Microsoft tools</a></li>
<li><a href="../323456/index.html">Women who have changed business</a></li>
<li><a href="../323460/index.html">How to return to coders when over forty</a></li>
<li><a href="../323462/index.html">Creating a blog engine with Phoenix and Elixir / Part 8. Finish with comments</a></li>
<li><a href="../323466/index.html">Protocol features in IO games</a></li>
<li><a href="../323468/index.html">How we ranked nine million developers on Github</a></li>
<li><a href="../323470/index.html">Why are all virtual assistants women?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>