<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional programming in Swift. Start</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface translator. 
 Celebrating the end of 2014, the famous Swift group SLUG from San Francisco selected the 5 most popular Swift videos for 2014 fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional programming in Swift. Start</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cf5/7f7/f77/cf57f7f77cce4328921e4e2112a4d980.png"><br><br><h2>  Preface translator. </h2><br>  Celebrating the end of 2014, the famous Swift group <a href="http://www.meetup.com/swift-language">SLUG</a> from San Francisco selected the <a href="http://realm.io/news/top-5-swift-videos-of-2014/">5 most popular Swift videos for 2014</a> from meetings organized by it.  And among them was the performance of Chris Eidhof "Functional programming in Swift". <br>  Now <a href="http://www.eidhof.nl/">Chris Eidhof</a> is a famous person in the Swift community, he is the author of the recently published book <a href="http://www.objc.io/books/">Functional programming in Swift</a> , one of the founders of the <a href="http://www.objc.io/">objc.io</a> magazine, the organizer of the conference <a href="http://2014.funswiftconf.com/">Functional Swift Conference</a> , which took place on December 6th in Brooklyn and the future <a href="http://www.uikonf.com/">UIKonf</a> conference . <br>  But I opened it when he, one of the first, published a <a href="http://chris.eidhof.nl/posts/json-parsing-in-swift.html">very simple elegant article</a> about the effectiveness of the functional approach in Swift to JSON parsing. <br>  In this article, there are no inaccessible concepts, no mystical mathematical ‚Äúchimeras‚Äù of the type ‚ÄúMonad, Functor, Applicative functor‚Äù, on which Haskell programmers swear to the rest of the world, rolling their eyes. <br>  There are no such innovations Swift, as generics (generics) and "type inference" (type inference). <br>  If you want to smoothly move into functional programming in Swift, then you should read his article <a href="http://chris.eidhof.nl/posts/json-parsing-in-swift.html">‚ÄúParsing JSON in Swift‚Äù</a> and the performance on SLUG <a href="http://realm.io/news/functional-programming-swift-chris-eidhof/">‚ÄúFunctional Programming in Swift‚Äù</a> . <br><a name="habracut"></a><br>  In order to facilitate this task, I will present the translation of the article and that part of the Chris Eidhof speech, which concerns <code>JSON</code> parsing and which collected the most questions on this talk. <br>  By the way, you will certainly come to the study of ‚ÄúMonads, Functors, Applicative Functors‚Äù and, apparently, they will form the functional future of <i>Swift</i> , but this will happen later, but for now 2 user operators and their ingenious combination give us the desired result. <br><br>  So Chris took the example of <code>JSON</code> data from <a href="http://inessential.com/2014/06/17/c_in_sheeps_clothing">Brent</a> and <a href="http://owensd.io/2014/06/21/json-parsing-take-two.html">David‚Äôs</a> skeptical colleagues: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="objectivec hljs">var json : [String: AnyObject] = [ <span class="hljs-string"><span class="hljs-string">"stat"</span></span>: <span class="hljs-string"><span class="hljs-string">"ok"</span></span>, <span class="hljs-string"><span class="hljs-string">"blogs"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"blog"</span></span>: [ [ <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">73</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Bloxus test"</span></span>, <span class="hljs-string"><span class="hljs-string">"needspassword"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://remote.bloxus.com/"</span></span> ], [ <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">74</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Manila Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"needspassword"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://flickrtest1.userland.com/"</span></span> ] ] ] ]</code> </pre><br><br>  and set the task to convert this <code>JSON</code> data in a typed and secure way into an array of <i>Swift</i> structures: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Blog { let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: Int let name: String let needsPassword : Bool let url: <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> }</code> </pre><br><br><h2>  Translation of the article ‚ÄúParsing JSON data in Swift‚Äù. </h2><br>  First, I will show the final parsing functions that contain two operators: &gt;&gt; = and &lt;*&gt;.  (Translator‚Äôs note. In the <a href="https://gist.github.com/chriseidhof/4c071de50461a802874e">Github</a> code, instead of the &gt;&gt; = operator, the &gt;&gt;&gt; = operator is used, since the &gt;&gt; = operator in Swift is already taken and is used for a broken offset.) <br>  These operators look a bit strange in <i>Swift</i> , but using them to completely <code>JSON</code> structure becomes very simple. <br>  The rest of the article will be devoted to the description of the library code. <br>  The following parsing works in such a way that if the <code>JSON</code> structure is incorrect (for example, the <code>name</code> missing or the <code>id</code> is not an integer), then the result is <code>nil</code> . <br>  In our case, neither <code>reflection</code> nor <code>KVO</code> , we just have a couple of simple functions and some smart way to combine them: <br><br><pre> <code class="objectivec hljs">func parseBlog(blog: AnyObject) -&gt; Blog? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asDict(blog) &gt;&gt;= { mkBlog &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) &lt;*&gt; string($<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) &lt;*&gt; (string($<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span>) &gt;&gt;= toURL) } } let parsed : [Blog]? = dictionary(json, <span class="hljs-string"><span class="hljs-string">"blogs"</span></span>) &gt;&gt;= { array($<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"blog"</span></span>) &gt;&gt;= { join($<span class="hljs-number"><span class="hljs-number">0.</span></span>map(parseBlog)) } }</code> </pre><br><br>  What does the above code do? <br>  Let's go through the most important features. <br>  Let's look at the function of the <code>dictionary</code> .  This function takes as input the <code>input: [String: AnyObject]</code> and a specific <code>key: Sting</code> , and tries to find in the original dictionary <code>input</code> by the key <code>key</code> also a dictionary, which will be the return value of the <code>Optional</code> : <br><br><pre> <code class="objectivec hljs">func dictionary(input: [String: AnyObject], key: String) -&gt; [String: AnyObject]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input[key] &gt;&gt;= { $<span class="hljs-number"><span class="hljs-number">0</span></span> as? [String:AnyObject] } }</code> </pre><br><br>  For example, in the above example of <code>JSON</code> data, we expect that the key <code>"blogs"</code> is a dictionary.  If the dictionary exists, then we return it, otherwise we return <code>nil</code> .  We can write similar functions for arrays ( <code>array</code> ), strings ( <code>strings</code> ) and integers ( <code>int</code> ) (here the signature is only for these types, and the full code is on <a href="https://gist.github.com/chriseidhof/4c071de50461a802874e">GitHub</a> ): <br><br><pre> <code class="objectivec hljs">func array(input: [String:AnyObject], key: String) -&gt; [AnyObject]? func string(input: [String:AnyObject], key: String) -&gt; String? func <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(input: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>:AnyObject], key: String) -&gt; Int?</code> </pre><br><br>  Now let's look at the outermost structure of our <code>JSON</code> data.  This is a dictionary that is present in the structure under the key <code>"blogs"</code> .  And under the key <code>"blog"</code> contains an array.  For such parsing we can write the following code: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let blogsDict = dictionary(parsedJSON, <span class="hljs-string"><span class="hljs-string">"blogs"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let blogsArray = array(blogsDict, <span class="hljs-string"><span class="hljs-string">"blog"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  -    } }</span></span></code> </pre><br><br>  Instead, we define the &gt;&gt; = operator, which takes an <code>Optional</code> value and applies the function <code>f</code> to it only if this <code>Optional</code> not <code>nil</code> .  This forces us to use the flatten ‚Äúleveling‚Äù function, which removes (‚Äúaligns‚Äù) the nested <code>Optional</code> and leaves the only <code>Optional</code> . <br><br><pre> <code class="objectivec hljs">infix operator &gt;&gt;= {} func &gt;&gt;= &lt;A,B&gt; (optional : A?, f : A -&gt; B?) -&gt; B? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flatten(optional.map(f)) } func flatten&lt;A&gt;(x: A??) -&gt; A? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let y = x { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  Another operator that will be used very intensively is the <code>&lt;*&gt;</code> operator.  To parse a single blog (Blog structure), we will have the following code: <br><br><pre> <code class="objectivec hljs">mkBlog &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dict,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) &lt;*&gt; string(dict,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(dict,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) &lt;*&gt; (string(dict, <span class="hljs-string"><span class="hljs-string">"url"</span></span>) &gt;&gt;= toURL</code> </pre>  ) <br><br>  You can read it as a function call, which becomes executable only if all <code>Optional</code> values ‚Äã‚Äãare non- <code>nil</code> : <br><br><pre> <code class="objectivec hljs">mkBlog(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dict,<span class="hljs-string"><span class="hljs-string">"id"</span></span>), string(dict,<span class="hljs-string"><span class="hljs-string">"name"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(dict,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>), (string(dict, <span class="hljs-string"><span class="hljs-string">"url"</span></span>) &gt;&gt;= toURL))</code> </pre><br><br>  Let's look at the definition of the <code>&lt;*&gt;</code> operator.  It combines two <code>Optional</code> values: it takes a function as the left operand, and a parameter of this function as the right operand.  He checks that both operands are not <code>nil</code> , and only then he applies the function. <br><br><pre> <code class="objectivec hljs">infix operator &lt;*&gt; { associativity left precedence <span class="hljs-number"><span class="hljs-number">150</span></span> } func &lt;*&gt;&lt;A, B&gt;(l: (A -&gt; B)?, r: A?) -&gt; B? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let l1 = l { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let r1 = r { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l1(r1) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  What is <code>mkBlog</code> ?  This is the curried function (curried function), which ‚Äúwraps‚Äù our initializer. <br>  First, we create a type function <code>(Int, String, Bool, NSURL) -&gt; Blog</code> . <br>  Then the <code>curry</code> function converts it to a function of type <code>Int -&gt; String -&gt; Bool -&gt; NSURL -&gt; Blog</code> : <br><br><pre> <code class="objectivec hljs">let mkBlog = curry {<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name, needsPassword, url <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name: name, needsPassword: needsPassword, url: url) }</code> </pre><br><br>  This is necessary so that we can use <code>mkBlog</code> together with the <code>&lt;*&gt;</code> operator. <br>  Let's look at the first line of code: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// mkBlog : Int -&gt; String -&gt; Bool -&gt; NSURL -&gt; Blog // int(dict,"id") : Int? let step1 = mkBlog &lt;*&gt; int(dict,"id")</span></span></code> </pre><br><br>  We see that the combination of <code>mkBlog</code> and <code>int (dict,"id")</code> using the <code>&lt;*&gt;</code> operator gives us a new function of the type <code>(String -&gt; Bool -&gt; NSURL -&gt; Blog)?</code>  .  And if we combine it with a string: <br><br><pre> <code class="objectivec hljs">let step2 = step1 &lt;*&gt; string(dict,<span class="hljs-string"><span class="hljs-string">"name"</span></span>)</code> </pre><br><br>  We get the function type <code>(Bool -&gt; NSURL -&gt; Blog)?</code>  .  And if we continue to do this, then we end up with the <code>Optional</code> value of <code>Blog?</code>  . <br><br>  I hope you understand how all these pieces fit together.  By creating a small number of helper functions and operators, we can make strongly typed <code>JSON</code> parsing really very simple.  Instead of <code>Optional</code> , you could also use another type, which includes errors (errors), but this is a topic for another post. <br><br>  We write about all these things in our book in more detail.  If you are interested, you can now access the book <a href="http://www.objc.io/books/">Functional Programming in Swift</a> . <br><br><h2>  Translator's note. </h2><br>  The code for Chris Eidhof <a href="http://chris.eidhof.nl/posts/json-parsing-in-swift.html">'s</a> article <a href="http://chris.eidhof.nl/posts/json-parsing-in-swift.html">‚ÄúJSON parsing in Swift‚Äù</a> with an improved print feature on the Playground on <a href="https://gist.github.com/BestKora/d4aac272917c72ce8b44">Github</a> . <br>  Although Chris said that it‚Äôs understandable how this all interacts together, in fact it‚Äôs not quite so, and that‚Äôs why I cite the translation of his <a href="http://realm.io/news/functional-programming-swift-chris-eidhof/">speech at the SLUG meeting</a> , where he shows in detail how to arrive at the desired result. <br><br><h2>  Translation of the speech "Functional programming in Swift". </h2><br>  This is an excerpt from the <a href="http://www.eidhof.nl/">Chris Eidhof talk</a> at a <a href="http://realm.io/news/functional-programming-swift-chris-eidhof/">meeting</a> in San Francisco in which he spoke about functional programming possibilities in <i>Swift</i> , but not as a substitute for object-oriented programming (OOP), but as an additional application development tool. <br>  I provide only the translation of the part that relates to <code>JSON</code> parsing, and answers to questions. <br><br><h3>  Why functional programming? </h3><br>  There are many ways to solve problems besides object-oriented programming (OOP).  You already know how to solve problems with OOP, but now <i>Swift also</i> offers very easy and convenient functional programming.  In fact, some tasks are even easier to solve using functional programming! <br><br><h3>  One of these tasks is parsing JSON. </h3><br>  This is a conversion of untypical <code>JSON</code> dictionaries into regular, typed dictionaries. <br>  <code>JSON</code> data are considered and the same task is set to convert them into an array of blogs <code>[Blog]</code> , as in the above article. <br><br><h3>  First try </h3><br>  The first version of the <code>parseBlog</code> function returns <code>Blog</code> if the types of all components are correct. <br>  Nested <code>if</code> continue to run for each key and the corresponding type only if the conditions are met. <br>  If all the conditions are met, we can construct the <code>Blog</code> value with the correct types and values ‚Äã‚Äãfrom the <code>Optionals</code> values. <br><br><pre> <code class="objectivec hljs">func parseBlog(blogDict: [String:AnyObject]) -&gt; Blog? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = blogDict[<span class="hljs-string"><span class="hljs-string">"id"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let name = blogDict[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let needsPassword = blogDict[<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let url = blogDict[<span class="hljs-string"><span class="hljs-string">"url"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>.integerValue, name: name, needsPassword: needsPassword.boolValue, url: <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string: url) ) } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  The first change is to create a <code>string</code> function that checks whether the type is <code>NSString</code> , because in our case we used it twice.  This function takes a dictionary, searches for the <code>key</code> and returns the corresponding value only if the key matches the string.  Otherwise, it returns <code>nil</code> . <br><br><pre> <code class="objectivec hljs">func string(input: [String:AnyObject], key: String) -&gt; String? { let result = input[key] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result as String? }</code> </pre><br><br><h3>  Second try </h3><br>  The second version now includes the above <code>string</code> function, and looks like this: <br><br><pre> <code class="objectivec hljs">func parseBlog(blogDict: [String:AnyObject]) -&gt; Blog? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = blogDict[<span class="hljs-string"><span class="hljs-string">"id"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let name = string(blogDict, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let needsPassword = blogDict[<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let url = string(blogDict, <span class="hljs-string"><span class="hljs-string">"url"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>.integerValue, name: name, needsPassword: needsPassword.boolValue, url: <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string: url) ) } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  Other changes in the code are due to the fact that for <code>numbers</code> we will create a function similar to the <code>string</code> function.  This function searches for a <code>number</code> and makes a cast, if it exists.  We can create similar functions for the <code>int</code> and <code>bool</code> types.  For <code>Optionals</code> we can also use <code>map</code> , which is executed only if the value exists. <br><br><pre> <code class="objectivec hljs">func number(input: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>:AnyObject], key: String) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? { let result = input[key] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result as <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>? } func <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(input: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>:AnyObject], key: String) -&gt; Int? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number(input,key).map { $<span class="hljs-number"><span class="hljs-number">0.</span></span>integerValue } } func <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(input: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>:AnyObject], key: String) -&gt; Bool? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number(input,key).map { $<span class="hljs-number"><span class="hljs-number">0.</span></span>boolValue } }</code> </pre><br><br><h3>  Third attempt </h3><br>  The code that we refactorized now looks a bit more declarative: <br><br><pre> <code class="objectivec hljs">func parseBlog(blogDict: [String:AnyObject]) -&gt; Blog? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(blogDict, <span class="hljs-string"><span class="hljs-string">"id"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let name = string(blogDict, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let needsPassword = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(blogDict, <span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let url = string(blogDict, <span class="hljs-string"><span class="hljs-string">"url"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name: name, needsPassword: needsPassword, url: <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string: url) ) } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  We can continue to improve our code, trying to get rid of nested <code>if</code> .  Our <code>flatten</code> function checks whether all <code>Optionals</code> have values, and if so, this ‚Äúlarge‚Äù <code>Optional</code> as a tuple. <br><br><pre> <code class="objectivec hljs">func flatten&lt;A,B,C,D&gt;(oa: A?,ob: B?,oc: C?,od: D?) -&gt; (A,B,C,D)? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let a = oa { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let b = ob { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let c = oc { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let d = od { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a,b,c,d) } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br><h3>  Fourth attempt </h3><br>  So, we calculate our 4 variables, ‚Äúalign‚Äù them with the help of the <code>flatten</code> function <code>flatten</code> and if they are all non- <code>nil</code> , return the <code>Blog</code> . <br><br><pre> <code class="objectivec hljs">func parseBlog(blogData: [String:AnyObject]) -&gt; Blog? { let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) let name = string(blogData,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) let needsPassword = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) let url = string(blogData,<span class="hljs-string"><span class="hljs-string">"url"</span></span>).map { <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:$<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name, needsPassword, url) = flatten(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name, needsPassword, url) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name: name, needsPassword: needsPassword, url: url) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  We can continue to work on our code, trying to get rid of the last <code>if</code> .  This will require the functions <code>A,B,C,D -&gt; R</code> , which converts the arguments <code>A,B,C,D</code> to <code>R</code> , as well as the tuple <code>(A, B, C, D)</code> , and if they are not both <code>nil</code> , then the function is applied to the tuple. <br><br><pre> <code class="objectivec hljs">func apply&lt;A, B, C, D, R&gt;(l: ((A,B,C,D) -&gt; R)?, r: (A,B,C,D)?) -&gt; R? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let l1 = l { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let r1 = r { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l1(r1) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br><h3>  Fifth attempt </h3><br>  Now our code looks like this: <br><br><pre> <code class="objectivec hljs">func parseBlog(blogData: [String:AnyObject]) -&gt; Blog? { let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) let name = string(blogData,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) let needsPassword = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) let url = string(blogData,<span class="hljs-string"><span class="hljs-string">"url"</span></span>).map { <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:$<span class="hljs-number"><span class="hljs-number">0</span></span>) } let makeBlog = { Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, name: $<span class="hljs-number"><span class="hljs-number">1</span></span>, needsPassword: $<span class="hljs-number"><span class="hljs-number">2</span></span>, url: $<span class="hljs-number"><span class="hljs-number">3</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(makeBlog, flatten(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name, needsPassword, url)) }</code> </pre><br><br>  We can call the function <code>apply</code> with an argument that is our ‚Äúaligned‚Äù structure.  But to continue refactoring the code, you need to make the <code>apply</code> function more generalized, and also to perform currying. <br><br><pre> <code class="objectivec hljs">func apply&lt;A, R&gt;(l: (A -&gt; R)?, r: A?) -&gt; R? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let l1 = l { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let r1 = r { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l1(r1) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  It may be difficult at first sight to understand <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2580">currying</a> as a concept.  It returns nested functions that can be very useful in functional programming.  <i>Swift</i> allows us to omit the parentheses when defining a type for nested functions.  By calling the <code>apply</code> function again, we can make the code more compact and finally get our <code>Blog</code> . <br><br><pre> <code class="objectivec hljs">func curry&lt;A,B,C,D,R&gt;(f: (A,B,C,D) -&gt; R) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f(a,b,c,d) } } } } } <span class="hljs-comment"><span class="hljs-comment">//  : (Int, String, Bool, NSURL) -&gt; Blog let blog = { Blog(id: $0, name: $1, needsPassword: $2, url: $3) } //  : Int -&gt; (String -&gt; (Bool -&gt; (NSURL -&gt; Blog))) let makeBlog = curry(blog) // : Int -&gt; String -&gt; Bool -&gt; NSURL -&gt; Blog let makeBlog = curry(blog) // : Int? let id = int(blogData, "id") //  : (String -&gt; Bool -&gt; NSURL -&gt; Blog)? let step1 = apply(makeBlog,id) //  : String? let name = string(blogData,"name") //  : (Bool -&gt; NSURL -&gt; Blog)? let step2 = apply(step1,name)</span></span></code> </pre><br><br><h3>  Sixth try </h3><br>  Now, after simplifying the <code>apply</code> function and after currying, our code has a lot of calls to the <code>apply</code> function. <br><br><pre> <code class="objectivec hljs">func parse(blogData: [String:AnyObject]) -&gt; Blog? { let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) let name = string(blogData,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) let needsPassword = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) let url = string(blogData,<span class="hljs-string"><span class="hljs-string">"url"</span></span>).map { <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:$<span class="hljs-number"><span class="hljs-number">0</span></span>) } let makeBlog = curry { Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, name: $<span class="hljs-number"><span class="hljs-number">1</span></span>, needsPassword: $<span class="hljs-number"><span class="hljs-number">2</span></span>, url: $<span class="hljs-number"><span class="hljs-number">3</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(apply(apply(apply(makeBlog, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>), name), needsPassword), url) }</code> </pre><br>  We can define one more operator, <code>&lt;*&gt;</code> .  This is the same as the <code>apply</code> function. <br><br><pre> <code class="objectivec hljs">infix operator &lt;*&gt; { associativity left precedence <span class="hljs-number"><span class="hljs-number">150</span></span> } func &lt;*&gt;&lt;A, B&gt;(l: (A -&gt; B)?, r: A?) -&gt; B? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let l1 = l { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let r1 = r { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l1(r1) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br><h3>  Seventh attempt ... already close to goal </h3><br>  Now our code is almost complete.  We replaced a set of calls to the <code>apply</code> function with our <code>&lt;*&gt;</code> operator. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    return apply(apply(apply(apply(makeBlog, id), name), needsPassword), url) //  return makeBlog &lt;*&gt; id &lt;*&gt; name &lt;*&gt; needsPassword &lt;*&gt; url }</span></span></code> </pre><br><br><h3>  Eighth (and last!) Attempt. </h3><br>  All intermediate offers and designs <code>if lets</code> removed.  All types are correct, but if we randomly specify other types, the compiler will ‚Äúcomplain‚Äù.  The final version of our code looks like this: <br><br><pre> <code class="objectivec hljs">func parse(blogData: [String:AnyObject]) -&gt; Blog? { let makeBlog = curry { Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, name: $<span class="hljs-number"><span class="hljs-number">1</span></span>, needsPassword: $<span class="hljs-number"><span class="hljs-number">2</span></span>, url: $<span class="hljs-number"><span class="hljs-number">3</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeBlog &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"id"</span></span>) &lt;*&gt; string(blogData,<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &lt;*&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(blogData,<span class="hljs-string"><span class="hljs-string">"needspassword"</span></span>) &lt;*&gt; string(blogData,<span class="hljs-string"><span class="hljs-string">"url"</span></span>).map { <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:$<span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre><br><br><h3>  Questions and answers </h3><br><br>  <b>Question</b> : Your currying is very limited, is there a way to write a more generalized currying? <br>  <b>Chris</b> : In some programming languages, this is present by default.  As far as I know, you cannot write <code>curry</code> by default, but you can write these <code>curry</code> functions with a certain number of arguments, and the compiler will choose one of them for you.  Perhaps in the future it will be added to <i>Swift</i> . <br><br>  <b>Q</b> : Is there any support for tail recursion optimization (tail-call optimization - TCO)? <br>  <b>Chris</b> : I don't think so.  When I performed many recursive calls, I had many crashes.  But the Swift development team knows these problems and will solve them in the future. <br><br>  <b>Question</b> : In your slides a lot of custom (custom) operators.  Can you say a little about how this affects new developers in the team? <br>  <b>Chris:</b> Awful.  But it all depends on the context - if you come from Objective-C, and just start using Swift, I would not recommend doing it.  I would also say if you work in a big company.  If you have people with functional programming languages, these operators are more familiar to them. <br><br>  <b>Question</b> : If you come from the world of OOP (object-oriented programming), then the goal is a sensible code.  How would you organize your code in functional programming? <br>  <b>Chris</b> : At the topmost level, it's almost the same.  At a lower level, I find it useful to use a lot of helper functions.  You see a lot of support functions in my code, which makes working with code more convenient.  This is a bit like the UNIX philosophy, in which you have smaller functions that can be combined with each other.  In the beginning, it is a bit confusing, because you have to rebuild your thoughts. <br><br>  <b>Question</b> : In your book, you talk about processing collections and such things as the <code>map</code> and <code>reduce</code> functions? <br>  <b>Chris</b> : Of course.  When you start to get acquainted with functional programming, the first thing you learn is these functions.  You can <code>map</code> everything, even arrays and <code>Optionals</code> , and, of course, you have to master it. <br><br>  <b>Question</b> : What can you say about <i>Swift</i> in comparison with other programming languages ‚Äã‚Äãthat you used? <br>  <b>Chris</b> : I was on a walking tour of Poland, and was sitting in a mountain hut when I updated Twitter, found out that WWDC was under way.  When they submitted Swift, I was in seventh heaven and immediately downloaded the eBook.  Now we can do all these really cool functional things, but if we consider Swift as a functional programming language, then there really is not a lot of possibilities.  But what I really love about Swift is that you can use functional programming, and at the same time have access to everything Cocoa does.  It is very difficult for most programming languages ‚Äã‚Äãlike Haskell to interact with Cocoa, and this is a super powerful combination. <br><br>  <b>Question</b> : Are any efforts being made to create open for functional operators and functions, like the <a href="https://github.com/scalaz/scalaz">Scala Z</a> library for Scala? <br>  <b>Chris</b> : Yes, it's called <a href="https://github.com/typelift/swiftz">Swift Z.</a> <br><br>  <b>Question</b> : I noticed that there is no declaration of var variables in your presentation, could you comment on this? <br>  <b>Chris</b> : For me, functional programming is basically immutability, that is, when you create values ‚Äã‚Äãand do not modify them.  This makes it easier to develop code because you know for sure that your values ‚Äã‚Äãwill not change.  Another advantage of this is manifested in parallel computing, because it is very difficult to work with variable objects.  But there are some drawbacks - in classical programming languages ‚Äã‚Äãit is hard to write ‚Äúquick sort‚Äù (the so-called quicksort) in one line.  But if I use var, I try to isolate it inside a function, and from the outside, the function looks ‚Äúimmutable‚Äù (immutable). <br><br>  <b>Question</b> : Can you explain your considerations when you set the priority (precedence) for the custom operator &lt;*&gt;, but for other setting operators there was no priority? <br>  <b>Chris</b> : I was looking at the priority of operators in Haskell, and was thinking about how to transfer this to <i>Swift</i> to improve its performance.  I also looked at the priorities for normal <i>Swift</i> operators and also had it in mind when setting the priorities of the operators. <br><br>  <b>Question</b> : Do you think these decisions are scaled, given the learning curves of some organizations? <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : I would say that you should work with the best possible solutions. It is not either / or, you can take some functional programming features and then slowly begin to embed them in your programming style. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Have you noticed some changes in the consumption of "memory" or other landmarks when using functional programming? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : I think that if you use ‚Äúmutable‚Äù data, the use of ‚Äúmemory‚Äù will be better. With a lot of constants, you use more ‚Äúmemory‚Äù and CPU, but you can win a lot in a different way. Your code may be faster and you can optimize execution in another way. For example, when used </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twice for an array. If this</font></font><code>pure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformations, then you can combine the two </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into one </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and then iterate over the array once. This will be very hard to write optimally in programming languages ‚Äã‚Äãlike C. Clarity is a huge gain, and, besides, I have never experienced performance problems. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : One of the big benefits of functional programming is laziness, is there a way to do this in Swift? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Yes, there is the keyword "lazy", which can make some thing "lazy", but I don't know exactly all the details of that. You can also write generators (sequences) and sequences (sequences), although there is little documentation on this. I don‚Äôt know exactly how these things work in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As for currying, in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> although manually, you can make a curried function for creating a Blog structure without writing curry functions, but by placing each parameter in a makeBlog wrapper in a separate parenthesis:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func makeBlog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: Int)(name: String)(needsPassword: Int)(url:String) -&gt; Blog { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Blog(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, name: name, needsPassword: Bool(needsPassword), url: toURL(url)) }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code for that part of the speech that concerns JSON parsing can be found on </font></font><a href="https://gist.github.com/BestKora/7c434ddab5abd52fb786"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afterword translator. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris sticks to the idea that functional programming in Swift is better to learn in small pieces of code that does useful work, and therefore in its journal </font></font><a href="http://www.objc.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objc.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publishes such </font></font><a href="http://www.objc.io/snippets/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">small functional sketches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if it seems to you to be bland and too simple, that is, functional developments in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , from which they really ‚Äúblow the roof off‚Äù, that is, a kind of </font></font><a href="http://2014.funswiftconf.com/speakers/brandon.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúfunctional extreme‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But this may be the subject of the following articles.</font></font></div><p>Source: <a href="https://habr.com/ru/post/246965/">https://habr.com/ru/post/246965/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246955/index.html">FLProg and penguins</a></li>
<li><a href="../246957/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ140 (December 22 - 28, 2014)</a></li>
<li><a href="../246959/index.html">Understanding Flux, reactive architecture from facebook</a></li>
<li><a href="../246961/index.html">Really transparent WCF usage</a></li>
<li><a href="../246963/index.html">About the diagonal of the square</a></li>
<li><a href="../246967/index.html">Happy New Year!</a></li>
<li><a href="../246969/index.html">When technology outpaces needs: how did they think about IT development in 1985</a></li>
<li><a href="../246971/index.html">Dirty tricks with macros C ++</a></li>
<li><a href="../246973/index.html">Hacker's guide to neural networks. Chapter 2: Machine Learning. We generalize SVM to a neural network.</a></li>
<li><a href="../246975/index.html">Assembler in 30 lines on Excel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>