<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Avito Picture Store History</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="But what if you are given the task of organizing the storage and distribution of static files? Surely many will think that everything is simple. And i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Avito Picture Store History</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/avito/blog/328778/"><img src="https://habrastorage.org/getpro/habr/post_images/90f/da3/e06/90fda3e0660219483f51835a5584eb00.png"></a> <br><br>  But what if you are given the task of organizing the storage and distribution of static files?  Surely many will think that everything is simple.  And if there are a billion, several hundred terabytes of such files and several billions of requests per day to them?  Also, many different systems will send files of different formats and sizes for storage.  This quest does not seem so simple.  Under the cut, the story of how we solved such a problem, what difficulties arose and how we overcame them. <br><br>  Avito has developed rapidly since the early days.  For example, the speed of downloading new images for ads has increased several times in the early years.  This required us at the initial stage to solve issues related to the architecture as quickly and efficiently as possible, in conditions of limited resources.  In addition, we have always preferred simple solutions that require few resources for support.  The principle of KISS (‚ÄúKeep it short and simple‚Äù) is still one of the values ‚Äã‚Äãof our company. <br><a name="habracut"></a><br><h2>  First decisions </h2><br>  The question of how to store and how to give pictures of ads, appeared immediately, as the ability to add photos to the ad, of course, is key for users - buyers want to see what they are buying. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At that time, Avito fit in less than 10 servers.  The first and fastest solution was to store image files in a directory tree on a single server and synchronize over the crown to the backup. <br><br>  The path to the file was determined based on the unique digital identifier of the images.  At first there were two levels of nesting with 100 directories on each. <br><br><img src="https://habrastorage.org/web/eae/daa/e29/eaedaae2906741eea1e9483313a0ac93.png" alt="image"><br><br>  Over time, the place on the server began to come to an end, and something had to be done about it.  This time we chose to use network storage mounted on multiple servers.  The network storage was previously provided to us by the data center itself as a service in a test mode, and according to our test measurements, at that time it worked satisfactorily.  But with the growth of the load, it began to slow down.  Optimization of storage by the data center did not help dramatically and was not always operational.  Our possibilities to influence how storage is optimized were limited and we could not be sure that the possibilities of such optimizations would not be exhausted sooner or later.  By that time, our server fleet increased significantly and began to be calculated in dozens.  An attempt was made to quickly raise distributed glusterfs.  However, it worked satisfactorily only under a small load.  As soon as they were taken out at full capacity, the cluster ‚Äúcollapsed‚Äù, or all requests to it ‚Äúhung‚Äù.  Attempts to tweak it have failed. <br><br>  We realized that we needed something else.  The requirements for a new storage system were identified: <br><br><ul><li>  as simple as possible </li><li>  built from simple and proven components </li><li>  not taking much support resources </li><li>  maximum possible and simple control over what is happening </li><li>  good potential for scaling </li><li>  very quick implementation and migration dates from the current solution </li><li>  some images are unavailable during server repair (servers were repaired to us more or less quickly) </li><li>  It is possible to lose a small part of the pictures in case of complete destruction of one of the servers.  I must say that during the entire existence of Avito, this has never happened before.  3 * Ugh. </li></ul><br><h2>  New scheme </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/899/cbe/c88/899cbec88b06f8e69a318d4ea85390ad.png"><br><br>  <i>In the image for simplicity, only four nodes on two servers are shown.</i> <br><br>  During the discussion came to this scheme.  Files will be stored in the same directory tree, but the top-level directories are distributed across a group of servers.  It must be said that by that time we had servers with the same disk configuration, the disks on which were ‚Äúidle‚Äù.  Files are sent all the same nginx.  On each server, IPs are raised that correspond to a specific top-level directory located on the server.  At that time, we didn‚Äôt think about balancing traffic, since the data center did it for us.  The logic of balancing was that, depending on the domain to which the request came (there were a total of 100 domains), send a request to an internal IP that was already on the correct server. <br><br>  The question arose of how the site code will upload pictures to the repository, if it is also distributed across different servers.  It was logical to use the same http protocol by which the file came to us from the user.  Began to look for what we can use as a service that will receive files on the server side, which stores files.  The eye fell on the nginx open module for file upload.  However, in the course of his study it turned out that the logic of his work does not fit into our scheme.  But this is open source, and we have programming experience in C. For a short time, in breaks between other tasks, the module was finalized and now, working as part of nginx, it received files and saved them in the correct directory.  Looking ahead, I will say that in the process of working in production a memory leak was revealed, which at first was treated by restarting at night, and then, when there was time, they found the cause and corrected it. <br><br><h2>  Loads grow </h2><br>  Over time, we began to use this storage not only for images, but also for other static files, flexibly adjusting with the help of nginx parameters affecting performance and access to files. <br>  As the number of requests and the amount of data increased, we faced (and sometimes foresaw in advance) a number of problems that, under conditions of high loads, required making quick and effective decisions. <br><br>  One of these problems was the balancing that the data center provided for us at the F5 Viprion load balancer.  We decided to remove it from the traffic processing path by allocating 100 external IPs (one for each node).  So we removed the bottleneck, accelerated data delivery and increased reliability. <br><br>  The number of files in one directory was increasing, which resulted in slowing down of components due to the increased time of reading the contents of directories.  In response, we added another level from 100 directories.  We received 100 ^ 3 = 1M directories for each storage node and increased overall speed. <br><br>  We have experimented a lot with optimal configuration of nginx and disk cache parameters.  In the picture that we observed, we had the impression that the disk cache does not give a full return from caching, and caching with nginx in tmpfs works better, but clearing its cache noticeably loads the system during peak hours.  First of all, we included the logging of nginx requests into a file and wrote our daemon, which late in the evening read this file, cleaned it, detected the most relevant files, and cleared the rest of the cache.  Thus, we have limited the clearing of the cache to the night period, when the load on the system is not great.  It worked quite successfully for a period, up to a certain level of load.  Building statistics and clearing the cache ceased to fit into the night interval; moreover, it was clear that disk space would come to an end in the near future. <br><br>  We decided to organize a second level of data storage, similar to the first, but with some differences: <br><br><ul><li>  50 times the size of the disk subsystem on each server;  however, the speed of the disks may be less. </li><li>  an order of magnitude fewer servers </li><li>  external access to files is possible only through proxying through the first level </li></ul><br>  This gave us the opportunity to: <br><br><ul><li>  more flexible caching options </li><li>  use cheaper storage equipment for the main part of the data </li><li>  even easier to scale the system in the future </li></ul><br>  However, this required some complication of the system configuration and code for downloading new files to the storage system. <br><br>  The diagram below shows how two storage nodes (00 and 01) can be placed on two storage levels using one server on the first level and one on the second.  It is clear that you can place a different number of nodes on the server, and the number of servers at each storage level can be from one to one hundred.  All nodes and servers in the diagram are not shown for simplification. <br><br><img src="https://habrastorage.org/web/cbb/8ee/03b/cbb8ee03b48e4ae0b0bea4f0d63248f8.png" alt="image"><br><br>  <i><font color="#999999">In the image, for simplicity, only two nodes on two servers are shown.</font></i> <br><br><h2>  Conclusion </h2><br>  What did we get in the end?  Static file storage system, which can be easily understood by a mid-level specialist, built on reliable, proven open elements, which, if necessary, can be replaced or modified with a small price.  In this case, the system can provide users with dozens of PB data per day and store hundreds of terabytes of data. <br><br>  Cons, too.  For example, the lack of data replication, complete protection from equipment failure.  And although initially, when designing the system, it was immediately determined and coordinated in accordance with the risk assessment, we have a set of additional tools that allow leveling these drawbacks (system backups, scripts for testing, restoring, synchronizing, moving, etc.) <br><br>  In the future plans to add the ability to flexibly configure replication for a part of the files, most likely through some delayed queue. <br><br>  I deliberately didn‚Äôt go into the details of implementation, the logic of the work (I don‚Äôt say anything at all), the nuances of the settings so as not to delay the article and bring the main idea: if you want to build a good strong system, then one of the right ways could be to use open proven products connected in a relatively simple and reliable scheme.  Normally do, it will be normal! </div><p>Source: <a href="https://habr.com/ru/post/328778/">https://habr.com/ru/post/328778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328768/index.html">Connecting to xxx.xxx.xx.xxx:443 ... failed: Unknown error or warned - so armed</a></li>
<li><a href="../328770/index.html">Configuring CryptoPro IPsec VPN with GOST Encryption</a></li>
<li><a href="../328772/index.html">Dummy Origin: we test work of CDN</a></li>
<li><a href="../328774/index.html">The book "DevOps Philosophy. IT Management Art</a></li>
<li><a href="../328776/index.html">Nature has no bad laws. Generation 5, or what will work after LTE?</a></li>
<li><a href="../328780/index.html">PDUG section on PHDays VII: how to develop applications that hackers do not hack</a></li>
<li><a href="../328782/index.html">[PHDays HackQuest 2017] Anonymizer: SSRF or what can be dangerous curl</a></li>
<li><a href="../328786/index.html">GitLab Values</a></li>
<li><a href="../328788/index.html">The best way to upload files to Ruby is with Shrine. Part 2. Loader</a></li>
<li><a href="../328790/index.html">Staff hunger is also not an aunt, or how to grow an IT specialist from a student</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>