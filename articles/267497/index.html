<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recipes for Android: How to make a delicious LayoutManager</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi habr! 

 We like to develop mobile applications that differ from their counterparts in both functions and user interface. Last time we talked about...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recipes for Android: How to make a delicious LayoutManager</h1><div class="post__text post__text-html js-mediator-article">  Hi habr! <br><br>  We like to develop mobile applications that differ from their counterparts in both functions and user interface.  <a href="http://habrahabr.ru/company/eastbanctech/blog/263397/">Last time</a> we talked about client-server interaction in one of our applications, and this time we will share the implementation of its UI features using the LayoutManager written from scratch.  We think that the article will be useful not only for novice android developers, but also for more advanced specialists. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/872/ce9/826/872ce98265b171e705cc2340ed9487ce.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Let's start with </h1><br>  If you are an android developer, then you probably already used RecyclerView, a powerful and incredibly customizable replacement for ListView and GridView.  One of the customization levels of RecyclerView is that it does not know anything about the location of the elements inside it.  This job has been delegated to its LayoutManager.  Google provided us with 3 standard managers: LinearLayoutManager for lists as in ListView, GridLayoutManager for tiles, grids or tables, and StaggeredGridLayoutManager for layout as in Google+.  For our application, it was necessary to implement a layout that did not fit into the framework of available layout managers, so we decided to try to write our own.  It turned out to create your LayoutManager like a drug.  Having once tried, it is already difficult to stop - it turned out to be so useful in solving non-standard layout tasks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0aa/df7/979/0aadf797930068c4cb20f5ff8abeffe5.gif" alt="image"><br><br>  So, the task.  In our educational application there will be articles of a very simple format: a picture, a title and a text.  We want to have a vertical list of articles, each card in which will occupy 75% of the screen height.  In addition to the vertical, there will be a horizontal list in which each article will be open to full screen.  The transition from vertical to horizontal mode will be animated by clicking on a card and using the back button - back to vertical.  And, for beauty, in the vertical mode, the lower card will scroll when scrolling with the zoom effect.  By the way, you can see our training project here: <a href="https://github.com/forceLain/AwesomeRecyclerView">https://github.com/forceLain/AwesomeRecyclerView</a> , it already has a fake DataProvider, which returns 5 non-realistic articles, all layouts and, in fact, the LayoutManager itself :) <br>  Imagine that an Activity with a RecyclerView in it, as well as a RecyclerView.Adapter that creates and populates article cards, we have already written (or copied from the training project) and it is time to create our own LayoutManager. <br><br><h1>  We write the basis </h1><br><br>  The first thing to do is to implement the generateDefaultLayoutParams () method, which will return the required LayoutParams for views whose LayoutParams do not suit us. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AwesomeLayoutManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclerView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RecyclerView.<span class="hljs-function"><span class="hljs-function">LayoutParams </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDefaultLayoutParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecyclerView.LayoutParams(RecyclerView.LayoutParams.MATCH_PARENT, RecyclerView.LayoutParams.MATCH_PARENT); } }</code> </pre> <br>  The main magic happens in the onLayoutChildren (...) method, which is the starting point for adding and positioning our views.  To begin, learn to have at least one article. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ View view = recycler.getViewForPosition(<span class="hljs-number"><span class="hljs-number">0</span></span>); addView(view); measureChildWithMargins(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); layoutDecorated(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, getWidth(), getHeight()); }</code> </pre><br>  In the first line, we ask recycler to give us a view for the first position.  Then, Recycler itself determines whether to return it from the internal cache or create a new one.  On the second line linger a little longer. <br><br>  If you have already created your own views, you probably know how to add another child inside your view.  To do this, add a child view to your layout (as in the second line), then measure it by calling its measure (...) method and, finally, place it in the right place by calling its layout (...) method with the right size.  If you have never done anything like this before, now you can imagine how this happens :) As for the RecyclerView, here it takes a different turn.  For almost all standard methods of the View class, related to dimensions and layout, RecyclerView has alternative ones that should be used.  First of all, they are needed because RecyclerView has a class ItemDecoration, with which you can resize views, and these alternative methods take into account all installed decorators. <br>  Here are some examples of alternative methods: <br><br><pre> <code class="java hljs">view.layout(left, top, right, bottom) -&gt; layoutDecorated(view, left, top, right, bottom) view.getLeft() -&gt; getDecoratedLeft(view) view.getWidth() -&gt; getDecoratedWidth(view)</code> </pre><br>  etc. <br><br>  So, in the third line we allow the view to calculate its dimensions, and in the fourth line we place it in the layout from the upper left corner (0, 0) to the lower right corner (getWidth (), getHeight ()). <br>  To measure the size of the view, we used the ready method measureChildWithMargins (...).  In fact, it does not quite suit us, since it takes measurements, taking into account the width and height specified in the LayoutParams of the child view.  And there can be anything: wrap_content, match_parent, or even specified in dp.  But we then agreed that all the cards we will have a fixed size!  So we have to write our measure, without forgetting about the existence of decorators: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureChildWithDecorationsAndMargin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthSpec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightSpec)</span></span></span><span class="hljs-function"> </span></span>{ Rect decorRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(); calculateItemDecorationsForChild(child, decorRect); RecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) child.getLayoutParams(); widthSpec = updateSpecWithExtra(widthSpec, lp.leftMargin + decorRect.left, lp.rightMargin + decorRect.right); heightSpec = updateSpecWithExtra(heightSpec, lp.topMargin + decorRect.top, lp.bottomMargin + decorRect.bottom); child.measure(widthSpec, heightSpec); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateSpecWithExtra</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startInset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endInset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startInset == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; endInset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spec; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mode = View.MeasureSpec.getMode(spec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mode == View.MeasureSpec.AT_MOST || mode == View.MeasureSpec.EXACTLY) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View.MeasureSpec.makeMeasureSpec( View.MeasureSpec.getSize(spec) - startInset - endInset, mode); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spec; }</code> </pre><br>  Now our onLayoutChildren () looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ View view = recycler.getViewForPosition(<span class="hljs-number"><span class="hljs-number">0</span></span>); addView(view); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthSpec = View.MeasureSpec.makeMeasureSpec(getWidth(), View.MeasureSpec.EXACTLY); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heightSpec = View.MeasureSpec.makeMeasureSpec(getHeight(), View.MeasureSpec.EXACTLY); measureChildWithDecorationsAndMargin(view, widthSpec, heightSpec); layoutDecorated(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, getWidth(), getHeight()); }</code> </pre><br>  With the help of MeasureSpec, we inform our view that its height and width should and will be equal to the height and width of the RecyclerView.  Of course, to draw an article 75% high of the screen height, you need to pass this same height to layoutDecorated (): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VIEW_HEIGHT_PERCENT = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ View view = recycler.getViewForPosition(<span class="hljs-number"><span class="hljs-number">0</span></span>); addView(view); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHeight = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (getHeight() * VIEW_HEIGHT_PERCENT); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthSpec = View.MeasureSpec.makeMeasureSpec(getWidth(), View.MeasureSpec.EXACTLY); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heightSpec = View.MeasureSpec.makeMeasureSpec(getHeight(), View.MeasureSpec.EXACTLY); measureChildWithDecorationsAndMargin(view, widthSpec, heightSpec); layoutDecorated(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, getWidth(), viewHeight); }</code> </pre><br>  Now, if we set our LayoutManager to RecyclerView and run the project, we‚Äôll see one article on three quarters of the screen. <br><img src="https://habrastorage.org/getpro/habr/post_images/e39/bba/cd2/e39bbacd2711829d74f984b01b564157.png"><br><br>  Now we will try to draw vyushki articles, starting with the first (zero) and placing them under each other, until the screen ends vertically or the elements in the adapter run out. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ fillDown(recycler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> fillDown = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewTop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemCount = getItemCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHeight = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (getHeight() * VIEW_HEIGHT_PERCENT); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthSpec = View.MeasureSpec.makeMeasureSpec(getWidth(), View.MeasureSpec.EXACTLY); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heightSpec = View.MeasureSpec.makeMeasureSpec(getHeight(), View.MeasureSpec.EXACTLY); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (fillDown &amp;&amp; pos &lt; itemCount){ View view = recycler.getViewForPosition(pos); addView(view); measureChildWithDecorationsAndMargin(view, widthSpec, heightSpec); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decoratedMeasuredWidth = getDecoratedMeasuredWidth(view); layoutDecorated(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, viewTop, decoratedMeasuredWidth, viewTop + viewHeight); viewTop = getDecoratedBottom(view); fillDown = viewTop &lt;= height; pos++; } }</code> </pre><br><img src="https://raw.githubusercontent.com/forceLain/storage/master/wp3.png"><br><br>  It looks ready, but so far we have not done one very important thing.  Earlier we said that recycler itself determines whether to take caches from it or create new ones, but in fact, the cache is still empty from it, since we haven‚Äôt put anything in it yet.  Add the detachAndScrapAttachedViews (recycler) call to onLayoutChildren () first in front of fillDown (). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ detachAndScrapAttachedViews(recycler); fillDown(recycler); }</code> </pre><br>  This method removes all views from our layout and places them in its special scrap cache.  If necessary, you can return the view using the method recycler.getViewForPosition (pos). <br><br><h1>  They see me rollin ' </h1><br>  Now it would be good to teach our LayoutManager to scroll. <br>  First, let's tell our LayoutManager that we want to scroll vertically: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canScrollVertically</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  Then we implement the vertical scroll itself. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollVerticallyBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy, RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ offsetChildrenVertical(-dy); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dy; }</code> </pre><br>  At the input of this method, we get dy - the distance that needs to be scrolled.  We must return the distance to which we actually rotated our views.  This is necessary in order not to allow the content to go beyond the boundaries of the screen.  Let's immediately write an algorithm that determines whether we can still scroll and how far: <br><br><div class="spoiler">  <b class="spoiler_title">Scrolling</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollVerticallyBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy, RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = scrollVerticallyInternal(dy); offsetChildrenVertical(-delta); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delta; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollVerticallyInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = getChildCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemCount = getItemCount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childCount == <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View topView = getChildAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View bottomView = getChildAt(childCount - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//,       int viewSpan = getDecoratedBottom(bottomView) - getDecoratedTop(topView); if (viewSpan &lt;= getHeight()) { return 0; } int delta = 0; //    if (dy &lt; 0){ View firstView = getChildAt(0); int firstViewAdapterPos = getPosition(firstView); if (firstViewAdapterPos &gt; 0){ //        delta = dy; } else { //              int viewTop = getDecoratedTop(firstView); delta = Math.max(viewTop, dy); } } else if (dy &gt; 0){ //    View lastView = getChildAt(childCount - 1); int lastViewAdapterPos = getPosition(lastView); if (lastViewAdapterPos &lt; itemCount - 1){ //        delta = dy; } else { //              int viewBottom = getDecoratedBottom(lastView); int parentBottom = getHeight(); delta = Math.min(viewBottom - parentBottom, dy); } } return delta; }</span></span></code> </pre><br></div></div><br>  Now we can scroll through our 2 added articles, but when scrolling new articles on the screen are not added.  The algorithm for adding new views during scrolling may seem to be intricate, but this is only at first glance.  We will first try to describe it with the words: <br><ol><li>  First we shift all available views to dy with offsetChildrenVertical (-dy) </li><li>  Select one of the views in the layout as anchor and memorize it and its position.  In our case, we will choose the one that is fully visible on the screen as an anchor view.  If this is not, then choose the one with the maximum visible area.  This method of defining an anchor view will help us in the future, when implementing the change of orientation of our layout manager. </li><li>  We remove all the views in the layout, putting them in our own cache and remembering what positions they were in </li><li>  Add views to the layout above the position we took as an anchor.  Then we add the anchor and everything that should be below it.  First of all, we take the views from our cache and, if we don‚Äôt find them, ask recycler </li></ol><br><br>  <i>NOTE: implementation of a scroll and adding a view to the layout is an individual matter.</i>  <i>With the same success it would be possible to take the uppermost one for the anchor view and fill the screen down from it.</i>  <i>And if you wanted to make such a LayoutManager, which behaves like a ViewPager, you wouldn‚Äôt have to add views at all during scrolling, but only between the swaps.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Scrolling + Recycling</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SparseArray&lt;View&gt; viewCache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparseArray&lt;&gt;(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span></span></span><span class="hljs-function"> </span></span>{ detachAndScrapAttachedViews(recycler); fill(recycler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler)</span></span></span><span class="hljs-function"> </span></span>{ View anchorView = getAnchorView(); viewCache.clear(); <span class="hljs-comment"><span class="hljs-comment">//    ... for (int i = 0, cnt = getChildCount(); i &lt; cnt; i++) { View view = getChildAt(i); int pos = getPosition(view); viewCache.put(pos, view); } //...     for (int i = 0; i &lt; viewCache.size(); i++) { detachView(viewCache.valueAt(i)); } fillUp(anchorView, recycler); fillDown(anchorView, recycler); //   ,        //        ,     //   for (int i=0; i &lt; viewCache.size(); i++) { recycler.recycleView(viewCache.valueAt(i)); } } private void fillUp(@Nullable View anchorView, RecyclerView.Recycler recycler) { int anchorPos = 0; int anchorTop = 0; if (anchorView != null){ anchorPos = getPosition(anchorView); anchorTop = getDecoratedTop(anchorView); } boolean fillUp = true; int pos = anchorPos - 1; int viewBottom = anchorTop; //          int viewHeight = (int) (getHeight() * VIEW_HEIGHT_PERCENT); final int widthSpec = View.MeasureSpec.makeMeasureSpec(getWidth(), View.MeasureSpec.EXACTLY); final int heightSpec = View.MeasureSpec.makeMeasureSpec(viewHeight, View.MeasureSpec.EXACTLY); while (fillUp &amp;&amp; pos &gt;= 0){ View view = viewCache.get(pos); //  if (view == null){ //     -   recycler ,     view = recycler.getViewForPosition(pos); addView(view, 0); measureChildWithDecorationsAndMargin(view, widthSpec, heightSpec); int decoratedMeasuredWidth = getDecoratedMeasuredWidth(view); layoutDecorated(view, 0, viewBottom - viewHeight, decoratedMeasuredWidth, viewBottom); } else { //     -     //   measure/layout . attachView(view); viewCache.remove(pos); } viewBottom = getDecoratedTop(view); fillUp = (viewBottom &gt; 0); pos--; } } private void fillDown(@Nullable View anchorView, RecyclerView.Recycler recycler) { int anchorPos = 0; int anchorTop = 0; if (anchorView != null){ anchorPos = getPosition(anchorView); anchorTop = getDecoratedTop(anchorView); } int pos = anchorPos; boolean fillDown = true; int height = getHeight(); int viewTop = anchorTop; int itemCount = getItemCount(); int viewHeight = (int) (getHeight() * VIEW_HEIGHT_PERCENT); final int widthSpec = View.MeasureSpec.makeMeasureSpec(getWidth(), View.MeasureSpec.EXACTLY); final int heightSpec = View.MeasureSpec.makeMeasureSpec(viewHeight, View.MeasureSpec.EXACTLY); while (fillDown &amp;&amp; pos &lt; itemCount){ View view = viewCache.get(pos); if (view == null){ view = recycler.getViewForPosition(pos); addView(view); measureChildWithDecorationsAndMargin(view, widthSpec, heightSpec); int decoratedMeasuredWidth = getDecoratedMeasuredWidth(view); layoutDecorated(view, 0, viewTop, decoratedMeasuredWidth, viewTop + viewHeight); } else { attachView(view); viewCache.remove(pos); } viewTop = getDecoratedBottom(view); fillDown = viewTop &lt;= height; pos++; } } //       private View getAnchorView() { int childCount = getChildCount(); HashMap&lt;Integer, View&gt; viewsOnScreen = new HashMap&lt;&gt;(); Rect mainRect = new Rect(0, 0, getWidth(), getHeight()); for (int i = 0; i &lt; childCount; i++) { View view = getChildAt(i); int top = getDecoratedTop(view); int bottom = getDecoratedBottom(view); int left = getDecoratedLeft(view); int right = getDecoratedRight(view); Rect viewRect = new Rect(left, top, right, bottom); boolean intersect = viewRect.intersect(mainRect); if (intersect){ int square = viewRect.width() * viewRect.height(); viewsOnScreen.put(square, view); } } if (viewsOnScreen.isEmpty()){ return null; } Integer maxSquare = null; for (Integer square : viewsOnScreen.keySet()) { if (maxSquare == null){ maxSquare = square; } else { maxSquare = Math.max(maxSquare, square); } } return viewsOnScreen.get(maxSquare); } @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) { int delta = scrollVerticallyInternal(dy); offsetChildrenVertical(-delta); fill(recycler); return delta; }</span></span></code> </pre><br></div></div><br>  Note that inside fillUp (), views are added using the addView (view, 0) method, not the addView (view), as before.  This was done in order to preserve the order of the elements inside the layout - the higher the view, the smaller its sequence number should be. <br><br><h1>  Wow effect </h1><br>  At this point, we had a completely working LayoutManager, which behaves like a ListView.  Now add to it the effect of scaling the bottom card.  All you need is one method! <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateViewScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = getChildCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thresholdPx = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (height * SCALE_THRESHOLD_PERCENT); <span class="hljs-comment"><span class="hljs-comment">// SCALE_THRESHOLD_PERCENT = 0.66f or 2/3 for (int i = 0; i &lt; childCount; i++) { float scale = 1f; View view = getChildAt(i); int viewTop = getDecoratedTop(view); if (viewTop &gt;= thresholdPx){ int delta = viewTop - thresholdPx; scale = (height - delta) / (float)height; scale = Math.max(scale, 0); } view.setPivotX(view.getHeight()/2); view.setPivotY(view.getHeight() / -2); view.setScaleX(scale); view.setScaleY(scale); } }</span></span></code> </pre><br>  Put this method inside fill () last.  It sets scale &lt;1 for those views whose upper limit is below 2/3 of the screen.  In this case, the scale is smaller, the lower this limit.  Additionally, we shift the zoom focus (setPivotX and setPivotY) so that it becomes higher than the view itself.  This allows you to create such an effect, as if the bottom card comes up from under the top <br><br>  If we launch our project now, we will see that everything does not work exactly as expected: the bottom card is drawn on top of the top one, although the opposite was necessary. <br><img src="https://raw.githubusercontent.com/forceLain/storage/master/wp4.png"><br><br>  This is because the order of drawing views to Android is determined by the order in which they are added.  Fortunately, invert the drawing order in RecyclerView is not at all difficult: <br><br><pre> <code class="java hljs"> recyclerView.setChildDrawingOrderCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecyclerView.ChildDrawingOrderCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onGetChildDrawingOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> childCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> childCount - i - <span class="hljs-number"><span class="hljs-number">1</span></span>; } });</code> </pre><br>  Well, now everything is in order. <br><br><img src="https://raw.githubusercontent.com/forceLain/storage/master/wp5.png"><br><br><h1>  The horizon is not overwhelmed! </h1><br>  Now that we know how to make a vertical LayoutManager, it‚Äôs easy for us to make a horizontal mode in its likeness.  We need a class field where the current mode (orientation) will be stored, getter- and setter- for it.  Also, you will need to implement similar methods fillLeft (), fillRight (), canScrollHorizontally (), scrollHorizontallyBy (), etc. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Orientation {VERTICAL, HORIZONTAL} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Orientation orientation = Orientation.VERTICAL; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mAnchorPos; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOrientation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Orientation orientation)</span></span></span><span class="hljs-function"> </span></span>{ View anchorView = getAnchorView(); mAnchorPos = anchorView != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? getPosition(anchorView) : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (orientation != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.orientation = orientation; } requestLayout(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler)</span></span></span><span class="hljs-function"> </span></span>{ View anchorView = getAnchorView(); viewCache.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, cnt = getChildCount(); i &lt; cnt; i++) { View view = getChildAt(i); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = getPosition(view); viewCache.put(pos, view); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; viewCache.size(); i++) { detachView(viewCache.valueAt(i)); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (orientation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VERTICAL: fillUp(anchorView, recycler); fillDown(anchorView, recycler); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HORIZONTAL: fillLeft(anchorView, recycler); fillRight(anchorView, recycler); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   ,        //        ,     //   for (int i=0; i &lt; viewCache.size(); i++) { recycler.recycleView(viewCache.valueAt(i)); } updateViewScale(); } @Override public boolean canScrollVertically() { return orientation == Orientation.VERTICAL; } @Override public boolean canScrollHorizontally() { return orientation == Orientation.HORIZONTAL; }</span></span></code> </pre><br><br>  Implementations of the fillLeft (), fillRight () methods and the definition of scroll boundaries will not be given, because they are very similar to their ‚Äúvertical‚Äù counterparts.  Just change top to left and bottom to right and make a layout full screen :).  You can see the code in our educational project on github, which we mentioned at the beginning of the article.  Also, we draw your attention to the fact that the position mAnchorPos is defined and stored inside the setOrientation (), which is then used inside the fill * () - methods to restore the current article when the orientation changes. <br><br>  Finally, you need to understand the animation of the transition from vertical to horizontal mode.  We will respond to clicks on the card and open the one we clicked on.  Since the left and right borders of the view in the vertical and horizontal modes always coincide, we will only have to animate its top and bottom.  And the tops and bottoms of all its neighbors :) <br><br>  Let's write a public method openView (int pos), the call of which will start the animation. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (orientation == Orientation.VERTICAL){ View viewToOpen = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = getChildCount(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; childCount; i++) { View view = getChildAt(i); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = getPosition(view); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position == pos){ viewToOpen = view; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (viewToOpen != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ openView(viewToOpen); } } }</code> </pre><br>  And the animation itself inside the private openView (View view): <br><br><div class="spoiler">  <b class="spoiler_title">Animation</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> View viewToAnimate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ArrayList&lt;ViewAnimationInfo&gt; animationInfos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = getChildCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> animatedPos = getPosition(viewToAnimate); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; childCount; i++) { View view = getChildAt(i); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = getPosition(view); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> posDelta = pos - animatedPos; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ViewAnimationInfo viewAnimationInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewAnimationInfo(); viewAnimationInfo.startTop = getDecoratedTop(view); viewAnimationInfo.startBottom = getDecoratedBottom(view); viewAnimationInfo.finishTop = getHeight() * posDelta; viewAnimationInfo.finishBottom = getHeight() * posDelta + getHeight(); viewAnimationInfo.view = view; animationInfos.add(viewAnimationInfo); } ValueAnimator animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); animator.setDuration(TRANSITION_DURATION_MS); animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueAnimator.AnimatorUpdateListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueAnimator animation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> animationProgress = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) animation.getAnimatedValue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ViewAnimationInfo animationInfo : animationInfos) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> top = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (animationInfo.startTop + animationProgress * (animationInfo.finishTop - animationInfo.startTop)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottom = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (animationInfo.startBottom + animationProgress * (animationInfo.finishBottom - animationInfo.startBottom)); layoutDecorated(animationInfo.view, <span class="hljs-number"><span class="hljs-number">0</span></span>, top, getWidth(), bottom); } updateViewScale(); } }); animator.addListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animator.AnimatorListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ setOrientation(Orientation.HORIZONTAL); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{} }); animator.start(); }</code> </pre><br>  ViewAnimationInfo is just a class structure for convenient storage of different values: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewAnimationInfo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startTop; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startBottom; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishTop; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishBottom; View view; }</code> </pre><br></div></div><br>  Here's what happens inside openView: for each view on the screen, we remember its top and bottom, and we also count its top and bottom, to which this view should ‚Äúleave.‚Äù  Then we create and run ValueAnimator, which gives us a progress from 0 to 1, based on which we count the top and bottom for each view during the animation and perform layoutDecorated (...) with the necessary values ‚Äã‚Äãin each animation cycle.  At the moment when the animation ends, call setOrientation (Orientation.HORIZONTAL) for the final transition to horizontal mode.  Smooth and discreet. <br><br><h1>  Remove the sample </h1><br>  It is a pity that it will not be possible to place all the useful information about the LayoutManager in just one article.  If necessary, you can see something in our training project (for example, the implementation of smoothScrollToPosition ()), and you have to search for something yourself. <br><br>  In conclusion, I would like to say that LayoutManager is an extremely powerful and flexible tool.  RecyclerView + CustomLayoutManager has repeatedly come to our aid in solving very unusual design problems.  It opens up spaces for animating both the views themselves and the content in them.  In addition, it greatly expands the possibilities of optimization.  For example, if the user wants to perform smoothScroll () from the 1st element to the 100th, it is not necessary to honestly scroll through all 99 elements.  You can cheat and add the 100th element to the layout before scrolling, and then scroll to it, saving a lot of resources! <br>  However, LayoutManager is not so easy to learn from scratch.  To effectively use it, you need to be well aware of how custom views are created, how measure / layout cycles work, how to use MeasureSpec, etc. in the same spirit. <br><br><h2>  Related Links: </h2><br>  Training project with an example of LayoutManager: <a href="https://github.com/forceLain/AwesomeRecyclerView">https://github.com/forceLain/AwesomeRecyclerView</a> <br>  An article in 3 parts about creating your LayoutManager, similar to GridLayoutManager in English: <a href="http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/">http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/</a> </div><p>Source: <a href="https://habr.com/ru/post/267497/">https://habr.com/ru/post/267497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267477/index.html">Create a REST service on PostgreSQL and Rust. Part 1: prototype</a></li>
<li><a href="../267483/index.html">(Archive) Matreshka.js 1.1: even more cool</a></li>
<li><a href="../267487/index.html">Embarcadero Technologies sold to Idera</a></li>
<li><a href="../267491/index.html">About UEFI security, part four</a></li>
<li><a href="../267495/index.html">New in Runkit 1.0.4: PHP 5.6+, closures everywhere and 12 more new features</a></li>
<li><a href="../267499/index.html">Messy about developing letters</a></li>
<li><a href="../267501/index.html">Localizing Google Chrome Extensions - Necessary and Easy</a></li>
<li><a href="../267503/index.html">Python Meetup 08.28.15: full-text search and Europython 2015</a></li>
<li><a href="../267505/index.html">Basics of NHibernate (easy tutorial)</a></li>
<li><a href="../267507/index.html">Another way to disable telemetry collection in Windows 10 OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>