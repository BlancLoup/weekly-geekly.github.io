<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Updating the application code on a running server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many organizations daily face the need to support the work of highly loaded systems, on the adequate functioning of which depends a huge number of ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Updating the application code on a running server</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/997/031/2e0/9970312e06694ccb97c9c25fa9410ba1.jpg"><br>  Many organizations daily face the need to support the work of highly loaded systems, on the adequate functioning of which depends a huge number of operations.  In such conditions it is difficult to imagine a situation when the system is suspended for updating the server components or the code of software applications.  And if the suspension of downloading a picture or playing a video on Facebook can be uncritical, then in the financial, military or aerospace industry the consequences of even the minimal delay in processing operations can be disastrous. <br><br>  To better understand the scale of these operations, just imagine that the bank was unable to make a multi-million dollar payment from a client or that any of the dispatching systems at Heathrow Airport decided to upgrade during the take-off of the aircraft.  Hardly a similar scenario is permissible in today's realities. <br><a name="habracut"></a><br>  However, the application server inevitably has to be updated - there is no getting away from it.  And given the constant load on them, the issue of uninterrupted operation of applications during updates becomes more relevant than ever. <br><br><h3>  What is necessary to ensure the smooth operation of applications during the update? </h3><br>  There are several ways to solve this problem: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Creating an excessive number of application servers or environments (clusters). </li><li>  Special features of the application server or applications directly. </li></ol><br>  It should be noted that recently, due to the cheapening of iron, the development trend of clusters, an excessive number of applications, as well as other resources required for work in complex distributed systems (for example, databases, additional disks (RAID of various types), several network interfaces for the same resources for reliability and so on). <br><br>  However, in this article I would like to focus on the second option, namely the possibility of updating the application code on a separate server that continues to work under load. <br><br><h3>  Who might be interested in such a decision? </h3><br>  Although creating an excessive number of application servers or environments provides higher reliability, it requires a proportionately large amount of resources.  In addition, it is much more difficult to ensure the operation of such clusters.  In sum, this is not always justified, especially in the case of small solutions, for which the question of resource intensity is much more acute. <br><br>  In this regard, applications without clustering occupy a separate niche, allowing you to bypass some of the difficulties in using an excessive number of application servers or environments, since such applications clearly benefit in terms of resource and ease of use. <br><br><h3>  Features of the development of complex applications </h3><br>  One of the principles for the development of complex applications is the construction of modular applications, modules in which are weakly connected.  In the Java world, they wanted to include such technology in JDK 7, later they decided to release it along with Java 8, but now, judging by the current announcements, it will appear no earlier than Java 9 in March 2017 as a mechanism for interaction of Jigsaw modules. <br><br>  Due to the principle of modularity, such applications can be updated in the course of their work even under load.  Those who do not want to wait for the release of fresh versions of Java, can use the modular approach to developing applications right now - the <b>technology</b> is called <b>OSGi</b> , its first specification appeared in the early 2000s.  Upgrading application code under load without clustering can be applicable for both PCs and mobile devices.  Moreover, it requires less resources (processor, memory, disk) and less time spent on configuration and testing. <br><br><h3>  What about the clouds? </h3><br>  Due to the increasing popularity of cloud services, this topic can not be touched on. <br>  To solve the update problem, you can actually create a virtual IP address, configure it to be balanced across several application nodes, and update them sequentially.  In this case, the system will simultaneously exist applications of different versions.  This is possible given the thoughtful design of applications, but imposes additional requirements on them.  In essence, the complete independence of applications from the data should be ensured, they should not maintain state and should be designed so that the availability of different versions in the system is acceptable.  In fact, this involves the simultaneous operation of several applications, which imposes additional costs for managing them.  It should, however, be noted that cloud technologies and OSGi are not mutually exclusive.  OSGi approaches can be used in the clouds, which, among other things, implies an abstraction from iron. <br><br>  Thus, the use of cloud servers allows both splitting application modules into separate cloud nodes according to the OSGi principle, and launching a full-fledged application with all modules at each node, creating redundancy.  Which of these methods to choose depends primarily on the resources of the organization. <br><br><h3>  What are the main differences between the OSGi specs from Jigsaw? </h3><br>  Of course, in order to understand the feasibility of using the OSGi specification in view of the upcoming Java update, you need to figure out how these solutions will differ and whether they will be compatible.  Let's look at the table below: <br><table border="1"><tbody><tr><td align="center">  <b>OSGi</b> </td><td align="center">  <b>Jigsaw</b> </td></tr><tr><td>  It has existed since 2000 and is a fully working mechanism with proven effectiveness. </td><td>  In development and will not be available until Java 9 </td></tr><tr><td>  Is a separate specification. </td><td>  Will be fully embedded in the Java 9 platform. </td></tr><tr><td>  Quite difficult to use </td><td>  JPMS tends to be easier to use than OSGi.  However, the creation of a modular product based on non-modular and is the main source of complexity.  Thus, Jigsaw is unlikely to be much easier OSGi </td></tr><tr><td>  It is impossible to load internal classes of modules, as they are not visible from the outside.  That is, the class loader of my module can only see the internal types of my module, as well as types that have been explicitly imported from other modules. </td><td>  Each type sees any other type, as they are in the same loader class.  True, JPMS adds a secondary check to make sure that the class being loaded has the right to access the type it is trying to load.  Internal types from other modules are private in reality, even if they are declared public. </td></tr><tr><td>  Allows simultaneous operation of multiple versions of applications. </td><td>  Does not allow to have several versions of the same module at the same time </td></tr><tr><td>  There is a product lifecycle management </td><td>  No product lifecycle management </td></tr><tr><td>  Dynamic modularity in real-time deployment </td><td>  Static modularity when deployed </td></tr><tr><td>  Allowed to have modules, the content of which duplicates each other </td><td>  It is impossible to have modules whose content duplicates each other. </td></tr></tbody></table><br>  In basic compatibility mode, the framework and OSGi sets will fully exist within the ‚Äúnameless‚Äù Jigsaw module.  OSGi will continue to offer all its functionality for isolation - along with a powerful registry and dynamic loading.  Any investment in OSGi is safe, as the specification will still remain a good option for any new projects. <br><br><h3>  What is special about working with the OSGi specification? </h3><br>  The OSGi specification is based on the use of modular applications, the components of which work in a loosely coupled environment, and the interaction routes between applications are configured in the configuration file.  Such an application model allows us to consider it as a network (graph), where nodes are components, and branches are connections between them.  In this connection can be both one-way and two-way. <br><br>  When updating the code of such a program, first of all it is necessary to analyze the following points: <br><br><ol><li>  What nodes need to be updated. </li><li>  What branches of the application will be affected. </li></ol><br>  It is important to note that there are <b>two main ways of interaction between components</b> in a distributed isolated environment: synchronous (through services) and asynchronous (using messages). <br><br>  They work as follows: in a loosely coupled environment, there is an unlimited number of modules that can communicate with each other, either using services, or using messages, or using both.  During the update of a specific module, messages will be accumulated in a queue, and services will wait half way until the destination module is updated. <br><br>  The analysis of services is carried out through an open implementation of the OSGi framework, and the analysis of messages is performed using application code (in our case, the Real Time Framework application (RTF), which will be discussed below).  This allows you to understand at what points in the interaction path of components you need to temporarily accumulate messages in the queue (with the help of which components interact) or temporarily suspend the called services so that immediately after updating the application code of the application you can continue working.  As a result, while the application code is updated to the next version, the messages will be accumulated in the queue, and the services will be put on standby, that is, during the update, the affected routes will become unavailable.  Thus, the application server does not need to be restarted, which will significantly reduce the unavailability of applications.  In addition, you do not need to load the caches again, since the application will continue to work exactly from the point where it stopped during the update. <br><br>  It is worth noting that in order to work effectively, it makes sense to design applications with the most unrelated routes of interaction between components, so that when they are updated, such routes and the services provided continue to function. <br><br>  In addition, it is necessary to separate the API from the implementation so that it can be easier to update without affecting the API.  What for?  For comparison: an application server usually starts in minutes, ideally in 20-30 seconds, and a component update in a running server will take only 2-5 seconds, while all the service data will not need to be re-loaded into memory (cache). <br><br><h3>  Real Time Framework (RTF) application for updating code under load </h3><br>  <b>RTF</b> is a commercial product based on the OSGi specification, which is an application consisting of modules.  The OSGi specification itself only provides the ability to simultaneously have multiple versions of the work of many modules related to certain dependencies, but building synchronous and asynchronous connections between modules and working on updating components is the responsibility of the RTF application itself. <br><br>  <b>The feature of RTF</b> is that it extends the capabilities of OSGi, allowing not only updating the source code of the application during operation, but also doing it under load.  In other words, it allows you to "pause the application", update and continue the execution of requests in the normal mode already on the updated application. <br><br>  It also provides a lightweight transport for sending and receiving messages between components, implemented in Java without storing messages in any database.  Such transport allows you to organize the interaction of components in a distributed system of weakly coupled components.  To illustrate the mechanism of interaction of components, you can use the scheme below: <br><img src="https://habrastorage.org/files/997/031/2e0/9970312e06694ccb97c9c25fa9410ba1.jpg"><br><br>  It is worth noting that the components interact indirectly - each component does not have special knowledge about the recipient of the message.  In this case, a message can transmit a data set of the form &lt;key-value&gt;, which will be sufficiently abstract for both the sender and the recipient. <br><br>  Messages are sent using the outgoing port, and reception, respectively, via the incoming port.  Route settings for sending messages are defined in a special xml configuration file, while you can additionally set filters for messages, one of the options is with the presence / absence of some parameters or their values. <br><br><h3>  RTF usage examples </h3><br>  RTF technology is not new and has proven its effectiveness more than once.  One example is setting up billing services from scratch for Axia based on an RTF application.  The implementation was carried out standalone, i.e., without using the possibilities of clustering.  In this case, the Company was more important than ever to ensure the stable operation of the system even during the update of any components, since the specifics of payment processing does not allow for the slightest error or delays in work. <br><br>  Recently, a large number of developments are underway for MANO (Management and Orchestration).  In this case, RTF technology is applied to the system monitor (monitors the hardware status) and the network virtualization monitor (VNF).  It should be noted that all work is carried out in the open stack, which once again confirms the full compatibility of RTF technology with cloud services.  As an example, it is worthwhile to cite the work of NEC / Netcracker on network virtualization for the Japanese telecom operator NTT DOCOMO.  This project gives the company the opportunity to flexibly change the power of the underlying network, and also significantly reduces recovery time in case of equipment failure. <br><br><h3>  findings </h3><br>  The article demonstrates one of the possible ways to update the application code on a server operating under load - using the example of a commercial RTF application server that complies with the OSGi specification.  RTF allows you to pause the interaction of the modules that make up the application, put all messages in the queue, and services (synchronous calls) to wait, update the necessary modules, and start the application from the moment you pause.  In this case, the data with which the application worked, will not disappear anywhere.  The described method of updating the code is suitable primarily for those who for some reason do not use clustering, do not want to duplicate applications and want to save resources on configuration and testing.  A good example is the development of a billing system for Axia. <br><br>  At the same time, RTF technology is effectively used by companies using clusters and cloud servers.  Thanks to RTF, applications can be used continuously, taking into account that at the time of updating requests will not be processed for a few seconds, and immediately after updating the application will continue.  This allows organizations to flexibly update application code without risking losing some data.  Moreover, the time to load applications after the update is significantly saved, since the module update in a working server will take only 2‚Äì5 seconds, after which the service data will not have to be loaded into the cache again. </div><p>Source: <a href="https://habr.com/ru/post/322814/">https://habr.com/ru/post/322814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322800/index.html">Starbucks should open public access to its API.</a></li>
<li><a href="../322802/index.html">How I got into the PayPal server through a bug in downloading files and got access to remote code execution</a></li>
<li><a href="../322804/index.html">Choosing the right error handling strategy (parts 3 and 4)</a></li>
<li><a href="../322806/index.html">A bit about functors and higher order functions in Swift</a></li>
<li><a href="../322812/index.html">The real hero in the programming world: who is he?</a></li>
<li><a href="../322816/index.html">Automated testing of bots for Telegram</a></li>
<li><a href="../322818/index.html">Announcement of HolyJS 2017 Piter: More JavaScript, good and different</a></li>
<li><a href="../322820/index.html">Models of buying advertising in traffic arbitration</a></li>
<li><a href="../322822/index.html">The reverse side of the operation of payment technologies based on NFC and MST</a></li>
<li><a href="../322824/index.html">SK Telecom begins work on quantum cryptosystems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>