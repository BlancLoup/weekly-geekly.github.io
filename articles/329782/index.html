<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create your own Angular 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, this article describes the mechanism of work of Angular 2. Today we look under the hood of a popular framework. 

 This article is a free trans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create your own Angular 2</h1><div class="post__text post__text-html js-mediator-article">  Hello, this article describes the mechanism of work of Angular 2. Today we look under the hood of a popular framework. <br><a name="habracut"></a><br>  This article is a free translation of the Tobias Bosch report - The Angular 2 Compiler.  You can find the link to the original report at the end of the article. <br><br><h3>  An overlook </h3><br>  Tobias Bosch is an employee of Google and a member of the Angular development team who created most of the components of the compiler.  Today he talks about how Angular works from the inside.  And this is not something extremely complex. <br><br>  I hope that you use some of the knowledge gained in your applications.  Perhaps you, like our team, will create your own compiler or a small framework.  I will talk about how the compiler works and how we achieved our goal. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What is a compiler? </h3><br>  This is all that happens between the application's input data (it can be your commands, patterns, etc.) and your running application. <br><img src="https://habrastorage.org/web/faa/184/8ce/faa1848cec4c43779909f60546158132.png" alt="angular2 compiler process"><br>  Everything that happens between them is the domain of the compiler.  In appearance, it may seem like pure magic.  But it is not. <br><br><h3>  What will we look at today? </h3><br><img src="https://habrastorage.org/web/3e0/2d3/d0c/3e02d3d0c36b4cb8a5dfdcffb0ea5a7d.png" alt="angular2 compiler agenda"><br><br>  First, we'll talk a little about performance: what is meant by fast work?  We will talk about what kind of input data we have. <br><br>  We will also talk about lexical analysis, what it is, and what the Angular 2 compiler does with analysis.  We‚Äôll talk about how Angular 2 takes the analyzed data and processes it.  In general, the implementation of this process took place in three attempts; at first there was a simple implementation, then an improved one and an even more improved one.  So did we.  These are the stages by which we managed to achieve accelerated work of our compiler. <br><br>  We will also discuss different environments, advantages and disadvantages of dynamic (Just In Time) and static (Ahead Of Time) compilations. <br><br><h3>  Performance: what does fast work mean? </h3><br>  Imagine a situation: I wrote an application and claimed that it works quickly.  What I mean?  The first thing you might think is that the application loads very quickly.  Did you see google amp pages?  They load unreal fast.  This can be attributed to the concept of "fast." <br><br>  Perhaps I use a great app.  I switch from one heading to another.  For example, from the overview to the expanded page, and such transition occurs very quickly.  This can also characterize speed. <br><br>  Or, say, I have a large table and now I just change all its values.  I create new values ‚Äã‚Äãwithout changing the structure.  This is real fast.  All these are different aspects of the same concept, different things that need to be addressed in the application. <br><br><h3>  Crossing the paths </h3> <br>  I would like to stay more detailed at the stage of transition along the paths (switching a route). <br><br>  The important point is that when moving along paths, the framework destroys and recreates everything anew.  It does not adhere to the structure: everything collapses and everything is recreated anew. <br><br>  <b>How can this process be made quick?</b> <br><br>  To do something quickly, you need to measure this speed.  For this you need a test.  One of the performance tests we use is the deep-tree performance test.  You may have heard of such.  This is a component that is used twice.  This is a recursion of a component until a certain depth is reached. <br><br><img src="https://habrastorage.org/web/29f/381/b74/29f381b74d804b9f8e327d212322a9ba.png" alt="angular2 compiler benchmarks"><br><br>  We have 512 components and buttons that can destroy or create these components.  Next, we measure how much time it takes to destroy and create components.  So there is a transition along the paths.  Transition from one view to another.  The destruction of everything is the creation of everything. <br><br>  <b>What input data do we have?</b> <br><br>  <b>Components</b> <br><br>  We have components, and I think everyone knows them. <br><br><img src="https://habrastorage.org/web/5c8/3c1/65d/5c83c165d08e4afcb968d58130f8c1a3.png" alt="angular2 compiler component"><br><br>  They have a template.  You can make the templates inline or put them in a separate file, it is worth remembering that they have context. <br><br>  Component instances are inherently the context, the data that is used to build a template.  In our case, we have a user, the user has a name (in our case, this is my name). <br><br>  <b>Template</b> <br><br>  Next we have a template.  This is simple HTML, here you can insert something like an input form, you can apply everything that HTML offers. <br><br><img src="https://habrastorage.org/web/8c2/478/e10/8c2478e1065647f5b344e72c20caca76.png" alt="angular2 compiler template"><br><br>  Here we have some new syntax: remember double curly brackets, square brackets and round brackets?  This is the binding of Angular to properties or events.  Today we will talk only about braces and what they mean.  From the point of view of semantics, this means "to take data from a component and place it in a certain place."  When data is changed, text should be updated. <br><br>  <b>Directives</b> <br><br><img src="https://habrastorage.org/web/ba5/1fc/b5b/ba51fcb5ba3246819c8e81d37a0425af.png" alt="angular2 compiler directives"><br><br>  Directives contain a selector - this is a CSS selector.  The bottom line is that when Angular passes the markup, if it finds a directive that matches an element, it executes it. <br><br>  Suppose we have a selector for forms, and with this we kind of say, every time we create a form element, please create this directive. <br><br>  Similarly with ngModel.  When you create the ngModel attribute, you must create a directive. <br>  These directives may have dependencies.  This is our expression of addiction. <br><br><img src="https://habrastorage.org/web/b01/ee8/ae4/b01ee8ae4c3441e794ea10b6dc453fc2.png" alt="angular2 compiler directives"><br><br>  The dependency has a hierarchical structure, so that ngModel requests ngForm. <br><br>  <b>And what does Angular do?</b> <br><br>  He scans the entire tree for the nearest ngForm, which is one level higher in the tree structure.  It will not view single-level items, only parent elements. <br><br>  There are other inputs, but we will not dwell on them in detail. <br><br>  Everything that is done in Angular passes through the compiler. <br><br>  Well, we have input.  The next thing we need is to understand them. <br>  Is it just a bunch of nonsense, or, after all, does it make any sense? <br><br><h3>  The process of lexical analysis </h3><br><h4>  First stage </h4><br>  Suppose we have some kind of template, for example, HTML. <br><br>  <b>Template view</b> <br><br><img src="https://habrastorage.org/web/e8a/103/e1b/e8a103e1b9214a31a3b278c3133a5751.png" alt="angular2 compiler template"><br><br>  How can we present it in such a way that the compiler can understand it? <br><br>  The analyzer is engaged in it.  He reads each character and then analyzes the meaning.  That is, he creates a tree.  Each element has only one object.  Suppose there is some name - the name of the element, there are child elements.  Let's just say a text node is a JSON object with text properties.  We also have item attributes.  Let's just say we encode it all as nested lists.  The first value is the key, the second is the value of the attribute.  And so on, there is nothing complicated.  Such a representation is called an abstract syntax tree (ASD, english - AST).  You will often hear this concept.  This is all HTML. <br><br>  <b>How can we portray the relationship of an element with data?</b> <br><br><img src="https://habrastorage.org/web/350/f9f/000/350f9f0003b844d2b450f24a3ea5dc14.png" alt="angular2 compiler template"><br><br>  We can display this as follows.  This is a text node, that is, we have a JSON object with text characteristics.  The text is empty because initially there is no text to display.  Text depends on incoming data.  Incoming data is presented in this expression. <br>  Any expressions are also analyzed for what they mean. <br>  You cannot declare a function inside expressions or use a for loop, but we have such things as pipes with which you can work with expressions. <br><br>  We can portray this expression, user.name, as a property path.  And also we can catch where this expression came from from your template. <br><br>  <b>Determination of the place of expression</b> <br>  So why is this so important?  Why is it important for us to know where exactly this expression came from? <br><br>  This is because we want to show you error messages at runtime.  Let's say that your user knows about these errors. <br><br>  And then, are there exceptions?  For example, it is impossible to read the name from undefined.  If this happens, then you need to go to the error debugger and check, set a breakpoint on the first error.  Then you must understand exactly where the error occurred. <br><br>  <b>Angular compiler gives you more information.</b> <br><br><img src="https://habrastorage.org/web/926/7b4/58e/9267b458e9784056a3c2ae14a5e9836b.png" alt="angular2 compiler template"><br><br>  It shows exactly where in the ‚Äúgrow legs‚Äù pattern of this error.  The goal is to show you that the error originates, for example, from this particular interpolation in the second row, column 14 of your pattern.  To do this, we need the row and column numbers to be in the SDA. <br><br>  <b>Next, what analyzers do we need to build this ASD?</b> <br><br>  There are many possibilities here.  For example, we can use a browser. <br><br>  The browser is a great HTML parser, right?  He does this every day.  We had this approach when developing Angular 1, we started using the same approach when developing Angular 2. <br><br>  Now we do not use the browser for such purposes for two reasons: <br><br><ol><li>  From the browser can not get the numbers of rows and columns.  When analyzing HTML, the browser simply does not use them. </li><li>  we want Angular to work on the server as well. </li></ol><br>  Obviously, there is no browser on the server.  We could say: in the browser we use the browser, and on the server we use something else.  So it was.  But then we got into dead ends, for example, with SVG, or with commas, so we needed to have the same semantics everywhere.  Therefore, it is easier to insert a fragment of JavaScript, and the analyzer.  This is exactly what we do. <br><br>  So we talked about HTML and expressions. <br><br>  <b>How do we present the directives we find?</b> <br><br>  We can display them through JSON objects that represent elements by simply adding another property: directives.  And we refer to the constructor functions of these directives. <br><br>  In our example with input data with ngModel, we can portray this element as a JSON object.  It has input name, attributes, ngModel and directives.  We have a pointer to constructors, and we also catch dependencies, because we need to specify that if we create ngModel, we need ngForm, and we need to pick up this information. <br><br>  Given the SDA with HTML information, links and guidelines, how do we bring this all to life?  How can this be done the easiest? <br><br>  First, let's deal with HTML.  What is the easiest way to create a DOM element?  First, you can use innerHTML.  Secondly, you can take an already existing item and clone it.  And third, you can call document.createElement. <br><br>  Let's vote.  Who thinks innerHTML is the fastest?  And who thinks element.cloneNode will create an element the fastest?  Or maybe the fastest way is element.createElement? <br><br>  Obviously, everything changes over time.  But for now: <br><br><ul><li>  innerHTML is the slowest option.  This is obvious, because the browser must call up its analyzer, take your string, go through each character and build the DOM element.  Obviously, this is very slow. <br><br><img src="https://habrastorage.org/web/6dd/bee/ac2/6ddbeeac290e4f86b015fc0c9d47ac81.png" alt="angular2 compiler innerHTML"><br><br></li><li>  element.cloneNode is the fastest way, because the browser already has a built projection, and it simply clones this projection.  It‚Äôs just adding another item to memory.  This is all you need to do. <br><br></li><li>  document.createElement is something between the two previous methods.  This method is very close to element.cloneNode.  Slightly slower, but very close. <br><br><img src="https://habrastorage.org/web/7ef/e9e/3ef/7efe9e3ef24a48b09ca365b84b214acc.png" alt="angular2 compiler createElement"><br></li></ul><br>  You say, "OK, let's use element.createElement to create a new DOM element." <br><br>  This is how Angular 1 worked, and we also started the development of Angular 2. And by tradition, it turns out that this is not a fair comparison, at least not in the case of Angular.  In the case of using Angular, we need to create some elements, but, in addition to this, we need to place these elements.  In our case, we want to create new text nodes, but we also need to find the one that is responsible for user.name, because later we want to update it. <br><br>  Therefore, if we compare, then we must compare both the creation and placement.  If you use innerHTML or cloneNode, then you have to re-traverse the entire path of the DOM.  When using createElement or createTextNode, you bypass these actions.  You simply call the method and immediately get its execution.  No new constructions and other things. <br><br>  In this regard, if we compare createElement and createTextNode, they are both about the same in speed (depending on the number of bindings). <br><br>  Secondly, much less data structures are required.  You do not need to keep track of all these indices and stuff, so these methods are simpler and almost equal in speed.  Therefore, we use these methods, and other frameworks also switch to this approach. <br><br>  So we can already create DOM elements. <br><br>  <b>Now we need to create directives</b> <br><br>  We need to inject dependencies from the child to the parent.  Suppose we have a data structure called ngElement, which includes a DOM element and directives for this element.  There is also a parent element.  This is a simple tree inside a DOM tree. <br><br><img src="https://habrastorage.org/web/31f/505/efd/31f505efd0194ee0ac146411cc6e180a.png" alt="angular2 compiler dependency hierarchy"><br><br>  <b>And how can we create DOM elements from ASD?</b> <br><br>  We have a template, we have an element from which we built an SDA.  What can we do with all this? <br><br><img src="https://habrastorage.org/web/746/49d/920/74649d920b9b465d8593ad3d6b6dd8e2.png" alt="angular2 compiler dependency hierarchy"><br><br>  In our ngElement and constructor, we call document.createElement, we look at the attributes and assign them to the elements, and then we add the element to our parent element.  As you can see, no magic. <br><br>  <b>Then go to the directives.</b>  <b>How it works?</b> <br><br>  We look at the bindings, somehow get them (talk about this a bit later) and simply re-call new for the constructor, give it bindings and save the Map.  Map will go from directive type (ngModel) to directive instances. <br><br>  And all this search for directives will work this way: we will have a method that receives a directive that first checks the element itself (if it has a directive).  If not, then go back to the parent and check there. <br><br>  This is the easiest thing to do.  We ourselves began in this direction.  And it works. <br><br>  <b>Important detail: bindings.</b>  <b>How to display bindings?</b> <br><br>  You simply create a binding class that has a target - Node.  It will be a text node. <br>  The target has a property, in our case it will be the value of the node, this is the place where the value fits.  And an expression. <br><br><img src="https://habrastorage.org/web/f20/699/960/f2069996054a407b8fe6c9bf8f281747.png" alt="angular2 compiler dependency binding"><br><br>  The binding works this way: every time you evaluate an expression or when it simply changes, you save it to the target. <br><br>  That is, you may have the following method: first, you evaluate the expression, if it has changed - then update the target and other previously saved values. <br><br><img src="https://habrastorage.org/web/334/6df/fcb/3346dffcbd144f5b879f359265fe94cd.png" alt="angular2 compiler dependency binding"><br><br>  As for the exceptions mentioned earlier, we call try catch methods to track the estimation path.  When an exception is thrown, we re-generate it and create a model for it from row and column numbers. <br><br>  So we get the row numbers and columns in which there are errors.  This is all we associate into a presentation.  This is the last data structure. <br><br><img src="https://habrastorage.org/web/0f5/89e/261/0f589e26115c46d286b1e1350ba7b403.png" alt="angular2 compiler view"><br><br>  A view is an element of a template.  That is, when we look at the error code - we will see a lot of views.  These are just template elements.  And we combine them into a presentation.  A view references a component, ng-elements and bindings, as well as a dirty-check method that scans bindings and checks them. <br><br>  So we finished the first stage.  We have a new compiler.  How fast are we?  Almost at the same level as Angular 1. Not bad at all.  Using the simpler approach, we achieved the same speed.  But Angular 1 is not slow. <br><br><h4>  Second stage </h4><br><br><img src="https://habrastorage.org/web/634/57f/b0a/63457fb0a7414f96865908d90622a4e1.png" alt="angular2 compiler dependency second step"><br><br>  How do we speed up the process?  What is the next step?  What have we missed?  Let's figure it out. <br><br>  We need something that is related to our data structures.  When it comes to data structures, in fact, this is a very difficult question.  If we compare with the last program we wrote, where try-catch appears, but if we discard it, we will see that many functions slow down the process and that many points need to be optimized.  If you consider the reason for the slow work of your data structure program, then this is a very difficult question, because they are scattered throughout your program.  This is just an assumption that the matter is in data structures. <br><br>  We conducted experiments and tried to figure it out.  We watched these directives: Map inside ngElements. <br><br><img src="https://habrastorage.org/web/dab/d68/ecd/dabd68ecd0864293a35933996281581f.png" alt="angular2 compiler dependency second step"><br><br>  It turns out that for each element in the DOM tree we create a new map?  One could say that there are no directives there, we did not create them.  But still, we always create a map, fill it with directives and read information from it.  It may be uneconomical, it may overload the memory, the reading still takes some time too. <br><br>  Alternative approach: you can say: ‚ÄúOkay, we only allow 10 directives for one item.  Next, we create an inlinengElement class, 10 properties for directive elements and directive types, and in order to find a directive, we create 10 conditional IF statements. ‚Äù  It's faster?  Maybe. <br><br>  <b>It does not consume a lot of memory resources, right?</b> <br><br>  For example, setting: you set the property, not the map.  Reading can be a bit slow due to 10 conditions.  This is exactly the case for which the JavaScript VM has been optimized.  JavaScript VM can create hidden classes (you can google them at your leisure).  This makes javascript js faster.  Switching to this data structure is what speeds up the processes.  Later we look at the results of performance tests.  Another thing that needs to be optimized for data structures is the reuse of existing instances. <br><br>  You can ask a logical question - If some lines are destroyed and others are restored, then why not cache these lines in the cache and change the data as soon as the lines appear?  So we did.  We created the so-called view cache, which restores old instances of views. <br><br><img src="https://habrastorage.org/web/454/e85/390/454e8539024c4cdaaf2fb0352be86a49.png" alt="angular2 compiler view cache"><br><br>  Before you go to the new pool, you need to destroy the state.  The state is contained in the directive.  So we kill all directives.  Further, when there is an exit from a pool, it is necessary to create these directives anew.  This is done by the methods of hydrate and dehydrate.  We retained the DOM nodes, since everything comes from the model, the entire status is in the model.  Therefore, we kept it.  And again we conducted a performance test. <br><br>  <b>Testing environment</b> <br><br>  So that you understand the results of these tests, it is worth noting that Baseline is a program with manual JavaScript code and hard coding.  In such a program, no frameworks were used; the program was written only for this deep-tree test.  The program performs dirtyChecking.  We took this program as a unit.  Everything else is compared in the ratio.  Angular 1 received a mark of 5.7. <br><br><img src="https://habrastorage.org/web/926/05e/7a8/92605e7a865f4719947d4d514925bd4b.png" alt="angular2 compiler benchmarks"><br><br>  Previously, we showed the same speed with optimized data structures and without view cache.  We were at the level of 2.7.  So, this is a good indicator.  We doubled the speed due to quick access to properties.  At first we thought that our work ends there. <br><br>  <b>Disadvantages of the second stage</b> <br><br>  We have created applications on this base.  But then we saw the flaws: <br><br><ol><li>  ViewCache is not good with memory.  Imagine you are switching query processing routes.  Your old requests remain in memory, because they are cached, aren't they?  The question is when to delete requests from the cache?  In fact, this is a very difficult question.  It would be possible to create several simple elements that would allow the user to choose whether to cache something or not.  But it would be, at least, strange. <br><br></li><li>  Another problem: DOM elements are hidden.  For example, the element is in focus.  Even if you do not have a focus binding, and the element can be both in focus and outside of it, its removal or return can change the focus of this or other elements.  We did not think about it.  There are related bugs.  It was possible to go this way: we could completely remove the elements, to remove their condition, and even restore them.  But that would nullify ViewCache if we had to recreate the DOM.  After all, we had a rate of 2.7.  How could we have reached speed in such a situation? </li></ol><br><h4>  Third stage </h4><br>  <b>Class view</b> <br><br>  Then a thought came to us: let's take another look at our view class.  What is there with us? <br>  We have a component - these are already optimized ngelement, right?  We have bindings.  But the view class still contains these arrays.  Can we create an InlineView that also uses properties only?  No arrays.  Is it possible  It turned out, yes. <br><br>  What does this look like?  Like that. <br><br><img src="https://habrastorage.org/web/2e1/d59/e10/2e1d59e10e1342bbbbb44c885122d5df.png" alt="angular2 compiler view"><br><br>  <b>Template</b> <br><br>  So, we, as before, will have a template, and for each element we will simply create code.  For this template, we will create code that displays our view class.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the constructor for each element, we call document.createElement, which will be stored in the Node0 property - for the first element, for the second, we will call document.createElement, which will be stored in Node1. Next, when we need to attach an element to its parent, we have properties, right? We just need to do everything in the right order. We can use the property to refer to the previous state. This is what we do with the DOM. </font></font><br><br><img src="https://habrastorage.org/web/f83/17f/a2f/f8317fa2fabe45bfa030655da2295737.png" alt="angular2 compiler template"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directives</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We do the same with directives. We have properties for each instance. And again, we just need to make sure that the order of actions is correct: that the dependencies come first, and then those components that use these dependencies. That we first use ngForm, and then - ngModel. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindings</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, bindings. We simply create code that performs dirty-check. We take our expressions, convert them back to JavaScript. In this case, it will be this.component user.name. This means that we pull user.name out of the component, compare it with the previous value, which is also a property. If the value has changed - we update the text node. In the end, we reduce everything to a view with a data structure. It has only properties. There are no arrays, Map, fast access through properties is used everywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This greatly speeds up the process. Soon I will show you the numbers so you can see this. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question is: how do we do it?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's say someone needs to create a string that evaluates this new class.</font></font> How it's done?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We simply apply what we did in implementation 101 in our current implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bottom line is this: If we previously created DOM nodes, we are now creating code to create DOM nodes. If earlier we compared elements, now we create code to compare elements. Finally, If we previously used directive instances or DOM nodes, we now store properties where directive instances and DOM nodes are stored. In this case, the code looks like this. </font></font><br><br><img src="https://habrastorage.org/web/532/6ed/332/5326ed3323fa4a8fb587a887a9687440.png" alt="angular2 compiler differences with first step"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, we had our ngelement, now we have a compileElement. In fact, these classes now exist in the compiler. There is a compileElement, compileView, and so on.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mapping will be like this: we used to have a DOM element, but now we only have a property in which the DOM element is stored. Previously, we called document.createElement, but now we create a string with this new string interpolation, which is great for creating code in which we say that this.document + the name of its property is equivalent to document.createElement called ASD. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, if earlier we called appendChild, now we are creating code to attach the child element to the parent element. The same thing happens with the search for directive dependencies. Everything happens according to the same algorithm, only now we are creating code for this purpose.</font></font><br><br><img src="https://habrastorage.org/web/34e/bb3/411/34ebb3411c6342639dada62c01e9abe4.png" alt="angular2 compiler differences benchmarks"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we now look at the indicators, we will see that now we have greatly increased the speed. If earlier our indicator was 2.7, now it is 1.5. It is almost twice as fast. ViewCache, as before, remains slightly faster. But we have excluded the option of using it, and you already know the reasons for our decision. We did a great job and could have finished.</font></font> But no. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic (Just in Time) compilation</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, at first we talked about dynamic (Just in Time) compilation. Dynamic means that we compile in the browser. </font></font><br><br><img src="https://habrastorage.org/web/ede/1f1/4c8/ede1f14c83d04db8b29c132a18b9d568.png" alt="angular2 compiler jit"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall that it works like this: you have any input data that is on your server. The browser loads and takes them, analyzes everything, creates the original view class. Now we need to evaluate this source code in order to get another class. After that we can create this class, and then we get a working application. There are certain problems with this part:</font></font><br><br><ol><li>    ,         .   - ,    ,    .     . ,    .   ,     .         . <br><br></li><li>   ‚Äì  ,      ,     Angular   . ,           ,    . <br><br></li><li>   ‚Äì   eval.   eval    , -  -    .      eval,    ,       . <br> (, ‚Äî        eval  <a href="https://habrahabr.ru/post/221937/"></a> ) <br><br></li><li>     ,            (,    ).   ,     ,         .     ,        Angular .    . <br><br></li><li>  ,    ,   .      (  ,     ,       ),  - ,    : <br><br><ol><li> -,    ,   ,     ,      . </li><li> -,     .  ,    ,        .  Closure    (  ¬´ ¬ª),     Google   . </li></ol></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, if we use improved minification while the compiler is running, this is what happens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are our components, our markup, loaded into the browser, the browser analyzes the template and creates the view class. So far, everything is going fine. The browser uses user.name, the component also contains user.name, just this user.name is minified using advanced minification technology. Thus, the component is called, say, C1, and my user suddenly turns out to be just U, and the name is N. The problem is that the minifier does not know about my template. After all, the template is still user.name.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the template is executed, still creates user.name, which simply does not exist in the component. There are certain solutions to this problem. You can tell the component that it is not necessary to minimize this property. But this is not what we need. We need to enable us to minify this property, but this will not work with real-time compilation and evaluation. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Static (Ahead of Time) compilation</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is for this reason that our next step was the appearance of a static (Ahead of Time) compilation. It works as follows. </font></font><br><br><img src="https://habrastorage.org/web/7a0/4e4/b15/7a04e4b151f74e4e9e6ff7eedc94c659.png" alt="angular2 compiler aot"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again we have input data that is analyzed on the server, and the view class is also created on the server.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the browser simply picks them up, loads them as plain script (as you load your regular JavaScript code), and then simply creates the necessary elements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This compilation method is great because: The analysis happens on the server (and therefore it is fast), the compiler does not need to be transferred to the browser (and this is also excellent). Also, we no longer use the assessment, because it is a script. Therefore, this compilation is suitable for any browser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, static compilation is great for improved minification, because now we create the view class on the server, and if we run the minifier, we can also minify our view classes. Now, when the minifier performs its work, we get the renamed properties in the classes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great, now we can use improved minification. </font><font style="vertical-align: inherit;">Therefore, our speed indicators have dropped even lower. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disadvantages of static compilation</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So now we have a static compilation. </font><font style="vertical-align: inherit;">Now everything is fine, yes? </font><font style="vertical-align: inherit;">But as always, there are drawbacks. </font><font style="vertical-align: inherit;">The first problem is that with static compilation, we need to create different code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For evaluation in the browser, you need to create code according to the standard ES5. </font><font style="vertical-align: inherit;">You create code that uses local variables, or that takes arguments passed to a function. </font><font style="vertical-align: inherit;">You do not use require.js or anything like that. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the code is generated on the server, it was necessary to generate TypeScript code for two reasons:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, we wanted to check the types of your expressions (whether they exist in the components). </font></font></li><li> -,       TypeScript.    ,     ,      .   ‚Äî        ,    require.js, system.js, Google Closure,     . </li><li>   ,       ES6 2016. </li></ul><br><img src="https://habrastorage.org/web/182/45a/edf/18245aedfa554cc29051e14183874045.png" alt="angular2 compiler aot output"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How did we manage to provide support for ES6 2016?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, if you are familiar with compilers, then there is a common pattern. Instead of creating rows, a data structure is created that is similar to the output, but this data structure, this ASD, can be serialized into different output data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASD contains features such as declaring a variable, calling methods, and so on, plus types. Then for ES5 we just serialize it all without types, and for TypeScript we serialize it with types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like this: our generated ASD output, inside the declared variables (we specify declare var name EL). This will create a var el code in TypeScript and create a type. In ES5, the type will be omitted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next we can call the method. First we read the document variable (since this is a global variable). And then for it we can call the createElement method with these arguments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We placed literal with a value of ‚Äúdiv‚Äù, because if you analyze strings, you must escape them correctly. The value may contain quotes, so when reading the code you need to screen them, skip. Therefore, this is the way we can do it. The good news is that now our generated code looks the same on both the server and the browser. No different parts of the code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second problem we encountered when developing a static compiler is the selection of metadata. Take a look at this code.</font></font><br><br><img src="https://habrastorage.org/web/c08/5e9/c00/c085e9c00f4a42e5ba3f1f8a475774af.png" alt="angular2 compiler aot decorator"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the problem with this code? </font><font style="vertical-align: inherit;">Let's say we have some kind of directive that has a dependency on cookies, and if you have cookies, the directive does something else.</font></font> It works.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can compile. </font></font> Super. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this does not work with static compilation. </font><font style="vertical-align: inherit;">If you think why? </font><font style="vertical-align: inherit;">If this is all down to the level of ES5, you will receive just such a code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does the decorator ultimately do? </font><font style="vertical-align: inherit;">It adds a property to your constructor for the metadata. </font><font style="vertical-align: inherit;">At the end, he simply adds SomeDir with notes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that if you run this on the server, it will not work. </font><font style="vertical-align: inherit;">After all, there is no document on the server.</font></font> What to do? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can offer to build a browser environment on the server, declare a document variable, a window variable, and so on. In some cases it will work, but in most cases it will not. The second method (we are now well versed in the ASD, right?) Is to process the ASD and remove the metadata from it without evaluating the code. In the ASD this can be represented somehow. </font></font><br><br><img src="https://habrastorage.org/web/e34/3d5/9e8/e343d59e819f48a185806df2067b82ab.png" alt="angular2 compiler aot decorator"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, our class SomeDir in the ASD may have a property decorators, which refers to the element that you call (this expression, where the directive plus the arguments are defined). The following happens. We pull metadata into JSON files, then our static compiler takes these files and creates a template from them. Obviously, there are limitations. We do not evaluate JavaScript code directly, so you can not do everything that you used to do in the browser.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, our static compiler limits us, but you can put a note. But if you use the above method, it will work in all cases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, let's look at performance tests again. </font></font><br><br><img src="https://habrastorage.org/web/e6d/379/5c7/e6d3795c7e9249abbc2eadfcc99e5d4c.png" alt="angular2 compiler aot benchmarks"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a simple program written by us. And the time of its loading has decreased very significantly. This is because we no longer perform the analysis, and also because the Angular 2 compiler no longer loads. It is almost three times faster. The size has also been reduced from the already mined ones in the gzip format, 144 kilobytes to 49. For comparison, the React library with improved minification weighs 46kb now. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now some illustrative examples.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppose we have an Angular component, we have ngForm and ngModel. ngModel has a ngForm as a dependency.</font></font><br><br><img src="https://habrastorage.org/web/efe/9b3/4ef/efe9b34efb7245f7ae388f60b6618cbb.png" alt="angular2 compiler examples"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add here NGC - these are _node modules that cover the TypeScript compiler, because when you pull out and support metadata, these modules depend on TypeScript. And if we look at the generated code, we will see that it looks very familiar. We have user.name. If its value changes, we update the input to the directive. We simply compare with the previous value and set it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a good side to this. Suppose in my template I change user.name to wrongName. Our template refers to user.name, not user. wrongName. Now, when we look at the generated code, TypeScript will generate an error.</font></font><br><br><img src="https://habrastorage.org/web/2d5/ead/ce1/2d5eadce14d94c75aa3a68a538fe5329.png" alt="angular2 compiler example generated code"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because these views have types based on the type of the component. And now when you compile them, you will discover the errors of your code, simply because we used TypeScript. We needed nothing else. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did well, but we strive to become even better. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our goal is to reach a size of 10 kb gzip. The size of some of our prototypes is 25 kb and I have a few ideas on how to make the compiler even smaller. Next, we want to be even faster than our starting point Baseline. We realize that this is not the limit, and we can be even faster than Baseline. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will not notice any changes. You will make changes, generate different code. The only thing - you will see the difference only in speed.</font></font><br><br><h3>  As a conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked about performance, about different aspects of performance. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We discussed input. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We learned what analysis is, ASD (AST). I talked about how we can present the template and how to implement it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We learned that document.createElement is great for the Angular framework. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We learned that quick access by properties and hidden classes are great tools for optimizing your code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We learned that code generation (if done correctly, that is, not only with the help of evaluation, but also with the support of offline, as well as output of the ASD) is an excellent and powerful thing. This will help you in generating hidden classes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked about static (Ahead Of Time) and dynamic (Just In Time) compilations, as well as things that can be optimized. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we looked at a good example. </font><font style="vertical-align: inherit;">On the slide there is a link to my presentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you so much for your attention.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links to materials</font></font></b> <div class="spoiler_text">   ‚Äî <a href="https://www.youtube.com/watch%3Fv%3DkW9cJsvcsGo">Angular 2 ‚Äî How it works</a> <br>  ‚Äî <a href="https://docs.google.com/presentation/d/11ZQxzb-Pr28pVRKIl-54PHEMM7SXc-lf_RQ6dQWyz1A/preview%3Fslide%3Did.g136bc68113_0_725">Angular2 Compiler ‚Äî Tobias Bosch</a> <br>    ‚Äî <a href="https://twitter.com/tbosch1009">Twitter Account ‚Äî Tobias Bosch</a> </div></div></div><p>Source: <a href="https://habr.com/ru/post/329782/">https://habr.com/ru/post/329782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329772/index.html">Designing and developing a template engine in C # and ANTLR</a></li>
<li><a href="../329774/index.html">Biometrics: not as difficult as it seems</a></li>
<li><a href="../329776/index.html">Why it was worth visiting OS Day 17</a></li>
<li><a href="../329778/index.html">Brief history of random numbers</a></li>
<li><a href="../329780/index.html">Chrome won</a></li>
<li><a href="../329784/index.html">Node.js and cote: simple and convenient development of microservices</a></li>
<li><a href="../329786/index.html">WebVR: the rebirth of virtual reality</a></li>
<li><a href="../329788/index.html">HexRaysPyTools: decompile with pleasure</a></li>
<li><a href="../329792/index.html">SCCM Inventory</a></li>
<li><a href="../329794/index.html">Once again about storing logs in Zabbix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>