<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Decorative decorative lamp SDB-Z "Evlampiya"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Honestly, I do not remember how it all began. Suppose I was bored again and wanted some light even at the end of the tunnel, at least at the beginning...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Decorative decorative lamp SDB-Z "Evlampiya"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d11/78c/bbc/d1178cbbcbc24064aba195298716d972.JPG"><br><br>  Honestly, I do not remember how it all began.  Suppose I was bored again and wanted some light even at the end of the tunnel, at least at the beginning.  Little by little, the desire took shape in the night light, which is switched on with a wave of the hand.  And later it was transformed into a decorative lamp with adjustable brightness, various hues of luminescence and all sorts of additional functions.  Namely, temperature display overboard and control of lighting in the room. <br><br>  And it all came out of the cheapest IKEA interior lamp, a couple of meters of LED tape, an Arduino, and a small handful of modules and components. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Meet Evlampiya </h4><br>  I would like some kind of official language like the ‚ÄúEvlampiya‚Äú SDB-3 lamp ‚Äùis intended for use for decorative purposes inside residential premises‚Äù, but then it will be necessary to write about strict adherence to the instruction, which is absent.  Therefore, I will be easier, especially since this is the basic principle of managing Evlampii. <br><br>  . <br><img src="https://habrastorage.org/files/cca/f08/dc3/ccaf08dc34574d9bb8ddbb1ca91b7378.JPG"><br><br>  So that she can: <br><br>  1) <b>To work as a nightlight</b> .  The light turns on and off with a horizontal wave of the hand above the lamp. <br><br>  2) <b>Work lamp background light</b> .  Brightness is regulated by the vertical movement of the hand above the lamp. <br><br>  3) <b>Show the temperature outside</b> .  More precisely - to visualize the range of temperatures.  Each range - its shade.  Receives data from the weather sensor on the radio. <br><br>  4) <b>Work as a decorative lamp with a manual tint change</b> .  The hue is changed by the vertical movement of the hand above the lamp. <br><br>  5) <b>Work as a decorative lamp with a cyclical change in shade</b> . <br><br>  6) <b>Control the light in the room *</b> .  Holding your hand at a certain height in normal lamp mode switches the background and overhead lights.  And if you cover the lamp with your palm, then after three seconds all the upper light in the apartment and the background light in the room are turned off altogether. <br><br>  * Controls Livolo switches and radio outlets with SC / PT2260 / 2262 chips and the like with fixed code. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/u86D-egP_xk%3Ffeature%3Doembed&amp;xid=17259,15700023,15700043,15700186,15700190,15700253&amp;usg=ALkJrhhxX26d9LCbdHjVJDSRwgPi01nQ8A" frameborder="0" allowfullscreen=""></iframe><br><br>  As you might have guessed, the lamp is controlled by horizontal and vertical movements.  At the same time, a horizontal swing or controls the nightlight, or switches in a circle modes (lamp, thermometer, manual rainbow, automatic rainbow). <br><br>  This is explained by the fact that I wanted to somehow get away from all kinds of consoles, switches and other Wi-Fi.  So that, you know, light and shades depended on, so to speak, manual dexterity.  The hand, of course, is conditionally mentioned - any obstacle will do.  But since people usually have hands, not obstacles, in the future - a hand. <br><br>  Given this specificity, I also chose the sensor - the Sharp infrared range finder, about which some individuals write that the target device is an automatic urinal, while others are wondering what kind of urinal this is, if some sensors in the family have a maximum working distance of about 40 cm. On the other hand, I know for sure that these sensors are used in vacuum cleaning robots to prevent collisions with obstacles. <br><br>  Not the point. <br><br>  The working distance of the selected sensor is 80 cm (although in fact it seems to be much more), and the output voltage is the higher, the closer the object.  But as the obstacle approaches, there is a threshold after which the voltage will go down, despite the fact that the obstacle is getting closer.  It is unpleasant, but not fatal, especially since in my case it is about 4 centimeters, which can be compensated for by ‚Äúdigging‚Äù the sensor into the design. <br><br>  After selecting the sensor, I suddenly realized that I just didn‚Äôt have enough light.  I wanted a rainbow, and many other buns - since all the same in the lamp will be a controller, the resources of which are almost not used.  So in the list of components appeared LED RGB-tape instead of simple, 433 MHz receiver and transmitter, as well as a transistor assembly to control the tape.  The latter seemed to me more attractive than just a few field effect transistors, do not ask why. <br><br>  To not remain unclear points.  The receiver is needed to obtain data on temperature and external commands - after all, it would be foolish to miss the opportunity to turn the lamp on and off with the background lighting console.  The transmitter is necessary for controlling the external light: the background one based on the usual radio-controlled outlets and the top one via the radio-controlled Livolo switches. <br><br><h4>  Accessories </h4><br>  In short, I had an IKEA lamp, an Arduino Pro Mini debug, a prototype board, a Sharp distance sensor, a 433 MHz amplitude modulated transmitter and receiver, an RGB LED tape, a can of beer, a bottle of drinking water, a box of tooth powder, a 9V power adapter, a handful of fasteners and some wires.  Not that this was enough to revive the Mir space station, but it was enough for Evlampia. <br><br>  So (links for example only): <br><br>  - <a href="http://www.ikea.com/ru/ru/catalog/products/90242189/">KVARNE</a> lamp; <br><br>  - Infrared distance sensors <a href="http://www.aliexpress.com/item/Free-Shipping-1PC-GP2Y0A2YK-IR-Infrared-Range-Sensor-With-Cable-For-Arduino-Sharp/1815373464.html">Sharp GP2Y0A21YK</a> , and then immediately <a href="http://www.sharpsma.com/webfm_send/1208">datashit</a> ; <br><br>  - <a href="http://www.dx.com/p/433mhz-superheterodyne-low-power-consumption-wireless-receiving-module-yellow-black-256198">The 433 MHz receiver</a> is superheterodyne because I was disappointed in the regenerative receivers.  Either because they are, or because I cannot make an antenna normally; <br><br>  - <a href="http://www.dx.com/p/zsd-t3-315-433mhz-ask-high-power-rf-transmitter-module-yellow-228289">The 433 MHz transmitter is</a> subjective - quite decent and, moreover, already with an antenna; <br><br>  - <a href="http://www.ebay.com/itm/New-ATMEAG328-5V-16Mhz-Replace-ATmega168-For-Arduino-Pro-Mini-Compatible-Nano-/191117208428%3Fpt%3DLH_DefaultDomain_0%26hash%3Ditem2c7f792b6c">Arduino Pro Mini</a> ; <br><br>  - Transistor Assembly <a href="http://www.chipdip.ru/product/uln2003a/">ULN2003A</a> ; <br><br>  - RGB LED strip - to taste, I bought offline; <br><br>  - The network adapter is also to the taste, I had some old 9V lying around (although it would probably be better to use 12V - because the tape is 12V); <br><br>  - Aluminum can with a capacity of 0.5 liters from under any drink; <br><br>  - Plastic bottle with a diameter under the inner diameter of the aluminum can; <br><br>  - Bank of tooth powder with a diameter for the internal diameter of the lamp.  <a href="http://www.lekarctva.ru/card/zubnoy-poroshok-osobiy-banka-140g/70001304/">It looks like this</a> (I bought in a store near the house); <br><br>  - Development board, installation wires - to taste; <br><br>  - Optional: 10 ŒºF capacitors, 0.1 ŒºF, 10 kŒ© resistor. <br><br><h4>  Scheme </h4><br><br>  Capacitors and pull-up resistor are optional, and are not shown in the diagram.  I used them within the company to combat false positives, but in the end it turned out that phantom potentials had nothing to do with it. <br><br>  .  I hope that more or less correctly painted. <br><img src="https://habrastorage.org/files/a7b/839/d64/a7b839d64058489b9a432507fe16c920.jpg"><br><br>  .  And so it looks like what happened according to the scheme.  Sorry to be ugly.  I am sure you will be better! <br><img src="https://habrastorage.org/files/75f/785/55e/75f78555e7d243528cf61e786ae8b537.JPG"><br><br>  Be sure to pay attention to the power of the IR sensor and receiver.  They need no more than 5V, so they eat from the Arduino stabilizer, and not directly from the power supply. <br><br><h4>  Miracle of miracles </h4><br>  The assembly of all this into a single whole turned out to be an absolutely incredible occupation.  At least, starting with the fact that in addition to the IKEA lamp, you also needed a plastic bottle with a capacity of 0.5 liters, an aluminum can of the same container from under any beverage, and a plastic can of tooth powder.  This is because the following concept arose in my head: RGB-tape is glued to an aluminum can.  It turns out a certain analogue of the famous Chinese "corn", which is placed inside the ceiling of the lamp. <br><br>  .  source lamp, carefully divided <br><img src="https://habrastorage.org/files/c17/5ea/02e/c175ea02eda14250aec6c084c17129b3.JPG"><br><br>  The bank here is needed to serve as a kind of heat sink and means to observe the geometry of the light emitter thus designed.  According to the plan of the creator (ie me), the management board fits into the bank.  But since the bank is metal, we protect ourselves against short-circuit conditions primitively: we lay inside a pre-cut plastic bottle that serves as an insulator. <br><br>  Hence the law of Evlampii: the outer diameter of the bottle should not exceed the inner diameter of the can. <br><br>  As for the can of tooth powder, it was required, first, to more or less aesthetically cover the top of the lamp from dust and curious glances.  And at the same time - it is convenient to fix the sensor and place the receiver with the transmitter.  Indeed, inside the metal can they have little chance of productive activity. <br><br>  Other wonders in order: <br><br><ul><li>  a couple of meters of LED strip bought at random was just enough to wrap a can </li><li>  a jar with a carefully cut off tip perfectly fitted into the lamp </li><li>  bottle insulator perfectly fit in the bank </li><li>  a can of powder tooth in diameter almost fit into the inner diameter of the ceiling.  ‚ÄúPractically‚Äù in this case means that there are minor violations of the geometry of the lid, which are partly due to the fact that the can body is still compressed, and partly because there was a hole in the can lid for the IR sensor. </li></ul><br><br>  .  something like this deformation <br><img src="https://habrastorage.org/files/e1c/9ab/63c/e1c9ab63cdc04d4c8aa614644e995755.JPG"><br><br>  "Kukuruzina" is attached to the cover in the lower point of it by regular fastening of the cartridge.  Of course, ‚Äúextra‚Äù elements had to be broken off from this attachment, but the fact remains. <br><br>  In my version, the build process is: <br><br>  1) Cut the top of the aluminum can and cut a hole in its bottom corresponding to the diameter of the hole in the nut that secures the lamp holder.  We glue the nut to the bottom of the jar - in the future, all of it will be wound on the fastening of the cartridge. <br><br>  .  like this <br><img src="https://habrastorage.org/files/bcf/1ec/f70/bcf1ecf707114160a7faf4725fdcd139.jpg"><br><br>  2) From the fastening of the cartridge, we remove the cartridge itself and parts that interfere with the insertion of a wire with a plug to power the controller through the hole. <br><br>  . <br><img src="https://habrastorage.org/files/da0/114/557/da01145574584de1a8d6cf5ee44406af.JPG"><br><br>  3) Here I would have to carefully cut off the bottom of the bottle and cut off its nose so that on one side this spout, being placed close to the bottom of the can, would prevent the controller from contacting metal walls, and on the other, that the bottle would not protrude beyond the can height.  But since I made a mistake twice, I finally put the bottom of the bottle on the bottom of the jar (with a hole, of course, and the top (with an overly cut nose down) - the rest of the bottle. <br><br>  . <br><img src="https://habrastorage.org/files/39c/4df/965/39c4df96566f4603bb984e343b0d381d.JPG"><br><br>  4) We glue the LED strip around the can so as to create a sufficient density of LEDs and at the same time fit the length (2 meters).  Glue from the bottom of the banks, feeding wires up to then lower them in the bank to the controller. <br><br>  . <br><img src="https://habrastorage.org/files/cc3/a2b/cb3/cc3a2bcb338943d18572a02297289bcf.JPG"><br><br>  5) In a clean can of tooth powder, we make two large holes.  In the bottom and in the lid, both under the sensor.  The holes must be at least the diameter of the sensor.  In the bottom, the hole can be almost any shape, but optimally rectangular, because next to it you need to make a couple of smaller holes - for the sensor mounting studs.  It was convenient for me to make a round one in the lid, since it was actually marked up with factory stamping, and I neatly cut it out with an ordinary stationery-painting knife. <br><br>  .  At first I drilled two round holes for the sensor, but when it turned out that it had to be moved away from the edge of the can, I had to arrange a real ‚Äúfailure‚Äù, otherwise I would get a reflection from the bottom of the can <br><img src="https://habrastorage.org/files/69b/5b4/475/69b5b44758c747f3961d056bc26800c7.JPG"><br><br>  Carefully ream the sensor holes under the M4 (if there is an M3 fastener - take it and do not drill anything) and fit it on the screws, fixing with nuts. <br><br>  . <br><img src="https://habrastorage.org/files/bda/f9d/ce0/bdaf9dce07a54c18b772b796aaa298fb.JPG"><br><br>  Screw the screws over the nut and pass them into the holes in the bottom of the jar, and on top - even on the nut.  This design allows you to mechanically adjust the position of the sensor for fine adjustment of the base level.  Looking ahead - the base level is the level at which Evlampiya believes that she was covered with a hand, and you need to turn off everything. <br><br>  . <br><img src="https://habrastorage.org/files/3cb/fa1/d7c/3cbfa1d7c8aa4e4aa0a3d08f6107624b.JPG"><br><br>  The bank will also require holes for the 433 MHz receiver and transmitter wires, which also need to be more or less carefully placed there. <br><br>  6) We connect to the controller LED strip, IR sensor, 433 MHz receiver and transmitter.  We pass through the power supply cable into the ceiling and also connect it to the controller. <br><br>  .  here you can see partially a rectangular hole in the bottom of the ‚Äúdental‚Äù can <br><img src="https://habrastorage.org/files/410/d81/bc2/410d81bc233841d288db6425ae890fed.JPG"><br><br>  7) We put the controller in the corn, close the entire structure with a can of tooth powder. <br><br>  eight) ?!!! <br><br>  9) PROFIT !!! <br><br><h4>  Algorithm </h4><br>  Here I tried to portray the algorithm of the Evlampia function core, excluding radio control.  Also, this algorithm is part of an infinitely executable loop. <br><br><img src="https://habrastorage.org/files/646/3a7/2ef/6463a72efdbd479bb277f0adad0356e7.png"><br><br><h4>  Code </h4><br><br>  In addition to the code, you will need two libraries: <br><br><ul><li>  <a href="https://code.google.com/p/rc-switch/">RC Switch</a> </li><li>  <a href="https%253A%252F%252Fdrive.google.com%252Ffile%252Fd%252F0B0DQ7La4EBHlU2ltTmlmeHhya3M%252Fedit%253Fusp%253Dsharing%26ei%3DXqyIVKnYBcv8UIXUgagK%26usg%3DAFQjCNFU-YuHHoOuUCMfhfpfhvdDXPD5rg%26sig2%3DsSvYD5sT0_Wi3xASSEUAgA%26bvm%3Dbv.81456516,d.d24">Livolo</a> </li></ul><br><br>  You will also need to first empirically find out, and then in the variables section, set the working range of the sensor, depending on how you place it. <br><br>  These are the variables <b>top</b> and <b>bottom</b> , marked with comments ‚Äútop of the zone of adjustment‚Äù and ‚Äúbottom of the zone of adjustment‚Äù. <br><br>  There are also debug lines left in the code - you can enable them if necessary. <br><br>  ps until Evlampiya gets the temperature, in the display mode it flashes in three colors in succession and switches to the next mode. <br><br><div class="spoiler">  <b class="spoiler_title">All that is acquired by overwork</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// beta 3 -           // beta 4 -       ,     // beta 4 -         // beta 4 -   : /* -35 - -25  0 -25 - -15  15 -15 - 0 - 50 0 - 15 - 85 15 - 20 100  20 - 25 - 170 25 - 30 - 235 30+  254 // : if (colorV &lt; 100) { targetR = colorV*0.05; } else { targetR = 5+(colorV-100)*1.29; } //  if (colorV &lt; 75) { // 0 - 180 targetG = 2.4*colorV; } if (colorV &gt; 75 &amp;&amp; colorV &lt; 100) { // 180 - 254 targetG = 180 + (colorV-75)*2.96; } if (colorV &gt; 100 &amp;&amp; colorV &lt; 150) { // 254 targetG = 254; } if (colorV &gt; 150 &amp;&amp; colorV &lt; 200) { // 254 - 154 targetG = 254 - (colorV-150)*2; } if (colorV &gt; 200) { // 154 - 0 targetG = 154 - (colorV-200)*2.85; } //  if (colorV &lt; 100) { targetB = 254 - colorV*2.54; } else { targetB = colorV*0.05; } */ #include &lt;RCSwitch.h&gt; //   SC2260/2262 http://code.google.com/p/rc-switch/ #include &lt;livolo.h&gt; //   Livolo #define txPin 8 //   Livolo livolo(8); //  Livolo RCSwitch mySwitch = RCSwitch(); //  RC-Switch int weatherData = 0; unsigned long dimmerDelay, timerStart, timerStop, timerSwitchStart, timerSwitchStop, timerRange; //  int prevRange, nowRange, tempRange, switchRange, vectorRange, initRange, rangeFinder, tempC; byte nightLightLevel, rainbow, delta, redB, greenB, blueB, targetL, targetR, targetG, targetB, lastValueRGB; byte lightMode = 0; //   (0 - , 1 - , 2 - , 3 -  , 4 -  ) byte lastMode = 1; //       byte valueRGB = 0; //    (  nowRange) boolean rainbowUp, followMeLight; //   boolean timing = false; //    (  ) boolean switchLock = false; //           boolean tempLock = false; //          boolean backLight = false; //     boolean mainLight = false; //     boolean nightLight = false; //    boolean tempRcvd = false; //    #define nightLightLimit 65 //   #define rangePin A0 //   #define redPin 9 //  #define greenPin 10 //  #define bluePin 11 //  #define bottom 630 //    #define top 135 //    #define delta 20 //      #define shortDelay 350 //     #define longDelay 3000 #define timeOutRange 100 //         ""   ,       #define rainbowStep 75 //     #define dimmerStep 35 //    void setup() { // Serial.begin(9600); pinMode(rangePin, INPUT); pinMode(redPin, OUTPUT); pinMode(greenPin, OUTPUT); pinMode(bluePin, OUTPUT); mySwitch.enableTransmit(txPin); //   mySwitch.enableReceive(0); //   ( 0 -&gt;  2) rgbLight(0, 0, 0); //    lastMode = 1; //       timerRange = millis(); //       nowRange = getRange(); //    } void loop() { //    if ((millis() - timerRange) &gt; timeOutRange) { //     timeOutRange prevRange = nowRange; //     nowRange = getRange(); //    timerRange = millis(); //      // Serial.print("Range: "); // Serial.println(nowRange); } //   --      ( ),   -   ( ) if ((nowRange &lt; bottom + delta) &amp;&amp; (nowRange &gt; top)) { //         if (nowRange &gt; bottom - delta) { //    ""         (2*delta) valueRGB = 0; } else { valueRGB = 254 - map(nowRange, top, bottom, 0, 254); //      0 - 254  "" } // Serial.print("valueRGB: "); // Serial.println(valueRGB); //         if (lightMode == 1) { //    if (valueRGB &gt; 70 &amp;&amp; valueRGB &lt; 110) { //       followMeLight = true; //      ,     lastValueRGB = valueRGB; //     rgbLight(0, 255, 0); //       ""  // Serial.println("Set Green to 255"); } else { if (valueRGB &gt; 175 &amp;&amp; valueRGB &lt; 215) { //       followMeLight = true; lastValueRGB = valueRGB; //     rgbLight(0, 0, 255); //       ""  // Serial.println("Set Blue to 255"); } else { if (valueRGB &gt; 235) { //      followMeLight = true; lastValueRGB = valueRGB; //     rgbLight(valueRGB, 0, 0); //        // Serial.println("Set RED"); } else { lastValueRGB = valueRGB; followMeLight = false; } } } } //    if (timing == false) { //     timerStart = millis(); //      timerSwitchStart = millis(); //      timing = true; //    } if (timing == true) { //        (  ) //        tempRange = nowRange - prevRange; //         if (abs(tempRange) &gt; delta) { //     timerStart = millis(); //     } if ((millis() - timerStart) &gt; longDelay) { //          //   if (lightMode == 0 &amp;&amp; switchLock == false) { //     -      lightMode = lastMode; switchLock = true; //        } //   (        ) if (lightMode == 1 &amp;&amp; switchLock == false) { //    //    if ((nowRange &gt; (bottom/2)) &amp;&amp; (nowRange &lt; (bottom - 2*delta))) { //      ,     +4*delta // // Serial.print("Backlight mode (nowRange): "); // // Serial.println(nowRange); // // Serial.print("backLight:"); // // Serial.println(backLight); if (backLight == false) { //     //    mySwitch.send(863029, 24); //   backLight = true; switchLock = true; // // Serial.println("Backlight ON"); // // Serial.print("backLight:"); // // Serial.println(backLight); } else { //     //    mySwitch.send(863028, 24); //   backLight = false; switchLock = true; // // Serial.println("Backlight OFF"); // // Serial.print("backLight:"); // // Serial.println(backLight); } } //    if ((nowRange &lt; (bottom/2)) &amp;&amp; (nowRange &gt; top)) { //      ,     /* // Serial.print("Main light mode (nowRange): "); // Serial.println(nowRange); // Serial.print("mainLight:"); // Serial.println(mainLight); */ if (mainLight == false) { //     //    livolo.sendButton(8500, 0); //    livolo.sendButton(8500, 96); //    mainLight = true; switchLock = true; /* // Serial.println("Main light ON"); // Serial.print("mainLight:"); // Serial.println(mainLight); */ } else { //     //    livolo.sendButton(8500, 0); //    livolo.sendButton(8500, 96); //    mainLight = false; switchLock = true; /* // Serial.println("Main light OFF"); // Serial.print("mainLight:"); // Serial.println(mainLight); */ } } } //        if (nowRange &gt; (bottom - delta)) { //     (2*delta) // Serial.print("Full off mode (nowRange): "); // Serial.println(nowRange); if (lightMode &gt; 0 &amp;&amp; switchLock == false) { //      blinkLight(150); rgbLight(0, 0, 0); //   livolo.sendButton(8500, 106); //    mySwitch.send(863028, 24); //   mainLight = false; backLight = false; lastMode = lightMode; //    lightMode = 0; //   switchLock = true; //      } } } // &gt; longDelay } // timing = true //    if (lightMode == 1) { if (followMeLight == false) { //      ,     // Serial.println("Brightness control"); rgbLight(valueRGB, valueRGB, valueRGB); } } //   if (lightMode == 3) { if (valueRGB &gt; 0) { //   colorRGB(valueRGB); } else { rgbLight(0, 0, 0); //       } } } // nowRange &gt; bottom //     ,    if ((nowRange &lt; (top + delta))) { if (timing == true) { //       if (lightMode == 1) { rgbLight(lastValueRGB, lastValueRGB, lastValueRGB); //          followMeLight = false; } unsigned long millistart = millis() - timerSwitchStart; if (millistart &lt; shortDelay) { //     //     if (lightMode == 0 &amp;&amp; switchLock == false) { //    if (nightLight == false) { //    nightLightLevel = 0; nightLight = true; //   } else { nightLightLevel = nightLightLimit; nightLight = false; //   } dimmerDelay = millis(); //      } //   if (lightMode &gt; 0) { //    lightMode = lightMode + 1; //   blinkLight(150); if (lightMode == 4) { //    dimmerDelay = millis(); //      if (nowRange &lt; 255) { //     rainbow = nowRange; rainbowUp = true; } else { rainbow = 254; rainbowUp = false; //   } } if (lightMode == 3) { //    -    colorRGB(valueRGB); } if (lightMode == 2) { if (tempRcvd == true) { colorRGB(tempC); //         } else { noTemp(); } } if (lightMode &gt; 4) { //    lightMode = 1; } } } // &lt; longDelay } // timing = true timing = false; switchLock = false; //            } // nowRange &lt; bottom + delta if (nightLight == true &amp;&amp; nightLightLevel &lt; nightLightLimit) { //   ,     if ((millis() - dimmerDelay) &gt; dimmerStep) { //     dimmerStep  nightLightLevel++; rgbLight(nightLightLevel, nightLightLevel, nightLightLevel); dimmerDelay = millis(); //      } } if (nightLight == false &amp;&amp; nightLightLevel &gt; 0) { //   ,     if ((millis() - dimmerDelay) &gt; dimmerStep) { nightLightLevel--; rgbLight(nightLightLevel, nightLightLevel, nightLightLevel); dimmerDelay = millis(); //      } } //   if (lightMode == 2) { if (valueRGB &gt; 0) { //        if (tempRcvd == true) { if (tempLock == false) { //       colorRGB(tempC); //         tempLock = true; //        } else { noTemp(); } } } else { rgbLight(0, 0, 0); tempLock = false; } } //  if (lightMode == 4) { if (valueRGB &gt; 0) { //        if ((millis() - dimmerDelay) &gt; rainbowStep) { // Serial.print("Rainbow value: "); // Serial.println(rainbow); if (rainbowUp == true) { if (rainbow &lt; 254) { rainbow++; } else { rainbowUp = false; } } if (rainbowUp == false) { if (rainbow &gt; 1) { rainbow--; } else { rainbowUp = true; } } colorRGB(rainbow); dimmerDelay = millis(); } } else { rgbLight(0, 0, 0); } } if (mySwitch.available()) { //     int value = mySwitch.getReceivedValue(); if (value != 0) { //     if (lightMode == 0) { if (mySwitch.getReceivedValue() == 863029) { lightMode = 1; rgbLight(254, 254, 254); switchLock = true; } } //     if (mySwitch.getReceivedValue() == 863028) { rgbLight(0, 0, 0); //   mainLight = false; //        backLight = false; if (lightMode == 0) { lastMode = 1; } else { lastMode = lightMode; //    } lightMode = 0; //   switchLock = true; //      } if (mySwitch.getReceivedValue()/100000 == 161) { weatherData = mySwitch.getReceivedValue() - 16100000; if (weatherData &lt; 10000) { //    if (weatherData &gt; 1000) { //   if (weatherData &gt; 1250) { //   -25 tempC = 0; } if (weatherData &lt; 1250 &amp;&amp; weatherData &gt; 1150) { //  -25 -- -15C tempC = 15; } if (weatherData &lt; 1150) { //  -15C -- 0C tempC = 50; } } else { //   if (weatherData &gt; 300) { //    +30 tempC = 254; } if (weatherData &gt; 250 &amp;&amp; weatherData &lt; 300) { //   +25C -- +30 tempC = 235; } if (weatherData &gt; 200 &amp;&amp; weatherData &lt; 250) { //   +25C -- +30 tempC = 170; } if (weatherData &gt; 150 &amp;&amp; weatherData &lt; 200) { //   +15C -- +25 tempC = 100; } if (weatherData &lt; 150) { //    +15 tempC = 85; } } tempRcvd = true; tempLock = false; //     // tempC = tempC*0.363; //      0  255 // Serial.print("TempC: "); // Serial.println(tempC); } } mySwitch.resetAvailable(); } } } // loop void rgbLight(byte redL, byte greenL, byte blueL) { analogWrite(redPin, redL); analogWrite(greenPin, greenL); analogWrite(bluePin, blueL); } void colorRGB(int colorV) { // : if (colorV &lt; 100) { targetR = colorV*0.05; } else { targetR = 5+(colorV-100)*1.29; } //  if (colorV &lt; 75) { // 0 - 180 targetG = 2.4*colorV; } if (colorV &gt; 75 &amp;&amp; colorV &lt; 100) { // 180 - 254 targetG = 180 + (colorV-75)*2.96; } if (colorV &gt; 100 &amp;&amp; colorV &lt; 150) { // 254 targetG = 254; } if (colorV &gt; 150 &amp;&amp; colorV &lt; 200) { // 254 - 154 targetG = 254 - (colorV-150)*2; } if (colorV &gt; 200) { // 154 - 0 targetG = 154 - (colorV-200)*2.85; } //  if (colorV &lt; 100) { targetB = 254 - colorV*2.54; } else { targetB = colorV*0.05; } rgbLight(targetR, targetG, targetB); } void blinkLight(byte spark) { for (byte i = 0; i &lt; 3; i++) { rgbLight(0, 0, 0); delay(75); rgbLight(spark, spark, spark); delay(75); } } unsigned int getRange(){ byte i; unsigned int rangeFinder = 0; for (i = 0; i &lt; 100; i++) { rangeFinder = rangeFinder + analogRead(rangePin); } rangeFinder = rangeFinder/100; return rangeFinder; } //    void noTemp() { rgbLight(254, 0, 0); //    delay(500); rgbLight(0, 254, 0); delay(500); rgbLight(0, 0, 254); delay(500); blinkLight(150); //   lightMode = 3; //     }</span></span></code> </pre> <br></div></div><br><br><h4>  Special features </h4><br>  Which is typical, the lamp turned out, as usual, despite the fact that I am already a scientist.  In other words, I did not collect anything entirely until I checked the work in all modes.  Works. <br><br>  Then I put everything in the case and again checked the work in all modes.  Works. <br><br>  Left a day for surprises.  There were no surprises.  works. <br><br>  Put on the bedside shelf.  The lamp has gone mad.  Namely: if it was in the nightlight mode, it began to turn on and off continuously;  if she was in luminaire mode, she constantly switched modes.  To my misfortune, I compared these problems with the location of the power wire and the location of the relative battery lamp.  I thought that these were potential sources of interference that could affect the operation of the sensor and the microcontroller. <br><br>  Then the lamp then worked fine, it did not work.  To return it to work, I constantly twisted it and the wire;  I bought an APC network filter socket, put 10 ŒºF and 0.1 ŒºF capacitors in parallel with the sensor power supply and pulled up the controller input, to which the sensor is connected to ground through a 10 kŒ© resistor.  Nothing helped, but it was embarrassing that the lamp went crazy at arbitrary points in time.  In the end, I took the will into a fist and disassembled the structure to see what was going on in her soul. <br><br>  While acquainting myself with the rich inner world of Evlampia, he accidentally turned the sensor and found that although the distance to the nearest object was more than 80 centimeters, the sensor readings changed.  And here I understood a lot.  Moreover, if you recall my mention of this sensor in robots, it is surprising that I did not immediately think about it. <br><br>  So, the sensor responds differently to various obstacles.  For example, a light wall or a dark door, judging by the behavior of the robot vacuum cleaner, are very different things.  But the cat - generally akin to a black hole.  In other words, when I first launched Eulampia in test mode, I set the limits of the working range of the sensor for a specific place - where, in fact, I checked.  But on the bedside shelf everything turned out differently. <br><br>  In general, after I changed the upper limit of the range, Evlampia became completely obedient. <br><br>  The second feature is the realization of the rainbow (northern lights).  Since I am not a mathematician at all, I just figured out exactly how to mix colors, and built a graph from the corresponding segments.  The attentive observer will note that the lamp spends most of the time in the green range.  And for this there is a reason: the same ‚Äúcolor generator‚Äù is used for displaying the temperature and for the rainbow. <br><br>  And since in my opinion in my home region it is more important to have an idea of ‚Äã‚Äãthe range from, say + 5C to + 25C, then the consequences are appropriate. </div><p>Source: <a href="https://habr.com/ru/post/243037/">https://habr.com/ru/post/243037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243023/index.html">Why Spritz has become so popular over the past few weeks.</a></li>
<li><a href="../243025/index.html">New on VPS Search: Notepad Domains and Notepad Servers</a></li>
<li><a href="../243027/index.html">Wargaming Developers Contest: Winners Announcement</a></li>
<li><a href="../243033/index.html">How and why does Yandex disable its own data centers</a></li>
<li><a href="../243035/index.html">We catch snmp mac-notification traps from Cisco devices</a></li>
<li><a href="../243039/index.html">Sandcastle and SHFB</a></li>
<li><a href="../243045/index.html">NetApp FAS performance optimization</a></li>
<li><a href="../243047/index.html">A 19-year-old vulnerability can capture a computer through Internet Explorer.</a></li>
<li><a href="../243049/index.html">Which GIS to use after the actual death of Google Maps?</a></li>
<li><a href="../243051/index.html">Stack programming with a human face (part two)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>