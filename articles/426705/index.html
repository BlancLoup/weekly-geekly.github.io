<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hyperledger Fabric Smart Contract Development and Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) is an open source platform using distributed ledger technology (DLT) designed to develop applications that work in the busine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hyperledger Fabric Smart Contract Development and Testing</h1><div class="post__text post__text-html js-mediator-article"><p>  Hyperledger Fabric (HLF) is an open source platform using distributed ledger technology (DLT) designed to develop applications that work in the business network environment created and controlled by a consortium of organizations using access rules (permissioned). </p><br><p>  The platform supports smart contracts, in terms of HLF - chaincode (chaincode) created in general-purpose languages ‚Äã‚Äãsuch as Golang, JavaScript, Java, in contrast to, for example, Ethereum, which uses a Solidity contract-oriented, functional language. (LLL, Viper and others). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  Development and testing of circuit codes, due to the need to deploy a significant number of components of the blockchain network, can be quite a long process with high time costs for testing changes.  The article discusses the approach to the rapid development and testing of HLF smart contracts at Golang using the <a href="https://github.com/s7techlab/cckit/">CCKit</a> library. </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  HLF based application </h2><br><p>  From the point of view of the developer, the blockchain application consists of two main parts: </p><br><ul><li>  <strong>On-chain</strong> - smart contracts (programs) operating in an isolated environment of the blockchain network, defining the rules for creating and composition of transaction attributes.  In a smart contract, the main actions are reading, updating, and deleting data from the state of the blockchain network.  It should be emphasized that deleting data from the state leaves information that this data was present. </li><li>  <strong>Off-chain</strong> is an application (for example, API) that interacts with the blockchain environment via the SDK.  Interaction means calling the functions of smart contracts and observing the events of a smart contract ‚Äî external events can trigger a change in data in a smart contract, while events in a smart contract can trigger actions in external systems. </li></ul><br><p>  Data is usually read through the ‚Äúhome‚Äù node of the blockchain network.  To write data, the application sends requests to the nodes of organizations participating in the ‚Äúapproval policy‚Äù of a particular smart contract. </p><br><p>  To develop off-chain code (API, etc.), a specialized SDK is used, which encapsulates interaction with blockchain nodes, collecting responses, etc.  For HLF there are SDK implementations on Go ( <a href="https://github.com/hyperledger/fabric-sdk-go">1</a> , <a href="https://github.com/s7techlab/hlf-sdk-go">2</a> ), <a href="https://github.com/hyperledger/fabric-sdk-node">Node.Js</a> and <a href="https://github.com/hyperledger/fabric-sdk-java">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Hyperledger Fabric Components </h2><br><h3 id="kanal">  Channel </h3><br><p>  A channel is a separate subnet of nodes supporting an isolated block chain (ledger), as well as the current state (key-value) of the block chain ( <em>world state</em> ) used for the operation of smart contracts.  A network node can have access to an arbitrary number of channels. </p><br><h3 id="tranzakciya">  Transaction </h3><br><p>  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html">A transaction in the Hyperledger Fabric</a> is an atomic update of the state of the chain of blocks, the result of the execution of the cheyncode method.  A transaction consists of a request to call a cheyncode method with some arguments (Transaction Proposal), signed by the calling node, and a set of responses (Transaction Proposal Response) from the nodes on which the "Endorsement" of the transaction was performed.  Answers contain information on changing pairs of key-value status of the chain of blocks <a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html">Read-Write Set</a> and service information (signatures and certificates of nodes that confirmed the transaction).  Since  chains of blocks of individual channels are physically separated, the transaction can be performed only in the context of one channel. </p><br><p>  "Classic" blockchain platforms, such as <a href="https://bitcoin.org/">Bitcoin</a> and <a href="https://ethereum.org/">Ethereum</a> , use the Sorting-Execution transaction execution cycle performed by all nodes, which limits the scalability of the blockchain network. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric uses a transaction execution and distribution architecture, in which there are 3 basic operations: </p><br><ul><li><p>  Execute ( <strong>execute</strong> ) - creating a smart contract running on one or several network nodes; a transaction ‚Äî atomic changing the state of a distributed registry ( <em>endorsement</em> ) </p><br></li><li><p>  Ordering ‚Äî ordering and grouping transactions into blocks by a specialized <em>orderer</em> service using a pluggable consensus algorithm. </p><br></li><li><p>  Validation - validation by network nodes of transactions coming from <em>orderer</em> before placing information from them in their copy of the distributed registry </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  This approach allows you to carry out the transaction execution stage before it enters the blockchain network, as well as horizontally scale the operation of network nodes. </p><br><h3 id="cheynkod">  Cheinkode </h3><br><p>  A cheinkode, which can also be called a smart contract, is a program written in Golang, JavaScript (HLF 1.1+) or Java (HLF 1.3+), which defines the rules for creating transactions that change the state of a chain of blocks.  The program is executed simultaneously on several independent nodes of the blockchain-distributed network of nodes, creating a neutral environment for executing smart contracts by verifying the results of program execution on all the nodes necessary to "confirm" the transaction. </p><br><p>  A cheinkode should implement an interface consisting of methods: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  The <strong>Init</strong> method is invoked during the installation or upgrade of a chejncode.  In this method, the necessary initialization of the state of the chynode is performed.  It is important to distinguish in the method code whether the call is instantiation or upgrade, so as not to initialize (reset) the data by mistake, which in the course of the work of the cheinkcode received a non-zero state. </li><li>  The <strong>Invoke</strong> method is called when calling any function of the cheyncode.  In this method, we work with the state of smart contracts. </li></ul><br><p>  The cheyncode is installed on the nodes (peer) of the blockchain network.  At the system level, each instance of a cheyncode corresponds to a separate docker-container tied to a specific network node that dispatches calls to execute cheyncode. <br>  Unlike Ethereum smart contracts, the logic of the cheyncode can be updated, but this requires that all nodes that host the cheyncode install the updated version. </p><br><p>  In response to an outside call to the cheyncode function via the SDK, the cheyncode creates a change in the state of the block chain ( <a href="https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html">Read-Write Set</a> ), as well as events.  A cheinkode refers to a specific channel and can change data in only one channel.  At the same time, if the node of the network on which the cheyncode is installed also has access to other channels, in the cheyncode logic there may be reading data from these channels. </p><br><p>  Special chain codes for managing various aspects of the blockchain network are called system chain codes. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Endorsement Policy </h3><br><p>  An approval policy defines consensus rules at the level of transactions created by a particular cheyncode.  The policy defines rules that define which channel nodes should create a transaction.  To do this, each of the nodes specified in the approval policy must run a chejncode method (step "Execute"), perform a "simulation", after which the signed results will be collected and checked by the SDK that initiated the transaction (all simulation results must be identical, Signatures must be present for all required nodes.  Next, the SDK sends the transaction to the <em>orderer</em> , after which all nodes that have access to the channel, through the <em>orderer,</em> will receive the transaction and perform the "Validate" step.  It is important to emphasize that not all channel nodes should participate in the "Execute" step. </p><br><p>  The approval policy is determined at the time of instantiation (instantiate) or upgrade (upgrade) of the cheyncode.  In version 1.3, it became possible to set policies not only at the level of a cheyncode, but also at the level of individual state keys of a chain of blocks ( <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.3/endorsement-policies.html">state based endorsement</a> ).  Examples of approval policies: </p><br><ul><li>  Nodes A, B, C, D </li><li>  Most channel nodes </li><li>  At least 3 nodes from A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  Event </h3><br><p>  An event is a named dataset that allows you to publish ‚Äúupdate tape‚Äù of the state of the blockchain chain.  A set of event attributes defines a cheynkod. </p><br><h2 id="infrastruktura-seti">  Network infrastructure </h2><br><h3 id="uzel-seti-peer">  Network node (Peer) </h3><br><p>  The network node is connected to an arbitrary number of channels to which it has access rights.  The network node maintains its version of the block chain and the state of the block chain, and also provides an environment for starting the chain codes.  If the network node is not included in the approval policy, then it does not have to be installed cheynkodov. </p><br><p>  At the software level of the network node, the current state of the world block chain can be stored in LevelDB or in CouchDB.  The advantage of CouchDB is support for extended queries (rich query) using MongoDB syntax. </p><br><h3 id="orderer">  Orderer </h3><br><p>  The transaction organizing service accepts signed transactions as input and ensures that transactions are distributed to network nodes in the correct order. </p><br><p>  Orderer does not launch smart contracts and does not contain a chain of blocks and the state of a chain of blocks.  At the moment (1.3) there are two <em>orderer</em> implementations - a <em>solo</em> for development and a version based on Kafka that provides crash fault tolerance.  An implementation of an <em>orderer</em> that supports resistance to the incorrect behavior of a certain percentage of participants (Byzantine fault tolerance) is expected at the end of 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Membership services </h3><br><p>  In the Hyperledger Fabric network, all participants have identity details known to other participants.  The identification uses a public key infrastructure (PKI), which is used to create X.509 certificates for organizations, infrastructure elements (node, orderer), applications, and end users.  As a result, read and modify data access can be controlled through access rules at the network level, individual channel, or in the logic of a smart contract.  In one blockchain network, several identification services of various types can simultaneously operate. </p><br><h1 id="realizaciya-cheynkoda">  Chejncode implementation </h1><br><p>  A cheynkod can be considered as an object having methods that implement certain business logic.  Unlike classical OOP, a cheynkod can not have fields - attributes.  To work with the state ( <em>state</em> ), which storage is provided by the HLF blockchain platform, the <a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim">ChaincodeStubInterface</a> layer is <a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim">used</a> , which is transmitted when calling the <em>Init</em> and <em>Invoke</em> methods.  It provides the ability to get arguments of the function call and make changes in the state of the chain of blocks: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  In the Ethereum smart contract developed by Solidity, each method corresponds to a public function.  In the cheyncode Hyperledger Fabric in the <em>Init</em> and <em>Invoke</em> methods using the <a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim">ChaincodeStubInterface</a> function.  <em>GetArgs ()</em> you can get the arguments of the function call in the form of an array of arrays of bytes, with the first element of the array when you call <em>Invoke</em> contains the name of the function cheynkod.  Since  Invoke method passes through the method of any cheynkod method, we can say that this is the implementation of the front controller pattern. </p><br><p>  For example, if we consider the implementation of the standard for Ethereum interface token <a href="">ERC-20</a> smart contract must implement the methods: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (address _owner) </li><li>  transfer (address _to, uint256 _value) </li></ul><br><p>  and others. In the case of HLF implementations, the cheyncode in the <em>Invoke</em> function should be able to handle cases where the first argument of the <em>Invoke</em> call contains the name of the expected methods (for example, ‚ÄútotalSupply‚Äù or ‚ÄúbalanceOf‚Äù).  An example of the implementation of the standard ERC-20 can be seen <a href="https://medium.com/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339">here</a> . </p><br><h2 id="primery-cheynkodov">  Examples of cheynkodov </h2><br><p>  In addition to the documentation <a href="https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html">Hyperledger Fabric,</a> you can give a few examples of cheynkodov: </p><br><ul><li>  <a href="https://developer.ibm.com/code/patterns/build-a-blockchain-insurance-app/">Blockchain insurance app (2018)</a> </li><li>  <a href="">Marbles</a> </li><li>  <a href="">Car-lease-demo (2017)</a> s </li></ul><br><p>  The implementation of cheynkodov in these examples is quite verbose and contains a lot of repeating logic of choosing called functions ‚Äúrouting‚Äù), checking the number of arguments, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Such an organization of the code leads to a deterioration in the readability of the code and possible errors, like <a href="https://github.com/IBM/build-blockchain-insurance-app/pull/44">this</a> , when you simply forgot to conduct an unmarshalling of the input data.  In presentations on HLF development plans, there is a mention of a redesigning of the cheyncode development approach, in particular, the introduction of annotations into java cheinkode, etc., but the plans refer to the version that is expected only in 2019.  The experience of developing smart contracts led to the conclusion that it would be easier to develop and test circuit codes if you select the basic functionality in a separate library. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - library for development and testing of cheynkodov </h1><br><p>  The <a href="https://github.com/s7techlab/cckit/">CCKit</a> library summarizes the practice of developing and testing cheek codes.  As part of the development of cheyncode <a href="https://github.com/s7techlab/cckit/tree/master/extensions">extensions, the</a> OpenZeppelin extension <a href="https://github.com/OpenZeppelin/openzeppelin-solidity">library</a> for Ethereum smart contracts was used as an example.  CCKit uses the following architectural solutions: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Routing (routing) calls to the functions of the smart contract </h2><br><p>  Routing is an algorithm by which an application responds to a client request.  This approach is used, for example, in almost all http-frameworks.  A router uses specific rules to associate a request and a request handler.  With reference to a cheynkod - this is the link between the name of the cheyncode function and the handler function. </p><br><p>  In the last examples of smart contracts, for example in the <a href="">Insurance App</a> , a mapping is used between the name of the cheyncode function and the function in the Golang code like: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  The CCKit router has a similar approach to the http router, and also added the ability to use the context of the query to the cheyncode function and intermediate processing functions (middleware) </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  The context of the appeal to the function cheynkoda </h2><br><p>  Similar to the http request context, which usually has access to the http request parameters, the CCKit router uses the context of accessing the <a href="">smart contract</a> function, which is an abstraction on top of <em>shim.ChaincodeStubInterface</em> .  The context can be the only argument of the handler of the cheyncode function, through it the handler can receive the arguments of the function call, as well as access to the auxiliary functionalities of working with the state of the smart contract (State), creating responses (Response), etc. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Since  Context is an interface, it can be extended in certain cheynkodakh. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Middleware functions (middleware) </h2><br><p>  The middleware functions are called before calling the handler of the cheyncode method, they have access to the context of the call to the cheyncode method and to the next intermediate function or directly to the handler of the cheyncode method (next).  Middleware can be used for: </p><br><ul><li>  input data conversion (in the example below <em>p.String</em> and <em>p.Struct</em> are middleware) </li><li>  function access restrictions (for example, <em>owner.Only</em> ) </li><li>  complete the request processing cycle </li><li>  calling the next staging function from the stack </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Data structure conversion </h2><br><p>  The cheinkcode interface assumes that an array of bytes is supplied to the input, each of the elements of which is an attribute of the cheyncode function.  In order for each handler of the cheynkod function not to perform manual unmarshalling of data from the byte array into the golang data type (int, string, structure, array) of function call arguments, in the CCKit router, the expected data types are set at the moment of creating the routing rule and the type is automatically converted .  In the example that is discussed later, the <em>carGet</em> function expects a string argument, and the <em>carRegister</em> function <em>expects a CarPayload</em> structure.  The argument is also named, which allows the handler to get its value from the context by name.  An example of the handler will be given below. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Also, automatic conversion (marshalling) is used when writing data to the smart contract state and when creating events (the golang type is serialized into an array of bytes) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Means of debugging and logging of cheynkodov </h2><br><p>  To debug a cheyncode, you can use the <a href="https://github.com/s7techlab/cckit/tree/master/extensions/debug">debug</a> extension, which implements smart contract methods that will allow you to inspect the presence of keys in a smart contract state, as well as directly read / modify / delete the value by key. </p><br><p>  For logging, in the context of a call to a cheyncode function, the Log () method can be used, which returns an instance of the logger used in the HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  Control methods for accessing smart contract methods </h2><br><p>  As part of the <a href="https://github.com/s7techlab/cckit/tree/master/extensions/owner">owner</a> extension, basic primitives are implemented for storing information about the owner of an instantiated cheyncode and access modifiers (middleware) for smart contract methods. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Smart Contract Testing Tools </h2><br><p>  Deploying the network blockchain, installing and initializing cheynkodov is quite a complicated setup and a long procedure.  The time to re-install / upgrade the code of a smart contract can be reduced by using the DEV mode of the smart contract, however, the process of updating the code will still be slow. </p><br><p>  The <a href="https://github.com/hyperledger/fabric/tree/release-1.2/core/chaincode/shim">shim</a> package contains a <a href="">MockStub</a> implementation that wraps calls to a cheyncode code, simulating its operation in the blockchain HLF environment.  Using MockStub allows you to get test results almost instantly and allows you to reduce development time.  If we consider the general scheme of the work of the cheyncode in the HLF, MockStub essentially replaces the SDK, allowing you to make calls to the cheyncode functions, and simulates the environment of starting the cheyncode on the network node. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  The HLF MockStub contains implementation of almost all the methods of the <em>shim.ChaincodeStubInterface</em> interface, but in the current version (1.3), it lacks the implementation of some important methods, such as GetCreator.  Since  The cheynkod can use this method to obtain the certificate of the transaction creator for the purpose of access control, for the maximum coverage in tests it is important to have a stub for this method. </p><br><p>  The CCKit library contains an enhanced version of <a href="">MockStub</a> , which contains the implementation of missing methods, as well as methods for working with event channels, etc. </p><br><h2 id="primer-cheynkoda">  Cheynkod example </h2><br><p>  For an example, we will create a simple cheinkcode for storing information about registered cars. </p><br><h3 id="model-dannyh">  Data model </h3><br><p>  The state of the cheyncode is the key-value storage, in which the key is a string, the value is an array of bytes.  The base practice is to store golang instances of data structures serialized in json as a value.  Accordingly, to work with the data in the cheyncode, after reading from the state, it is necessary to conduct an unmarshalling of the byte array. </p><br><p>  To write about the car will use the following set of attributes: </p><br><ul><li>  Identifier (car number) </li><li>  Car model </li><li>  Vehicle Owner Information </li><li>  Information about data modification time </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  To transfer data to the cheyncode, we will create a separate structure containing only the fields coming from outside the cheyncode: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Work with keys </h3><br><p>  Record keys in the smart contract state is a string.  It also supports the ability to create composite keys in which parts of the key are separated by a zero byte ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  In <em>CCKit,</em> smart contract state functions can automatically create keys for entries if the transferred structures support the <em>Keyer</em> interface. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  For a vehicle entry, the key creation function will be as follows: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Declaration of smart contract functions (routing) </h3><br><p>  In the cheyncode constructor method, we can define cheyncode functions and their arguments.  There will be 3 functions in the cheynkod car registration </p><br><ul><li>  carList, returns an array of Car structures </li><li>  carGet, takes the car ID and returns the Car structure </li><li>  carRegister, accepts a serialized instance of the CarPayload structure and returns the registration result.  Access to this method is possible only for the owner of the cheyncode, which is saved using middleware from the <a href="https://github.com/s7techlab/cckit/tree/master/extensions/owner">owner</a> package. </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  In the example above, a <a href="">Chaincode</a> structure is <a href="">used</a> in which the processing of the <em>Init</em> and <em>Invoke</em> methods is delegated to the router: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  Using the router and the basic structure of Chaincode allows you to reuse handler functions.  For example, to implement a cheynkod without checking access to the <code>carRegister</code> function will be enough to create a new <a href="">constructor method</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementing Smart Contract Functions </h3><br><p>  Golang functions - smart contract function handlers in <strong>CCKit</strong> router can be of three types: </p><br><ul><li>  <em>StubHandlerFunc</em> - the standard handler interface, accepts <em>shim.ChaincodeStubInterface</em> , returns the standard response <em>peer.Response</em> </li><li>  <em>ContextHandlerFunc</em> - takes a context and returns <em>peer.Response</em> </li><li>  <em>HandlerFunc</em> - accepts context, returns interface and error.  It can return an array of bytes or any type of golang that is automatically converted into an array of bytes, on the basis of which <em>peer.Response</em> is created.  The response status will be <em>shim.Ok</em> or <em>shim.Error</em> , depending on the error transmitted. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>  The arguments of the cheyncode functions described in the router will be automatically converted from arrays of bytes into the target data types (string or CarPayload structure) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       ‚Äî        ,     .      BDD ‚Äì Behavior Driven Development,          . </p><br><p>  , , <a href="https://habr.com/post/321362/">- Ethereum</a>     <a href="https://github.com/trufflesuite/ganache-cli">ganache-cli</a>   <a href="https://truffleframework.com/">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://onsi.github.io/ginkgo">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://onsi.github.io/gomega">gomega</a>        <a href="https://github.com/s7techlab/cckit/tree/master/testing/expect">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Since   cars      ,    <a href="https://github.com/s7techlab/cckit/tree/master/examples/cert"> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426705/">https://habr.com/ru/post/426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426691/index.html">Programmer at the hospital</a></li>
<li><a href="../426693/index.html">Navigation service robot on the golf course. Construction and obstacle avoidance</a></li>
<li><a href="../426697/index.html">Working with devices on LibUsb from under Android</a></li>
<li><a href="../426701/index.html">Flutter - a new look at cross-platform development</a></li>
<li><a href="../426703/index.html">What was interesting on DataVizDay in Minsk</a></li>
<li><a href="../426707/index.html">Matching system How we invented the bicycle</a></li>
<li><a href="../426709/index.html">JavaScript timers: all you need to know</a></li>
<li><a href="../426713/index.html">Intel Xeon W-3175X: 28 cores for home</a></li>
<li><a href="../426715/index.html">Russia is developing an analogue DMCA</a></li>
<li><a href="../426717/index.html">Illusion of deception: visual-optical illusion based on retro-prediction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>