<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Can I render realistic images without floating point numbers?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 ‚ÄúWhat happens if we replace floating-point numbers with rational numbers and try to render an image?‚Äù 

 I asked myself this question ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Can I render realistic images without floating point numbers?</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><hr><br>  ‚ÄúWhat happens if we replace floating-point numbers with rational numbers and try to render an image?‚Äù <br><br>  I asked myself this question after thinking about the tweet of the researcher and computer graphics teacher Morgan McGwire.  He talked about how much computer science students are surprised when they first learn that in order to store the usual floating-point numbers in modern computers, one has to make compromises.  And these compromises make simple tasks difficult, for example, checking that a point belongs to a triangle.  The problem, of course, is that checking for finding four points in one plane (coplanarity) with the help of a determinant or some vector multiplication (and in fact it‚Äôs the same thing) will never give a value exactly equal to zero, which is required these mathematical methods.  Even if the real calculations on one plane were accurate, the same trade-offs with an accuracy of almost 1.0 would give the answer that the four points themselves are not coplanar. <br><br>  This gave rise to the idea in me - if we assume that all the input data of the renderer (vertex coordinates, 3D transformations, etc.) would be specified as rational numbers, then all operations would be created, from beam creation, bypassing the accelerating structure to the intersection rays with triangles are only rational numbers?  If that were the case, then we would be able to perform a coplanarity check for sure!  You may be wondering why a 3D scene expressed in rational numbers should only give results in rational numbers ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>A simple scene, tracing the path in which performed a rational arithmetic.</i>  <i>It uses a system of numbers "with a floating <b>line fraction</b> ", and not numbers with a floating <b>comma</b> .</i> <br><a name="habracut"></a><br>  First, a rational number is a number that can be expressed as the ratio of two integers, for example, 1/2 or 355/113.  Secondly, ‚Äúconventional rendering operations‚Äù, such as checking bounding box tests, checking for intersection of a ray with a triangle, ray reflections, etc., are based on vector and scalar products, as well as scalar division (this includes the transformations of coordinates and matrix inversion, quaternions, etc.), which in turn are based on four basic operations: addition, subtraction, multiplication and division.  When adding, subtracting, multiplying and dividing rational numbers, we also get rational numbers.  A mathematician would say that the set of rational numbers forms a field closed under four basic arithmetic operations.  For us, this means that if you stick to extremely rational numbers, then you can actually move from the incoming data of the 3D scene to the fully rendered image, without leaving the world of rational numbers. <br><br>  The exceptions to the rule ‚Äúactions on rational numbers are rational numbers‚Äù are square roots and trigonometric / transcendental functions.  As for the latter, I always say that if you had to perform trigonometric calculations in the geometric interior of your renderer, then most likely you are doing something wrong (and I showed <a href="http://www.iquilezles.org/www/articles/noacos/noacos.htm">how to fix the most standard cases</a> ).  As regards square roots, with the exception of conic sections (spheres, cylinders, etc.) and shading / DFOS / coloring, it is not necessary to normalize the rays and normals to the surfaces as often as is usually done.  You certainly do not need to do this to create a beam, its passage, intersection, reflections, etc.  Unfortunately, very often I see that programmers normalize values ‚Äã‚Äãfor no reason other than ‚Äúwell, I don‚Äôt know, I‚Äôm doing it to make sure‚Äù.  In practice, in the part of the rendering where geometry tracing is performed, it is very rarely necessary to normalize the values, so I had the hope that you can trace the whole scene without leaving the world of rational numbers - this is what I would call rational rendering. <br><br>  To put this into practice, I need to create a system of numbers based on rational numbers that a computer could use.  Then on top of it, I could implement the usual path tracing algorithms, calculate images without losing accuracy, perform coplanarity checks that have accurate answers, and bring happiness to all students studying computer graphics. <br><br>  This article is a story about two evenings investigating the realism of such an idea.  I will talk about the many aspects that I have learned, about what I have invented, and about several surprises that I discovered in the process.  The article is written in more or less chronological order of my work.  In addition, it is written in my unusually informal and very unscientific style (which I am proud of).  The image shown above is a kind of spoiler, but read the article to the end, because I will tell you about the good and the bad. <br><br><h2>  Training </h2><br><hr><br>  The first thing I did was implement <a href="https://www.shadertoy.com/">Shadertoy with a</a> minimized tracer for an ultra- <a href="https://www.shadertoy.com/">simple</a> scene consisting of a plane, a sphere, a rectangular parallelepiped and a triangle - the building blocks of real-world renderers.  Then I copied the code into the C ++ file and, after making a couple of minor changes, I compiled it using my <a href="http://www.iquilezles.org/code/piLibs/piLibs.htm">piLibs</a> framework.  So I got to compare the traced image rendered on the CPU using ordinary IEEE754 floating-point numbers.  I also removed all ray normalization from the trace code, because, as mentioned above, none of them are really needed.  I recall that normalization requires a square root, and rational numbers are not saved when it is used (the square root of a rational number is not a rational number).  A little later, we will see that, of course, you can still use square roots, I just wanted to make the code as mathematically pure as possible to see how far I can go with accurate arithmetic of rational numbers without rounding. <br><br>  The last preparatory step - I took all the vec3, mat4x4 and other basic classes of algebra / mathematics, and then changed them so that they use ‚Äúrational‚Äù instead of ‚Äúfloat‚Äù.  Since my rational structure overloads all standard operators (add, sub, mul, div, sign changes, comparisons, etc.), the replacement took place without problems.  I quickly implemented the remaining normal operations (abs, sign, mod, fract, floor, sqrt, etc.), which theoretically were enough to produce beautiful, rational renders. <br><br><h2>  Test 1 - a naive solution </h2><br><hr><br>  But let's see what this first implementation was.  At first I always try the simplest, and then I look at the results.  And the simplest way to implement rational values ‚Äã‚Äãwas to use two integers.  As can be understood from the title of the section, this will not be my final decision, but for the first attempt it was a reasonable decision.  So, each number <b>x</b> should have been represented as the numerator <b>N</b> and the denominator <b>D</b> , forming the value <b>N</b> / <b>D.</b>  The value of <b>x is</b> approximated by the best possible <b>N</b> / <b>D</b> pair (within a given bit depth), which is closest to the true value of <b>x</b> .  I decided that both numbers must be positive, and the number sign must be stored in a separate bit in order to simplify the work and get rid of ambiguities, although this is not very important.  At this stage, both numerators and denominators were unsigned.  But even with the separation of the sign <b>N</b> / <b>D</b> had a lot of redundancy: for example, 1/4 and 7/28 denote the same number, but have completely different bit representations.  We will touch on this later, but for now let's not focus and see what the four basic arithmetic operations look like in this rational form. <br><br>  First, note that subtracting <b>a</b> - <b>b</b> is simply the addition of <b>a</b> and the value opposite to <b>b</b> , i.e., <b>a</b> + ( <b>-b</b> ), where <b>-b</b> can be calculated by simply replacing the <b>b</b> sign.  Similarly, the division of <b>a</b> / <b>b</b> is the same as the multiplication of <b>a</b> and the inverse of <b>b</b> .  Or, in other words, <b>a</b> / <b>b</b> = <b>a</b> ¬∑ (1 / <b>b</b> ), where (1 / <b>b</b> ) can be calculated by simply changing the places of the numerator <b>b <sub>n</sub></b> and the denominator <b>b <sub>d of the</sub></b> number <b>b</b> .  So, here's the first interesting property of rational arithmetic - division and multiplication have the same costs, so unlike the usual floating-point rendering, in which divisions are usually avoided, postponed or hidden under slower requests for receiving textures, you don‚Äôt need to be afraid of . <br><br>  Let us proceed to addition with multiplication: we know that it is trivial to calculate the opposite and inverse values, therefore we get: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/ac2/4da/53fac24da912886adb7eedc4545363da.png"></div><br>  The preservation of the sign during multiplication is trivial, it is just xor, because two positive values ‚Äã‚Äãgive a positive result, like two negative values.  Preserving the sign for addition is a more complicated process and for a quick solution I implemented it through three branches (addition is trivial, if the signs for <b>a</b> and <b>b</b> coincide, but when they do not match, then you need to choose a smaller number and subtract it from the larger one - in the article I don‚Äôt I will describe such small details in more detail, but I‚Äôll just post the source code somewhere). <br><br>  Also I‚Äôll skip the implementation of fract () and floor ();  If you decide to try to implement them yourself, you will see their simplicity and beauty.  Attention should also be paid to comparison operators.  By taking care of the signs and accepting that <b>a</b> and <b>b are</b> positive, we get <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  It is important to note here that even for comparison, we need a couple of multiplication operations, which can lead to a transition to the next word size and will be important slightly lower. <br><br>  Finally, we will look at the square roots in a separate section, knowing that for the most part we don‚Äôt need them (with the exception of the scope from this first test). <br><br>  This was enough to launch the first render and trace the test scene (plane + sphere + triangle + rectangular parallelepiped) to see what happens.  I generously used 65-bit rational numbers for this first test, which in fact represents a large amount of data (comparable to the ‚Äúdouble‚Äù data type): 32 bits are taken up by the numerator, 32 bits are the denominator, and one more bit is the sign.  The first is an image obtained with this naive approach, the second is an image made using floating-point numbers (reference): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>"Naive" 65-bit rational numbers</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Floating point reference</i> <br><br>  The result was rather bad, the box and the triangle did not even appear on the render, and the sphere and the floor plane were too noisy.  The problem, of course, was that every time my rational numbers performed any basic arithmetic operation at any of the algorithmic rendering stages, the numerator and denominator uncontrollably became more and more, because integer multiplication was used.  Think about the following: if the units of measurement of our original world were meters, and we would have tied the original geometry (vertices and the camera) to millimeter accuracy, then only the original data occupied 16 bits volume for a rather small scene.  At the same time, with standard HD screen resolution and 4X anti-aliasing, rational directions of the beam direction would easily require 12 bits.  That is, at the first interaction of the beam and geometry, the simplest arithmetic operation using both input data sets would turn the result into numbers of 28-bit length ‚Äî close enough to the 32-bit constraint that I asked myself in this first implementation.  And this is before we have completed the very first vector or scalar product.  By the time the dot-product was completed, the renderer would have already needed hundreds of bits long rational numbers to represent numbers.  Of course, this is the worst case, but the average case would be close to that.  Taking into account that I singled out the total 32-bit capacity as the numerator and denominator, it is easy to understand how quickly the values ‚Äã‚Äãgo beyond the boundaries in this test - it is not surprising that with the exception of the floor plane and part of the sphere, almost nothing is visible. <br><br><h2>  Test 2 - reduction by the greatest common factor. </h2><br><hr><br>  Then I improved the system by using the property that I briefly mentioned above - different rational numbers can denote the same value.  Indeed, 6/12 is the same as 1/2, but it uses far more bits than the last.  Therefore, the idea was as follows: if after each basic arithmetic operation (or after it) I would remove all common dividers from the numerator and denominators, and bring the fraction to its simplest form, then perhaps I will be able to keep everything under control and continue operations longer with accurate arithmetic without loss of accuracy.  Perhaps you will be able to do this long enough to get clean rendered images?  I will make a small digression to show another example: 588/910 can be simplified to 42/65, because 14 is a divider and 588, and 910. But for storing 42/65, obviously, you need less bits than 588/910.  Finding the largest possible number that simultaneously divides two other numbers can be done using the greatest common divider algorithm (Great Common Divisor, GCD), which you can find effective implementations anywhere (I personally copied it straight from Wikipedia and sped up a bit, performing the scanning step bits using internal x64 operations).  So, armed with the NOD algorithm, my ‚Äúrational‚Äù class should constantly simplify fractions generated during the rendering process.  This could be done in two ways: <br><br>  The first is to convert the intermediate result of the addition and multiplication operators to the next type of bit data (in my current naive solution, it is uin64_t), search for GCD in this more voluminous data type, and then reduce the result to the original bit length (32).  The second way is to analyze how <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> and <b>b <sub>d</sub></b> are combined with each other in both arithmetic operators and to extract common divisors from them before performing multiplication.  The second approach, in principle, eliminated the need to use large bit lengths.  Knowing that I might have to use them anyway, I decided to choose the first method, because it is easier to implement and he allowed me to speed up my work (the evening flies by very quickly).  Having done all this, let's see which render I can create now: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>65-bit rational numbers with an abbreviation for GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Floating point reference</i> <br><br>  Much better!  So far away from the ideal, of course, but it looks promising.  I made a box and a triangle appear, and the sphere now seems much more voluminous.  However, a funny artifact appeared in the upper right corner, and rational numbers for many pixels still go beyond the boundaries, which leads to a lot of points in the image.  However, it is worth noting that for some (many) pixels I began to get <b>accurate</b> and perfect results!  That is, the tracer found mathematically exact intersections of points and distances, which was the primary reason for trying to use rational numbers. <br><br>  Before proceeding to the next step in the process of proving the applicability of rational numbers, I want to briefly stop and share my findings regarding the GCD and the reduction of rational numbers. <br><br>  The first discovery is associated with the bit volume of rational numbers.  Even though I still cannot render beautiful images and this is more important than worrying about optimizing data volumes, and although this early implementation still used a large number of bits (1 + 32 + 32), I was already thinking about the previously mentioned waste bits in the form of excess fractions.  In particular, after adding a stage with GCD, combinations of bits like 2/4 are no longer applicable, because they are automatically reduced to 1/2 before writing to any register or variable.  That is, in a sense, of all 2 <sup>64</sup> combinations of bits that could be the numerator and denominator, many remained untapped.  And so it is impossible to spend bits in vain.  Or can it?  How much space do I actually lose?  I made a small digression to explore this question. <br><br><h2>  Retreat - about mutually simple numbers </h2><br><hr><br>  The illustrations below show the use of bits for rational numbers in 5/5 bits and 7/7 bits.  The horizontal and vertical axes of the graphs represent the values ‚Äã‚Äãof the numerator and denominator of all possible rational numbers that have numerators and denominators of up to 5 bits (31) and 7 bits (127).  Black pixels are unused combinations, and white pixels are used fractions.  For example, the entire diagonal is black, with the exception of the 1/1 pixel, because all fractions of the form n / n are reduced to 1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Using bits for 5/5 rational</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Using bits for 7/7 rational</i> <br><br>  If you count the pixels, as I did, then you can quickly understand that the proportion of useful pixels with an increase in the number of bits tends to 60.8%.  A small online study showed me that this ratio turns out to be exactly 6 / œÄ <sup>2</sup> , because it is also the probability of being mutually simple (not having common divisors) for two random numbers.  You may ask, where did pi come from?  It turns out that ‚Äúsix on pi‚Äù in the square ‚Äùis a value equal to one divided by the <a href="https://en.wikipedia.org/wiki/Riemann_zeta_function">Riemann zeta function</a> calculated at the point 2, 1 / (2).  This should not surprise us, because the Riemann zeta function often comes up in problems involving simple and coprime numbers. <br><br>  Anyway, it seems that in my rational representation I wasted about 40% of the bit combinations.  And although this seems like a large number, I decided to look at it as if it were actually less than a bit ... so I could not be particularly upset.  Taking this into account, I decided to move on, using other, completely different approaches, instead of trying to locally optimize this single problem.  However, I briefly learned about the Stern-Brocot and Calkin-Wilf trees, which could allow me to fully use all the available bits, but the interval of values ‚Äã‚Äãobtained with their help turns out to be very small, so I quickly abandoned this idea and moved on.  I think at this point I must express my appreciation to <a href="https://www.wikipedia.org/">Wikipedia</a> as a constant source of my knowledge. <br><br>  Let's return to the analysis of what we have received: I can render images with distortions, but I depend very much on the distribution of prime numbers in the calculations.  It depends on these prime numbers whether the GCD algorithm can simplify the expression ‚Äî as soon as any simple or multiple number falls into any number of the renderer (vectors, scalars, matrices), it ‚Äúpollutes‚Äù all the numbers following it in further arithmetic manipulations, and remains in them forever.  Therefore, gradually everything is guaranteed to begin to grow, it is only a matter of time.  Besides the fact that it is inevitable, it is also necessary, because it is precisely mutually simple divisors that carry information about the meaning of a number.  But at the same time, large prime numbers break everything very quickly.  So there is a conflict. <br><br>  The last thing to notice is that I still used twice as many bits as a standard floating point number, so there are no real advantages here.  Of course, I tried to use 16/16-bit rational numbers, which would be a more honest comparison with the true requirements for floating-point arithmetic, but with an accuracy of 16/16, the system I wrote with numerator + denominator + NOD created completely unintelligible images. <br><br><h2>  Test 3 - normalization of rational numbers </h2><br><hr><br>  So, at this moment I needed something really significant.  It seemed that in order to prevent numbers from going out of line, one had to start cutting numbers and losing accuracy.  My whole experiment began with the idea of ‚Äã‚Äãresearching <b>accurate</b> rendering, but by this time I felt ready to give up this idea and continue to explore other areas, if only for fun, and see what it will lead me to (the initial idea that stimulates the research process - this is exactly the idea to start the process, and after it you often end up in a completely unexpected place. Or, as John Cleese once said, bad ideas can lead to good ideas, the process of creativity is not necessarily always  edovatelnostyu or logically true progression of steps). <br><br>  Anyway, I decided to check what would happen to the renderers if I somehow protected the numerator and denominator from overflow.  The simplest thing would be to shift both the numerator and the denominator, if necessary, by a sufficient number of bits to the right, until they again find themselves in the bit space allocated to them.  In essence, this means an integer division of both the numerator and the denominator by one quantity, which means that the value of the number remains <b>approximately</b> unchanged.  And here I deviated from the original goal of the experiment. <br><br>  In my first implementation, I looked at the number of bits needed for the numerator and denominator, took the maximum for both, and shifted both by that number of bits (performing rounding to the nearest whole number).  When this was implemented in addition and multiplication operators, everything began to look quite acceptable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br>  <i>65-bit rational numbers with reduction on GCD and normalization</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Floating point reference</i> <br><br>  Since everything looked pretty good, at this stage I started to solve the problem of a large amount of bits used in the current implementation.  I tried using 32/32 (65 bits) 16/16 instead (33 bits), and the images were surprisingly good!  I still saw that there were small holes in some edges of the sphere, and there were small tears in the figure of the texture of the triangle.  But this is not bad for values ‚Äã‚Äãclose enough to floating point numbers.  It gave me the energy to learn new ideas. <br><br><h2>  Test 4 - floating fraction </h2><br><hr><br>  At this stage, I decided to distract myself and stop looking for excuses - if I want to find something interesting for rendering in rational numbers, then they should take 32 bits and no more.  It is better to find a good idea or stop, and finish at that (this was at the beginning of the second evening of the experiments). <br><br>  At first, I thought that it was worth adhering to the ideas of the GCD and normalization, but at the same time, it was smarter to approach the storage and use of bits.  The first thing that occurred to me was that even though the numerator and denominator may become large, this often does not happen.  Or at least it does not happen at the same time.  Therefore, when the numerator is small, you can allow the denominator to be large, and vice versa.  Unused bits of one of the two integer values ‚Äã‚Äãcan be used to represent larger values.  Then I realized that similarly to this, a floating-point number is essentially a fixed-point format, where the ‚Äúfixed‚Äù comma is made variable.  I can take my rational numbers and also make the bit position of the fraction fraction variable.  That is, not to set a fraction hard as 16/16, but to allow the same 32-bit variable to sometimes be 16/16, and sometimes 5/27 or 13/19, if necessary. <br><br>  It was worth checking out.  Anyway, a few lines of packing / unpacking code in internal setters and getters can be written quickly.  The most logical scheme for me was 1 | 5 | 26, that is: <br><br><blockquote>  1 bit: sign <br>  5 bits: slash position position (B) <br>  26 bits: combined numerator and denominator data;  the numerator is the top 26-B bits, the denominator is the bottom B bits, </blockquote><br>  where the fraction bar (B) determines the size of the denominator.  For example, the number 7/3 will be written as <br><br><blockquote>  7/3 = 0 00010 000000000000000000000111 11, </blockquote><br>  where a 0 indicates a positive value, a 2 slash denotes a denominator (number 3), to represent which 2 bits are needed, and the rest of the bits go to the numerator. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Those readers who have worked with the IEEE754 standard may find this observation familiar: the binary representation of the denominator always starts with ‚Äú1‚Äù, because the number of a fraction line always truncates it to the shortest presentation. </font><font style="vertical-align: inherit;">That is, the first bit of the denominator is not necessary to store. </font><font style="vertical-align: inherit;">In this case, the number ‚Äú3‚Äù can be represented only by the binary value ‚Äú1‚Äù and the value of the slash feature ‚Äú1‚Äù:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00001 00000000000000000000111 1 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This trick not only saved me one precious bit, but also has one excellent side effect: when the value of the fraction line is zero, this naturally means at the same time that the denominator is 1 and that no space is needed to store it. This means that my rational representation of numbers suddenly turned out to be fully compatible with ordinary integer representation and arithmetic, until the values ‚Äã‚Äãof the numbers rise above 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, to a sufficiently large threshold. </font><font style="vertical-align: inherit;">What a wonderful surprise! </font><font style="vertical-align: inherit;">That is, theoretically, I can use exactly the same data type, ‚Äúrational‚Äù, to perform standard rendering and shading operations, but also to perform all the logic and tasks of the command flow in the path tracer ‚Äî I no longer need to use two data types, as it happens in most renderers ("int" and "float") and perform conversions to one and the other side! </font><font style="vertical-align: inherit;">However, time was pressing me, so I did not change all the indexes of the cycles from ‚Äúint‚Äù to ‚Äúrational‚Äù. </font><font style="vertical-align: inherit;">The evening was coming to an end, but I still had to check out a lot of things to improve the quality of renders. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having created the implementation, I was able to verify it:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-bit rational numbers with a floating </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1 | 5 | 26)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-bit floating- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point</font></font></b></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;"> benchmark.</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oh, oh, not bad! I still have artifacts in the realm, which for the time being I will consider as the fault of my poor realization of the square root, but the parallelepiped and the triangle have become really clean. The number of accurately resolved image pixels also increased. I think that due to the fact that before the overflow, more numbers appear in the denominator or numerator, I increased the likelihood that the GCD will find common dividers and perform the reduction. That is, the floating fraction feature not only increased the interval of represented numbers and postponed the moment of normalization (with loss of accuracy) caused by overflow, but also took the next step in improving quality due to the increased likelihood of reductions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, I was ready to conduct a more serious test (but still experimental, until the system is ready for operation). </font><font style="vertical-align: inherit;">I implemented a path tracer with a minimal set of functions (not necessarily physically accurate or even taking into account physics) and created a scene with several rectangular parallelepipeds and two light sources, the reference implementation of which on the GPU is here: </font></font><a href="https://www.shadertoy.com/view/Xd2fzR"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.shadertoy.com/view/Xd2fzR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I again converted the scene into a C ++ framework, again deleted a few unnecessary ray normalizations and started rendering. </font><font style="vertical-align: inherit;">Here is what I got:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-bit rational floating </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature fractions</font></font></b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-bit floating- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point</font></font></b></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;"> reference</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wow, this is really good! </font><font style="vertical-align: inherit;">Although clearly visible leakage of light in the corners, where the edges of the floor and ceiling connect. </font><font style="vertical-align: inherit;">Look at them in an approximation: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They may be caused by a problem in my implementation of the intersection of the ray and the rectangular parallelepiped, which is only expressed in rational numbers; </font><font style="vertical-align: inherit;">I would not be surprised. </font><font style="vertical-align: inherit;">Or maybe I rested on the boundaries of what rational numbers are capable of. </font><font style="vertical-align: inherit;">Anyway, I'm quite pleased. </font><font style="vertical-align: inherit;">In addition, I have other changes and experiments that I wanted to test in the remaining short time:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some other experiments </font></font></h2><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 64 bit exact arithmetic </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãexact arithmetic cannot be realized neither in naive 64-bit rational numbers, nor in 32-bit (1 | 5 | 26) rational numbers with a floating fraction line. Will 64-bit floating point numbers work? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I quickly implemented rational numbers 1 | 6 | 57 (although I had to study the new x64 internal mechanisms for the bit shift). These 57 bits of the numerator / denominator allowed to trace a much longer interval of distances. I actually managed to trace the scene with several triangles with all the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exact</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arithmetic (not mentioned above scene with rectangular parallelepipeds and global illumination, but only a few triangles in front of the camera). And I was waiting for success! However, the coplanarity test, which I implemented to verify the correctness, required several scalar and vector product operations, which made the numbers begin to renormalize themselves. Therefore, even though I knew that the render was accurate, I could not ‚Äúprove‚Äù this experimentally. What irony. In general, this means that 64 bits was enough for several triangles, but more complex scenes will still fall apart. However, it made me think about another question: is there any algorithm that can be used to test coplanarity, based not on absolute values, but on modular arithmetic? Maybe,In modular arithmetic, rational numbers should not ‚Äúexplode‚Äù in size? I did not have time to investigate all this, and I am not an expert in number theory.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Square roots </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the last (second) evening of research, I decided to briefly dwell on this topic and study the new information. </font><font style="vertical-align: inherit;">I wanted to implement the best square root function possible for rational numbers. </font><font style="vertical-align: inherit;">My current naive solution ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bad</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) took the integer square root of the numerator (with the corresponding rounding), and then did the same with the denominator. </font><font style="vertical-align: inherit;">Since the square root of a fraction is a fraction of the square roots of the numerator and denominator, in general, this approach returns decent results, not too different from the best answer. </font><font style="vertical-align: inherit;">But he certainly does not return the best rational approximation of the square root of a rational number. </font><font style="vertical-align: inherit;">Instead of one approach, it performs two. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried the following: in the end, here we are looking for two integers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , such that</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we can rewrite this expression as finding the solution of the (non-trivial) following Diophantine equation (‚ÄúDiophantine‚Äù means that we are only interested in integer solutions): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a search on Wikipedia, I discovered that this particular equation is the so-called ‚ÄúPell's modified equation‚Äù (Modified Pell's equation). </font><font style="vertical-align: inherit;">There are algorithms that find the smallest </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">to solve this equation. </font><font style="vertical-align: inherit;">Unfortunately, my attention quickly shifted to another curious diophantine mathematics, and I did not begin to implement any of these algorithms.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> More effective reduction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the last minutes of the evening, I thought about exploring the idea of ‚Äã‚Äãusing multiple members that are combined in complex geometric operators, for example, in a vector product. Suppose the first component of a vector product was</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assuming that sy = a / b, tz = c / d, ty = e / f, sz = g / h </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This meant that now I can try to find common divisors, for example, between a and d, or e and h and use them for pre-cuts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I had another idea: if at some stage the rendering speed becomes a problem, then you can completely disable the GCD search steps and apply only normalization. A quick check showed that in this case, the rendered images still remain acceptable and work well at a much higher speed. However, we, of course, get a smaller number of arithmetically accurate results.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a compromise, you can refuse to implement the GCD procedure or scheme, and instead use something mathematically simple, hard-coded and effective in the code that determines the divisibility only by 2, 3 and 5. Even though we will not find an exhaustive number of dividers, In practice, this would lead to finding a large number of cuts. Consider - divisibility by 2 is three times more often than divisibility by 7, and 20 times more often than divisibility by 41!</font></font><br><br><h2>  Conclusion </h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After this experience, I began to believe that the existence of a representation of numbers based on rational numbers is quite possible, similar to what I call a ‚Äúfloating fraction‚Äù. A representation that is compatible with integers and that can perform many operations in exact arithmetic for many problems (provided that the input data is presented in a rational form). The 64-bit version (1 | 6 | 57) has a lot of potential, although the 32-bit version (1 | 5 | 26) already creates interesting renderings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it was not an experiment for two evenings, but something professional created in a studio or company, then in the future the following steps could be taken: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Get a histogram of the number of exactly and not exactly traced pixels (in other words, the frequency of normalization)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Try to implement hard-coded reduction on dividers 2, 3 and 5 and measure the percentage of lost exact pixels </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Show pixel difference between floating-point rendering and floating-line rendering </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Find creative ways to use unused values ‚Äã‚Äãof the floating-line fraction character, for example , to designate Inf and NaN </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Implement NaN, Inf, underflow, overflow detection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overall, it was a fascinating study. </font><font style="vertical-align: inherit;">In the process, I discovered several surprises, came up with one small invention and learned a lot about Pell's equation, square roots, GCD, x86_64 internal mechanisms, Riemann's zeta function, and some other aspects. </font><font style="vertical-align: inherit;">I am very pleased with this!</font></font></div><p>Source: <a href="https://habr.com/ru/post/448558/">https://habr.com/ru/post/448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448540/index.html">VMware NSX for the smallest. Part 5. Configuring a Load Balancer</a></li>
<li><a href="../448542/index.html">String sorting algorithm</a></li>
<li><a href="../448546/index.html">UITableView automatic header and footer sizes with AutoLayout</a></li>
<li><a href="../448550/index.html">The competition of reports on #PAYMENTSECURITY 2019 is open</a></li>
<li><a href="../448552/index.html">ProLiant 100th series - "lost younger brother"</a></li>
<li><a href="../448560/index.html">Plan AI-transformation: how to manage a company in the era of AI?</a></li>
<li><a href="../448562/index.html">Google helps police identify devices near crime scenes using location data</a></li>
<li><a href="../448564/index.html">First in the group - first in the mouth: risk assessment of leadership in self-organized groups of animals</a></li>
<li><a href="../448568/index.html">How to implement ISO 27001: instructions for use</a></li>
<li><a href="../448572/index.html">Human communication becomes a luxury item.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>