<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploring OpenCL through password cracking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Recently, after reading various articles and presentations about GPGPU, I decided to also try programming for a video card. In fact, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploring OpenCL through password cracking</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Recently, after reading various articles and presentations about GPGPU, I decided to also try programming for a video card.  In fact, the choice of technologies in this area is not great - only CUDA (proprietary standard nVidia) and OpenCL (free standard, running on ATI's GPU, nVidia, and also on central processors) are alive and well.  Due to the fact that my laptop has an ATI video card (Mobility Radeon 5650 HD), the choice has come down to only one option - OpenCL.  This article focuses on the process of learning OpenCL from scratch, as well as what came of it. <br><a name="habracut"></a><br><h4>  OpenCL and PyOpenCl Overview </h4><br>  At first glance, it seemed to me very confusing, both the control code in C and the code of the so-called kernels - kernels.  In the provided C API, even launching the simplest program takes a large number of lines, especially with handling at least some errors, so I wanted to find something more convenient and humane.  The choice fell on the <a href="http://mathema.tician.de/software/pyopencl/">PyOpenCL</a> library, from the name of which it is clear that the control code is written in Python.  Everything looks more understandable in it, even for someone who sees the code on OpenCL for the first time (of course, this applies only to simple examples).  However, the code of the cores themselves is still written in slightly modified C, so you will still have to study it.  Full documentation on it can be obtained on the standard developer‚Äôs website ( <a href="https://www.khronos.org/">Khronos</a> ), and information on specific implementations can be obtained on the ATI and nVidia sites, respectively. <br>  You can get the first impression about the language by the simplest example (adding two arrays): <br><br><pre><code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gid = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); c[gid] = a[gid] + b[gid]; }</code> </pre> <br><br>  And here is the full necessary code to run this example and validate (taken from the PyOpenCL documentation): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyopencl <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy.linalg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> la a = numpy.random.rand(<span class="hljs-number"><span class="hljs-number">50000</span></span>).astype(numpy.float32) b = numpy.random.rand(<span class="hljs-number"><span class="hljs-number">50000</span></span>).astype(numpy.float32) ctx = cl.create_some_context() queue = cl.CommandQueue(ctx) mf = cl.mem_flags a_buf = cl.Buffer(ctx, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=a) b_buf = cl.Buffer(ctx, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=b) dest_buf = cl.Buffer(ctx, mf.WRITE_ONLY, b.nbytes) prg = cl.Program(ctx, <span class="hljs-string"><span class="hljs-string">""" __kernel void sum(__global const float *a, __global const float *b, __global float *c) { int gid = get_global_id(0); c[gid] = a[gid] + b[gid]; } """</span></span>).build() prg.sum(queue, a.shape, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, a_buf, b_buf, dest_buf) a_plus_b = numpy.empty_like(a) cl.enqueue_copy(queue, a_plus_b, dest_buf) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> la.norm(a_plus_b - (a+b))</code> </pre><br></div></div><br><br>  Specific lines are immediately visible: creating a context, execution queues, creating and copying buffers to the device, as well as compiling and running the actual kernel.  About contexts and queues in OpenCL, you can read in detail in the documentation, and for relatively simple programs you only need one queue and one context, which will be created in lines that are very similar to those in the example.  In general, often the structure of calculations in programs on OpenCL look like this: <br><br><ul><li>  creating context, queue, program compilation </li><li>  copying data (buffers) to the device that do not change during execution </li><li>  cycle </li><li><ul><li>  copying data specific to this iteration to a device </li><li>  kernel execution </li><li>  copying the calculated data back to main memory, maybe some processing </li></ul><br></li></ul><br><br><h4>  Hashing SHA1 </h4><br>  It is time to go down a level and understand how the code of the kernel itself is arranged.  For whom, in order for the OpenCL function to run from the outside, it must be indicated by the __kernel attribute, have the value type void and a number of arguments, which can be either the values ‚Äã‚Äãitself (int, float4, ...), or pointers to areas memory __global, __constant, __local.  Also, for convenience, other functions that are called from the kernel can be declared for convenience, and this does not affect performance: all functions are automatically substituted (that is, as with the inline directive).  Related to this is that recursion in OpenCL is not supported at all. <br><br>  Using the fact that the OpenCL language is a modified C, you can take a ready-made implementation of the hashing function, for example SHA1, and with minor modifications use it: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> K1 0x5A827999 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> K2 0x6ED9EBA1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> K3 0x8F1BBCDC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> K4 0xCA62C1D6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> a0 0x67452301; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> b0 0xEFCDAB89; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> c0 0x98BADCFE; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> d0 0x10325476; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e0 0xC3D2E1F0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> f1(x,y,z) ( z ^ ( x &amp; ( y ^ z ) ) ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Rounds 0-19 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> f2(x,y,z) ( x ^ y ^ z ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Rounds 20-39 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> f3(x,y,z) ( ( x &amp; y ) | ( z &amp; ( x | y ) ) ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Rounds 40-59 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> f4(x,y,z) ( x ^ y ^ z ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Rounds 60-79 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROTL(n,X) ( ( ( X ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; n ) | ( ( X ) &gt;&gt; ( 32 - n ) ) ) #define expand(W,i) ( W[ i &amp; 15 ] = ROTL( 1, ( W[ i &amp; 15 ] ^ W[ (i - 14) &amp; 15 ] ^ \ W[ (i - 8) &amp; 15 ] ^ W[ (i - 3) &amp; 15 ] ) ) ) #define subRound(a, b, c, d, e, f, k, data) \ ( e += ROTL( 5, a ) + f( b, c, d ) + k + data, b = ROTL( 30, b ) ) #define REVERSE(value) value = ((value &amp; 0xFF000000) &gt;&gt; 24) | ((value &amp; 0x00FF0000) &gt;&gt; 8) | ((value &amp; 0x0000FF00) &lt;&lt; 8) | ((value &amp; 0x000000FF) &lt;&lt; 24) long sha1(uint *eData, const int length) { unsigned int A = a0; unsigned int B = b0; unsigned int C = c0; unsigned int D = d0; unsigned int E = e0; ((__local char *)eData)[length] = 0x80; for (int i = 0; i &lt;= length / 4; i++) { REVERSE(eData[i]); } eData[14] = 0; eData[15] = length * 8; subRound( A, B, C, D, E, f1, K1, eData[ 0 ] ); subRound( E, A, B, C, D, f1, K1, eData[ 1 ] ); subRound( D, E, A, B, C, f1, K1, eData[ 2 ] ); subRound( C, D, E, A, B, f1, K1, eData[ 3 ] ); subRound( B, C, D, E, A, f1, K1, eData[ 4 ] ); subRound( A, B, C, D, E, f1, K1, eData[ 5 ] ); subRound( E, A, B, C, D, f1, K1, eData[ 6 ] ); subRound( D, E, A, B, C, f1, K1, eData[ 7 ] ); subRound( C, D, E, A, B, f1, K1, eData[ 8 ] ); subRound( B, C, D, E, A, f1, K1, eData[ 9 ] ); subRound( A, B, C, D, E, f1, K1, eData[ 10 ] ); subRound( E, A, B, C, D, f1, K1, eData[ 11 ] ); subRound( D, E, A, B, C, f1, K1, eData[ 12 ] ); subRound( C, D, E, A, B, f1, K1, eData[ 13 ] ); subRound( B, C, D, E, A, f1, K1, eData[ 14 ] ); subRound( A, B, C, D, E, f1, K1, eData[ 15 ] ); subRound( E, A, B, C, D, f1, K1, expand( eData, 16 ) ); subRound( D, E, A, B, C, f1, K1, expand( eData, 17 ) ); subRound( C, D, E, A, B, f1, K1, expand( eData, 18 ) ); subRound( B, C, D, E, A, f1, K1, expand( eData, 19 ) ); subRound( A, B, C, D, E, f2, K2, expand( eData, 20 ) ); subRound( E, A, B, C, D, f2, K2, expand( eData, 21 ) ); subRound( D, E, A, B, C, f2, K2, expand( eData, 22 ) ); subRound( C, D, E, A, B, f2, K2, expand( eData, 23 ) ); subRound( B, C, D, E, A, f2, K2, expand( eData, 24 ) ); subRound( A, B, C, D, E, f2, K2, expand( eData, 25 ) ); subRound( E, A, B, C, D, f2, K2, expand( eData, 26 ) ); subRound( D, E, A, B, C, f2, K2, expand( eData, 27 ) ); subRound( C, D, E, A, B, f2, K2, expand( eData, 28 ) ); subRound( B, C, D, E, A, f2, K2, expand( eData, 29 ) ); subRound( A, B, C, D, E, f2, K2, expand( eData, 30 ) ); subRound( E, A, B, C, D, f2, K2, expand( eData, 31 ) ); subRound( D, E, A, B, C, f2, K2, expand( eData, 32 ) ); subRound( C, D, E, A, B, f2, K2, expand( eData, 33 ) ); subRound( B, C, D, E, A, f2, K2, expand( eData, 34 ) ); subRound( A, B, C, D, E, f2, K2, expand( eData, 35 ) ); subRound( E, A, B, C, D, f2, K2, expand( eData, 36 ) ); subRound( D, E, A, B, C, f2, K2, expand( eData, 37 ) ); subRound( C, D, E, A, B, f2, K2, expand( eData, 38 ) ); subRound( B, C, D, E, A, f2, K2, expand( eData, 39 ) ); subRound( A, B, C, D, E, f3, K3, expand( eData, 40 ) ); subRound( E, A, B, C, D, f3, K3, expand( eData, 41 ) ); subRound( D, E, A, B, C, f3, K3, expand( eData, 42 ) ); subRound( C, D, E, A, B, f3, K3, expand( eData, 43 ) ); subRound( B, C, D, E, A, f3, K3, expand( eData, 44 ) ); subRound( A, B, C, D, E, f3, K3, expand( eData, 45 ) ); subRound( E, A, B, C, D, f3, K3, expand( eData, 46 ) ); subRound( D, E, A, B, C, f3, K3, expand( eData, 47 ) ); subRound( C, D, E, A, B, f3, K3, expand( eData, 48 ) ); subRound( B, C, D, E, A, f3, K3, expand( eData, 49 ) ); subRound( A, B, C, D, E, f3, K3, expand( eData, 50 ) ); subRound( E, A, B, C, D, f3, K3, expand( eData, 51 ) ); subRound( D, E, A, B, C, f3, K3, expand( eData, 52 ) ); subRound( C, D, E, A, B, f3, K3, expand( eData, 53 ) ); subRound( B, C, D, E, A, f3, K3, expand( eData, 54 ) ); subRound( A, B, C, D, E, f3, K3, expand( eData, 55 ) ); subRound( E, A, B, C, D, f3, K3, expand( eData, 56 ) ); subRound( D, E, A, B, C, f3, K3, expand( eData, 57 ) ); subRound( C, D, E, A, B, f3, K3, expand( eData, 58 ) ); subRound( B, C, D, E, A, f3, K3, expand( eData, 59 ) ); subRound( A, B, C, D, E, f4, K4, expand( eData, 60 ) ); subRound( E, A, B, C, D, f4, K4, expand( eData, 61 ) ); subRound( D, E, A, B, C, f4, K4, expand( eData, 62 ) ); subRound( C, D, E, A, B, f4, K4, expand( eData, 63 ) ); subRound( B, C, D, E, A, f4, K4, expand( eData, 64 ) ); subRound( A, B, C, D, E, f4, K4, expand( eData, 65 ) ); subRound( E, A, B, C, D, f4, K4, expand( eData, 66 ) ); subRound( D, E, A, B, C, f4, K4, expand( eData, 67 ) ); subRound( C, D, E, A, B, f4, K4, expand( eData, 68 ) ); subRound( B, C, D, E, A, f4, K4, expand( eData, 69 ) ); subRound( A, B, C, D, E, f4, K4, expand( eData, 70 ) ); subRound( E, A, B, C, D, f4, K4, expand( eData, 71 ) ); subRound( D, E, A, B, C, f4, K4, expand( eData, 72 ) ); subRound( C, D, E, A, B, f4, K4, expand( eData, 73 ) ); subRound( B, C, D, E, A, f4, K4, expand( eData, 74 ) ); subRound( A, B, C, D, E, f4, K4, expand( eData, 75 ) ); subRound( E, A, B, C, D, f4, K4, expand( eData, 76 ) ); subRound( D, E, A, B, C, f4, K4, expand( eData, 77 ) ); subRound( C, D, E, A, B, f4, K4, expand( eData, 78 ) ); subRound( B, C, D, E, A, f4, K4, expand( eData, 79 ) ); A += a0; B += b0; C += c0; D += d0; E += e0; return as_ulong((uint2)(D, E)); }</span></span></span></span></code> </pre><br></div></div><br><br>  Here you need to make some explanations.  As an ‚Äúexperimental‚Äù password hash for cracking, I took LinkedIn leaked hashes, which are almost 6 million (unique).  There are several options for a fairly quick check of the presence in the list, I used hash tables (more on this later).  To reduce memory consumption and speed up work, the idea appeared to store not the full 20 bytes of SHA1, but the last 8 bytes, i.e.  single value long / ulong.  Of course, this increases the probability of a false coincidence, but it remains very small: of all the passwords I had, I had only 6 such cases, which is not at all critical.  Therefore, the truncated value is returned immediately from the above function (last 8 bytes).  Otherwise, everything is standard, the SHA1 algorithm is implemented directly according to the specification for the case of lines less than 56 bytes. <br><br><h4>  Brute force organization </h4><br>  Next you need to organize the search itself.  The simplest option is brute force, for all positions the same set of characters, and this can be directly implemented, for example, in a similar way: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_brute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ulong start_num, __global ulong *result, __global uint *res_ind)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s[<span class="hljs-number"><span class="hljs-number">64</span></span>]; uint *s_l = (__local uint *)s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; ulong _n, n; ulong start = start_num + get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>) * HASHES_PER_WORKITEM; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; HASHES_PER_WORKITEM; j++) { n = _n = j + start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">15</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { s_l[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = COMB_LEN - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { s[i] = charset[n % CHARS_CNT]; n /= CHARS_CNT; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_in_table(table, sha1(s_l, COMB_LEN))) { result[atomic_inc(res_ind)] = _n; } } }</code> </pre></div></div><br><br>  Here HASHES_PER_WORKITEM is the number of hashes processed in one run by one work item (stream), COMB_LEN is the length of the combination, charset is an array of characters, CHARS_CNT is the number of characters in the array.  As you can see, when the kernel is launched, a pointer to the hash table, the password number from which the search starts, and a pointer to the array for outputting the result and the index in it are passed. <br><br>  In OpenCL, not one thread is launched at once, but some of them, called the global work size, and all the threads get the same arguments.  In order for each of them to go through its own part of the key space, the string <code>ulong start = start_num + get_global_id(0) * HASHES_PER_WORKITEM;</code>  calculates the number for a specific thread (get_global_id (0) - a standard function that returns a thread index from 0 to the current global work size). <br><br>  Next, each stream of the HASHES_PER_WORKITEM passwords is iterated, each of which is hashed by the sha1 function and checked for the presence of the check_in_table function, which is further on.  In this form, and with the simplest implementation of a hash table, I got the result of about 20 million passwords per second, which frankly is not much compared to, for example, oclHascat, which gives out more than 300 million on my laptop (even the fact that the check is in the large list of hashes does not justify this).  Looking ahead, for a simple brute force, I managed to reach a speed of 160 million per second, which is more than half the speed of oclHascat (with one hash). <br><br><h4>  Hash table </h4><br>  So, check for the existence of a hash.  The first implemented variant was the simplest <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">openly addressed hash table</a> .  It was filled in, in order not to complicate matters, with a processor, and not with a video card, in OpenCL there were only queries to it.  This case looked like this: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_in_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ uint index = calc_index(value); uint step = calc_step(value); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint a = <span class="hljs-number"><span class="hljs-number">1</span></span>; ; a++) { index %= TABLE_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table[index] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table[index] == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } index += a * step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre></div></div><br><br>  I tried different table sizes and probing methods, but the speed did not improve significantly.  While searching for material on hash tables on GPU, I came across the article ‚ÄúBuilding an Efficient Hash Table on the GPU‚Äù by <a href="http://www.cs.berkeley.edu/~volkov/">Vasily Volkov</a> , which mentions a certain <a href="http://en.wikipedia.org/wiki/Cuckoo_hashing">Cuckoo Hashtable</a> (I don‚Äôt know if there is a well-established Russian translation) did not hear.  In short, its essence is to use several hash functions instead of one and a special filling method, after which an element is found in no more than k memory accesses, where k is the number of hash functions.  Since the speed of work is more important to me than the memory I occupy, I used k = 2.  Filling it also occurs on the CPU. <br><br><h4>  Conclusion </h4><br>  Of course, the optimizations also affected another part of the code, namely the generation of passwords.  In the above variant, several non-optimal places are immediately visible, for example, each next password is generated from scratch, although you can change the previous one.  There are other places to optimize, in particular, specific to OpenCL: using global or constant memory for an array of characters instead of much faster local memory (read more about memory areas directly from the developer of a specific implementation).  However, it‚Äôs worth writing a separate article about various kernel code optimizations with details, but here I‚Äôll say that when programming for a GPU, it‚Äôs worth trying different options and looking at their speed, because  It is not always possible to tell by eye that it will work faster.  Sometimes even the removal of some instructions slows down the execution, and significantly. <br><br>  Later I added support for different alphabets for different positions, as well as, more significantly, alphabets of words, and not just individual characters.  For convenience and flexibility, the kernel code is processed by the Mako template engine.  All this is in the archive (see below). <br><br><h4>  findings </h4><br>  So, in the end, I acquired: <br><ul><li>  OpenCL knowledge with many subtleties (from scratch, I think that is quite successful) </li><li>  raised the level of programming in Python (not quite from scratch, but from a fairly low level) </li><li>  I found out and tried the related technologies: Cython compiler, Mako template engine, VCS git (I haven't used it before) </li></ul><br><br>  Tangible results: <br><ul><li>  the program goes through passwords at a speed of about 160 million per second for a simple brute force (when using an alphabet of words rather than characters, the speed is less: from 50 million per second) on a notebook video card - can be compared on one side with 300 million from oclHascat working with one hash, and on the other with 30 million of the fastest brute forcer on the CPU (I have i5 2.5 GHz), written using assembler and SSE instructions </li><li>  with its use and without any tricks, about 2.5 million passwords from LinkedIn hashes were picked up (not so much, but here I didn‚Äôt strive for a record) </li><li>  You can download it <a href="">here</a> (in some places there is a terrible govnod!), you need Python 2.7, numpy, PyOpenCL, Cython, Mako and a file with LinkedIn hashes to run. </li></ul><br><br>  Impressions: <br><ul><li>  Python is a very slow language (but simple enough to write), processing large lists in cycles is very slow, as well as various comprehensions, which is why Cython is used for some parts of the program - by the way, a really convenient thing </li><li>  With the proper approach to profiling and subsequent optimizations, OpenCL can work very quickly, and you don‚Äôt need to rewrite anything in assembler </li></ul><br><h4>  PS: </h4><br>  Various comments and recommendations are welcome. </div><p>Source: <a href="https://habr.com/ru/post/150289/">https://habr.com/ru/post/150289/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150280/index.html">Which SIP server to choose: SER, OpenSER, Kamailio, OpenSIPS? What do they have in common and what is the difference?</a></li>
<li><a href="../150283/index.html">ZTE welcomes Habr</a></li>
<li><a href="../150285/index.html">Nekki internship program</a></li>
<li><a href="../150287/index.html">Site done, what next? Organization of web-studio support services</a></li>
<li><a href="../150288/index.html">Programmers and management</a></li>
<li><a href="../150290/index.html">Speakers' Corner: A Nontrivial Approach to Web Design by Pavel Kondratenko</a></li>
<li><a href="../150292/index.html">Android smartphones will control NASA satellites</a></li>
<li><a href="../150293/index.html">The backdoor for the brain has already been created!</a></li>
<li><a href="../150294/index.html">Original Samsung</a></li>
<li><a href="../150295/index.html">40 million installations of Web Of Trust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>