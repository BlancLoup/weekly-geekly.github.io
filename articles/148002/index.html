<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The ideal student, or what is silent in machine learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier, habrahabr.ru/post/145309 we reviewed the approach to universal artificial intelligence (AI). But what is a universal AI? What exactly is lack...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The ideal student, or what is silent in machine learning</h1><div class="post__text post__text-html js-mediator-article"> Earlier, <a href="http://habrahabr.ru/post/145309/">habrahabr.ru/post/145309</a> we reviewed the approach to universal artificial intelligence (AI).  But what is a universal AI?  What exactly is lacking in modern practical AI systems to be called universal?  For more specificity of the discussion of this issue, let's consider it on the example of machine learning, which is a necessary component of AI. <a name="habracut"></a><br><br>  Machine learning has long overgrown the boundaries of the field of academic artificial intelligence and has come to "ordinary programmers."  Many applied tasks use practical methods of data mining, pattern recognition, statistical inference, etc.  Large firms arrange various courses and schools for automatic data analysis, create basic departments, participate in the organization of conferences and carry the knowledge gained in machine learning to the world by other means.  Scientists, too, are not lagging behind: they are inventing new methods and are working on new subregions, such as the current transfer training. <br><br>  However, such a development of this area in breadth does not particularly contribute to its development.  On the contrary, simplified interpretations of the fundamentals of machine learning (despite the fact that these interpretations are often supported by a rather complicated theory) are spreading, allowing one to obtain particular practical solutions.  The latter, of course, is not bad, but the problem of universal methods of machine learning remains unsolved (and even ignored).  At the same time, on the one hand, myths about universal methods of machine learning (such as neural networks), which in reality are not, were popularized in the ‚Äúapplied‚Äù environment.  On the other hand, the ‚Äútheorists‚Äù lost faith in the possibility of creating universal methods of machine learning, which means that any attempt to propose a new universal method is a priori labeled ‚ÄúYet Another Classifier‚Äù or ‚ÄúNo Free Lunch‚Äù theorem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The most striking thing about this is that the theory of truly universal machine learning has existed for already half a century, and many of the arguments of modern researchers in the context of this theory look very naive.  What is this theory?  How does she solve machine learning problems?  Why she has not received much distribution so far?  And is it still possible to make a universal machine learning system?  We will try to get closer to the answers to these questions, but first we will show the need for universal training for strong AI. <br><br>  The main problems of machine learning can be demonstrated by the example of such a ‚Äúsimple‚Äù task as functional approximation and extrapolation.  Ultimately, an intelligent agent needs to establish a connection between the sensory input and the motor output, or learn to extrapolate the magnitudes of the reinforcements from the environment depending on the actions performed, so the connection of this task with the AI ‚Äã‚Äãis undeniable. <br><br>  Let's look at the sequence of points shown in Fig.  1. How to continue it?  At first, it seems absolutely natural that to solve this problem, you need to select a function that runs the most closely to the existing points, and this function will be the best solution. <br><br><img src="http://aideus.ru/habr/fig1.png" alt="image"><br>  Fig.  1. How to continue the points? <br><br>  In mathematics, there are various theorems that some arbitrary function, the form of which is not imposed significant restrictions (except, perhaps, continuity and differentiability), can be approximated by functions of a certain type with an arbitrary accuracy.  In particular, it is precisely because of such theorems that artificial neural networks (INS) have a reputation of universal approximators.  It's funny that such a reputation has developed precisely with the INS, and not, say, with polynomials, for which similar theorems were proved much earlier. <br><br>  But what do these theorems mean in terms of machine learning?  The fact that approximation of some functions by other functions is possible in principle does not mean at all that it can be implemented in practice.  After all, in practice there is a training sample of always finite size, and besides, it is often noisy.  Let's see how approximation will work in such conditions.  For this we use polynomials, since the result for them will have a more transparent interpretation. <br><br>  We will choose the parameters of polynomials of different degrees so that these polynomials pass most closely to the points of the training sample, that is, we use the least squares method, which in this case has a very simple implementation.  In fig.  2 shows solutions for a linear function, a parabola and a cubic function.  The last (red) point was not included in the training sample and corresponds to the true dependence. <br><br><img src="http://aideus.ru/habr/fig2.png" alt="image"><br>  Fig.  2. The results of the construction of polynomials of the 1st, 2nd and 3rd degrees. <br><br>  As if all is well: by increasing the degree of the polynomial, it is possible both to reduce the deviations from the points of the training sample and to improve the prediction accuracy.  But try to continue to increase the degree further.  In fig.  3 shows solutions for polynomials of the 4th, 7th and 10th degrees. <br><br><img src="http://aideus.ru/habr/fig3.png" alt="image"><br>  Fig.  3. The results of the construction of polynomials of the 4th, 7th and 10th degrees. <br><br>  As you can see, the accuracy of the training sample increases, and the 10th degree polynomial passes ideally through all points, but the prediction accuracy drops dramatically!  This is a well-known effect of overfitting.  To some, this effect may seem completely mystical: ‚ÄúWe are improving the approximation on the available sample, except for which there is no data!  Why is it really getting worse? ‚Äù  And it will seem trivial to someone: ‚ÄúWhat did you expect if you try to adjust your model to the noise in the data?‚Äù.  However, regardless of the attitude to this problem, it does not disappear anywhere.  It manifests itself, of course, in the case of the INS.  This problem in the field of machine learning is omnipresent: it is typical not only for approximation and extrapolation, but also for pattern recognition, segmentation, clustering, etc.  How can you deal with it? <br><br>  Here different approaches are possible.  In the case of some classes of neural networks, training is specifically interrupted, until the INS has not managed to adapt too much to the data (even special heuristic criteria have been developed that determine the most suitable moment for stopping the training).  In this regard, this phenomenon has a second name - overlearning.  In simple terms, this is cramming, in which the system concentrates on concrete examples.  This disadvantage is also peculiar to the training of students, if their training and assessment of its quality is carried out according to the same tests. <br><br>  Another simple way of dealing with this effect is cross-checking, or cross-validation, the idea of ‚Äã‚Äãwhich is to select a test from the training set.  In this case, training is performed on one part of the sample, and the quality of training is evaluated on the other part.  That is, since we want our solution to work well not on the data on which we trained it, but on new data, let's check it out.  This approach has its drawbacks.  First, the size of the training sample decreases, and, therefore, the quality of the model under construction also deteriorates.  Secondly, such an approach is still prone to retraining, albeit to a weaker one: overly close fitting indirectly occurs in relation to the control sample (it suffices to recall how schoolchildren are dragged into the USE without special benefit for learning).  To weaken this effect, the training sample is divided into many parts (say, 10) and, alternatively, the quality of the solution is tested on different of them, which, however, increases the computation time and exacerbates the first drawback.  And, thirdly, this approach is not too easy to apply when teaching without a teacher. <br><br>  In any case, neither early interruption of training, nor cross-training do not answer the question about the nature of retraining and look strange: if you study poorly for a long time or use all the available information, then something must be wrong in the learning process itself.  Let's try to figure it out.  Re-training occurs when the space of models is too large, for example, arbitrary degree polynomials or neural networks with any number of neurons are used (because of this, it is sometimes thought that in practice such spaces are meaningless to consider - there is too much ‚Äúcreative freedom‚Äù in them this is not fashionable nowadays when teaching people).  Hence, the problem is to choose the best from a large number of models.  To solve it, you need at least an adequate criterion for the quality of the models. <br><br>  A hint at the nature of retraining is provided by probability theory.  By Bayes' rule, the best <i>M</i> data model <i>D</i> will be the model with the maximum posterior probability <i>P (M | D)</i> , which is proportional to the product likelihood of the data for this model <i>P (D | M)</i> multiplied by the a priori probability <i>P</i> model <i>(M)</i> : <br><br>  <i>P (M | D) ~ P (D | M) P (M).</i> <br><br>  Here, the accuracy with which the model describes the data corresponds to the likelihood, which, under the assumption of a normal distribution of errors (deviations of the model from the data), is explicitly expressed in terms of the standard deviation.  If only maximizing it (that is, using the maximum likelihood method), then just the effect of retraining occurs.  This means that, in accordance with the Bayes rule, it is possible to choose a less accurate, but not prone to retraining, the model can only be provided by a priori probabilities <i>P (M).</i> <br><br>  The problem of prior probabilities in statistical inference is fundamental.  After all, these probabilities are a priori, that is, they must be miraculously determined before receiving the data.  If we have a lot of data sets, then the prior probabilities of the models are the probabilities that the particular model will be the best for some arbitrary set.  But this only complicates the task: after all, when determining a priori probabilities for many data sets, we again need some a priori probabilities so that no retraining occurs.  And so on.  Although we found out that the problem of retraining is connected with the problem of setting a priori probabilities, but this is not so much easier. <br><br>  An interesting observation, however, can be made if the Bayes rule is prologized and, instead of maximizing the a posteriori probability itself, the minus logarithm of it is minimized: <br><br>  <i>‚ÄìLog <sub>2</sub> P (M | D) ~ ‚Äìlog <sub>2</sub> P (D | M) - log <sub>2</sub> P (M).</i> <br><br>  The minus logarithm of probability is just the amount of information, and <i>‚Äìlog <sub>2</sub> P (M)</i> is the amount of information in the model (the length of its description in bits), and <i>‚Äìlog <sub>2</sub> P (D | M)</i> is the additional amount of information in the data, with existing model (in fact, the length of the description of data deviations from the model, which characterizes its accuracy).  If we ignore the method of calculating the amount of information through probabilities, we can see the following.  The amount of information in the model is its complexity.  Say, the more members of our polynomial or neurons and the connections between them in the ANN, the more bits will be spent on coding such models. <br><br>  The need to find a compromise between the complexity of the model and its accuracy is expressed in the principle of the minimum description length, which states that the best model is the model for which the minimum length of the description of data deviations from the model (or data encoded with the model) and the complexity of the model itself are achieved.  This principle is sometimes called the formalization of Occam's razor rule, which has long indicated that you should not produce entities beyond necessity. <br><br>  It is important here that the complexity of the model can be considered directly, and not through its prior probability.  In fact, there is a correct opportunity to introduce the concept of the amount of information to the notion of probability (and the theory of probability to derive from information theory, and not vice versa), and thereby solve a number of fundamental problems inherent in both the theory of probability and the classical (Shannonovskaya) based on it information theory.  But this is a topic for another discussion. <br><br>  So, the model should have the less a priori probability, the higher its complexity.  Such a penalty of models for complexity in practice rather well replaces other methods of eliminating the effect of retraining.  Overtraining occurs when choosing a too complex model.  The simpler the model, the more general it is.  Obviously, retraining is associated with insufficient generalization.  It is the lack of generalization that is the cause of the poor quality of training in cramming or fitting training to tests.  There is, of course, another extreme, when using one simple model they try to describe too much, regardless of errors or the fact that the model does not simplify (‚Äúdoes not compress‚Äù) the data.  Information criterion allows you to find the right compromise. <br><br>  However, the general problem of machine learning is still not solved.  The impossibility of correct generalization may be due to the fact that the required model is simply not present in the used model space. <br>  Let's go back to the polynomial approximation example.  If the true model for us is a polynomial, then everything will be fine - the description length criterion will allow you to select a polynomial with the optimal number of parameters that provides the best (with the available data) prediction.  But what happens if the data is generated by some other function?  Will it save us that this function can in principle be approximated by some polynomial? <br><br>  Take, for example, the exhibitor.  It is described by a number of terms of the form <i>xn / n !.</i>  But in this series there are an infinite number of members.  And the sample of points we will have is finite, therefore the reconstructed polynomial will also have a finite degree.  So, extrapolating the error will still accumulate very quickly, and no criterion will help us.  Equally, if the data contains a harmonic relationship, then it will not be well extrapolated by either polynomials or exponents whose finite series cannot be periodic.  Of course, some types of dependencies can be better or worse extrapolated by other types, but it can be said that if we do not have exactly the type of dependencies in the model space contained in the data, then we will not get the best prediction. <br><br>  The same can be said not only about prediction, but also, say, about recognition.  In the case of recognition, this problem is most clearly manifested in the problem of invariants.  If some images from a certain class satisfy some invariant, then the work of the recognition system will not be good enough if it cannot learn this particular invariant.  In particular, this is why neural networks for image recognition either require that they immediately be given signs that are invariant to geometric transformations of images, or require samples of huge sizes.  So, if a perceptron is shown to present recognizable objects in one part of the image during training, it will not be able to recognize them, if they are then presented in another part of the image. <br><br>  It is this kind of perceptron criticism that was contained in the famous book by Minsk and Papert: they are not able to build non-local invariants (to carry out an appropriate generalization) and require a training sample of exponentially large size in order to learn to recognize an image in all its forms.  Even if perceptrons are not retrained in this case, they do not achieve the main goal of effective training - to identify the underlying laws, which allow to perform prediction or recognize patterns in a form that has not been encountered before. <br><br>  The inability to express patterns of arbitrary types is characteristic, naturally, not only for specific ANN architectures, but also for other machine learning methods.  All of them use some limited way to represent patterns, for example, in the form of a specific family of basic functions, which are decomposed.  The same can be said about symbolic training when using, for example, decision trees or sets of rules.  In complex systems based on knowledge, this problem may be veiled, but not solved at all. <br><br>  Naturally, there is a desire to try to combine different methods that take into account various possible patterns in the data.  And this approach is really quite popular now.  However, a simple combination of non-universal methods only slightly increases their capabilities, since developers can manually lay only a relatively small number of different families of patterns. <br>  But is it possible to put in the machine learning system the ability to identify any possible regularities?  Is there a space in which arbitrary patterns that are not specifically provided by the developer in advance are constructively described?  This space is not only there;  it is also generally known.  This is a space of algorithms. <br><br>  Need to reproduce exponential dependency?  Such an algorithm is easy to build.  Need polynomials, harmonic functions, Fibonacci sequence, factorial?  There are also such algorithms.  Need to recognize classes of even and odd numbers?  Using the appropriate algorithm is easy!  And now think how easy it would be to solve all these tasks simultaneously using the INS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, in order for the comparison to be correct, a method is needed that itself would build all these algorithms upon presentation of the corresponding training set. But here the main thing for us is that in the space of algorithms, at least, there are suitable solutions for all such problems.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, in order for the machine learning system to be universal, it is necessary that it can deduce any pattern. Modern machine learning methods do not satisfy this requirement; therefore, it is doubtful that a universal AI can be built on their basis. For such an AI, it is natural to use a set of algorithms as the ‚Äúspace of all possible laws‚Äù. Of course, one can argue whether a set of algorithms really contains all the possible laws (we, however, have already written that the algorithmic approach is enough to implement AI </font></font><a href="http://habrahabr.ru/post/145929/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habrahabr.ru/post/145929</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). In any case, modern methods of machine learning work in highly restricted subspaces of algorithms. And if it is possible to ‚Äúat least‚Äù use algorithms of an arbitrary type as models, then the possibilities of machine learning will unimaginably expand. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the overwhelming majority of teaching methods are implemented in the form of algorithms, the idea of ‚Äã‚Äãgoing through algorithms as potential solutions to learning problems may even seem trivial. And so much the better. However, there are many algorithms capable of reproducing the available data (including the algorithm that simply ‚Äúremembers‚Äù the training sample), and the fact that the length description criterion allows you to choose the best solution to the training problem is not so obvious.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A universal method that works in the space of algorithms and uses the criterion of algorithmic complexity for the general solution of the problem of induction (machine learning) was proposed by R. Solomon in 1964. True, this method requires almost infinite computational resources, which is quite understandable given the complexity of brute-force algorithms. Not surprisingly, pragmatically minded researchers, he was completely ignored. However, this does not mean that you need to look where it is light, and not where you lost it. To create a strong AI, you need to get as close as possible to the effective implementation of such a universal learning method, otherwise (that is, if you use only modern practical methods of machine learning), the AI ‚Äã‚Äãcannot really learn anything. From understanding, in particular,This fact results in such a field of research as universal AI. How to get closer to solving a problem is a topic for another difficult conversation.</font></font></div><p>Source: <a href="https://habr.com/ru/post/148002/">https://habr.com/ru/post/148002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147993/index.html">The largest index of pirated content</a></li>
<li><a href="../147996/index.html">Networks for the smallest. Part Five ACL and NAT</a></li>
<li><a href="../147999/index.html">"Toy" cartography or 3D cards do it yourself</a></li>
<li><a href="../148000/index.html">Edit-in-place on Bootstrap components</a></li>
<li><a href="../148001/index.html">Review of fresh materials, April-June 2012</a></li>
<li><a href="../148003/index.html">Completed the contest on VK messenger for Android</a></li>
<li><a href="../148004/index.html">Increase web application stack security (LAMP virtualization, step 1/6)</a></li>
<li><a href="../148009/index.html">Runetology (156): Sergei Bulaev, the creator of ‚ÄúBuy a loaf!‚Äù And ‚ÄúTiny Beach‚Äù</a></li>
<li><a href="../148010/index.html">The whole PHP in two lines</a></li>
<li><a href="../148011/index.html">Intel and The Code Project competition for Android games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>