<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Copying partitions on a hard disk using GNU / Linux: how to manage a bootable USB flash drive where Acronis was previously needed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the good news of the existence of an operating system called GNU / Linux, which is used by all real programmers, I have tried several times, I t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Copying partitions on a hard disk using GNU / Linux: how to manage a bootable USB flash drive where Acronis was previously needed</h1><div class="post__text post__text-html js-mediator-article">  Since the good news of the existence of an operating system called GNU / Linux, which is used by all real programmers, I have tried several times, I tried to replace the brainchild of Bill Gates and failed several times. <br><br>  There were no gurus nearby, Internet access was tightly restricted and therefore any non-trivial task became completely unsolvable at that time. <br><br>  Then, when the unlimited Internet appeared, as a result, with the receipt of software and knowledge, it became much easier, I set up a dual boot and began to master Ubuntu. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main difficulties in the process of relocation were created primarily because of the need to drop familiar programs almost from childhood, which are simply not available in the operating system for real programmers. <br><br>  In most cases this was not fatal.  Instead of the usual foobar, you can always listen to music on Rhythmbox.  Instead of Microsoft Office, there is OpenOffice.  Yes, its compatibility with the product of the corporation of evil sometimes leaves much to be desired, but it is quite possible to use it for solving everyday problems of the average user.  About any Firefox, Opera and Chrome, I generally keep quiet. <br><br>  But in some cases it was necessary to reboot the computer, select the Microsoft Windows item in the bootloader menu and do everything in the old fashioned way.  Such a task was for example the removal of the image of a logical disk in order to transfer to another physical medium, because the current one was pretty dumb. <br><a name="habracut"></a><br>  The program that was used in such situations was Acronis.  Intuition suggested that it would take at least a week to figure out how to do without him, and the result usually needed an edge in half an hour, so asking was postponed, postponed and postponed. <br><br>  But after another friendly joke about nobody needed and not knowing anything, and therefore a free Linux, I decided that the next time I would need nothing more than a bootable USB flash drive and the command line to create a disk image.  And he went to google. <br><br>  Google created a clear impression that each dog knows how to clone disks using open source operating systems.  Alas, clear instructions on the implementation of well-known and elementary things are usually the most difficult to find.  Some manuals as a result of stubborn searches eventually came to light, but still they were tight, because they were clearly written by literate people who mess around with the topic not for the first or even the second day, and simply don‚Äôt remember that the knowledge that they honored for the required minimum, not everyone owns. <br><br>  Now that the horrors of googling are over, I understand that everything is really quite simple and I want to formalize the results of my research in the form of a brief guide on working with disk images in GNU / Linux, addressed primarily to those who are used to Acronis or another the program.  In due time such a document would help me very much, I hope that it will help someone else. <br><br><h2>  Acronis </h2><br>  In Acronis, everything was simple and clear: the window interface, hints and previous experience with images of CDs made the process simple.  He took off the image, put in a new screw, unrolled the image on it - there was nothing even to tell about it.  In the case of Linux, the process choked at the stage of removing the image - how to do this was absolutely unclear.  There was no special program with prompts, a program that added a virtual DVD to the device list - like Daemon Tools too.  Yes, and the list of devices turned out to be quite problematic, so you can start right from it. <br><br><h2>  View the list of drives </h2><br>  For each connected drive (hard drive, flash drive) in the / dev directory you can find the corresponding file.  Its name consists of the letters <b>sd</b> and the letter designating the device number.  That is, the hard drive connected to the first channel will match the sda ‚Äã‚Äãfile, the second sdb, and so on.  Accordingly, the easiest way to view the list of devices is <b>ls -1 / dev / sd [az]</b> .  This command will show the list of drives, but will not give us any information about them.  And we need to at least see the list of sections. <br><br><h2>  View the list of sections on the drive </h2><br>  Each section in the dev directory also has a file.  Its name is built from the name of the file corresponding to the drive and the partition number.  That is, for the sda ‚Äã‚Äãdrive, on which there are 2 partitions, 2 files will be created in the / dev directory - sda1 and sda2.  You can view the list of partitions on the sda ‚Äã‚Äãdrive using the <b>ls -1 / dev / sda [0-9] command; the</b> full list of partitions on all devices is obtained at the output of the <b>ls -1 / dev / sd [az] [0-9] command</b> , and if necessary include the devices themselves in the list, then you can simply write <b>ls -1 / dev / sd *</b> , which is much less meaningful, but briefly and most importantly works.  Or, as suggested in the comments, there is another option <b>cat / proc / partitions</b> <br><br>  Often, the owner can identify the disk simply by the following list (this is when it does not have 452 disks), but if this is not enough, then you can use the <b>hdparm</b> program. <br><br>  Specifically, <b>hdparm -I / dev / sda</b> will print detailed information about the device / dev / sda. <br><br>  The same information, but in a form scattered across different files, can be found in the <b>/ sys / block / sda</b> directory.  For example, the disk model is in the <b>/ dev / block / sda / device / model</b> file. <br><br>  If this is not enough, then it remains only to mount the devices in turn and watch what is recorded on them.  But that's another story. <br><br><h2>  Image removal </h2><br>  So, the device is recognized and the section from which you want to remove the image is found.  Now the process itself. <br><br><h3>  General recommendations </h3><br>  A disk image is what we usually call a disk copy at the partition level or the entire device.  And if the Windows user in response to the question of how to make this copy, usually hears a recommendation to use a specialized software, then in Linux this is not the case. <br><br>  As I said, here each disk and each disk partition is represented by a specific file.  And, since the image is a file with a copy of the disk, it is logical to assume that the operation of removing the image and the operation of copying the partition file are one and the same. <br><br>  The way it is.  Suppose we need to remove the image of the / dev / sda2 partition (on it, Windows 7 usually holds the C drive :) and save it to a file called win_c.img. <br><br>  To do this, just write <b>cp / dev / sda2 win_c.img</b> .  Or <b>cat / dev / sda2&gt; win_c.img</b> .  In short, you can use any program or combination of programs that copies files. <br><br><h3>  The right way </h3><br>  As you probably already guess, you can achieve the desired not in one or even in two, witty and not so ways, but in my opinion it is more correct and easiest to use the <b>ddrescue</b> utility.  What is essentially important is referring to <b>GNU ddrescue</b> , and not long ago the outdated original. <br><br>  She, like cp, is copying files, but if errors are found, ddrescue will not stop working with the joyful message that the patient is more dead than alive, and will remember the place with an error to return to it later and try to read again .  Now slowly and gently. <br><br>  Ddrescue is used as follows: <br>  <b>ddrescue &lt;keys&gt; &lt;file which is copied&gt; &lt;new file, into which we copy old&gt; &lt;log file&gt;</b> <br><br>  ddrescue is not able to receive input data from the pipeline, or transmit the result of the work to the conveyor, which, however, is not surprising.  The ability to skip places with errors during the first iteration and return to them in subsequent cycles implies the presence of files on the output and input. <br><br>  The command that performs the operation similar to that described above will look like this: <br><br>  <b>ddrescue / dev / sda2 win_c.img win_c.img.log</b> <br><br>  By the way, at the moment I silently mean that the hard disk from which we remove the copy is more or less intact and does not throw out the tricks.  If there are serious problems with the disk, it is better to get acquainted with the details of using ddrescue, for example, <a href="http://habrahabr.ru/post/56796/">here</a> .  and apply this knowledge when removing the image. <br><br><h3>  Wrong way </h3><br>  You can often find recommendations to use a program called dd to copy a device file or partition.  As a rule, to remove the image it is proposed to do something like this: <br><br>  <b>dd if = / dev / sda2 of = win_c.img</b> <br><br>  Do not do this!  Although the semantic approach is correct (copying one file to another will occur), the consequences can be very sad.  Yes, dd exceeds cp in the sense that if an error is detected, cp stops working and dd does not stop, but if there are broken or badly readable sectors on the disk, then dd will continue to try to read their contents until the hard drive starts to smoke. <br><br>  Yes, dd has the argument <b>noerror</b> , but when using it, copying can be performed with errors, no attempt to restore them will be made.  ddrescue in a similar situation after the first pass will return to the missing places and try to read them in small pieces.  And leave a log file with which you can continue to try to subtract bad places in the future. <br><br>  In short, use ddrescue.  And if there is nothing except dd, do not forget about the argument noerror. <br><br>  The procedure described above can be used, for example, to save a disk image with a newly installed operating system for later recovery.  Yes, a real Linux user will not do that, but this is a fairly common practice among users of the operating system with a different name.  And for periodic thoughtful repair of a regularly breaking computer of some kind of pretty girl, even penguin lovers can safely use it.  And if there are more girls than some, strictly individual for each self-made quantity, then this method is simply irreplaceable.  The main thing is not to confuse the names of files with images. <br><br><h2>  View the contents of the partition image (logical drive) </h2><br>  Since each disk partition is represented by a file, it can be assumed that there should be a regular way of connecting image files to the file system.  From a certain point of view, it is.  Specifically, the <b>mount</b> utility is used for this, with which you can place the tree of files contained in the image in any directory of your choice.  This process is called mount. <br><br>  So, we already have an image taken from the C: drive of the Windows 7 operating system. We called the image win_c.img and want to see its contents in the previously created directory <b>/ mnt / win_c</b> .  To do this, enter the command <b>mount -o loop win_c.img / mnt / win_c</b> . <br><br>  This is how you can make sure that the image that you are going to roll onto the hard drive of the next pink laptop is the image of that C: drive that is expected to be seen on this particular machine.  Well, or you can simply copy files from it without which you can‚Äôt do anything and send this image into outer darkness.  And on the laptop to put the last Ubuntu or Fedor. <br><br>  But we can go deeper. <br><br><h2>  View the contents of the physical disk image </h2><br>  But with the mounting of the disk image is not so simple.  The terrible truth is that the kernel does not know how to mount files from an arbitrary location in the file system and the argument -o loop, the mount command, signals that you first need to associate the image with the virtual device file in the / dev directory, and then attach the contents of this devices to the file system. <br><br>  Virtual device files are created in advance (at the system boot stage) and have the names loop0, loop1, loop2, and so on in ascending order. <br><br>  You can <b>associate a</b> partition image with one of these files with the <b>losetup</b> command.  The mount command from the previous section is actually equivalent to the following two commands. <br><br>  <b>losetup / dev / loop0 win_c.img</b> <br>  <b>mount / dev / loop0 / mnt / win_c</b> <br><br>  But in order to view the contents of the image in which there are several sections, this is not enough.  The fact is that if you run the losetup command for such a file, then the entire image will be associated with the / dev / loop0 device.  That is, this device will be equivalent to / dev / sda, and we need equivalents of / dev / sda1 and / dev / sda2. <br><br>  Holders of the latest versions of losetup (read gents and archwingers) can execute losetup with the <b>--partscan</b> argument, which will automatically create files in the / dev directory corresponding to the image sections.  That is / dev / loop0p1, / ‚Äã‚Äãdev / loop0p2 and so on up to the horizon.  And now these files can be given to the mount command. <br><br>  <b>losetup --partscan / dev / loop0 drive.img</b> <br>  <b>mount / dev / loop0p2 / mnt / win_c</b> <br><br>  Those who are not so lucky with the distribution can use the <b>kpartx</b> program, which will do the same, but put the files corresponding to the sections not in the / dev directory, but in the / dev / mapper directory, from where they can be mounted and viewed. <br><br>  <b>kpartx -a / dev / loop0 drive.img</b> <br>  <b>mount / dev / mapper / loop0p2 / mnt / win_c</b> <br><br>  But we can go even deeper than that ... <br><br><h3>  Automatic creation of partition files when running the losetup command <br></h3><br>  In fact, the kernel (and specifically the <b>loop</b> module) has been able to look for a partition table in the image file for a long time and create the corresponding files, but this feature is disabled by default. <br><br>  It is <b>turned on</b> if the parameter of the loop <b>max_part</b> module is not zero.  This parameter can only be set when the module is loaded, so if the system is already running, the module must be unloaded from memory and loaded again with the parameter already set.  To do this, run the following two commands. <br><br>  <b>modprobe -r loop</b> <br>  <b>modprobe loop max_part = 63</b> <br><br>  However, in some distributions (for example, in Ubunt), the loop module is compiled tightly into the kernel and therefore, to set the parameter, <b>loop.max_part = 63</b> will have to be <b>entered</b> into the kernel command line and the system will be rebooted. <br><br><h2>  Deploy image to physical media </h2><br>  And now about how to actually roll the image to another disk.  As before, we must be guided by the fact that the disks and partitions are presented in the form of files.  And if for removing the image it was necessary to create a copy of the device file or partition, then in order to roll up this image back, you must perform a copy operation in the opposite direction.  That is, instead of <b>cp / dev / sda2 win_c.img</b> write <b>cp win_c.img / dev / sda2</b> .  Well, it is better to remember the advice outlined in the guide to removing the image.  Namely, use ddrescue and not use dd. <br><br>  <b>ddrescue --force win_c.img / dev / sda2 win_c_restore.img.log</b> <br>  Of course, it should be remembered that the partition in which we restore the image (in this case / dev / sda2) must be no less than the file with the image.  If the partition is larger than this file, then there will be no problems during recovery, but the partition will have unpartitioned space.  And you have to either come to terms with this fact, or increase the size of the file system to the size of a partition with some specialized software (it is usually much easier and faster to increase the size than to reduce it). <br><br><h2>  Compressing a partition image (logical drive) </h2><br>  A particularly nice feature of Acronis is the ability not to write disk or partition chunks that do not contain files to an image file.  This allows you to shrink the image to the actual amount of data in a partition or on disk. <br><br>  The approach outlined earlier has fundamental limitations that prevent such a feature from being implemented - sector-based copying programs do not know anything about the structure of file systems, and even more, they don‚Äôt know what it is - a file system. <br><br>  However, there is a way out.  True, to use it, the file system on which the image will be stored must support such a specific thing as <b>sparse files</b> . <br><br><h3>  Sparse files </h3><br>  A sparse file is a file in which pieces containing zeroes are not written to disk.  That is, if half of the file is filled with data, and the other half with zeros, only half of this file will be written to the disk and additional information about areas of the file filled with zeros will be recorded.  If the area with zeros is continuous and starts in the middle, then the actual file on the disk will replace half of its theoretical volume. <br><br><h3>  Preparing a partition or device for compression </h3><br>  In order to take advantage of this opportunity in order to compress the image, you need to write zeros in the free space before removing.  It is easy to do this - just mount the file system to a directory and create a binary zero file in this directory whose size will be equal to the size of free space on the partition. <br><br>  But, fortunately, it is not necessary to find out the amount of free space and transfer it to the program that creates the file, and you will not need to look for the program that creates the file with zeros.  There is a dimensionless zero file in the / dev directory, which, as the name implies, is an inexhaustible source of binary zeros.  It remains only to copy it to the right place. <br><br>  Since the file is dimensionless, copying will continue until the copy fills all the space available to it, that is, all the free space in the section that we actually needed. <br><br>  About how to copy files using standard operating system tools, it‚Äôs written here so many times that the manual could well be called ‚ÄúThe Art of Copying Files in the GNU Environment‚Äù, but since the truth does not get stuck from repetition, I‚Äôll probably write again. <br><br>  To create a file with binary zeros, you can run the command <b>cp / dev / zero zerofile</b> or <b>cat / dev / zero&gt; zerofile</b> . <br><br><h3>  Creating a sparse device image file or partition </h3><br>  Most utilities for working with files are aware of the existence of sparse files and are able to create them.  The ddrescue mentioned earlier, in order for the image to turn out to be a sparse file, you need to pass the key <b>--sparse</b> .  Now the resulting file will take up as much space as it needs, and no more. <br><br><h3>  How to be in the case of compression of the image of a damaged disk </h3><br>  As you know, it‚Äôs scary to take many disks and take it into your hands, what can be the conversation about recording multi-gigabyte files there.  If you just got such a disc in your hands, you must first remove the image, and then make a sparse file out of it.  To do this, you need to mount the resulting image, then fill the free space with zeros and make a copy from the image, which will already be a full-fledged sparse file.  The original image can then be deleted. <br><br>  Copying a file can be done perfectly by cp, which can make sparse files as good as ddrescue.  <b>cp --sparse win_c.img win_c_sparse.img</b> <br><br>  Of course, for these operations a lot of free space will be required, but it is still much better than nothing at all. <br><br><h2>  Conclusion </h2><br>  And now in a concise form about what can be learned from this guide. <br><br><ol><li>  In Linux, each drive and each partition on the drive corresponds to a file. <br></li><li>  Since an image is a byte copy of the contents of a disk or partition, to create it, it is enough to make a copy of the corresponding file with any program that can make copies. <br></li><li>  The GNU ddrescue program is best suited for making a copy of the file corresponding to the partition or drive. <br></li><li>  To restore the image just copy it back. <br></li><li>  To view the contents of an image, it is enough to mount it in a directory of your choice, just as the system mounts devices at boot. <br></li><li>  Partition images and drive images are completely mounted differently and not quite in the same way as real drives and partitions are mounted. <br></li><li>  To obtain a compressed image of a partition, you must specifically copy the previously prepared partition into a file system that supports sparse files. <br></li></ol><br>  And the fact that this guide can not be gleaned. <br><br><ol><li>  There is a specialized software package called <b>Clonezilla</b> , as well as a distribution based on it, designed to back up and restore partitions on a hard disk. </li><li>  There are <b>ntfsclone</b> and <b>partclone utilities</b> that have knowledge of the structure of file systems and use this knowledge, for example, in order not to write empty space to backup. </li></ol><br>  <b>PS</b> Just in case I give a link to <a href="http://slax.org/">Slax</a> - a distribution kit, which I put on bootable flash drives.  He can copy himself into RAM and there is a ddrescue by default. <br></div><p>Source: <a href="https://habr.com/ru/post/233961/">https://habr.com/ru/post/233961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233947/index.html">Behaviosec: mobile app user identification by behavioral parameters</a></li>
<li><a href="../233951/index.html">3D cartoon from scratch</a></li>
<li><a href="../233953/index.html">Published records of the conference reports DevCon 2014</a></li>
<li><a href="../233955/index.html">How Yandex.Metrika sells ‚Äúgeneralized statistical information‚Äù of your site to your competitors</a></li>
<li><a href="../233957/index.html">An authorization module for a site using the Wargaming.net Public API</a></li>
<li><a href="../233963/index.html">Experience replacing Microsoft Outlook with Mozilla Thunderbird with Exchange Server</a></li>
<li><a href="../233967/index.html">LEO fitness system will become a personal trainer for those who do not have it</a></li>
<li><a href="../233969/index.html">Market analysts and project managers</a></li>
<li><a href="../233971/index.html">OpenVPN Installation and Setup Guide</a></li>
<li><a href="../233973/index.html">Use liquibase plugin for maven</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>