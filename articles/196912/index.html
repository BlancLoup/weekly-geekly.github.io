<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SlideStackView or Extending ViewGroup on Android (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I talked about my experience in developing SlideStackView in Mail.Ru mobile mail for Android. Then I promised that in the near future I will...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SlideStackView or Extending ViewGroup on Android (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/235/a60/996/235a60996cd979612bd67a9022537008.jpeg"><br><br>  Recently, <a href="http://habrahabr.ru/company/mailru/blog/182750/">I talked</a> about my experience in developing SlideStackView in Mail.Ru mobile mail for Android.  Then I promised that in the near future I will prepare the second part, in which I will talk about how to implement the most interesting part from the point of view of programming visual components.  Naturally, we will talk about what adds interactivity to the application - about animation.  All have long been accustomed to the fact that the mobile application must be responsive to user actions.  Obviously, the main way to interact with your application is to use the Touch screen. <br><a name="habracut"></a><br>  As we write the navigation controller, SlideStackView, then interactivity will be added to us by animated transitions between the main parts of the application.  In the mobile mail Mail.Ru there are three fragments: a list of accounts added to the application, a list of folders inside the selected mailbox and a list of letters that shows the contents of one folder. <br><br>  As I wrote in the first part, everything starts with learning how to locate and draw static slides.  The next step is to learn how to animate these slides. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I am sure that most of the developers, within the framework of the tasks being solved, have come across this and have some idea of ‚Äã‚Äãhow MotionEvent is processed in the Android Framework, but, nevertheless, I will start from the very beginning. <br><br>  So, the base View class is designed in such a way that it implies the potential handling of MotionEvents.  And in response to the corresponding action, the widget gets this very MotionEvent, which stores all the necessary information about how the user interacts with the TouchScreen. <br><br>  In our example, we are interested only in those events that will help to make the slide scrolling inside the slide stack. <br><br>  But before starting to write code, I always prefer to first collect all the available data, requirements and wishes in a heap in order to build for myself the most accurate model of what is happening, so that not a single detail will be left aside.  Naturally, it is impossible to immediately think over all the little things, and as the code is being written, you will have to abandon any ideas in favor of simplicity of the architecture, or in order to shorten the development time.  But, as I noted long ago, this is done with minimal losses if you sit down before drawing up, draw approximate flowcharts, interaction tables, break one cumbersome class into interacting components, whose behavior will be easily changed without affecting the independent parts of the system.  As you write various widgets, this understanding will come by itself at the level of intuition, and you will not clutch your head at the thought that in order to make the necessary changes, you now have to shovel all the code written in the last month.  Here rather simple and familiar to every programmer rules come to the fore: <br><br><ul><li>  Do not overload the class with extra functionality </li><li>  Always refactor your code when it seems to you that this part can come in handy later </li><li>  Do not optimize ahead of time </li><li>  Each field or method should not cause confusion when looking at them in isolation from the component itself. </li></ul><br><br>  With the last point, it will probably be the most difficult, because often in an impulse to achieve the desired result, all programmers compromise and often tend to do "just to work" now with the note "I will change later when there is time."  I do not say that this is absolutely wrong, I just want to warn you that, most likely, you will remember this later, when it becomes too late to change something or even worse, it is impossible. <br><br>  And the last point, which I consider necessary to note, is a slightly contradictory appeal.  Do all of the above without fanaticism.  That is, if you are faced with the task of writing a widget that should be used as a controller for navigating between the screens of your application, and the main task in the requirements is the convenience of managing via the Touch Screen, then you do not need to pay attention to moments such as, for example, touch control.  Of course, to navigate by simply turning or moving the phone is very cool, and even convenient, but still it is not the main task, and it can be postponed, so to speak "until better times." <br><br>  So back to our sheep. <br><br>  At first glance, everything is quite simple, but it is only at first glance.  If you had to handle scrolling before, then you probably know that among all kinds of MotionEvents, it is not so easy to determine the true intention of the user.  Did he decide to just move the slide to the side, or does he click on the item that is inside the list, etc.  All this logic can be implemented as if separately from the slidestack, so it will be convenient to isolate the entire scrolling processing algorithm into a separate SlideStackScroller component. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SlideScroller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scroller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnTouchListener</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ScrollingListener mListener; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GestureDetector mGestureDetector; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SlideScroller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, ScrollingListener listener, OnGestureListener gestureListener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mListener = listener; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mGestureDetector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GestureDetector(context, gestureListener); mGestureDetector.setIsLongpressEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre> <br><br>  Scrolling is not an innovative task, so, of course, classes are available for us that can help us.  Namely Scroller and GestureDetector.  The first one provides a convenient interface for scrolling calculation, and the second helps to define standard types of gestures, in this case we are most interested in the fling gesture.  In addition to the main advantage of using a ready-made solution (lazy programmers will understand me) - you don‚Äôt have to write this logic yourself - when using solutions provided by the platform, it is easier to achieve the so-called consistent user experience, or behavior that will be familiar to the user and will not stand out among other components platforms.  And this is especially important to consider if you are developing an interactive part of the system. <br><br>  The scroller must provide the slide stack with an interface through which it will report on important, from the point of view of the slide stack, events, namely: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollingListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onJustify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  About when the scrolling began, when the slide shifted by a certain number of pixels, that the scrolling is over and we need to trim the position of the slide, and that the scrolling is fully completed. <br><br>  From the point of view of the slidestack, nothing could be simpler, we simply delegate the processing of all touch events to the scroller, and he will figure out what really happened and call the necessary callback. <br><br>  As you probably noticed, all delegation occurs through the onTouch (View v, MotionEvent event) method of the android.view.View.OnTouchListener interface. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v, MotionEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (event.getAction()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MotionEvent.ACTION_DOWN:{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointerId = MotionEventCompat.findPointerIndex(event, mActivePointerId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointerId == INVALID_POINTER_ID){ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } mLastTouchX = MotionEventCompat.getX(event, pointerId); mJustifying = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; forceFinished(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); clearMessages(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MotionEvent.ACTION_MOVE:{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointerId = MotionEventCompat.findPointerIndex(event, mActivePointerId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointerId == INVALID_POINTER_ID){ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// perform scrolling float x = MotionEventCompat.getX(event, pointerId); int distanceX = (int)(x - mLastTouchX); if (distanceX != 0) { mTouchScrolling = true; startScrolling(); mListener.onScroll(-distanceX); mLastTouchX = x; } break; } case MotionEvent.ACTION_UP: mTouchScrolling = false; mActivePointerId = INVALID_POINTER_ID; break; } if ((!mGestureDetector.onTouchEvent(event) || ((SlideStackView)v).isOverScrolled()) &amp;&amp; (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)){ justify(); } return true; }</span></span></code> </pre><br><br>  We go in order: <br><br><ul><li>  ACTION_DOWN tells us that the user has touched the screen in a certain area with certain coordinates.  In this case, we must perform a completely standard procedure for such cases, namely, to prepare the ground and be ready for subsequent movements of the user on the screen, in response to which we will scroll our slide stack.  In this case, this procedure includes memorizing the initial position and resetting all flags and the current scrolling, if it was performed. </li><li>  ACTION_MOVE speaks about the movement itself, that is, the user touch has moved to the new coordinates.  It is not difficult to guess that now we need to calculate the difference of coordinates and inform the slide center that the user has made a scroll.  Allocating a component such as SlideStackScroller avoided excessive coherence between the processing of Motion Events and the internal logic of the slidestack.  In other words, here we do not care about the state in which the slide stack is now located, whether it can scroll in some direction or not.  We simply inform him of what the user has done, and whether the slidestack decides whether to react to it and how to react. </li><li>  ACTION_UP.  This often completes the user's interaction with the screen.  BUT: it does not mean that we can relax.  Perhaps this is where the simplest part of the work ends.  I mean the gesture that everyone is used to, and is usually called fling.  A literal translation (‚Äúthrow‚Äù) does not allow us to understand what this means.  In this context, a gesture is meant in which the user, moving his finger across the screen, as if accelerates an element, and, having stopped touching, expects the element to move as it would happen to a physical body in real life.  That is, by inertia.  For example, how would the phone slide if we pushed it across the table to another person. </li><li>  Finally, we need to decide whether the gesture has ended so that we can align the position of the slides, or the user's perfect gesture can be interpreted as fling, and then we should take the appropriate action and wait for it to complete before proceeding with the alignment of the slides. </li></ul><br><br>  At once I want to say that fling, which at first glance seems to be an additional and minor case, is the most frequent completion of the slide scrolling.  The thing is that now most users are accustomed to horizontal svaypu both in the platform itself and in many applications, therefore it performs this gesture intuitively and quickly enough. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!mGestureDetector.onTouchEvent(event) || ((SlideStackView)v).isOverScrolled()) &amp;&amp; (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)){ justify(); }</code> </pre><br><br>  Look at this condition again.  Here it is very important not only to check how the GestureDetector reacted to our gesture, but rather that all gestures pass through it.  In this case, we are sure that we have not missed a single movement of the user and will be able to determine the gesture we need exactly when it happens.  If in this condition we rearrange the order of testing, then our slide stack will stop responding to the svayp, because most MotionEvents simply do not get to Gesture Detector. <br><br>  As a result, if the fling is completed, everything will end for us (or begin, for whom it is more convenient) by calling the onFling method (MotionEvent e1, MotionEvent e2, float velocityX, float velocityY): <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e1, MotionEvent e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocityX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocityY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScroller.isTouchScrolling()){ LOG.w(<span class="hljs-string"><span class="hljs-string">"mTouchScrolling in fling"</span></span>); } SlideInfo slide = getSlideInfo(mSelected); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = getAdjustedTargetX(velocityX) - slide.mOffset; mScroller.fling(-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)getVelocity(dx)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br><br>  In this method, the final coordinate is considered, into which we have to get after the fling is completed, then an amendment is made to the current position of the slide, the initial speed for movement is calculated, and the fling itself begins. <br><br>  Why consider speed, if it is already given to us?  The fact is that the speed can be different, but in this case it is important for us that any fling is over at a specific point, and this point is calculated in the getAdjustedTargetX () method: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Defines target x coordinate of the slide. * It depends on fling direction * &lt;p&gt; * In case right fling it is calculated like this * &lt;pre&gt; * * getLeftEdge() getRightEdge() targetX * _|___________________________|______________________|__ * | | |rightOverScrollInFling| | * | _ _ _ _ _ _ _ _ _ _ _ _ _ _ &lt;--------------------&gt; | * | | | | | * | | * | | | | | * | mSelectedSlide | * | | | | | * | | * | |_ _ _ _ _ _ _ _ _ _ _ _ _ _| | | * | SlideStackView | * |_|___________________________|______________________|__| * &lt;/pre&gt; * &lt;p&gt; * In case left fling it is calculated like this * &lt;pre&gt; * 0 * ________________________|_____________________________ * | |leftOverScrollInFling | | * | &lt;--------------------&gt; _ _ _ _ _ _ _ _ _ _ _ _ _ _ | * | | | | | * | | * | | | | | * | mSelectedSlide | * | | | | | * | | * | | |_ _ _ _ _ _ _ _ _ _ _ _ _ _| | * | SlideStackView | * |_|______________________|_____________________________| * &lt;/pre&gt; * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> velocityX velocity that defines direction of the fling * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> delta x in pixels that slide needs to scolled by * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SlideStackView#getLeftEdge(int) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SlideStackView#getRightEdge(int) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SlideStackView#mRightOverScrollInFling * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SlideStackView#mLeftOverScrollInFling */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAdjustedTargetX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocityX)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (velocityX &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ result = getRightEdge(mSelected) - getLeftEdge(mSelected) + mRightOverScrollInFling; <span class="hljs-comment"><span class="hljs-comment">// LOG.v("onFling " + targetX); } else { // relative to layout position of the slide result = 0 - mLeftOverScrollInFling; } return result; }</span></span></code> </pre><br><br>  As can be seen from the body of the method, the calculation of this point depends on the direction of the fling, but the final position remains unchanged.  In the case of flinging to the right, this is the extreme right position of the slide + ‚Äúskid‚Äù by the number of pixels by which the slide will fly further than the extreme right position.  If fling to the left, then this is the leftmost position - a skid.  And this is at any initial speed of movement.  Such a restriction is made artificially, since the analysis of user experience has shown that specifically for this controller, this behavior looks more natural. <br><br>  On the Android platform, the scroller deals with the calculation of the kinematics of an element during fling.  As a model, developers from Google took the well-accelerated motion formula known from school: S = V <sub>0</sub> * t- (g * t <sup>2</sup> ) / 2.  We know the initial speed of movement, we can measure time from the beginning of the movement, all that remains is to choose the acceleration with which the slide will stop. <br><br>  The developers did not guess and took the acceleration of gravity as a basis: <br><br><pre> <code class="java hljs"> mDefaultDeceleration = SensorManager.GRAVITY_EARTH <span class="hljs-comment"><span class="hljs-comment">// g (m/s^2) * 39.37f // inch/meter * ppi // pixels per inch * ViewConfiguration.getScrollFriction() * 10.0f;</span></span></code> </pre><br><br>  If we ignore the realization we stopped at, we can single out 4 possible scenarios that will occur during fling at different initial speeds. <br><br>  Take the position of the open and closed slide as follows: <br><br><img src="https://habrastorage.org/storage3/4c0/49b/eb6/4c049beb62ee51dcf288889494c9d6b2.png"><br><br><img src="https://habrastorage.org/storage3/9fe/004/150/9fe004150e233b6bb9af3b801e66afc3.png"><br><br>  Suppose we fling from the initial position.  The 4 possible options are obtained as a result of enumerating the distance traveled relative to the leftmost (1 screenshot) and rightmost (2 screenshot) positions of the slide.  Assume that the distance between these positions is S <sub>n</sub> <br><br><img src="https://habrastorage.org/storage3/e32/486/ffb/e32486ffb64dbf2cd20764cba2110f64.png"><br><br>  S &lt;S <sub>n</sub> / 2 <br><br>  This situation suggests that the user performed the fling, giving the element an initial speed that is not enough for the element to cover half the distance to the end position.  In this case, to emulate the natural behavior, you can fling with the speed that the user gave the element, and, waiting for the element to stop, return it to its original, i.e.  extreme left position. <br><br><img src="https://habrastorage.org/storage3/28f/411/8d8/28f4118d8bdccac33d72add434fa0921.png"><br><br>  S <sub>n</sub> / 2 &lt;S &lt;S <sub>n</sub> <br><br>  Here, the initial velocity of the element was sufficient to cover half the distance to the target, but not sufficient to reach the end point.  Therefore, by defining such a scenario, you can give the element a little more speed ‚Äî such that it is enough to hit the destination point.  To do this, it is worth remembering the physics of uniformly accelerated motion, and, knowing the acceleration and the final distance, calculate the initial speed with which you need to fling. <br><br>  S <sub>n</sub> &lt;S &lt;S <sub>n</sub> + overscroll <br><br>  This result suggests that the user has given a sufficiently high speed to the element in which he ends the movement beyond the rightmost point, but does not reach the maximum allowable drift.  In this case, everything will happen exactly as we want, namely: the user will see that the element has drifted abroad, as a result, after which it will align and return to the extreme right position. <br><br>  S&gt; S <sub>n</sub> + overscroll <br><br>  This situation is a bit worse.  The element's initial speed is so high that it will move on to the extreme right position, and its drift will be more than the maximum allowed.  Theoretically, the difference can be much higher, which creates, albeit a natural, but ugly visual effect.  The positive point is that with a very sharp movement, it is more difficult for the user to notice how we adjust the speed - the main thing is that everything happens quickly and the element does not fly far beyond the borders of the screen. <br><br>  If we analyze the fling in the other direction, we will see all the same cases, except that the reference distances will be calculated slightly differently. <br><br>  So, how to handle fling we figured out.  Now it is necessary to decide how to create an animation during this movement.  To do this, consider the following method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocity)</span></span></span></span>{ mLastX = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxX = <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minX = -maxX; fling(mLastX, <span class="hljs-number"><span class="hljs-number">0</span></span>, velocity, <span class="hljs-number"><span class="hljs-number">0</span></span>, minX, maxX, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); setNextMessage(MSG_SCROLL); }</code> </pre><br><br>  This method is necessary only for horizontal fling and does not take into account the initial and final positions.  Therefore, we simply remember the initial position, set the maximum possible boundaries, start the fling itself from the class of the heir and send us a message that we need to process the scroll. <br><br>  This method is extremely simple, in it we clear all messages previously placed there and send to the handler only one message required at the moment: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Handler mAnimationHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnimationHandler(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setNextMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message)</span></span></span><span class="hljs-function"> </span></span>{ clearMessages(); mAnimationHandler.sendEmptyMessage(message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearMessages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mAnimationHandler.removeMessages(MSG_SCROLL); mAnimationHandler.removeMessages(MSG_JUSTIFY); }</code> </pre><br><br>  mAnimationHandler is the usual auxiliary Inner class, which receives a message that we are doing some kind of scrolling, which is done after the user's contact with the TouchScreen: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message msg)</span></span></span><span class="hljs-function"> </span></span>{ computeScrollOffset(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currX = getCurrX(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = mLastX - currX; mLastX = currX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta != <span class="hljs-number"><span class="hljs-number">0</span></span>) { mListener.onScroll(-delta); } ‚Ä¶ } }</code> </pre><br><br>  Everything is very simple: first we ask the scroller to calculate the current position of the animation at the moment when we received this message.  Then we calculate the difference between the new position and the last known to us.  At the end of the report slidestek that the scroll is completed.  Just like we did from the body of the onTouchEvent () method. <br><br>  Now it's up to you - in response to these messages, you need to change the position of the slides on the screen.  The starting point will be the implementation of the onScroll () method: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// LOG.d("onScroll " + distance); doScroll(distance); }</span></span></code> </pre><br><br>  At once I want to reassure: inside the method, there will not be a single line followed by a call to the doScrollInternal () method, within which the method call is actuallyDoScroll () and so on.         ,          ,  , ,   api,     .     . <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Performs actual scrolling. Moves the views according * to the current selected slide number and distance * passed to the method. After the scrolling has been * performed method {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #onScrollPerformed()} will be * called where you can apply some visual effects. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> distance scroll distance */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span><span class="hljs-function"> </span></span>{ adjustScrollDistance(distance); <span class="hljs-comment"><span class="hljs-comment">// LOG.d("scroll delta " + mScrollDelta); View selected = getChild(getSelectedViewIndex()); scrollChildBy(selected, mScrollDelta); notifyScrollPerformed(); onScrollPerformed(); fillViewsIn(); if (!mDirty.isEmpty()){ invalidate(mDirty.left, mDirty.top, mDirty.right, mDirty.bottom); mDirty.setEmpty(); } }</span></span></code> </pre><br><br>        adjustScrollDistance().  ,                 ,          . <br>     ,      ,      .       .     ,       . <br>    ,      ,    ,       ,     ,    .   ,   ,      .      ‚Äî     ,     . <br><br>      : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Moves the specified child by some amount of pixels * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> child child to move * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> scrollDelta scrolling delta */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollChildBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollDelta)</span></span></span><span class="hljs-function"> </span></span>{ SlideInfo info = getSlideInfo(child); <span class="hljs-comment"><span class="hljs-comment">// LOG.d("apply scroll " + info.mPosition + " delta " + scrollDelta); Rect childDirty = getChildRectWithShadow(child); info.mOffset -= scrollDelta; child.offsetLeftAndRight(-scrollDelta); childDirty.union(getChildRectWithShadow(child)); mDirty.union(childDirty); // LOG.d("apply scroll " + info.mPosition + " newoff " + info.mOffset); }</span></span></code> </pre><br><br>        , mDirty      ,       ,    .       ,        ,      .     ,    . <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Notifies scroll listeners about selected slide has been scrolled. * Do nothing if there is no scroll listener was set earlier. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyScrollPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScrollListener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> p = getSlidePositionInBounds(mSelected); <span class="hljs-comment"><span class="hljs-comment">// LOG.v("notifyScrollPerformed " + mSelected + ", " + p); mScrollListener.onSlideScrolled(mSelected, p); } } /** * Calculates position for the specified slide relative to it's * scrollable bounds. * &lt;p&gt; * &lt;b&gt;Note:&lt;/b&gt; Slide position coulld be &lt;code&gt;&lt; 0.0f&lt;/code&gt; and * &lt;code&gt; &gt; 1.0f * @param slidePosition * @return */ private float getSlidePositionInBounds(int slidePosition) { SlideInfo info = getSlideInfo(slidePosition); int offset = info.mOffset; int scrollBounds = getWidth() - getRightEdgeDelta(info.mPosition) - getLeftEdge(info.mPosition); float p = ((float) offset) / scrollBounds; return p; }</span></span></code> </pre><br><br> ,    - ,    ,     ,  -      ,    .             - ,          .       ,    .   ,  : <br> ,     ,      ,   ,        ,      ,     ,    . <br> ,     ,        .          [0, 1],      ¬´¬ª,      . <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Listener interface that informs about slide scrolling * related events such as current selected slide has changed, * or current selected slide scroll position has changed. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> k.kharkov */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnSlideScrollListener</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Called when the current selected position for slide * has changed. Usually it happen after scrolling finished. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> selectedSlide */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSlideChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> selectedSlide)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Informs about changing scroll position of the slide. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position current selected slide position * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> p position of the slide inside it's scroll * bounds. 0.0f at left edge, 1.0f at right edge. If * &lt;code&gt;p &lt; 0.0f || p &gt; 1.0f&lt;/code&gt; the slide is over * scrolled to left or to the right. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSlideScrolled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span></span>; }</code> </pre><br><br>  , ,  ,          .     ,   ,       : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Retrieves slide's left edge coordinate in opened state * relative to parent. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position slide number in adapter's data set * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> coordinate of the slide's left in opened state */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeftEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mAdapter == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> :mAdapter.getSlideOffset(position); }</code> </pre><br><br>   .     ,        .       ,         , ,   ,         . <br><br>   @Mail.Ru      ,       ,      .       - ,     ,       - : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Retrieves coordinate of the slide's left edge in closed state * relative to parent. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position slide number in adapter's data set * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> coordinate of slide's left in closed state. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRightEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightEdge = getRight() - getRightEdgeDelta(position); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rightEdge; } <span class="hljs-comment"><span class="hljs-comment">/** * Just calculates delta between child's right edge and * parent's right edge * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> position position of the child (in adapter's * data set indexes) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> delta in pixels */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRightEdgeDelta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = mSlideInvisibleOffsetFirst + mSlideInvisibleOffset * position; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delta; }</code> </pre><br><br>  ,  ,        .  ,      .       .    ,        - ,   ,        . <br><br>   2 : onScrollPerformed(), adjustScrollDistance(). <br><br>        ,   -          .      ,    ,      ,        -     .             ,     -,    .     ,      ,   ,        . ,        .       ,       -  . <br><br>       bouncing effect. , -,    . ,  ,    Android-    ,   iOS.   ,           .         look&amp;feel.  ,     , ,   iOS    ,       .   ,   .  ,     ,      ,   <br>   ,       , -   ,    . <br><br>    ,      :           ,     .             -.      adjustScrollDistance(): <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Processes scroll distance according to the current scroll * state of the slide stack view. Takes into account * over scrolling, justifying. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> distance desired distance to scroll. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adjustScrollDistance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span><span class="hljs-function"> </span></span>{ mScrollDelta = distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScroller.isJustifying()){ processNonOverScroll(distance); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScrollDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; isRightOverScrolled()){ processOverScroll(distance); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScrollDelta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; isLeftOverScrolled()){ processOverScroll(distance); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { processNonOverScroll(distance); } }</code> </pre><br><br>    SlideStackView,  , ,   ,                 ,    ,   .    ,       ,       . <br><br>    .    ,              : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> &lt;code&gt;true&lt;/code&gt; if slide stack over scrolled * to the right. &lt;code&gt;false&lt;/code&gt; otherwise */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isRightOverScrolled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * info.mOffset - it is * the latest position of the slide's left side * so if it is over scrolled - return true * _________________ * | _____________|_ * | |lastSlide | | * |&lt;-&gt;| | | * | | | | * | |_____________|_| * |_________________| * SlideStack */</span></span> SlideInfo info = getSlideInfo(getSelectedViewIndex()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mSelected == mFirst + getChildCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.mOffset &gt; getLeftEdge(info.mPosition)){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/** * getRightEdge() - it is left bound of the slide * when it is hidden * ___________|______ * | | __|____________ * | | | |anySlide | * | |&lt;-&gt;| | | * | | | | | * | | |__|____________| * |___________|______| * SlideStack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = info.mOffset + getLeftEdge(mSelected); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &gt; getRightEdge(mSelected)){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br><br>  ,      , : <br><br><ul><li>   ,        .          <br>    . </li><li>    ,         .       ‚Äî    . </li></ul><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> &lt;code&gt;true&lt;/code&gt; if the slide stack view is * over scrolled to the left. &lt;code&gt;false&lt;/code&gt; otherwise. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeftOverScrolled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ View selected = getChild(getSelectedViewIndex()); SlideInfo info = getSlideInfo(selected); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selected.getRight() + info.mOffset &lt; getRightEdge(mSelected - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>      ,           .  ,       ,        ,           () .     ,      ,          (. getRightEdge()). <br><br>      ,   ,      : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Changes actual scroll delta in case over scroll. * Depends on whether we in fling mode or not. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> distance */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processOverScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// LOG.d("process overscroll " + distance); //process over scroll while in fling mode; if (!mScroller.isTouchScrolling()){ mScroller.setDecelerationFactor(mDecelerationFactor); } else{ // or just slow down while touch scrolling mOverScrollOffset += distance; int nOffsetAbsolute = (int) (mOverScrollOffset / mOverScrollFactor); int oldOffsetAbsolute = mLastOverScrollOffset; int scrollDelta = nOffsetAbsolute - oldOffsetAbsolute; mLastOverScrollOffset += scrollDelta; mScrollDelta = scrollDelta; } }</span></span></code> </pre><br><br>     ,    touchScrolling,  ,           - .          ,  :      - ,           .    ,      .     ,  mOverscrollFactor    .          .   ,        ,     . ,   overscroll factor = 5,      ,      distance = 1.        .      . , ,     .      ,   .   ,        5 , ,   ,      1 .  ,       ,     .  For this we <br>    mOverScrollOffset ‚Äî      ,      .  mLastOverScrollOffset ‚Äî    ,        .       ,        ,   . <br><br>      :   ,  ,     mOverScrollOffset  mLastOverScrollOffset.      ,          ( ),        .     ,      .         : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * We need assume that actual scroll delta is distance parameter, * we need adjust {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #mLastOverScroll} if we will not go out * from over scroll mode and over scroll again. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> distance raw distance passed from the scroller. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processNonOverScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance)</span></span></span><span class="hljs-function"> </span></span>{ mScrollDelta = distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOverScrolled()){ mLastOverScrollOffset += distance; mOverScrollOffset = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (mLastOverScrollOffset * mOverScrollFactor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mLastOverScrollOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; mOverScrollOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br>   :     mOverScrollOffset  mLastOverScrollOffset   ,  ,         ,   ,     .          ‚Äî    . <br><br>    :      ,       . <br><br>      ,             .      ,    ( )    .        ,       ,       ,      ,   Scroller.  ,       : <br><br> S=V <sub>0</sub> *t-(g*t <sup>2</sup> )/2 ( ) <br><br>   ,          ,     .     3 : <br><br> S=V <sub>0</sub> *t-(g*t <sup>2</sup> )/2 <br><br>        ,          <br><br> S2=V <sub>k</sub> *t2- ((g*p)*„Äñt2„Äó <sup>2</sup> )/2 <br><br>         ,     ,      p . <br><br> S3=V <sub>k2</sub> *t3- ((g*p*p)*„Äñt3„Äó <sup>2</sup> )/2 <br><br>    :        ,      . <br>      ,     . <br><br> mScroller.setDecelerationFactor(mDecelerationFactor); <br><br>       ,   .    ,   ,    : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Adjusts the current deceleration to slow down more or less. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> factor if &gt; 1.0 the scroller will slow down more. * if factor &lt; 1.0 the scroller will slow down less. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setDecelerationFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor)</span></span></span></span>{ mVelocity = mVelocity - mDeceleration * mPassed / <span class="hljs-number"><span class="hljs-number">1000.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity = mVelocity; mDeceleration *= factor; mDuration = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">1000.0f</span></span> * mVelocity / mDeceleration); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startX = mStartX = mCurrX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startY = mStartY = mCurrY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalDistance = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((velocity * velocity) / (<span class="hljs-number"><span class="hljs-number">2.0f</span></span> * mDeceleration)); mFinalX = startX + Math.round(totalDistance * mCoeffX); <span class="hljs-comment"><span class="hljs-comment">// Pin to mMinX &lt;= mFinalX &lt;= mMaxX mFinalX = Math.min(mFinalX, mMaxX); mFinalX = Math.max(mFinalX, mMinX); mFinalY = startY + Math.round(totalDistance * mCoeffY); // Pin to mMinY &lt;= mFinalY &lt;= mMaxY mFinalY = Math.min(mFinalY, mMaxY); mFinalY = Math.max(mFinalY, mMinY); mStartTime += mPassed; }</span></span></code> </pre><br><br>       ,     ,     ,  ,    <a href="https://habrahabr.ru/users/hide/" class="user_link">hide</a> : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@hide</span></span></span><span class="hljs-comment"> * Returns the current velocity. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> The original velocity less the deceleration. Result may be * negative. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrVelocity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mVelocity - mDeceleration * timePassed() / <span class="hljs-number"><span class="hljs-number">2000.0f</span></span>; }</code> </pre><br><br>    ,       v(t)=v <sub>0</sub> +at        (1000 ‚Äî    ).   -  ,   <a href="http://stackoverflow.com/questions/13024902/android-scroller-current-velocity-calculation"></a>   ,       . <br><br>  ,     event'  ,   .    ,    .    ,     ,    ,    . Android Framework     ,          .  ,     .    ,         ViewGroup.dispatchTouchEvent(). <br><br>        .      ,   ,       .       ,    ,          : <br><br><ul><li>    child,   touchEvent. </li><li>   child ,    event,      .    ,  event     ViewGroup. </li><li>    MotionEvent'a  ViewGroup    .     MotionEvent    ViewGroup,  child'. </li></ul><br><br> ,   ,        View    . <br><br> ,          ,    .            ,     .  ,   event' ,    :          . <br><br>  Let's go in order.     : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Determines whether the user tries to scroll the slide stack view * or just tries to scroll some scrollable content inside the slide. * &lt;p&gt; * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInterceptTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent ev)</span></span></span><span class="hljs-function"> </span></span>{</code> </pre><br><br> , ,      ,  \\    . <br>    ,   : <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> action = MotionEventCompat.getActionMasked(ev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP){ <span class="hljs-comment"><span class="hljs-comment">/* * That means we need to abort all scrolling and return to nearest * stable position in the slide stack. So justify position. */</span></span> mBeingDrag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; mUnableToDrag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; mScroller.justify(); <span class="hljs-comment"><span class="hljs-comment">// LOG.v("OnInterceptTouchEvent: action cancel | up"); return false; } /* * In case we have already determined whether we need this * touch event or not - just return immediately */ if (action != MotionEvent.ACTION_DOWN){ if (mBeingDrag){ // LOG.v("OnInterceptTouchEvent: already dragging"); return true; } if (mUnableToDrag){ // LOG.v("OnInterceptTouchEvent: already unable to drag"); return false; } }</span></span></code> </pre><br><br>       (,   MotionEvent),     event'         ,          . <br><br>     ,        ,               ,   event  . <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MotionEvent.ACTION_DOWN:{ <span class="hljs-comment"><span class="hljs-comment">/* * remember the start coordinates for the motion event * in order to determine drag event length */</span></span> mInitialX = ev.getX(); mInitialY = ev.getY(); mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* * pass down event to the scroller after we have decided to intercept, * not here. It helps to start calculation motion event in case we * decide to intercept it. */</span></span> mScroller.setActivePointer(mActivePointerId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScroller.isScrolling() || isHiddenSlideMove(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)){ <span class="hljs-comment"><span class="hljs-comment">/* * in case the user start the touch while we didn't * accomplish scrolling - intercept touch event. * */</span></span> mBeingDrag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; mUnableToDrag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* * Otherwise let's start the process of detecting * who the touch event belongs to. */</span></span> mBeingDrag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; mUnableToDrag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// LOG.v("OnInterceptTouchEvent: DOWN being drag " + mBeingDrag + // ", unable to drag " + mUnableToDrag); return mBeingDrag; }</span></span></code> </pre><br><br>    event   ,        .           .     ,      MotionEvent.ACTION_DOWN.     event'  ,    .       ,       ,   event' child'  .      ,   isHiddenSlideMove().  ,      event'  ¬´¬ª,    ,     ,    .      ,       . <br><br>   ,     : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Defines whether motion events has been started on the closed slide or not * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> extend * if &lt;code&gt;true&lt;/code&gt; it will take into account * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #mTouchExtension}. Otherwise this method will only take * into account {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #mInitialX} and {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #mInitialY} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> &lt;code&gt;true&lt;/code&gt; in case the motion event has been started to * the right of the last closed slide, &lt;code&gt;false&lt;/code&gt; otherwise. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHiddenSlideMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> extend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mInitialX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mInitialY; Rect rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> right = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = getLastHiddenSlideIndex(); i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !right; i--) { View view = getChild(i); Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(); view.getHitRect(rect); rightSide.union(rect); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightSide.contains(x, y) || (extend &amp;&amp; rightSide.contains(x + mTouchExtension, y))) { right = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; }</code> </pre><br><br>     ‚Äî   : <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MotionEvent.ACTION_MOVE:{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activePointerId = mActivePointerId; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activePointerId == INVALID_POINTER_ID) { <span class="hljs-comment"><span class="hljs-comment">// If we don't have a valid id, the touch down wasn't on content. break; } final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId); final float x = MotionEventCompat.getX(ev, pointerIndex); final float dx = x - mInitialX; final float xDiff = Math.abs(dx); final float y = MotionEventCompat.getY(ev, pointerIndex); final float dy = y - mInitialY; final float yDiff = Math.abs(dy); if (dx != 0 &amp;&amp; canScroll(this, false, (int) dx, (int) x, (int) y)) { // Nested view has scrollable area under this point. Let it be handled there. if(!isHiddenSlideMove(false)) { mUnableToDrag = true; return false; } } // if it seems to be horizontal scroll if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.5f &gt; yDiff){ // LOG.v("OnInterceptTouchEvent: MOVE start drag"); ev.setAction(MotionEvent.ACTION_DOWN); adjustSelectedSlide(); mScroller.onTouch(this, ev); mBeingDrag = true; } else if (yDiff &gt; mTouchSlop){ // LOG.v("OnInterceptTouchEvent: MOVE unable to drag"); mUnableToDrag = true; } break; }</span></span></code> </pre><br><br>  Let's figure it out.           . -,  ,  ,          , ,      (  ).   ,         ,       .  ,          <br>  .      ,       .             .  ,        ,  22,5 ,     . <br><br><img src="http://habrastorage.org/storage3/dd3/64b/aca/dd364baca8a69f0448e6ccb8d9c575d8.png"><br><br>      ,       ,  ‚Äî      .        . ,            . <br><br>           . ,    ,  ,        (     ),        ,     .      ,       Google (. ViewPager): <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; canScroll(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) dx, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) x, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) y)) { <span class="hljs-comment"><span class="hljs-comment">// Nested view has scrollable area under this point. Let it be handled there. if(!isHiddenSlideMove(false)) { mUnableToDrag = true; return false; } }</span></span></code> </pre><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Tests scrollability within child views of v given a delta of dx. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> v View to test for horizontal scrollability * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> checkV Whether the view v passed should itself be checked for scrollability (true), * or just its children (false). * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> dx Delta scrolled in pixels * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> x X coordinate of the active touch point * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> y Y coordinate of the active touch point * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> true if child views of v can be scrolled by delta of dx. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ViewGroup) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ViewGroup group = (ViewGroup) v; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scrollX = v.getScrollX(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scrollY = v.getScrollY(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = group.getChildCount(); <span class="hljs-comment"><span class="hljs-comment">// Count backwards - let topmost views consume scroll distance first. for (int i = count - 1; i &gt;= 0; i--) { final View child = group.getChildAt(i); if (x + scrollX &gt;= child.getLeft() &amp;&amp; x + scrollX &lt; child.getRight() &amp;&amp; y + scrollY &gt;= child.getTop() &amp;&amp; y + scrollY &lt; child.getBottom() &amp;&amp; canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) { return true; } } } return (checkV &amp;&amp; ViewCompat.canScrollHorizontally(v, -dx)); }</span></span></code> </pre><br><br>       View,     ¬´¬ª,    ,  ,     ViewCompat.canScrollHorizontally(). ,      ,            .      ViewCompat,        . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewCompat</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canScrollHorizontally</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direction)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> QuickActionView){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((QuickActionView)v).canScrollHorizontally(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> android.support.v4.view.ViewCompat.canScrollHorizontally(v, direction); } } } }</code> </pre> <br><br>  .   . <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent event)</span></span></span><span class="hljs-function"> </span></span>{ LOG.i(<span class="hljs-string"><span class="hljs-string">"onTouchEvent: "</span></span> + event); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; event.getEdgeFlags() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Don't handle edge touches immediately -- they may actually belong to one of our // descendants. return false; } if ((event.getAction() &amp; MotionEventCompat.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){ continueWithSecondPointer(event); return true; } // adjust selected slide in case we didn't it in #onInterceptTouchEvent() method // if we have no touchable child under the touch event for instance if (!mScroller.isScrolling() &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN){ adjustSelectedSlide(); } return mScroller.onTouch(this, event); }</span></span></code> </pre><br><br>    event'    ,      .   ,   ,   ,     View. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent ev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// LOG.v("dispatchTouchEvent: " + ev); if (getChildCount() == 0){ return false; } return super.dispatchTouchEvent(ev); }</span></span></code> </pre><br><br>    .    - ,        . <br><br>    ,          , ,       MotionEvent'. <br><br>    ‚Äî   .         dispatchTouchEvent(), onInterceptTouchEvent()  onTouchEvent(),     ,      event. ,  ,        .     developer.android.com    ,      event'. <br><br>    ,    . ,       ,        . <br><br>      :) </div><p>Source: <a href="https://habr.com/ru/post/196912/">https://habr.com/ru/post/196912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196894/index.html">Another way to spend money - thanks to the "beloved" mobile operator!</a></li>
<li><a href="../196896/index.html">Ask questions to the experts. How can developers get help from Intel?</a></li>
<li><a href="../196900/index.html">About flags 0x41414141 times</a></li>
<li><a href="../196904/index.html">RAD Studio XE5 World Tour in Lviv, Ufa, Kiev, Minsk</a></li>
<li><a href="../196910/index.html">Opera 17 release</a></li>
<li><a href="../196916/index.html">Agile application in a fixed phase contract</a></li>
<li><a href="../196920/index.html">God bless Dynamic SQL</a></li>
<li><a href="../196922/index.html">How to cheap print a book in Linux</a></li>
<li><a href="../196924/index.html">Overview of the new TI Launchpad (MSP-EXP430F5529LP or MSP430F5529 USB LaunchPad)</a></li>
<li><a href="../196926/index.html">Booting Linux without bootloader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>