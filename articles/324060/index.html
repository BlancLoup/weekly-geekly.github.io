<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is Resizable Concurrent Map</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the previous posts I told how to implement the world's ‚Äúsimplest lock-free hash table‚Äù in C ++. It was so simple that it was impossible to d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is Resizable Concurrent Map</h1><div class="post__text post__text-html js-mediator-article">  In one of the previous posts I told how to implement the <a href="https://habrahabr.ru/company/wunderfund/blog/322496/">world's ‚Äúsimplest lock-free hash table‚Äù</a> in C ++.  It was so simple that it was impossible to delete records from it or change its dimension.  Several years have passed since then, and not so long ago I wrote several multi-threaded associative arrays without such restrictions.  They can be found in my <a href="https://github.com/preshing/junction">Junction</a> project on GitHub. <br><habracut><br>  Junction contains several multi-threaded map interface implementations ‚Äî even the ‚Äúsimplest in the world‚Äù among them, called <code>ConcurrentMap_Crude</code> .  For brevity, we will call it the <b>Crude</b> map.  In this post I will explain the difference between the Crude map and the <b>Linear</b> map from the Junction library.  Linear is the simplest map in Junction, supporting both resizing and deletion. <br><br>  You can read the explanation of how the Crude map works <a href="http://preshing.com/20160201/new-concurrent-hash-maps-for-cpp/">in the original post</a> .  In short, it is based on <i>open addressing</i> and <i>linear probing</i> .  This means that it is essentially a large array of keys and values ‚Äã‚Äãusing linear search.  While adding or searching for a given key, we calculate the hash from the key to determine where to start the search.  Adding and searching data are possible in multi-threaded mode. <br><br><img src="https://habrastorage.org/files/e64/1eb/a82/e641eba82cc14f4c80fac5cacc26ea78.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The linear map in Junction is based on the same principle, with the following exception: when an array is full, all its contents are transferred to a new array of higher dimension.  When the data transfer ends, the old table is replaced with a new one.  But how do we still manage to support multithreaded operations?  The Linear map approach is based on the <a href="">non-blocking Hash Map of</a> Clif click on Java, with the exception of a few differences. <br><br><h2>  <font color="#c75733">Data structure</font> </h2><br>  To begin with, we will have to slightly change the data structure.  Crude map initially had two data elements: the <code>m_cells</code> pointer and the <code>m_cells</code> integer. <br><br><img src="https://habrastorage.org/files/1de/f9b/4c7/1def9b4c78b448e5970bf7a6a0005174.png"><br><br>  In the Linear map, the only data item is <code>m_root</code> , which points to the <code>Table</code> structure, followed by the cells themselves as a single continuous block of memory. <br><br><img src="https://habrastorage.org/files/2eb/47f/f0b/2eb47ff0b9734a049b76e1f00323d188.png"><br><br>  The <code>Table</code> structure stores a new shared <code>cellsRemaining</code> counter, with an initial value of 75% of the table size.  Each time a thread tries to add a new key, it first reduces <code>cellsRemaining</code> .  If <code>cellsRemaining</code> becomes less than zero, then the table is full and it's time to transfer data to a new one. <br><br>  With such a data structure, we can simultaneously replace the table, <code>sizeMask</code> and <code>cellsRemaining</code> in one atomic step, simply by redirecting the <code>m_root</code> pointer. <br><br><img src="https://habrastorage.org/files/922/7bf/833/9227bf8330a84d248e2abc7d89151326.png"><br><br>  Another difference between the two maps is that the Linear map stores the <i>hash</i> keys instead of the original ones.  This allows us to speed up the migration, since in this case we do not have to re-calculate the hash function.  The hash function used in Junction is also reversible, so the original key can always be recovered from the hash. <br><br><img src="https://habrastorage.org/files/d92/77f/f8a/d9277ff8ae3848ec849469952ded8f38.png"><br><br>  Since the hash function is reversible, the task of finding an existing key is as simple as calculating its hash.  Therefore, Junction currently supports only integer keys and key-pointers.  (In my opinion, it would be best to provide support for more complex keys by implementing a multithreaded set (set) instead of a map). <br><br><h2>  <font color="#c75733">Transferring data to a new table is the wrong way.</font> </h2><br>  Now that you know when to start transferring data, let's consider the migration task itself.  In essence, we must find each used cell in the old table and add its copy to the new table.  Some entries will be in the same places in the array, some will have higher indices, and some will move closer to their ideal index. <br><br><img src="https://habrastorage.org/files/5eb/7ef/53b/5eb7ef53b9b64ef7a5e9f8cb7c804e4e.png"><br><br>  Of course, if during the migration other threads can still change the data in the old table, everything becomes somewhat more complicated.  Using a naive approach, we risk losing change.  Suppose, for example, that our map is almost complete, but at this time two streams do the following: <br><br><ol><li>  Stream 1 calls <code>assign(2, "apple")</code> , reduces <code>cellsRemaining</code> to 0. </li><li>  Stream 2 performs <code>assign(14, "peach")</code> and reduces <code>cellsRemaining</code> to -1.  Migration required. </li><li>  Stream 2 transfers the contents of the old table to the new one, but does not yet open up access to the new table. </li><li>  Thread 1 calls <code>assign(2, "banana")</code> on the old table.  Since the cell already exists for this key, the function does not reduce <code>cellsRemaining</code> .  She will simply replace ‚Äúapple‚Äù with ‚Äúbanana‚Äù in the old cell. </li><li>  Stream 2 links the new table with the <code>m_root</code> pointer, thereby <code>m_root</code> the changes in stream 1. </li><li>  Thread 1 calls <code>get(2)</code> on the new table. </li></ol><br>  At this point, we expect <code>get(2)</code> return ‚Äúbanana‚Äù, because the key was changed only by one thread, and this was the last value recorded.  Unfortunately, <code>get(2)</code> returns the old value of ‚Äúapple‚Äù, which is wrong.  So we need a different strategy. <br><br><h2>  <font color="#c75733">Secure data transfer</font> </h2><br>  To avoid the above problem, we can block multi-threaded changes with the help of <a href="https://en.wikipedia.org/wiki/Readers%25E2%2580%2593writer_lock">readers-writer lock</a> , although in this case the definition of ‚Äúshared-exclusive lock‚Äù would be more appropriate.  With this approach, any function that changes the content of the table will put a joint lock.  The thread transferring data between tables will put an exclusive lock.  And thanks to <a href="http://preshing.com/20160726/using-quiescent-states-to-reclaim-memory">QSBR</a> , no locks are needed for <code>get</code> at all. <br><br>  But the Linear map does not.  She is one step ahead - it doesn‚Äôt even require joint blocking to change data.  The method is as follows: in the process of transferring data from the old table, the <code>value</code> field of each cell is replaced with a special <code>Redirect</code> marker. <br><br><img src="https://habrastorage.org/files/886/0a8/f97/8860a8f979024018a1cab5e8607a138d.png"><br><br>  This change affects all map operations.  In particular, the <code>assign</code> function can no longer blindly change the <code>value</code> field of a cell.  Instead, it must perform a <a href="http://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/p">read-modify-write</a> ( <a href="http://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/p">read-modify-write</a> ) operation on <code>value</code> to avoid rewriting the <code>Redirect</code> token if it has been set.  If the function finds a <code>Redirect</code> token corresponding to <code>value</code> , then the new table already exists and the operation must be performed on it already. <br><br>  Now, if we allow multithreaded operations during data transfer, then obviously it is necessary to ensure that the same values ‚Äã‚Äãcorrespond to each key in both tables.  Unfortunately, there is no way to automatically set <code>Redirect</code> for the old cell and at the same time copy its old value to the new cell.  However, we can ensure the integrity of the data by transferring each value in the loop.  Linear map uses the following loop: <br><br><img src="https://habrastorage.org/files/dca/a2e/db3/dcaa2edb35a24e90b37d152aac81096f.png"><br><br>  In this cycle, competing streams can still change the original <code>value</code> immediately after the stream responsible for the migration reads it, since the <code>Redirect</code> marker has not yet been set.  In this case, when the stream transferring the data tries to set the <code>Redirect</code> marker using <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> , CAS returns an error, and the stream tries to perform the operation again, already with a new value.  As long as the <code>value</code> in the source table changes, the data transfer stream will continue to try, but sooner or later the transfer will be successful.  This approach allows multithreaded get calls to safely find values ‚Äã‚Äãin a new table, while parallel <code>assign</code> calls cannot modify a new table until the migration is complete (Cliff Click hash map has no such limit, so there are a few more steps in its migration cycle). <br><br>  In the current version of the Linear map, even <code>get</code> calls do not read from the new table until all data has been transferred.  Therefore, in the latest version of the cycle is not necessary;  Migration could be accomplished by performing an atomic exchange of <code>value</code> in the source table and then simply saving the <code>value</code> in the new table (I realized this when I wrote this post).  Now, if the <code>get</code> call bumps into <code>Redirect</code> , it will help complete the migration.  Perhaps if he immediately read the value from the new table instead, our solution would be more scalable.  This is a topic for further research. <br><br><h2>  <font color="#c75733">Multithreaded data transfer</font> </h2><br>  There are other data elements in the <code>Table</code> structure that I haven't mentioned yet.  One of them is a <code>jobCoordinator</code> .  During data migration, a <code>jobCoordinator</code> points to a <code>TableMigration</code> object that reflects the migration process.  A new table is stored in it until it is shared with <code>m_root</code> .  I will not go into details, but the <code>jobCoordinator</code> allows several threads to participate in the migration process. <br><br><img src="https://habrastorage.org/files/1ce/4cc/a66/1ce4cca66ed449048eabee90afd2a797.png"><br><br>  What if several threads try <i>to start</i> migration at once?  In the event of such a race condition, the Linear map uses <a href="http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/">double-checked locking</a> to prevent duplication of the <code>TableMigration</code> object.  That is why each <code>Table</code> object has a mutex (Cliff's Click clipping is also different here. It optimistically allows the flow of threads to create new tables). <br><br>  In this post, I did not pay enough attention to the <code>erase</code> function, because it is simple: it simply replaces the cell <code>value</code> with a special <code>NullValue</code> value, which we have already used to initialize it.  The <code>hash</code> field, however, remains unchanged.  This means that, sooner or later, the table may become overflowed with deleted cells, but when moving to a new table, they will be cleared.  There are also a few subtleties regarding the choice of the dimension of the new table, but for now I‚Äôll omit these details. <br><br>  This is how the Linear map looks in general!  <b>The Leapfrog</b> map and the <b>Grampa</b> map in Junction are based on the same idea, but expand it in different ways. <br><br>  Parallel programming is a difficult task, but I think that it is worth developing its understanding, since multi-core processors do not go out of use.  That's why I decided to share the experience of implementing the Linear map.  Examples are a good way to learn something, or at least become familiar with a new area. <br><br><blockquote><div class="spoiler">  <b class="spoiler_title">Oh, and come to work with us?</b>  <b class="spoiler_title">:)</b> <div class="spoiler_text">  <a href="http://wunderfund.io/"><b>wunderfund.io</b></a> is a young foundation that deals with <a href="https://en.wikipedia.org/wiki/High-frequency_trading">high-frequency algorithmic trading</a> .  High-frequency trading is a continuous competition of the best programmers and mathematicians of the whole world.  By joining us, you will become part of this fascinating fight. <br><br>  We offer interesting and challenging data analysis and low latency tasks for enthusiastic researchers and programmers.  Flexible schedule and no bureaucracy, decisions are quickly made and implemented. <br><br>  Join our team: <a href="http://wunderfund.io/">wunderfund.io</a> </div></div></blockquote></habracut></div><p>Source: <a href="https://habr.com/ru/post/324060/">https://habr.com/ru/post/324060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324042/index.html">How we accelerated on FPGA AES: driver development</a></li>
<li><a href="../324046/index.html">Feature, not a bug. Or how Rambler allows to replace the sender of the letter</a></li>
<li><a href="../324048/index.html">I am an impostor</a></li>
<li><a href="../324052/index.html">Another algorithm for recovering blurred images</a></li>
<li><a href="../324056/index.html">The path to the dream</a></li>
<li><a href="../324062/index.html">Count to three</a></li>
<li><a href="../324064/index.html">5 reasons to enter the international marketplace</a></li>
<li><a href="../324066/index.html">Modern JWT authorization for modern Kode framework Node.js</a></li>
<li><a href="../324068/index.html">How to feed cattle. Advice to the head of the developer unit</a></li>
<li><a href="../324070/index.html">FPGA Image Filtering</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>