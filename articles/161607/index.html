<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once you read about the volatile keyword ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C and C ++ there is the keyword volatile , which indicates to the compiler that the value in the corresponding memory area can be changed at an arb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once you read about the volatile keyword ...</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/d0e/c5f/e41/d0ec5fe41e720a1bb894c2d6901bc1d2.png">  In C and C ++ there is the keyword <i>volatile</i> , which indicates to the compiler that the value in the corresponding memory area can be changed at an arbitrary moment and therefore it is impossible to optimize access to this area.  Usually, the description of a keyword immediately gives an example with data that can be changed at any time from another thread, by hardware or by the operating system.  After reading the description of the example, the majority of readers deeply yawns, decides that in this life they will not need this, and proceeds to the next section. <br><br>  Today we will consider a less exotic scenario of using the <i>volatile</i> keyword. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The C ++ standard defines the so-called observable behavior as a sequence of input-output and read-write operations of data declared as <i>volatile</i> (1.9 / 6).  Within the limits of the preservation of the observed behavior, the compiler is allowed to optimize the code in any way. <br><br>  For example ... Your code allocates memory using the operating system, and you want the operating system to allocate physical memory pages for the entire requested area.  Many operating systems allocate pages at the first real access, and this may lead to additional delays, and you, for example, want to avoid these delays and move them to an earlier point.  You can write this code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = start; ptr &lt; start + size; ptr += MemoryPageSize ) { *ptr; }</code> </pre> <br>  This code runs across the region and reads one byte from each page of memory.  One problem - the compiler optimizes this code and completely removes it.  It has the full right - this code does not affect the observed behavior.  Your experiences about the allocation of pages by the operating system and the resulting delays do not apply to the observed behavior. <br><br>  What to do, what to do ... Oh, right!  Let's ban the compiler from optimizing this code. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optimize( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, off ) for( char* ptr = start; ptr &lt; start + size; ptr += MemoryPageSize ) { *ptr; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optimize( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, on )</span></span></code> </pre><br>  Great, as a result ... <br><br>  1. used <i>#pragma</i> , which makes the code poorly portable, plus ... <br>  2. optimization is turned off completely, and this increases the amount of machine code three times, plus in Visual C ++, for example, this <i>#pragma</i> can only be used outside the function, respectively, it is not necessary to rely on embedding this code in the calling code and further optimization. <br><br>  The keyword <i>volatile</i> would help a <i>lot here</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = start; ptr &lt; start + size; ptr += MemoryPageSize ) { *ptr; }</code> </pre><br>  And everything is achieved exactly the desired effect - the code instructs the compiler to be sure to perform the reading with the specified step.  Optimization by the compiler does not have the right to change this behavior, because now the sequence of readings refers to the observed behavior. <br><br>  Now let's try to overwrite the memory in the name of security and paranoia (this is not nonsense, <a href="http://habrahabr.ru/company/abbyy/blog/127259/">this is how it happens in real life</a> ).  In that post, a certain magic function <i>SecureZeroMemory ()</i> is mentioned that supposedly guaranteed to overwrite the specified memory area with zeros.  If you use <i>memset ()</i> or an equivalent self-written cycle, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; size; index++ ) ptr[index] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br><br>  for a local variable, that is, the risk that the compiler will delete this cycle, because the cycle does not affect the observed behavior (the arguments in that post also do not apply to the observed behavior). <br><br>  What to do, what to do ... And, we "deceive" the compiler ... Here is what can be found at the request of "prevent memset optimization": <br><br>  1. replacing a local variable with a variable in dynamic memory with all the attendant overhead and the risk of leakage ( <a href="http://linux.derkeiler.com/Mailing-Lists/Kernel/2010-02/msg09740.html">message in the linux-kernel distribution archive</a> ) <br>  2. macro with assembler magic ( <a href="http://linux.derkeiler.com/Mailing-Lists/Kernel/2010-02/msg10882.html">message in the linux-kernel mailing list archive</a> ) <br>  3. the proposal to use a special preprocessor symbol that prohibits embedding <i>memset ()</i> in place and makes it difficult for the compiler to optimize (of course, this feature should be supported in the library version used, plus Visual C ++ 10 can even optimize the code of functions marked as non-embeddable) <br>  4. various read-write sequences using global variables (the code becomes noticeably larger and such code is not thread safe) <br>  5. subsequent reading with an error message in case if the wrong data was written that was written (the compiler has the right to notice that there is no ‚Äúwrong data‚Äù and delete this code) <br><br>  All these methods have many common features - they are poorly portable and difficult to verify.  For example, you "deceived" some version of the compiler, and the newer one will have a smarter analyzer, which will guess that the code does not make sense, and will remove it, and will not do so everywhere, but only in some places. <br><br>  You can compile the rewrite function into a separate translation unit so that the compiler does not ‚Äúsee‚Äù what it does.  After the next compiler change, code generation by the linker will enter the game (LTCG in Visual C ++, LTO in gcc or as it is called in the compiler you use) - and the compiler will recover the memory and see that overwriting the memory "does not make sense" and deletes it. <br><br>  No wonder there was a saying <i>you can't lie to a compiler</i> . <br><br>  But what if you look at the typical implementation of <i>SecureZeroMemory ()</i> ?  It is essentially as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *volatilePtr = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(ptr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; index &lt; size; index++ ) * volatilePtr = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <s>And that's all - the compiler no longer has the right to delete the record ...</s> <br><br>  EXTREMELY UNEXPECTED ... despite all superstitions, the <u>strikethrough statement above is incorrect</u> . <br><br>  In fact - it has.  The standard says that a read-write sequence should be saved only for data with a <i>volatile</i> qualifier.  Here for such: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> buffer[size];</code> </pre><br>  If the data itself does not have a <i>volatile</i> qualifier, and the <i>volatile</i> qualifier is added to a pointer to this data, the read-write of this data no longer applies to the observed behavior: <br><br><pre> <code class="cpp hljs">buffer[size]; SecureZeroMemory(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer));</code> </pre><br>  All hope for compiler developers - at the moment both Visual C ++ and gcc do not optimize memory accesses via pointers with a <i>volatile</i> qualifier - including because this is one of the important use cases for such pointers. <br><br>  There is no standard-guaranteed way to overwrite data with a function equivalent to <i>SecureZeroMemory ()</i> if the variable with this data does not have a <i>volatile</i> qualifier.  Similarly, it is impossible to code as at the very beginning of the post is guaranteed to read the memory.  All possible solutions are not completely portable. <br><br>  The reason for this is trivial - it is ‚Äúnot necessary.‚Äù <br><br>  Situations where a variable with data to be written goes out of scope, and then the memory occupied by it is reused for another variable and the new variable is read without prior initialization, refer to undefined behavior.  The standard clearly states that in such cases any behavior is permissible.  Usually just read "garbage", which was recorded in this memory before. <br><br>  Therefore, from the standpoint of the Standard, guaranteed rewriting of such variables before going out of scope does not make sense.  Similarly, it does not make sense to read memory for the sake of reading memory. <br><br>  Using <i>volatile</i> pointers is most likely the most effective way to solve a problem.  First, compiler developers usually deliberately turn off memory access optimization.  Secondly, the overhead is minimal.  Thirdly, it is relatively easy to check whether this method works on a specific implementation ‚Äî just look at which machine code will be generated for the trivial examples above from this post. <br><br>  <i>volatile</i> - not only for drivers and operating systems. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/161607/">https://habr.com/ru/post/161607/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161591/index.html">AWS CLI utilities now for PowerShell</a></li>
<li><a href="../161595/index.html">StoreVirtual - a new name for Lefty</a></li>
<li><a href="../161597/index.html">Multi-threading implementation of the CART caching algorithm</a></li>
<li><a href="../161601/index.html">How to find out about the problem of the server first, or how to SMS PRTG Network Monitor</a></li>
<li><a href="../161605/index.html">View OpenCV images while debugging C ++ code in Visual Studio</a></li>
<li><a href="../161609/index.html">Overview of dialer programs for Windows Phone OS</a></li>
<li><a href="../161611/index.html">Traffic jams from the future</a></li>
<li><a href="../161615/index.html">Room plans are now available for Google Maps / Germany</a></li>
<li><a href="../161617/index.html">Old Shakes: intercepting data stream between i386 and ATA controller using STM32</a></li>
<li><a href="../161621/index.html">Google Maps API v2 - end of service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>