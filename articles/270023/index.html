<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to RxJava: Key Types</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the introductory article, we looked at the benefits of a reactive approach to Java programming, as well as situations in which the Rx library is mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to RxJava: Key Types</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d29/234/42c/d2923442c6d54c8e9e6b517d73ff978f.png" alt="rxjava"><br>  <i>In the <a href="http://habrahabr.ru/post/269417/">introductory article,</a> we looked at the benefits of a reactive approach to Java programming, as well as situations in which the Rx library is more or less useful.</i>  <i>In this part we will look at the main types on which the concept of reactive programming is based and several additional classes that will help us in understanding the principles of the library.</i> <br><a name="habracut"></a><br><h5>  Content: </h5><br><ul><li>  Part One - Introduction <br><ol><li>  <a href="http://habrahabr.ru/post/269417/">Why Rx?</a> </li><li>  <b>Key types</b> </li><li>  <a href="http://habrahabr.ru/post/270975/">Subscription life cycle</a> </li></ol></li><li>  Part Two - Sequences <br><ol><li>  <a href="https://habrahabr.ru/post/281633/">Creating a sequence</a> </li><li>  Sequence filtering </li><li>  Study </li><li>  Aggregation </li><li>  Sequence transformation </li></ol></li><li>  Part Three - Sequence Management </li><li>  Part Four - Parallelism </li></ul><br><br><h1>  Key types </h1><br>  Rx is based on two fundamental types, while some others extend their functionality.  These basic types are <b>Observable</b> and <b>Observer</b> , which we will look at in this section.  We will also look at <b>Subjects</b> ‚Äî they will help in understanding the basic concepts of Rx. <br><br>  Rx is built on the <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Observer</a> pattern.  There is nothing new in this, event handlers already exist in Java (for example, JavaFX EventHandler [ <a href="https://habr.com/ru/post/270023/">1</a> ]), but they lose out on Rx for the following reasons: <br><ul><li>  Event handling in them is difficult to compose </li><li>  Their call cannot be postponed. </li><li>  May lead to memory leak </li><li>  There is no easy way to report the end of a stream of events. </li><li>  Requires manual multithreading control. </li></ul><br><h2>  Observable </h2><br>  <a href="http://reactivex.io/RxJava/javadoc/rx/Observable">Observable</a> is the first base type we will look at.  This class contains the bulk of the Rx implementation, including all the basic operators.  We will look at them later, but for now we should understand the principle of the <b>subscribe</b> method.  Here is the key overload [ <a href="https://habr.com/ru/post/270023/">2</a> ]: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Subscription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span></code> </pre> <br>  The <b>subscribe</b> method is used to get the data returned by [ <a href="https://habr.com/ru/post/270023/">3</a> ] observable.  These data are transmitted to the observer, who assumes their processing depending on the requirements of the consumer.  The observer in this case is an implementation of the <b>Observer</b> interface. <br><br>  Observable reports three kinds of events: <br><ul><li>  Data </li><li>  Signal of completion of the sequence [ <a href="https://habr.com/ru/post/270023/">4</a> ] (which means that there will be no more data) </li><li>  An error if the sequence ended due to an exception (this event also implies the completion of the sequence) </li></ul><br><h2>  Observer </h2><br>  Rx provides an abstract implementation of Observer, <b>Subscriber</b> .  <b>Subscriber</b> implements additional functionality and, as a rule, it should be used to implement the <b>Observer</b> .  However, for starters, consider only the interface: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Throwable e)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; }</code> </pre><br>  These three methods are behavior that describes the observer's reaction to a message from observable.  <b>The observer's onNext</b> will be called 0 or more times, optionally followed by <b>onCompleted</b> or <b>onError</b> .  After them there will be no more calls. <br><br>  When developing code with Rx, you will see a lot of <b>Observable</b> , but a lot less <b>Observer</b> .  And although it is necessary to understand the concept of <b>Observer</b> , there are ways that do not require the direct creation of its instance. <br><br><h2>  Implementing Observable and Observer </h2><br>  You can manually implement <b>Observer</b> and <b>Observable</b> .  In reality, this is usually not necessary: ‚Äã‚ÄãRx provides ready-made solutions to simplify development.  It may also not be entirely secure, since the interaction between parts of the Rx library includes principles and internal infrastructure that may not be obvious to the newcomer.  In any case, it will be easier to start using the many tools already provided by the library to create the functionality we need. <br><br>  To subscribe to observable, there is absolutely no need for an <b>observer</b> implementation.  There are other overloads of the <b>subscribe</b> method that take as arguments the corresponding functions for <b>onNext</b> , <b>onError,</b> and <b>onSubscribe</b> , which encapsulate the creation of an <b>Observer</b> instance.  It is not necessary to provide them all either, you can describe only a part of them, for example, only <b>onNext</b> or only <b>onNext</b> and <b>onError</b> . <br><br>  Lambda expressions in Java 1.8 make these overloads very suitable for use in short examples in this series of articles. <br><br><h2>  Subject </h2><br>  <b>Subjects</b> are extensions of the <b>Observable</b> , while simultaneously implementing the Observer interface.  The idea may seem strange, but in certain cases they make some things a lot easier.  They can receive event messages (as observer) and report them to their subscribers (as observable).  This makes them the ideal starting point for exploring Rx code: when you have data coming in from outside, you can pass it on to the Subject, turning it into observable in this way. <br><br>  There are several implementations of Subject.  Now we consider the most important of them. <br><br><h2>  PublishSubject </h2><br>  <b>PublishSubject</b> is the simplest implementation of <b>Subject</b> .  When data is sent to the <b>PublishSubject</b> , it issues it to all subscribers who are currently subscribed to it. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ PublishSubject&lt;Integer&gt; subject = PublishSubject.create(); subject.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.subscribe(System.out::println); subject.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.onNext(<span class="hljs-number"><span class="hljs-number">3</span></span>); subject.onNext(<span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre><br>  <a href="">Conclusion:</a> <br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  As we see, <b>1 was</b> not printed due to the fact that we were not signed at the moment when it was transmitted.  After we signed up, we started getting all the values ‚Äã‚Äãcoming in to subject. <br><br>  Here we use the <b>subscribe</b> method for the first time, so it‚Äôs worth paying attention to.  In this case, we use an overloaded version that accepts one object of the <a href="http://reactivex.io/RxJava/javadoc/rx/functions/Function.html">Function</a> class responsible for <b>onNext</b> .  This function accepts a value of type Integer and returns nothing.  Functions that return nothing are also called actions.  We can transfer this function in the following ways: <br><ul><li>  Provide an object of class <b>Action1 &lt;Integer&gt;</b> </li><li>  Implicitly create one using <a href="https://en.wikipedia.org/wiki/Anonymous_function">lambda expression</a> </li><li>  Send a link to an existing method with the appropriate signature.  In this case, <b>System.out :: println</b> has an overloaded version that accepts <b>Object</b> , so we pass a reference to it.  Thus, the subscription allows us to print all incoming numbers to the <b>Subject</b> into the main output stream. </li></ul><br><br><h2>  Replaysubject </h2><br>  <b>ReplaySubject</b> has a special ability to cache all the data entered into it.  When he gets a new subscriber, the sequence is issued to him from the beginning.  All subsequent incoming data will be issued to subscribers as usual. <br><br><pre> <code class="java hljs">ReplaySubject&lt;Integer&gt; s = ReplaySubject.create(); s.subscribe(v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Early:"</span></span> + v)); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); s.subscribe(v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Late: "</span></span> + v)); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs">Early:<span class="hljs-number"><span class="hljs-number">0</span></span> Early:<span class="hljs-number"><span class="hljs-number">1</span></span> Late: <span class="hljs-number"><span class="hljs-number">0</span></span> Late: <span class="hljs-number"><span class="hljs-number">1</span></span> Early:<span class="hljs-number"><span class="hljs-number">2</span></span> Late: <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  All values ‚Äã‚Äãwere obtained, despite the fact that one of the subscribers subscribed later than the other.  Please note that before getting a new value, the subscriber gets all missing.  Thus, the sequence order for the subscriber is not broken. <br><br>  Caching everything is not always the best idea, since sequences can be long or even infinite.  The factory method <b>ReplaySubject.createWithSize</b> limits the size of the buffer, and <b>ReplaySubject.createWithTime limits the</b> time that objects will remain in the cache. <br><br><pre> <code class="java hljs">ReplaySubject&lt;Integer&gt; s = ReplaySubject.createWithSize(<span class="hljs-number"><span class="hljs-number">2</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>); s.subscribe(v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Late: "</span></span> + v)); s.onNext(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs">Late: <span class="hljs-number"><span class="hljs-number">1</span></span> Late: <span class="hljs-number"><span class="hljs-number">2</span></span> Late: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  This time our subscriber missed the first value that fell out of the buffer of size 2. In the same way, over time, objects drop out of the buffer. <br>  Subject created with <b>createWithTime</b> . <br><br><pre> <code class="java hljs">ReplaySubject&lt;Integer&gt; s = ReplaySubject.createWithTime(<span class="hljs-number"><span class="hljs-number">150</span></span>, TimeUnit.MILLISECONDS, Schedulers.immediate()); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); Thread.sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); Thread.sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>); s.subscribe(v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Late: "</span></span> + v)); s.onNext(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs">Late: <span class="hljs-number"><span class="hljs-number">1</span></span> Late: <span class="hljs-number"><span class="hljs-number">2</span></span> Late: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Creating a time- <b>bound ReplaySubject</b> requires a <b>Scheduler</b> object, which is a time representation in Rx.  We will definitely return to the schedulers in the section about multithreading. <br><br>  <b>ReplaySubject.createWithTimeAndSize</b> restricts the buffer in both parameters. <br><br><h2>  BehaviorSubject </h2><br>  <b>BehaviorSubject</b> stores only the last value.  This is the same as <b>ReplaySubject</b> , but with a buffer size of 1. At creation time, it can be assigned an initial value, thus ensuring that the data will always be available to new subscribers. <br><br><pre> <code class="javascript hljs">BehaviorSubject&lt;Integer&gt; s = BehaviorSubject.create(); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>); s.subscribe(v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Late: "</span></span> + v)); s.onNext(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs">Late: <span class="hljs-number"><span class="hljs-number">2</span></span> Late: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  The initial value is provided in order to be available even before the data is received. <br><br><pre> <code class="java hljs">BehaviorSubject&lt;Integer&gt; s = BehaviorSubject.create(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.subscribe(v -&gt; System.out.println(v)); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Since the <b>BehaviorSubject</b> role is to always have available data, it is considered wrong to create it without an initial value, as well as complete it. <br><br><h2>  Asyncsubject </h2><br>  <b>AsyncSubject</b> also stores the last value.  The difference is that it does not issue data until the sequence is completed.  It is used when it is necessary to produce a single value and complete immediately. <br><br><pre> <code class="java hljs">AsyncSubject&lt;Integer&gt; s = AsyncSubject.create(); s.subscribe(v -&gt; System.out.println(v)); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>); s.onCompleted();</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Note that if we did not <b>call s.onCompleted ()</b> , this code would not have printed anything. <br><br><h2>  Implicit infrastructure </h2><br>  As we already mentioned, there are principles that may not be obvious in the code.  One of the most important is that no event will be issued after the sequence is completed ( <b>onError</b> or <b>onCompleted</b> ).  The <b>subject</b> implementation respects these principles: <br><br><pre> <code class="java hljs">Subject&lt;Integer, Integer&gt; s = ReplaySubject.create(); s.subscribe(v -&gt; System.out.println(v)); s.onNext(<span class="hljs-number"><span class="hljs-number">0</span></span>); s.onCompleted(); s.onNext(<span class="hljs-number"><span class="hljs-number">1</span></span>); s.onNext(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  <a href="">Conclusion</a> <br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Security cannot be guaranteed wherever Rx is used, so you better be aware and not violate this principle, as this can lead to undefined consequences. <br><br>  In the <a href="http://habrahabr.ru/post/270975/">sequel,</a> we will look at the Observable life cycle. <br><br><a name="notes"></a><br>  [1] Or familiar to all Event Listeners.  - <i>Note.</i>  <i>The author</i> <br>  [2] I, nevertheless, believe that the key overload here is exactly the version with the Observer as an argument, in the original the version of the subscribe version is given (Subscriber &lt;? Super T&gt; subscriber) - <i>Note.</i>  <i>The author</i> <br>  [3] I will use the word ‚Äúissue‚Äù to describe the data transfer event from the Observable to the Observer (to emit in original).  - <i>Note.</i>  <i>The author</i> <br>  [4] The author uses the term sequence to denote the set of all data that Observable can issue.  - <i>Note.</i>  <i>The author</i> </div><p>Source: <a href="https://habr.com/ru/post/270023/">https://habr.com/ru/post/270023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270009/index.html">Memory Management: A View from the Inside</a></li>
<li><a href="../270011/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ183 (October 26 - November 1, 2015)</a></li>
<li><a href="../270015/index.html">Enabling BitLocker on Exchange Servers</a></li>
<li><a href="../270017/index.html">Michael Stonebreaker - Hadoop at the Crossroads</a></li>
<li><a href="../270019/index.html">Vivaldi Beta 1.0 browser release</a></li>
<li><a href="../270027/index.html">Why ‚Äúerrors are meanings‚Äù in Go</a></li>
<li><a href="../270031/index.html">NSNJSON. ÈÅì (Final article)</a></li>
<li><a href="../270033/index.html">Dagaz: Halfway</a></li>
<li><a href="../270039/index.html">Creating Gesture Recognition Web Applications with the Intel RealSense SDK</a></li>
<li><a href="../270041/index.html">Run iOS applications from the console on the device and simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>