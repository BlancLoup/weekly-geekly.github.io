<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal bot for the game Flood-It</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Figure 1. The playing field. 

 Once, one little article caught my eye. Immediately after reading the title, dozens of ideas of this kind appeared in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal bot for the game Flood-It</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/ca9/175/0fa/ca91750fa5598a6787aabe3833996773.png" alt="image"><br>  <i>Figure 1. The playing field.</i> <br><br>  Once, one little <a href="http://habrahabr.ru/blogs/gdev/129117/">article</a> caught my eye.  Immediately after reading the title, dozens of ideas of this kind appeared in my head, including the very idea of ‚Äã‚Äãcreating a universal bot for this game. <br><br>  At that time I had no particular experience in the automation of games, but the desire was paramount.  Therefore, taking out a notebook, I began to think about this process ... <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Analysis </h4><br><br>  I started analyzing from the end, imagining that I already have a working program in my hands, pressing the right buttons in the right sequence.  In order for her to do this, she needs to know the coordinates of these buttons, will she not poke at any place on the screen, in the hope that she will get there at least once?  Next, you need to provide a sequence in which the bot will press the buttons, he will not poke any buttons, right?  To provide the necessary sequence of clicks, you need to choose the most optimal algorithm for selecting colors for the fill, and how to do it without having data on the state of the field?  That's right, no way!  Therefore, you need to obtain data on the colors of the cells in the playing field.  Fine, but the question is, where is the playing field itself?  The answer "somewhere on the screen" is not accepted, so you will need to find it.  Now everything seems to be, let's write down a plan for our further actions: <br><ul><li>  recognize the playing field and its parameters; </li><li>  get data about the colors of the cells in the game; </li><li>  find the optimal sequence of fill options; </li><li>  find the position of the fill buttons for each color; </li><li>  automate the process of the game. </li></ul><br><br><h4>  Recognition of the playing field and its parameters </h4><br><br>  The first thing was to somehow find out the position of the playing field on the screen.  But first, it would not hurt to get a screenshot.  For this, I needed a java.awt.Robot class, with its method: BufferedImage createScreenCapture (Rectangle screenRect). <br>  And what next?  And then there were many attempts to force the program to find the position of the playing field, tens of thousands of calls to the getRGB method of the BufferedImage class, attempts to find out the position of the playing field from a pattern, etc.  All these results were unsuccessful.  What worked for one game did not work for another.  Then one day, such a plan flew into my head: <br><ul><li>  binarize the image; </li><li>  if necessary, invert it so that the significant points are white and the background is black; </li><li>  calculate the number of occurrences of white dots horizontally and vertically; </li><li>  weed out unnecessary occurrences; </li><li>  find the longest sequence of nonzero values.  The position from which this long sequence begins will be the starting point of the playing field, and the length of this sequence will be in pixels. </li></ul><br><br>  Having taken a screenshot, it would be nice to convert it to an ARGB array: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[w * h]; image.getRGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, w, h, pixels, <span class="hljs-number"><span class="hljs-number">0</span></span>, w);</code> </pre> <br><br>  It is difficult to work with a color image, so you need to binarize it, that is, make it monochrome, so that we have only black and white colors at our disposal.  Everything is simple here: we take another color and look at its brightness, if it is lower than the threshold, then this color will be black, if higher, white.  In the software implementation, it looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> red = (color &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> green = (color &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blue = color &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mean = (qr + qg + qb) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mean &gt; thresholdValue) color = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>;</code> </pre> <br>  First you need to get the brightness of the current color, and it is taken either as the average amount of the RGB component, or by the formula: brightness = 0.3 * red + 0.59 * green + 0.11 * blue.  The coefficients are taken for a reason, they mean the perception of a particular color component with the human eye. <br><br>  Now you need to pick a threshold value (thresholdValue), 191 is quite suitable - on all sites with a game where there was a light background, binarization gave the following image: <br><img src="https://habrastorage.org/storage2/09f/7f6/24f/09f7f624f69690228c5e3b84aa9e67ef.png"><br>  <i>Figure 2. Monochrome image.</i> <br>  And on sites with a dark background, the value 64 gave a similar picture, but inverse.  By the way, I chose 191 for a reason, and according to law 255-64. <br><br>  It is easy to see that in such an image the playing field is much easier to find than if we were looking for a color one.  It remains only to find out whether our background is bright or dark in order to use the threshold 64 or (255-64) from these data and invert the image if necessary.  In my code, it looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] threshold(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] pixels, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> inverse = isBackgroundLight(MAX_COLOR_POINTS); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inverse) value = <span class="hljs-number"><span class="hljs-number">255</span></span> - value; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] bw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[pixels.length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = getBrightness(pixels[i]); bw[i] = (brightNess &gt;= value) ^ inverse; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bw; }</code> </pre> <br><br>  isBackgroundLight takes the number of dots that are needed in order to understand that the background is bright or dark.  We get MAX_COLOR_POINTS from a color image and find the average brightness.  If it is more than 128, then the background is bright, if less - dark. <br><br>  Further, in the resulting monochrome image, we need to calculate the number of white dots horizontally and vertically.  This is done in two passes in the image.  As a result, we get two arrays with the following values: 1440, 1440, 410, 23, 119, 838 ... Filter the values ‚Äã‚Äãbelow the average, and we get an array: 1, 1, 0, 0, 0, 1 ... And finally, we need to determine the longest sequence These are the ones who are not broken by zero.  This is also a rather trivial task. <br><br>  In the end, we get 4 values: the position of the playing field horizontally, vertically, the width and height of the playing field.  Since it is square, the last two values ‚Äã‚Äãshould be the same.  To find out the size of each cell, you need to divide the size of the playing field by its dimension.  The dimension is set by the user, because the field is not only 14x14, but also 10x10, 20x20, etc. <br><br><h4>  Retrieving cell color data </h4><br><br>  Now that we have determined the parameters of the playing field, we can read the colors of the cells: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[boardSize][boardSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = cellSize / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; boardSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; boardSize; j++) { table[i][j] = detectImage.getRGB(j*cellSize + offset, i*cellSize + offset); } }</code> </pre> <br>  In order to avoid mistakes, we will take colors strictly in the center of the cell. <br><br>  Further, in order to make it easier to work with data, you need to translate these colors into identifiers: 0, 1, 2, 3 ... But you can‚Äôt do this if (color == 0xFF46B1E2), since the palette differs in different versions of games.  For example, in one there is an orange color, and in the other, instead of it, lilac is used instead ... But do not worry, let's go round by - we will remember the colors for each index: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[][] colorsToIds(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] tableColor) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = tableColor.length; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[][] out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size][size]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colorsReaded = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    for (int i = 0; i &lt; size; i++) { for (int j = 0; j &lt; size; j++) { int color = tableColor[i][j]; for (byte k = 0; k &lt; colorsReaded; k++) { //     if (colors[k] == -1) { colors[k] = color; colorsReaded++; if (colorsReaded &gt; MAX_COLORS) colorsReaded = MAX_COLORS; } //     ,    ID if (color == colors[k]) { out[i][j] = k; break; } } } } return out; }</span></span></code> </pre> <br><br>  MAX_COLORS here is equal to 6, because in the games Flood-It there are just so many colors in the palette.  But if suddenly someone wants to make a game with ten different colors in the palette, the program will be able to recognize them. <br><br>  Now you can check the performance of this piece of code.  After feeding the program the image of the playing field in Figure 1, the result did not take long to wait: <br><br>  0 1 2 2 3 3 0 0 1 2 2 3 3 3 <br>  2 4 1 1 5 4 5 0 2 4 5 3 4 4 <br>  3 1 1 5 2 1 3 5 5 2 1 0 4 2 <br>  0 3 1 0 5 4 4 1 4 1 4 5 3 5 <br>  4 5 0 4 4 4 3 2 0 3 1 0 0 5 <br>  0 4 3 4 1 1 2 2 3 2 3 3 1 2 <br>  3 2 0 0 5 2 1 5 3 0 2 1 4 4 <br>  3 3 5 3 1 5 3 0 3 5 2 4 1 1 <br>  3 3 3 3 0 5 0 3 5 0 1 4 2 4 <br>  4 2 3 0 2 1 0 3 1 3 2 2 2 3 <br>  5 5 1 4 2 3 5 4 1 2 5 0 4 0 <br>  5 2 0 2 2 3 2 5 4 1 1 5 0 5 <br>  1 0 0 5 5 5 4 1 2 2 3 2 2 0 <br>  3 2 2 3 4 3 0 3 2 2 3 3 5 5 <br><br><h4>  Search for the optimal sequence of fill options </h4><br><br>  No matter how I tried, I couldn‚Äôt work out an algorithm better than the author‚Äôs <a href="http://habrahabr.ru/blogs/gdev/129117/">article</a> .  So I took his algorithm and rewrote it in a more universal way.  I think he will not object. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextFillColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] table)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    int fillSize = (int) Math.pow(MAX_COLORS, FILL_STEPS); int[] fillRate = new int[fillSize]; //     int[] fillPow = new int[FILL_STEPS]; for (int i = 0; i &lt; FILL_STEPS; i++) { fillPow[i] = (int) Math.pow(MAX_COLORS, i); } //  FILL_STEPS  MAX_COLORS  for (int i = 0; i &lt; fillSize; i++) { byte[][] iteration = copyTable(table); for (int j = 0; j &lt; FILL_STEPS; j++) { byte fillColor = (byte) (i / fillPow[j] % MAX_COLORS); fillTable(iteration, fillColor); } //     fillRate[i] = getFillCount(iteration); } //       FILL_STEPS   int maxArea = fillRate[0]; int maxColor = 0; for (int i = 1; i &lt; fillSize; i++) { if (fillRate[i] &gt; maxArea) { maxColor = i; maxArea = fillRate[i]; } } //        byte colorID = (byte) (maxColor % MAX_COLORS); fillTable(table, colorID); return colorID; }</span></span></code> </pre> <br><br>  Now we are not limited to four miscalculations forward and six colors in the palette, so you can change the values ‚Äã‚Äãat your discretion. <br>  Based on this function, we compose a function for obtaining the complete winning sequence: <br><pre> <code class="java hljs">ArrayList&lt;Byte&gt; seq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Byte&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!gameCompleted(copyTable)) { seq.add(getNextFillColor(copyTable)); }</code> </pre> <br>  gameCompleted checks whether all cells are filled with any one color, and if so, then the game is over. <br><br>  Having launched the application, we will give it our picture 1 to be eaten, as a result of which we will get: <br>  1 2 1 3 0 5 4 0 3 1 0 5 3 1 4 1 5 2 4 0 5 <br>  But this kind of result is not very convenient for us. <br><br><h4>  Search for the position of the fill buttons </h4><br><br>  So, at our disposal there is a sequence of identifiers for the fill, a palette with the colors of the cells, the coordinates of the field and its size.  Buttons left.  Looking at the playing fields you can see that the buttons are often to the left of the playing field, and at the same level with it.  Of course, we will not limit ourselves to this.  Suddenly somewhere there is a game with buttons on the top or on the right?  Further, the colors of the buttons are close to the colors of the cells, but not always equal to them.  This means that we will not be limited to a simple comparison of the points of the image with the palette.  Well, let's collect everything in a heap and make up a button search algorithm: <br><ul><li>  select one of the four parts of the window image: to the left of the playing field, above, to the right and, finally, below; </li><li>  for each color from the palette we are looking for a color close to it in the image.  On finding, remember the position of this point; </li><li>  if the points are found for all the colors from the palette, then everything is fine, they coped with the task.  Otherwise, go to the first step and select the next part of the image; </li><li>  if all parts of the image were viewed, but the buttons were never found, then they simply do not exist!  In this case, simply issue the result in a more human form. </li></ul><br><br><img src="http://habrastorage.org/storage2/eb5/084/393/eb5084393ea736278a7dd738cfd3a643.png"><br>  <i>Figure 3. The image is divided into parts.</i> <br><br>  All of the above in the code looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point[] getButtons(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] colors) { Point[] out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[colors.length]; <span class="hljs-comment"><span class="hljs-comment">//      int size = boardSize * cellSize; //   ,      Rectangle[] partsOfImage = new Rectangle[] { new Rectangle(0, board.y, board.x, size), //    new Rectangle(0, 0, w, board.y), //    new Rectangle(board.x+size, board.y, w-board.x-size, size), //    new Rectangle(0, board.y+size, w, h-board.y-size) //    }; for (int i = 0; i &lt; partsOfImage.length; i++) { Rectangle rect = partsOfImage[i]; BufferedImage part = image.getSubimage(rect.x, rect.y, rect.width, rect.height); //   ,     boolean found = true; for (int j = 0; j &lt; colors.length; j++) { if (colors[i] == -1) continue; Point pt = findButton(part, colors[j]); if (pt != null) { //      pt.translate(rect.x, rect.y); out[j] = pt; } else { found = false; break; } } if (found) return out; } //      return null; }</span></span></code> </pre> <br><br>  findButton just goes through all the points of the image until it meets a color similar to the one given to it.  To find such a color, you need to calculate the difference modulo each of its RGB components and compare it with a certain number - sensitivity: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tolerance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tolerance &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color1 == color2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r1 = (color1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g1 = (color1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b1 = color1 &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r2 = (color2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g2 = (color2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b2 = color2 &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Math.abs(r1 - r2) &lt;= tolerance) &amp;&amp; (Math.abs(g1 - g2) &lt;= tolerance) &amp;&amp; (Math.abs(b1 - b2) &lt;= tolerance); }</code> </pre> <br><br><h4>  Automation of gameplay </h4><br><br>  So, when all the buttons are found and the desired sequence of their presses is given, you can proceed to the "auto-click".  In order for the program itself to move the cursor to the right place and press the left mouse button, the same java.awt.Robot class serves.  The function looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point click)</span></span></span><span class="hljs-function"> </span></span>{ robot.mouseMove(click.x, click.y); robot.mousePress(InputEvent.BUTTON1_MASK); robot.delay(CLICK_DELAY); robot.mouseRelease(InputEvent.BUTTON1_MASK); }</code> </pre> <br><br>  Let me explain: first, move the cursor to the desired position of the screen, then press the left mouse button, wait a few fractions of a second so that the browser can manage to process the click, and then release the button.  It's simple.  And having a sequence of indexes for clicks and the coordinates of each button, you can write an automatic clicker: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">autoClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point[] buttons, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; result.length; i++) { clickPoint(buttons[result[i]]); } }</code> </pre> <br><br>  All that remains now is to handle the situation when the buttons are not on the screen.  In this case, simply create an image, draw on it all the colors (colors, not identifiers 0, 1, 2 ...) in order and display on the screen. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BufferedImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sequenceToImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] ids, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] palette)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    //    10    final int CELLS_IN_ROW = 10; int width = CELLS_IN_ROW * size; if (width == 0) width = size; int rows = ids.length / CELLS_IN_ROW; BufferedImage out = new BufferedImage(width, (rows*size)+size, BufferedImage.TYPE_INT_RGB); Graphics G = out.getGraphics(); for (int i = 0; i &lt; ids.length; i++) { G.setColor(new Color(palette[ids[i]])); G.fillRect(i % CELLS_IN_ROW * size, i / CELLS_IN_ROW * size, size, size); } G.dispose(); return out; }</span></span></code> </pre> <br><br><h4>  Conclusion </h4><br><br>  That's what happened with the same picture 1: <br><img src="http://habrastorage.org/storage2/05a/2c2/e4b/05a2c2e4b629ac36b73bf671ddbe6aca.png"><br>  <i>Figure 4. Result.</i> <br><br>  Thank you for your attention, I will be glad to any advice and ideas on this topic. <br>  Sources are available on github: <a href="https://github.com/aNNiMON/Flood-It-Bot">Flood-It-Bot</a> </div><p>Source: <a href="https://habr.com/ru/post/136380/">https://habr.com/ru/post/136380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136371/index.html">DesignPatterns, Interpreter Template</a></li>
<li><a href="../136374/index.html">Kinetic ScrollBar</a></li>
<li><a href="../136375/index.html">Hibernate Cache. Practice</a></li>
<li><a href="../136376/index.html">A Pakistani girl who became the youngest certified Microsoft specialist at 9 years of age died</a></li>
<li><a href="../136377/index.html">How-to: How to create a beautiful and functional banner rotator with Drupal 7 tools</a></li>
<li><a href="../136382/index.html">Where can I get a team for a startup?</a></li>
<li><a href="../136383/index.html">Visa certified BlackBerry Bold 9900, Curve 9360, Bold 9790 and Curve 9380 smartphones as mobile payment devices</a></li>
<li><a href="../136384/index.html">Corporate terrorism</a></li>
<li><a href="../136385/index.html">My coworking experience</a></li>
<li><a href="../136386/index.html">Review budget 7 "tablets: Kindle Fire, Nook Tablet, BB PlayBook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>