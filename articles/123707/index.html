<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of productive applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Performance Applications 

 The application for the Android platform will run on a mobile device with limited computational capabilities and memory, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of productive applications</h1><div class="post__text post__text-html js-mediator-article"><h4>  Performance Applications </h4><br><br>  The application for the Android platform will run on a mobile device with limited computational capabilities and memory, and with a short battery life.  So, the application must be effective.  Battery life is one of the reasons why you want to optimize your application, even if it runs fast enough.  The battery life is very important for users, and the Android platform will easily show the user if the application significantly reduces it. <br><br>  Despite the fact that micro-optimizations will be described here, they will almost never be able to damage your application.  Choosing the right algorithms and data structures should always be first priorities, but this aspect will not be considered. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Intro </h5><br>  There are only two basic rules for developing a productive code: <br><br><ul><li>  Do not do the work you do not need </li><li>  Do not allocate memory, which can not allocate </li></ul><br><h5>  Optimize wisely </h5><br>  We describe micro-optimizations for Android, so it is assumed that you have already used the profiler to determine which specific piece of code you need to optimize, and that you already know how to evaluate the effect of any changes you make.  You‚Äôve been developing a lot of time in development, so it‚Äôs important to know that you spend it wisely. <br><br>  It is also assumed that you have already chosen the best algorithms and data structures, and provided for the impact of your decisions regarding the API on performance.  Using the right data structures and algorithms improves performance much more than any of these tips, and carefully considering the impact of API on performance will ease the transition to a better implementation in the future (which is primarily important for library code than application code). <br><br>  One of the most cunning difficulties that you will encounter during the micro-optimization of an Android application will be that your application must work with a high probability on many different hardware platforms.  Different versions of the virtual machine on different processors operate at different speeds.  In general, this is not the case when you can just say ‚ÄúDevice X is n times faster / slower than device Y‚Äù and extrapolate the results to other devices.  In particular, testing on the emulator says almost nothing about performance on any device.  There is also a huge difference between devices with and without JIT: the ‚Äúbest‚Äù code for a device with JIT does not always remain the best for a device that is devoid of it. <br><br>  If you want to know how the application behaves on some device, then it will have to be tested on it. <br><br><h5>  Avoid creating unnecessary objects. </h5><br>  Creating objects is never free.  A garbage collector that works with generations and pools for temporary objects in each stream can make allocating memory easier, but allocating memory is always more expensive than not allocating it. <br><br>  If you select objects in a loop in the user interface, you force a periodic garbage collection, creating small ‚Äústutters‚Äù that are visible to the user.  The parallel garbage collector, which appeared in Gingerbread, can help with this, but unnecessary work should always be avoided. <br><br>  Thus, you should avoid creating objects that are not necessary.  Here are a couple of examples that can help with this: <br><br><ul><li>  If there is a method that returns a string and it is known that the result will always be added to the StringBuffer, change the implementation so that the method adds directly instead of creating a short-lived temporary object. </li><li>  When extracting a string from the input data set, try to return the substring of the initial data instead of creating a copy.  A new String object will be created, but the character array for it and the initial data will be shared.  (The compromise is that if only a small part of the initial input is used, it will still be stored in the memory as a whole if you follow this advice). </li></ul><br><br>  Take something more radical: dividing multidimensional arrays into one parallel one-dimensional array: <br><br><ul><li>  The int array is much better than the Integer array.  But we can summarize this fact: two parallel arrays of int are also much more efficient than arrays of objects (int, int).  The same applies to any combination of primitives. </li><li>  If you need to implement a container that contains pairs (Foo, Bar), remember that two parallel arrays of Foo [] and Bar [] in general are much better than one array (Foo, Bar) of objects.  (The exception is when you develop an API; for these cases, it is better to stick with a good API at a slight performance detriment. But you should try to be as efficient as possible in your own internal code.) </li></ul><br><br>  In general, avoid creating short-lived objects if possible.  A smaller number of objects created means that garbage collection occurs less frequently, which directly affects the interaction with the user. <br><br><h5>  Performance myths </h5><br>  Old versions of this manual contain various incorrect statements.  We turn to some of them. <br><br>  On non-JIT devices, calling methods on a specific class object is slightly faster than calling through an interface.  (Thus, it is cheaper to call HashMap methods instead of Map, even if it is the same object.) Not 2 times faster.  The real number is more close to 6%.  Moreover, with JIT, the difference is not noticeable at all. <br><br>  On devices without JIT, caching of calls to the class fields is 20% faster than a repeated call to the field itself.  With JIT, the cost of accessing a field is equal to the price of accessing a local address, so this optimization is not needed until it seems that it makes the code more readable.  (What is true about final, static and static final fields). <br><br><h5>  Prefer static to virtual </h5><br>  If there is no need to refer to the fields of the object, then the method can be made static.  The call will be 15-20% faster.  This is good also because it can be said from the signature that the method does not change the state of the object. <br><br><h5>  Avoid internal accessor methods </h5><br>  In native languages ‚Äã‚Äãsuch as C ++, it is good practice to use getters (eg i = getCount ()) instead of direct access (i = mCount).  This is a great habit for C ++, because the compiler can usually perform inline substitution and, if you need to restrict or debug field access, you can add the necessary code at any time. <br><br>  For Android, this is a bad idea.  Calling virtual methods is quite expensive - much more expensive than searching for object fields.  Of course, using common OOP practices and using getters and setters in the interface is reasonable, but inside the class you should always refer to the fields directly. <br><br>  Without JIT, direct access to the field is about 3 times faster than calling a regular getter.  With JIT, where direct access is equal to the speed of direct access to the local address, direct access will be approximately 7 times faster than calling the accessor method.  This statement is true already for Froyo, but in future releases the situation will improve due to the fact that JIT inlineit getters. <br><br><h5>  Use static final for constants. </h5><br>  Consider the following declaration at the beginning of the class: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intVal = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String strVal = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>;</code> </pre> <br><br>  The compiler generates a class initialization method, with the name that is executed when the class is first used.  The method assigns the value 42 to the variable intVal and extracts the reference from the table of unchangeable rows of the class file for strVal.  When these variables are accessed, the corresponding class fields will be searched. <br><br>  Here's how we can change this behavior with the ‚Äúfinal‚Äù keyword: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intVal = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String strVal = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>;</code> </pre><br><br>  No longer need a method, because the constants are written to static field initializers in the dex file.  Code that accesses intVal uses integer value 42 directly, and access to strVal will cause an inexpensive reference to a string constant instead of searching for a field.  (Note that this optimization only works for primitives and strings, and not for all arbitrary types of references. Despite this, constant static declarations should be used wherever possible.) <br><br><h5>  Using the improved For loop syntax </h5><br>  The for-each loop can be used for collections that implement the <code>Iterable</code> interface and arrays.  For collections, an iterator is allocated to call the hasNext () and next () methods.  For <code>ArrayList</code> classic loop with a counter is about 3 times faster (with or without JIT), but for other collections, the ‚Äúfor-each‚Äù syntax would be equivalent to explicitly using an iterator. <br><br>  There are several alternatives for traversing an array: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mSplat; } Foo[] mArray = ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mArray.length; ++i) { sum += mArray[i].mSplat; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; Foo[] localArray = mArray; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = localArray.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { sum += localArray[i].mSplat; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">two</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Foo a : mArray) { sum += a.mSplat; } }</code> </pre><br><br>  <b>zero ()</b> is the slowest method, because JIT cannot optimize the length of the array at each iteration step. <br><br>  <b>one ()</b> is faster.  It pulls the necessary information into local variables, avoiding the search field.  Only array.length here improves performance. <br><br>  <b>two () is</b> faster for devices without JIT and indistinguishable from one () for devices with JIT.  It uses the extended for syntax introduced in Java 1.5. <br><br>  Bottom line: use the for-each syntax by default, but think about manual iteration for performance-critical passes through <code>ArrayList</code> .  (See also <a href="http://java.sun.com/docs/books/effective/">Effective Java</a> , clause 46.) <br><br><h5>  Use package-private access instead of private for private inner classes. </h5><br>  Consider the following class definition: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doStuff(Foo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mValue); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Inner in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Inner(); mValue = <span class="hljs-number"><span class="hljs-number">27</span></span>; in.stuff(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"  "</span></span> + value); } }</code> </pre><br><br>  The most important thing to note is the definition of a private inner class (Foo $ Inner), which directly refers to the private method and the private field in the outer class.  The code is correct and displays "Value is 27", as expected. <br>  The problem here is that the virtual machine considers direct access to private members of Foo from the inner class as invalid, because Foo and Foo $ Inner are different classes, even though Java allows inner classes access to private members of the outer classes.  To overcome this gap, the compiler generates a pair of artificial methods: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*package*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Foo.access$<span class="hljs-number"><span class="hljs-number">100</span></span>(Foo foo) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.mValue; } <span class="hljs-comment"><span class="hljs-comment">/*package*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo.access$<span class="hljs-number"><span class="hljs-number">200</span></span>(Foo foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { foo.doStuff(value); }</code> </pre><br><br>  The inner class calls these static methods each time it needs to access the mValue or calls the doStuff () of the outer class.  This means that the code above turns into a case where access to class fields occurs through accessor methods.  We have already discussed the question of the slowness of such methods before direct access to fields, so it turns out that the specific idiom of the language results in an ‚Äúinvisible‚Äù degradation of performance. <br><br>  If a performance-critical piece of the application uses similar code, then you can avoid this behavior by declaring the fields and methods accessed from the inner class, package-private instead of private.  Unfortunately, this means that the fields will be accessible from other classes of the package, so this technique cannot be used in a public API. <br><br><h5>  Use floating point numbers wisely </h5><br>  In short, floating-point calculations are about 2 times slower than integers on Android devices.  This is true for G1 (without JIT and FPU) and Nexus One with FPU and JIT.  (Although of course, the absolute difference between these two devices in the speed of arithmetic operations is about 10 times). <br><br>  In terms of speed, there is no difference between float and double on more modern hardware.  From memory, double is 2 times more.  For desktops, without taking memory into account, double should be preferred over float. <br><br>  Also, some chips carry onboard integrated multiplication of integers, but do not have integrated integer division.  In such cases, integer division and modulo operations are performed at the software level.  Think about it if you are writing a hash table or doing a lot of math operations. <br><br><h5>  Know and use libraries </h5><br>  In addition to all the usual reasons for using library code instead of writing your own, keep in mind that the system can replace library code with assembly inserts that can be faster than the best code produced by the JIT compiler for the Java equivalent.  A typical example is <code>String.indexOf</code> and other methods that Dalvik replaces with internal code.  Because of this, <code>System.arraycopy</code> about 9 (!) Times faster than the manual cycle on the Nexus One with the existing JIT.  (See also <a href="http://java.sun.com/docs/books/effective/">Effective Java</a> , paragraph 47.) <br><br><h5>  Use native methods wisely </h5><br><br>  Native code is not necessarily more efficient than Java.  For one reason: there is a price for switching Java -&gt; native code, and JIT cannot do anything within these limits.  If you allocate native resources <br>  (heap memory, file handles, or anything else), then the complexity of collecting these resources in a timely manner increases noticeably.  You also have to compile the code for each architecture on which you plan to run it (instead of relying on JIT for this).  You can even build multiple versions for the same architecture: the native code compiled for an ARM processor in G1 cannot take full advantage of the same processor, but in Nexus One, and the code compiled for Nexus One simply won't run on G1. <br><br>  Native code is mainly useful if there is some native base that you want to port to Android, and not to speed up individual parts of a Java application.  (See also Effective Java, para. 54.) <br><br><h5>  At last </h5><br><br>  One last thing: always measure.  Before you start optimizing, make sure you have a problem.  Make sure that you can accurately measure the existing performance, otherwise you will not be able to measure the advantage obtained from alternative solutions. <br><br>  Every statement made here is backed by a test.  Source codes can be found at code.google.com, in the ‚Äúdalvik‚Äù project. <br><br>  These tests are written using Caliper micro-measurements framework.  Micromeasures are difficult to perform correctly, so Caliper helps to do the hard work for you, and even determines some cases where you measure things other than what you are trying to measure (for example, because the virtual machine has optimized all of your code).  We strongly recommend using Caliper to make your own micro measurements. <br><br>  You can also use Traceview for profiling, but it is important to understand that it now turns off the JIT, which leads to a large execution time that the JIT can play.  It is especially important, after making the changes proposed by Traceview, to make sure that the resulting code is actually executed faster when running without Traceview. </div><p>Source: <a href="https://habr.com/ru/post/123707/">https://habr.com/ru/post/123707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123700/index.html">Once again about ‚ÄúMercurial vs. Git‚Äù (with pictures)</a></li>
<li><a href="../123702/index.html">Virtual store in the Korean subway</a></li>
<li><a href="../123703/index.html">How to start a search engine, or a few thoughts about the crawler</a></li>
<li><a href="../123704/index.html">GTD. The most frequent problems in the use and solutions</a></li>
<li><a href="../123705/index.html">The e-commerce system nopCommerce is now on ASP.NET MVC 3</a></li>
<li><a href="../123711/index.html">Skype + FSB = ‚ô•</a></li>
<li><a href="../123712/index.html">PHP modification: its extension</a></li>
<li><a href="../123713/index.html">Nokia explains why major manufacturers have not created a "solar" mobile phone</a></li>
<li><a href="../123715/index.html">useful utility vmware boomerang</a></li>
<li><a href="../123717/index.html">Common words about a web search device</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>