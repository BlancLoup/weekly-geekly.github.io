<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskel - knight's move II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the second article I would like to continue the started topic and consider the task of finding a cyclic route when filling in NxN squares with a kn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskel - knight's move II</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dd/1e/59dd1eef20afc909367014.jpeg" alt="image"></div><br>  In the second article I would like to continue the <a href="https://geektimes.ru/post/293315/">started topic</a> and consider the task of finding a cyclic route when filling in NxN squares with a knight's move.  But in the comments to the first article suggested an interesting heuristics, for which many thanks to the commentators, and this hint is certainly worth considering in more detail.  The idea is known as the Varnsdorf rule and requires from the list of possible moves, first of all, choose a move with the least number of continuations. <a name="habracut"></a>  This allows not even at times, but by orders of magnitude to reduce the waiting time for the first decision.  In this case, an additional test for connectivity becomes redundant, its quadratic complexity only hinders and slows down the process. <br><br>  The basic recursion described in the previous article is easy to change to meet this rule, it is enough to sort the list of possible moves according to the required criterion. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knightsTo</span></span> x [] = [[x]] knightsTo x xs = [x:ks | k &lt;- ksort xs $ neighbours xs x, ks &lt;- knightsTo k $ delete k xs]</code> </pre> <br>  Finding free neighbors should be put into a separate function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">neighbours</span></span> xs x = filter (near x) xs <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> near (x1,y1) (x2,y2) = abs ((x2-x1)*(y2-y1)) == <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Things are <i>easy</i> , it remains to paint the sort function <i>ksort</i> , which orders the list of neighbors by the number of "neighbors of these neighbors."  Alternatively, it can be done so <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ksort</span></span> xs ns = map snd $ sort $ zip (map (length . neighbours xs) ns) ns</code> </pre><br>  For each neighbor in the <i>ns</i> list, we find a list of its possible moves and calculate its length.  We arrange the lengths in pairs with the coordinates of the neighbors.  The regular <i>sort</i> sorts by the first element, i.e.  in length, after which we discard the first elements of the pairs, leaving only the second ones. <br><br>  Somewhat ornate, but most importantly - the result.  What is there 10x10 - 50x50 in less than a minute!  And even 90x90, if you just wait.  Here is the result of 100x100 did not wait. <br><br>  By experimenting with intermediate sizes of squares, you can find out that the algorithm starts to stumble even earlier.  The first problematic square turns out to be 49x49, the second 60x60, then there are squares with sides 64, 76, 87, 89 and 98. But if you go around the square not from the lower left corner, but, say, from the opposite, then for squares with sides 49, 60 and 64 solutions are now found, but problems for other squares are emerging, starting from the size of 23x23.  The upper left corner allows you to find a route in the 76x76 square (and, by the way, 100x100), but problems are found in a square with a side of 32. <br><br>  Such selective fastidiousness is a little surprising and it seems illogical, but even this rule may have uncertainties when choosing a move.  Neighbors with the same minimum number of outcomes are also desirable to somehow streamline, perhaps these situations are critical.  But here, really, the more we find the answers, the more questions arise.  On this topic with arbitrary routes, I think you can close and go to closed routes. <br><br>  This task is considered more complex, and, indeed, the requirement to return to the initial cell seems to be difficult.  After all, when building a closed route, we must always leave a loophole for returning.  In other words, the starting cell must remain accessible from the current position at each step of construction.  But here it is worth remembering again about the connectivity check and the dropped function of <i>connected</i> .  Since the same requirement of connectedness now extends to the initial cell, as well as to unoccupied cells, you just need to add it to the general list with each call of the check function.  And the initial cell itself can be passed into recursion as another parameter. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knFromTo</span></span> x _ [] = [[x]] knFromTo xs xs = [x:ks | connected [x] (s:xs), k &lt;- ksort xs $ neighbours xs x, ks &lt;- knFromTo ks $ delete k xs]</code> </pre><br>  In an amicable way, to guarantee the result, in the base of the recursion it was also worth adding a check that the last occupied cell is connected to the initial move of the knight.  But, since any route is definitely completed in two moves to the end, for an even number of cells this check is not necessary, but for an odd number of closed routes it still does not exist, and for this variant the algorithm will try to close the path until the last move, and in the absence of the checkout simply fills the remaining cell. <br><br>  Slightly correct interface <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knight</span></span> n = head . knFromTo (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) $ tail [(x,y) | x &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.n], y &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.n]]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">And we are experimenting a little ...</b> <div class="spoiler_text"><pre> <code class="hljs css">*<span class="hljs-selector-tag"><span class="hljs-selector-tag">Main</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">knightC</span></span> 6 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[(1,1),(2,3),(1,5),(3,6),(5,5),(6,3),(5,1),(4,3),(3,1),(1,2),(2,4),(1,6),(3,5),(5,6),(6,4),(5,2),(4,4),(6,5),(4,6),(2,5),(1,3),(2,1),(3,3),(1,4),(2,2),(4,1),(6,2),(5,4),(6,6),(4,5),(2,6),(3,4),(4,2),(6,1),(5,3),(3,2)]</span></span></code> </pre><br><pre> <code class="hljs css">*<span class="hljs-selector-tag"><span class="hljs-selector-tag">Main</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">knightC</span></span> 7 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[(1,1),(2,3),(1,5),(2,7),(4,6),(6,7),(7,5),(5,6),(7,7),(6,5),(5,7),(7,6),(6,4),(7,2),(5,1),(6,3),(7,1),(5,2),(3,1),(1,2),(2,4),(1,6),(3,7),(2,5),(1,7),(3,6),(5,5),(4,3),(2,2),(1,4),(3,5),(4,7),(2,6),(3,4),(1,3),(2,1),(4,2),(6,1),(7,3),(5,4),(3,3),(4,1),(6,2),(7,4),(6,6),(4,5),(5,3),(3,2),(4,4)]</span></span></code> </pre><br><pre> <code class="hljs css">*<span class="hljs-selector-tag"><span class="hljs-selector-tag">Main</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">knightC</span></span> 8 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[(1,1),(2,3),(1,5),(2,7),(4,8),(6,7),(8,8),(7,6),(6,8),(8,7),(7,5),(8,3),(7,1),(5,2),(3,1),(1,2),(2,4),(1,6),(2,8),(3,6),(1,7),(3,8),(5,7),(7,8),(8,6),(7,4),(8,2),(6,1),(4,2),(2,1),(1,3),(2,5),(3,3),(1,4),(2,2),(4,1),(6,2),(8,1),(7,3),(5,4),(3,5),(4,3),(5,1),(6,3),(5,5),(4,7),(2,6),(1,8),(3,7),(4,5),(6,6),(5,8),(4,6),(3,4),(5,3),(7,2),(8,4),(6,5),(7,7),(8,5),(6,4),(5,6),(4,4),(3,2)]</span></span></code> </pre><br></div></div><br>  For even-sized squares (and odd ones are not interesting), the results are up to the size of 50x50, but the quadratic complexity of the additional check affects and the last result has to wait 40 minutes. <br><br>  By the way, it can be noted that it is not necessary to indicate the initial cell as the final goal.  You can specify any other one, and when building a route, the algorithm will diligently strive towards it.  To strive in the sense that after filling the entire area in the specified cell, you can move on to the next move.  This can be used when building chains, as already described in the previous article.  Only now, thanks to such a targeted search, the solution will be much faster.  It is only necessary to take into account the peculiarity of the knight's move and remember that for an even number of cells, the target position must have the same color of the chess coloring as the initial color, in other words, the parity of the sum of coordinates must match.  And for an odd number of cells, color and, accordingly, parity must alternate. <br><br><div class="spoiler">  <b class="spoiler_title">Some code and experiments ...</b> <div class="spoiler_text">  As in the previous article, we describe the function of filling with squares, this time of arbitrary size <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knightN</span></span> n ((m,l), st, fin) = head . knFromTo st fin $ delete st [(x,y) | x &lt;- [m..m+n<span class="hljs-number"><span class="hljs-number">-1</span></span>], y &lt;- [l..l+n<span class="hljs-number"><span class="hljs-number">-1</span></span>]]</code> </pre><br>  And apply it to the specified parameters <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knights10</span></span> = concatMap (knightN <span class="hljs-number"><span class="hljs-number">5</span></span>) [((<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>),(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>),(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)), ((<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>)), ((<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>),(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>))] knights4x26 = concatMap (knightN <span class="hljs-number"><span class="hljs-number">26</span></span>) [((<span class="hljs-number"><span class="hljs-number">1</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">26</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">27</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>)), ((<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">52</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>)), ((<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">52</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>),(<span class="hljs-number"><span class="hljs-number">26</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>))] knights16x13 = concatMap (knightN <span class="hljs-number"><span class="hljs-number">13</span></span>) [((<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>)), ((<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>)), ((<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>)), ((<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>)), ((<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>)), ((<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>)), ((<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">39</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>)), ((<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">39</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">26</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>)), ((<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">26</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">39</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">39</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">26</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>)), ((<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>)), ((<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>)), ((<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>),(<span class="hljs-number"><span class="hljs-number">27</span></span>,<span class="hljs-number"><span class="hljs-number">27</span></span>))]</code> </pre><br></div></div><br>  The 10x10 square by splitting into four 5x5 squares is now instantly filled.  For the problematic 52x52 square, filling a closed chain of four 26x26 squares fits into 5 minutes of waiting (and in the 50x50 square, as already mentioned, the cycle was searched for 40 minutes).  The splitting into 16 squares of 13x13 is cyclically filled at all in a half dozen seconds.  So for large sizes this method of filling with small areas may still be useful. <br><br>  But god with them, with big squares.  Finally, I would like to touch on another interesting problem and try to calculate the number of closed paths (or, what's too embarrassing, Hamiltonian cycles) in a particular graph figure.  At least, now it is possible to calculate the number of directed cycles, for which the interface function simply removes the call to <i>head</i> , after which the function will search not only the first but also all possible routes, and add a call to <i>length</i> to count their number.  Well, be patient. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">kNCircles</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> kNCircles mn = length . knFromTo (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) $ delete (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [(x,y) | x &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.m], y &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.n]]</code> </pre><br>  For an odd number of cells, as we have said, such cycles do not exist.  For rectangles with the length of one side in 4 cells, they also cannot be built, which is proved, for example, in the book by E. Gick ‚ÄúMathematics on a chessboard‚Äù.  The sizes 5x6 and 3x10 are the smallest among the permissible rectangles, and for each of them the program in a few minutes finds 16 and 32 variants, respectively.  The 3x12 rectangle contains 352 cyclic routes, 3x14 - 3 072, and for the 6x6 square of such cycles there are already 19,724 (with the directional unclosed routes, 524,486 are found from only one corner, who would have thought!), But the time to count is half a day already.  Exhibitor in all its glory.  Large areas and computations will require orders of magnitude more. <br><br>  In principle, to reduce brute force, you can also add a check for the absence of deadlocks to the main function.  All free cells, except perhaps the current and the final, must have at least two neighbors.  It is also possible to reduce the connectivity check to linear complexity, if the neighbors are found in constant time.  To do this, however, it is necessary to complicate the data structure, and, for example, go to the honest presentation of graphs in the form of a list of connections.  But, firstly, I would not want to get into the wilds, and, secondly, if you believe the estimate from <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2585%25D0%25BE%25D0%25B4%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%258F">Wikipedia</a> , there still is not enough to count the number of cycles in the 8x8 square of these optimizations.  Alas, the 13 trillion variants are not calculated by brute force. <br><br>  And for those who want to experiment the latest developments can be combined into one module. <br><br><div class="spoiler">  <b class="spoiler_title">knights.hs</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List(<span class="hljs-title"><span class="hljs-title">delete</span></span>, (\\), sort) type Cell = (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) type Pool = [Cell] type Track = [Cell] near :: Cell -&gt; Cell -&gt; Bool near (<span class="hljs-title"><span class="hljs-title">x1</span></span>,<span class="hljs-title"><span class="hljs-title">y1</span></span>) (<span class="hljs-title"><span class="hljs-title">x2</span></span>,<span class="hljs-title"><span class="hljs-title">y2</span></span>) = abs ((<span class="hljs-title"><span class="hljs-title">x2</span></span>-<span class="hljs-title"><span class="hljs-title">x1</span></span>)*(<span class="hljs-title"><span class="hljs-title">y2</span></span>-<span class="hljs-title"><span class="hljs-title">y1</span></span>)) == 2 neighbours :: Pool -&gt; Cell -&gt; Track neighbours xs x = filter (<span class="hljs-title"><span class="hljs-title">near</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) xs connected :: Track -&gt; Pool -&gt; Bool connected _ [] = True connected [] _ = False connected (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ws = let ns = neighbours ws x in connected (<span class="hljs-title"><span class="hljs-title">xs</span></span>++<span class="hljs-title"><span class="hljs-title">ns</span></span>) (<span class="hljs-title"><span class="hljs-title">ws</span></span>\\<span class="hljs-title"><span class="hljs-title">ns</span></span>) deadlocks :: Pool -&gt; Track deadlocks xs = map snd . filter ((&lt;2) . fst) $ zip (<span class="hljs-title"><span class="hljs-title">map</span></span> (<span class="hljs-title"><span class="hljs-title">length</span></span> . <span class="hljs-title"><span class="hljs-title">neighbours</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) xs) xs ksort :: Pool -&gt; Track -&gt; Track ksort xs ks = map snd . sort $ zip (<span class="hljs-title"><span class="hljs-title">map</span></span> (<span class="hljs-title"><span class="hljs-title">length</span></span> . <span class="hljs-title"><span class="hljs-title">neighbours</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) ks) ks knFromTo :: Cell -&gt; Cell -&gt; Pool -&gt; [Track] knFromTo x _ [] = [[x]] knFromTo xs xs = [x:ks | connected [x] $ s:xs, deadlocks (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">s</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) \\ [x,s] == [], k &lt;- ksort xs $ neighbours xs x, ks &lt;- knFromTo ks $ delete k xs] knightC :: Int -&gt; Track knightC n = head . knFromTo (1,1) (1,1) $ tail [(<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>) | x &lt;- [1..n], y &lt;- [1..n]] kNCircles :: Int -&gt; Int -&gt; Int kNCircles mn = length . knFromTo (1,1) (3,2) $ [(<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>) | x &lt;- [1..m], y &lt;- [1..n]] \\ [(1,1),(3,2)]</code> </pre><br>  PS Well, a much more productive option in the graph representation <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List(<span class="hljs-title"><span class="hljs-title">delete</span></span>, <span class="hljs-title"><span class="hljs-title">sortOn</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Map.Lazy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Environment (<span class="hljs-title"><span class="hljs-title">getArgs</span></span>) type Cell = (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) type Pool = M.Map Cell [Cell] kDel :: Cell -&gt; Pool -&gt; Pool kDel x xs = M.delete x $ foldr (<span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> (<span class="hljs-title"><span class="hljs-title">delete</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>)) xs (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">x</span></span>) connected :: [Cell] -&gt; Pool -&gt; Bool connected [] ws = null ws connected (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ws | M.member x ws = connected (<span class="hljs-title"><span class="hljs-title">ws</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">x</span></span> ++ <span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-title"><span class="hljs-title">delete</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">ws</span></span>) | otherwise = connected xs ws knFromTo :: [Cell] -&gt; Cell -&gt; Pool -&gt; [[Cell]] knFromTo nx s xs | M.size xs == 1 = [[s]] | otherwise = [k:ks | k &lt;- sortOn (<span class="hljs-title"><span class="hljs-title">length</span></span> . (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.!)) nx, k /= s, connected [k] xs, ks &lt;- knFromTo (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">k</span></span>) s (<span class="hljs-title"><span class="hljs-title">kDel</span></span> <span class="hljs-title"><span class="hljs-title">k</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>)] knightC :: Int -&gt; [Cell] knightC n = head $ knFromTo [(1,1)] (3,2) $ prepare $ (,) &lt;$&gt; [1..n] &lt;*&gt; [1..n] where prepare xs = M.fromList [(<span class="hljs-title"><span class="hljs-title">x</span></span>, <span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">near</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) xs) | x &lt;- xs] near (<span class="hljs-title"><span class="hljs-title">x1</span></span>,<span class="hljs-title"><span class="hljs-title">y1</span></span>) (<span class="hljs-title"><span class="hljs-title">x2</span></span>,<span class="hljs-title"><span class="hljs-title">y2</span></span>) = abs ((<span class="hljs-title"><span class="hljs-title">x2</span></span> - <span class="hljs-title"><span class="hljs-title">x1</span></span>) * (<span class="hljs-title"><span class="hljs-title">y2</span></span> - <span class="hljs-title"><span class="hljs-title">y1</span></span>)) == 2 main = do [n] &lt;- getArgs print $ knightC (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>)</code> </pre></div></div><br>  <a href="https://geektimes.ru/post/293315/">Start</a> <br>  <a href="https://geektimes.ru/post/295471/">Conclusion</a> </div><p>Source: <a href="https://habr.com/ru/post/357702/">https://habr.com/ru/post/357702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357692/index.html">Certificate Store in LibreOffice Office Suite</a></li>
<li><a href="../357694/index.html">Haskell - knight's move</a></li>
<li><a href="../357696/index.html">Parsing the site using T-SQL</a></li>
<li><a href="../357698/index.html">Documentation generator using built-in 1C: Enterprise 8.3.10 language</a></li>
<li><a href="../357700/index.html">External scripts with access to your credit cards and personal account</a></li>
<li><a href="../357704/index.html">How not to work with time zones or Aeroflot-Fail</a></li>
<li><a href="../357706/index.html">Haskell - knight's move 3. Conclusion</a></li>
<li><a href="../357710/index.html">The fate of the open source project after the death of the programmer</a></li>
<li><a href="../357712/index.html">Detective story with CMake 3.10 and Android Studio</a></li>
<li><a href="../357714/index.html">Semaphores, races, critical sections and Scratch. Plants vs. Zombies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>