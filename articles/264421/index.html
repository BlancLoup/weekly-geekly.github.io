<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Grinding CSS Animation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Creating CSS animations may look like a simple study of syntax, but to create a beautiful and intuitive animation requires certain subtleties. Since t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Grinding CSS Animation</h1><div class="post__text post__text-html js-mediator-article">  Creating CSS animations may look like a simple study of syntax, but to create a beautiful and intuitive animation requires certain subtleties.  Since the animation attracts a lot of attention, it is extremely important to put the code in order for the timing to work correctly and to debug everything that does not work correctly.  After I dealt with this problem myself, I decided to collect several tools that can help in this process. <br><br><h4>  Use negative delay values </h4><br>  Let's say you have several animations that run at the same time, and you need to build them in a checkerboard pattern.  You can use the animation delay, but you don‚Äôt want the user to wait while visiting the page until some immovable parts start. <br><a name="habracut"></a><br>  You can set a negative animation delay value, and this will move the playback cursor back in time, with the result that all animations will move when the user enters the page.  This option is suitable, in particular, when animations have the same keyframe values, and the difference in movement is only in the delay. <br><br>  This concept can also be used for debugging.  Set animation-play-state: paused ;, then set various negative delay values.  As you go, you will see <a href="http://codepen.io/team/css-tricks/pen/LVMMGZ">animation frames</a> in various pause states. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.thing</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: move <span class="hljs-number"><span class="hljs-number">2s</span></span> linear infinite alternate; <span class="hljs-attribute"><span class="hljs-attribute">animation-play-state</span></span>: paused; <span class="hljs-attribute"><span class="hljs-attribute">animation-delay</span></span>: -<span class="hljs-number"><span class="hljs-number">1s</span></span>; }</code> </pre> <br><br>  In this funny <a href="http://codepen.io/sdras/pen/qdLJLJ">demo,</a> we see two robots hovering with a different period of time to make it look more natural.  When describing the hang animation, let the purple robot get a negative delay so that when the user first sees the page, it will already move. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.teal</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: hover <span class="hljs-number"><span class="hljs-number">2s</span></span> ease-in-out infinite both; } <span class="hljs-selector-class"><span class="hljs-selector-class">.purple</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: hover <span class="hljs-number"><span class="hljs-number">2s</span></span> -<span class="hljs-number"><span class="hljs-number">0.5s</span></span> ease-in-out infinite both; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> hover { 50% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateY</span></span>(-4px); } }</code> </pre><br><br><h4>  Multiple Transformation Value Problems </h4><br><br>  For greater efficiency, some elements should also be moved and modified using the transform function, which will help you avoid the cost of redrawing with a field or shifting left / right, etc.  Paul Lewis has an excellent resource called <a href="http://csstriggers.com/">CSS Triggers</a> , in which such costs are presented in the form of a convenient table.  The pitfalls here are that if you try to move elements through multiple transformations, you will encounter a number of problems. <br><br>  The main problem is order.  Transformations will not be applied at the same time, as one would expect, and instead they will appear in the order of operations.  The first operation will be on the far right, and then in order.  For example, in the code below, the scaling will start first, then the transformation, and then the rotation. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> foo { <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* 3rd 2nd 1st */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(90deg) <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(30px) <span class="hljs-built_in"><span class="hljs-built_in">scale</span></span>(1.5); } }</code> </pre><br><br>  In most situations, this is not ideal.  Most likely, you need all this to happen in parallel.  Moreover, it becomes even more difficult if you begin to divide the transformations into several keyframes, in which some values ‚Äã‚Äãare used simultaneously and some not.  For example, in this way: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> foo { 30% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(360deg); } 65% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateY</span></span>(-30px) <span class="hljs-built_in"><span class="hljs-built_in">rotateY</span></span>(-360deg) <span class="hljs-built_in"><span class="hljs-built_in">scale</span></span>(1.5); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateY</span></span>(10px) <span class="hljs-built_in"><span class="hljs-built_in">scale</span></span>(0.75); } }</code> </pre><br><br>  This will lead to some surprising and not quite perfect <a href="http://codepen.io/sdras/pen/bdOvJL">results</a> .  The solution, unfortunately, is the use of several nested elements, with an application for each individual transformation, so that there are no conflicts. <br><br>  There are other alternatives, for example, using matrix transformations (which are not intuitive for manual code) or using the JavaScript animation API, for example, GreenSock, in which you cannot customize the order of multiple interpolations of transformations. <br><br>  Using multiple div elements can also help troubleshoot SVGs.  In Safari, you cannot set the transparency and transformation of the animation at the same time - one of the values ‚Äã‚Äãwill not work.  The workaround is shown in this article in the first demo. <br><br>  In early August 2015, the definitions of individual transformations entered Chrome Canary.  This means that we no longer need to worry about order.  The functions rotate, translate and scale can now be set separately. <br><br><h4>  Timekeeping Tools </h4><br>  Both Chrome and Firefox today provide several tools designed specifically for working with animation.  They offer a slider for speed control, a pause button, a user interface for working with smoothing values.  Reducing the speed of movement of elements and the consideration of animation at certain stopping points helps a lot in debugging CSS animations. <br><br>  Both tools use Lee Verow's cubicbebezier.com and GUI visualization.  This is pretty good, since you no longer have to jump back and forth from cubic-bezier.com to a text editor for verification. <br><br>  These tools allow us to customize the animation more intuitively.  Here‚Äôs what the user interface looks like: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/be0/01b/38c/be001b38cd4640b29053b3673d6f7e28.jpg" alt="img"></div><br><br>  Both Chrome and Firefox allow you to control timekeeping (speed up or slow down), as well as manually clean up animations.  More advanced time management tools will soon be introduced to Chrome and will be able to view multiple items at once.  This would be nice, since working with only one animation element at a time is a strong limiting factor. <br><br>  One of the problems I encountered is a quick capture of the element, if the animation is short and fast.  In such cases, I usually set animation-iteration-count: infinite; to be able to continuously play the animation without having to fight over time. <br><br>  I also consider it a great way to slow down the animation, and then re-play it and adjust the timing in the browser using these tools.  This allows you to break every movement at the initial level and see how everything interacts and how the movement itself looks.  If you configure everything at this speed, then you can set a high speed, and it will look more professional. <br><br><h4>  Debugging CSS Animation Events with JavaScript </h4><br>  If you want to determine exactly where and when each animation begins, you can use a bit of JavaScript to define and mark when each event occurs by connecting animationstart, animationiteration and animationend. <br><br>  <a href="http://codepen.io/sdras/pen/PqXeMX">Demo</a> <br><br><h4>  Keyframes must remain compact </h4><br>  I often see how people define the same property and value in a keyframe at 0% and in a keyframe at 100%.  It is not necessary to do this, and this may lead to more bloated code.  The browser will take the value of the properties as the original, and the final - by default. <br><br>  This is too much: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.element</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: animation-name <span class="hljs-number"><span class="hljs-number">2s</span></span> linear infinite; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> animation-name { 0% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(200px); } 50% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(350px); } 100% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(200px); } }</code> </pre><br><br>  It should look like this: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.element</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(200px); <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: animation-name <span class="hljs-number"><span class="hljs-number">2s</span></span> linear infinite; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> animation-name { 50% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(350px); } }</code> </pre><br><br><h4>  "Dry" animation </h4><br>  Creating a beautiful and capacious animation usually means writing a certain function of smoothness cubic-bezier ().  A well-tuned smoothness function works like a company palette.  You have a certain branding and ‚Äúvoice‚Äù in motion.  If you use them throughout the site (and you have to maintain everything in the same style), the easiest way to do this is to keep one or two smoothness functions in a variable, just like we do in palettes.  SASS and other pre / post processors make it pretty simple: <br><br><pre> <code class="css hljs">$<span class="hljs-selector-tag"><span class="hljs-selector-tag">smooth</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">cubic-bezier</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.17</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.67</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.48</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.28</span></span>); <span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: animation-name <span class="hljs-number"><span class="hljs-number">3s</span></span> $smooth; } <span class="hljs-selector-class"><span class="hljs-selector-class">.bar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: animation-name <span class="hljs-number"><span class="hljs-number">1s</span></span> $smooth; }</code> </pre><br>  When creating animations using CSS keyframes, we want as much help from the GPU as possible.  This means that if you are animating multiple objects, you need a way to easily prepare the DOM for the incoming movement and layered the element.  You can hardware speed up a native DOM element (not SVG) using CSS by using the standard description component.  Since we reuse it on all the elements that we animate, it makes sense to make a little description and additionally use impurities or inheritance: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">mixin</span></span> accelerate($name) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">will-change</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">name</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">transform</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">translateZ</span></span>(0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">backface-visibility</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">hidden</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">perspective</span></span>: 1000<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { @include accelerate(transform); }</code> </pre><br>  Be careful.  Unloading too many items at a time can have the opposite effect and slow performance.  Most animations should be detailed, but be careful if you use something like haml to generate a huge amount of DOM elements. <br><br><h4>  Cycles for better performance </h4><br>  On Smashing Magazine recently published a good <a href="http://www.smashingmagazine.com/2015/06/the-making-of-in-pieces/">article</a> , which was presented work on a fantastic project - Species in Pieces.  In one of the sections, the author describes in some detail how the animation of all the details at once led to performance problems.  He's writing: <br><br><blockquote>  Imagine that you are moving 30 objects at the same time;  you require too much from the browser, and it is logical that this can lead to problems.  If the speed of each object is 0.199 seconds and the delay is 0.2 seconds, the displacement of only one object at a time can solve the problem.  The fact that the same number of movements actually occurs does not matter: if the animation is performed along a chain, the performance immediately increases 30 times. </blockquote><br><br>  You can use for loops in Sass or other pre / post processors to create such functionality.  Here is a pretty simple version that I wrote to loop the nth-child child: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> $i from <span class="hljs-number"><span class="hljs-number">1</span></span> through $n { &amp;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:nth-child(</span></span>#{$i}) { <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: loadIn <span class="hljs-number"><span class="hljs-number">2s</span></span> #{$i*<span class="hljs-number"><span class="hljs-number">0.11</span></span>}<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">easeOutSine</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">forwards</span></span>; } }</code> </pre><br><br>  In addition, they can be used to place in a staggered manner such visual effects as color, etc. <br><br><h4>  Setting up multiple animations in a sequence </h4><br>  When creating longer animations, you can build a sequence of several animations or events by linking them in a chain with progressive delays.  For example: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">animation</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">foo</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">bar</span></span> 4<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">brainz</span></span> 6<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> 7<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>;</code> </pre><br>  But suppose you make certain changes and find that the second account of the first animation needs to be changed.  This will affect the delays of everything that goes after it, so you need to adjust the timing of each subsequent animation.  It is not difficult. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">animation</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">foo</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.5s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">bar</span></span> 4<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.5s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">brainz</span></span> 6<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> 6<span class="hljs-selector-class"><span class="hljs-selector-class">.5s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span>;</code> </pre><br>  And now let's add another animation and change the timing of the second one again (this configuration option almost always happens when creating really high-quality animation).  It gets a bit ineffective.  If you do this more than three times, it will be really ineffective. <br><br>  Now imagine that in the middle of the path two animation movements must start at the same time, so you need to adhere to uniform timing with two different properties and ... well, you understand.  Therefore, every time I line up three or four linked animations, I switch to JavaScript.  Personally, I like the GreenSock animation API, as it has very convenient time setting functionality, and most of the JS animations make it easy to build animation without recalculation, which definitely has a good effect on the workflow. <br><br>  Debugging animation work is more important than just building an animation.  As a rule, editing, improving and debugging turn a project into a well-organized and efficient thing.  I hope these tips will bring some new tools to your piggy bank and smooth out your workflow. <br><br><div class="spoiler">  <b class="spoiler_title">Paysto payment solutions for Habr readers:</b> <div class="spoiler_text">  ‚Üí <a href="http://linkcharge.ru/email">Get paid by credit card right now.</a>  <a href="http://linkcharge.ru/email">Without a site, PI and LLC.</a> <br>  ‚Üí <a href="http://linkcharge.ru/">Accept payments from companies via the Internet.</a>  <a href="http://linkcharge.ru/">Without a site, PI and LLC.</a> <br>  ‚Üí <a href="http://linkcharge.ru/api">Acceptance of payments from companies for your site.</a>  <a href="http://linkcharge.ru/api">With document circulation and exchange of originals.</a> <br>  ‚Üí <a href="http://linkcharge.ru/automat">Automation of sales and service transactions with legal entities.</a>  <a href="http://linkcharge.ru/automat">Without intermediary in the calculations.</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/264421/">https://habr.com/ru/post/264421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264409/index.html">Min-plus polynomials, cyclic games, and Hilbert's theorem on zeros</a></li>
<li><a href="../264411/index.html">The rhythm of the gameplay - why do we need a base</a></li>
<li><a href="../264415/index.html">Implementing web consoles in the jvm process using the SonarQube example</a></li>
<li><a href="../264417/index.html">Proper use of Exception in PHP</a></li>
<li><a href="../264419/index.html">Method of Lyapunov functions in the problem of the Janibekov effect</a></li>
<li><a href="../264423/index.html">Isomorphic Application with React and Redux</a></li>
<li><a href="../264425/index.html">CometQL - api of work from comets server using MySQL protocol</a></li>
<li><a href="../264427/index.html">Limited offer: a cloud server in the Netherlands and the United States at the price of hosting, cheaper ip-address</a></li>
<li><a href="../264429/index.html">Destroy everything</a></li>
<li><a href="../264431/index.html">Embarcadero Announces Purchase of Raize Components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>