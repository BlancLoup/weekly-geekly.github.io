<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I added support for Code Contracts for VS2015</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the past few weeks, I have been actively working on refining Code Contracts , fixing some nasty bugs and adding support for VS2015. And since VS201...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I added support for Code Contracts for VS2015</h1><div class="post__text post__text-html js-mediator-article">  In the past few weeks, I have been actively working on refining <a href="https://visualstudiogallery.msdn.microsoft.com/1ec7db13-3363-46c9-851f-1ce455f66970">Code Contracts</a> , fixing some nasty bugs and adding support for VS2015.  And since VS2015 just saw the light, such support would be very helpful.  Now about everything in order, and with a number of technical details. <br><br>  So the first thing to know about Code Contracts is that this thing is alive.  The code is publicly available on the githaba (https://github.com/Microsoft/CodeContracts) and there are a number of people who are actively involved in bringing order there.  I am the owner of the repository, but I do it in my free time.  In addition to me, there are a few other people who are cleaning up the Code Contracts Editor Extensions ( <a href="https://github.com/sharwell">@sharwell</a> ) and in some other areas. <br><br>  Code Contracts can be divided into several components: <br><ul><li>  ccrewrite is a tool that deals with ‚Äúrewriting‚Äù IL, removing statements (Contract.Requires / Ensures / Assert / Assume / if-throw) and replacing them with necessary calls to contract methods, depending on the configuration. </li><li>  cccheck is a tool that deals with static analysis and formal proof at compile time that the program is correct. </li><li>  Code Contracts Editor Extensions is an extension to VS that allows you to ‚Äúsee‚Äù contracts directly in the IDE. </li></ul><br>  There are a number of other things, for example, for generating documentation, as well as a <a href="https://github.com/SergeyTeplyakov/ReSharperContractExtensions">plugin for ReSharper</a> , which simplifies the addition of preconditions / postconditions and shows ccrewrite errors directly in the IDE. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I deal with two components - ccrewrite and a plugin, but now I want to focus on ccrewrite and on the difficulties that I face when adding support for VS2015. <br clear="all"><br><a name="habracut"></a><br><br><h3>  Breaking changes in VS2015 </h3><br>  The C # / VB compiler team did an amazing job developing new compilers from scratch.  They added a bunch of expansion points and now they don‚Äôt need a PhD to write a fairly functional analyzer for the studio.  But not without breaking changes. <br><br>  For normal operation, ccrewrite must clearly know how the C # / VB language compiler works, and what a particular code translates into.  Especially delivering blocks of iterators, asynchronous methods and closures, for which the C # / VB compilers do all sorts of different tricks.  It becomes especially sad when the behavior of the compilers begins to change and the generated code becomes somewhat different. <br><br>  The developers of the C # 6.0 compiler (aka Roslyn) introduced a number of optimizations to the generated IL code, which led to breakdowns of decompilers and ccrewrite. <br><br><h4>  Caching lambda expressions </h4><br><br>  You may have noticed strange static fields in the decompiled code that start with <b>CS $ &lt;&gt; 9__</b> .  These <s>souls are</s> caches of lambda expressions that do not capture the external context (lambda expressions that capture the external context lead to the generation of <a href="http://sergeyteplyakov.blogspot.com/2010/04/c.html">closures</a> , and classes of the form <b>&lt;&gt; c__DisplayClass1</b> are generated for them). <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Action action = () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello, lambda!"</span></span>); action(); }</code> </pre> <br><br>  In this case, the ‚Äúold‚Äù compiler will generate the CS $ &lt;&gt; 9__CachedAnonymousMethodDelegatef field and initialize it in a lazy way: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &lt;Foo&gt;b__e() { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello, lambda!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Action CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action(&lt;Foo&gt;b__e); } Action CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef = CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef; CS$&lt;&gt;<span class="hljs-number"><span class="hljs-number">9</span></span>__CachedAnonymousMethodDelegatef(); }</code> </pre><br><br>  The C # 6.0 compiler takes a different approach.  Experimental OS developers - <a href="https://ru.wikipedia.org/wiki/Midori_(%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0)">Midori</a> found out that invoking an instance method through a delegate is more efficient than invoking a static method.  Therefore, the Roslyn compiler for the same lambda expression generates other code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StaticClosure</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StaticClosure Instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticClosure(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Action CachedDelegate; <span class="hljs-comment"><span class="hljs-comment">//      internal void FooAnonymousMethodBody() { Console.WriteLine("Hello, lambda!"); } } static void Foo() { Action actionTmp; if ((actionTmp = StaticClosure.CachedDelegate) == null) { StaticClosure.CachedDelegate = new Action( StaticClosure.Instance.FooAnonymousMethodBody) actionTmp = StaticClosure.CachedDelegate; } Action action = actionTmp; action(); }</span></span></code> </pre><br><br>  Now a ‚Äúclosure‚Äù is created - the <b>StaticClosure</b> class (real name <b>&lt;&gt; c</b> ) with a static field for storing the delegate - <b>CachedDelegate</b> ( <b>&lt;&gt; 9__8_0</b> ) and a ‚Äúsingleton‚Äù.  But now, the body of the anonymous method is in the instance method <b>FooAnonymousMethodBody</b> ( <b>&lt;Foo&gt; b__8_0</b> ). <br><br>  A simple test showed that calling the delegate through an instance method is indeed 10 percent faster, although in absolute units the difference is very, very small. <br><br>  Now let's see when this change leads to problems in ccrewrite. <br>  Assertions in Code Contracts are defined as calls to the <b>Contract</b> class methods, which somewhat complicates the assignment of contracts for interfaces and abstract classes.  To circumvent this limitation, you need to create a special contract class marked with the <b>ContractClassFor</b> attribute.  But this causes a number of additional difficulties. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ContractClass(typeof (IFooContract))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFoo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span>; } [ExcludeFromCodeCoverage,ContractClassFor(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IFoo))] <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IFooContract</span></span> : <span class="hljs-title"><span class="hljs-title">IFoo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IFoo.Boo(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data) { Contract.Requires(Contract.ForAll(data, n =&gt; n == <span class="hljs-number"><span class="hljs-number">42</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> : <span class="hljs-title"><span class="hljs-title">IFoo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Foo.Boo was called!"</span></span>); } }</code> </pre><br><br>  In this case, the <b>Foo.Boo</b> method contains no preconditions at all, and ccrewrite must first find the contract class ( <b>IFooContracts</b> ), ‚Äútear out‚Äù the contract from the <b>IFooContracts.Boo</b> method and transfer it to the <b>Foo.Boo</b> method.  In the case of simple preconditions, it is not difficult to do this, but with closures, everything becomes more interesting. <br><br>  Now, you need to find the internal <b>IFooContracts. &lt;&gt; C</b> class, copy it to the <b>Foo</b> class, copy the <b>Contract.Requires</b> call from the <b>IFooContracts.Foo</b> method and update IL so that it works with the new copy, and not with the original closure.  In some cases, everything is even more fun: the presence of nested closures (several scopes, each of which has an exciting anonymous method) will require updating the nested classes in the correct order - from the most nested to the topmost one (that <a href="">is why this logic is located here</a> ). <br><br><h4>  Asynchronous method with two awaits </h4><br><br>  Another change in the new compiler is related to the generated code for asynchronous methods.  The old compiler generated different code for the asynchronous method with one <b>await</b> operator and several <b>await</b> operators.  The new compiler has a new optimization for asynchronous methods with two <b>awaits</b> , which also caused a lot of trouble. <br><br>  Let's consider the following simple example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { Contract.Ensures(str != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br><br>  The C # compiler (pre-Roslyn) converts this code as follows: <br><br><ol><li>  A structure is created that implements <b>I</b> <b>AsyncStateMachine</b> and the entire logic of the method moves to the <b>MoveNext</b> method. </li><li>  In the <b>FooAsync</b> method, the ‚Äú <b>front</b> ‚Äù logic remained: creating an instance of <b>AsyncTaskMethodBuilder</b> and initializing an instance of the state machine. </li></ol><br>  Here is what the generated code looks like: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FooAsync_StatemMachine : IAsyncStateMachine { <span class="hljs-comment"><span class="hljs-comment">//   FooAsync(string str) public string str; //    public int l__state; //      . //   TaskCompletionSource. public AsyncTaskMethodBuilder&lt;int&gt; t__builder; // ""    private TaskAwaiter u__taskAwaiter; public void MoveNext() { int num = this.l__state; int result; try { TaskAwaiter taskAwaiter = default(TaskAwaiter); if (num != 0) { //   //      Contract.Requires(this.str != null); taskAwaiter = Task.Delay(42).GetAwaiter(); //  :     //      "":  , //      if (!taskAwaiter.IsCompleted) { // l__state  0 ,    //     . this.l__state = 0; //  this AsyncTaskBuilder-,    //   ,      // t__bulder.AwaitUnsafeOnCompleted(..., this); return; } } //       ,  //   ,  . //  GetResult    ,  //     taskAwaiter.GetResult(); //    result = 42; } catch (Exception exception) { //     this.l__state = -2; this.t__builder.SetException(exception); return; } //    this.l__state = -2; this.t__builder.SetResult(result); } } public Task&lt;int&gt; FooAsync(string str) { var stateMachine = new FooAsync_StatemMachine { l__state = -1, t__builder = AsyncTaskMethodBuilder&lt;int&gt;.Create(), str = str, }; stateMachine.t__builder.Start(ref stateMachine); return stateMachine.t__builder.Task; }</span></span></code> </pre><br><br>  There are quite a few letters, but the basic idea is this: <br><br><ol><li>  The precondition of the asynchronous method is inside the state machine.  That is why ccrewrite should pull it out and transfer it to the <b>FooAsync</b> method.  Otherwise, violation of the precondition will lead to the faulted task, and not to a ‚Äúsynchronous exception‚Äù. </li><li>  There is a certain pattern as ccrewrite determines where the precondition is located.  In the case of an asynchronous method with a single <b>await</b> operator, the original beginning of the method, and therefore the preconditions are immediately inside the <b>if (num! = 0)</b> condition.  It is important! </li><li>  The generated code depends on the number of <b>await</b> statements within the asynchronous method.  With two or more <b>await</b> statements, the old compiler generates a finite state machine based on a switch, and ccrewrite handled this pattern correctly. </li></ol><br>  The C # 6.0 compiler generates the same code for the asynchronous method with one await, but a completely different code if there are two awaits. <br><br>  <b>NOTE</b> <br>  Another change to the C # 6.0 compiler: in Debug mode, the state machine generates a class, not a structure.  This is done to support Edit and Continue. <br><br>  If the <b>fooAsync</b> method change as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooAsyncOrig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { Contract.Ensures(str != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">43</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br><br>  That C # 6.0 compiler, instead of generating a switch that is understandable to any decompiler and ccrewrite, will generate code that is very similar to code with one <b>await</b> operator, but with minor modifications: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   MoveNext if (num != 0) { // ccrewrite ,    ! if (num == 1) { taskAwaiter = this.u__taskAwaiter; this.u__taskAwaiter = default(TaskAwaiter); this.l__state = -1; goto OperationCompleted; } //    ! Contract.Requires(this.str != null); taskAwaiter = Task.Delay(42).GetAwaiter();</span></span></code> </pre><br><br>  Since this is a new pattern, ccrewrite naively searched for contracts right inside the <b>if</b> condition <b>(num! = 0)</b> and considered the nested if statement as preconditions / postconditions.  I had to teach him new tricks to handle this option correctly. <br><br><h3>  As a conclusion </h3><br><br>  Work at the IL-level is walking on thin ice.  The search for patterns is rather complicated, the modification of the IL code is not intuitive, and even a simple task, like checking the postconditions in asynchronous methods, may require a lot of effort.  In addition, many things are implementation details of the compiler and can vary from version to version.  Here we have reviewed only a few examples, but this is not all the changes from the C # 6.0 compiler.  At least <a href="https://github.com/Microsoft/CodeContracts/issues/133">, the IL code</a> generated by using expression trees <a href="https://github.com/Microsoft/CodeContracts/issues/133">has changed a</a> little, which also broke several test cases. <br><br>  There are still a couple of nasty bugs that are being worked on.  There is a problem with the <a href="https://github.com/Microsoft/CodeContracts/issues/137">Error List in VS2015</a> , and the <a href="https://github.com/Microsoft/CodeContracts/milestones/Async%2520Features">postconditions in asynchronous methods</a> apparently never worked normally.  But, most importantly, the project is alive and, most likely, will be developed.  So if you have any wishes, especially in the field of ccrewrite, write about it or get bugs on <a href="https://github.com/Microsoft/">github</a> ! <br><br><h3>  Links </h3><br><ol><li>  <a href="https://github.com/Microsoft/CodeContracts">Code Contracts</a> on GitHub </li><li>  <a href="https://github.com/SergeyTeplyakov/ReSharperContractExtensions">Code Contracts Editor Extensions</a> on githab </li><li>  <a href="">Latest release</a> on github </li><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/1ec7db13-3363-46c9-851f-1ce455f66970">Code Contracts at Visual Studio Gallery</a> </li><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/02de7066-b6ca-42b3-8b3c-2562c7fa024f">Code Contracts Editor Extensions in Visual Studio Gallery</a> </li><li>  <a href="http://sergeyteplyakov.blogspot.com/2013/10/articles.html">Series of articles on contract programming in .NET</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/263235/">https://habr.com/ru/post/263235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263225/index.html">PostgreSQL 9.3 + Pgpool-II</a></li>
<li><a href="../263227/index.html">Translation Announcements</a></li>
<li><a href="../263229/index.html">Algorithms of Mind</a></li>
<li><a href="../263231/index.html">Two reasons to install Veeam Endpoint Backup FREE now</a></li>
<li><a href="../263233/index.html">Actor Open Messaging Platform from Telegram developer</a></li>
<li><a href="../263237/index.html">Hacking Team exploit box replenished with one more copy</a></li>
<li><a href="../263239/index.html">PhpStorm: Tips and tricks. Part 1</a></li>
<li><a href="../263241/index.html">What's New in Visual Studio 2015 for JS Developers</a></li>
<li><a href="../263257/index.html">New tab engine for cloud IDE</a></li>
<li><a href="../263259/index.html">AI for "Fool"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>