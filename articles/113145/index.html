<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java Logging: A Nightmare Story</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 The path of the Java platform to the correct way to write lines to log files is stubborn and tortuous. The history of logging in Java i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java Logging: A Nightmare Story</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  The path of the Java platform to the correct way to write lines to log files is stubborn and tortuous.  The history of logging in Java is quite informative in terms of exploring the features of Open Source, including its interaction with corporations and individual programmers.  I am going to tell as much as possible about the history of Java logging, as well as about what it all came to and how to live. <a name="habracut"></a>  My analysis of the situation will be quite subjective about the reason that logging is always a matter of taste, and my tastes have been formed by my adults.  I think that this will not be informative in terms of some technical features of the entire zoo logging frameworks, but in terms of the policy and psychology of the developers in the Open Source model. <br><br><h2>  Start </h2><br>  It is clear that any logging library should allow at least to print a string to the console / log file. <br><br>  In the beginning was, of course, <code>System.err.println</code> .  In addition, the first version of the Servlet API consisted of a <code>log</code> function (though, rather primitive). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the more advanced solutions in 1999 was the Avalon project (and the subprojects called Excalibur and Fortress), which in addition to DI services offered the LogEnabled interface.  The component that LogEnabled declared itself was injected (I use this word instead of ‚Äúinjected‚Äù to emphasize its connection with DI) an object of type Logger, where you could write: a) lines b) exceptions.  This approach at that time seemed fresh and innovative, but from a modern point of view it is pure idiocy and over-engineering.  There is no point in using DI for logging, and a static instance of this Logger itself would be fine for everyone.  In Avalon, I had to think about where this damned Logger should be saved and what to do if the class does not use DI (that is, it is not controlled by the container), but I really want to log in it. <br><br>  Around 1999, a new generation library appeared - log4j.  The library's prototype was developed by IBM (back in the era when the blue giant tried to squeeze Java into OS / 2), then ASF picked up the baton.  The product was already much more thoughtful and run-in on real needs.  In general, it must be said that by that time server applications in Java were only about a year old, and logging was always required on the server.  During this time, the Java community began to gradually understand what they needed and how. <br><br>  log4j divided the concept of a logger or <em>category</em> (i.e., the application area that wants to write to the log), the actual entries in the log, which are carried out by the so-called <em>appenders</em> , and the formatting of records ( <em>layout</em> ).  The log4j configuration determines which appenders are attached to which categories and which <em>log level</em> messages fall into each appender. <br><br>  The cornerstone of log4j is the hierarchy of categories.  For example, you can log all messages from <code>org.hibernate</code> and mute everything from <code>org.hibernate.type</code> .  After some time, the de facto established practice of matching the hierarchy of categories and hierarchy of packages in an application. <br><br>  The hierarchy of categories allows you to effectively cut off unnecessary messages, so log4j worked extremely fast.  By the way, the principal for loggers is not so much the recording speed, as the filtering speed is unnecessary (and unnecessary, usually more than 90%) and formatting. <br><br>  The principles laid down in log4j were rather well ported to other languages: log4cxx, log4net (and the new cub - log4php).  The standard logging package in Python 2.x is a redesigned log4j (with a small addition of other libraries). <br><br>  So, we summarize.  A successful architecture, clear configuration scheme, the principle of <a href="http://logging.apache.org/log4j/1.2/faq.html">fail-safe</a> - why not include such a wonderful library in the platform? <br><br><h2>  Java Logging API </h2><br>  In fact, everything turned out strange.  IBM, in the depths of which log4j arose, turned out to be quite brisk in questions of forming a new JSR47 (Java Logging API).  In particular, the friend responsible for JSR47, Graham Hamilton, decided <em>not</em> to base <em>log4j</em> , but the <em>original IBM logging toolkit</em> .  Moreover, the logging toolkit was used to its fullest: not only the names of all the main classes coincided, but also their implementations;  The code was tried to finish as little as possible, apparently, in time for the next release of the platform.  However, conceptually it was very similar to log4j, only instead of appenders it was called handlers, and instead of layout there was a formatter. <br><br>  Since the main purpose of JSR47 is to determine the <strong>API, and not the implementation</strong> , there were only 4 output tools (by default in the platform) (in log4j more than 10), and the formatting tools were so poor that almost immediately I had to make my own formatters, because not enough.  JSR47 offered to use the configuration in the form of <code>.properties</code> , and it was noted in brackets that not all can be described in the file.  Thus, with the complexity of the configuration, the programmer unexpectedly discovered that it was again necessary to write code, since  in the form of <code>.properties</code> its configuration is not realizable. <br><br>  This is not to say that JSR47 is losing performance.  In some places, he overtook log4j by keeping in memory a special representation of his configuration (which, by the way, at the same time complicated this very configuration).  However, as it turned out, JSR47 compulsorily collected the so-called Caller Information, that is, "from where this message is logged."  Getting Caller Information is quite an expensive operation, it proceeds using Native-code.  Experienced uncles from log4j knew this, therefore they provided this opportunity with the proviso ‚Äúdon't turn it on‚Äù. <br><br>  The developers of log4j made an open <a href="http://www.ingrid.org/jajakarta/log4j/jakarta-log4j-1.1.3/docs/critique.html">petition</a> , where they demanded to ‚Äúremove JSR47 from the conveyor‚Äù, while it was not yet part of the platform.  The petition was signed by more than 100 people ... However, it was too late.  The next JDK release was approved and the platform rushed into the future with a rudimentary <code>java.util.logging</code> , or abbreviated as JUL.  The new logging was so underdeveloped and inconvenient that it was decided to use it only in a few application servers (among them Resin and Jetty).  Sun, however, responded to the petition and most of the major problems with the original JSR47 were gradually resolved.  Nevertheless, these manipulations were more like the installation of props to a wooden bridge, which by no means make this bridge reinforced.  The developers of log4j made a <a href="http://svn.apache.org/repos/asf/logging/log4j/tags/v_1_2beta3/docs/lobby.html">nod</a> toward the Sun, noting, however, that the degree of curvature of JUL is still quite high.  In addition, the JDK 1.4 license <strong>did not allow</strong> using log4j as a JUL implementation.  The last train for log4j is gone. <br><br>  Not being able to support a large number of log writers (i.e. handlers), JUL showed up by identifying an incredible number of logging levels.  For example, for debug messages, there were already 3 levels - FINE, FINER and FINEST.  Seeing all this, the developers often did not understand at all which of the three levels, damn it, should be used. <br><br>  The Java community was completely disoriented by the emergence of ‚Äústandard‚Äù logging in parallel with the popular, stable and evolving log4j.  No one understood which of them was a tenant.  There were often situations when several libraries were assembled in the project, each of which used its own logging and its own settings, recording its log files completely at odds with each other. <br><br>  Of course, the community tried to fix this problem.  <strong>Wrapping epidemic began</strong> .  Or, I would even say, a pandemic. <br><br><h2>  Wrapper hell </h2><br>  When you connect several libraries and try to connect their logs into one unit (and the code cannot be modified), it will be called Adapter.  Adapters were written from JUL to log4j and vice versa.  Unfortunately, adapters in terms of functionality are ‚Äúthe least common multiple‚Äù.  Even when context support (NDC and MDC) appeared in log4j, it was lost during the transfusion into JUL.  Worse, JUL only worked since JDK 1.4, while an incredible amount of enterprise applications still sat on 1.3.  As a result, the community became obsessed with the idea of ‚Äã‚Äãcreating a ‚Äúcommon de facto standard‚Äù that everyone would use together and who worked always and everywhere. <br><br>  Around 2002, a project called commons-logging (JCL = Jakarta Commons Logging) emerged from the Jakarta group.  In fact, it was a wrapper around all the logging tools available at the time.  It was suggested to write applications in such a way that they addressed the wrapper (interface called <code>Log</code> ), which selected the ‚Äúsuitable‚Äù logging system and connected to it itself.  The wrapper was poorly functional and did not add any additions to the existing means of logging. <br><br>  How was the appropriate logging system <em>automatically</em> selected?  But this is the most interesting.  First, you could explicitly set it by placing a special <code>commons-logging.properties</code> file somewhere in CLASSPATH.  Secondly, through the system property (which, obviously, no one will do).  Thirdly, if log4j was found somewhere in CLASSPATH, it was automatically activated.  The implementations of all other libraries were sought by the same method, the first one was always connected. <br><br>  Handsomely!  Well, that <em>would be</em> nice if all the software in the world would use commons-logging.  Then you could easily assemble JARs, put them into the application server, and there JCL will pick up the logging of this application server and voila! <br><br>  In fact, as it turned out, a bunch of software usually uses ‚Äúthe favorite logging of its developer‚Äù.  This means that a completely arbitrary library can, in the form of a dependency, pull up, for example, log4j, which thus falls into CLASSPATH and suddenly switches JCL to use log4j.  Even worse with <code>commons-logging.properties</code> .  If any figure thought of pushing it into his JAR, then when you connect this JAR, you understand, write it was gone.  The situation was particularly piqued by the fact that it was completely incomprehensible from which JAR it came from.  Sometimes it helped to enumerate all JARs in alphabetical order.  Sometimes a tambourine. <br><br>  The complete unpredictability of the choice of logging turned out to be the main and very fun feature of JCL.  The log4j group broke out with an angry <a href="http://articles.qos.ch/thinkAgain.html">Think again</a> article <a href="http://articles.qos.ch/thinkAgain.html">before adopting the commons-logging API</a> , where it offered to stop the epidemic and focus on refining the existing solution - log4j. <br><br>  Unfortunately, it was too late.  From the submission of Jakarta to commons-logging, hundreds and then thousands of libraries were translated.  Among them were Hibernate, Spring, Tomcat.  After that, numerous users of these libraries were overwhelmed by a wave of problems, generally described as <strong>ClassLoader hell</strong> .  Application servers use a rather complex hierarchy of ClassLoaders, often with serious deviations from the J2EE standard.  Under these conditions <em>, the</em> JCL is <em>sometimes</em> initialized twice, and incorrectly, leading to a completely mystical stack traces, which do not even allow one to suspect that the problem is in the log wrapper. <br><br>  Why, strictly speaking, Open Source worked in such a strange way, giving birth to this perversion?  Why the developers did not decide to just take and use another mature and popular Open Source product - log4j?  The point here is perhaps in some inertia of the community, accustomed to be led by either ASF (and the Jakarta group that gave rise to this nightmare has a part of ASF), or Sun.  As soon as a critical mass of projects using JCL is formed, all the rest (and not the most stupid people, don't they, Gavin King?) Start using JCL (for Apache is cool!).  This is generally reminiscent of the Brownian movement, where brands such as Apache or Sun are capable of creating low pressure areas where millions of developers rush.  In the case of the JCL, the ‚Äúsuccess story‚Äù is described in the <a href="http://radio-weblogs.com/0122027/2003/08/15.html">blog of Rod Waldhoff</a> (one of the developers of the so-called Jakarta Commons) in 2003. <br><br><h2>  New round of progress </h2><br>  So, somewhere in 2004 we have in the set: <br><ol><li>  Stable and functionally developed log4j </li><li>  Dull java.util.logging </li><li>  Problem commons-logging </li><li>  Several small loggers unworthy of mention </li></ol><br>  Note that in the draft log4j at this time conservative moods prevailed.  Particular attention was paid to the issue of compatibility with the old JDK.  It seems that the development of the new log4j branch - 1.3.x. begins.  This version is a kind of compromise solution: yes, I want a new functionality, yes, I want to maintain backward compatibility, yes, we will try to please both ours and yours.  Meanwhile, JDK 1.5 is on its way with varargs, JMX extensions and a bunch of other gifts.  In the team log4j began the fermentation of minds.  The 2.x branch is budded - incompatible with the main 1.2.x branch and created specifically for JDK 1.5.  The Java community is impatient.  It seems to be happening as <em>something</em> .  But what exactly is impossible to understand - log4j 2.0 still remains an unattainable alpha, log4j 1.3 is wildly buggy and does not provide the promised drop-in compatibility.  And only branch 1.2 is still stable and alive and well, jumping <em>over several years</em> - attention!  - from version 1.2.6 to 1.2.12. <br><br>  Somewhere in 2006, one of the founding fathers of log4j, Ceki G√ºlc√º, decides to leave the rapidly dying team.  This is how the next ‚Äúwrapper of everything‚Äù called SLF4J (Simple Logging Facade for Java) is born.  Now it wraps around: log4j, jul, commons-logging and a new logger called logback.  As you can see, progress quickly reached the ‚Äúwrapper around the wrapper‚Äù stage.  <i>It is easy to predict that according to the same scheme, the number of libraries to be wrapped will grow as a factorial.</i>  However, SLF4J offers other other quirks.  These are special binary adapters: from log4j to SLF4J, from commons-logging to SLF4J, and the like.  Such adapters are made for the code whose source is not available;  at the same time, they should replace the original JARs of the log libraries.  I can not imagine what kind of porridge is formed, but if you really want, then you can. <br><br>  With all my hatred of wrappers, hand on heart, SLF4J is a well-made product.  Were taken into account all the shortcomings of the predecessors.  For example, instead of shaman dancing with the search for classes in CLASSPATH a more reliable scheme was invented.  Now the whole wrapper is divided into two parts - API (which is used by applications) and the Implementation, which is represented by separate JAR files for each type of logging (for example, <code>slf4j-log4j12.jar</code> , <code>slf4j-jdk14.jar</code> , etc.).  Now you just need to connect the necessary Realization file to the project, after which - oops!  all project code and all used libraries (provided that they access the SLF4J API) will log in the right direction. <br><br>  Functionally, the SLF4J supported all modern NDC and MDC freaks.  In addition to actually wrapping calls, SLF4J offered a small but useful bonus when formatting strings.  The bonus is here next.  In the code it is often necessary to print constructions of the form: <br><br><pre> <code class="java hljs">log.debug(<span class="hljs-string"><span class="hljs-string">"User "</span></span> + user + <span class="hljs-string"><span class="hljs-string">" connected from "</span></span> + request.getRemoteAddr());</code> </pre><br>  In addition to printing the string itself, the <code>user.toString()</code> conversion will be implicitly followed by string concatenation.  All anything.  In the debug mode, the speed of execution doesn‚Äôt worry us much.  However, even if we set the level, say, to INFO, it turns out that the construction of the string will still occur!  No miracles: the string is constructed <em>before</em> calling <code>log.debug</code> , so <code>log.debug</code> has no way to control this.  If you imagine that this <code>log.debug</code> located in some critical internal loop ... well, you can't live like this.  The log4j developers suggested to frame the debugging code like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (log.isDebugEnabled()) { log.debug(<span class="hljs-string"><span class="hljs-string">"User "</span></span> + user + <span class="hljs-string"><span class="hljs-string">" connected from "</span></span> + request.getRemoteAddr()); }</code> </pre><br>  Not good at it.  In theory, all these problems should be taken up by the logging library itself.  This problem has become just the Achilles heel of log4j.  The developers reacted sluggishly to kicks, telling that now you can add an object to logging calls (exactly one!) And describe how this object will be logged using the <code>ObjectRenderer</code> interface.  By and large, all this was excuses and half measures. <br><br>  SLF4J was not squeezed within the framework of compatibility with older versions of the JDK and API, so the move offered a more elegant solution: <br><pre> <code class="java hljs"> log.debug(<span class="hljs-string"><span class="hljs-string">"User {} connected from {}"</span></span>, user, request.getRemoteAddr());</code> </pre><br>  In general, everything is simple.  In this line, <code>{}</code> are references to parameters that are passed separately.  Conversion of parameters to the string and final formatting of the log record occurs <em>only</em> when DEBUG level is set.  Parameters can pass a lot.  Works!  Do not write framing <code>if</code> and other stupidity! <br><br>  In brackets, it should be noted that this possibility was also completely unexpectedly implemented by the Groovy language, where there is a GString concept, i.e  view string <pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"User </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${user}</span></span></span><span class="hljs-string"> connected from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${request.getRemoteAddr()}</span></span></span><span class="hljs-string">"</span></span></code> </pre>  which is implicitly associated with several context variables (here it is <code>user</code> , <code>request</code> ), with the string being calculated in a <em>lazy way</em> .  This is very convenient for such log libraries as log4j - you can get a GString as input, and then either throw it away without a calculation, or convert it to a normal (static) string, String. <br><br>  In short, the SLF4J was done right, with the future in mind.  This led to a serious increase in its popularity among the community: now, SLF4J are using such significant projects as Jetty, Hibernate, Mina, Geronimo, Mule, Wicket, Nexus ... well, almost all the losers who had hanged on commons-logging at one time switched to SLF4J .  Interestingly, what prevented the improvement of commons-logging to the desired state many years ago?  But these are the realities of Open Source - the development of software in it is more revolutionary than evolution. <br><br>  At the same time with SLF4J, a completely new logger was submitted to the table - Logback.  It was made by a man who ate a dog at logging, and in fact turned out to be a good product.  Logback was originally sharpened by JDK 1.5+, having at one stroke got rid of all the backward-compatibility senile diseases inherent in the log4j project.  And that means - varargs, <code>java.util.concurrent</code> and <a href="http://logback.qos.ch/reasonsToSwitch.html">other delights</a> .  For example, due to the built-in runtime filtering system, you can change the logging level depending on the user session, scatter users in different log files, and so on. <br><br>  I'll put the mustard into the idyll drawn by the author.  Most of these features can be implemented as additional appenders to log4j.  It is necessary to bend and file the configuration, it is more difficult, but it is a fact that it is not necessary to switch to this for a new logger.  Thus, all advertised Logback chips are convenient, but not unique. <br><br>  As for the community, it is with caution to the Logback.  First, in a few years he got to version 0.9.x, and that scares some programmers.  Secondly, the Logback is neither under the Apache umbrella, nor in the scope of the Sun.  It confuses people scrupulous.  Third, the author needs to eat, so for some add-ons to the Logback and support, it requires money.  This sometimes scares off students.  Among other things, Logback has a rather complicated dual license (LGPL / EPL), while log4j is a universal Apache license.  For libraries and generally redistributable software, licensing is a very subtle point. <br><br>   , Logback    ‚Äî  .  Logback      logging-,          .  ,     : <br><ul><li> <strong>log4j</strong> ‚Äî          . </li><li> <strong>JUL</strong> ‚Äî   . ,     ,   Logback. </li><li> <strong>commons-logging</strong> ‚Äî    legacy-,      ,   - . </li><li> <strong>SLF4J</strong> ‚Äî    .    ,    commons-logging </li><li> <strong>Logback</strong> ‚Äî   high-performance ,    log4j. </li></ul><br>   ,  Open Source      ¬´ ¬ª.       SLF4J   ¬´¬ª.   SLF4J  -      .  ,  SLF4J,      ¬´ ¬ª.  Logback (  , )    . (, log4j         2.0,     .) ,  Logback       Apache,    . <br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is interesting to look at the history of the issue from the perspective of the psychology of programmers. After all, in principle, all this is spiral (and it seems like a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">progressive</font></font></em> !)  ‚Äî  ¬´reinvent the wheel¬ª.      ¬´ ¬ª  ¬´ ¬ª   .            (    ¬´-¬ª).        ¬´¬ª      ,  ,   .   ,         .      (,  Graham Hamilton  IBM),      .    Jakarta Commons   ¬´ ¬ª      ¬´ ¬ª. <br><br>  -,       .    10-   ,     ,  Sun    -   Java-.  ,      Sun    Sun.  , ,    .     ‚Äî    ,    :) </div><p>Source: <a href="https://habr.com/ru/post/113145/">https://habr.com/ru/post/113145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113140/index.html">Designing a computer case in CATIA V6</a></li>
<li><a href="../113141/index.html">DreamPlug - PC for lovers of miniature gadgets</a></li>
<li><a href="../113142/index.html">Accelerated solution of the issue for 50 rubles from FirstVDS</a></li>
<li><a href="../113143/index.html">Malware for GNU / Linux and the fight against it</a></li>
<li><a href="../113144/index.html">History of ABBYY Lingvo. How it all began</a></li>
<li><a href="../113146/index.html">Audiko Ringtones for Android</a></li>
<li><a href="../113148/index.html">From the "South-West" to Cambridge. Winter Business School from InCube</a></li>
<li><a href="../113149/index.html">Brainfuckers are spotted among JavaScript developers.</a></li>
<li><a href="../113150/index.html">Digital Electronics Developer Forum (DEDF-2011) in Moscow. March, 3rd</a></li>
<li><a href="../113151/index.html">Canobuvosti, 77th edition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>