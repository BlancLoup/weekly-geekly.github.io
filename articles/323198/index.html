<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: From simple to complex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="„Åü „Å§ „Å∂ „Çä „Åù „Çç „Åù „Çç Áôª „Çå „Çå ÂØåÂ£´ „ÅÆ Â±± 

 Silently crawl, snail, on the slope of Fuji, 
 up to the heights 

 Â∞èÊûó ‰∏Ä Ëå∂ (Kobayashi Issa) 
 
 I wrote a lot about wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: From simple to complex</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>„Åü „Å§ „Å∂ „Çä „Åù „Çç „Åù „Çç Áôª „Çå „Çå ÂØåÂ£´ „ÅÆ Â±±</i></b> <b><i><br><br></i></b>  <b><i>Silently crawl, snail, on the slope of Fuji,</i></b> <b><i><br></i></b>  <b><i>up to the heights</i></b> <b><i><br><br></i></b>  <b><i><a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D1%2581%25D0%25B0,_%25D0%259A%25D0%25BE%25D0%25B1%25D0%25B0%25D1%258F%25D1%2581%25D0%25B8">Â∞èÊûó ‰∏Ä Ëå∂ (Kobayashi Issa)</a></i></b> <b><i><br></i></b> <br>  I <a href="https://habrahabr.ru/post/320474/">wrote a</a> lot about what I want to get in the end.  <a href="https://habrahabr.ru/post/322212/">He told</a> how it can be used, but left one simple question unanswered.  Why am I <b>convinced</b> that all <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src">this</a> (well, okay, <b>almost</b> all of this) works?  I have a secret weapon!  And today I want to talk about it. <br><a name="habracut"></a><br>  The project that I am writing is complicated.  I am developing a universal model, potentially suitable for describing <b>any</b> board games.  There is nothing to think about developing such a project from scratch, launching it and checking whether it works.  Moreover, there is nothing to launch yet.  There is neither a controller, nor any sort of a stray view, under which this model could be launched.  But I have to check and debug the written code right now!  Then, when the controller and the presentation appear, it will be simply impossible to debug it all, in its entirety! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I am not the first to face such a problem, and the method of its solution has long been <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">invented</a> .  To test my code, I use <a href="https://qunitjs.com/">QUnit</a> , but of course, this is not the only such solution in the JavaScript world.  I do not adhere to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">TDD</a> methodology, in the sense that I do not try to preface writing code with tests, but I try to cover the entire model code with tests as much as possible.  This helps me to solve the following tasks: <br><br><ul><li>  Finding and fixing stupid bugs and typos in the code </li><li>  Check compatibility of solutions used with various platforms (browsers) </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B5%25D1%2581%25D1%2581%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Regression testing</a> (changing something, I have to be sure that I didn't break anything) </li><li>  Minimum documentation (tests fix ways to use model interfaces) </li></ul><br><div class="spoiler">  <b class="spoiler_title">The approach has already managed to justify itself</b> <div class="spoiler_text">  At the very beginning of development, when with JavaScript I was still very ‚Äúon you‚Äù, I took <a href="https://www.jocly.com/">Jocly</a> code as a <a href="https://www.jocly.com/">basis</a> .  Now, I have to get rid of a lot of what was written then, but at that time, I had to start somewhere.  I well (as time showed, not well enough) understood the task, but knew the language very poorly.  Here is one of the examples of the code of those times: <br><br><div class="spoiler">  <b class="spoiler_title">Search for an element in an array</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([].indexOf) { Model.find = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.indexOf(value); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Model.find = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] === value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } }</code> </pre> </div></div><br>  Yes, premature optimization.  If the arrays support " <b>indexOf</b> ", use it, otherwise, we search manually, in a loop.  Since from the very beginning I built the model in such a way as to work only with numerical values, after some time, I decided to optimize something else: <br><br><div class="spoiler">  <b class="spoiler_title">Arrays of integer values</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span> !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { Model.int32Array = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(array.length); a.set(array); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Model.int32Array = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array; } }</code> </pre></div></div><br>  The logic is the same.  Those who can - use numeric arrays, the rest use what they can.  For a while, it all worked perfectly.  On those browsers that I used.  But at one point, I launched my tests on IE11.  And the creation of Microsoft, and not slow to strike.  Tests did not work.  Everything resulted in <a href="https://github.com/GlukKazan/JoclyGames/commit/87032851ad1fed49e219935755dd26d1797ed99b">this</a> fix.  I don‚Äôt want to say that this code is much better (now it has already been rewritten), but if I didn‚Äôt run the tests regularly and on different platforms, I wouldn‚Äôt have known about the problem!  Unit tests really work. <br></div></div><br>  As I develop tests, I move from simple code to more complex code.  Before checking the complex logic of the course generation (this is the main thing from what the model does), I must make sure that all the parts used by it are working correctly.  All classes used in my model can be ranked by increasing ‚Äúcomplexity‚Äù: <br><br><ul><li>  <b>ZrfPiece</b> - description of the figure (object on the board) </li><li>  <b>ZrfDesign</b> - description of the board topology and game rules </li><li>  <b>ZrfMove</b> - description of the course that changes the state of the game </li><li>  <b>ZrfMoveGenerator</b> - a generator of possible moves "by pattern" </li><li>  <b>ZrfBoard</b> - game state storage and generator of all allowable moves </li></ul><br>  The <b>ZrfPiece</b> class <b>is</b> so simple that testing it does not even require a full-fledged game <a href="">design</a> .  However, it has some not obvious features that need to be verified.  For example, the logic of creating a new object when changing the type, the owner or some of the attributes of the shape. <br><br><div class="spoiler">  <b class="spoiler_title">All this is elementary checked.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">QUnit.test( <span class="hljs-string"><span class="hljs-string">"Piece"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> assert </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.getDesign(); design.addPlayer(<span class="hljs-string"><span class="hljs-string">"White"</span></span>, []); design.addPlayer(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>, []); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Man"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"King"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> man = Model.Game.createPiece(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); assert.equal( man.toString(), <span class="hljs-string"><span class="hljs-string">"White Man"</span></span>, <span class="hljs-string"><span class="hljs-string">"White Man"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> king = man.promote(<span class="hljs-number"><span class="hljs-number">1</span></span>); assert.ok( king !== man, <span class="hljs-string"><span class="hljs-string">"Promoted Man"</span></span>); assert.equal( king.toString(), <span class="hljs-string"><span class="hljs-string">"White King"</span></span>, <span class="hljs-string"><span class="hljs-string">"White King"</span></span>); assert.equal( man.getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Non existent value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = man.setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); assert.ok( piece !== man, <span class="hljs-string"><span class="hljs-string">"Non mutable pieces"</span></span>); assert.ok( piece.getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>) === <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"Existent value"</span></span>); piece = piece.setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); assert.ok( piece.getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>) === <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Reset value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = piece.setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); assert.equal( piece, p, <span class="hljs-string"><span class="hljs-string">"Value not changed"</span></span>); Model.Game.design = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; });</code> </pre></div></div><br>  We manually create the most minimal ‚Äúdesign‚Äù (two players, two types of figures and no hint of a board) and manually perform all the checks we are interested in.  After that, calmly use the <b>ZrfPiece</b> , not expecting any <b>tricks</b> from him.  Even if it later turns out that you forgot to check something, just add a few more checks.  Next we test more complex code: <br><br><div class="spoiler">  <b class="spoiler_title">Game design</b> <div class="spoiler_text"><pre> <code class="javascript hljs">QUnit.test( <span class="hljs-string"><span class="hljs-string">"Design"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> assert </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.getDesign(); design.addDirection(<span class="hljs-string"><span class="hljs-string">"w"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"e"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"s"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"n"</span></span>); assert.equal( design.dirs.length, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Directions"</span></span>); design.addPlayer(<span class="hljs-string"><span class="hljs-string">"White"</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]); design.addPlayer(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]); assert.equal( design.players[<span class="hljs-number"><span class="hljs-number">0</span></span>].length, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Opposite"</span></span>); assert.equal( design.players[<span class="hljs-number"><span class="hljs-number">2</span></span>].length, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Symmetry"</span></span>); design.addPosition(<span class="hljs-string"><span class="hljs-string">"a2"</span></span>, [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]); design.addPosition(<span class="hljs-string"><span class="hljs-string">"b2"</span></span>, [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]); design.addPosition(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>]); design.addPosition(<span class="hljs-string"><span class="hljs-string">"b1"</span></span>, [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-number"><span class="hljs-number">2</span></span>; assert.equal( design.positionNames.length,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Positions"</span></span>); assert.equal( Model.Game.posToString(pos), <span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"Start position"</span></span>); pos = design.navigate(<span class="hljs-number"><span class="hljs-number">1</span></span>, pos, <span class="hljs-number"><span class="hljs-number">3</span></span>); assert.equal( Model.Game.posToString(pos), <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"Player A moving"</span></span>); pos = design.navigate(<span class="hljs-number"><span class="hljs-number">2</span></span>, pos, <span class="hljs-number"><span class="hljs-number">3</span></span>); assert.equal( Model.Game.posToString(pos), <span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"Player B moving"</span></span>); ... Model.Game.design = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; });</code> </pre></div></div><br>  <b>ZrfDesign</b> is 99% navigation on the game board.  Her and check.  We create the design again manually (now with a small board), after which we run the most typical test cases.  And do not forget, at the end, clear the created design!  So he did not break the other tests. <br><br><div class="spoiler">  <b class="spoiler_title">By the way, right now it turned out</b> <div class="spoiler_text">  I was very wrong when I considered the design of the game <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">singleton</a> !  Not to mention the server version, which simply needs to be able to work with several different models of games at the same time, there is another interesting case.  While working on the simplest game <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src/js/debug/ai">bots</a> , I remembered a <a href="http://www.battlevschess.com/en/">wonderful game</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/F1r3WUKJ0kM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mines are scattered across the field, but how to lure the enemy on them, provided that he knows about them?  After all, there is absolutely no reason for him to simply lose a piece by standing on a ‚Äúmined‚Äù field.  The problem is solved simply.  The bot with which we play can get a slightly different game design.  The board, the rules of the shapes - everything will be the same, with one small exception.  He will know nothing about the mines. <br><br>  In fact, this is the only adequate way to implement games with incomplete information, such as <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D554">Kriegspiel</a> or <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2515">Luzhanqi</a> , of course, if we don‚Äôt want the computer to see all our figures, and we don‚Äôt have it.  Anyway, I'm working on it now.  Unit tests help me again with this!  When performing such extensive refactoring, it is vital to know that nothing fell apart! <br></div></div><br>  Further, the tests are becoming more and more high-level.  Generation of a separate move according to a pattern by the <b>ZrfMoveGenerator</b> class, applying a turn to the game state and, finally, generating a set of moves by a certain position: <br><br><div class="spoiler">  <b class="spoiler_title">Fight of several figures by the woman</b> <div class="spoiler_text"><pre> <code class="javascript hljs">QUnit.test( <span class="hljs-string"><span class="hljs-string">"King's capturing chain"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> assert </span></span></span><span class="hljs-function">) </span></span>{ Model.Game.InitGame(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.getDesign(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> board = Model.Game.getInitBoard(); board.clear(); assert.equal( board.moves.length, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"No board moves"</span></span>); design.setup(<span class="hljs-string"><span class="hljs-string">"White"</span></span>, <span class="hljs-string"><span class="hljs-string">"King"</span></span>, Model.Game.stringToPos(<span class="hljs-string"><span class="hljs-string">"d4"</span></span>)); design.setup(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>, <span class="hljs-string"><span class="hljs-string">"Man"</span></span>, Model.Game.stringToPos(<span class="hljs-string"><span class="hljs-string">"c4"</span></span>)); design.setup(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>, <span class="hljs-string"><span class="hljs-string">"Man"</span></span>, Model.Game.stringToPos(<span class="hljs-string"><span class="hljs-string">"a6"</span></span>)); design.setup(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>, <span class="hljs-string"><span class="hljs-string">"Man"</span></span>, Model.Game.stringToPos(<span class="hljs-string"><span class="hljs-string">"f8"</span></span>)); board.generate(); assert.equal( board.moves.length, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"2 moves generated"</span></span>); assert.equal( board.moves[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString(), <span class="hljs-string"><span class="hljs-string">"d4 - a4 - a8 - g8 x c4 x a6 x f8"</span></span>, <span class="hljs-string"><span class="hljs-string">"d4 - a4 - a8 - g8 x c4 x a6 x f8"</span></span>); assert.equal( board.moves[<span class="hljs-number"><span class="hljs-number">1</span></span>].toString(), <span class="hljs-string"><span class="hljs-string">"d4 - a4 - a8 - h8 x c4 x a6 x f8"</span></span>, <span class="hljs-string"><span class="hljs-string">"d4 - a4 - a8 - h8 x c4 x a6 x f8"</span></span>); Model.Game.design = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; Model.Game.board = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; });</code> </pre></div></div><br>  With all the brevity of the test, it is almost a full game!  In any case, one move from it.  Here both the composite moves and the move by the ‚Äúsliding‚Äù figure and the capture priority and even the <a href="">majority rule</a> , implemented as a game extension and prescribing the capture of the maximum possible number of enemy pieces, are tested!  This small test covers almost all the functionality of the model.  And when something breaks, we see it, and immediately <a href="https://github.com/GlukKazan/JoclyGames/commit/ff74cedd4e25fb4acdb8e9a87e461e474853abbe">correct it</a> . <br><br>  One more thing unit-tests help is refactoring!  At some point, we decided that <a href="http://underscorejs.ru/">Underscore</a> <b>would be</b> used in the project.  This wonderful library helps to write code in a <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">functional style</a> , making it more concise and maintainable.  To make it clearer, I will give one example of the ‚Äúlife‚Äù of the project. <br><br>  Functional programming is the more useful the more complex the task.  If the code is very simple, rewriting it in a functional style will do little.  But if the task is a bit more complicated, the advantages of the functional approach become more obvious. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/csy39T5G220" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Remember this <a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html">game</a> ?  She has two fun rules: <br><br><ul><li>  If moving a stone creates a new row, the player gets the right to capture <b>any</b> of the opponent‚Äôs stones. </li><li>  When a player is left with just three stones, his stones turn into ‚Äúflying‚Äù.  These stones can move (‚Äúfly‚Äù) not only to one of the neighboring ones, but generally to <b>any</b> free cell on the board. </li></ul><br>  I marked the key word.  What does "a player can capture any opponent's stone"?  If the enemy has <b>N</b> pieces on the board, then exactly the same number of times we are obliged to duplicate each turn, leading to the construction of a ‚Äúrow‚Äù.  These moves will differ only in the figure taken!  In <a href="http://zillions-of-games.com/">Zillions of Games, this</a> is exactly what is being done.  And this incredibly complicates the implementation of the game!  But there is still the rule of "flying" stones ... <br><br>  There is another solution.  We can form only <b>one</b> move, listing in it all the positions of the potential take.  Of course, this does not mean that we will take <b>all the</b> stones, not at all!  Only one of these will be taken.  The move will become non-deterministic.  The same with the movements.  If a ‚Äúflying‚Äù stone can build a ‚Äúrow‚Äù, it turns out the Cartesian product of all effective moves to the many positions occupied by enemy figures. <br><br>  I came up with a good <a href="https://habrahabr.ru/post/320474/">way</a> by which the user interface can work with such moves, but for AI bots it is not applicable!  AI should receive strictly determined moves on an input!  This means that there must be a mechanism that turns non-deterministic moves into deterministic moves. <br><br><div class="spoiler">  <b class="spoiler_title">Here is the first version of what I once wrote</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getIx = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, ix, mx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ix &gt; x.length) { x = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ix == x.length) { c.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = x[ix]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &gt;= mx) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ix + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;= x.length) { x = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= ix; i++) { x[ix] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } x[ix + <span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } ZrfMove.prototype.determinate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = [<span class="hljs-number"><span class="hljs-number">0</span></span>]; x.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; x[<span class="hljs-number"><span class="hljs-number">0</span></span>]++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = Model.Game.createMove(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ix = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions[i][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { k = getIx(x, ix++, fp.length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } fp = [ fp[k] ]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions[i][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { k = getIx(x, ix++, tp.length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } tp = [ tp[k] ]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pc = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions[i][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pc !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { k = getIx(x, ix++, pc.length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } pc = [ pc[k] ]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pn = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions[i][<span class="hljs-number"><span class="hljs-number">3</span></span>]; m.actions.push([fp, tp, pc, pn]); } r.push(m); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  60 lines of completely incomprehensible and absolutely unsupported code!  Most likely, it does not even work!  I never tested it. <br><br><div class="spoiler">  <b class="spoiler_title">Instead, I rewrote it.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">ZrfMove.prototype.getControlList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(_.range(<span class="hljs-number"><span class="hljs-number">3</span></span>)) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action[ix] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action[ix].length; } }) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }) .value(); }) .flatten() .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.range(n); }) .cartesian() .value(); } ZrfMove.prototype.determinate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getControlList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(c) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZrfMove(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = []; _.each(_.range(<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ix</span></span></span><span class="hljs-function">) </span></span>{ pos = pushItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, action[ix], l, pos); }, x); x.push(action[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidAction(x)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions.push(x); } }, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .filter(isValidMove) .value(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ]; } }</code> </pre></div></div><br>  The code is longer and, at first glance, does not look more understandable.  But let's take a closer look at it.  For a start, let's try to understand the problem.  The course description ( <b>ZrfMove</b> ) consists of a set of actions ( <b>actions</b> ), each of which is a tuple of four elements: <br><br><ol><li>  Starting Position ( <b>from</b> ) </li><li>  End position ( <b>to</b> ) </li><li>  Figure </li><li>  Partial stroke number ( <b>num</b> ) </li></ol><br>  Since the transformation of the figures in the "Mill" is absent and the composite moves are not used, only the first two of these values ‚Äã‚Äãare important for us.  They are enough to describe any action performed: <br><br><ul><li>  Adding a piece to the board (reset) - <b>from == null &amp;&amp; to! = Null</b> </li><li>  Deleting a shape (capture) - <b>from! = Null &amp;&amp; to == null</b> </li><li>  Moving the shape - <b>from! = Null &amp;&amp; to! = Null &amp;&amp; from! = To</b> </li></ul><br>  But this is only half the battle!  In fact, both <b>from</b> and <b>to</b> (and even <b>piece</b> , but it's not about it) are also arrays!  If the move is deterministic, each of these arrays contains exactly one element.  The presence of more values ‚Äã‚Äãin any of them means the possibility of choice (which we must deal with). <br><br><div class="spoiler">  <b class="spoiler_title">Non-deterministic move</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = [ [ [<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] ], [ [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], <span class="hljs-literal"><span class="hljs-literal">null</span></span> ] ]; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre></div></div><br>  There is a movement of the figure from position <b>0</b> to any of the two positions ( <b>1</b> or <b>2</b> ) and the capture of one opponent's figure from positions <b>3</b> , <b>4</b> or <b>5</b> .  To begin with, you can choose the size of all ‚Äúnon-deterministic‚Äù positions (containing more than one element): <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m = _.map(m, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(_.range(<span class="hljs-number"><span class="hljs-number">2</span></span>)) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action[ix] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action[ix].length; } }) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }) .value(); });</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m == [ [<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>] ] <span class="hljs-comment"><span class="hljs-comment">//  "" </span></span></code> </pre></div></div><br>  This array is ‚Äúsmoothed out‚Äù, after which we turn each numeric value into a range: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><br>  m = _.chain (m) <br>  .flatten () <br>  .map (function (n) {return _.range (n);}) <br>  .value (); <br></div></div><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m == [ [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] ]</code> </pre></div></div><br>  Now we need an operation, which is not provided in the basic configuration of <a href="http://underscorejs.ru/">Underscore.js</a> .  Something like a <a href="http://www.wikiwand.com/bg/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25BE%25D0%25B2%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Cartesian product</a> .  Nothing wrong. <br><br><div class="spoiler">  <b class="spoiler_title">Write it yourself</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cartesian = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r, prefix, arr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _.each(_.first(arr), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = _.clone(prefix); x.push(n); cartesian(r, x, _.rest(arr)); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.push(prefix); } }</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">And build in Underscore.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs">_.mixin({ <span class="hljs-attr"><span class="hljs-attr">cartesian</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = []; cartesian(r, [], x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } });</code> </pre></div></div><br>  I admit that my decision is not quite "kosher."  If anyone knows how to do better, write in the comments.  Apply it: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> _.chain(m) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(_.range(<span class="hljs-number"><span class="hljs-number">2</span></span>)) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action[ix] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action[ix].length; } }) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }) .value(); }) .flatten() .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.range(n); }) .cartesian() .value();</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="javascript hljs">[ [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] ]</code> </pre></div></div><br>  The rest of the task is a little more complicated.  It is necessary to choose ‚Äúnon-determined‚Äù positions from the initial variant of the move, in accordance with the existing cheat sheet.  I will not bother with this reader, the problem is purely technical.  The most important thing is that the use of the functional approach allowed us to divide the rather complex task into parts that can be solved and debugged separately. <br><br>  Of course, the use of the functional approach is not always associated with solving such puzzles.  Usually, everything is somewhat simpler.  As a typical example, I can cite the <b><a href="">maximal-captures</a></b> module, which implements an option inherited from Zillions of Games, which takes the maximum number of pieces in games of the checkers family. <br><br><div class="spoiler">  <b class="spoiler_title">It was</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Model.Game.PostActions = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board</span></span></span><span class="hljs-function">) </span></span>{ PostActions(board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mode !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moves = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves[i].actions) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fp = board.moves[i].actions[j][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tp = board.moves[i].actions[j][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tp === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(fp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.type &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { kv++; } vl++; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vl &gt; mx) { mx = vl; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kv &gt; mk) { mk = kv; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves[i].actions) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fp = board.moves[i].actions[j][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tp = board.moves[i].actions[j][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tp === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(fp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.type &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { kv++; } vl++; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mode === <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (mk &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kv == mk) { moves.push(board.moves[i]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vl == mx) { moves.push(board.moves[i]); } } } board.moves = moves; } }</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">... and so it became</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Model.Game.PostActions = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board</span></span></span><span class="hljs-function">) </span></span>{ PostActions(board); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> captures = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.chain(move.actions) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (action[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (action[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.getPiece(action[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }) .compact() .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">piece</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> piece.type; }) .countBy(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type === <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-string"><span class="hljs-string">"Mans"</span></span> : <span class="hljs-string"><span class="hljs-string">"Kings"</span></span>; }) .defaults({ <span class="hljs-attr"><span class="hljs-attr">Mans</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">Kings</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }) .value(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mode !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caps = _.map(board.moves, captures); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all = _.chain(caps) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">captured</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captured.Mans + captured.Kings; }) .max() .value(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kings = _.chain(caps) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">captured</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captured.Kings; }) .max() .value(); board.moves = _.chain(board.moves) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = captures(move); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mode === <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (kings &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Kings &gt;= kings; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Mans + c.Kings &gt;= all; } }) .value(); } }</code> </pre></div></div><br>  Both options work well (at the time of refactoring, the code was already covered with tests), but the functional version is shorter, easier to understand and assembled from unified blocks.  To support him, of course, much easier. <br><br>  In conclusion of the article, I want to voice a few principles by which I try to be guided in my work.  I, in any case, do not want to make a dogma of them, but they help me. <br><br><div class="spoiler">  <b class="spoiler_title">Not a day without a line</b> <div class="spoiler_text">  Work on the project should not be interrupted!  In any case, for some long time.  The longer the break, the more difficult it is to return to work.  Work takes much less time and effort if you do it every day.  At least a little!  This does not mean that it is necessary to ‚Äúsqueeze‚Äù the code ‚Äúthrough I can‚Äôt‚Äù out of myself (it‚Äôs not long to burn out).  If the project is complex and interesting, you can always find a job that suits your mood. <br></div></div><div class="spoiler">  <b class="spoiler_title">Morning code, evening tests</b> <div class="spoiler_text">  Yes, yes, I know, this goes in full section with the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">TDD</a> methodology.  But who said that I stick to it?  <b>Unit-test-</b> s (very) are useful, even if you do not put them at the forefront!  Any code, both simple and complex, should be covered with tests as far as possible!  At the same time, it is desirable to move from simple to complex, testing more complex functionality after there is no doubt about the performance of the one on which it is built.  Do not delete tests until they have lost their relevance!  On the contrary, we must try to run them as often as possible, in various environments.  I found some serious and very non-trivial errors in this way! <br></div></div><div class="spoiler">  <b class="spoiler_title">Do no harm</b> <div class="spoiler_text">  Any changes should not break the code already covered with tests!  No need to <b>commit</b> code with broken tests.  Even if you dealt with this code all day!  Even if very tired to deal with the problem "here and now"!  Not working code is garbage.  This is a bomb that can explode at any time!  If you do not have the strength to deal with it, it is better to completely remove it, then to rewrite it again. <br></div></div><div class="spoiler">  <b class="spoiler_title">Never give up</b> <div class="spoiler_text">  Do not be afraid to rewrite the code again and again!  A small refactoring, or even a complete rewriting of the project from scratch - this is not a reason for panic!  This is an opportunity to solve the problem better. <br></div></div><div class="spoiler">  <b class="spoiler_title">If you can't win honestly - just win.</b> <div class="spoiler_text">  Good code solves the problem.  Good code is understandable and accompany.  That's all!  No need to turn inside out just to ‚Äúfit‚Äù it to the ideology of the <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">PLO</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">OP</a> or something else!  Using some possibilities of the language or its environment, one should not think about fashion, but only about the usefulness of these ‚Äúfeatures‚Äù for the project.  Behind the fashion, you still can‚Äôt keep up! <br></div></div><br>  Of course, I still have room to grow.  I do not see this problem.  My understanding of the language is changing (I hope for the better), and with it the code is also changing.  And unit tests just help me with that. <br></div><p>Source: <a href="https://habr.com/ru/post/323198/">https://habr.com/ru/post/323198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323182/index.html">Copyleft at risk: does Github lose GPL compatibility?</a></li>
<li><a href="../323186/index.html">Metaregular expressions on D</a></li>
<li><a href="../323188/index.html">Programmers can not write algorithms without help: once again about the interview</a></li>
<li><a href="../323192/index.html">Z-order vs R-tree, optimization and 3D</a></li>
<li><a href="../323194/index.html">What are the authors of ‚ÄúHello World?‚Äù Silent</a></li>
<li><a href="../323200/index.html">Power BI Embedded, IoT and machine learning for processing brain thermograms</a></li>
<li><a href="../323202/index.html">Web scraper development to extract data from the open data portal of Russia data.gov.ru</a></li>
<li><a href="../323204/index.html">Apache Ant - quick start</a></li>
<li><a href="../323206/index.html">Program on PYTHON to determine the authorship of the text by the frequency of occurrence of new words</a></li>
<li><a href="../323208/index.html">Nginx + PHP 7.1.1 FPM vs Node.js 7.7.1 as part 2 backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>