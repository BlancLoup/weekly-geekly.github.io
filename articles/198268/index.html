<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm for learning a multilayer neural network using the back propagation error (Backpropagation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of neural networks was already repeatedly covered in Habr√©, but today I would like to acquaint readers with the algorithm for learning a mul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm for learning a multilayer neural network using the back propagation error (Backpropagation)</h1><div class="post__text post__text-html js-mediator-article">  The topic of neural networks was already repeatedly covered in Habr√©, but today I would like to acquaint readers with the algorithm for learning a multilayer neural network using the method of back-propagation of error and lead the implementation of this method. <br><a name="habracut"></a><br>  I just want to make a reservation that I am not an expert in the field of neural networks, so I expect constructive criticism, comments and additions from readers. <br><br><h4>  Theoretical part </h4><br>  This material assumes familiarity with the basics of neural networks, but I consider it possible to introduce the reader to the topic course without unnecessary ordeal on the theory of neural networks.  So, for those who for the first time hears the phrase ‚Äúneural network‚Äù, I propose to perceive the neural network as a weighted directed graph, the nodes (neurons) of which are arranged in layers.  In addition, the node of one layer has connections with all nodes of the previous layer.  In our case, such a graph will have input and output layers, the nodes of which play the role of inputs and <br>  outputs respectively.  Each node (neuron) has an activation function - a function responsible for calculating the signal at the output of the node (neuron).  There is also the concept of displacement, which is a node, at the output of which a unit always appears.  In this article, we will consider the neural network learning process, which implies the presence of a ‚Äúteacher‚Äù, that is, a learning process in which learning occurs by providing the network with a sequence of learning examples with correct responses. <br><br>  As with most neural networks, our goal is to train the network in such a way as to achieve a balance between the ability of the network to respond correctly to the input data used in the learning process (remembering) and the ability to produce the correct results in response to the input data similar, but not identical to those used in training (the principle of generalization).  Teaching the network the method of back propagation of an error includes three stages: submission of data to the input, followed by dissemination of data in the direction of the outputs, calculation and back propagation of the corresponding error and correction of weights.  After the training, it is only assumed that data is fed to the network input and distributed in the direction of the outputs.  At the same time, if the training of the network can be a rather long process, the direct calculation of the results by the trained network occurs very quickly.  In addition, there are numerous variations of the back-propagation error method, designed to increase the flow rate <br>  learning process. <br>  It is also worth noting that a single-layer neural network is significantly limited in learning which input data patterns it is subject to, while a multi-layer network (with one or more hidden layers) does not have this disadvantage.  Next, a description will be given of a standard neural network with back propagation of an error. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Architecture </h5><br>  Figure 1 shows a multilayer neural network with one layer of hidden neurons (elements of Z). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38d/6f5/938/38d6f59385f91a5a67f8d9252ea4c1f3.png" alt="image"><br>  Neurons, which are network outputs (labeled <img src="https://habrastorage.org/getpro/habr/post_images/da8/c9d/14f/da8c9d14fab94ee3e15e002ef28ce592.png">  ), and hidden neurons may have an offset (as shown in the image).  Output offset <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  marked <img src="https://habrastorage.org/getpro/habr/post_images/735/552/fcb/735552fcbfcf153c158f2b7d8341cd1b.png">  hidden item <img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  - <img src="https://habrastorage.org/getpro/habr/post_images/08f/729/683/08f729683f33c7817a44164db06891e4.png">  .  These offsets serve as weights on connections emanating from neurons, at the output of which 1 always appears (in Figure 1 they are shown, but usually not explicitly displayed, implied).  In addition, in Figure 1, the arrows indicate the movement of information during the data distribution phase from inputs to outputs.  In the process of learning the signals propagate in the opposite direction. <br><br><h5>  Algorithm Description </h5><br>  The algorithm presented below is applicable to a neural network with one hidden layer, which is an acceptable and adequate situation for most applications.  As mentioned earlier, network training includes three stages: feeding the training data to the network inputs, back propagating the error, and adjusting the weights.  During the first stage, each input neuron <img src="https://habrastorage.org/getpro/habr/post_images/166/087/875/1660878752df56b0440afa43a678ed4f.png">  receives a signal and broadcasts it to each of the hidden neurons <img src="https://habrastorage.org/getpro/habr/post_images/1a9/237/a03/1a9237a0311cb65fb96838e1797f57cb.png">  .  Each hidden neuron then calculates the result of its activation function (network function) and sends its signal <img src="https://habrastorage.org/getpro/habr/post_images/b9b/e08/293/b9be08293a5a60d1e4014538abfb3f9d.png">  all weekend neurons.  Every output neuron <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  , in turn, calculates the result of its activation function <img src="https://habrastorage.org/getpro/habr/post_images/fb6/638/f7b/fb6638f7b148adf6d533aab3533d4ba8.png">  which is nothing but the output signal of a given neuron for the corresponding input data.  In the process of learning, each neuron at the output of the network compares the calculated value <img src="https://habrastorage.org/getpro/habr/post_images/fb6/638/f7b/fb6638f7b148adf6d533aab3533d4ba8.png">  with the teacher provided <img src="https://habrastorage.org/getpro/habr/post_images/168/307/b1b/168307b1b7b360eaba24382211e71963.png">  (target value), defining the corresponding error value for a given input pattern.  Based on this error, it is calculated <img src="https://habrastorage.org/getpro/habr/post_images/051/c89/194/051c891941d8d4a9536c62b3b2b842f0.png">  . <img src="https://habrastorage.org/getpro/habr/post_images/5a8/dcf/4e5/5a8dcf4e5b4a874885b937ae3672726f.png">  used when propagating errors from <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  to all network elements of the previous layer (hidden neurons associated with <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  ), as well as later when changing the weights of the connections between the output neurons and the hidden ones.  Similarly, it is calculated <img src="https://habrastorage.org/getpro/habr/post_images/40a/b78/d3b/40ab78d3b2db064e9aabaa14e83258fd.png">  for each hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  .  Although there is no need to propagate the error to the input layer, <img src="https://habrastorage.org/getpro/habr/post_images/b43/11c/f7c/b4311cf7cfea3ccc4db0fbe72b007cd1.png">  It is used to change the weights of connections between the neurons of the hidden layer and the input neurons.  After all <img src="https://habrastorage.org/getpro/habr/post_images/7e5/561/289/7e5561289221da7e0e3fb3efc1077a3e.png">  were determined, there is a simultaneous adjustment of the weights of all links. <br><br><h6>  Legend: </h6><br><br>  The network training algorithm uses the following notation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82a/bf8/f83/82abf8f833c10a839b10db71b61ceab1.png">  Input vector training data <img src="https://habrastorage.org/getpro/habr/post_images/463/bd9/d93/463bd9d9310b07f938dcb2282a043871.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/778/df5/c21/778df5c21816047a133ee1ad9b2dc5d9.png">  Vector target output values ‚Äã‚Äãprovided by the teacher <img src="https://habrastorage.org/getpro/habr/post_images/48b/868/4a7/48b8684a7a0f15f64873e3c654002ca8.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/5a8/dcf/4e5/5a8dcf4e5b4a874885b937ae3672726f.png">  Linkage adjustment component <img src="https://habrastorage.org/getpro/habr/post_images/cf5/900/669/cf59006696ea246e89387f56fdebe014.png">  corresponding to the error of the output neuron <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  ;  also, neuron error information <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  which is distributed to those neurons of the hidden layer that are associated with <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  . <br><img src="https://habrastorage.org/getpro/habr/post_images/b43/11c/f7c/b4311cf7cfea3ccc4db0fbe72b007cd1.png">  Linkage adjustment component <img src="https://habrastorage.org/getpro/habr/post_images/24a/23e/821/24a23e82102f3b8b5145fe44d657ce1d.png">  corresponding to propagation from the output layer to the hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  error information. <br><img src="https://habrastorage.org/getpro/habr/post_images/a25/6b9/e0a/a256b9e0a8062f3257eadbf641f4fb3e.png">  Learning speed <br><img src="https://habrastorage.org/getpro/habr/post_images/81e/0e8/e95/81e0e8e9509762677402cc805a077030.png">  Neuron inlet with index i.  For input neurons, the input and output signals are the same - <img src="https://habrastorage.org/getpro/habr/post_images/166/087/875/1660878752df56b0440afa43a678ed4f.png">  . <br><img src="https://habrastorage.org/getpro/habr/post_images/08f/729/683/08f729683f33c7817a44164db06891e4.png">  Offset of the hidden neuron j. <br><img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  Hidden neuron j;  The total value supplied to the input of the hidden item <img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  denoted by <img src="https://habrastorage.org/getpro/habr/post_images/b9d/61c/dfe/b9d61cdfe5b495b2eb26941f88ea4adb.png">  : <img src="https://habrastorage.org/getpro/habr/post_images/885/f39/e7e/885f39e7ee0ede3db2366601ca147a0d.png"><br>  Output signal <img src="https://habrastorage.org/getpro/habr/post_images/447/c49/ffa/447c49ffa52067e5e83c2b1178a8fb6f.png">  (result of applying to <img src="https://habrastorage.org/getpro/habr/post_images/b9d/61c/dfe/b9d61cdfe5b495b2eb26941f88ea4adb.png">  activation function) is denoted by <img src="https://habrastorage.org/getpro/habr/post_images/b9b/e08/293/b9be08293a5a60d1e4014538abfb3f9d.png">  : <img src="https://habrastorage.org/getpro/habr/post_images/99e/cd1/4b6/99ecd14b67801572c48d7cd37f3d3627.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/735/552/fcb/735552fcbfcf153c158f2b7d8341cd1b.png">  The displacement of the neuron at the exit. <br><img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  Neuron output k;  The total value supplied to the input of the output element <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  denoted by <img src="https://habrastorage.org/getpro/habr/post_images/5a6/b0c/064/5a6b0c064e0f51a616b13a18ea2da55e.png">  : <img src="https://habrastorage.org/getpro/habr/post_images/82f/0e7/424/82f0e74249b31a09bcf06d6ef0aa2396.png">  .  Output signal <img src="https://habrastorage.org/getpro/habr/post_images/8a0/789/360/8a07893605ee487e57d8b656082aaf11.png">  (result of applying to <img src="https://habrastorage.org/getpro/habr/post_images/5a6/b0c/064/5a6b0c064e0f51a616b13a18ea2da55e.png">  activation function) is denoted by <img src="https://habrastorage.org/getpro/habr/post_images/fb6/638/f7b/fb6638f7b148adf6d533aab3533d4ba8.png">  : <br><br><h5>  Activation function </h5><br>  The activation function in the backpropagation error algorithm must have several important characteristics: continuity, differentiability and be monotonously non-decreasing.  Moreover, for the sake of efficiency of calculations, it is desirable that its derivative be easily found.  Often, the activation function is also a function with saturation.  One of the most frequently used activation functions is a binary sigmoid function with a range of values ‚Äã‚Äãin (0, 1) and defined as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f8/68c/f09/6f868cf09ffea9191cba6628d7da38cb.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/063/854/a74/063854a74b79f58f11868cca0f803d33.png"><br>  Another widespread activation function is bipolar sigmoid with a range of values ‚Äã‚Äã(-1, 1) and defined as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/20d/ffe/961/20dffe96199ef272cd832a2b8b6eb2fe.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/651/f74/749/651f74749b0694f2b96b147435e6f874.png"><br><h5>  Learning algorithm </h5><br>  The learning algorithm is as follows: <br><br><h6>  Step 0. </h6><br>  The initialization of the weights (the weights of all the links are initialized to random small values). <br><br><h6>  Step 1. </h6><br>  Until the termination condition of the algorithm is incorrect, steps 2‚Äì9 are performed. <br><br><h6>  Step 2. </h6><br>  For each pair {data, target value} steps 3‚Äì8 are performed. <br><br><h6>  Distribution of data from inputs to outputs: </h6><br><h6>  Step 3. </h6><br>  Each input neuron <img src="https://habrastorage.org/getpro/habr/post_images/46c/e8c/b1d/46ce8cb1dd7e39143f21cc5a5e21cea8.png">  sends the received signal <img src="https://habrastorage.org/getpro/habr/post_images/166/087/875/1660878752df56b0440afa43a678ed4f.png">  all neurons in the next layer (hidden). <br><br><h6>  Step 4. </h6><br>  Every hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/1d1/edd/d20/1d1eddd207d736064909cc1a25ee8df0.png">  summarizes the weighted incoming signals: <img src="https://habrastorage.org/getpro/habr/post_images/885/f39/e7e/885f39e7ee0ede3db2366601ca147a0d.png">  and applies the activation function: <img src="https://habrastorage.org/getpro/habr/post_images/99e/cd1/4b6/99ecd14b67801572c48d7cd37f3d3627.png">  Then sends the result to all elements of the next layer (output). <br><br><h6>  Step 5. </h6><br>  Every output neuron <img src="https://habrastorage.org/getpro/habr/post_images/79f/c41/541/79fc41541557eb180869ffcb9508d598.png">  summarizes the weighted incoming signals: <img src="https://habrastorage.org/getpro/habr/post_images/82f/0e7/424/82f0e74249b31a09bcf06d6ef0aa2396.png">  and applies the activation function, calculating the output signal: <img src="https://habrastorage.org/getpro/habr/post_images/edb/8ed/193/edb8ed1935c43d337dc004149b067c34.png"><br><br><h6>  Reverse Error Propagation: </h6><br><h6>  Step 6. </h6><br>  Every output neuron <img src="https://habrastorage.org/getpro/habr/post_images/79f/c41/541/79fc41541557eb180869ffcb9508d598.png">  gets the target value - the output value that is correct for this input signal, and calculates the error: <img src="https://habrastorage.org/getpro/habr/post_images/617/aea/2fa/617aea2fa43ce4bcf4929bf7500bf4be.png">  , also calculates the amount by which the weight of the connection will change <img src="https://habrastorage.org/getpro/habr/post_images/cf5/900/669/cf59006696ea246e89387f56fdebe014.png">  : <img src="https://habrastorage.org/getpro/habr/post_images/6bb/7c2/d29/6bb7c2d29e1ba7c5e24b1439fbb9b83f.png">  .  In addition, it calculates the magnitude of the offset correction: <img src="https://habrastorage.org/getpro/habr/post_images/b28/df6/c8b/b28df6c8b850fc324345ff80a000b363.png">  and sends <img src="https://habrastorage.org/getpro/habr/post_images/5a8/dcf/4e5/5a8dcf4e5b4a874885b937ae3672726f.png">  neurons in the previous layer. <br><br><h6>  Step 7. </h6><br>  Every hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/1d1/edd/d20/1d1eddd207d736064909cc1a25ee8df0.png">  summarizes incoming errors (from neurons in the next layer) <img src="https://habrastorage.org/getpro/habr/post_images/340/ed2/6d3/340ed26d37a79407e4e21bf353f26fc6.png">  and calculates the magnitude of the error, multiplying the resulting value by the derivative of the activation function: <img src="https://habrastorage.org/getpro/habr/post_images/a20/92c/66f/a2092c66fbb73614cddd7ac606e75bcb.png">  , also calculates the amount by which the weight of the connection will change <img src="https://habrastorage.org/getpro/habr/post_images/24a/23e/821/24a23e82102f3b8b5145fe44d657ce1d.png">  : <img src="https://habrastorage.org/getpro/habr/post_images/72c/69f/fd4/72c69ffd4988db568e67bfb71e8547cc.png">  .  In addition, it calculates the magnitude of the offset correction: <img src="https://habrastorage.org/getpro/habr/post_images/121/58d/5d5/12158d5d5f985d78205f5543c4bb8d3d.png"><br><br><h6>  Step 8. Changing weights. </h6><br>  Every output neuron <img src="https://habrastorage.org/getpro/habr/post_images/79f/c41/541/79fc41541557eb180869ffcb9508d598.png">  changes the weights of its connections with the displacement element and hidden neurons: <img src="https://habrastorage.org/getpro/habr/post_images/001/9c9/cc5/0019c9cc533438ac809b0be56aa44423.png"><br>  Every hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/1d1/edd/d20/1d1eddd207d736064909cc1a25ee8df0.png">  changes the weights of its connections with the displacement element and output neurons: <img src="https://habrastorage.org/getpro/habr/post_images/0e2/be6/915/0e2be69159c16393df76d4ae31d2ba5f.png"><br><br><h6>  Step 9. </h6><br>  Check the condition of the termination of the algorithm. <br><br>  The condition for the termination of the algorithm can be both the achievement of a total quadratic error of the result at the network output of a predetermined minimum in the course of the learning process, and the execution of a certain number of iterations of the algorithm.  The algorithm is based on a method called gradient descent.  Depending on the sign, the gradient of the function (in this case, the value of the function is an error, and the parameters are the weights of the links in the network) gives the direction in which the values ‚Äã‚Äãof the function increase (or decrease) most rapidly. <br><br><h5>  Selection of initial weights and offsets </h5><br>  Random initialization.  The choice of initial weights will influence whether the network is able to achieve a global (or only local) minimum of error, and how quickly this process will take place.  The change in weights between two neurons is related to the derivative of the activation function of the neuron from the next layer and the activation function of the neuron of the previous layer.  In this regard, it is important to avoid choosing such initial weights that will nullify the activation function or its derivative.  Also, the initial weights should not be too large (or the input signal for each hidden or output neuron is likely to fall into a region of very small sigmoid values ‚Äã‚Äã(saturation region)).  On the other hand, if the initial weights are too small, then the input to the hidden or output neurons will be close to zero, which will also lead to a very low learning rate.  The standard procedure for initializing weights is to assign them random values ‚Äã‚Äãin the interval (-0.5; 0.5).  Values ‚Äã‚Äãcan be both positive and negative, since the final weights obtained after training the network can be both signs.  Initializing Nguyen - Widrow.  The following simple modification of the standard initialization procedure facilitates faster learning: The weights of the connections of the hidden and output neurons, as well as the displacement of the output layer, are also initialized, as in the standard procedure, with random values ‚Äã‚Äãfrom the interval (-0.5; 0.5). <br><br>  We introduce the notation: <br><img src="https://habrastorage.org/getpro/habr/post_images/15b/f0f/235/15bf0f235bbaaa0a82718b48eb1c962b.png">  number of input neurons <br><img src="https://habrastorage.org/getpro/habr/post_images/766/088/910/7660889100e11197f53a2181c445217a.png">  number of hidden neurons <br><img src="https://habrastorage.org/getpro/habr/post_images/a04/70e/63f/a0470e63fe05330552ba4d5e05ece2d8.png">  scaling factor: <br><img src="https://habrastorage.org/getpro/habr/post_images/d29/c03/7e5/d29c037e5b2f309cae600cb4794ca856.png"><br>  The procedure consists of the following simple steps: <br>  For each hidden neuron <img src="https://habrastorage.org/getpro/habr/post_images/1d1/edd/d20/1d1eddd207d736064909cc1a25ee8df0.png">  : <br>  initialize its weight vector (connections to input neurons): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b76/b1d/a25/b76b1da256e518703788e2fea5873394.png"><br><br>  calculate <img src="https://habrastorage.org/getpro/habr/post_images/9db/216/21f/9db21621ffa71782c562f00b94d31c43.png"><br>  reinitialize weights: <img src="https://habrastorage.org/getpro/habr/post_images/697/82f/062/69782f06252b90b2ce0217130f116516.png"><br>  set offset value: <img src="https://habrastorage.org/getpro/habr/post_images/9ca/1de/a4c/9ca1dea4c08c96f1e38c06aaae81df4c.png"><br><h4>  Practical part </h4><br>  I'll start with the implementation of the concept of a neuron.  It was decided to present the neurons of the input layer as the base class, and the hidden and the weekend as decorators of the base class.  In addition, the neuron stores information about outgoing and incoming connections, as well as each neuron compositionally contains an activation function. <br><br><div class="spoiler">  <b class="spoiler_title">Neuron interface</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Neuron base class. * Represents a basic element of neural network, node in the net's graph. * There are several possibilities for creation an object of type Neuron, different constructors suites for * different situations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Neuron</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * A default Neuron constructor. * - Description: Creates a Neuron; general purposes. * - Purpose: Creates a Neuron, linked to nothing, with a Linear network function. * - Prerequisites: None. */</span></span> Neuron( ) : mNetFunc( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Linear ), mSumOfCharges( <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) { }; <span class="hljs-comment"><span class="hljs-comment">/** * A Neuron constructor based on NetworkFunction. * - Description: Creates a Neuron; mostly designed to create an output kind of neurons. * @param inNetFunc - a network function which is producing neuron's output signal; * - Purpose: Creates a Neuron, linked to nothing, with a specific network function. * - Prerequisites: The existence of NetworkFunction object. */</span></span> Neuron( NetworkFunction * inNetFunc ) : mNetFunc( inNetFunc ), mSumOfCharges( <span class="hljs-number"><span class="hljs-number">0.0</span></span> ){ }; Neuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; inLinksToNeurons, NetworkFunction * inNetFunc ) : mNetFunc( inNetFunc ), mLinksToNeurons(inLinksToNeurons), mSumOfCharges(<span class="hljs-number"><span class="hljs-number">0.0</span></span>){ }; <span class="hljs-comment"><span class="hljs-comment">/** * A Neuron constructor based on layer of Neurons. * - Description: Creates a Neuron; mostly designed to create an input and hidden kinds of neurons. * @param inNeuronsLinkTo - a vector of pointers to Neurons which is representing a layer; * @param inNetFunc - a network function which is producing neuron's output signal; * - Purpose: Creates a Neuron, linked to every Neuron in provided layer. * - Prerequisites: The existence of std::vector&lt;Neuron *&gt; and NetworkFunction. */</span></span> Neuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron *&gt;&amp; inNeuronsLinkTo, NetworkFunction * inNetFunc ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Neuron( ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetLinksToNeurons( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLinksToNeurons; }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> NeuralLink&lt;T&gt; * at( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inIndexOfNeuralLink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLinksToNeurons[ inIndexOfNeuralLink ]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLinkToNeuron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inNeuralLink )</span></span></span></span>{ mLinksToNeurons.push_back( inNeuralLink ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inInputData )</span></span></span></span>{ mSumOfCharges += inInputData; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumOfLinks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLinksToNeurons.size( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ mSumOfCharges = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNetFunc-&gt;Process( mSumOfCharges ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inArg )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNetFunc-&gt;Process( inArg ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNetFunc-&gt;Derivative( mSumOfCharges ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInputLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inLink )</span></span></span></span>{ mInputLinks.push_back( inLink ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetInputLink( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInputLinks; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformTrainingProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inTarget )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformWeightsUpdating</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNeuronState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: NetworkFunction * mNetFunc; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt; mInputLinks; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt; mLinksToNeurons; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mSumOfCharges; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputLayerNeuronDecorator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Neuron&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OutputLayerNeuronDecorator( Neuron&lt;T&gt; * inNeuron ){ mOutputCharge = <span class="hljs-number"><span class="hljs-number">0</span></span>; mNeuron = inNeuron; }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~OutputLayerNeuronDecorator( ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetLinksToNeurons( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetLinksToNeurons( ) ;}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> NeuralLink&lt;T&gt; * at( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inIndexOfNeuralLink ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( mNeuron-&gt;at( inIndexOfNeuralLink ) ) ;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLinkToNeuron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inNeuralLink )</span></span></span></span>{ mNeuron-&gt;SetLinkToNeuron( inNeuralLink ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetSumOfCharges( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ mNeuron-&gt;ResetSumOfCharges( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inInputData )</span></span></span></span>{ mNeuron-&gt;Input( inInputData ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumOfLinks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetNumOfLinks( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Process( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inArg )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Process( inArg ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Derivative( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInputLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inLink )</span></span></span></span>{ mNeuron-&gt;SetInputLink( inLink ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetInputLink( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetInputLink( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformTrainingProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inTarget )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformWeightsUpdating</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNeuronState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ mNeuron-&gt;ShowNeuronState( ); }; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mOutputCharge; Neuron&lt;T&gt; * mNeuron; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HiddenLayerNeuronDecorator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Neuron&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HiddenLayerNeuronDecorator( Neuron&lt;T&gt; * inNeuron ) { mNeuron = inNeuron; }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~HiddenLayerNeuronDecorator( ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetLinksToNeurons( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetLinksToNeurons( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLinkToNeuron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inNeuralLink )</span></span></span></span>{ mNeuron-&gt;SetLinkToNeuron( inNeuralLink ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetSumOfCharges( ) ;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetSumOfCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{mNeuron-&gt;ResetSumOfCharges( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inInputData )</span></span></span></span>{ mNeuron-&gt;Input( inInputData ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumOfLinks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetNumOfLinks( ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> NeuralLink&lt;T&gt; * ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inIndexOfNeuralLink ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( mNeuron-&gt;at( inIndexOfNeuralLink) ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Process( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inArg )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Process( inArg ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;Derivative( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInputLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuralLink&lt;T&gt; * inLink )</span></span></span></span>{ mNeuron-&gt;SetInputLink( inLink ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NeuralLink&lt;T &gt; *&gt;&amp; GetInputLink( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuron-&gt;GetInputLink( ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformTrainingProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inTarget )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformWeightsUpdating</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNeuronState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ mNeuron-&gt;ShowNeuronState( ); }; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Neuron&lt;T&gt; * mNeuron; };</code> </pre> <br></div></div><br><br>  The neural link interface is shown below, each link stores a weight and a pointer to a neuron: <br><br><div class="spoiler">  <b class="spoiler_title">Neural Communication Interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Neuron</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NeuralLink</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: NeuralLink( ) : mWeightToNeuron( <span class="hljs-number"><span class="hljs-number">0.0</span></span> ), mNeuronLinkedTo( <span class="hljs-number"><span class="hljs-number">0</span></span> ), mWeightCorrectionTerm( <span class="hljs-number"><span class="hljs-number">0</span></span> ), mErrorInformationTerm( <span class="hljs-number"><span class="hljs-number">0</span></span> ), mLastTranslatedSignal( <span class="hljs-number"><span class="hljs-number">0</span></span> ){ }; NeuralLink( Neuron&lt;T&gt; * inNeuronLinkedTo, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inWeightToNeuron = <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) : mWeightToNeuron( inWeightToNeuron ), mNeuronLinkedTo( inNeuronLinkedTo ), mWeightCorrectionTerm( <span class="hljs-number"><span class="hljs-number">0</span></span> ), mErrorInformationTerm( <span class="hljs-number"><span class="hljs-number">0</span></span> ), mLastTranslatedSignal( <span class="hljs-number"><span class="hljs-number">0</span></span> ){ }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; inWeight )</span></span></span></span>{ mWeightToNeuron = inWeight; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mWeightToNeuron; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeuronLinkedTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Neuron&lt;T&gt; * inNeuronLinkedTo )</span></span></span></span>{ mNeuronLinkedTo = inNeuronLinkedTo; }; Neuron&lt;T&gt; * GetNeuronLinkedTo( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mNeuronLinkedTo; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWeightCorrectionTerm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inWeightCorrectionTerm )</span></span></span></span>{ mWeightCorrectionTerm = inWeightCorrectionTerm; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightCorrectionTerm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mWeightCorrectionTerm; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ mWeightToNeuron = mWeightToNeuron + mWeightCorrectionTerm; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErrorInFormationTerm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mErrorInformationTerm; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetErrorInFormationTerm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inEITerm )</span></span></span></span>{ mErrorInformationTerm = inEITerm; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLastTranslatedSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inLastTranslatedSignal )</span></span></span></span>{ mLastTranslatedSignal = inLastTranslatedSignal; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLastTranslatedSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLastTranslatedSignal; }; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mWeightToNeuron; Neuron&lt;T&gt; * mNeuronLinkedTo; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mWeightCorrectionTerm; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mErrorInformationTerm; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mLastTranslatedSignal; };</code> </pre><br></div></div><br><br>  Each activation function inherits from an abstract class, implementing the function itself and its derivative: <br><br><div class="spoiler">  <b class="spoiler_title">Interface activation function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkFunction</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: NetworkFunction(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~NetworkFunction(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linear</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NetworkFunction { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Linear(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Linear(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inParam; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sigmoid</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NetworkFunction { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sigmoid(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Sigmoid(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span> / ( <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>( -inParam ) ) ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Process(inParam)*(<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Process(inParam)) );}; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BipolarSigmoid</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NetworkFunction { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: BipolarSigmoid(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~BipolarSigmoid(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-number"><span class="hljs-number">2</span></span> / ( <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>( -inParam ) ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ) ;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inParam )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ( <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Process( inParam ) ) * ( <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Process( inParam ) ) ); }; };</code> </pre><br></div></div><br><br>  The neuron factory is responsible for the production of neurons: <br><br><div class="spoiler">  <b class="spoiler_title">Neural Factory Interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NeuronFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: NeuronFactory(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~NeuronFactory(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateInputNeuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; inNeuronsLinkTo, NetworkFunction * inNetFunc ) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateOutputNeuron( NetworkFunction * inNetFunc ) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateHiddenNeuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; inNeuronsLinkTo, NetworkFunction * inNetFunc ) = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PerceptronNeuronFactory</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NeuronFactory&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PerceptronNeuronFactory(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PerceptronNeuronFactory(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateInputNeuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; inNeuronsLinkTo, NetworkFunction * inNetFunc ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Neuron&lt;T&gt;( inNeuronsLinkTo, inNetFunc ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateOutputNeuron( NetworkFunction * inNetFunc ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OutputLayerNeuronDecorator&lt;T&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Neuron&lt;T&gt;( inNetFunc ) ); }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Neuron&lt;T&gt; * CreateHiddenNeuron( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; inNeuronsLinkTo, NetworkFunction * inNetFunc ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HiddenLayerNeuronDecorator&lt;T&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Neuron&lt;T&gt;( inNeuronsLinkTo, inNetFunc ) ); }; };</code> </pre><br></div></div><br><br>  The neural network itself stores pointers to neurons organized by <br>  layers (in general, pointers to neurons are stored in vectors that <br>  need to be replaced with layer objects), includes abstract <br>  a neuron factory; and a network learning algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Neural network interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrainAlgorithm</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Neural network class. * An object of that type represents a neural network of several types: * - Single layer perceptron; * - Multiple layers perceptron. * * There are several training algorithms available as well: * - Perceptron; * - Backpropagation. * * How to use this class: * To be able to use neural network , you have to create an instance of that class, specifying * a number of input neurons, output neurons, number of hidden layers and amount of neurons in hidden layers. * You can also specify a type of neural network, by passing a string with a name of neural network, otherwise * MultiLayerPerceptron will be used. ( A training algorithm can be changed via public calls); * * Once the neural network was created, all u have to do is to set the biggest MSE required to achieve during * the training phase ( or u can skip this step, then mMinMSE will be set to 0.01 ), * train the network by providing a training data with target results. * Afterwards u can obtain the net response by feeding the net with data; * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NeuralNetwork</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * A Neural Network constructor. * - Description: A template constructor. T is a data type, all the nodes will operate with. Create a neural network by providing it with: * @param inInputs - an integer argument - number of input neurons of newly created neural network; * @param inOutputs- an integer argument - number of output neurons of newly created neural network; * @param inNumOfHiddenLayers - an integer argument - number of hidden layers of newly created neural network, default is 0; * @param inNumOfNeuronsInHiddenLayers - an integer argument - number of neurons in hidden layers of newly created neural network ( note that every hidden layer has the same amount of neurons), default is 0; * @param inTypeOfNeuralNetwork - a const char * argument - a type of neural network, we are going to create. The values may be: * &lt;UL&gt; * &lt;LI&gt;MultiLayerPerceptron;&lt;/LI&gt; * &lt;LI&gt;Default is MultiLayerPerceptron.&lt;/LI&gt; * &lt;/UL&gt; * - Purpose: Creates a neural network for solving some interesting problems. * - Prerequisites: The template parameter has to be picked based on your input data. * */</span></span> NeuralNetwork( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inInputs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inOutputs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inNumOfHiddenLayers = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inNumOfNeuronsInHiddenLayers = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * inTypeOfNeuralNetwork = <span class="hljs-string"><span class="hljs-string">"MultiLayerPerceptron"</span></span> ); ~NeuralNetwork( ); <span class="hljs-comment"><span class="hljs-comment">/** * Public method Train. * - Description: Method for training the network. * - Purpose: Trains a network, so the weights on the links adjusted in the way to be able to solve problem. * - Prerequisites: * @param inData - a vector of vectors with data to train with; * @param inTarget - a vector of vectors with target data; * - the number of data samples and target samples has to be equal; * - the data and targets has to be in the appropriate order u want the network to learn. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T &gt; &gt;&amp; inData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T &gt; &gt;&amp; inTarget )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Public method GetNetResponse. * - Description: Method for actually get response from net by feeding it with data. * - Purpose: By calling this method u make the network evaluate the response for u. * - Prerequisites: * @param inData - a vector data to feed with. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; GetNetResponse( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;&amp; inData ); <span class="hljs-comment"><span class="hljs-comment">/** * Public method SetAlgorithm. * - Description: Setter for algorithm of training the net. * - Purpose: Can be used for dynamic change of training algorithm. * - Prerequisites: * @param inTrainingAlgorithm - an existence of already created object of type TrainAlgorithm. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAlgorithm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TrainAlgorithm&lt;T&gt; * inTrainingAlgorithm )</span></span></span><span class="hljs-function"> </span></span>{ mTrainingAlgoritm = inTrainingAlgorithm; }; <span class="hljs-comment"><span class="hljs-comment">/** * Public method SetNeuronFactory. * - Description: Setter for the factory, which is making neurons for the net. * - Purpose: Can be used for dynamic change of neuron factory. * - Prerequisites: * @param inNeuronFactory - an existence of already created object of type NeuronFactory. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeuronFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NeuronFactory&lt;T&gt; * inNeuronFactory )</span></span></span><span class="hljs-function"> </span></span>{ mNeuronFactory = inNeuronFactory; }; <span class="hljs-comment"><span class="hljs-comment">/** * Public method ShowNetworkState. * - Description: Prints current state to the standard output: weight of every link. * - Purpose: Can be used for monitoring the weights change during training of the net. * - Prerequisites: None. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNetworkState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Public method GetMinMSE. * - Description: Returns the biggest MSE required to achieve during the training phase. * - Purpose: Can be used for getting the biggest MSE required to achieve during the training phase. * - Prerequisites: None. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMinMSE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mMinMSE; }; <span class="hljs-comment"><span class="hljs-comment">/** * Public method SetMinMSE. * - Description: Setter for the biggest MSE required to achieve during the training phase. * - Purpose: Can be used for setting the biggest MSE required to achieve during the training phase. * - Prerequisites: * @param inMinMse - double value, the biggest MSE required to achieve during the training phase. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMinMSE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; inMinMse )</span></span></span></span>{ mMinMSE = inMinMse; }; <span class="hljs-comment"><span class="hljs-comment">/** * Friend class. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hebb</span></span></span><span class="hljs-class">&lt;T&gt;;</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Friend class. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backpropagation</span></span></span><span class="hljs-class">&lt;T&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * Protected method GetLayer. * - Description: Getter for the layer by index of that layer. * - Purpose: Can be used by inner implementation for getting access to neural network's layers. * - Prerequisites: * @param inInd - an integer index of layer. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; GetLayer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; inInd ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLayers[inInd]; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method size. * - Description: Returns the number of layers in the network. * - Purpose: Can be used by inner implementation for getting number of layers in the network. * - Prerequisites: None. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLayers.size( ); }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method GetNumOfOutputs. * - Description: Returns the number of units in the output layer. * - Purpose: Can be used by inner implementation for getting number of units in the output layer. * - Prerequisites: None. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; GetOutputLayer( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLayers[mLayers.size( )<span class="hljs-number"><span class="hljs-number">-1</span></span>]; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method GetInputLayer. * - Description: Returns the input layer. * - Purpose: Can be used by inner implementation for getting the input layer. * - Prerequisites: None. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; GetInputLayer( ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLayers[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method GetBiasLayer. * - Description: Returns the vector of Biases. * - Purpose: Can be used by inner implementation for getting vector of Biases. * - Prerequisites: None. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt;&amp; GetBiasLayer( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mBiasLayer; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method UpdateWeights. * - Description: Updates the weights of every link between the neurons. * - Purpose: Can be used by inner implementation for updating the weights of links between the neurons. * - Prerequisites: None, but only makes sense, when its called during the training phase. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWeights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method ResetCharges. * - Description: Resets the neuron's data received during iteration of net training. * - Purpose: Can be used by inner implementation for reset the neuron's data between iterations. * - Prerequisites: None, but only makes sense, when its called during the training phase. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetCharges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method AddMSE. * - Description: Changes MSE during the training phase. * - Purpose: Can be used by inner implementation for changing MSE during the training phase. * - Prerequisites: * @param inInd - a double amount of MSE to be add. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddMSE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inPortion )</span></span></span></span>{ mMeanSquaredError += inPortion; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method GetMSE. * - Description: Getter for MSE value. * - Purpose: Can be used by inner implementation for getting access to the MSE value. * - Prerequisites: None. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMSE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mMeanSquaredError; }; <span class="hljs-comment"><span class="hljs-comment">/** * Protected method ResetMSE. * - Description: Resets MSE value. * - Purpose: Can be used by inner implementation for resetting MSE value. * - Prerequisites: None. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetMSE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ mMeanSquaredError = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; NeuronFactory&lt;T&gt; * mNeuronFactory; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Member, which is responsible for creating neurons @see SetNeuronFactory */</span></span> TrainAlgorithm&lt;T&gt; * mTrainingAlgoritm; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Member, which is responsible for the way the network will trained @see SetAlgorithm */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt; &gt; mLayers; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Inner representation of neural networks */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Neuron&lt;T &gt; *&gt; mBiasLayer; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Container for biases */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mInputs, mOutputs, mHidden; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Number of inputs, outputs and hidden units */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mMeanSquaredError; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Mean Squared Error which is changing every iteration of the training*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mMinMSE; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; The biggest Mean Squared Error required for training to stop*/</span></span> };</code> </pre><br></div></div><br><br>  And finally, the interface itself of the class responsible for network training: <br><br><div class="spoiler">  <b class="spoiler_title">Learning algorithm interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NeuralNetwork</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrainAlgorithm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~TrainAlgorithm(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inTarget)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeightsInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hebb</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TrainAlgorithm&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Hebb(NeuralNetwork&lt;T&gt; * inNeuralNetwork) : mNeuralNetwork(inNeuralNetwork){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Hebb(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inTarget)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeightsInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: NeuralNetwork&lt;T&gt; * mNeuralNetwork; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backpropagation</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TrainAlgorithm&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Backpropagation(NeuralNetwork&lt;T&gt; * inNeuralNetwork); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Backpropagation(){}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; inTarget)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeightsInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NguyenWidrowWeightsInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommonInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; NeuralNetwork&lt;T&gt; * mNeuralNetwork; };</code> </pre><br></div></div><br><br>  All code is available on github: Sovietmade / NeuralNetworks <br><br>  As a conclusion, I would like to note that the topic of neural networks is not fully developed at the moment, again and again we see on the pages of Habr mention of new achievements of scientists in the field of neural networks, new amazing developments.  From my side, <br>  This article was the first step in the development of the most interesting technology, and I hope for someone it will be useful. <br><br><h5>  References: </h5><br>  The learning algorithm of the neural network was taken from an amazing book: <br>  Laurene V. Fausett ‚ÄúFundamentals of Neural Networks: Architects, Algorithms and Applications‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/198268/">https://habr.com/ru/post/198268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198252/index.html">Localization of Node.js applications Part 3: localization in action</a></li>
<li><a href="../198254/index.html">Only a few will be left.</a></li>
<li><a href="../198256/index.html">From the experience of creating a programming circle for children</a></li>
<li><a href="../198264/index.html">Prevent participation in dns amplification attack or experience in writing nuclear code</a></li>
<li><a href="../198266/index.html">Algorithm for finding paths in the maze</a></li>
<li><a href="../198270/index.html">Qt Meta System over Network. Part 1 - Properties</a></li>
<li><a href="../198272/index.html">Chelyabinsk meteorite: systematized photo and video materials</a></li>
<li><a href="../198274/index.html">Metaobject Protocol for Basic Perl 5</a></li>
<li><a href="../198276/index.html">Zabbix: Backing up a small base</a></li>
<li><a href="../198280/index.html">Babel and handlebars, it's time to make friends</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>